pub fn sub_82C3B868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3B868 size=144
    let mut pc: u32 = 0x82C3B868;
    'dispatch: loop {
        match pc {
            0x82C3B868 => {
    //   block [0x82C3B868..0x82C3B8A0)
	// 82C3B868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3B86C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3B870: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3B874: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3B878: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3B87C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3B880: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3B884: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C3B888: 388A4F7C  addi r4, r10, 0x4f7c
	ctx.r[4].s64 = ctx.r[10].s64 + 20348;
	// 82C3B88C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3B890: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3B894: 4E800421  bctrl
	ctx.lr = 0x82C3B898;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3B898: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3B89C: 409A001C  bne cr6, 0x82c3b8b8
	if !ctx.cr[6].eq {
	pc = 0x82C3B8B8; continue 'dispatch;
	}
            }
            0x82C3B8A0 => {
    //   block [0x82C3B8A0..0x82C3B8B8)
	// 82C3B8A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3B8A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3B8A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3B8AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3B8B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3B8B4: 4E800020  blr
	return;
            }
            0x82C3B8B8 => {
    //   block [0x82C3B8B8..0x82C3B8F8)
	// 82C3B8B8: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C3B8BC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C3B8C0: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C3B8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3B8C8: 4BFFD149  bl 0x82c38a10
	ctx.lr = 0x82C3B8CC;
	sub_82C38A10(ctx, base);
	// 82C3B8CC: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3B8D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3B8D4: 419AFFCC  beq cr6, 0x82c3b8a0
	if ctx.cr[6].eq {
	pc = 0x82C3B8A0; continue 'dispatch;
	}
	// 82C3B8D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3B8DC: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C3B8E0: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3B8E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3B8E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3B8EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3B8F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3B8F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3B8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3B8F8 size=76
    let mut pc: u32 = 0x82C3B8F8;
    'dispatch: loop {
        match pc {
            0x82C3B8F8 => {
    //   block [0x82C3B8F8..0x82C3B930)
	// 82C3B8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3B8FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3B900: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3B904: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C3B908: 4B5E3951  bl 0x8221f258
	ctx.lr = 0x82C3B90C;
	sub_8221F258(ctx, base);
	// 82C3B90C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3B910: 419A0020  beq cr6, 0x82c3b930
	if ctx.cr[6].eq {
	pc = 0x82C3B930; continue 'dispatch;
	}
	// 82C3B914: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3B918: 394BC1B0  addi r10, r11, -0x3e50
	ctx.r[10].s64 = ctx.r[11].s64 + -15952;
	// 82C3B91C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3B920: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3B924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3B928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3B92C: 4E800020  blr
	return;
            }
            0x82C3B930 => {
    //   block [0x82C3B930..0x82C3B944)
	// 82C3B930: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3B934: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3B938: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3B93C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3B940: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3B948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3B948 size=100
    let mut pc: u32 = 0x82C3B948;
    'dispatch: loop {
        match pc {
            0x82C3B948 => {
    //   block [0x82C3B948..0x82C3B970)
	// 82C3B948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3B94C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3B950: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3B954: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3B958: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3B95C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3B960: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3B964: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3B968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3B96C: 409A0028  bne cr6, 0x82c3b994
	if !ctx.cr[6].eq {
	pc = 0x82C3B994; continue 'dispatch;
	}
	pc = 0x82C3B970; continue 'dispatch;
            }
            0x82C3B970 => {
    //   block [0x82C3B970..0x82C3B994)
	// 82C3B970: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3B974: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3B978: 4BFFFFD1  bl 0x82c3b948
	ctx.lr = 0x82C3B97C;
	sub_82C3B948(ctx, base);
	// 82C3B97C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3B980: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3B984: 4BC09E2D  bl 0x828457b0
	ctx.lr = 0x82C3B988;
	sub_828457B0(ctx, base);
	// 82C3B988: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3B98C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3B990: 419AFFE0  beq cr6, 0x82c3b970
	if ctx.cr[6].eq {
	pc = 0x82C3B970; continue 'dispatch;
	}
	pc = 0x82C3B994; continue 'dispatch;
            }
            0x82C3B994 => {
    //   block [0x82C3B994..0x82C3B9AC)
	// 82C3B994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3B998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3B99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3B9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3B9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3B9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3B9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3B9B0 size=12
    let mut pc: u32 = 0x82C3B9B0;
    'dispatch: loop {
        match pc {
            0x82C3B9B0 => {
    //   block [0x82C3B9B0..0x82C3B9BC)
	// 82C3B9B0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C3B9B4: 386B4F7C  addi r3, r11, 0x4f7c
	ctx.r[3].s64 = ctx.r[11].s64 + 20348;
	// 82C3B9B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3B9C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3B9C0 size=124
    let mut pc: u32 = 0x82C3B9C0;
    'dispatch: loop {
        match pc {
            0x82C3B9C0 => {
    //   block [0x82C3B9C0..0x82C3BA18)
	// 82C3B9C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3B9C4: 4806DA49  bl 0x82ca940c
	ctx.lr = 0x82C3B9C8;
	sub_82CA93D0(ctx, base);
	// 82C3B9C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3B9CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3B9D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3B9D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3B9D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3B9DC: 388BAF70  addi r4, r11, -0x5090
	ctx.r[4].s64 = ctx.r[11].s64 + -20624;
	// 82C3B9E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3B9E4: 4BFCB7C5  bl 0x82c071a8
	ctx.lr = 0x82C3B9E8;
	sub_82C071A8(ctx, base);
	// 82C3B9E8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3B9EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3B9F0: 419A0028  beq cr6, 0x82c3ba18
	if ctx.cr[6].eq {
	pc = 0x82C3BA18; continue 'dispatch;
	}
	// 82C3B9F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3B9F8: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C3B9FC: 388BB430  addi r4, r11, -0x4bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -19408;
	// 82C3BA00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BA04: 4BFDF8B5  bl 0x82c1b2b8
	ctx.lr = 0x82C3BA08;
	sub_82C1B2B8(ctx, base);
	// 82C3BA08: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BA0C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C3BA10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BA14: 409A0008  bne cr6, 0x82c3ba1c
	if !ctx.cr[6].eq {
	pc = 0x82C3BA1C; continue 'dispatch;
	}
	pc = 0x82C3BA18; continue 'dispatch;
            }
            0x82C3BA18 => {
    //   block [0x82C3BA18..0x82C3BA1C)
	// 82C3BA18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C3BA1C; continue 'dispatch;
            }
            0x82C3BA1C => {
    //   block [0x82C3BA1C..0x82C3BA3C)
	// 82C3BA1C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82C3BA20: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C3BA24: 388B2304  addi r4, r11, 0x2304
	ctx.r[4].s64 = ctx.r[11].s64 + 8964;
	// 82C3BA28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BA2C: 4BFCB77D  bl 0x82c071a8
	ctx.lr = 0x82C3BA30;
	sub_82C071A8(ctx, base);
	// 82C3BA30: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3BA34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BA38: 4806DA24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BA40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BA40 size=152
    let mut pc: u32 = 0x82C3BA40;
    'dispatch: loop {
        match pc {
            0x82C3BA40 => {
    //   block [0x82C3BA40..0x82C3BA74)
	// 82C3BA40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BA44: 4806D9C1  bl 0x82ca9404
	ctx.lr = 0x82C3BA48;
	sub_82CA93D0(ctx, base);
	// 82C3BA48: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BA4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BA50: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BA54: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3BA58: 392BC1E0  addi r9, r11, -0x3e20
	ctx.r[9].s64 = ctx.r[11].s64 + -15904;
	// 82C3BA5C: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82C3BA60: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3BA64: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3BA68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BA6C: 4099003C  ble cr6, 0x82c3baa8
	if !ctx.cr[6].gt {
	pc = 0x82C3BAA8; continue 'dispatch;
	}
	// 82C3BA70: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82C3BA74; continue 'dispatch;
            }
            0x82C3BA74 => {
    //   block [0x82C3BA74..0x82C3BA94)
	// 82C3BA74: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BA78: 7FABF02E  lwzx r29, r11, r30
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82C3BA7C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3BA80: 419A0014  beq cr6, 0x82c3ba94
	if ctx.cr[6].eq {
	pc = 0x82C3BA94; continue 'dispatch;
	}
	// 82C3BA84: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 82C3BA88: 4B5D9351  bl 0x82214dd8
	ctx.lr = 0x82C3BA8C;
	sub_82214DD8(ctx, base);
	// 82C3BA8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3BA90: 4BC09D21  bl 0x828457b0
	ctx.lr = 0x82C3BA94;
	sub_828457B0(ctx, base);
	pc = 0x82C3BA94; continue 'dispatch;
            }
            0x82C3BA94 => {
    //   block [0x82C3BA94..0x82C3BAA8)
	// 82C3BA94: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3BA98: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C3BA9C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C3BAA0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3BAA4: 4198FFD0  blt cr6, 0x82c3ba74
	if ctx.cr[6].lt {
	pc = 0x82C3BA74; continue 'dispatch;
	}
	pc = 0x82C3BAA8; continue 'dispatch;
            }
            0x82C3BAA8 => {
    //   block [0x82C3BAA8..0x82C3BAD0)
	// 82C3BAA8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BAAC: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82C3BAB0: 394BB820  addi r10, r11, -0x47e0
	ctx.r[10].s64 = ctx.r[11].s64 + -18400;
	// 82C3BAB4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3BAB8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BABC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BAC0: 419A0010  beq cr6, 0x82c3bad0
	if ctx.cr[6].eq {
	pc = 0x82C3BAD0; continue 'dispatch;
	}
	// 82C3BAC4: 4BC09CED  bl 0x828457b0
	ctx.lr = 0x82C3BAC8;
	sub_828457B0(ctx, base);
	// 82C3BAC8: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C3BACC: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x82C3BAD0; continue 'dispatch;
            }
            0x82C3BAD0 => {
    //   block [0x82C3BAD0..0x82C3BAD8)
	// 82C3BAD0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3BAD4: 4806D980  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BAD8 size=80
    let mut pc: u32 = 0x82C3BAD8;
    'dispatch: loop {
        match pc {
            0x82C3BAD8 => {
    //   block [0x82C3BAD8..0x82C3BB10)
	// 82C3BAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BAE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3BAE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BAE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BAEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BAF0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3BAF4: 4BFFFF4D  bl 0x82c3ba40
	ctx.lr = 0x82C3BAF8;
	sub_82C3BA40(ctx, base);
	// 82C3BAF8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3BAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3BB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3BB04: 419A000C  beq cr6, 0x82c3bb10
	if ctx.cr[6].eq {
	pc = 0x82C3BB10; continue 'dispatch;
	}
	// 82C3BB08: 4BC09CA9  bl 0x828457b0
	ctx.lr = 0x82C3BB0C;
	sub_828457B0(ctx, base);
	// 82C3BB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3BB10; continue 'dispatch;
            }
            0x82C3BB10 => {
    //   block [0x82C3BB10..0x82C3BB28)
	// 82C3BB10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BB14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BB18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BB1C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3BB20: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BB24: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BB28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BB28 size=156
    let mut pc: u32 = 0x82C3BB28;
    'dispatch: loop {
        match pc {
            0x82C3BB28 => {
    //   block [0x82C3BB28..0x82C3BB60)
	// 82C3BB28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BB2C: 4806D8D9  bl 0x82ca9404
	ctx.lr = 0x82C3BB30;
	sub_82CA93D0(ctx, base);
	// 82C3BB30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BB34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BB38: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BB3C: 394BC1E4  addi r10, r11, -0x3e1c
	ctx.r[10].s64 = ctx.r[11].s64 + -15900;
	// 82C3BB40: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3BB44: 4BFEF2C5  bl 0x82c2ae08
	ctx.lr = 0x82C3BB48;
	sub_82C2AE08(ctx, base);
	// 82C3BB48: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3BB4C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3BB50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3BB54: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 82C3BB58: 4099003C  ble cr6, 0x82c3bb94
	if !ctx.cr[6].gt {
	pc = 0x82C3BB94; continue 'dispatch;
	}
	// 82C3BB5C: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	pc = 0x82C3BB60; continue 'dispatch;
            }
            0x82C3BB60 => {
    //   block [0x82C3BB60..0x82C3BB80)
	// 82C3BB60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BB64: 7FABF02E  lwzx r29, r11, r30
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82C3BB68: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3BB6C: 419A0014  beq cr6, 0x82c3bb80
	if ctx.cr[6].eq {
	pc = 0x82C3BB80; continue 'dispatch;
	}
	// 82C3BB70: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 82C3BB74: 4B5D9265  bl 0x82214dd8
	ctx.lr = 0x82C3BB78;
	sub_82214DD8(ctx, base);
	// 82C3BB78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3BB7C: 4BC09C35  bl 0x828457b0
	ctx.lr = 0x82C3BB80;
	sub_828457B0(ctx, base);
	pc = 0x82C3BB80; continue 'dispatch;
            }
            0x82C3BB80 => {
    //   block [0x82C3BB80..0x82C3BB94)
	// 82C3BB80: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3BB84: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C3BB88: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C3BB8C: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3BB90: 4198FFD0  blt cr6, 0x82c3bb60
	if ctx.cr[6].lt {
	pc = 0x82C3BB60; continue 'dispatch;
	}
	pc = 0x82C3BB94; continue 'dispatch;
            }
            0x82C3BB94 => {
    //   block [0x82C3BB94..0x82C3BBBC)
	// 82C3BB94: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BB98: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82C3BB9C: 394BB008  addi r10, r11, -0x4ff8
	ctx.r[10].s64 = ctx.r[11].s64 + -20472;
	// 82C3BBA0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3BBA4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BBA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BBAC: 419A0010  beq cr6, 0x82c3bbbc
	if ctx.cr[6].eq {
	pc = 0x82C3BBBC; continue 'dispatch;
	}
	// 82C3BBB0: 4BC09C01  bl 0x828457b0
	ctx.lr = 0x82C3BBB4;
	sub_828457B0(ctx, base);
	// 82C3BBB4: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C3BBB8: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	pc = 0x82C3BBBC; continue 'dispatch;
            }
            0x82C3BBBC => {
    //   block [0x82C3BBBC..0x82C3BBC4)
	// 82C3BBBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3BBC0: 4806D894  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BBC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BBC8 size=80
    let mut pc: u32 = 0x82C3BBC8;
    'dispatch: loop {
        match pc {
            0x82C3BBC8 => {
    //   block [0x82C3BBC8..0x82C3BC00)
	// 82C3BBC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BBCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BBD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3BBD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BBD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BBDC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BBE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3BBE4: 4BFFFF45  bl 0x82c3bb28
	ctx.lr = 0x82C3BBE8;
	sub_82C3BB28(ctx, base);
	// 82C3BBE8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3BBEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3BBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3BBF4: 419A000C  beq cr6, 0x82c3bc00
	if ctx.cr[6].eq {
	pc = 0x82C3BC00; continue 'dispatch;
	}
	// 82C3BBF8: 4BC09BB9  bl 0x828457b0
	ctx.lr = 0x82C3BBFC;
	sub_828457B0(ctx, base);
	// 82C3BBFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3BC00; continue 'dispatch;
            }
            0x82C3BC00 => {
    //   block [0x82C3BC00..0x82C3BC18)
	// 82C3BC00: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BC04: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BC08: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BC0C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3BC10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BC14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BC18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BC18 size=148
    let mut pc: u32 = 0x82C3BC18;
    'dispatch: loop {
        match pc {
            0x82C3BC18 => {
    //   block [0x82C3BC18..0x82C3BC8C)
	// 82C3BC18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BC1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BC20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3BC24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BC28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BC2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BC30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C3BC34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BC38: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C3BC3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3BC40: 4E800421  bctrl
	ctx.lr = 0x82C3BC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BC44: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BC48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3BC4C: 419A0040  beq cr6, 0x82c3bc8c
	if ctx.cr[6].eq {
	pc = 0x82C3BC8C; continue 'dispatch;
	}
	// 82C3BC50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3BC54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BC58: 4BFFFD69  bl 0x82c3b9c0
	ctx.lr = 0x82C3BC5C;
	sub_82C3B9C0(ctx, base);
	// 82C3BC5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BC60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3BC64: 419A0028  beq cr6, 0x82c3bc8c
	if ctx.cr[6].eq {
	pc = 0x82C3BC8C; continue 'dispatch;
	}
	// 82C3BC68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BC6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3BC70: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3BC74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3BC78: 4E800421  bctrl
	ctx.lr = 0x82C3BC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BC7C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BC80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C3BC84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3BC88: 409A0008  bne cr6, 0x82c3bc90
	if !ctx.cr[6].eq {
	pc = 0x82C3BC90; continue 'dispatch;
	}
            }
            0x82C3BC8C => {
    //   block [0x82C3BC8C..0x82C3BC90)
	// 82C3BC8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C3BC90; continue 'dispatch;
            }
            0x82C3BC90 => {
    //   block [0x82C3BC90..0x82C3BCAC)
	// 82C3BC90: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C3BC94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BC98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BC9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BCA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3BCA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BCA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3BCB0 size=12
    let mut pc: u32 = 0x82C3BCB0;
    'dispatch: loop {
        match pc {
            0x82C3BCB0 => {
    //   block [0x82C3BCB0..0x82C3BCBC)
	// 82C3BCB0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C3BCB4: 386B4F80  addi r3, r11, 0x4f80
	ctx.r[3].s64 = ctx.r[11].s64 + 20352;
	// 82C3BCB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BCC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BCC0 size=208
    let mut pc: u32 = 0x82C3BCC0;
    'dispatch: loop {
        match pc {
            0x82C3BCC0 => {
    //   block [0x82C3BCC0..0x82C3BD58)
	// 82C3BCC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BCC4: 4806D749  bl 0x82ca940c
	ctx.lr = 0x82C3BCC8;
	sub_82CA93D0(ctx, base);
	// 82C3BCC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BCCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BCD0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3BCD4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BCD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3BCDC: 388BB730  addi r4, r11, -0x48d0
	ctx.r[4].s64 = ctx.r[11].s64 + -18640;
	// 82C3BCE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BCE4: 4BFCB4C5  bl 0x82c071a8
	ctx.lr = 0x82C3BCE8;
	sub_82C071A8(ctx, base);
	// 82C3BCE8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BCEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BCF0: 419A0068  beq cr6, 0x82c3bd58
	if ctx.cr[6].eq {
	pc = 0x82C3BD58; continue 'dispatch;
	}
	// 82C3BCF4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BCF8: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C3BCFC: 388BC20C  addi r4, r11, -0x3df4
	ctx.r[4].s64 = ctx.r[11].s64 + -15860;
	// 82C3BD00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BD04: 4BFCB4A5  bl 0x82c071a8
	ctx.lr = 0x82C3BD08;
	sub_82C071A8(ctx, base);
	// 82C3BD08: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BD0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BD10: 419A0048  beq cr6, 0x82c3bd58
	if ctx.cr[6].eq {
	pc = 0x82C3BD58; continue 'dispatch;
	}
	// 82C3BD14: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BD18: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C3BD1C: 388BC134  addi r4, r11, -0x3ecc
	ctx.r[4].s64 = ctx.r[11].s64 + -16076;
	// 82C3BD20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BD24: 4BFCB485  bl 0x82c071a8
	ctx.lr = 0x82C3BD28;
	sub_82C071A8(ctx, base);
	// 82C3BD28: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BD2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BD30: 419A0028  beq cr6, 0x82c3bd58
	if ctx.cr[6].eq {
	pc = 0x82C3BD58; continue 'dispatch;
	}
	// 82C3BD34: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BD38: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82C3BD3C: 388BB710  addi r4, r11, -0x48f0
	ctx.r[4].s64 = ctx.r[11].s64 + -18672;
	// 82C3BD40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BD44: 4BFCB465  bl 0x82c071a8
	ctx.lr = 0x82C3BD48;
	sub_82C071A8(ctx, base);
	// 82C3BD48: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BD4C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C3BD50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3BD54: 409A0008  bne cr6, 0x82c3bd5c
	if !ctx.cr[6].eq {
	pc = 0x82C3BD5C; continue 'dispatch;
	}
	pc = 0x82C3BD58; continue 'dispatch;
            }
            0x82C3BD58 => {
    //   block [0x82C3BD58..0x82C3BD5C)
	// 82C3BD58: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C3BD5C; continue 'dispatch;
            }
            0x82C3BD5C => {
    //   block [0x82C3BD5C..0x82C3BD90)
	// 82C3BD5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3BD60: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82C3BD64: 388BC200  addi r4, r11, -0x3e00
	ctx.r[4].s64 = ctx.r[11].s64 + -15872;
	// 82C3BD68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BD6C: 4BFDF845  bl 0x82c1b5b0
	ctx.lr = 0x82C3BD70;
	sub_82C1B5B0(ctx, base);
	// 82C3BD70: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3BD74: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 82C3BD78: 388AC1F4  addi r4, r10, -0x3e0c
	ctx.r[4].s64 = ctx.r[10].s64 + -15884;
	// 82C3BD7C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BD80: 4BFDF831  bl 0x82c1b5b0
	ctx.lr = 0x82C3BD84;
	sub_82C1B5B0(ctx, base);
	// 82C3BD84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3BD88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BD8C: 4806D6D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BD90 size=148
    let mut pc: u32 = 0x82C3BD90;
    'dispatch: loop {
        match pc {
            0x82C3BD90 => {
    //   block [0x82C3BD90..0x82C3BE04)
	// 82C3BD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BD94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BD98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3BD9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BDA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BDA4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BDA8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C3BDAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BDB0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C3BDB4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3BDB8: 4E800421  bctrl
	ctx.lr = 0x82C3BDBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BDBC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BDC0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3BDC4: 419A0040  beq cr6, 0x82c3be04
	if ctx.cr[6].eq {
	pc = 0x82C3BE04; continue 'dispatch;
	}
	// 82C3BDC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3BDCC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3BDD0: 4BFFFEF1  bl 0x82c3bcc0
	ctx.lr = 0x82C3BDD4;
	sub_82C3BCC0(ctx, base);
	// 82C3BDD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BDD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3BDDC: 419A0028  beq cr6, 0x82c3be04
	if ctx.cr[6].eq {
	pc = 0x82C3BE04; continue 'dispatch;
	}
	// 82C3BDE0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3BDE8: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3BDEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3BDF0: 4E800421  bctrl
	ctx.lr = 0x82C3BDF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BDF4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3BDF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C3BDFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3BE00: 409A0008  bne cr6, 0x82c3be08
	if !ctx.cr[6].eq {
	pc = 0x82C3BE08; continue 'dispatch;
	}
            }
            0x82C3BE04 => {
    //   block [0x82C3BE04..0x82C3BE08)
	// 82C3BE04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C3BE08; continue 'dispatch;
            }
            0x82C3BE08 => {
    //   block [0x82C3BE08..0x82C3BE24)
	// 82C3BE08: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C3BE0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3BE10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BE14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BE18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3BE1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BE20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BE28 size=168
    let mut pc: u32 = 0x82C3BE28;
    'dispatch: loop {
        match pc {
            0x82C3BE28 => {
    //   block [0x82C3BE28..0x82C3BE78)
	// 82C3BE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BE2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BE30: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BE34: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C3BE38: 409A0040  bne cr6, 0x82c3be78
	if !ctx.cr[6].eq {
	pc = 0x82C3BE78; continue 'dispatch;
	}
	// 82C3BE3C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C3BE40: 4B5E3419  bl 0x8221f258
	ctx.lr = 0x82C3BE44;
	sub_8221F258(ctx, base);
	// 82C3BE44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BE48: 419A0074  beq cr6, 0x82c3bebc
	if ctx.cr[6].eq {
	pc = 0x82C3BEBC; continue 'dispatch;
	}
	// 82C3BE4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3BE50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3BE54: 392AC1D4  addi r9, r10, -0x3e2c
	ctx.r[9].s64 = ctx.r[10].s64 + -15916;
	// 82C3BE58: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3BE5C: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3BE60: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3BE64: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3BE68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BE6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BE70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BE74: 4E800020  blr
	return;
            }
            0x82C3BE78 => {
    //   block [0x82C3BE78..0x82C3BEBC)
	// 82C3BE78: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82C3BE7C: 409A0040  bne cr6, 0x82c3bebc
	if !ctx.cr[6].eq {
	pc = 0x82C3BEBC; continue 'dispatch;
	}
	// 82C3BE80: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C3BE84: 4B5E33D5  bl 0x8221f258
	ctx.lr = 0x82C3BE88;
	sub_8221F258(ctx, base);
	// 82C3BE88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BE8C: 419A0030  beq cr6, 0x82c3bebc
	if ctx.cr[6].eq {
	pc = 0x82C3BEBC; continue 'dispatch;
	}
	// 82C3BE90: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3BE94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3BE98: 392AC1E8  addi r9, r10, -0x3e18
	ctx.r[9].s64 = ctx.r[10].s64 + -15896;
	// 82C3BE9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3BEA0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3BEA4: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3BEA8: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3BEAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BEB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BEB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BEB8: 4E800020  blr
	return;
            }
            0x82C3BEBC => {
    //   block [0x82C3BEBC..0x82C3BED0)
	// 82C3BEBC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3BEC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BEC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BEC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BECC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BED0 size=112
    let mut pc: u32 = 0x82C3BED0;
    'dispatch: loop {
        match pc {
            0x82C3BED0 => {
    //   block [0x82C3BED0..0x82C3BF04)
	// 82C3BED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BED8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BEDC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BEE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3BEE4: 4BFFF985  bl 0x82c3b868
	ctx.lr = 0x82C3BEE8;
	sub_82C3B868(ctx, base);
	// 82C3BEE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BEEC: 409A0018  bne cr6, 0x82c3bf04
	if !ctx.cr[6].eq {
	pc = 0x82C3BF04; continue 'dispatch;
	}
	// 82C3BEF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BEF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BEF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BEFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BF00: 4E800020  blr
	return;
            }
            0x82C3BF04 => {
    //   block [0x82C3BF04..0x82C3BF40)
	// 82C3BF04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BF08: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3BF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3BF10: 388A4F80  addi r4, r10, 0x4f80
	ctx.r[4].s64 = ctx.r[10].s64 + 20352;
	// 82C3BF14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BF18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3BF1C: 4E800421  bctrl
	ctx.lr = 0x82C3BF20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BF20: 7C680034  cntlzw r8, r3
	ctx.r[8].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C3BF24: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C3BF28: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 82C3BF2C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BF30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BF34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BF38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BF3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BF40 size=112
    let mut pc: u32 = 0x82C3BF40;
    'dispatch: loop {
        match pc {
            0x82C3BF40 => {
    //   block [0x82C3BF40..0x82C3BF8C)
	// 82C3BF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BF4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BF50: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BF54: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3BF58: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3BF5C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C3BF60: 388A4F7C  addi r4, r10, 0x4f7c
	ctx.r[4].s64 = ctx.r[10].s64 + 20348;
	// 82C3BF64: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BF68: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3BF6C: 4E800421  bctrl
	ctx.lr = 0x82C3BF70;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3BF70: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3BF74: 409A0018  bne cr6, 0x82c3bf8c
	if !ctx.cr[6].eq {
	pc = 0x82C3BF8C; continue 'dispatch;
	}
	// 82C3BF78: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BF7C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BF80: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BF84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BF88: 4E800020  blr
	return;
            }
            0x82C3BF8C => {
    //   block [0x82C3BF8C..0x82C3BFB0)
	// 82C3BF8C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BF90: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C3BF94: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C3BF98: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3BF9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BFA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BFA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BFA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3BFAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3BFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3BFB0 size=84
    let mut pc: u32 = 0x82C3BFB0;
    'dispatch: loop {
        match pc {
            0x82C3BFB0 => {
    //   block [0x82C3BFB0..0x82C3C004)
	// 82C3BFB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3BFB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3BFB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3BFBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3BFC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3BFC4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BFC8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BFCC: 4BFFF97D  bl 0x82c3b948
	ctx.lr = 0x82C3BFD0;
	sub_82C3B948(ctx, base);
	// 82C3BFD0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BFD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3BFD8: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3BFDC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BFE0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3BFE4: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C3BFE8: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3BFEC: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C3BFF0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3BFF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3BFF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3BFFC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3C000: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C008 size=876
    let mut pc: u32 = 0x82C3C008;
    'dispatch: loop {
        match pc {
            0x82C3C008 => {
    //   block [0x82C3C008..0x82C3C078)
	// 82C3C008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C00C: 4806D3F1  bl 0x82ca93fc
	ctx.lr = 0x82C3C010;
	sub_82CA93D0(ctx, base);
	// 82C3C010: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C014: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3C018: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C3C01C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C020: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C024: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C028: 4E800421  bctrl
	ctx.lr = 0x82C3C02C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C02C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C030: 41980138  blt cr6, 0x82c3c168
	if ctx.cr[6].lt {
	pc = 0x82C3C168; continue 'dispatch;
	}
	// 82C3C034: 409A0298  bne cr6, 0x82c3c2cc
	if !ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C038: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C03C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C040: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3C044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C048: 4E800421  bctrl
	ctx.lr = 0x82C3C04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C04C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C050: 41980068  blt cr6, 0x82c3c0b8
	if ctx.cr[6].lt {
	pc = 0x82C3C0B8; continue 'dispatch;
	}
	// 82C3C054: 409A0278  bne cr6, 0x82c3c2cc
	if !ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C058: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C05C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3C060: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C3C064: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C068: 40990300  ble cr6, 0x82c3c368
	if !ctx.cr[6].gt {
	pc = 0x82C3C368; continue 'dispatch;
	}
	// 82C3C06C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C070: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3C074: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3C078 => {
    //   block [0x82C3C078..0x82C3C0B8)
	// 82C3C078: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C07C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C080: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C084: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3C088: 4BFFFB91  bl 0x82c3bc18
	ctx.lr = 0x82C3C08C;
	sub_82C3BC18(ctx, base);
	// 82C3C08C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C090: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3C094: 419A0238  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C098: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C09C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3C0A0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3C0A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C0A8: 4198FFD0  blt cr6, 0x82c3c078
	if ctx.cr[6].lt {
	pc = 0x82C3C078; continue 'dispatch;
	}
	// 82C3C0AC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C0B0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3C0B4: 4806D398  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C0B8 => {
    //   block [0x82C3C0B8..0x82C3C0FC)
	// 82C3C0B8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C0BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C0C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3C0C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C0C8: 4E800421  bctrl
	ctx.lr = 0x82C3C0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C0CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C0D0: 3B6B5D98  addi r27, r11, 0x5d98
	ctx.r[27].s64 = ctx.r[11].s64 + 23960;
	// 82C3C0D4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3C0D8: 4BFCCAE1  bl 0x82c08bb8
	ctx.lr = 0x82C3C0DC;
	sub_82C08BB8(ctx, base);
	// 82C3C0DC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C3C0E0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C0E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C0E8: 4BFEA1B9  bl 0x82c262a0
	ctx.lr = 0x82C3C0EC;
	sub_82C262A0(ctx, base);
	// 82C3C0EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3C0F0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3C0F4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C3C0F8: 419A0270  beq cr6, 0x82c3c368
	if ctx.cr[6].eq {
	pc = 0x82C3C368; continue 'dispatch;
	}
            }
            0x82C3C0FC => {
    //   block [0x82C3C0FC..0x82C3C124)
	// 82C3C0FC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C3C100: 4B5E3159  bl 0x8221f258
	ctx.lr = 0x82C3C104;
	sub_8221F258(ctx, base);
	// 82C3C104: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C108: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C3C10C: 419A0018  beq cr6, 0x82c3c124
	if ctx.cr[6].eq {
	pc = 0x82C3C124; continue 'dispatch;
	}
	// 82C3C110: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3C114: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C3C118: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3C11C: 4B5BB6E5  bl 0x821f7800
	ctx.lr = 0x82C3C120;
	sub_821F7800(ctx, base);
	// 82C3C120: 48000008  b 0x82c3c128
	pc = 0x82C3C128; continue 'dispatch;
            }
            0x82C3C124 => {
    //   block [0x82C3C124..0x82C3C128)
	// 82C3C124: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82C3C128; continue 'dispatch;
            }
            0x82C3C128 => {
    //   block [0x82C3C128..0x82C3C168)
	// 82C3C128: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3C12C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3C130: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C134: 4BFFFAE5  bl 0x82c3bc18
	ctx.lr = 0x82C3C138;
	sub_82C3BC18(ctx, base);
	// 82C3C138: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C13C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C140: 419A018C  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C148: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C14C: 4BFEA59D  bl 0x82c266e8
	ctx.lr = 0x82C3C150;
	sub_82C266E8(ctx, base);
	// 82C3C150: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3C154: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C3C158: 4198FFA4  blt cr6, 0x82c3c0fc
	if ctx.cr[6].lt {
	pc = 0x82C3C0FC; continue 'dispatch;
	}
	// 82C3C15C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C160: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3C164: 4806D2E8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C168 => {
    //   block [0x82C3C168..0x82C3C1E8)
	// 82C3C168: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C16C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C170: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3C174: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C178: 4E800421  bctrl
	ctx.lr = 0x82C3C17C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C17C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C180: 419800A8  blt cr6, 0x82c3c228
	if ctx.cr[6].lt {
	pc = 0x82C3C228; continue 'dispatch;
	}
	// 82C3C184: 409A0148  bne cr6, 0x82c3c2cc
	if !ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C188: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C18C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C190: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C194: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C198: 4E800421  bctrl
	ctx.lr = 0x82C3C19C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C19C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C1A0: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C1A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3C1A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C1AC: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3C1B0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3C1B4: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C3C1B8: 4E800421  bctrl
	ctx.lr = 0x82C3C1BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C1BC: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C1C0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3C1C4: 419A0108  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C1C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C1CC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3C1D0: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82C3C1D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C1D8: 419A0190  beq cr6, 0x82c3c368
	if ctx.cr[6].eq {
	pc = 0x82C3C368; continue 'dispatch;
	}
	// 82C3C1DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C1E0: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3C1E4: 3BCB5D98  addi r30, r11, 0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3C1E8 => {
    //   block [0x82C3C1E8..0x82C3C228)
	// 82C3C1E8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C1EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3C1F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C1F4: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3C1F8: 4BFFFA21  bl 0x82c3bc18
	ctx.lr = 0x82C3C1FC;
	sub_82C3BC18(ctx, base);
	// 82C3C1FC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C200: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3C204: 419A00C8  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C208: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C20C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C3C210: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3C214: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C218: 4198FFD0  blt cr6, 0x82c3c1e8
	if ctx.cr[6].lt {
	pc = 0x82C3C1E8; continue 'dispatch;
	}
	// 82C3C21C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C220: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3C224: 4806D228  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C228 => {
    //   block [0x82C3C228..0x82C3C2CC)
	// 82C3C228: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C22C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C230: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C234: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C238: 4E800421  bctrl
	ctx.lr = 0x82C3C23C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C23C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C244: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3C248: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C24C: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3C250: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3C254: 4E800421  bctrl
	ctx.lr = 0x82C3C258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C258: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C25C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C3C260: 419A006C  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C264: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C268: 4BFCBAB9  bl 0x82c07d20
	ctx.lr = 0x82C3C26C;
	sub_82C07D20(ctx, base);
	// 82C3C26C: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C270: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C3C274: 40990064  ble cr6, 0x82c3c2d8
	if !ctx.cr[6].gt {
	pc = 0x82C3C2D8; continue 'dispatch;
	}
	// 82C3C278: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C27C: 4BFCBAA5  bl 0x82c07d20
	ctx.lr = 0x82C3C280;
	sub_82C07D20(ctx, base);
	// 82C3C280: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C284: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3C288: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C28C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C3C290: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3C294: 3BAAB0E8  addi r29, r10, -0x4f18
	ctx.r[29].s64 = ctx.r[10].s64 + -20248;
	// 82C3C298: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C3C29C: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C3C2A0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C2A4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3C2A8: 4E800421  bctrl
	ctx.lr = 0x82C3C2AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C2AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3C2B0: 4BFC9549  bl 0x82c057f8
	ctx.lr = 0x82C3C2B4;
	sub_82C057F8(ctx, base);
	// 82C3C2B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C2B8: 4BFC95B1  bl 0x82c05868
	ctx.lr = 0x82C3C2BC;
	sub_82C05868(ctx, base);
	// 82C3C2BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C2C0: 4BFC9539  bl 0x82c057f8
	ctx.lr = 0x82C3C2C4;
	sub_82C057F8(ctx, base);
	// 82C3C2C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3C2C8: 4BFC95A1  bl 0x82c05868
	ctx.lr = 0x82C3C2CC;
	sub_82C05868(ctx, base);
            }
            0x82C3C2CC => {
    //   block [0x82C3C2CC..0x82C3C2D8)
	// 82C3C2CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3C2D0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3C2D4: 4806D178  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C2D8 => {
    //   block [0x82C3C2D8..0x82C3C304)
	// 82C3C2D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C2DC: 4BFE9FC5  bl 0x82c262a0
	ctx.lr = 0x82C3C2E0;
	sub_82C262A0(ctx, base);
	// 82C3C2E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C2E8: 419A0080  beq cr6, 0x82c3c368
	if ctx.cr[6].eq {
	pc = 0x82C3C368; continue 'dispatch;
	}
	// 82C3C2EC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3C2F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C2F4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C3C2F8: 419A0070  beq cr6, 0x82c3c368
	if ctx.cr[6].eq {
	pc = 0x82C3C368; continue 'dispatch;
	}
	// 82C3C2FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C300: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
	pc = 0x82C3C304; continue 'dispatch;
            }
            0x82C3C304 => {
    //   block [0x82C3C304..0x82C3C32C)
	// 82C3C304: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C3C308: 4B5E2F51  bl 0x8221f258
	ctx.lr = 0x82C3C30C;
	sub_8221F258(ctx, base);
	// 82C3C30C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C310: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C3C314: 419A0018  beq cr6, 0x82c3c32c
	if ctx.cr[6].eq {
	pc = 0x82C3C32C; continue 'dispatch;
	}
	// 82C3C318: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3C31C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 82C3C320: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3C324: 4B5BB4DD  bl 0x821f7800
	ctx.lr = 0x82C3C328;
	sub_821F7800(ctx, base);
	// 82C3C328: 48000008  b 0x82c3c330
	pc = 0x82C3C330; continue 'dispatch;
            }
            0x82C3C32C => {
    //   block [0x82C3C32C..0x82C3C330)
	// 82C3C32C: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82C3C330; continue 'dispatch;
            }
            0x82C3C330 => {
    //   block [0x82C3C330..0x82C3C368)
	// 82C3C330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C334: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3C338: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3C33C: 4BFFF8DD  bl 0x82c3bc18
	ctx.lr = 0x82C3C340;
	sub_82C3BC18(ctx, base);
	// 82C3C340: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C348: 419AFF84  beq cr6, 0x82c3c2cc
	if ctx.cr[6].eq {
	pc = 0x82C3C2CC; continue 'dispatch;
	}
	// 82C3C34C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C350: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C354: 4BFEA395  bl 0x82c266e8
	ctx.lr = 0x82C3C358;
	sub_82C266E8(ctx, base);
	// 82C3C358: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C35C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3C360: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C364: 4198FFA0  blt cr6, 0x82c3c304
	if ctx.cr[6].lt {
	pc = 0x82C3C304; continue 'dispatch;
	}
	pc = 0x82C3C368; continue 'dispatch;
            }
            0x82C3C368 => {
    //   block [0x82C3C368..0x82C3C374)
	// 82C3C368: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C36C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3C370: 4806D0DC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3C378 size=968
    let mut pc: u32 = 0x82C3C378;
    'dispatch: loop {
        match pc {
            0x82C3C378 => {
    //   block [0x82C3C378..0x82C3C3EC)
	// 82C3C378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C37C: 4806D081  bl 0x82ca93fc
	ctx.lr = 0x82C3C380;
	sub_82CA93D0(ctx, base);
	// 82C3C380: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 82C3C384: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82C3C388: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C38C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C3C390: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C3C394: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C398: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C39C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C3A0: 4E800421  bctrl
	ctx.lr = 0x82C3C3A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C3A4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C3A8: 4198015C  blt cr6, 0x82c3c504
	if ctx.cr[6].lt {
	pc = 0x82C3C504; continue 'dispatch;
	}
	// 82C3C3AC: 409A02C4  bne cr6, 0x82c3c670
	if !ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C3B0: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C3B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C3B8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3C3BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C3C0: 4E800421  bctrl
	ctx.lr = 0x82C3C3C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C3C4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C3C8: 4198006C  blt cr6, 0x82c3c434
	if ctx.cr[6].lt {
	pc = 0x82C3C434; continue 'dispatch;
	}
	// 82C3C3CC: 409A02A4  bne cr6, 0x82c3c670
	if !ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C3D0: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C3D4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3C3D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C3DC: 40990350  ble cr6, 0x82c3c72c
	if !ctx.cr[6].gt {
	pc = 0x82C3C72C; continue 'dispatch;
	}
	// 82C3C3E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C3E4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C3C3E8: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3C3EC => {
    //   block [0x82C3C3EC..0x82C3C434)
	// 82C3C3EC: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C3F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C3F4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C3F8: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3C3FC: 4BFFF995  bl 0x82c3bd90
	ctx.lr = 0x82C3C400;
	sub_82C3BD90(ctx, base);
	// 82C3C400: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C404: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3C408: 419A0268  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C40C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C410: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3C414: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3C418: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C41C: 4198FFD0  blt cr6, 0x82c3c3ec
	if ctx.cr[6].lt {
	pc = 0x82C3C3EC; continue 'dispatch;
	}
	// 82C3C420: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C424: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3C428: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C3C42C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3C430: 4806D01C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C434 => {
    //   block [0x82C3C434..0x82C3C488)
	// 82C3C434: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C438: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C43C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3C440: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C444: 4E800421  bctrl
	ctx.lr = 0x82C3C448;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C448: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C44C: 3B4B5D98  addi r26, r11, 0x5d98
	ctx.r[26].s64 = ctx.r[11].s64 + 23960;
	// 82C3C450: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C3C454: 4BFCC765  bl 0x82c08bb8
	ctx.lr = 0x82C3C458;
	sub_82C08BB8(ctx, base);
	// 82C3C458: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3C45C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C460: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3C464: 4BFE9E3D  bl 0x82c262a0
	ctx.lr = 0x82C3C468;
	sub_82C262A0(ctx, base);
	// 82C3C468: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3C46C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C3C470: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82C3C474: 419A02B8  beq cr6, 0x82c3c72c
	if ctx.cr[6].eq {
	pc = 0x82C3C72C; continue 'dispatch;
	}
	// 82C3C478: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C3C47C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82C3C480: C3CB0AEC  lfs f30, 0xaec(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(2796 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C3C484: C3EABE10  lfs f31, -0x41f0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x82C3C488 => {
    //   block [0x82C3C488..0x82C3C4B8)
	// 82C3C488: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82C3C48C: 4B5E2DCD  bl 0x8221f258
	ctx.lr = 0x82C3C490;
	sub_8221F258(ctx, base);
	// 82C3C490: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3C494: 419A0024  beq cr6, 0x82c3c4b8
	if ctx.cr[6].eq {
	pc = 0x82C3C4B8; continue 'dispatch;
	}
	// 82C3C498: D3E30010  stfs f31, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C3C49C: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C3C4A0: D3C30014  stfs f30, 0x14(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C3C4A4: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C3C4A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C4AC: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C3C4B0: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C3C4B4: 48000008  b 0x82c3c4bc
	pc = 0x82C3C4BC; continue 'dispatch;
            }
            0x82C3C4B8 => {
    //   block [0x82C3C4B8..0x82C3C4BC)
	// 82C3C4B8: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x82C3C4BC; continue 'dispatch;
            }
            0x82C3C4BC => {
    //   block [0x82C3C4BC..0x82C3C504)
	// 82C3C4BC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C3C4C0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3C4C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C4C8: 4BFFF8C9  bl 0x82c3bd90
	ctx.lr = 0x82C3C4CC;
	sub_82C3BD90(ctx, base);
	// 82C3C4CC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C4D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C4D4: 419A019C  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C4D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C4DC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C4E0: 4BFEA209  bl 0x82c266e8
	ctx.lr = 0x82C3C4E4;
	sub_82C266E8(ctx, base);
	// 82C3C4E4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C3C4E8: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C3C4EC: 4198FF9C  blt cr6, 0x82c3c488
	if ctx.cr[6].lt {
	pc = 0x82C3C488; continue 'dispatch;
	}
	// 82C3C4F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C4F4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3C4F8: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C3C4FC: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3C500: 4806CF4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C504 => {
    //   block [0x82C3C504..0x82C3C584)
	// 82C3C504: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C508: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C50C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3C510: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C514: 4E800421  bctrl
	ctx.lr = 0x82C3C518;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C518: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3C51C: 419800B0  blt cr6, 0x82c3c5cc
	if ctx.cr[6].lt {
	pc = 0x82C3C5CC; continue 'dispatch;
	}
	// 82C3C520: 409A0150  bne cr6, 0x82c3c670
	if !ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C524: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C528: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C52C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C530: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C534: 4E800421  bctrl
	ctx.lr = 0x82C3C538;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C538: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C53C: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C540: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3C544: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C548: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3C54C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3C550: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C3C554: 4E800421  bctrl
	ctx.lr = 0x82C3C558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C558: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C55C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3C560: 419A0110  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C564: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C568: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3C56C: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82C3C570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C574: 419A01B8  beq cr6, 0x82c3c72c
	if ctx.cr[6].eq {
	pc = 0x82C3C72C; continue 'dispatch;
	}
	// 82C3C578: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C57C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82C3C580: 3BCB5D98  addi r30, r11, 0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3C584 => {
    //   block [0x82C3C584..0x82C3C5CC)
	// 82C3C584: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3C58C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C590: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3C594: 4BFFF7FD  bl 0x82c3bd90
	ctx.lr = 0x82C3C598;
	sub_82C3BD90(ctx, base);
	// 82C3C598: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C59C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3C5A0: 419A00D0  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C5A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C5A8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C3C5AC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3C5B0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C5B4: 4198FFD0  blt cr6, 0x82c3c584
	if ctx.cr[6].lt {
	pc = 0x82C3C584; continue 'dispatch;
	}
	// 82C3C5B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C5BC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3C5C0: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C3C5C4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3C5C8: 4806CE84  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C5CC => {
    //   block [0x82C3C5CC..0x82C3C670)
	// 82C3C5CC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C5D0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C5D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C5D8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C5DC: 4E800421  bctrl
	ctx.lr = 0x82C3C5E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C5E0: 813B0000  lwz r9, 0(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C5E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C5E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3C5EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C5F0: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3C5F4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3C5F8: 4E800421  bctrl
	ctx.lr = 0x82C3C5FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C5FC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C600: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C3C604: 419A006C  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C60C: 4BFCB715  bl 0x82c07d20
	ctx.lr = 0x82C3C610;
	sub_82C07D20(ctx, base);
	// 82C3C610: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C614: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C3C618: 4099006C  ble cr6, 0x82c3c684
	if !ctx.cr[6].gt {
	pc = 0x82C3C684; continue 'dispatch;
	}
	// 82C3C61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C620: 4BFCB701  bl 0x82c07d20
	ctx.lr = 0x82C3C624;
	sub_82C07D20(ctx, base);
	// 82C3C624: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C628: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3C62C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C630: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C3C634: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3C638: 3BAAB0E8  addi r29, r10, -0x4f18
	ctx.r[29].s64 = ctx.r[10].s64 + -20248;
	// 82C3C63C: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C3C640: 3B89B0C8  addi r28, r9, -0x4f38
	ctx.r[28].s64 = ctx.r[9].s64 + -20280;
	// 82C3C644: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C648: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3C64C: 4E800421  bctrl
	ctx.lr = 0x82C3C650;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3C650: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3C654: 4BFC91A5  bl 0x82c057f8
	ctx.lr = 0x82C3C658;
	sub_82C057F8(ctx, base);
	// 82C3C658: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C65C: 4BFC920D  bl 0x82c05868
	ctx.lr = 0x82C3C660;
	sub_82C05868(ctx, base);
	// 82C3C660: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3C664: 4BFC9195  bl 0x82c057f8
	ctx.lr = 0x82C3C668;
	sub_82C057F8(ctx, base);
	// 82C3C668: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3C66C: 4BFC91FD  bl 0x82c05868
	ctx.lr = 0x82C3C670;
	sub_82C05868(ctx, base);
            }
            0x82C3C670 => {
    //   block [0x82C3C670..0x82C3C684)
	// 82C3C670: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3C674: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3C678: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C3C67C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3C680: 4806CDCC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3C684 => {
    //   block [0x82C3C684..0x82C3C6C0)
	// 82C3C684: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C688: 4BFE9C19  bl 0x82c262a0
	ctx.lr = 0x82C3C68C;
	sub_82C262A0(ctx, base);
	// 82C3C68C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C694: 419A0098  beq cr6, 0x82c3c72c
	if ctx.cr[6].eq {
	pc = 0x82C3C72C; continue 'dispatch;
	}
	// 82C3C698: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3C69C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C6A0: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 82C3C6A4: 419A0088  beq cr6, 0x82c3c72c
	if ctx.cr[6].eq {
	pc = 0x82C3C72C; continue 'dispatch;
	}
	// 82C3C6A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C3C6AC: 3D208204  lis r9, -0x7dfc
	ctx.r[9].s64 = -2113667072;
	// 82C3C6B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3C6B4: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
	// 82C3C6B8: C3CA0AEC  lfs f30, 0xaec(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2796 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C3C6BC: C3E9BE10  lfs f31, -0x41f0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16880 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82C3C6C0; continue 'dispatch;
            }
            0x82C3C6C0 => {
    //   block [0x82C3C6C0..0x82C3C6F0)
	// 82C3C6C0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82C3C6C4: 4B5E2B95  bl 0x8221f258
	ctx.lr = 0x82C3C6C8;
	sub_8221F258(ctx, base);
	// 82C3C6C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3C6CC: 419A0024  beq cr6, 0x82c3c6f0
	if ctx.cr[6].eq {
	pc = 0x82C3C6F0; continue 'dispatch;
	}
	// 82C3C6D0: D3E30010  stfs f31, 0x10(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C3C6D4: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C3C6D8: D3C30014  stfs f30, 0x14(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C3C6DC: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C3C6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C6E4: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C3C6E8: 93C3000C  stw r30, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C3C6EC: 48000008  b 0x82c3c6f4
	pc = 0x82C3C6F4; continue 'dispatch;
            }
            0x82C3C6F0 => {
    //   block [0x82C3C6F0..0x82C3C6F4)
	// 82C3C6F0: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	pc = 0x82C3C6F4; continue 'dispatch;
            }
            0x82C3C6F4 => {
    //   block [0x82C3C6F4..0x82C3C72C)
	// 82C3C6F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3C6F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3C6FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C700: 4BFFF691  bl 0x82c3bd90
	ctx.lr = 0x82C3C704;
	sub_82C3BD90(ctx, base);
	// 82C3C704: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3C708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C70C: 419AFF64  beq cr6, 0x82c3c670
	if ctx.cr[6].eq {
	pc = 0x82C3C670; continue 'dispatch;
	}
	// 82C3C710: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3C714: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3C718: 4BFE9FD1  bl 0x82c266e8
	ctx.lr = 0x82C3C71C;
	sub_82C266E8(ctx, base);
	// 82C3C71C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3C720: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C3C724: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3C728: 4198FF98  blt cr6, 0x82c3c6c0
	if ctx.cr[6].lt {
	pc = 0x82C3C6C0; continue 'dispatch;
	}
	pc = 0x82C3C72C; continue 'dispatch;
            }
            0x82C3C72C => {
    //   block [0x82C3C72C..0x82C3C740)
	// 82C3C72C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3C730: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3C734: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82C3C738: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3C73C: 4806CD10  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C740 size=136
    let mut pc: u32 = 0x82C3C740;
    'dispatch: loop {
        match pc {
            0x82C3C740 => {
    //   block [0x82C3C740..0x82C3C76C)
	// 82C3C740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3C748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3C74C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C750: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C754: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C3C758: 4B5E2B01  bl 0x8221f258
	ctx.lr = 0x82C3C75C;
	sub_8221F258(ctx, base);
	// 82C3C75C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3C760: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3C764: 419A0008  beq cr6, 0x82c3c76c
	if ctx.cr[6].eq {
	pc = 0x82C3C76C; continue 'dispatch;
	}
	// 82C3C768: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3C76C; continue 'dispatch;
            }
            0x82C3C76C => {
    //   block [0x82C3C76C..0x82C3C778)
	// 82C3C76C: 35430004  addic. r10, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C3C770: 41820008  beq 0x82c3c778
	if ctx.cr[0].eq {
	pc = 0x82C3C778; continue 'dispatch;
	}
	// 82C3C774: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3C778; continue 'dispatch;
            }
            0x82C3C778 => {
    //   block [0x82C3C778..0x82C3C784)
	// 82C3C778: 35430008  addic. r10, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[10].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82C3C77C: 41820008  beq 0x82c3c784
	if ctx.cr[0].eq {
	pc = 0x82C3C784; continue 'dispatch;
	}
	// 82C3C780: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3C784; continue 'dispatch;
            }
            0x82C3C784 => {
    //   block [0x82C3C784..0x82C3C7C8)
	// 82C3C784: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C3C788: 9963001D  stb r11, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[11].u8 ) };
	// 82C3C78C: 9943001C  stb r10, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82C3C790: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C3C794: 9943001D  stb r10, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[10].u8 ) };
	// 82C3C798: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C79C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3C7A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C7A4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3C7A8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C7AC: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C3C7B0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3C7B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3C7B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3C7BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3C7C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3C7C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C7C8 size=128
    let mut pc: u32 = 0x82C3C7C8;
    'dispatch: loop {
        match pc {
            0x82C3C7C8 => {
    //   block [0x82C3C7C8..0x82C3C7F0)
	// 82C3C7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C7CC: 4806CC39  bl 0x82ca9404
	ctx.lr = 0x82C3C7D0;
	sub_82CA93D0(ctx, base);
	// 82C3C7D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C7D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3C7D8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C3C7DC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 82C3C7E0: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3C7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C7E8: 409A0058  bne cr6, 0x82c3c840
	if !ctx.cr[6].eq {
	pc = 0x82C3C840; continue 'dispatch;
	}
	// 82C3C7EC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82C3C7F0; continue 'dispatch;
            }
            0x82C3C7F0 => {
    //   block [0x82C3C7F0..0x82C3C820)
	// 82C3C7F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3C7F4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3C7F8: 4BFFFFD1  bl 0x82c3c7c8
	ctx.lr = 0x82C3C7FC;
	sub_82C3C7C8(ctx, base);
	// 82C3C7FC: 807D0014  lwz r3, 0x14(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3C800: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 82C3C804: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3C808: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C80C: 419A0014  beq cr6, 0x82c3c820
	if ctx.cr[6].eq {
	pc = 0x82C3C820; continue 'dispatch;
	}
	// 82C3C810: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3C814: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C818: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3C81C: 4E800421  bctrl
	ctx.lr = 0x82C3C820;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3C820 => {
    //   block [0x82C3C820..0x82C3C840)
	// 82C3C820: 939E0004  stw r28, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C3C824: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3C828: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82C3C82C: 4BC08F85  bl 0x828457b0
	ctx.lr = 0x82C3C830;
	sub_828457B0(ctx, base);
	// 82C3C830: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3C834: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C3C838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C83C: 419AFFB4  beq cr6, 0x82c3c7f0
	if ctx.cr[6].eq {
	pc = 0x82C3C7F0; continue 'dispatch;
	}
	pc = 0x82C3C840; continue 'dispatch;
            }
            0x82C3C840 => {
    //   block [0x82C3C840..0x82C3C848)
	// 82C3C840: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3C844: 4806CC10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C848 size=84
    let mut pc: u32 = 0x82C3C848;
    'dispatch: loop {
        match pc {
            0x82C3C848 => {
    //   block [0x82C3C848..0x82C3C89C)
	// 82C3C848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C84C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3C850: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3C854: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C858: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C85C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C860: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C864: 4BFFFF65  bl 0x82c3c7c8
	ctx.lr = 0x82C3C868;
	sub_82C3C7C8(ctx, base);
	// 82C3C868: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C86C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3C870: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3C874: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C878: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3C87C: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C3C880: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C884: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C3C888: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3C88C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3C890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3C894: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3C898: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C8A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C8A0 size=100
    let mut pc: u32 = 0x82C3C8A0;
    'dispatch: loop {
        match pc {
            0x82C3C8A0 => {
    //   block [0x82C3C8A0..0x82C3C904)
	// 82C3C8A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C8A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3C8A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3C8AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C8B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C8B4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3C8B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3C8BC: 392BB820  addi r9, r11, -0x47e0
	ctx.r[9].s64 = ctx.r[11].s64 + -18400;
	// 82C3C8C0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C3C8C4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3C8C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3C8CC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3C8D0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C3C8D4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3C8D8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C3C8DC: 4BFF79FD  bl 0x82c342d8
	ctx.lr = 0x82C3C8E0;
	sub_82C342D8(ctx, base);
	// 82C3C8E0: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C3C8E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C8E8: 38E8C1E0  addi r7, r8, -0x3e20
	ctx.r[7].s64 = ctx.r[8].s64 + -15904;
	// 82C3C8EC: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C3C8F0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3C8F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3C8F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3C8FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3C900: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C908(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C908 size=132
    let mut pc: u32 = 0x82C3C908;
    'dispatch: loop {
        match pc {
            0x82C3C908 => {
    //   block [0x82C3C908..0x82C3C97C)
	// 82C3C908: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C90C: 4806CB01  bl 0x82ca940c
	ctx.lr = 0x82C3C910;
	sub_82CA93D0(ctx, base);
	// 82C3C910: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C914: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3C918: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3C91C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3C920: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C3C924: 392BC1D4  addi r9, r11, -0x3e2c
	ctx.r[9].s64 = ctx.r[11].s64 + -15916;
	// 82C3C928: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C3C92C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C3C930: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3C934: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C3C938: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3C93C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C3C940: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C3C944: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3C948: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C3C94C: 4BFF798D  bl 0x82c342d8
	ctx.lr = 0x82C3C950;
	sub_82C342D8(ctx, base);
	// 82C3C950: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C3C954: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3C958: 38C7C1E4  addi r6, r7, -0x3e1c
	ctx.r[6].s64 = ctx.r[7].s64 + -15900;
	// 82C3C95C: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C3C960: 4BFFF1C9  bl 0x82c3bb28
	ctx.lr = 0x82C3C964;
	sub_82C3BB28(ctx, base);
	// 82C3C964: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3C968: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3C96C: 419A0010  beq cr6, 0x82c3c97c
	if ctx.cr[6].eq {
	pc = 0x82C3C97C; continue 'dispatch;
	}
	// 82C3C970: 4BC08E41  bl 0x828457b0
	ctx.lr = 0x82C3C974;
	sub_828457B0(ctx, base);
	// 82C3C974: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C3C978: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3C97C; continue 'dispatch;
            }
            0x82C3C97C => {
    //   block [0x82C3C97C..0x82C3C98C)
	// 82C3C97C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3C980: 4BFC9781  bl 0x82c06100
	ctx.lr = 0x82C3C984;
	sub_82C06100(ctx, base);
	// 82C3C984: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3C988: 4806CAD4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C990 size=80
    let mut pc: u32 = 0x82C3C990;
    'dispatch: loop {
        match pc {
            0x82C3C990 => {
    //   block [0x82C3C990..0x82C3C9C8)
	// 82C3C990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C994: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3C998: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3C99C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3C9A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3C9A8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3C9AC: 4BFFFF5D  bl 0x82c3c908
	ctx.lr = 0x82C3C9B0;
	sub_82C3C908(ctx, base);
	// 82C3C9B0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3C9B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3C9B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3C9BC: 419A000C  beq cr6, 0x82c3c9c8
	if ctx.cr[6].eq {
	pc = 0x82C3C9C8; continue 'dispatch;
	}
	// 82C3C9C0: 4BC08DF1  bl 0x828457b0
	ctx.lr = 0x82C3C9C4;
	sub_828457B0(ctx, base);
	// 82C3C9C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3C9C8; continue 'dispatch;
            }
            0x82C3C9C8 => {
    //   block [0x82C3C9C8..0x82C3C9E0)
	// 82C3C9C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3C9CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3C9D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3C9D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3C9D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3C9DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3C9E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3C9E0 size=132
    let mut pc: u32 = 0x82C3C9E0;
    'dispatch: loop {
        match pc {
            0x82C3C9E0 => {
    //   block [0x82C3C9E0..0x82C3CA54)
	// 82C3C9E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3C9E4: 4806CA29  bl 0x82ca940c
	ctx.lr = 0x82C3C9E8;
	sub_82CA93D0(ctx, base);
	// 82C3C9E8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3C9EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3C9F0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3C9F4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3C9F8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C3C9FC: 392BC1E8  addi r9, r11, -0x3e18
	ctx.r[9].s64 = ctx.r[11].s64 + -15896;
	// 82C3CA00: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C3CA04: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C3CA08: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3CA0C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C3CA10: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3CA14: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C3CA18: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C3CA1C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3CA20: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C3CA24: 4BFF78B5  bl 0x82c342d8
	ctx.lr = 0x82C3CA28;
	sub_82C342D8(ctx, base);
	// 82C3CA28: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C3CA2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3CA30: 38C7C380  addi r6, r7, -0x3c80
	ctx.r[6].s64 = ctx.r[7].s64 + -15488;
	// 82C3CA34: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C3CA38: 48005EE1  bl 0x82c42918
	ctx.lr = 0x82C3CA3C;
	sub_82C42918(ctx, base);
	// 82C3CA3C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CA40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3CA44: 419A0010  beq cr6, 0x82c3ca54
	if ctx.cr[6].eq {
	pc = 0x82C3CA54; continue 'dispatch;
	}
	// 82C3CA48: 4BC08D69  bl 0x828457b0
	ctx.lr = 0x82C3CA4C;
	sub_828457B0(ctx, base);
	// 82C3CA4C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C3CA50: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3CA54; continue 'dispatch;
            }
            0x82C3CA54 => {
    //   block [0x82C3CA54..0x82C3CA64)
	// 82C3CA54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3CA58: 4BFC96A9  bl 0x82c06100
	ctx.lr = 0x82C3CA5C;
	sub_82C06100(ctx, base);
	// 82C3CA5C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3CA60: 4806C9FC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3CA68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3CA68 size=80
    let mut pc: u32 = 0x82C3CA68;
    'dispatch: loop {
        match pc {
            0x82C3CA68 => {
    //   block [0x82C3CA68..0x82C3CAA0)
	// 82C3CA68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3CA6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3CA70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3CA74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3CA78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3CA7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3CA80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3CA84: 4BFFFF5D  bl 0x82c3c9e0
	ctx.lr = 0x82C3CA88;
	sub_82C3C9E0(ctx, base);
	// 82C3CA88: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3CA8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3CA90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CA94: 419A000C  beq cr6, 0x82c3caa0
	if ctx.cr[6].eq {
	pc = 0x82C3CAA0; continue 'dispatch;
	}
	// 82C3CA98: 4BC08D19  bl 0x828457b0
	ctx.lr = 0x82C3CA9C;
	sub_828457B0(ctx, base);
	// 82C3CA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3CAA0; continue 'dispatch;
            }
            0x82C3CAA0 => {
    //   block [0x82C3CAA0..0x82C3CAB8)
	// 82C3CAA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3CAA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3CAA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3CAAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3CAB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3CAB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3CAB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3CAB8 size=1108
    let mut pc: u32 = 0x82C3CAB8;
    'dispatch: loop {
        match pc {
            0x82C3CAB8 => {
    //   block [0x82C3CAB8..0x82C3CB2C)
	// 82C3CAB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3CABC: 4806C941  bl 0x82ca93fc
	ctx.lr = 0x82C3CAC0;
	sub_82CA93D0(ctx, base);
	// 82C3CAC0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3CAC4: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82C3CAC8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C3CACC: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C3CAD0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C3CAD4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3CAD8: 897F0029  lbz r11, 0x29(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CAE0: 419A005C  beq cr6, 0x82c3cb3c
	if ctx.cr[6].eq {
	pc = 0x82C3CB3C; continue 'dispatch;
	}
	// 82C3CAE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C3CAE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3CAEC: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82C3CAF0: 4B6B5451  bl 0x822f1f40
	ctx.lr = 0x82C3CAF4;
	sub_822F1F40(ctx, base);
	// 82C3CAF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3CAF8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3CAFC: 4B6B5275  bl 0x822f1d70
	ctx.lr = 0x82C3CB00;
	sub_822F1D70(ctx, base);
	// 82C3CB00: 4B6B5321  bl 0x822f1e20
	ctx.lr = 0x82C3CB04;
	sub_822F1E20(ctx, base);
	// 82C3CB04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C3CB08: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3CB0C: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C3CB10: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C3CB14: 4BA3ECCD  bl 0x8267b7e0
	ctx.lr = 0x82C3CB18;
	sub_8267B7E0(ctx, base);
	// 82C3CB18: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C3CB1C: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C3CB20: 4198000C  blt cr6, 0x82c3cb2c
	if ctx.cr[6].lt {
	pc = 0x82C3CB2C; continue 'dispatch;
	}
	// 82C3CB24: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3CB28: 4BC08C89  bl 0x828457b0
	ctx.lr = 0x82C3CB2C;
	sub_828457B0(ctx, base);
	pc = 0x82C3CB2C; continue 'dispatch;
            }
            0x82C3CB2C => {
    //   block [0x82C3CB2C..0x82C3CB3C)
	// 82C3CB2C: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C3CB30: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82C3CB34: 9B610054  stb r27, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u8 ) };
	// 82C3CB38: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3CB3C; continue 'dispatch;
            }
            0x82C3CB3C => {
    //   block [0x82C3CB3C..0x82C3CB60)
	// 82C3CB3C: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82C3CB40: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82C3CB44: 4BFD56B5  bl 0x82c121f8
	ctx.lr = 0x82C3CB48;
	sub_82C121F8(ctx, base);
	// 82C3CB48: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CB4C: 896A0029  lbz r11, 0x29(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CB54: 419A000C  beq cr6, 0x82c3cb60
	if ctx.cr[6].eq {
	pc = 0x82C3CB60; continue 'dispatch;
	}
	// 82C3CB58: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CB5C: 4800002C  b 0x82c3cb88
	pc = 0x82C3CB88; continue 'dispatch;
            }
            0x82C3CB60 => {
    //   block [0x82C3CB60..0x82C3CB78)
	// 82C3CB60: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CB64: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CB68: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3CB6C: 419A000C  beq cr6, 0x82c3cb78
	if ctx.cr[6].eq {
	pc = 0x82C3CB78; continue 'dispatch;
	}
	// 82C3CB70: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82C3CB74: 48000014  b 0x82c3cb88
	pc = 0x82C3CB88; continue 'dispatch;
            }
            0x82C3CB78 => {
    //   block [0x82C3CB78..0x82C3CB88)
	// 82C3CB78: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C3CB7C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CB80: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CB84: 409A00F0  bne cr6, 0x82c3cc74
	if !ctx.cr[6].eq {
	pc = 0x82C3CC74; continue 'dispatch;
	}
	pc = 0x82C3CB88; continue 'dispatch;
            }
            0x82C3CB88 => {
    //   block [0x82C3CB88..0x82C3CB9C)
	// 82C3CB88: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CB8C: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CB90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CB94: 409A0008  bne cr6, 0x82c3cb9c
	if !ctx.cr[6].eq {
	pc = 0x82C3CB9C; continue 'dispatch;
	}
	// 82C3CB98: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3CB9C; continue 'dispatch;
            }
            0x82C3CB9C => {
    //   block [0x82C3CB9C..0x82C3CBB4)
	// 82C3CB9C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CBA0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CBA4: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CBA8: 409A000C  bne cr6, 0x82c3cbb4
	if !ctx.cr[6].eq {
	pc = 0x82C3CBB4; continue 'dispatch;
	}
	// 82C3CBAC: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C3CBB0: 4800001C  b 0x82c3cbcc
	pc = 0x82C3CBCC; continue 'dispatch;
            }
            0x82C3CBB4 => {
    //   block [0x82C3CBB4..0x82C3CBC8)
	// 82C3CBB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CBB8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CBBC: 409A000C  bne cr6, 0x82c3cbc8
	if !ctx.cr[6].eq {
	pc = 0x82C3CBC8; continue 'dispatch;
	}
	// 82C3CBC0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3CBC4: 48000008  b 0x82c3cbcc
	pc = 0x82C3CBCC; continue 'dispatch;
            }
            0x82C3CBC8 => {
    //   block [0x82C3CBC8..0x82C3CBCC)
	// 82C3CBC8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x82C3CBCC; continue 'dispatch;
            }
            0x82C3CBCC => {
    //   block [0x82C3CBCC..0x82C3CBF0)
	// 82C3CBCC: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CBD0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CBD4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CBD8: 409A0044  bne cr6, 0x82c3cc1c
	if !ctx.cr[6].eq {
	pc = 0x82C3CC1C; continue 'dispatch;
	}
	// 82C3CBDC: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CBE4: 419A000C  beq cr6, 0x82c3cbf0
	if ctx.cr[6].eq {
	pc = 0x82C3CBF0; continue 'dispatch;
	}
	// 82C3CBE8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C3CBEC: 4800002C  b 0x82c3cc18
	pc = 0x82C3CC18; continue 'dispatch;
            }
            0x82C3CBF0 => {
    //   block [0x82C3CBF0..0x82C3CC04)
	// 82C3CBF0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CBF4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C3CBF8: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CBFC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3CC00: 409A0018  bne cr6, 0x82c3cc18
	if !ctx.cr[6].eq {
	pc = 0x82C3CC18; continue 'dispatch;
	}
	pc = 0x82C3CC04; continue 'dispatch;
            }
            0x82C3CC04 => {
    //   block [0x82C3CC04..0x82C3CC18)
	// 82C3CC04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3CC08: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CC0C: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CC10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3CC14: 419AFFF0  beq cr6, 0x82c3cc04
	if ctx.cr[6].eq {
	pc = 0x82C3CC04; continue 'dispatch;
	}
	pc = 0x82C3CC18; continue 'dispatch;
            }
            0x82C3CC18 => {
    //   block [0x82C3CC18..0x82C3CC1C)
	// 82C3CC18: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3CC1C; continue 'dispatch;
            }
            0x82C3CC1C => {
    //   block [0x82C3CC1C..0x82C3CC44)
	// 82C3CC1C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CC20: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CC24: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CC28: 409A00E0  bne cr6, 0x82c3cd08
	if !ctx.cr[6].eq {
	pc = 0x82C3CD08; continue 'dispatch;
	}
	// 82C3CC2C: 897D0029  lbz r11, 0x29(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CC34: 419A0010  beq cr6, 0x82c3cc44
	if ctx.cr[6].eq {
	pc = 0x82C3CC44; continue 'dispatch;
	}
	// 82C3CC38: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C3CC3C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3CC40: 480000C8  b 0x82c3cd08
	pc = 0x82C3CD08; continue 'dispatch;
            }
            0x82C3CC44 => {
    //   block [0x82C3CC44..0x82C3CC58)
	// 82C3CC44: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CC48: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C3CC4C: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CC50: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3CC54: 409A0018  bne cr6, 0x82c3cc6c
	if !ctx.cr[6].eq {
	pc = 0x82C3CC6C; continue 'dispatch;
	}
	pc = 0x82C3CC58; continue 'dispatch;
            }
            0x82C3CC58 => {
    //   block [0x82C3CC58..0x82C3CC6C)
	// 82C3CC58: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3CC5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CC60: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CC64: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3CC68: 419AFFF0  beq cr6, 0x82c3cc58
	if ctx.cr[6].eq {
	pc = 0x82C3CC58; continue 'dispatch;
	}
	pc = 0x82C3CC6C; continue 'dispatch;
            }
            0x82C3CC6C => {
    //   block [0x82C3CC6C..0x82C3CC74)
	// 82C3CC6C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3CC70: 48000098  b 0x82c3cd08
	pc = 0x82C3CD08; continue 'dispatch;
            }
            0x82C3CC74 => {
    //   block [0x82C3CC74..0x82C3CC94)
	// 82C3CC74: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3CC78: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CC7C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3CC80: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CC84: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3CC88: 409A000C  bne cr6, 0x82c3cc94
	if !ctx.cr[6].eq {
	pc = 0x82C3CC94; continue 'dispatch;
	}
	// 82C3CC8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C3CC90: 4800002C  b 0x82c3ccbc
	pc = 0x82C3CCBC; continue 'dispatch;
            }
            0x82C3CC94 => {
    //   block [0x82C3CC94..0x82C3CCA8)
	// 82C3CC94: 895D0029  lbz r10, 0x29(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CC98: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CC9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3CCA0: 409A0008  bne cr6, 0x82c3cca8
	if !ctx.cr[6].eq {
	pc = 0x82C3CCA8; continue 'dispatch;
	}
	// 82C3CCA4: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3CCA8; continue 'dispatch;
            }
            0x82C3CCA8 => {
    //   block [0x82C3CCA8..0x82C3CCBC)
	// 82C3CCA8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3CCAC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CCB0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3CCB4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CCB8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3CCBC; continue 'dispatch;
            }
            0x82C3CCBC => {
    //   block [0x82C3CCBC..0x82C3CCD4)
	// 82C3CCBC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CCC0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CCC4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CCC8: 409A000C  bne cr6, 0x82c3ccd4
	if !ctx.cr[6].eq {
	pc = 0x82C3CCD4; continue 'dispatch;
	}
	// 82C3CCCC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3CCD0: 48000020  b 0x82c3ccf0
	pc = 0x82C3CCF0; continue 'dispatch;
            }
            0x82C3CCD4 => {
    //   block [0x82C3CCD4..0x82C3CCEC)
	// 82C3CCD4: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CCD8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CCDC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3CCE0: 409A000C  bne cr6, 0x82c3ccec
	if !ctx.cr[6].eq {
	pc = 0x82C3CCEC; continue 'dispatch;
	}
	// 82C3CCE4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C3CCE8: 48000008  b 0x82c3ccf0
	pc = 0x82C3CCF0; continue 'dispatch;
            }
            0x82C3CCEC => {
    //   block [0x82C3CCEC..0x82C3CCF0)
	// 82C3CCEC: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3CCF0; continue 'dispatch;
            }
            0x82C3CCF0 => {
    //   block [0x82C3CCF0..0x82C3CD08)
	// 82C3CCF0: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CCF4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3CCF8: 890B0028  lbz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CCFC: 893A0028  lbz r9, 0x28(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD00: 992B0028  stb r9, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u8 ) };
	// 82C3CD04: 991A0028  stb r8, 0x28(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[8].u8 ) };
	pc = 0x82C3CD08; continue 'dispatch;
            }
            0x82C3CD08 => {
    //   block [0x82C3CD08..0x82C3CD28)
	// 82C3CD08: 897A0028  lbz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD0C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C3CD10: 409A0194  bne cr6, 0x82c3cea4
	if !ctx.cr[6].eq {
	pc = 0x82C3CEA4; continue 'dispatch;
	}
	// 82C3CD14: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CD18: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C3CD1C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CD20: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3CD24: 419A017C  beq cr6, 0x82c3cea0
	if ctx.cr[6].eq {
	pc = 0x82C3CEA0; continue 'dispatch;
	}
	pc = 0x82C3CD28; continue 'dispatch;
            }
            0x82C3CD28 => {
    //   block [0x82C3CD28..0x82C3CD68)
	// 82C3CD28: 897D0028  lbz r11, 0x28(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD2C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C3CD30: 409A0170  bne cr6, 0x82c3cea0
	if !ctx.cr[6].eq {
	pc = 0x82C3CEA0; continue 'dispatch;
	}
	// 82C3CD34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CD38: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3CD3C: 409A00A8  bne cr6, 0x82c3cde4
	if !ctx.cr[6].eq {
	pc = 0x82C3CDE4; continue 'dispatch;
	}
	// 82C3CD40: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CD44: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3CD4C: 409A001C  bne cr6, 0x82c3cd68
	if !ctx.cr[6].eq {
	pc = 0x82C3CD68; continue 'dispatch;
	}
	// 82C3CD50: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CD54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3CD58: 9B7F0028  stb r27, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	// 82C3CD5C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CD60: 4BFD6579  bl 0x82c132d8
	ctx.lr = 0x82C3CD64;
	sub_82C132D8(ctx, base);
	// 82C3CD64: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3CD68; continue 'dispatch;
            }
            0x82C3CD68 => {
    //   block [0x82C3CD68..0x82C3CD94)
	// 82C3CD68: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CD6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3CD70: 409A00C8  bne cr6, 0x82c3ce38
	if !ctx.cr[6].eq {
	pc = 0x82C3CE38; continue 'dispatch;
	}
	// 82C3CD74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CD78: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD7C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CD80: 409A0014  bne cr6, 0x82c3cd94
	if !ctx.cr[6].eq {
	pc = 0x82C3CD94; continue 'dispatch;
	}
	// 82C3CD84: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CD88: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD8C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CD90: 419A00A4  beq cr6, 0x82c3ce34
	if ctx.cr[6].eq {
	pc = 0x82C3CE34; continue 'dispatch;
	}
	pc = 0x82C3CD94; continue 'dispatch;
            }
            0x82C3CD94 => {
    //   block [0x82C3CD94..0x82C3CDC0)
	// 82C3CD94: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CD98: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CD9C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CDA0: 409A0020  bne cr6, 0x82c3cdc0
	if !ctx.cr[6].eq {
	pc = 0x82C3CDC0; continue 'dispatch;
	}
	// 82C3CDA4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CDA8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C3CDAC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CDB0: 9BCA0028  stb r30, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CDB4: 9B6B0028  stb r27, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	// 82C3CDB8: 4BFFE909  bl 0x82c3b6c0
	ctx.lr = 0x82C3CDBC;
	sub_82C3B6C0(ctx, base);
	// 82C3CDBC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3CDC0; continue 'dispatch;
            }
            0x82C3CDC0 => {
    //   block [0x82C3CDC0..0x82C3CDE4)
	// 82C3CDC0: 895F0028  lbz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CDC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3CDC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CDCC: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 82C3CDD0: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CDD4: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CDD8: 9BC90028  stb r30, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CDDC: 4BFD64FD  bl 0x82c132d8
	ctx.lr = 0x82C3CDE0;
	sub_82C132D8(ctx, base);
	// 82C3CDE0: 480000C0  b 0x82c3cea0
	pc = 0x82C3CEA0; continue 'dispatch;
            }
            0x82C3CDE4 => {
    //   block [0x82C3CDE4..0x82C3CE08)
	// 82C3CDE4: 894B0028  lbz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CDE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3CDEC: 409A001C  bne cr6, 0x82c3ce08
	if !ctx.cr[6].eq {
	pc = 0x82C3CE08; continue 'dispatch;
	}
	// 82C3CDF0: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CDF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3CDF8: 9B7F0028  stb r27, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	// 82C3CDFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CE00: 4BFFE8C1  bl 0x82c3b6c0
	ctx.lr = 0x82C3CE04;
	sub_82C3B6C0(ctx, base);
	// 82C3CE04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3CE08; continue 'dispatch;
            }
            0x82C3CE08 => {
    //   block [0x82C3CE08..0x82C3CE34)
	// 82C3CE08: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3CE0C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3CE10: 409A0028  bne cr6, 0x82c3ce38
	if !ctx.cr[6].eq {
	pc = 0x82C3CE38; continue 'dispatch;
	}
	// 82C3CE14: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CE18: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CE1C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CE20: 409A0034  bne cr6, 0x82c3ce54
	if !ctx.cr[6].eq {
	pc = 0x82C3CE54; continue 'dispatch;
	}
	// 82C3CE24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CE28: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CE2C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CE30: 409A0024  bne cr6, 0x82c3ce54
	if !ctx.cr[6].eq {
	pc = 0x82C3CE54; continue 'dispatch;
	}
	pc = 0x82C3CE34; continue 'dispatch;
            }
            0x82C3CE34 => {
    //   block [0x82C3CE34..0x82C3CE38)
	// 82C3CE34: 9B6B0028  stb r27, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	pc = 0x82C3CE38; continue 'dispatch;
            }
            0x82C3CE38 => {
    //   block [0x82C3CE38..0x82C3CE54)
	// 82C3CE38: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CE3C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C3CE40: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CE44: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CE48: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3CE4C: 409AFEDC  bne cr6, 0x82c3cd28
	if !ctx.cr[6].eq {
	pc = 0x82C3CD28; continue 'dispatch;
	}
	// 82C3CE50: 48000050  b 0x82c3cea0
	pc = 0x82C3CEA0; continue 'dispatch;
            }
            0x82C3CE54 => {
    //   block [0x82C3CE54..0x82C3CE80)
	// 82C3CE54: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CE58: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CE5C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3CE60: 409A0020  bne cr6, 0x82c3ce80
	if !ctx.cr[6].eq {
	pc = 0x82C3CE80; continue 'dispatch;
	}
	// 82C3CE64: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CE68: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C3CE6C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CE70: 9BCA0028  stb r30, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CE74: 9B6B0028  stb r27, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[27].u8 ) };
	// 82C3CE78: 4BFD6461  bl 0x82c132d8
	ctx.lr = 0x82C3CE7C;
	sub_82C132D8(ctx, base);
	// 82C3CE7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3CE80; continue 'dispatch;
            }
            0x82C3CE80 => {
    //   block [0x82C3CE80..0x82C3CEA0)
	// 82C3CE80: 895F0028  lbz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3CE84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3CE88: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3CE8C: 994B0028  stb r10, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[10].u8 ) };
	// 82C3CE90: 9BDF0028  stb r30, 0x28(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CE94: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CE98: 9BC90028  stb r30, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3CE9C: 4BFFE825  bl 0x82c3b6c0
	ctx.lr = 0x82C3CEA0;
	sub_82C3B6C0(ctx, base);
	pc = 0x82C3CEA0; continue 'dispatch;
            }
            0x82C3CEA0 => {
    //   block [0x82C3CEA0..0x82C3CEA4)
	// 82C3CEA0: 9BDD0028  stb r30, 0x28(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	pc = 0x82C3CEA4; continue 'dispatch;
            }
            0x82C3CEA4 => {
    //   block [0x82C3CEA4..0x82C3CEC4)
	// 82C3CEA4: 807A0014  lwz r3, 0x14(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3CEA8: 3BFA0010  addi r31, r26, 0x10
	ctx.r[31].s64 = ctx.r[26].s64 + 16;
	// 82C3CEAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3CEB0: 419A0014  beq cr6, 0x82c3cec4
	if ctx.cr[6].eq {
	pc = 0x82C3CEC4; continue 'dispatch;
	}
	// 82C3CEB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CEB8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CEBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3CEC0: 4E800421  bctrl
	ctx.lr = 0x82C3CEC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3CEC4 => {
    //   block [0x82C3CEC4..0x82C3CEFC)
	// 82C3CEC4: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C3CEC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C3CECC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82C3CED0: 4BC088E1  bl 0x828457b0
	ctx.lr = 0x82C3CED4;
	sub_828457B0(ctx, base);
	// 82C3CED4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CED8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3CEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3CEE0: 419A001C  beq cr6, 0x82c3cefc
	if ctx.cr[6].eq {
	pc = 0x82C3CEFC; continue 'dispatch;
	}
	// 82C3CEE4: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C3CEE8: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82C3CEEC: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C3CEF0: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82C3CEF4: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3CEF8: 4806C554  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3CEFC => {
    //   block [0x82C3CEFC..0x82C3CF0C)
	// 82C3CEFC: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C3CF00: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C3CF04: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3CF08: 4806C544  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3CF10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3CF10 size=848
    let mut pc: u32 = 0x82C3CF10;
    'dispatch: loop {
        match pc {
            0x82C3CF10 => {
    //   block [0x82C3CF10..0x82C3CF90)
	// 82C3CF10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3CF14: 4806C4E5  bl 0x82ca93f8
	ctx.lr = 0x82C3CF18;
	sub_82CA93D0(ctx, base);
	// 82C3CF18: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3CF1C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C3CF20: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82C3CF24: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82C3CF28: 6169FFFE  ori r9, r11, 0xfffe
	ctx.r[9].u64 = ctx.r[11].u64 | 65534;
	// 82C3CF2C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C3CF30: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CF34: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C3CF38: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 82C3CF3C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C3CF40: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3CF44: 4198005C  blt cr6, 0x82c3cfa0
	if ctx.cr[6].lt {
	pc = 0x82C3CFA0; continue 'dispatch;
	}
	// 82C3CF48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C3CF4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3CF50: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82C3CF54: 4B6B4FED  bl 0x822f1f40
	ctx.lr = 0x82C3CF58;
	sub_822F1F40(ctx, base);
	// 82C3CF58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3CF5C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3CF60: 4B6B4E11  bl 0x822f1d70
	ctx.lr = 0x82C3CF64;
	sub_822F1D70(ctx, base);
	// 82C3CF64: 4B6B4EBD  bl 0x822f1e20
	ctx.lr = 0x82C3CF68;
	sub_822F1E20(ctx, base);
	// 82C3CF68: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C3CF6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3CF70: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C3CF74: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C3CF78: 4BA3E869  bl 0x8267b7e0
	ctx.lr = 0x82C3CF7C;
	sub_8267B7E0(ctx, base);
	// 82C3CF7C: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C3CF80: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C3CF84: 4198000C  blt cr6, 0x82c3cf90
	if ctx.cr[6].lt {
	pc = 0x82C3CF90; continue 'dispatch;
	}
	// 82C3CF88: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3CF8C: 4BC08825  bl 0x828457b0
	ctx.lr = 0x82C3CF90;
	sub_828457B0(ctx, base);
	pc = 0x82C3CF90; continue 'dispatch;
            }
            0x82C3CF90 => {
    //   block [0x82C3CF90..0x82C3CFA0)
	// 82C3CF90: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C3CF94: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82C3CF98: 9B210054  stb r25, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u8 ) };
	// 82C3CF9C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3CFA0; continue 'dispatch;
            }
            0x82C3CFA0 => {
    //   block [0x82C3CFA0..0x82C3CFEC)
	// 82C3CFA0: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C3CFA4: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CFA8: 4B5E22B1  bl 0x8221f258
	ctx.lr = 0x82C3CFAC;
	sub_8221F258(ctx, base);
	// 82C3CFAC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C3CFB0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C3CFB4: 419A0038  beq cr6, 0x82c3cfec
	if ctx.cr[6].eq {
	pc = 0x82C3CFEC; continue 'dispatch;
	}
	// 82C3CFB8: 93BA0000  stw r29, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3CFBC: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C3CFC0: 93BA0008  stw r29, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C3CFC4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3CFC8: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3CFCC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CFD0: 915A0010  stw r10, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C3CFD4: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CFD8: 913A0014  stw r9, 0x14(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 82C3CFDC: 811E000C  lwz r8, 0xc(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3CFE0: 911A0018  stw r8, 0x18(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 82C3CFE4: 9B3A001C  stb r25, 0x1c(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82C3CFE8: 9B3A001D  stb r25, 0x1d(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(29 as u32), ctx.r[25].u8 ) };
	pc = 0x82C3CFEC; continue 'dispatch;
            }
            0x82C3CFEC => {
    //   block [0x82C3CFEC..0x82C3D01C)
	// 82C3CFEC: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3CFF0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3CFF4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C3CFF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3CFFC: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3D000: 409A001C  bne cr6, 0x82c3d01c
	if !ctx.cr[6].eq {
	pc = 0x82C3D01C; continue 'dispatch;
	}
	// 82C3D004: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3D008: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D00C: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3D010: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D014: 934A0008  stw r26, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C3D018: 48000044  b 0x82c3d05c
	pc = 0x82C3D05C; continue 'dispatch;
            }
            0x82C3D01C => {
    //   block [0x82C3D01C..0x82C3D044)
	// 82C3D01C: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C3D020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D024: 419A0020  beq cr6, 0x82c3d044
	if ctx.cr[6].eq {
	pc = 0x82C3D044; continue 'dispatch;
	}
	// 82C3D028: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3D02C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D030: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D034: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D038: 409A0024  bne cr6, 0x82c3d05c
	if !ctx.cr[6].eq {
	pc = 0x82C3D05C; continue 'dispatch;
	}
	// 82C3D03C: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3D040: 4800001C  b 0x82c3d05c
	pc = 0x82C3D05C; continue 'dispatch;
            }
            0x82C3D044 => {
    //   block [0x82C3D044..0x82C3D05C)
	// 82C3D044: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C3D048: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D04C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D050: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D054: 409A0008  bne cr6, 0x82c3d05c
	if !ctx.cr[6].eq {
	pc = 0x82C3D05C; continue 'dispatch;
	}
	// 82C3D058: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	pc = 0x82C3D05C; continue 'dispatch;
            }
            0x82C3D05C => {
    //   block [0x82C3D05C..0x82C3D078)
	// 82C3D05C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D060: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82C3D064: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C3D068: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3D06C: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D070: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D074: 409A01CC  bne cr6, 0x82c3d240
	if !ctx.cr[6].eq {
	pc = 0x82C3D240; continue 'dispatch;
	}
	pc = 0x82C3D078; continue 'dispatch;
            }
            0x82C3D078 => {
    //   block [0x82C3D078..0x82C3D0C0)
	// 82C3D078: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D07C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D080: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D084: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3D088: 409A00D8  bne cr6, 0x82c3d160
	if !ctx.cr[6].eq {
	pc = 0x82C3D160; continue 'dispatch;
	}
	// 82C3D08C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D090: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D094: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D098: 409A0028  bne cr6, 0x82c3d0c0
	if !ctx.cr[6].eq {
	pc = 0x82C3D0C0; continue 'dispatch;
	}
	// 82C3D09C: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C3D0A0: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D0A4: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D0A8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D0AC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0B0: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82C3D0B4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D0B8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0BC: 48000170  b 0x82c3d22c
	pc = 0x82C3D22C; continue 'dispatch;
            }
            0x82C3D0C0 => {
    //   block [0x82C3D0C0..0x82C3D0D8)
	// 82C3D0C0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D0C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3D0C8: 409A0010  bne cr6, 0x82c3d0d8
	if !ctx.cr[6].eq {
	pc = 0x82C3D0D8; continue 'dispatch;
	}
	// 82C3D0CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3D0D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3D0D4: 4BF2D74D  bl 0x82b6a820
	ctx.lr = 0x82C3D0D8;
	sub_82B6A820(ctx, base);
	pc = 0x82C3D0D8; continue 'dispatch;
            }
            0x82C3D0D8 => {
    //   block [0x82C3D0D8..0x82C3D114)
	// 82C3D0D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0DC: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D0E0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0E4: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0E8: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82C3D0EC: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0F0: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D0F4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D0F8: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D0FC: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C3D100: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D104: 88C9001D  lbz r6, 0x1d(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D108: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3D10C: 409A0008  bne cr6, 0x82c3d114
	if !ctx.cr[6].eq {
	pc = 0x82C3D114; continue 'dispatch;
	}
	// 82C3D110: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D114; continue 'dispatch;
            }
            0x82C3D114 => {
    //   block [0x82C3D114..0x82C3D138)
	// 82C3D114: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D118: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3D11C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D120: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D124: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3D128: 409A0010  bne cr6, 0x82c3d138
	if !ctx.cr[6].eq {
	pc = 0x82C3D138; continue 'dispatch;
	}
	// 82C3D12C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3D130: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3D134: 480000F4  b 0x82c3d228
	pc = 0x82C3D228; continue 'dispatch;
            }
            0x82C3D138 => {
    //   block [0x82C3D138..0x82C3D154)
	// 82C3D138: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D13C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D140: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3D144: 409A0010  bne cr6, 0x82c3d154
	if !ctx.cr[6].eq {
	pc = 0x82C3D154; continue 'dispatch;
	}
	// 82C3D148: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3D14C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3D150: 480000D8  b 0x82c3d228
	pc = 0x82C3D228; continue 'dispatch;
            }
            0x82C3D154 => {
    //   block [0x82C3D154..0x82C3D160)
	// 82C3D154: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3D158: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3D15C: 480000CC  b 0x82c3d228
	pc = 0x82C3D228; continue 'dispatch;
            }
            0x82C3D160 => {
    //   block [0x82C3D160..0x82C3D194)
	// 82C3D160: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D164: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D168: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D16C: 409A0028  bne cr6, 0x82c3d194
	if !ctx.cr[6].eq {
	pc = 0x82C3D194; continue 'dispatch;
	}
	// 82C3D170: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D174: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D178: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D17C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D180: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D184: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82C3D188: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D18C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D190: 4800009C  b 0x82c3d22c
	pc = 0x82C3D22C; continue 'dispatch;
            }
            0x82C3D194 => {
    //   block [0x82C3D194..0x82C3D1AC)
	// 82C3D194: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D198: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3D19C: 409A0010  bne cr6, 0x82c3d1ac
	if !ctx.cr[6].eq {
	pc = 0x82C3D1AC; continue 'dispatch;
	}
	// 82C3D1A0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3D1A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3D1A8: 4BFFE591  bl 0x82c3b738
	ctx.lr = 0x82C3D1AC;
	sub_82C3B738(ctx, base);
	pc = 0x82C3D1AC; continue 'dispatch;
            }
            0x82C3D1AC => {
    //   block [0x82C3D1AC..0x82C3D1E8)
	// 82C3D1AC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1B0: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D1B4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1B8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1BC: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82C3D1C0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1C4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D1CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D1D0: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C3D1D4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D1D8: 88C9001D  lbz r6, 0x1d(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D1DC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3D1E0: 409A0008  bne cr6, 0x82c3d1e8
	if !ctx.cr[6].eq {
	pc = 0x82C3D1E8; continue 'dispatch;
	}
	// 82C3D1E4: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D1E8; continue 'dispatch;
            }
            0x82C3D1E8 => {
    //   block [0x82C3D1E8..0x82C3D208)
	// 82C3D1E8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1EC: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3D1F0: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1F4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D1F8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3D1FC: 409A000C  bne cr6, 0x82c3d208
	if !ctx.cr[6].eq {
	pc = 0x82C3D208; continue 'dispatch;
	}
	// 82C3D200: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3D204: 48000020  b 0x82c3d224
	pc = 0x82C3D224; continue 'dispatch;
            }
            0x82C3D208 => {
    //   block [0x82C3D208..0x82C3D220)
	// 82C3D208: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D20C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D210: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3D214: 409A000C  bne cr6, 0x82c3d220
	if !ctx.cr[6].eq {
	pc = 0x82C3D220; continue 'dispatch;
	}
	// 82C3D218: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3D21C: 48000008  b 0x82c3d224
	pc = 0x82C3D224; continue 'dispatch;
            }
            0x82C3D220 => {
    //   block [0x82C3D220..0x82C3D224)
	// 82C3D220: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3D224; continue 'dispatch;
            }
            0x82C3D224 => {
    //   block [0x82C3D224..0x82C3D228)
	// 82C3D224: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D228; continue 'dispatch;
            }
            0x82C3D228 => {
    //   block [0x82C3D228..0x82C3D22C)
	// 82C3D228: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3D22C; continue 'dispatch;
            }
            0x82C3D22C => {
    //   block [0x82C3D22C..0x82C3D240)
	// 82C3D22C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D230: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C3D234: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D238: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D23C: 419AFE3C  beq cr6, 0x82c3d078
	if ctx.cr[6].eq {
	pc = 0x82C3D078; continue 'dispatch;
	}
	pc = 0x82C3D240; continue 'dispatch;
            }
            0x82C3D240 => {
    //   block [0x82C3D240..0x82C3D260)
	// 82C3D240: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D244: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C3D248: 93580004  stw r26, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3D24C: 93780000  stw r27, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82C3D250: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D254: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D258: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3D25C: 4806C1EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3D260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3D260 size=232
    let mut pc: u32 = 0x82C3D260;
    'dispatch: loop {
        match pc {
            0x82C3D260 => {
    //   block [0x82C3D260..0x82C3D298)
	// 82C3D260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3D264: 4806C1A1  bl 0x82ca9404
	ctx.lr = 0x82C3D268;
	sub_82CA93D0(ctx, base);
	// 82C3D268: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3D26C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3D270: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82C3D274: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3D278: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3D27C: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C3D280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D284: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D288: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D28C: 419A000C  beq cr6, 0x82c3d298
	if ctx.cr[6].eq {
	pc = 0x82C3D298; continue 'dispatch;
	}
	// 82C3D290: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3D294: 419A0008  beq cr6, 0x82c3d29c
	if ctx.cr[6].eq {
	pc = 0x82C3D29C; continue 'dispatch;
	}
	pc = 0x82C3D298; continue 'dispatch;
            }
            0x82C3D298 => {
    //   block [0x82C3D298..0x82C3D29C)
	// 82C3D298: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D29C; continue 'dispatch;
            }
            0x82C3D29C => {
    //   block [0x82C3D29C..0x82C3D2C0)
	// 82C3D29C: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3D2A0: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C3D2A4: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C3D2A8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3D2AC: 409A0044  bne cr6, 0x82c3d2f0
	if !ctx.cr[6].eq {
	pc = 0x82C3D2F0; continue 'dispatch;
	}
	// 82C3D2B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C3D2B4: 419A000C  beq cr6, 0x82c3d2c0
	if ctx.cr[6].eq {
	pc = 0x82C3D2C0; continue 'dispatch;
	}
	// 82C3D2B8: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3D2BC: 419A0008  beq cr6, 0x82c3d2c4
	if ctx.cr[6].eq {
	pc = 0x82C3D2C4; continue 'dispatch;
	}
	pc = 0x82C3D2C0; continue 'dispatch;
            }
            0x82C3D2C0 => {
    //   block [0x82C3D2C0..0x82C3D2C4)
	// 82C3D2C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D2C4; continue 'dispatch;
            }
            0x82C3D2C4 => {
    //   block [0x82C3D2C4..0x82C3D2F0)
	// 82C3D2C4: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3D2C8: 409A0028  bne cr6, 0x82c3d2f0
	if !ctx.cr[6].eq {
	pc = 0x82C3D2F0; continue 'dispatch;
	}
	// 82C3D2CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3D2D0: 4BFFF579  bl 0x82c3c848
	ctx.lr = 0x82C3D2D4;
	sub_82C3C848(ctx, base);
	// 82C3D2D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D2D8: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C3D2DC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D2E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D2E4: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3D2E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D2EC: 4806C168  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D2F0 => {
    //   block [0x82C3D2F0..0x82C3D300)
	// 82C3D2F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D2F4: 419A000C  beq cr6, 0x82c3d300
	if ctx.cr[6].eq {
	pc = 0x82C3D300; continue 'dispatch;
	}
	// 82C3D2F8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3D2FC: 419A0008  beq cr6, 0x82c3d304
	if ctx.cr[6].eq {
	pc = 0x82C3D304; continue 'dispatch;
	}
	pc = 0x82C3D300; continue 'dispatch;
            }
            0x82C3D300 => {
    //   block [0x82C3D300..0x82C3D304)
	// 82C3D300: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D304; continue 'dispatch;
            }
            0x82C3D304 => {
    //   block [0x82C3D304..0x82C3D338)
	// 82C3D304: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3D308: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C3D30C: 419A002C  beq cr6, 0x82c3d338
	if ctx.cr[6].eq {
	pc = 0x82C3D338; continue 'dispatch;
	}
	// 82C3D310: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82C3D314: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3D318: 4BFD4EE1  bl 0x82c121f8
	ctx.lr = 0x82C3D31C;
	sub_82C121F8(ctx, base);
	// 82C3D31C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C3D320: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D324: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3D328: 4BFFF791  bl 0x82c3cab8
	ctx.lr = 0x82C3D32C;
	sub_82C3CAB8(ctx, base);
	// 82C3D32C: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82C3D330: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3D334: 4BFFFFBC  b 0x82c3d2f0
	pc = 0x82C3D2F0; continue 'dispatch;
            }
            0x82C3D338 => {
    //   block [0x82C3D338..0x82C3D348)
	// 82C3D338: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82C3D33C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D340: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D344: 4806C110  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3D348(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3D348 size=1068
    let mut pc: u32 = 0x82C3D348;
    'dispatch: loop {
        match pc {
            0x82C3D348 => {
    //   block [0x82C3D348..0x82C3D3BC)
	// 82C3D348: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3D34C: 4806C0B1  bl 0x82ca93fc
	ctx.lr = 0x82C3D350;
	sub_82CA93D0(ctx, base);
	// 82C3D350: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3D354: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82C3D358: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C3D35C: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C3D360: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C3D364: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3D368: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D36C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D370: 419A005C  beq cr6, 0x82c3d3cc
	if ctx.cr[6].eq {
	pc = 0x82C3D3CC; continue 'dispatch;
	}
	// 82C3D374: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C3D378: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3D37C: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82C3D380: 4B6B4BC1  bl 0x822f1f40
	ctx.lr = 0x82C3D384;
	sub_822F1F40(ctx, base);
	// 82C3D384: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3D388: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3D38C: 4B6B49E5  bl 0x822f1d70
	ctx.lr = 0x82C3D390;
	sub_822F1D70(ctx, base);
	// 82C3D390: 4B6B4A91  bl 0x822f1e20
	ctx.lr = 0x82C3D394;
	sub_822F1E20(ctx, base);
	// 82C3D394: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C3D398: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3D39C: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C3D3A0: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C3D3A4: 4BA3E43D  bl 0x8267b7e0
	ctx.lr = 0x82C3D3A8;
	sub_8267B7E0(ctx, base);
	// 82C3D3A8: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C3D3AC: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C3D3B0: 4198000C  blt cr6, 0x82c3d3bc
	if ctx.cr[6].lt {
	pc = 0x82C3D3BC; continue 'dispatch;
	}
	// 82C3D3B4: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3D3B8: 4BC083F9  bl 0x828457b0
	ctx.lr = 0x82C3D3BC;
	sub_828457B0(ctx, base);
	pc = 0x82C3D3BC; continue 'dispatch;
            }
            0x82C3D3BC => {
    //   block [0x82C3D3BC..0x82C3D3CC)
	// 82C3D3BC: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C3D3C0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 82C3D3C4: 9B610054  stb r27, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u8 ) };
	// 82C3D3C8: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D3CC; continue 'dispatch;
            }
            0x82C3D3CC => {
    //   block [0x82C3D3CC..0x82C3D3F0)
	// 82C3D3CC: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 82C3D3D0: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82C3D3D4: 4BE5F145  bl 0x82a9c518
	ctx.lr = 0x82C3D3D8;
	sub_82A9C518(ctx, base);
	// 82C3D3D8: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D3DC: 896A001D  lbz r11, 0x1d(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D3E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D3E4: 419A000C  beq cr6, 0x82c3d3f0
	if ctx.cr[6].eq {
	pc = 0x82C3D3F0; continue 'dispatch;
	}
	// 82C3D3E8: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D3EC: 4800002C  b 0x82c3d418
	pc = 0x82C3D418; continue 'dispatch;
            }
            0x82C3D3F0 => {
    //   block [0x82C3D3F0..0x82C3D408)
	// 82C3D3F0: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D3F4: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D3F8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D3FC: 419A000C  beq cr6, 0x82c3d408
	if ctx.cr[6].eq {
	pc = 0x82C3D408; continue 'dispatch;
	}
	// 82C3D400: 7D5D5378  mr r29, r10
	ctx.r[29].u64 = ctx.r[10].u64;
	// 82C3D404: 48000014  b 0x82c3d418
	pc = 0x82C3D418; continue 'dispatch;
            }
            0x82C3D408 => {
    //   block [0x82C3D408..0x82C3D418)
	// 82C3D408: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82C3D40C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D410: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D414: 409A00F0  bne cr6, 0x82c3d504
	if !ctx.cr[6].eq {
	pc = 0x82C3D504; continue 'dispatch;
	}
	pc = 0x82C3D418; continue 'dispatch;
            }
            0x82C3D418 => {
    //   block [0x82C3D418..0x82C3D42C)
	// 82C3D418: 897D001D  lbz r11, 0x1d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D41C: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D424: 409A0008  bne cr6, 0x82c3d42c
	if !ctx.cr[6].eq {
	pc = 0x82C3D42C; continue 'dispatch;
	}
	// 82C3D428: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3D42C; continue 'dispatch;
            }
            0x82C3D42C => {
    //   block [0x82C3D42C..0x82C3D444)
	// 82C3D42C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D430: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D434: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D438: 409A000C  bne cr6, 0x82c3d444
	if !ctx.cr[6].eq {
	pc = 0x82C3D444; continue 'dispatch;
	}
	// 82C3D43C: 93AB0004  stw r29, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C3D440: 4800001C  b 0x82c3d45c
	pc = 0x82C3D45C; continue 'dispatch;
            }
            0x82C3D444 => {
    //   block [0x82C3D444..0x82C3D458)
	// 82C3D444: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D448: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D44C: 409A000C  bne cr6, 0x82c3d458
	if !ctx.cr[6].eq {
	pc = 0x82C3D458; continue 'dispatch;
	}
	// 82C3D450: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3D454: 48000008  b 0x82c3d45c
	pc = 0x82C3D45C; continue 'dispatch;
            }
            0x82C3D458 => {
    //   block [0x82C3D458..0x82C3D45C)
	// 82C3D458: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x82C3D45C; continue 'dispatch;
            }
            0x82C3D45C => {
    //   block [0x82C3D45C..0x82C3D480)
	// 82C3D45C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D460: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D464: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D468: 409A0044  bne cr6, 0x82c3d4ac
	if !ctx.cr[6].eq {
	pc = 0x82C3D4AC; continue 'dispatch;
	}
	// 82C3D46C: 897D001D  lbz r11, 0x1d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D474: 419A000C  beq cr6, 0x82c3d480
	if ctx.cr[6].eq {
	pc = 0x82C3D480; continue 'dispatch;
	}
	// 82C3D478: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C3D47C: 4800002C  b 0x82c3d4a8
	pc = 0x82C3D4A8; continue 'dispatch;
            }
            0x82C3D480 => {
    //   block [0x82C3D480..0x82C3D494)
	// 82C3D480: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D484: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C3D488: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D48C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3D490: 409A0018  bne cr6, 0x82c3d4a8
	if !ctx.cr[6].eq {
	pc = 0x82C3D4A8; continue 'dispatch;
	}
	pc = 0x82C3D494; continue 'dispatch;
            }
            0x82C3D494 => {
    //   block [0x82C3D494..0x82C3D4A8)
	// 82C3D494: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3D498: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D49C: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D4A0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3D4A4: 419AFFF0  beq cr6, 0x82c3d494
	if ctx.cr[6].eq {
	pc = 0x82C3D494; continue 'dispatch;
	}
	pc = 0x82C3D4A8; continue 'dispatch;
            }
            0x82C3D4A8 => {
    //   block [0x82C3D4A8..0x82C3D4AC)
	// 82C3D4A8: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3D4AC; continue 'dispatch;
            }
            0x82C3D4AC => {
    //   block [0x82C3D4AC..0x82C3D4D4)
	// 82C3D4AC: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D4B0: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D4B4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D4B8: 409A00E0  bne cr6, 0x82c3d598
	if !ctx.cr[6].eq {
	pc = 0x82C3D598; continue 'dispatch;
	}
	// 82C3D4BC: 897D001D  lbz r11, 0x1d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D4C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D4C4: 419A0010  beq cr6, 0x82c3d4d4
	if ctx.cr[6].eq {
	pc = 0x82C3D4D4; continue 'dispatch;
	}
	// 82C3D4C8: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82C3D4CC: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3D4D0: 480000C8  b 0x82c3d598
	pc = 0x82C3D598; continue 'dispatch;
            }
            0x82C3D4D4 => {
    //   block [0x82C3D4D4..0x82C3D4E8)
	// 82C3D4D4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D4D8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C3D4DC: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D4E0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3D4E4: 409A0018  bne cr6, 0x82c3d4fc
	if !ctx.cr[6].eq {
	pc = 0x82C3D4FC; continue 'dispatch;
	}
	pc = 0x82C3D4E8; continue 'dispatch;
            }
            0x82C3D4E8 => {
    //   block [0x82C3D4E8..0x82C3D4FC)
	// 82C3D4E8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3D4EC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D4F0: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D4F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3D4F8: 419AFFF0  beq cr6, 0x82c3d4e8
	if ctx.cr[6].eq {
	pc = 0x82C3D4E8; continue 'dispatch;
	}
	pc = 0x82C3D4FC; continue 'dispatch;
            }
            0x82C3D4FC => {
    //   block [0x82C3D4FC..0x82C3D504)
	// 82C3D4FC: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3D500: 48000098  b 0x82c3d598
	pc = 0x82C3D598; continue 'dispatch;
            }
            0x82C3D504 => {
    //   block [0x82C3D504..0x82C3D524)
	// 82C3D504: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3D508: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D50C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3D510: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D514: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3D518: 409A000C  bne cr6, 0x82c3d524
	if !ctx.cr[6].eq {
	pc = 0x82C3D524; continue 'dispatch;
	}
	// 82C3D51C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C3D520: 4800002C  b 0x82c3d54c
	pc = 0x82C3D54C; continue 'dispatch;
            }
            0x82C3D524 => {
    //   block [0x82C3D524..0x82C3D538)
	// 82C3D524: 895D001D  lbz r10, 0x1d(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D528: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D52C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D530: 409A0008  bne cr6, 0x82c3d538
	if !ctx.cr[6].eq {
	pc = 0x82C3D538; continue 'dispatch;
	}
	// 82C3D534: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82C3D538; continue 'dispatch;
            }
            0x82C3D538 => {
    //   block [0x82C3D538..0x82C3D54C)
	// 82C3D538: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3D53C: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D540: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3D544: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D548: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D54C; continue 'dispatch;
            }
            0x82C3D54C => {
    //   block [0x82C3D54C..0x82C3D564)
	// 82C3D54C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D550: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D554: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D558: 409A000C  bne cr6, 0x82c3d564
	if !ctx.cr[6].eq {
	pc = 0x82C3D564; continue 'dispatch;
	}
	// 82C3D55C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3D560: 48000020  b 0x82c3d580
	pc = 0x82C3D580; continue 'dispatch;
            }
            0x82C3D564 => {
    //   block [0x82C3D564..0x82C3D57C)
	// 82C3D564: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D568: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D56C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82C3D570: 409A000C  bne cr6, 0x82c3d57c
	if !ctx.cr[6].eq {
	pc = 0x82C3D57C; continue 'dispatch;
	}
	// 82C3D574: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C3D578: 48000008  b 0x82c3d580
	pc = 0x82C3D580; continue 'dispatch;
            }
            0x82C3D57C => {
    //   block [0x82C3D57C..0x82C3D580)
	// 82C3D57C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3D580; continue 'dispatch;
            }
            0x82C3D580 => {
    //   block [0x82C3D580..0x82C3D598)
	// 82C3D580: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D584: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3D588: 890B001C  lbz r8, 0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D58C: 893A001C  lbz r9, 0x1c(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D590: 992B001C  stb r9, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 82C3D594: 991A001C  stb r8, 0x1c(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[8].u8 ) };
	pc = 0x82C3D598; continue 'dispatch;
            }
            0x82C3D598 => {
    //   block [0x82C3D598..0x82C3D5B8)
	// 82C3D598: 897A001C  lbz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D59C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C3D5A0: 409A0194  bne cr6, 0x82c3d734
	if !ctx.cr[6].eq {
	pc = 0x82C3D734; continue 'dispatch;
	}
	// 82C3D5A4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D5A8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C3D5AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D5B0: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D5B4: 419A017C  beq cr6, 0x82c3d730
	if ctx.cr[6].eq {
	pc = 0x82C3D730; continue 'dispatch;
	}
	pc = 0x82C3D5B8; continue 'dispatch;
            }
            0x82C3D5B8 => {
    //   block [0x82C3D5B8..0x82C3D5F8)
	// 82C3D5B8: 897D001C  lbz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D5BC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C3D5C0: 409A0170  bne cr6, 0x82c3d730
	if !ctx.cr[6].eq {
	pc = 0x82C3D730; continue 'dispatch;
	}
	// 82C3D5C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D5C8: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3D5CC: 409A00A8  bne cr6, 0x82c3d674
	if !ctx.cr[6].eq {
	pc = 0x82C3D674; continue 'dispatch;
	}
	// 82C3D5D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D5D4: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D5D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D5DC: 409A001C  bne cr6, 0x82c3d5f8
	if !ctx.cr[6].eq {
	pc = 0x82C3D5F8; continue 'dispatch;
	}
	// 82C3D5E0: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D5E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D5E8: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82C3D5EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D5F0: 4BF2D231  bl 0x82b6a820
	ctx.lr = 0x82C3D5F4;
	sub_82B6A820(ctx, base);
	// 82C3D5F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3D5F8; continue 'dispatch;
            }
            0x82C3D5F8 => {
    //   block [0x82C3D5F8..0x82C3D624)
	// 82C3D5F8: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D5FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D600: 409A00C8  bne cr6, 0x82c3d6c8
	if !ctx.cr[6].eq {
	pc = 0x82C3D6C8; continue 'dispatch;
	}
	// 82C3D604: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D608: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D60C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D610: 409A0014  bne cr6, 0x82c3d624
	if !ctx.cr[6].eq {
	pc = 0x82C3D624; continue 'dispatch;
	}
	// 82C3D614: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D618: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D61C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D620: 419A00A4  beq cr6, 0x82c3d6c4
	if ctx.cr[6].eq {
	pc = 0x82C3D6C4; continue 'dispatch;
	}
	pc = 0x82C3D624; continue 'dispatch;
            }
            0x82C3D624 => {
    //   block [0x82C3D624..0x82C3D650)
	// 82C3D624: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D628: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D62C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D630: 409A0020  bne cr6, 0x82c3d650
	if !ctx.cr[6].eq {
	pc = 0x82C3D650; continue 'dispatch;
	}
	// 82C3D634: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D638: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C3D63C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D640: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D644: 9B6B001C  stb r27, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82C3D648: 4BFFE0F1  bl 0x82c3b738
	ctx.lr = 0x82C3D64C;
	sub_82C3B738(ctx, base);
	// 82C3D64C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3D650; continue 'dispatch;
            }
            0x82C3D650 => {
    //   block [0x82C3D650..0x82C3D674)
	// 82C3D650: 895F001C  lbz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D654: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D658: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D65C: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82C3D660: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D664: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D668: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D66C: 4BF2D1B5  bl 0x82b6a820
	ctx.lr = 0x82C3D670;
	sub_82B6A820(ctx, base);
	// 82C3D670: 480000C0  b 0x82c3d730
	pc = 0x82C3D730; continue 'dispatch;
            }
            0x82C3D674 => {
    //   block [0x82C3D674..0x82C3D698)
	// 82C3D674: 894B001C  lbz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D678: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D67C: 409A001C  bne cr6, 0x82c3d698
	if !ctx.cr[6].eq {
	pc = 0x82C3D698; continue 'dispatch;
	}
	// 82C3D680: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D684: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D688: 9B7F001C  stb r27, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82C3D68C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D690: 4BFFE0A9  bl 0x82c3b738
	ctx.lr = 0x82C3D694;
	sub_82C3B738(ctx, base);
	// 82C3D694: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3D698; continue 'dispatch;
            }
            0x82C3D698 => {
    //   block [0x82C3D698..0x82C3D6C4)
	// 82C3D698: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D69C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D6A0: 409A0028  bne cr6, 0x82c3d6c8
	if !ctx.cr[6].eq {
	pc = 0x82C3D6C8; continue 'dispatch;
	}
	// 82C3D6A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D6A8: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D6AC: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D6B0: 409A0034  bne cr6, 0x82c3d6e4
	if !ctx.cr[6].eq {
	pc = 0x82C3D6E4; continue 'dispatch;
	}
	// 82C3D6B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D6B8: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D6BC: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D6C0: 409A0024  bne cr6, 0x82c3d6e4
	if !ctx.cr[6].eq {
	pc = 0x82C3D6E4; continue 'dispatch;
	}
	pc = 0x82C3D6C4; continue 'dispatch;
            }
            0x82C3D6C4 => {
    //   block [0x82C3D6C4..0x82C3D6C8)
	// 82C3D6C4: 9B6B001C  stb r27, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	pc = 0x82C3D6C8; continue 'dispatch;
            }
            0x82C3D6C8 => {
    //   block [0x82C3D6C8..0x82C3D6E4)
	// 82C3D6C8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D6CC: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 82C3D6D0: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D6D4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D6D8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D6DC: 409AFEDC  bne cr6, 0x82c3d5b8
	if !ctx.cr[6].eq {
	pc = 0x82C3D5B8; continue 'dispatch;
	}
	// 82C3D6E0: 48000050  b 0x82c3d730
	pc = 0x82C3D730; continue 'dispatch;
            }
            0x82C3D6E4 => {
    //   block [0x82C3D6E4..0x82C3D710)
	// 82C3D6E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D6E8: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D6EC: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C3D6F0: 409A0020  bne cr6, 0x82c3d710
	if !ctx.cr[6].eq {
	pc = 0x82C3D710; continue 'dispatch;
	}
	// 82C3D6F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D6F8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C3D6FC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D700: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D704: 9B6B001C  stb r27, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82C3D708: 4BF2D119  bl 0x82b6a820
	ctx.lr = 0x82C3D70C;
	sub_82B6A820(ctx, base);
	// 82C3D70C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3D710; continue 'dispatch;
            }
            0x82C3D710 => {
    //   block [0x82C3D710..0x82C3D730)
	// 82C3D710: 895F001C  lbz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3D714: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D718: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D71C: 994B001C  stb r10, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 82C3D720: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D724: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D728: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82C3D72C: 4BFFE00D  bl 0x82c3b738
	ctx.lr = 0x82C3D730;
	sub_82C3B738(ctx, base);
	pc = 0x82C3D730; continue 'dispatch;
            }
            0x82C3D730 => {
    //   block [0x82C3D730..0x82C3D734)
	// 82C3D730: 9BDD001C  stb r30, 0x1c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	pc = 0x82C3D734; continue 'dispatch;
            }
            0x82C3D734 => {
    //   block [0x82C3D734..0x82C3D764)
	// 82C3D734: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C3D738: 4BC08079  bl 0x828457b0
	ctx.lr = 0x82C3D73C;
	sub_828457B0(ctx, base);
	// 82C3D73C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D740: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3D744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D748: 419A001C  beq cr6, 0x82c3d764
	if ctx.cr[6].eq {
	pc = 0x82C3D764; continue 'dispatch;
	}
	// 82C3D74C: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C3D750: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 82C3D754: 913C0008  stw r9, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82C3D758: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82C3D75C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3D760: 4806BCEC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D764 => {
    //   block [0x82C3D764..0x82C3D774)
	// 82C3D764: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82C3D768: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C3D76C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3D770: 4806BCDC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3D778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3D778 size=316
    let mut pc: u32 = 0x82C3D778;
    'dispatch: loop {
        match pc {
            0x82C3D778 => {
    //   block [0x82C3D778..0x82C3D7B0)
	// 82C3D778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3D77C: 4806BC85  bl 0x82ca9400
	ctx.lr = 0x82C3D780;
	sub_82CA93D0(ctx, base);
	// 82C3D780: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3D784: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C3D788: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C3D78C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3D790: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3D794: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82C3D798: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D79C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D7A0: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D7A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D7A8: 409A003C  bne cr6, 0x82c3d7e4
	if !ctx.cr[6].eq {
	pc = 0x82C3D7E4; continue 'dispatch;
	}
	// 82C3D7AC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3D7B0; continue 'dispatch;
            }
            0x82C3D7B0 => {
    //   block [0x82C3D7B0..0x82C3D7D4)
	// 82C3D7B0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3D7B4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C3D7B8: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82C3D7BC: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C3D7C0: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82C3D7C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3D7C8: 419A000C  beq cr6, 0x82c3d7d4
	if ctx.cr[6].eq {
	pc = 0x82C3D7D4; continue 'dispatch;
	}
	// 82C3D7CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D7D0: 48000008  b 0x82c3d7d8
	pc = 0x82C3D7D8; continue 'dispatch;
            }
            0x82C3D7D4 => {
    //   block [0x82C3D7D4..0x82C3D7D8)
	// 82C3D7D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3D7D8; continue 'dispatch;
            }
            0x82C3D7D8 => {
    //   block [0x82C3D7D8..0x82C3D7E4)
	// 82C3D7D8: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3D7DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3D7E0: 419AFFD0  beq cr6, 0x82c3d7b0
	if ctx.cr[6].eq {
	pc = 0x82C3D7B0; continue 'dispatch;
	}
	pc = 0x82C3D7E4; continue 'dispatch;
            }
            0x82C3D7E4 => {
    //   block [0x82C3D7E4..0x82C3D844)
	// 82C3D7E4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C3D7E8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82C3D7EC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C3D7F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D7F4: 419A0054  beq cr6, 0x82c3d848
	if ctx.cr[6].eq {
	pc = 0x82C3D848; continue 'dispatch;
	}
	// 82C3D7F8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D7FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3D800: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D804: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D808: 409A003C  bne cr6, 0x82c3d844
	if !ctx.cr[6].eq {
	pc = 0x82C3D844; continue 'dispatch;
	}
	// 82C3D80C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C3D810: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C3D814: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3D818: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3D81C: 4BFFF6F5  bl 0x82c3cf10
	ctx.lr = 0x82C3D820;
	sub_82C3CF10(ctx, base);
	// 82C3D820: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3D824: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C3D828: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3D82C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D830: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D834: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3D838: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3D83C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D840: 4806BC10  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D844 => {
    //   block [0x82C3D844..0x82C3D848)
	// 82C3D844: 4BBC53CD  bl 0x82802c10
	ctx.lr = 0x82C3D848;
	sub_82802C10(ctx, base);
	pc = 0x82C3D848; continue 'dispatch;
            }
            0x82C3D848 => {
    //   block [0x82C3D848..0x82C3D898)
	// 82C3D848: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3D84C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D850: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3D854: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3D858: 40980040  bge cr6, 0x82c3d898
	if !ctx.cr[6].lt {
	pc = 0x82C3D898; continue 'dispatch;
	}
	// 82C3D85C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C3D860: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C3D864: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C3D868: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3D86C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3D870: 4BFFF6A1  bl 0x82c3cf10
	ctx.lr = 0x82C3D874;
	sub_82C3CF10(ctx, base);
	// 82C3D874: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3D878: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C3D87C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3D880: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D884: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D888: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3D88C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3D890: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D894: 4806BBBC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D898 => {
    //   block [0x82C3D898..0x82C3D8B4)
	// 82C3D898: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3D89C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3D8A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3D8A4: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82C3D8A8: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C3D8AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D8B0: 4806BBA0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3D8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3D8B8 size=232
    let mut pc: u32 = 0x82C3D8B8;
    'dispatch: loop {
        match pc {
            0x82C3D8B8 => {
    //   block [0x82C3D8B8..0x82C3D8F0)
	// 82C3D8B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3D8BC: 4806BB49  bl 0x82ca9404
	ctx.lr = 0x82C3D8C0;
	sub_82CA93D0(ctx, base);
	// 82C3D8C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3D8C4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3D8C8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82C3D8CC: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3D8D0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3D8D4: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C3D8D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D8DC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D8E0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D8E4: 419A000C  beq cr6, 0x82c3d8f0
	if ctx.cr[6].eq {
	pc = 0x82C3D8F0; continue 'dispatch;
	}
	// 82C3D8E8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3D8EC: 419A0008  beq cr6, 0x82c3d8f4
	if ctx.cr[6].eq {
	pc = 0x82C3D8F4; continue 'dispatch;
	}
	pc = 0x82C3D8F0; continue 'dispatch;
            }
            0x82C3D8F0 => {
    //   block [0x82C3D8F0..0x82C3D8F4)
	// 82C3D8F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D8F4; continue 'dispatch;
            }
            0x82C3D8F4 => {
    //   block [0x82C3D8F4..0x82C3D918)
	// 82C3D8F4: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3D8F8: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C3D8FC: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C3D900: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3D904: 409A0044  bne cr6, 0x82c3d948
	if !ctx.cr[6].eq {
	pc = 0x82C3D948; continue 'dispatch;
	}
	// 82C3D908: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C3D90C: 419A000C  beq cr6, 0x82c3d918
	if ctx.cr[6].eq {
	pc = 0x82C3D918; continue 'dispatch;
	}
	// 82C3D910: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3D914: 419A0008  beq cr6, 0x82c3d91c
	if ctx.cr[6].eq {
	pc = 0x82C3D91C; continue 'dispatch;
	}
	pc = 0x82C3D918; continue 'dispatch;
            }
            0x82C3D918 => {
    //   block [0x82C3D918..0x82C3D91C)
	// 82C3D918: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D91C; continue 'dispatch;
            }
            0x82C3D91C => {
    //   block [0x82C3D91C..0x82C3D948)
	// 82C3D91C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3D920: 409A0028  bne cr6, 0x82c3d948
	if !ctx.cr[6].eq {
	pc = 0x82C3D948; continue 'dispatch;
	}
	// 82C3D924: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3D928: 4BFFE689  bl 0x82c3bfb0
	ctx.lr = 0x82C3D92C;
	sub_82C3BFB0(ctx, base);
	// 82C3D92C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D930: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C3D934: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D938: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D93C: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3D940: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D944: 4806BB10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D948 => {
    //   block [0x82C3D948..0x82C3D958)
	// 82C3D948: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3D94C: 419A000C  beq cr6, 0x82c3d958
	if ctx.cr[6].eq {
	pc = 0x82C3D958; continue 'dispatch;
	}
	// 82C3D950: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3D954: 419A0008  beq cr6, 0x82c3d95c
	if ctx.cr[6].eq {
	pc = 0x82C3D95C; continue 'dispatch;
	}
	pc = 0x82C3D958; continue 'dispatch;
            }
            0x82C3D958 => {
    //   block [0x82C3D958..0x82C3D95C)
	// 82C3D958: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3D95C; continue 'dispatch;
            }
            0x82C3D95C => {
    //   block [0x82C3D95C..0x82C3D990)
	// 82C3D95C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3D960: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C3D964: 419A002C  beq cr6, 0x82c3d990
	if ctx.cr[6].eq {
	pc = 0x82C3D990; continue 'dispatch;
	}
	// 82C3D968: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82C3D96C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3D970: 4BE5EBA9  bl 0x82a9c518
	ctx.lr = 0x82C3D974;
	sub_82A9C518(ctx, base);
	// 82C3D974: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C3D978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3D97C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3D980: 4BFFF9C9  bl 0x82c3d348
	ctx.lr = 0x82C3D984;
	sub_82C3D348(ctx, base);
	// 82C3D984: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82C3D988: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3D98C: 4BFFFFBC  b 0x82c3d948
	pc = 0x82C3D948; continue 'dispatch;
            }
            0x82C3D990 => {
    //   block [0x82C3D990..0x82C3D9A0)
	// 82C3D990: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82C3D994: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3D998: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D99C: 4806BAB8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3D9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3D9A0 size=524
    let mut pc: u32 = 0x82C3D9A0;
    'dispatch: loop {
        match pc {
            0x82C3D9A0 => {
    //   block [0x82C3D9A0..0x82C3D9E8)
	// 82C3D9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3D9A4: 4806BA61  bl 0x82ca9404
	ctx.lr = 0x82C3D9A8;
	sub_82CA93D0(ctx, base);
	// 82C3D9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3D9AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3D9B0: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3D9B4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3D9B8: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C3D9BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C3D9C0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3D9C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D9C8: 409A0020  bne cr6, 0x82c3d9e8
	if !ctx.cr[6].eq {
	pc = 0x82C3D9E8; continue 'dispatch;
	}
	// 82C3D9CC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3D9D0: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D9D4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3D9D8: 4BFFF539  bl 0x82c3cf10
	ctx.lr = 0x82C3D9DC;
	sub_82C3CF10(ctx, base);
	// 82C3D9DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3D9E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3D9E4: 4806BA70  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3D9E8 => {
    //   block [0x82C3D9E8..0x82C3DA04)
	// 82C3D9E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3D9EC: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3D9F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3D9F4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3D9F8: 419A000C  beq cr6, 0x82c3da04
	if ctx.cr[6].eq {
	pc = 0x82C3DA04; continue 'dispatch;
	}
	// 82C3D9FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3DA00: 419A0008  beq cr6, 0x82c3da08
	if ctx.cr[6].eq {
	pc = 0x82C3DA08; continue 'dispatch;
	}
	pc = 0x82C3DA04; continue 'dispatch;
            }
            0x82C3DA04 => {
    //   block [0x82C3DA04..0x82C3DA08)
	// 82C3DA04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3DA08; continue 'dispatch;
            }
            0x82C3DA08 => {
    //   block [0x82C3DA08..0x82C3DA48)
	// 82C3DA08: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3DA0C: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3DA10: 409A0038  bne cr6, 0x82c3da48
	if !ctx.cr[6].eq {
	pc = 0x82C3DA48; continue 'dispatch;
	}
	// 82C3DA14: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DA18: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DA1C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DA20: 4098015C  bge cr6, 0x82c3db7c
	if !ctx.cr[6].lt {
	pc = 0x82C3DB7C; continue 'dispatch;
	}
	// 82C3DA24: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3DA28: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C3DA2C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3DA30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3DA34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DA38: 4BFFF4D9  bl 0x82c3cf10
	ctx.lr = 0x82C3DA3C;
	sub_82C3CF10(ctx, base);
	// 82C3DA3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DA40: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DA44: 4806BA10  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3DA48 => {
    //   block [0x82C3DA48..0x82C3DA58)
	// 82C3DA48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3DA4C: 419A000C  beq cr6, 0x82c3da58
	if ctx.cr[6].eq {
	pc = 0x82C3DA58; continue 'dispatch;
	}
	// 82C3DA50: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3DA54: 419A0008  beq cr6, 0x82c3da5c
	if ctx.cr[6].eq {
	pc = 0x82C3DA5C; continue 'dispatch;
	}
	pc = 0x82C3DA58; continue 'dispatch;
            }
            0x82C3DA58 => {
    //   block [0x82C3DA58..0x82C3DA5C)
	// 82C3DA58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3DA5C; continue 'dispatch;
            }
            0x82C3DA5C => {
    //   block [0x82C3DA5C..0x82C3DA98)
	// 82C3DA5C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DA60: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DA64: 409A0034  bne cr6, 0x82c3da98
	if !ctx.cr[6].eq {
	pc = 0x82C3DA98; continue 'dispatch;
	}
	// 82C3DA68: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3DA6C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DA70: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3DA74: 40980108  bge cr6, 0x82c3db7c
	if !ctx.cr[6].lt {
	pc = 0x82C3DB7C; continue 'dispatch;
	}
	// 82C3DA78: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3DA7C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3DA80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3DA84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DA88: 4BFFF489  bl 0x82c3cf10
	ctx.lr = 0x82C3DA8C;
	sub_82C3CF10(ctx, base);
	// 82C3DA8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DA90: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DA94: 4806B9C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3DA98 => {
    //   block [0x82C3DA98..0x82C3DAE4)
	// 82C3DA98: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DA9C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DAA0: 40980058  bge cr6, 0x82c3daf8
	if !ctx.cr[6].lt {
	pc = 0x82C3DAF8; continue 'dispatch;
	}
	// 82C3DAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3DAA8: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C3DAAC: 4BBC5165  bl 0x82802c10
	ctx.lr = 0x82C3DAB0;
	sub_82802C10(ctx, base);
	// 82C3DAB0: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3DAB4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DAB8: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DABC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3DAC0: 40980038  bge cr6, 0x82c3daf8
	if !ctx.cr[6].lt {
	pc = 0x82C3DAF8; continue 'dispatch;
	}
	// 82C3DAC4: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3DAC8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3DACC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3DAD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DAD4: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3DAD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3DADC: 409A008C  bne cr6, 0x82c3db68
	if !ctx.cr[6].eq {
	pc = 0x82C3DB68; continue 'dispatch;
	}
	// 82C3DAE0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C3DAE4; continue 'dispatch;
            }
            0x82C3DAE4 => {
    //   block [0x82C3DAE4..0x82C3DAF8)
	// 82C3DAE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3DAE8: 4BFFF429  bl 0x82c3cf10
	ctx.lr = 0x82C3DAEC;
	sub_82C3CF10(ctx, base);
	// 82C3DAEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DAF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DAF4: 4806B960  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3DAF8 => {
    //   block [0x82C3DAF8..0x82C3DB28)
	// 82C3DAF8: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DAFC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3DB00: 4098007C  bge cr6, 0x82c3db7c
	if !ctx.cr[6].lt {
	pc = 0x82C3DB7C; continue 'dispatch;
	}
	// 82C3DB04: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3DB08: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C3DB0C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DB10: 4BE5EA09  bl 0x82a9c518
	ctx.lr = 0x82C3DB14;
	sub_82A9C518(ctx, base);
	// 82C3DB14: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3DB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3DB1C: 419A000C  beq cr6, 0x82c3db28
	if ctx.cr[6].eq {
	pc = 0x82C3DB28; continue 'dispatch;
	}
	// 82C3DB20: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3DB24: 419A0008  beq cr6, 0x82c3db2c
	if ctx.cr[6].eq {
	pc = 0x82C3DB2C; continue 'dispatch;
	}
	pc = 0x82C3DB28; continue 'dispatch;
            }
            0x82C3DB28 => {
    //   block [0x82C3DB28..0x82C3DB2C)
	// 82C3DB28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3DB2C; continue 'dispatch;
            }
            0x82C3DB2C => {
    //   block [0x82C3DB2C..0x82C3DB48)
	// 82C3DB2C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3DB30: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C3DB34: 419A0014  beq cr6, 0x82c3db48
	if ctx.cr[6].eq {
	pc = 0x82C3DB48; continue 'dispatch;
	}
	// 82C3DB38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DB3C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DB40: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DB44: 40980038  bge cr6, 0x82c3db7c
	if !ctx.cr[6].lt {
	pc = 0x82C3DB7C; continue 'dispatch;
	}
	pc = 0x82C3DB48; continue 'dispatch;
            }
            0x82C3DB48 => {
    //   block [0x82C3DB48..0x82C3DB68)
	// 82C3DB48: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3DB4C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3DB50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3DB54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DB58: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3DB5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3DB60: 419AFF84  beq cr6, 0x82c3dae4
	if ctx.cr[6].eq {
	pc = 0x82C3DAE4; continue 'dispatch;
	}
	// 82C3DB64: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C3DB68; continue 'dispatch;
            }
            0x82C3DB68 => {
    //   block [0x82C3DB68..0x82C3DB7C)
	// 82C3DB68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3DB6C: 4BFFF3A5  bl 0x82c3cf10
	ctx.lr = 0x82C3DB70;
	sub_82C3CF10(ctx, base);
	// 82C3DB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DB74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DB78: 4806B8DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3DB7C => {
    //   block [0x82C3DB7C..0x82C3DBAC)
	// 82C3DB7C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C3DB80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3DB84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3DB88: 4BFFFBF1  bl 0x82c3d778
	ctx.lr = 0x82C3DB8C;
	sub_82C3D778(ctx, base);
	// 82C3DB8C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3DB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3DB94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DB98: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3DB9C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DBA0: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3DBA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DBA8: 4806B8AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3DBB0 size=252
    let mut pc: u32 = 0x82C3DBB0;
    'dispatch: loop {
        match pc {
            0x82C3DBB0 => {
    //   block [0x82C3DBB0..0x82C3DBD8)
	// 82C3DBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DBB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3DBB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3DBBC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82C3DBC0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DBC4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DBC8: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3DBCC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3DBD0: 409A0030  bne cr6, 0x82c3dc00
	if !ctx.cr[6].eq {
	pc = 0x82C3DC00; continue 'dispatch;
	}
	// 82C3DBD4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3DBD8; continue 'dispatch;
            }
            0x82C3DBD8 => {
    //   block [0x82C3DBD8..0x82C3DBEC)
	// 82C3DBD8: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DBDC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3DBE0: 4098000C  bge cr6, 0x82c3dbec
	if !ctx.cr[6].lt {
	pc = 0x82C3DBEC; continue 'dispatch;
	}
	// 82C3DBE4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3DBE8: 4800000C  b 0x82c3dbf4
	pc = 0x82C3DBF4; continue 'dispatch;
            }
            0x82C3DBEC => {
    //   block [0x82C3DBEC..0x82C3DBF4)
	// 82C3DBEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3DBF0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3DBF4; continue 'dispatch;
            }
            0x82C3DBF4 => {
    //   block [0x82C3DBF4..0x82C3DC00)
	// 82C3DBF4: 88EB001D  lbz r7, 0x1d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82C3DBF8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C3DBFC: 419AFFDC  beq cr6, 0x82c3dbd8
	if ctx.cr[6].eq {
	pc = 0x82C3DBD8; continue 'dispatch;
	}
	pc = 0x82C3DC00; continue 'dispatch;
            }
            0x82C3DC00 => {
    //   block [0x82C3DC00..0x82C3DC28)
	// 82C3DC00: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DC04: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C3DC08: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C3DC0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C3DC10: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3DC14: 419A0014  beq cr6, 0x82c3dc28
	if ctx.cr[6].eq {
	pc = 0x82C3DC28; continue 'dispatch;
	}
	// 82C3DC18: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DC1C: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DC20: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C3DC24: 40980058  bge cr6, 0x82c3dc7c
	if !ctx.cr[6].lt {
	pc = 0x82C3DC7C; continue 'dispatch;
	}
	pc = 0x82C3DC28; continue 'dispatch;
            }
            0x82C3DC28 => {
    //   block [0x82C3DC28..0x82C3DC7C)
	// 82C3DC28: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 82C3DC2C: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DC30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3DC34: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3DC38: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C3DC3C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82C3DC40: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3DC44: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C3DC48: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3DC4C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3DC50: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C3DC54: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C3DC58: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C3DC5C: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82C3DC60: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82C3DC64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C3DC68: 4BFFFD39  bl 0x82c3d9a0
	ctx.lr = 0x82C3DC6C;
	sub_82C3D9A0(ctx, base);
	// 82C3DC6C: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C3DC70: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82C3DC74: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3DC78: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82C3DC7C; continue 'dispatch;
            }
            0x82C3DC7C => {
    //   block [0x82C3DC7C..0x82C3DC88)
	// 82C3DC7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3DC80: 409A0008  bne cr6, 0x82c3dc88
	if !ctx.cr[6].eq {
	pc = 0x82C3DC88; continue 'dispatch;
	}
	// 82C3DC84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3DC88; continue 'dispatch;
            }
            0x82C3DC88 => {
    //   block [0x82C3DC88..0x82C3DC98)
	// 82C3DC88: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DC8C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DC90: 409A0008  bne cr6, 0x82c3dc98
	if !ctx.cr[6].eq {
	pc = 0x82C3DC98; continue 'dispatch;
	}
	// 82C3DC94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3DC98; continue 'dispatch;
            }
            0x82C3DC98 => {
    //   block [0x82C3DC98..0x82C3DCAC)
	// 82C3DC98: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82C3DC9C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3DCA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3DCA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3DCA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DCB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3DCB0 size=200
    let mut pc: u32 = 0x82C3DCB0;
    'dispatch: loop {
        match pc {
            0x82C3DCB0 => {
    //   block [0x82C3DCB0..0x82C3DCF4)
	// 82C3DCB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DCB4: 4806B74D  bl 0x82ca9400
	ctx.lr = 0x82C3DCB8;
	sub_82CA93D0(ctx, base);
	// 82C3DCB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3DCBC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DCC0: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3DCC4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3DCC8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3DCCC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82C3DCD0: 388A4F80  addi r4, r10, 0x4f80
	ctx.r[4].s64 = ctx.r[10].s64 + 20352;
	// 82C3DCD4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DCD8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3DCDC: 4E800421  bctrl
	ctx.lr = 0x82C3DCE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3DCE0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C3DCE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3DCE8: 409A000C  bne cr6, 0x82c3dcf4
	if !ctx.cr[6].eq {
	pc = 0x82C3DCF4; continue 'dispatch;
	}
	// 82C3DCEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DCF0: 4806B760  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3DCF4 => {
    //   block [0x82C3DCF4..0x82C3DD08)
	// 82C3DCF4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DCF8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3DCFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3DD00: 40990058  ble cr6, 0x82c3dd58
	if !ctx.cr[6].gt {
	pc = 0x82C3DD58; continue 'dispatch;
	}
	// 82C3DD04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82C3DD08; continue 'dispatch;
            }
            0x82C3DD08 => {
    //   block [0x82C3DD08..0x82C3DD44)
	// 82C3DD08: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DD0C: 815C0028  lwz r10, 0x28(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3DD10: 7FEBF02E  lwzx r31, r11, r30
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82C3DD14: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DD18: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3DD1C: 409A0028  bne cr6, 0x82c3dd44
	if !ctx.cr[6].eq {
	pc = 0x82C3DD44; continue 'dispatch;
	}
	// 82C3DD20: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 82C3DD24: 387C0010  addi r3, r28, 0x10
	ctx.r[3].s64 = ctx.r[28].s64 + 16;
	// 82C3DD28: 4BFFFE89  bl 0x82c3dbb0
	ctx.lr = 0x82C3DD2C;
	sub_82C3DBB0(ctx, base);
	// 82C3DD2C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DD30: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C3DD34: C01F0010  lfs f0, 0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C3DD38: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C3DD3C: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C3DD40: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82C3DD44; continue 'dispatch;
            }
            0x82C3DD44 => {
    //   block [0x82C3DD44..0x82C3DD58)
	// 82C3DD44: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DD48: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C3DD4C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C3DD50: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3DD54: 4198FFB4  blt cr6, 0x82c3dd08
	if ctx.cr[6].lt {
	pc = 0x82C3DD08; continue 'dispatch;
	}
	pc = 0x82C3DD58; continue 'dispatch;
            }
            0x82C3DD58 => {
    //   block [0x82C3DD58..0x82C3DD78)
	// 82C3DD58: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DD5C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3DD60: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3DD64: 556997FE  rlwinm r9, r11, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 82C3DD68: 995C0031  stb r10, 0x31(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(49 as u32), ctx.r[10].u8 ) };
	// 82C3DD6C: 993C0030  stb r9, 0x30(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(48 as u32), ctx.r[9].u8 ) };
	// 82C3DD70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3DD74: 4806B6DC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DD78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3DD78 size=144
    let mut pc: u32 = 0x82C3DD78;
    'dispatch: loop {
        match pc {
            0x82C3DD78 => {
    //   block [0x82C3DD78..0x82C3DE08)
	// 82C3DD78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DD7C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3DD80: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3DD84: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3DD88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3DD8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3DD90: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3DD94: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3DD98: 392BC218  addi r9, r11, -0x3de8
	ctx.r[9].s64 = ctx.r[11].s64 + -15848;
	// 82C3DD9C: 390AB7CC  addi r8, r10, -0x4834
	ctx.r[8].s64 = ctx.r[10].s64 + -18484;
	// 82C3DDA0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3DDA4: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C3DDA8: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C3DDAC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3DDB0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C3DDB4: 4800FCF5  bl 0x82c4daa8
	ctx.lr = 0x82C3DDB8;
	sub_82C4DAA8(ctx, base);
	// 82C3DDB8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C3DDBC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82C3DDC0: 38C7B7CC  addi r6, r7, -0x4834
	ctx.r[6].s64 = ctx.r[7].s64 + -18484;
	// 82C3DDC4: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82C3DDC8: 4BFFE979  bl 0x82c3c740
	ctx.lr = 0x82C3DDCC;
	sub_82C3C740(ctx, base);
	// 82C3DDCC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82C3DDD0: 4BFD8FF1  bl 0x82c16dc0
	ctx.lr = 0x82C3DDD4;
	sub_82C16DC0(ctx, base);
	// 82C3DDD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3DDD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3DDDC: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82C3DDE0: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C3DDE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3DDE8: 997F0030  stb r11, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	// 82C3DDEC: 98BF0031  stb r5, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[5].u8 ) };
	// 82C3DDF0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3DDF4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3DDF8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3DDFC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3DE00: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3DE04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DE08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3DE08 size=136
    let mut pc: u32 = 0x82C3DE08;
    'dispatch: loop {
        match pc {
            0x82C3DE08 => {
    //   block [0x82C3DE08..0x82C3DE48)
	// 82C3DE08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DE0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3DE10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3DE14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3DE18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3DE1C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82C3DE20: FDA01090  fmr f13, f2
	ctx.f[13].f64 = ctx.f[2].f64;
	// 82C3DE24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DE28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3DE2C: 419A0050  beq cr6, 0x82c3de7c
	if ctx.cr[6].eq {
	pc = 0x82C3DE7C; continue 'dispatch;
	}
	// 82C3DE30: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C3DE34: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 82C3DE38: C02B0C14  lfs f1, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C3DE3C: 4098000C  bge cr6, 0x82c3de48
	if !ctx.cr[6].lt {
	pc = 0x82C3DE48; continue 'dispatch;
	}
	// 82C3DE40: EC601828  fsubs f3, f0, f3
	ctx.f[3].f64 = (((ctx.f[0].f64 - ctx.f[3].f64) as f32) as f64);
	// 82C3DE44: 48000010  b 0x82c3de54
	pc = 0x82C3DE54; continue 'dispatch;
            }
            0x82C3DE48 => {
    //   block [0x82C3DE48..0x82C3DE54)
	// 82C3DE48: FF036800  fcmpu cr6, f3, f13
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[13].f64);
	// 82C3DE4C: 40990018  ble cr6, 0x82c3de64
	if !ctx.cr[6].gt {
	pc = 0x82C3DE64; continue 'dispatch;
	}
	// 82C3DE50: EC636828  fsubs f3, f3, f13
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82C3DE54; continue 'dispatch;
            }
            0x82C3DE54 => {
    //   block [0x82C3DE54..0x82C3DE64)
	// 82C3DE54: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3DE58: C05F0010  lfs f2, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C3DE5C: C03F000C  lfs f1, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C3DE60: 48018CA1  bl 0x82c56b00
	ctx.lr = 0x82C3DE64;
	sub_82C56B00(ctx, base);
	pc = 0x82C3DE64; continue 'dispatch;
            }
            0x82C3DE64 => {
    //   block [0x82C3DE64..0x82C3DE7C)
	// 82C3DE64: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DE68: 38A00032  li r5, 0x32
	ctx.r[5].s64 = 50;
	// 82C3DE6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DE70: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3DE74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3DE78: 4E800421  bctrl
	ctx.lr = 0x82C3DE7C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3DE7C => {
    //   block [0x82C3DE7C..0x82C3DE90)
	// 82C3DE7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3DE80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3DE84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3DE88: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3DE8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DE90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3DE90 size=236
    let mut pc: u32 = 0x82C3DE90;
    'dispatch: loop {
        match pc {
            0x82C3DE90 => {
    //   block [0x82C3DE90..0x82C3DF7C)
	// 82C3DE90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DE94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3DE98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3DE9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3DEA0: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3DF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3DF80 size=128
    let mut pc: u32 = 0x82C3DF80;
    'dispatch: loop {
        match pc {
            0x82C3DF80 => {
    //   block [0x82C3DF80..0x82C3DFC4)
	// 82C3DF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3DF84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3DF88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3DF8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3DF90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3DF94: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3DF98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3DF9C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DFA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C3DFA4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3DFA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3DFAC: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C3DFB0: 419A0014  beq cr6, 0x82c3dfc4
	if ctx.cr[6].eq {
	pc = 0x82C3DFC4; continue 'dispatch;
	}
	// 82C3DFB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DFB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3DFBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3DFC0: 4E800421  bctrl
	ctx.lr = 0x82C3DFC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3DFC4 => {
    //   block [0x82C3DFC4..0x82C3E000)
	// 82C3DFC4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3DFC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3DFCC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3DFD0: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C3DFD4: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C3DFD8: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C3DFDC: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C3DFE0: 895E0014  lbz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3DFE4: 995F0014  stb r10, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82C3DFE8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3DFEC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3DFF0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3DFF4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3DFF8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3DFFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E000(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E000 size=156
    let mut pc: u32 = 0x82C3E000;
    'dispatch: loop {
        match pc {
            0x82C3E000 => {
    //   block [0x82C3E000..0x82C3E030)
	// 82C3E000: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E004: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3E008: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3E00C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3E010: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E014: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E018: 3BE3001C  addi r31, r3, 0x1c
	ctx.r[31].s64 = ctx.r[3].s64 + 28;
	// 82C3E01C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3E020: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C3E024: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E028: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E02C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x82C3E030; continue 'dispatch;
            }
            0x82C3E030 => {
    //   block [0x82C3E030..0x82C3E044)
	// 82C3E030: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E038: 419A000C  beq cr6, 0x82c3e044
	if ctx.cr[6].eq {
	pc = 0x82C3E044; continue 'dispatch;
	}
	// 82C3E03C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3E040: 419A0008  beq cr6, 0x82c3e048
	if ctx.cr[6].eq {
	pc = 0x82C3E048; continue 'dispatch;
	}
	pc = 0x82C3E044; continue 'dispatch;
            }
            0x82C3E044 => {
    //   block [0x82C3E044..0x82C3E048)
	// 82C3E044: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E048; continue 'dispatch;
            }
            0x82C3E048 => {
    //   block [0x82C3E048..0x82C3E05C)
	// 82C3E048: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3E04C: 419A0038  beq cr6, 0x82c3e084
	if ctx.cr[6].eq {
	pc = 0x82C3E084; continue 'dispatch;
	}
	// 82C3E050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E054: 409A0008  bne cr6, 0x82c3e05c
	if !ctx.cr[6].eq {
	pc = 0x82C3E05C; continue 'dispatch;
	}
	// 82C3E058: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E05C; continue 'dispatch;
            }
            0x82C3E05C => {
    //   block [0x82C3E05C..0x82C3E06C)
	// 82C3E05C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E060: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E064: 409A0008  bne cr6, 0x82c3e06c
	if !ctx.cr[6].eq {
	pc = 0x82C3E06C; continue 'dispatch;
	}
	// 82C3E068: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E06C; continue 'dispatch;
            }
            0x82C3E06C => {
    //   block [0x82C3E06C..0x82C3E084)
	// 82C3E06C: 9BC90024  stb r30, 0x24(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), ctx.r[30].u8 ) };
	// 82C3E070: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E074: 4BFD4185  bl 0x82c121f8
	ctx.lr = 0x82C3E078;
	sub_82C121F8(ctx, base);
	// 82C3E078: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E07C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E080: 4BFFFFB0  b 0x82c3e030
	pc = 0x82C3E030; continue 'dispatch;
            }
            0x82C3E084 => {
    //   block [0x82C3E084..0x82C3E09C)
	// 82C3E084: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3E088: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3E08C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3E090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3E094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3E098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E0A0 size=236
    let mut pc: u32 = 0x82C3E0A0;
    'dispatch: loop {
        match pc {
            0x82C3E0A0 => {
    //   block [0x82C3E0A0..0x82C3E0BC)
	// 82C3E0A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E0A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3E0A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3E0AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E0B0: 89630031  lbz r11, 0x31(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(49 as u32) ) } as u64;
	// 82C3E0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E0B8: 409A001C  bne cr6, 0x82c3e0d4
	if !ctx.cr[6].eq {
	pc = 0x82C3E0D4; continue 'dispatch;
	}
	pc = 0x82C3E0BC; continue 'dispatch;
            }
            0x82C3E0BC => {
    //   block [0x82C3E0BC..0x82C3E0D4)
	// 82C3E0BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3E0C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3E0C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3E0C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3E0CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3E0D0: 4E800020  blr
	return;
            }
            0x82C3E0D4 => {
    //   block [0x82C3E0D4..0x82C3E0EC)
	// 82C3E0D4: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E0D8: 3BE3001C  addi r31, r3, 0x1c
	ctx.r[31].s64 = ctx.r[3].s64 + 28;
	// 82C3E0DC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C3E0E0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E0E4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E0E8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E0EC; continue 'dispatch;
            }
            0x82C3E0EC => {
    //   block [0x82C3E0EC..0x82C3E100)
	// 82C3E0EC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E0F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E0F4: 419A000C  beq cr6, 0x82c3e100
	if ctx.cr[6].eq {
	pc = 0x82C3E100; continue 'dispatch;
	}
	// 82C3E0F8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3E0FC: 419A0008  beq cr6, 0x82c3e104
	if ctx.cr[6].eq {
	pc = 0x82C3E104; continue 'dispatch;
	}
	pc = 0x82C3E100; continue 'dispatch;
            }
            0x82C3E100 => {
    //   block [0x82C3E100..0x82C3E104)
	// 82C3E100: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E104; continue 'dispatch;
            }
            0x82C3E104 => {
    //   block [0x82C3E104..0x82C3E118)
	// 82C3E104: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E108: 419A006C  beq cr6, 0x82c3e174
	if ctx.cr[6].eq {
	pc = 0x82C3E174; continue 'dispatch;
	}
	// 82C3E10C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E110: 409A0008  bne cr6, 0x82c3e118
	if !ctx.cr[6].eq {
	pc = 0x82C3E118; continue 'dispatch;
	}
	// 82C3E114: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E118; continue 'dispatch;
            }
            0x82C3E118 => {
    //   block [0x82C3E118..0x82C3E128)
	// 82C3E118: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E11C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E120: 409A0008  bne cr6, 0x82c3e128
	if !ctx.cr[6].eq {
	pc = 0x82C3E128; continue 'dispatch;
	}
	// 82C3E124: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E128; continue 'dispatch;
            }
            0x82C3E128 => {
    //   block [0x82C3E128..0x82C3E140)
	// 82C3E128: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E12C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E130: 419A0030  beq cr6, 0x82c3e160
	if ctx.cr[6].eq {
	pc = 0x82C3E160; continue 'dispatch;
	}
	// 82C3E134: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E138: 409A0008  bne cr6, 0x82c3e140
	if !ctx.cr[6].eq {
	pc = 0x82C3E140; continue 'dispatch;
	}
	// 82C3E13C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E140; continue 'dispatch;
            }
            0x82C3E140 => {
    //   block [0x82C3E140..0x82C3E160)
	// 82C3E140: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E144: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E148: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E14C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E150: 4E800421  bctrl
	ctx.lr = 0x82C3E154;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3E154: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3E158: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E15C: 419AFF60  beq cr6, 0x82c3e0bc
	if ctx.cr[6].eq {
	pc = 0x82C3E0BC; continue 'dispatch;
	}
            }
            0x82C3E160 => {
    //   block [0x82C3E160..0x82C3E174)
	// 82C3E160: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E164: 4BFD4095  bl 0x82c121f8
	ctx.lr = 0x82C3E168;
	sub_82C121F8(ctx, base);
	// 82C3E168: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E16C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E170: 4BFFFF7C  b 0x82c3e0ec
	pc = 0x82C3E0EC; continue 'dispatch;
            }
            0x82C3E174 => {
    //   block [0x82C3E174..0x82C3E18C)
	// 82C3E174: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3E178: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3E17C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3E180: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3E184: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3E188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E190 size=200
    let mut pc: u32 = 0x82C3E190;
    'dispatch: loop {
        match pc {
            0x82C3E190 => {
    //   block [0x82C3E190..0x82C3E1C8)
	// 82C3E190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E194: 4806B279  bl 0x82ca940c
	ctx.lr = 0x82C3E198;
	sub_82CA93D0(ctx, base);
	// 82C3E198: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E19C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3E1A0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3E1A4: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C3E1A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E1AC: 419A00A4  beq cr6, 0x82c3e250
	if ctx.cr[6].eq {
	pc = 0x82C3E250; continue 'dispatch;
	}
	// 82C3E1B0: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E1B4: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 82C3E1B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C3E1BC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E1C0: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E1C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E1C8; continue 'dispatch;
            }
            0x82C3E1C8 => {
    //   block [0x82C3E1C8..0x82C3E1DC)
	// 82C3E1C8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E1CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E1D0: 419A000C  beq cr6, 0x82c3e1dc
	if ctx.cr[6].eq {
	pc = 0x82C3E1DC; continue 'dispatch;
	}
	// 82C3E1D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3E1D8: 419A0008  beq cr6, 0x82c3e1e0
	if ctx.cr[6].eq {
	pc = 0x82C3E1E0; continue 'dispatch;
	}
	pc = 0x82C3E1DC; continue 'dispatch;
            }
            0x82C3E1DC => {
    //   block [0x82C3E1DC..0x82C3E1E0)
	// 82C3E1DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E1E0; continue 'dispatch;
            }
            0x82C3E1E0 => {
    //   block [0x82C3E1E0..0x82C3E1F4)
	// 82C3E1E0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E1E4: 419A0064  beq cr6, 0x82c3e248
	if ctx.cr[6].eq {
	pc = 0x82C3E248; continue 'dispatch;
	}
	// 82C3E1E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E1EC: 409A0008  bne cr6, 0x82c3e1f4
	if !ctx.cr[6].eq {
	pc = 0x82C3E1F4; continue 'dispatch;
	}
	// 82C3E1F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E1F4; continue 'dispatch;
            }
            0x82C3E1F4 => {
    //   block [0x82C3E1F4..0x82C3E204)
	// 82C3E1F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E1F8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E1FC: 409A0008  bne cr6, 0x82c3e204
	if !ctx.cr[6].eq {
	pc = 0x82C3E204; continue 'dispatch;
	}
	// 82C3E200: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E204; continue 'dispatch;
            }
            0x82C3E204 => {
    //   block [0x82C3E204..0x82C3E21C)
	// 82C3E204: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E208: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E20C: 419A0028  beq cr6, 0x82c3e234
	if ctx.cr[6].eq {
	pc = 0x82C3E234; continue 'dispatch;
	}
	// 82C3E210: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E214: 409A0008  bne cr6, 0x82c3e21c
	if !ctx.cr[6].eq {
	pc = 0x82C3E21C; continue 'dispatch;
	}
	// 82C3E218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E21C; continue 'dispatch;
            }
            0x82C3E21C => {
    //   block [0x82C3E21C..0x82C3E234)
	// 82C3E21C: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E220: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3E224: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E228: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3E22C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E230: 4E800421  bctrl
	ctx.lr = 0x82C3E234;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3E234 => {
    //   block [0x82C3E234..0x82C3E248)
	// 82C3E234: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E238: 4BFD3FC1  bl 0x82c121f8
	ctx.lr = 0x82C3E23C;
	sub_82C121F8(ctx, base);
	// 82C3E23C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E240: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E244: 4BFFFF84  b 0x82c3e1c8
	pc = 0x82C3E1C8; continue 'dispatch;
            }
            0x82C3E248 => {
    //   block [0x82C3E248..0x82C3E250)
	// 82C3E248: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3E24C: 997E0030  stb r11, 0x30(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	pc = 0x82C3E250; continue 'dispatch;
            }
            0x82C3E250 => {
    //   block [0x82C3E250..0x82C3E258)
	// 82C3E250: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3E254: 4806B208  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E258 size=200
    let mut pc: u32 = 0x82C3E258;
    'dispatch: loop {
        match pc {
            0x82C3E258 => {
    //   block [0x82C3E258..0x82C3E290)
	// 82C3E258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E25C: 4806B1B1  bl 0x82ca940c
	ctx.lr = 0x82C3E260;
	sub_82CA93D0(ctx, base);
	// 82C3E260: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3E268: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3E26C: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C3E270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E274: 409A00A4  bne cr6, 0x82c3e318
	if !ctx.cr[6].eq {
	pc = 0x82C3E318; continue 'dispatch;
	}
	// 82C3E278: 815E0020  lwz r10, 0x20(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E27C: 3BFE001C  addi r31, r30, 0x1c
	ctx.r[31].s64 = ctx.r[30].s64 + 28;
	// 82C3E280: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82C3E284: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E288: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E28C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E290; continue 'dispatch;
            }
            0x82C3E290 => {
    //   block [0x82C3E290..0x82C3E2A4)
	// 82C3E290: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E298: 419A000C  beq cr6, 0x82c3e2a4
	if ctx.cr[6].eq {
	pc = 0x82C3E2A4; continue 'dispatch;
	}
	// 82C3E29C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3E2A0: 419A0008  beq cr6, 0x82c3e2a8
	if ctx.cr[6].eq {
	pc = 0x82C3E2A8; continue 'dispatch;
	}
	pc = 0x82C3E2A4; continue 'dispatch;
            }
            0x82C3E2A4 => {
    //   block [0x82C3E2A4..0x82C3E2A8)
	// 82C3E2A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E2A8; continue 'dispatch;
            }
            0x82C3E2A8 => {
    //   block [0x82C3E2A8..0x82C3E2BC)
	// 82C3E2A8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E2AC: 419A0064  beq cr6, 0x82c3e310
	if ctx.cr[6].eq {
	pc = 0x82C3E310; continue 'dispatch;
	}
	// 82C3E2B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E2B4: 409A0008  bne cr6, 0x82c3e2bc
	if !ctx.cr[6].eq {
	pc = 0x82C3E2BC; continue 'dispatch;
	}
	// 82C3E2B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E2BC; continue 'dispatch;
            }
            0x82C3E2BC => {
    //   block [0x82C3E2BC..0x82C3E2CC)
	// 82C3E2BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E2C0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E2C4: 409A0008  bne cr6, 0x82c3e2cc
	if !ctx.cr[6].eq {
	pc = 0x82C3E2CC; continue 'dispatch;
	}
	// 82C3E2C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E2CC; continue 'dispatch;
            }
            0x82C3E2CC => {
    //   block [0x82C3E2CC..0x82C3E2E4)
	// 82C3E2CC: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E2D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E2D4: 419A0028  beq cr6, 0x82c3e2fc
	if ctx.cr[6].eq {
	pc = 0x82C3E2FC; continue 'dispatch;
	}
	// 82C3E2D8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E2DC: 409A0008  bne cr6, 0x82c3e2e4
	if !ctx.cr[6].eq {
	pc = 0x82C3E2E4; continue 'dispatch;
	}
	// 82C3E2E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E2E4; continue 'dispatch;
            }
            0x82C3E2E4 => {
    //   block [0x82C3E2E4..0x82C3E2FC)
	// 82C3E2E4: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E2E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3E2EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E2F0: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C3E2F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E2F8: 4E800421  bctrl
	ctx.lr = 0x82C3E2FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3E2FC => {
    //   block [0x82C3E2FC..0x82C3E310)
	// 82C3E2FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E300: 4BFD3EF9  bl 0x82c121f8
	ctx.lr = 0x82C3E304;
	sub_82C121F8(ctx, base);
	// 82C3E304: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E308: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E30C: 4BFFFF84  b 0x82c3e290
	pc = 0x82C3E290; continue 'dispatch;
            }
            0x82C3E310 => {
    //   block [0x82C3E310..0x82C3E318)
	// 82C3E310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C3E314: 997E0030  stb r11, 0x30(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[11].u8 ) };
	pc = 0x82C3E318; continue 'dispatch;
            }
            0x82C3E318 => {
    //   block [0x82C3E318..0x82C3E320)
	// 82C3E318: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3E31C: 4806B140  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E320 size=260
    let mut pc: u32 = 0x82C3E320;
    'dispatch: loop {
        match pc {
            0x82C3E320 => {
    //   block [0x82C3E320..0x82C3E360)
	// 82C3E320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E324: 4806B0DD  bl 0x82ca9400
	ctx.lr = 0x82C3E328;
	sub_82CA93D0(ctx, base);
	// 82C3E328: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E32C: 89630031  lbz r11, 0x31(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(49 as u32) ) } as u64;
	// 82C3E330: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C3E334: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E338: 409A00E4  bne cr6, 0x82c3e41c
	if !ctx.cr[6].eq {
	pc = 0x82C3E41C; continue 'dispatch;
	}
	// 82C3E33C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C3E340: 3B83001C  addi r28, r3, 0x1c
	ctx.r[28].s64 = ctx.r[3].s64 + 28;
	// 82C3E344: 99630031  stb r11, 0x31(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(49 as u32), ctx.r[11].u8 ) };
	// 82C3E348: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3E34C: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E350: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82C3E354: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82C3E358: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E35C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	pc = 0x82C3E360; continue 'dispatch;
            }
            0x82C3E360 => {
    //   block [0x82C3E360..0x82C3E374)
	// 82C3E360: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E364: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3E368: 419A000C  beq cr6, 0x82c3e374
	if ctx.cr[6].eq {
	pc = 0x82C3E374; continue 'dispatch;
	}
	// 82C3E36C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C3E370: 419A0008  beq cr6, 0x82c3e378
	if ctx.cr[6].eq {
	pc = 0x82C3E378; continue 'dispatch;
	}
	pc = 0x82C3E374; continue 'dispatch;
            }
            0x82C3E374 => {
    //   block [0x82C3E374..0x82C3E378)
	// 82C3E374: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E378; continue 'dispatch;
            }
            0x82C3E378 => {
    //   block [0x82C3E378..0x82C3E38C)
	// 82C3E378: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E37C: 419A00A0  beq cr6, 0x82c3e41c
	if ctx.cr[6].eq {
	pc = 0x82C3E41C; continue 'dispatch;
	}
	// 82C3E380: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3E384: 409A0008  bne cr6, 0x82c3e38c
	if !ctx.cr[6].eq {
	pc = 0x82C3E38C; continue 'dispatch;
	}
	// 82C3E388: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E38C; continue 'dispatch;
            }
            0x82C3E38C => {
    //   block [0x82C3E38C..0x82C3E39C)
	// 82C3E38C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E390: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E394: 409A0008  bne cr6, 0x82c3e39c
	if !ctx.cr[6].eq {
	pc = 0x82C3E39C; continue 'dispatch;
	}
	// 82C3E398: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E39C; continue 'dispatch;
            }
            0x82C3E39C => {
    //   block [0x82C3E39C..0x82C3E3B8)
	// 82C3E39C: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E3A0: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82C3E3A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3E3A8: 419A0060  beq cr6, 0x82c3e408
	if ctx.cr[6].eq {
	pc = 0x82C3E408; continue 'dispatch;
	}
	// 82C3E3AC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E3B0: 409A0008  bne cr6, 0x82c3e3b8
	if !ctx.cr[6].eq {
	pc = 0x82C3E3B8; continue 'dispatch;
	}
	// 82C3E3B4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E3B8; continue 'dispatch;
            }
            0x82C3E3B8 => {
    //   block [0x82C3E3B8..0x82C3E3E4)
	// 82C3E3B8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E3BC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3E3C0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3E3C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E3C8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E3CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E3D0: 4E800421  bctrl
	ctx.lr = 0x82C3E3D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3E3D4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E3D8: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E3DC: 409A0008  bne cr6, 0x82c3e3e4
	if !ctx.cr[6].eq {
	pc = 0x82C3E3E4; continue 'dispatch;
	}
	// 82C3E3E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x82C3E3E4 => {
    //   block [0x82C3E3E4..0x82C3E400)
	// 82C3E3E4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E3E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3E3EC: 419A0014  beq cr6, 0x82c3e400
	if ctx.cr[6].eq {
	pc = 0x82C3E400; continue 'dispatch;
	}
	// 82C3E3F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E3F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E3F8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E3FC: 4E800421  bctrl
	ctx.lr = 0x82C3E400;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3E400 => {
    //   block [0x82C3E400..0x82C3E408)
	// 82C3E400: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3E404: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	pc = 0x82C3E408; continue 'dispatch;
            }
            0x82C3E408 => {
    //   block [0x82C3E408..0x82C3E41C)
	// 82C3E408: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E40C: 4BFD3DED  bl 0x82c121f8
	ctx.lr = 0x82C3E410;
	sub_82C121F8(ctx, base);
	// 82C3E410: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E414: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E418: 4BFFFF48  b 0x82c3e360
	pc = 0x82C3E360; continue 'dispatch;
            }
            0x82C3E41C => {
    //   block [0x82C3E41C..0x82C3E424)
	// 82C3E41C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3E420: 4806B030  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E428 size=188
    let mut pc: u32 = 0x82C3E428;
    'dispatch: loop {
        match pc {
            0x82C3E428 => {
    //   block [0x82C3E428..0x82C3E45C)
	// 82C3E428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E42C: 4806AFE1  bl 0x82ca940c
	ctx.lr = 0x82C3E430;
	sub_82CA93D0(ctx, base);
	// 82C3E430: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3E438: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3E43C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C3E440: 48017F89  bl 0x82c563c8
	ctx.lr = 0x82C3E444;
	sub_82C563C8(ctx, base);
	// 82C3E444: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E448: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82C3E44C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82C3E450: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E454: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E458: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E45C; continue 'dispatch;
            }
            0x82C3E45C => {
    //   block [0x82C3E45C..0x82C3E470)
	// 82C3E45C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E460: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E464: 419A000C  beq cr6, 0x82c3e470
	if ctx.cr[6].eq {
	pc = 0x82C3E470; continue 'dispatch;
	}
	// 82C3E468: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3E46C: 419A0008  beq cr6, 0x82c3e474
	if ctx.cr[6].eq {
	pc = 0x82C3E474; continue 'dispatch;
	}
	pc = 0x82C3E470; continue 'dispatch;
            }
            0x82C3E470 => {
    //   block [0x82C3E470..0x82C3E474)
	// 82C3E470: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E474; continue 'dispatch;
            }
            0x82C3E474 => {
    //   block [0x82C3E474..0x82C3E488)
	// 82C3E474: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E478: 419A0064  beq cr6, 0x82c3e4dc
	if ctx.cr[6].eq {
	pc = 0x82C3E4DC; continue 'dispatch;
	}
	// 82C3E47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E480: 409A0008  bne cr6, 0x82c3e488
	if !ctx.cr[6].eq {
	pc = 0x82C3E488; continue 'dispatch;
	}
	// 82C3E484: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E488; continue 'dispatch;
            }
            0x82C3E488 => {
    //   block [0x82C3E488..0x82C3E498)
	// 82C3E488: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E48C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E490: 409A0008  bne cr6, 0x82c3e498
	if !ctx.cr[6].eq {
	pc = 0x82C3E498; continue 'dispatch;
	}
	// 82C3E494: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E498; continue 'dispatch;
            }
            0x82C3E498 => {
    //   block [0x82C3E498..0x82C3E4B0)
	// 82C3E498: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E49C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E4A0: 419A0028  beq cr6, 0x82c3e4c8
	if ctx.cr[6].eq {
	pc = 0x82C3E4C8; continue 'dispatch;
	}
	// 82C3E4A4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E4A8: 409A0008  bne cr6, 0x82c3e4b0
	if !ctx.cr[6].eq {
	pc = 0x82C3E4B0; continue 'dispatch;
	}
	// 82C3E4AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E4B0; continue 'dispatch;
            }
            0x82C3E4B0 => {
    //   block [0x82C3E4B0..0x82C3E4C8)
	// 82C3E4B0: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E4B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3E4B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E4BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E4C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E4C4: 4E800421  bctrl
	ctx.lr = 0x82C3E4C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3E4C8 => {
    //   block [0x82C3E4C8..0x82C3E4DC)
	// 82C3E4C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E4CC: 4BFD3D2D  bl 0x82c121f8
	ctx.lr = 0x82C3E4D0;
	sub_82C121F8(ctx, base);
	// 82C3E4D0: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E4D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E4D8: 4BFFFF84  b 0x82c3e45c
	pc = 0x82C3E45C; continue 'dispatch;
            }
            0x82C3E4DC => {
    //   block [0x82C3E4DC..0x82C3E4E4)
	// 82C3E4DC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3E4E0: 4806AF7C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E4E8 size=188
    let mut pc: u32 = 0x82C3E4E8;
    'dispatch: loop {
        match pc {
            0x82C3E4E8 => {
    //   block [0x82C3E4E8..0x82C3E51C)
	// 82C3E4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E4EC: 4806AF21  bl 0x82ca940c
	ctx.lr = 0x82C3E4F0;
	sub_82CA93D0(ctx, base);
	// 82C3E4F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E4F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3E4F8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3E4FC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C3E500: 48018241  bl 0x82c56740
	ctx.lr = 0x82C3E504;
	sub_82C56740(ctx, base);
	// 82C3E504: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E508: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82C3E50C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82C3E510: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E514: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E518: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E51C; continue 'dispatch;
            }
            0x82C3E51C => {
    //   block [0x82C3E51C..0x82C3E530)
	// 82C3E51C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E520: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E524: 419A000C  beq cr6, 0x82c3e530
	if ctx.cr[6].eq {
	pc = 0x82C3E530; continue 'dispatch;
	}
	// 82C3E528: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3E52C: 419A0008  beq cr6, 0x82c3e534
	if ctx.cr[6].eq {
	pc = 0x82C3E534; continue 'dispatch;
	}
	pc = 0x82C3E530; continue 'dispatch;
            }
            0x82C3E530 => {
    //   block [0x82C3E530..0x82C3E534)
	// 82C3E530: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E534; continue 'dispatch;
            }
            0x82C3E534 => {
    //   block [0x82C3E534..0x82C3E548)
	// 82C3E534: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E538: 419A0064  beq cr6, 0x82c3e59c
	if ctx.cr[6].eq {
	pc = 0x82C3E59C; continue 'dispatch;
	}
	// 82C3E53C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E540: 409A0008  bne cr6, 0x82c3e548
	if !ctx.cr[6].eq {
	pc = 0x82C3E548; continue 'dispatch;
	}
	// 82C3E544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E548; continue 'dispatch;
            }
            0x82C3E548 => {
    //   block [0x82C3E548..0x82C3E558)
	// 82C3E548: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E54C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E550: 409A0008  bne cr6, 0x82c3e558
	if !ctx.cr[6].eq {
	pc = 0x82C3E558; continue 'dispatch;
	}
	// 82C3E554: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E558; continue 'dispatch;
            }
            0x82C3E558 => {
    //   block [0x82C3E558..0x82C3E570)
	// 82C3E558: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E55C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E560: 419A0028  beq cr6, 0x82c3e588
	if ctx.cr[6].eq {
	pc = 0x82C3E588; continue 'dispatch;
	}
	// 82C3E564: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E568: 409A0008  bne cr6, 0x82c3e570
	if !ctx.cr[6].eq {
	pc = 0x82C3E570; continue 'dispatch;
	}
	// 82C3E56C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E570; continue 'dispatch;
            }
            0x82C3E570 => {
    //   block [0x82C3E570..0x82C3E588)
	// 82C3E570: 806A0010  lwz r3, 0x10(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3E574: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3E578: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E57C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E580: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E584: 4E800421  bctrl
	ctx.lr = 0x82C3E588;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3E588 => {
    //   block [0x82C3E588..0x82C3E59C)
	// 82C3E588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E58C: 4BFD3C6D  bl 0x82c121f8
	ctx.lr = 0x82C3E590;
	sub_82C121F8(ctx, base);
	// 82C3E590: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E594: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E598: 4BFFFF84  b 0x82c3e51c
	pc = 0x82C3E51C; continue 'dispatch;
            }
            0x82C3E59C => {
    //   block [0x82C3E59C..0x82C3E5A4)
	// 82C3E59C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3E5A0: 4806AEBC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E5A8 size=88
    let mut pc: u32 = 0x82C3E5A8;
    'dispatch: loop {
        match pc {
            0x82C3E5A8 => {
    //   block [0x82C3E5A8..0x82C3E5D0)
	// 82C3E5A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E5AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3E5B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3E5B4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E5B8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3E5BC: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 82C3E5C0: 4B5E0C99  bl 0x8221f258
	ctx.lr = 0x82C3E5C4;
	sub_8221F258(ctx, base);
	// 82C3E5C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3E5C8: 419A0008  beq cr6, 0x82c3e5d0
	if ctx.cr[6].eq {
	pc = 0x82C3E5D0; continue 'dispatch;
	}
	// 82C3E5CC: 90630000  stw r3, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82C3E5D0; continue 'dispatch;
            }
            0x82C3E5D0 => {
    //   block [0x82C3E5D0..0x82C3E5DC)
	// 82C3E5D0: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C3E5D4: 41820008  beq 0x82c3e5dc
	if ctx.cr[0].eq {
	pc = 0x82C3E5DC; continue 'dispatch;
	}
	// 82C3E5D8: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	pc = 0x82C3E5DC; continue 'dispatch;
            }
            0x82C3E5DC => {
    //   block [0x82C3E5DC..0x82C3E600)
	// 82C3E5DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3E5E0: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C3E5E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3E5E8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3E5EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3E5F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3E5F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3E5F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3E5FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E600 size=840
    let mut pc: u32 = 0x82C3E600;
    'dispatch: loop {
        match pc {
            0x82C3E600 => {
    //   block [0x82C3E600..0x82C3E680)
	// 82C3E600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E604: 4806ADF5  bl 0x82ca93f8
	ctx.lr = 0x82C3E608;
	sub_82CA93D0(ctx, base);
	// 82C3E608: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E60C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C3E610: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 82C3E614: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82C3E618: 61699248  ori r9, r11, 0x9248
	ctx.r[9].u64 = ctx.r[11].u64 | 37448;
	// 82C3E61C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C3E620: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E624: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82C3E628: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82C3E62C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C3E630: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E634: 4198005C  blt cr6, 0x82c3e690
	if ctx.cr[6].lt {
	pc = 0x82C3E690; continue 'dispatch;
	}
	// 82C3E638: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C3E63C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E640: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82C3E644: 4B6B38FD  bl 0x822f1f40
	ctx.lr = 0x82C3E648;
	sub_822F1F40(ctx, base);
	// 82C3E648: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3E64C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3E650: 4B6B3721  bl 0x822f1d70
	ctx.lr = 0x82C3E654;
	sub_822F1D70(ctx, base);
	// 82C3E654: 4B6B37CD  bl 0x822f1e20
	ctx.lr = 0x82C3E658;
	sub_822F1E20(ctx, base);
	// 82C3E658: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C3E65C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3E660: 392A1720  addi r9, r10, 0x1720
	ctx.r[9].s64 = ctx.r[10].s64 + 5920;
	// 82C3E664: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 82C3E668: 4BA3D179  bl 0x8267b7e0
	ctx.lr = 0x82C3E66C;
	sub_8267B7E0(ctx, base);
	// 82C3E66C: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 82C3E670: 2B080010  cmplwi cr6, r8, 0x10
	ctx.cr[6].compare_u32(ctx.r[8].u32, 16 as u32, &mut ctx.xer);
	// 82C3E674: 4198000C  blt cr6, 0x82c3e680
	if ctx.cr[6].lt {
	pc = 0x82C3E680; continue 'dispatch;
	}
	// 82C3E678: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E67C: 4BC07135  bl 0x828457b0
	ctx.lr = 0x82C3E680;
	sub_828457B0(ctx, base);
	pc = 0x82C3E680; continue 'dispatch;
            }
            0x82C3E680 => {
    //   block [0x82C3E680..0x82C3E690)
	// 82C3E680: 3960000F  li r11, 0xf
	ctx.r[11].s64 = 15;
	// 82C3E684: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82C3E688: 9B210054  stb r25, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u8 ) };
	// 82C3E68C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3E690; continue 'dispatch;
            }
            0x82C3E690 => {
    //   block [0x82C3E690..0x82C3E6D4)
	// 82C3E690: 3860002C  li r3, 0x2c
	ctx.r[3].s64 = 44;
	// 82C3E694: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E698: 4B5E0BC1  bl 0x8221f258
	ctx.lr = 0x82C3E69C;
	sub_8221F258(ctx, base);
	// 82C3E69C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 82C3E6A0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 82C3E6A4: 419A0030  beq cr6, 0x82c3e6d4
	if ctx.cr[6].eq {
	pc = 0x82C3E6D4; continue 'dispatch;
	}
	// 82C3E6A8: 397A000C  addi r11, r26, 0xc
	ctx.r[11].s64 = ctx.r[26].s64 + 12;
	// 82C3E6AC: 93DA0000  stw r30, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C3E6B0: 93FA0004  stw r31, 4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C3E6B4: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 82C3E6B8: 93DA0008  stw r30, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C3E6BC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C3E6C0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E6C4: 917A000C  stw r11, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3E6C8: 4BFFF8B9  bl 0x82c3df80
	ctx.lr = 0x82C3E6CC;
	sub_82C3DF80(ctx, base);
	// 82C3E6CC: 9B3A0028  stb r25, 0x28(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 82C3E6D0: 9B3A0029  stb r25, 0x29(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(41 as u32), ctx.r[25].u8 ) };
	pc = 0x82C3E6D4; continue 'dispatch;
            }
            0x82C3E6D4 => {
    //   block [0x82C3E6D4..0x82C3E704)
	// 82C3E6D4: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E6D8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E6DC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C3E6E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E6E4: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3E6E8: 409A001C  bne cr6, 0x82c3e704
	if !ctx.cr[6].eq {
	pc = 0x82C3E704; continue 'dispatch;
	}
	// 82C3E6EC: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3E6F0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E6F4: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3E6F8: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E6FC: 934A0008  stw r26, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C3E700: 48000044  b 0x82c3e744
	pc = 0x82C3E744; continue 'dispatch;
            }
            0x82C3E704 => {
    //   block [0x82C3E704..0x82C3E72C)
	// 82C3E704: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 82C3E708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E70C: 419A0020  beq cr6, 0x82c3e72c
	if ctx.cr[6].eq {
	pc = 0x82C3E72C; continue 'dispatch;
	}
	// 82C3E710: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3E714: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E718: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E71C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3E720: 409A0024  bne cr6, 0x82c3e744
	if !ctx.cr[6].eq {
	pc = 0x82C3E744; continue 'dispatch;
	}
	// 82C3E724: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3E728: 4800001C  b 0x82c3e744
	pc = 0x82C3E744; continue 'dispatch;
            }
            0x82C3E72C => {
    //   block [0x82C3E72C..0x82C3E744)
	// 82C3E72C: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 82C3E730: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E734: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E738: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3E73C: 409A0008  bne cr6, 0x82c3e744
	if !ctx.cr[6].eq {
	pc = 0x82C3E744; continue 'dispatch;
	}
	// 82C3E740: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	pc = 0x82C3E744; continue 'dispatch;
            }
            0x82C3E744 => {
    //   block [0x82C3E744..0x82C3E760)
	// 82C3E744: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E748: 397A0004  addi r11, r26, 4
	ctx.r[11].s64 = ctx.r[26].s64 + 4;
	// 82C3E74C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 82C3E750: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3E754: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3E758: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E75C: 409A01CC  bne cr6, 0x82c3e928
	if !ctx.cr[6].eq {
	pc = 0x82C3E928; continue 'dispatch;
	}
	pc = 0x82C3E760; continue 'dispatch;
            }
            0x82C3E760 => {
    //   block [0x82C3E760..0x82C3E7A8)
	// 82C3E760: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E764: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E768: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E76C: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3E770: 409A00D8  bne cr6, 0x82c3e848
	if !ctx.cr[6].eq {
	pc = 0x82C3E848; continue 'dispatch;
	}
	// 82C3E774: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E778: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3E77C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E780: 409A0028  bne cr6, 0x82c3e7a8
	if !ctx.cr[6].eq {
	pc = 0x82C3E7A8; continue 'dispatch;
	}
	// 82C3E784: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C3E788: 9BC90028  stb r30, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E78C: 9BCA0028  stb r30, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E790: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E794: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E798: 9B270028  stb r25, 0x28(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 82C3E79C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E7A0: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7A4: 48000170  b 0x82c3e914
	pc = 0x82C3E914; continue 'dispatch;
            }
            0x82C3E7A8 => {
    //   block [0x82C3E7A8..0x82C3E7C0)
	// 82C3E7A8: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E7AC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E7B0: 409A0010  bne cr6, 0x82c3e7c0
	if !ctx.cr[6].eq {
	pc = 0x82C3E7C0; continue 'dispatch;
	}
	// 82C3E7B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3E7B8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3E7BC: 4BFD4B1D  bl 0x82c132d8
	ctx.lr = 0x82C3E7C0;
	sub_82C132D8(ctx, base);
	pc = 0x82C3E7C0; continue 'dispatch;
            }
            0x82C3E7C0 => {
    //   block [0x82C3E7C0..0x82C3E7FC)
	// 82C3E7C0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7C4: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E7C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7CC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7D0: 9B290028  stb r25, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 82C3E7D4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7D8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E7DC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E7E0: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E7E4: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C3E7E8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E7EC: 88C90029  lbz r6, 0x29(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3E7F0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3E7F4: 409A0008  bne cr6, 0x82c3e7fc
	if !ctx.cr[6].eq {
	pc = 0x82C3E7FC; continue 'dispatch;
	}
	// 82C3E7F8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3E7FC; continue 'dispatch;
            }
            0x82C3E7FC => {
    //   block [0x82C3E7FC..0x82C3E820)
	// 82C3E7FC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E800: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3E804: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E808: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E80C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3E810: 409A0010  bne cr6, 0x82c3e820
	if !ctx.cr[6].eq {
	pc = 0x82C3E820; continue 'dispatch;
	}
	// 82C3E814: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3E818: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3E81C: 480000F4  b 0x82c3e910
	pc = 0x82C3E910; continue 'dispatch;
            }
            0x82C3E820 => {
    //   block [0x82C3E820..0x82C3E83C)
	// 82C3E820: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E824: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E828: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3E82C: 409A0010  bne cr6, 0x82c3e83c
	if !ctx.cr[6].eq {
	pc = 0x82C3E83C; continue 'dispatch;
	}
	// 82C3E830: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C3E834: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3E838: 480000D8  b 0x82c3e910
	pc = 0x82C3E910; continue 'dispatch;
            }
            0x82C3E83C => {
    //   block [0x82C3E83C..0x82C3E848)
	// 82C3E83C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3E840: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3E844: 480000CC  b 0x82c3e910
	pc = 0x82C3E910; continue 'dispatch;
            }
            0x82C3E848 => {
    //   block [0x82C3E848..0x82C3E87C)
	// 82C3E848: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E84C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3E850: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E854: 409A0028  bne cr6, 0x82c3e87c
	if !ctx.cr[6].eq {
	pc = 0x82C3E87C; continue 'dispatch;
	}
	// 82C3E858: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E85C: 9BC90028  stb r30, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E860: 9BCA0028  stb r30, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E864: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E868: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E86C: 9B270028  stb r25, 0x28(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 82C3E870: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E874: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E878: 4800009C  b 0x82c3e914
	pc = 0x82C3E914; continue 'dispatch;
            }
            0x82C3E87C => {
    //   block [0x82C3E87C..0x82C3E894)
	// 82C3E87C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E880: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E884: 409A0010  bne cr6, 0x82c3e894
	if !ctx.cr[6].eq {
	pc = 0x82C3E894; continue 'dispatch;
	}
	// 82C3E888: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C3E88C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3E890: 4BFFCE31  bl 0x82c3b6c0
	ctx.lr = 0x82C3E894;
	sub_82C3B6C0(ctx, base);
	pc = 0x82C3E894; continue 'dispatch;
            }
            0x82C3E894 => {
    //   block [0x82C3E894..0x82C3E8D0)
	// 82C3E894: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E898: 9BCB0028  stb r30, 0x28(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E89C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8A0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8A4: 9B290028  stb r25, 0x28(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(40 as u32), ctx.r[25].u8 ) };
	// 82C3E8A8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8AC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8B0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3E8B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E8B8: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C3E8BC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E8C0: 88C90029  lbz r6, 0x29(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3E8C4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3E8C8: 409A0008  bne cr6, 0x82c3e8d0
	if !ctx.cr[6].eq {
	pc = 0x82C3E8D0; continue 'dispatch;
	}
	// 82C3E8CC: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3E8D0; continue 'dispatch;
            }
            0x82C3E8D0 => {
    //   block [0x82C3E8D0..0x82C3E8F0)
	// 82C3E8D0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8D4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3E8D8: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8DC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8E0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3E8E4: 409A000C  bne cr6, 0x82c3e8f0
	if !ctx.cr[6].eq {
	pc = 0x82C3E8F0; continue 'dispatch;
	}
	// 82C3E8E8: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C3E8EC: 48000020  b 0x82c3e90c
	pc = 0x82C3E90C; continue 'dispatch;
            }
            0x82C3E8F0 => {
    //   block [0x82C3E8F0..0x82C3E908)
	// 82C3E8F0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E8F4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E8F8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3E8FC: 409A000C  bne cr6, 0x82c3e908
	if !ctx.cr[6].eq {
	pc = 0x82C3E908; continue 'dispatch;
	}
	// 82C3E900: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3E904: 48000008  b 0x82c3e90c
	pc = 0x82C3E90C; continue 'dispatch;
            }
            0x82C3E908 => {
    //   block [0x82C3E908..0x82C3E90C)
	// 82C3E908: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E90C; continue 'dispatch;
            }
            0x82C3E90C => {
    //   block [0x82C3E90C..0x82C3E910)
	// 82C3E90C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C3E910; continue 'dispatch;
            }
            0x82C3E910 => {
    //   block [0x82C3E910..0x82C3E914)
	// 82C3E910: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C3E914; continue 'dispatch;
            }
            0x82C3E914 => {
    //   block [0x82C3E914..0x82C3E928)
	// 82C3E914: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E918: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C3E91C: 892A0028  lbz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C3E920: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3E924: 419AFE3C  beq cr6, 0x82c3e760
	if ctx.cr[6].eq {
	pc = 0x82C3E760; continue 'dispatch;
	}
	pc = 0x82C3E928; continue 'dispatch;
            }
            0x82C3E928 => {
    //   block [0x82C3E928..0x82C3E948)
	// 82C3E928: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E92C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C3E930: 93580004  stw r26, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3E934: 93780000  stw r27, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82C3E938: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E93C: 9BCA0028  stb r30, 0x28(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[30].u8 ) };
	// 82C3E940: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C3E944: 4806AB04  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3E948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3E948 size=252
    let mut pc: u32 = 0x82C3E948;
    'dispatch: loop {
        match pc {
            0x82C3E948 => {
    //   block [0x82C3E948..0x82C3E970)
	// 82C3E948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3E94C: 4806AAC1  bl 0x82ca940c
	ctx.lr = 0x82C3E950;
	sub_82CA93D0(ctx, base);
	// 82C3E950: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3E954: 81430020  lwz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E958: 3BC3001C  addi r30, r3, 0x1c
	ctx.r[30].s64 = ctx.r[3].s64 + 28;
	// 82C3E95C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C3E960: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82C3E964: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C3E968: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E96C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x82C3E970; continue 'dispatch;
            }
            0x82C3E970 => {
    //   block [0x82C3E970..0x82C3E984)
	// 82C3E970: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E978: 419A000C  beq cr6, 0x82c3e984
	if ctx.cr[6].eq {
	pc = 0x82C3E984; continue 'dispatch;
	}
	// 82C3E97C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3E980: 419A0008  beq cr6, 0x82c3e988
	if ctx.cr[6].eq {
	pc = 0x82C3E988; continue 'dispatch;
	}
	pc = 0x82C3E984; continue 'dispatch;
            }
            0x82C3E984 => {
    //   block [0x82C3E984..0x82C3E988)
	// 82C3E984: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E988; continue 'dispatch;
            }
            0x82C3E988 => {
    //   block [0x82C3E988..0x82C3E99C)
	// 82C3E988: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3E98C: 419A00B0  beq cr6, 0x82c3ea3c
	if ctx.cr[6].eq {
	pc = 0x82C3EA3C; continue 'dispatch;
	}
	// 82C3E990: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E994: 409A0008  bne cr6, 0x82c3e99c
	if !ctx.cr[6].eq {
	pc = 0x82C3E99C; continue 'dispatch;
	}
	// 82C3E998: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E99C; continue 'dispatch;
            }
            0x82C3E99C => {
    //   block [0x82C3E99C..0x82C3E9AC)
	// 82C3E99C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E9A0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3E9A4: 409A0008  bne cr6, 0x82c3e9ac
	if !ctx.cr[6].eq {
	pc = 0x82C3E9AC; continue 'dispatch;
	}
	// 82C3E9A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3E9AC; continue 'dispatch;
            }
            0x82C3E9AC => {
    //   block [0x82C3E9AC..0x82C3E9D0)
	// 82C3E9AC: 89690024  lbz r11, 0x24(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C3E9B0: 3BE90010  addi r31, r9, 0x10
	ctx.r[31].s64 = ctx.r[9].s64 + 16;
	// 82C3E9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3E9B8: 419A0018  beq cr6, 0x82c3e9d0
	if ctx.cr[6].eq {
	pc = 0x82C3E9D0; continue 'dispatch;
	}
	// 82C3E9BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3E9C0: 4BFD3839  bl 0x82c121f8
	ctx.lr = 0x82C3E9C4;
	sub_82C121F8(ctx, base);
	// 82C3E9C4: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3E9C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3E9CC: 4BFFFFA4  b 0x82c3e970
	pc = 0x82C3E970; continue 'dispatch;
            }
            0x82C3E9D0 => {
    //   block [0x82C3E9D0..0x82C3EA10)
	// 82C3E9D0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E9D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3E9D8: 419A0040  beq cr6, 0x82c3ea18
	if ctx.cr[6].eq {
	pc = 0x82C3EA18; continue 'dispatch;
	}
	// 82C3E9DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3E9E0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3E9E4: 388003E8  li r4, 0x3e8
	ctx.r[4].s64 = 1000;
	// 82C3E9E8: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3E9EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3E9F0: 4E800421  bctrl
	ctx.lr = 0x82C3E9F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3E9F4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3E9F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3E9FC: 419A0014  beq cr6, 0x82c3ea10
	if ctx.cr[6].eq {
	pc = 0x82C3EA10; continue 'dispatch;
	}
	// 82C3EA00: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EA04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EA08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3EA0C: 4E800421  bctrl
	ctx.lr = 0x82C3EA10;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3EA10 => {
    //   block [0x82C3EA10..0x82C3EA18)
	// 82C3EA10: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C3EA14: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82C3EA18; continue 'dispatch;
            }
            0x82C3EA18 => {
    //   block [0x82C3EA18..0x82C3EA3C)
	// 82C3EA18: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3EA1C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3EA20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C3EA24: 4BFFE095  bl 0x82c3cab8
	ctx.lr = 0x82C3EA28;
	sub_82C3CAB8(ctx, base);
	// 82C3EA28: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C3EA2C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C3EA30: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3EA34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3EA38: 4BFFFF38  b 0x82c3e970
	pc = 0x82C3E970; continue 'dispatch;
            }
            0x82C3EA3C => {
    //   block [0x82C3EA3C..0x82C3EA44)
	// 82C3EA3C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3EA40: 4806AA1C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3EA48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3EA48 size=316
    let mut pc: u32 = 0x82C3EA48;
    'dispatch: loop {
        match pc {
            0x82C3EA48 => {
    //   block [0x82C3EA48..0x82C3EA80)
	// 82C3EA48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3EA4C: 4806A9B5  bl 0x82ca9400
	ctx.lr = 0x82C3EA50;
	sub_82CA93D0(ctx, base);
	// 82C3EA50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3EA54: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C3EA58: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C3EA5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3EA60: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3EA64: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82C3EA68: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EA6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EA70: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3EA74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3EA78: 409A003C  bne cr6, 0x82c3eab4
	if !ctx.cr[6].eq {
	pc = 0x82C3EAB4; continue 'dispatch;
	}
	// 82C3EA7C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3EA80; continue 'dispatch;
            }
            0x82C3EA80 => {
    //   block [0x82C3EA80..0x82C3EAA4)
	// 82C3EA80: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EA84: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82C3EA88: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82C3EA8C: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82C3EA90: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82C3EA94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3EA98: 419A000C  beq cr6, 0x82c3eaa4
	if ctx.cr[6].eq {
	pc = 0x82C3EAA4; continue 'dispatch;
	}
	// 82C3EA9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EAA0: 48000008  b 0x82c3eaa8
	pc = 0x82C3EAA8; continue 'dispatch;
            }
            0x82C3EAA4 => {
    //   block [0x82C3EAA4..0x82C3EAA8)
	// 82C3EAA4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82C3EAA8; continue 'dispatch;
            }
            0x82C3EAA8 => {
    //   block [0x82C3EAA8..0x82C3EAB4)
	// 82C3EAA8: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3EAAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3EAB0: 419AFFD0  beq cr6, 0x82c3ea80
	if ctx.cr[6].eq {
	pc = 0x82C3EA80; continue 'dispatch;
	}
	pc = 0x82C3EAB4; continue 'dispatch;
            }
            0x82C3EAB4 => {
    //   block [0x82C3EAB4..0x82C3EB14)
	// 82C3EAB4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C3EAB8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82C3EABC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C3EAC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EAC4: 419A0054  beq cr6, 0x82c3eb18
	if ctx.cr[6].eq {
	pc = 0x82C3EB18; continue 'dispatch;
	}
	// 82C3EAC8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EACC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3EAD0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EAD4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EAD8: 409A003C  bne cr6, 0x82c3eb14
	if !ctx.cr[6].eq {
	pc = 0x82C3EB14; continue 'dispatch;
	}
	// 82C3EADC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C3EAE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C3EAE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3EAE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3EAEC: 4BFFFB15  bl 0x82c3e600
	ctx.lr = 0x82C3EAF0;
	sub_82C3E600(ctx, base);
	// 82C3EAF0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3EAF4: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C3EAF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EAFC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EB00: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EB04: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3EB08: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3EB0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EB10: 4806A940  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3EB14 => {
    //   block [0x82C3EB14..0x82C3EB18)
	// 82C3EB14: 4BFD361D  bl 0x82c12130
	ctx.lr = 0x82C3EB18;
	sub_82C12130(ctx, base);
	pc = 0x82C3EB18; continue 'dispatch;
            }
            0x82C3EB18 => {
    //   block [0x82C3EB18..0x82C3EB68)
	// 82C3EB18: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3EB1C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EB20: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EB24: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EB28: 40980040  bge cr6, 0x82c3eb68
	if !ctx.cr[6].lt {
	pc = 0x82C3EB68; continue 'dispatch;
	}
	// 82C3EB2C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82C3EB30: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C3EB34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C3EB38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3EB3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3EB40: 4BFFFAC1  bl 0x82c3e600
	ctx.lr = 0x82C3EB44;
	sub_82C3E600(ctx, base);
	// 82C3EB44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3EB48: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82C3EB4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EB50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EB54: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EB58: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3EB5C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3EB60: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EB64: 4806A8EC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3EB68 => {
    //   block [0x82C3EB68..0x82C3EB84)
	// 82C3EB68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3EB6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C3EB70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EB74: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82C3EB78: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C3EB7C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EB80: 4806A8D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3EB88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3EB88 size=524
    let mut pc: u32 = 0x82C3EB88;
    'dispatch: loop {
        match pc {
            0x82C3EB88 => {
    //   block [0x82C3EB88..0x82C3EBD0)
	// 82C3EB88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3EB8C: 4806A879  bl 0x82ca9404
	ctx.lr = 0x82C3EB90;
	sub_82CA93D0(ctx, base);
	// 82C3EB90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3EB94: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3EB98: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C3EB9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3EBA0: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C3EBA4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82C3EBA8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3EBAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EBB0: 409A0020  bne cr6, 0x82c3ebd0
	if !ctx.cr[6].eq {
	pc = 0x82C3EBD0; continue 'dispatch;
	}
	// 82C3EBB4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3EBB8: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EBBC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3EBC0: 4BFFFA41  bl 0x82c3e600
	ctx.lr = 0x82C3EBC4;
	sub_82C3E600(ctx, base);
	// 82C3EBC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EBC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EBCC: 4806A888  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3EBD0 => {
    //   block [0x82C3EBD0..0x82C3EBEC)
	// 82C3EBD0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EBD4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C3EBD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EBDC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EBE0: 419A000C  beq cr6, 0x82c3ebec
	if ctx.cr[6].eq {
	pc = 0x82C3EBEC; continue 'dispatch;
	}
	// 82C3EBE4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3EBE8: 419A0008  beq cr6, 0x82c3ebf0
	if ctx.cr[6].eq {
	pc = 0x82C3EBF0; continue 'dispatch;
	}
	pc = 0x82C3EBEC; continue 'dispatch;
            }
            0x82C3EBEC => {
    //   block [0x82C3EBEC..0x82C3EBF0)
	// 82C3EBEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EBF0; continue 'dispatch;
            }
            0x82C3EBF0 => {
    //   block [0x82C3EBF0..0x82C3EC30)
	// 82C3EBF0: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C3EBF4: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3EBF8: 409A0038  bne cr6, 0x82c3ec30
	if !ctx.cr[6].eq {
	pc = 0x82C3EC30; continue 'dispatch;
	}
	// 82C3EBFC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EC00: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EC04: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EC08: 4098015C  bge cr6, 0x82c3ed64
	if !ctx.cr[6].lt {
	pc = 0x82C3ED64; continue 'dispatch;
	}
	// 82C3EC0C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3EC10: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 82C3EC14: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3EC18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3EC1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EC20: 4BFFF9E1  bl 0x82c3e600
	ctx.lr = 0x82C3EC24;
	sub_82C3E600(ctx, base);
	// 82C3EC24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EC28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EC2C: 4806A828  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3EC30 => {
    //   block [0x82C3EC30..0x82C3EC40)
	// 82C3EC30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EC34: 419A000C  beq cr6, 0x82c3ec40
	if ctx.cr[6].eq {
	pc = 0x82C3EC40; continue 'dispatch;
	}
	// 82C3EC38: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3EC3C: 419A0008  beq cr6, 0x82c3ec44
	if ctx.cr[6].eq {
	pc = 0x82C3EC44; continue 'dispatch;
	}
	pc = 0x82C3EC40; continue 'dispatch;
            }
            0x82C3EC40 => {
    //   block [0x82C3EC40..0x82C3EC44)
	// 82C3EC40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EC44; continue 'dispatch;
            }
            0x82C3EC44 => {
    //   block [0x82C3EC44..0x82C3EC80)
	// 82C3EC44: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EC48: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EC4C: 409A0034  bne cr6, 0x82c3ec80
	if !ctx.cr[6].eq {
	pc = 0x82C3EC80; continue 'dispatch;
	}
	// 82C3EC50: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3EC54: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EC58: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3EC5C: 40980108  bge cr6, 0x82c3ed64
	if !ctx.cr[6].lt {
	pc = 0x82C3ED64; continue 'dispatch;
	}
	// 82C3EC60: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3EC64: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3EC68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3EC6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EC70: 4BFFF991  bl 0x82c3e600
	ctx.lr = 0x82C3EC74;
	sub_82C3E600(ctx, base);
	// 82C3EC74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3EC78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3EC7C: 4806A7D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3EC80 => {
    //   block [0x82C3EC80..0x82C3ECCC)
	// 82C3EC80: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EC84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EC88: 40980058  bge cr6, 0x82c3ece0
	if !ctx.cr[6].lt {
	pc = 0x82C3ECE0; continue 'dispatch;
	}
	// 82C3EC8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3EC90: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C3EC94: 4BFD349D  bl 0x82c12130
	ctx.lr = 0x82C3EC98;
	sub_82C12130(ctx, base);
	// 82C3EC98: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3EC9C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3ECA0: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3ECA4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3ECA8: 40980038  bge cr6, 0x82c3ece0
	if !ctx.cr[6].lt {
	pc = 0x82C3ECE0; continue 'dispatch;
	}
	// 82C3ECAC: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3ECB0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3ECB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3ECB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3ECBC: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3ECC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3ECC4: 409A008C  bne cr6, 0x82c3ed50
	if !ctx.cr[6].eq {
	pc = 0x82C3ED50; continue 'dispatch;
	}
	// 82C3ECC8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C3ECCC; continue 'dispatch;
            }
            0x82C3ECCC => {
    //   block [0x82C3ECCC..0x82C3ECE0)
	// 82C3ECCC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3ECD0: 4BFFF931  bl 0x82c3e600
	ctx.lr = 0x82C3ECD4;
	sub_82C3E600(ctx, base);
	// 82C3ECD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3ECD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3ECDC: 4806A778  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3ECE0 => {
    //   block [0x82C3ECE0..0x82C3ED10)
	// 82C3ECE0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3ECE4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3ECE8: 4098007C  bge cr6, 0x82c3ed64
	if !ctx.cr[6].lt {
	pc = 0x82C3ED64; continue 'dispatch;
	}
	// 82C3ECEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3ECF0: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 82C3ECF4: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3ECF8: 4BFD3501  bl 0x82c121f8
	ctx.lr = 0x82C3ECFC;
	sub_82C121F8(ctx, base);
	// 82C3ECFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3ED00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3ED04: 419A000C  beq cr6, 0x82c3ed10
	if ctx.cr[6].eq {
	pc = 0x82C3ED10; continue 'dispatch;
	}
	// 82C3ED08: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C3ED0C: 419A0008  beq cr6, 0x82c3ed14
	if ctx.cr[6].eq {
	pc = 0x82C3ED14; continue 'dispatch;
	}
	pc = 0x82C3ED10; continue 'dispatch;
            }
            0x82C3ED10 => {
    //   block [0x82C3ED10..0x82C3ED14)
	// 82C3ED10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3ED14; continue 'dispatch;
            }
            0x82C3ED14 => {
    //   block [0x82C3ED14..0x82C3ED30)
	// 82C3ED14: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3ED18: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C3ED1C: 419A0014  beq cr6, 0x82c3ed30
	if ctx.cr[6].eq {
	pc = 0x82C3ED30; continue 'dispatch;
	}
	// 82C3ED20: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3ED24: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3ED28: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3ED2C: 40980038  bge cr6, 0x82c3ed64
	if !ctx.cr[6].lt {
	pc = 0x82C3ED64; continue 'dispatch;
	}
	pc = 0x82C3ED30; continue 'dispatch;
            }
            0x82C3ED30 => {
    //   block [0x82C3ED30..0x82C3ED50)
	// 82C3ED30: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3ED34: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82C3ED38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3ED3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3ED40: 894B0029  lbz r10, 0x29(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3ED44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3ED48: 419AFF84  beq cr6, 0x82c3eccc
	if ctx.cr[6].eq {
	pc = 0x82C3ECCC; continue 'dispatch;
	}
	// 82C3ED4C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x82C3ED50; continue 'dispatch;
            }
            0x82C3ED50 => {
    //   block [0x82C3ED50..0x82C3ED64)
	// 82C3ED50: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3ED54: 4BFFF8AD  bl 0x82c3e600
	ctx.lr = 0x82C3ED58;
	sub_82C3E600(ctx, base);
	// 82C3ED58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3ED5C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3ED60: 4806A6F4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3ED64 => {
    //   block [0x82C3ED64..0x82C3ED94)
	// 82C3ED64: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C3ED68: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3ED6C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3ED70: 4BFFFCD9  bl 0x82c3ea48
	ctx.lr = 0x82C3ED74;
	sub_82C3EA48(ctx, base);
	// 82C3ED74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3ED78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3ED7C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3ED80: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3ED84: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3ED88: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82C3ED8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3ED90: 4806A6C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3ED98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3ED98 size=272
    let mut pc: u32 = 0x82C3ED98;
    'dispatch: loop {
        match pc {
            0x82C3ED98 => {
    //   block [0x82C3ED98..0x82C3EDC4)
	// 82C3ED98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3ED9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3EDA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3EDA4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3EDA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3EDAC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EDB0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EDB4: 892B0029  lbz r9, 0x29(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3EDB8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3EDBC: 409A0030  bne cr6, 0x82c3edec
	if !ctx.cr[6].eq {
	pc = 0x82C3EDEC; continue 'dispatch;
	}
	// 82C3EDC0: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3EDC4; continue 'dispatch;
            }
            0x82C3EDC4 => {
    //   block [0x82C3EDC4..0x82C3EDD8)
	// 82C3EDC4: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EDC8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3EDCC: 4098000C  bge cr6, 0x82c3edd8
	if !ctx.cr[6].lt {
	pc = 0x82C3EDD8; continue 'dispatch;
	}
	// 82C3EDD0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3EDD4: 4800000C  b 0x82c3ede0
	pc = 0x82C3EDE0; continue 'dispatch;
            }
            0x82C3EDD8 => {
    //   block [0x82C3EDD8..0x82C3EDE0)
	// 82C3EDD8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82C3EDDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82C3EDE0; continue 'dispatch;
            }
            0x82C3EDE0 => {
    //   block [0x82C3EDE0..0x82C3EDEC)
	// 82C3EDE0: 890B0029  lbz r8, 0x29(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(41 as u32) ) } as u64;
	// 82C3EDE4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3EDE8: 419AFFDC  beq cr6, 0x82c3edc4
	if ctx.cr[6].eq {
	pc = 0x82C3EDC4; continue 'dispatch;
	}
	pc = 0x82C3EDEC; continue 'dispatch;
            }
            0x82C3EDEC => {
    //   block [0x82C3EDEC..0x82C3EE14)
	// 82C3EDEC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EDF0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C3EDF4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C3EDF8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C3EDFC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C3EE00: 419A0014  beq cr6, 0x82c3ee14
	if ctx.cr[6].eq {
	pc = 0x82C3EE14; continue 'dispatch;
	}
	// 82C3EE04: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EE08: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EE0C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C3EE10: 40980060  bge cr6, 0x82c3ee70
	if !ctx.cr[6].lt {
	pc = 0x82C3EE70; continue 'dispatch;
	}
	pc = 0x82C3EE14; continue 'dispatch;
            }
            0x82C3EE14 => {
    //   block [0x82C3EE14..0x82C3EE6C)
	// 82C3EE14: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EE18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3EE1C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3EE20: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C3EE24: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 82C3EE28: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82C3EE2C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 82C3EE30: 4BFFF151  bl 0x82c3df80
	ctx.lr = 0x82C3EE34;
	sub_82C3DF80(ctx, base);
	// 82C3EE34: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 82C3EE38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3EE3C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3EE40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C3EE44: 4BFFFD45  bl 0x82c3eb88
	ctx.lr = 0x82C3EE48;
	sub_82C3EB88(ctx, base);
	// 82C3EE48: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C3EE4C: 80610088  lwz r3, 0x88(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82C3EE50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3EE54: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82C3EE58: 419A0014  beq cr6, 0x82c3ee6c
	if ctx.cr[6].eq {
	pc = 0x82C3EE6C; continue 'dispatch;
	}
	// 82C3EE5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EE60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EE64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3EE68: 4E800421  bctrl
	ctx.lr = 0x82C3EE6C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3EE6C => {
    //   block [0x82C3EE6C..0x82C3EE70)
	// 82C3EE6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x82C3EE70; continue 'dispatch;
            }
            0x82C3EE70 => {
    //   block [0x82C3EE70..0x82C3EE80)
	// 82C3EE70: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3EE74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3EE78: 409A0008  bne cr6, 0x82c3ee80
	if !ctx.cr[6].eq {
	pc = 0x82C3EE80; continue 'dispatch;
	}
	// 82C3EE7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EE80; continue 'dispatch;
            }
            0x82C3EE80 => {
    //   block [0x82C3EE80..0x82C3EE90)
	// 82C3EE80: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EE84: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EE88: 409A0008  bne cr6, 0x82c3ee90
	if !ctx.cr[6].eq {
	pc = 0x82C3EE90; continue 'dispatch;
	}
	// 82C3EE8C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EE90; continue 'dispatch;
            }
            0x82C3EE90 => {
    //   block [0x82C3EE90..0x82C3EEA8)
	// 82C3EE90: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 82C3EE94: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C3EE98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3EE9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3EEA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3EEA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3EEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3EEA8 size=372
    let mut pc: u32 = 0x82C3EEA8;
    'dispatch: loop {
        match pc {
            0x82C3EEA8 => {
    //   block [0x82C3EEA8..0x82C3EF10)
	// 82C3EEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3EEAC: 4806A559  bl 0x82ca9404
	ctx.lr = 0x82C3EEB0;
	sub_82CA93D0(ctx, base);
	// 82C3EEB0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3EEB4: 9081010C  stw r4, 0x10c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(268 as u32), ctx.r[4].u32 ) };
	// 82C3EEB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3EEBC: 3881010C  addi r4, r1, 0x10c
	ctx.r[4].s64 = ctx.r[1].s64 + 268;
	// 82C3EEC0: 90C1011C  stw r6, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[6].u32 ) };
	// 82C3EEC4: 387E001C  addi r3, r30, 0x1c
	ctx.r[3].s64 = ctx.r[30].s64 + 28;
	// 82C3EEC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C3EECC: 4BFFFECD  bl 0x82c3ed98
	ctx.lr = 0x82C3EED0;
	sub_82C3ED98(ctx, base);
	// 82C3EED0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3EED4: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82C3EED8: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 82C3EEDC: 38A1011C  addi r5, r1, 0x11c
	ctx.r[5].s64 = ctx.r[1].s64 + 284;
	// 82C3EEE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3EEE4: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 82C3EEE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3EEEC: 4BBC09CD  bl 0x827ff8b8
	ctx.lr = 0x82C3EEF0;
	sub_827FF8B8(ctx, base);
	// 82C3EEF0: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82C3EEF4: 815E0014  lwz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3EEF8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82C3EEFC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C3EF00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EF04: 419A000C  beq cr6, 0x82c3ef10
	if ctx.cr[6].eq {
	pc = 0x82C3EF10; continue 'dispatch;
	}
	// 82C3EF08: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C3EF0C: 419A0008  beq cr6, 0x82c3ef14
	if ctx.cr[6].eq {
	pc = 0x82C3EF14; continue 'dispatch;
	}
	pc = 0x82C3EF10; continue 'dispatch;
            }
            0x82C3EF10 => {
    //   block [0x82C3EF10..0x82C3EF14)
	// 82C3EF10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EF14; continue 'dispatch;
            }
            0x82C3EF14 => {
    //   block [0x82C3EF14..0x82C3EF2C)
	// 82C3EF14: 83A1005C  lwz r29, 0x5c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C3EF18: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3EF1C: 419A00F4  beq cr6, 0x82c3f010
	if ctx.cr[6].eq {
	pc = 0x82C3F010; continue 'dispatch;
	}
	// 82C3EF20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EF24: 409A0008  bne cr6, 0x82c3ef2c
	if !ctx.cr[6].eq {
	pc = 0x82C3EF2C; continue 'dispatch;
	}
	// 82C3EF28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EF2C; continue 'dispatch;
            }
            0x82C3EF2C => {
    //   block [0x82C3EF2C..0x82C3EF3C)
	// 82C3EF2C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EF30: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3EF34: 409A0008  bne cr6, 0x82c3ef3c
	if !ctx.cr[6].eq {
	pc = 0x82C3EF3C; continue 'dispatch;
	}
	// 82C3EF38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3EF3C; continue 'dispatch;
            }
            0x82C3EF3C => {
    //   block [0x82C3EF3C..0x82C3EF74)
	// 82C3EF3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3EF40: 4B596FC9  bl 0x821d5f08
	ctx.lr = 0x82C3EF44;
	sub_821D5F08(ctx, base);
	// 82C3EF44: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C3EF48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3EF4C: 80BD0010  lwz r5, 0x10(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3EF50: 4BFC3981  bl 0x82c028d0
	ctx.lr = 0x82C3EF54;
	sub_82C028D0(ctx, base);
	// 82C3EF54: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C3EF58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3EF5C: 4BFC398D  bl 0x82c028e8
	ctx.lr = 0x82C3EF60;
	sub_82C028E8(ctx, base);
	// 82C3EF60: 897E0030  lbz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C3EF64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EF68: 419A000C  beq cr6, 0x82c3ef74
	if ctx.cr[6].eq {
	pc = 0x82C3EF74; continue 'dispatch;
	}
	// 82C3EF6C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3EF70: 4BFC3A69  bl 0x82c029d8
	ctx.lr = 0x82C3EF74;
	sub_82C029D8(ctx, base);
	pc = 0x82C3EF74; continue 'dispatch;
            }
            0x82C3EF74 => {
    //   block [0x82C3EF74..0x82C3EFB8)
	// 82C3EF74: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EF78: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 82C3EF7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C3EF80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3EF84: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EF88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3EF8C: 4E800421  bctrl
	ctx.lr = 0x82C3EF90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3EF90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C3EF94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3EF98: 4BFD2D31  bl 0x82c11cc8
	ctx.lr = 0x82C3EF9C;
	sub_82C11CC8(ctx, base);
	// 82C3EF9C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3EFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3EFA4: 419A0014  beq cr6, 0x82c3efb8
	if ctx.cr[6].eq {
	pc = 0x82C3EFB8; continue 'dispatch;
	}
	// 82C3EFA8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EFAC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3EFB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3EFB4: 4E800421  bctrl
	ctx.lr = 0x82C3EFB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3EFB8 => {
    //   block [0x82C3EFB8..0x82C3F008)
	// 82C3EFB8: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 82C3EFBC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 82C3EFC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3EFC8: 419A0040  beq cr6, 0x82c3f008
	if ctx.cr[6].eq {
	pc = 0x82C3F008; continue 'dispatch;
	}
	// 82C3EFCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3EFD0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82C3EFD4: 480172B5  bl 0x82c56288
	ctx.lr = 0x82C3EFD8;
	sub_82C56288(ctx, base);
	// 82C3EFD8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EFDC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C3EFE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3EFE4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3EFE8: C02B0C18  lfs f1, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C3EFEC: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3EFF0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3EFF4: 4E800421  bctrl
	ctx.lr = 0x82C3EFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3EFF8: C01D0014  lfs f0, 0x14(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C3EFFC: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C3F000: C1BD0018  lfs f13, 0x18(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C3F004: D1BF0010  stfs f13, 0x10(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
            }
            0x82C3F008 => {
    //   block [0x82C3F008..0x82C3F010)
	// 82C3F008: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C3F00C: 4B64AA3D  bl 0x82289a48
	ctx.lr = 0x82C3F010;
	sub_82289A48(ctx, base);
	pc = 0x82C3F010; continue 'dispatch;
            }
            0x82C3F010 => {
    //   block [0x82C3F010..0x82C3F01C)
	// 82C3F010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F014: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C3F018: 4806A43C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F020(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F020 size=160
    let mut pc: u32 = 0x82C3F020;
    'dispatch: loop {
        match pc {
            0x82C3F020 => {
    //   block [0x82C3F020..0x82C3F06C)
	// 82C3F020: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F024: 4806A3E1  bl 0x82ca9404
	ctx.lr = 0x82C3F028;
	sub_82CA93D0(ctx, base);
	// 82C3F028: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F02C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3F030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F034: 93A100AC  stw r29, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[29].u32 ) };
	// 82C3F038: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C3F03C: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82C3F040: 38A100AC  addi r5, r1, 0xac
	ctx.r[5].s64 = ctx.r[1].s64 + 172;
	// 82C3F044: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3F048: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F04C: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 82C3F050: 4BFD7CD1  bl 0x82c16d20
	ctx.lr = 0x82C3F054;
	sub_82C16D20(ctx, base);
	// 82C3F054: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3F058: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3F05C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F060: 419A000C  beq cr6, 0x82c3f06c
	if ctx.cr[6].eq {
	pc = 0x82C3F06C; continue 'dispatch;
	}
	// 82C3F064: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C3F068: 419A0008  beq cr6, 0x82c3f070
	if ctx.cr[6].eq {
	pc = 0x82C3F070; continue 'dispatch;
	}
	pc = 0x82C3F06C; continue 'dispatch;
            }
            0x82C3F06C => {
    //   block [0x82C3F06C..0x82C3F070)
	// 82C3F06C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F070; continue 'dispatch;
            }
            0x82C3F070 => {
    //   block [0x82C3F070..0x82C3F088)
	// 82C3F070: 81210054  lwz r9, 0x54(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C3F074: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C3F078: 419A002C  beq cr6, 0x82c3f0a4
	if ctx.cr[6].eq {
	pc = 0x82C3F0A4; continue 'dispatch;
	}
	// 82C3F07C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F080: 409A0008  bne cr6, 0x82c3f088
	if !ctx.cr[6].eq {
	pc = 0x82C3F088; continue 'dispatch;
	}
	// 82C3F084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F088; continue 'dispatch;
            }
            0x82C3F088 => {
    //   block [0x82C3F088..0x82C3F098)
	// 82C3F088: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F08C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3F090: 409A0008  bne cr6, 0x82c3f098
	if !ctx.cr[6].eq {
	pc = 0x82C3F098; continue 'dispatch;
	}
	// 82C3F094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F098; continue 'dispatch;
            }
            0x82C3F098 => {
    //   block [0x82C3F098..0x82C3F0A4)
	// 82C3F098: 38690010  addi r3, r9, 0x10
	ctx.r[3].s64 = ctx.r[9].s64 + 16;
	// 82C3F09C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3F0A0: 4806A3B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3F0A4 => {
    //   block [0x82C3F0A4..0x82C3F0C0)
	// 82C3F0A4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C3F0A8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C3F0AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3F0B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F0B4: 4BFFFDF5  bl 0x82c3eea8
	ctx.lr = 0x82C3F0B8;
	sub_82C3EEA8(ctx, base);
	// 82C3F0B8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3F0BC: 4806A398  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F0C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3F0C0 size=588
    let mut pc: u32 = 0x82C3F0C0;
    'dispatch: loop {
        match pc {
            0x82C3F0C0 => {
    //   block [0x82C3F0C0..0x82C3F188)
	// 82C3F0C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F0C4: 4806A32D  bl 0x82ca93f0
	ctx.lr = 0x82C3F0C8;
	sub_82CA93D0(ctx, base);
	// 82C3F0C8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82C3F0CC: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F0D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C3F0D4: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C3F0D8: 897D0031  lbz r11, 0x31(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(49 as u32) ) } as u64;
	// 82C3F0DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F0E0: 409A0220  bne cr6, 0x82c3f300
	if !ctx.cr[6].eq {
	pc = 0x82C3F300; continue 'dispatch;
	}
	// 82C3F0E4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F0E8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82C3F0EC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3F0F0: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C3F0F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F0F8: 4E800421  bctrl
	ctx.lr = 0x82C3F0FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F0FC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3F100: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3F104: 419A01FC  beq cr6, 0x82c3f300
	if ctx.cr[6].eq {
	pc = 0x82C3F300; continue 'dispatch;
	}
	// 82C3F108: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3F10C: 4BFFEEF5  bl 0x82c3e000
	ctx.lr = 0x82C3F110;
	sub_82C3E000(ctx, base);
	// 82C3F110: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C3F114: C0010080  lfs f0, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C3F118: C1A10088  lfs f13, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C3F11C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C3F120: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C3F124: 4BFFF485  bl 0x82c3e5a8
	ctx.lr = 0x82C3F128;
	sub_82C3E5A8(ctx, base);
	// 82C3F128: 38A10068  addi r5, r1, 0x68
	ctx.r[5].s64 = ctx.r[1].s64 + 104;
	// 82C3F12C: 807D002C  lwz r3, 0x2c(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C3F130: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C3F134: 4BFCBB35  bl 0x82c0ac68
	ctx.lr = 0x82C3F138;
	sub_82C0AC68(ctx, base);
	// 82C3F138: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C3F13C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C3F140: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82C3F144: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82C3F148: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C3F14C: 3AE00010  li r23, 0x10
	ctx.r[23].s64 = 16;
	// 82C3F150: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F154: 3B000014  li r24, 0x14
	ctx.r[24].s64 = 20;
	// 82C3F158: 3AC00018  li r22, 0x18
	ctx.r[22].s64 = 24;
	// 82C3F15C: C3EB0C18  lfs f31, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C3F160: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 82C3F164: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C3F168: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82C3F16C: 83610060  lwz r27, 0x60(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C3F170: 83810064  lwz r28, 0x64(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C3F174: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C3F178: 419A0010  beq cr6, 0x82c3f188
	if ctx.cr[6].eq {
	pc = 0x82C3F188; continue 'dispatch;
	}
	// 82C3F17C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 82C3F180: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3F184: 419A0008  beq cr6, 0x82c3f18c
	if ctx.cr[6].eq {
	pc = 0x82C3F18C; continue 'dispatch;
	}
            }
            0x82C3F188 => {
    //   block [0x82C3F188..0x82C3F18C)
	// 82C3F188: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F18C; continue 'dispatch;
            }
            0x82C3F18C => {
    //   block [0x82C3F18C..0x82C3F1A4)
	// 82C3F18C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C3F190: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3F194: 419A0154  beq cr6, 0x82c3f2e8
	if ctx.cr[6].eq {
	pc = 0x82C3F2E8; continue 'dispatch;
	}
	// 82C3F198: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C3F19C: 409A0008  bne cr6, 0x82c3f1a4
	if !ctx.cr[6].eq {
	pc = 0x82C3F1A4; continue 'dispatch;
	}
	// 82C3F1A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F1A4; continue 'dispatch;
            }
            0x82C3F1A4 => {
    //   block [0x82C3F1A4..0x82C3F1B4)
	// 82C3F1A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F1A8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3F1AC: 409A0008  bne cr6, 0x82c3f1b4
	if !ctx.cr[6].eq {
	pc = 0x82C3F1B4; continue 'dispatch;
	}
	// 82C3F1B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C3F1B4; continue 'dispatch;
            }
            0x82C3F1B4 => {
    //   block [0x82C3F1B4..0x82C3F224)
	// 82C3F1B4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82C3F1B8: 80DC000C  lwz r6, 0xc(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3F1BC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3F1C0: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3F1C4: 3BFC0008  addi r31, r28, 8
	ctx.r[31].s64 = ctx.r[28].s64 + 8;
	// 82C3F1C8: 4BFFFE59  bl 0x82c3f020
	ctx.lr = 0x82C3F1CC;
	sub_82C3F020(ctx, base);
	// 82C3F1CC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3F1D0: 9B5E0014  stb r26, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 82C3F1D4: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C3F1D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F1DC: 409A0048  bne cr6, 0x82c3f224
	if !ctx.cr[6].eq {
	pc = 0x82C3F224; continue 'dispatch;
	}
	// 82C3F1E0: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82C3F1E4: 13FFBC07  vcmpneb. (lvlx128) v31, v31, v23
	tmp.u32 = ctx.r[31].u32 + ctx.r[23].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C3F1E8: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 82C3F1EC: 13DFC407  vcmpneb. (lvlx128) v30, v31, v24
	tmp.u32 = ctx.r[31].u32 + ctx.r[24].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C3F1F0: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 82C3F1F4: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C3F1F8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 82C3F1FC: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82C3F200: 13A058C7  vcmpequd (lvx128) v29, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	pc = 0x82C3F224; continue 'dispatch;
            }
            0x82C3F224 => {
    //   block [0x82C3F224..0x82C3F2E8)
	// 82C3F224: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C3F228: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C3F22C: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C3F230: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82C3F234: D3E10060  stfs f31, 0x60(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C3F238: 39210058  addi r9, r1, 0x58
	ctx.r[9].s64 = ctx.r[1].s64 + 88;
	// 82C3F23C: 409A0038  bne cr6, 0x82c3f274
	if !ctx.cr[6].eq {
	pc = 0x82C3F274; continue 'dispatch;
	}
	// 82C3F240: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 82C3F244: 13004C07  vcmpneb. (lvlx128) v24, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[56] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C3F248: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C3F24C: 13205407  vcmpneb. (lvlx128) v25, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[57] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C3F250: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C3F254: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C3F258: 12E04407  vcmpneb. (lvlx128) v23, v0, v8
	tmp.u32 = ctx.r[8].u32;
	// load shuffled into ctx.v[55] using VectorMaskL[(tmp.u32 & 0xF)]
	pc = 0x82C3F2E8; continue 'dispatch;
            }
            0x82C3F2E8 => {
    //   block [0x82C3F2E8..0x82C3F300)
	// 82C3F2E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C3F2EC: 4BFFF65D  bl 0x82c3e948
	ctx.lr = 0x82C3F2F0;
	sub_82C3E948(ctx, base);
	// 82C3F2F0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C3F2F4: 4BFCB3D5  bl 0x82c0a6c8
	ctx.lr = 0x82C3F2F8;
	sub_82C0A6C8(ctx, base);
	// 82C3F2F8: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C3F2FC: 4BC064B5  bl 0x828457b0
	ctx.lr = 0x82C3F300;
	sub_828457B0(ctx, base);
	pc = 0x82C3F300; continue 'dispatch;
            }
            0x82C3F300 => {
    //   block [0x82C3F300..0x82C3F30C)
	// 82C3F300: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 82C3F304: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82C3F308: 4806A138  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F310 size=212
    let mut pc: u32 = 0x82C3F310;
    'dispatch: loop {
        match pc {
            0x82C3F310 => {
    //   block [0x82C3F310..0x82C3F3E4)
	// 82C3F310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F31C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F320: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F328: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3F32C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C3F330: 394BC218  addi r10, r11, -0x3de8
	ctx.r[10].s64 = ctx.r[11].s64 + -15848;
	// 82C3F334: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C3F338: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3F33C: 4BFFEFE5  bl 0x82c3e320
	ctx.lr = 0x82C3F340;
	sub_82C3E320(ctx, base);
	// 82C3F340: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3F344: 389F001C  addi r4, r31, 0x1c
	ctx.r[4].s64 = ctx.r[31].s64 + 28;
	// 82C3F348: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C3F34C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C3F350: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C3F354: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F358: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82C3F35C: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3F360: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 82C3F364: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C3F368: 4BFFDEF9  bl 0x82c3d260
	ctx.lr = 0x82C3F36C;
	sub_82C3D260(ctx, base);
	// 82C3F36C: 807F0020  lwz r3, 0x20(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3F370: 4BC06441  bl 0x828457b0
	ctx.lr = 0x82C3F374;
	sub_828457B0(ctx, base);
	// 82C3F374: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C3F378: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 82C3F37C: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82C3F380: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C3F384: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82C3F388: 80FF0014  lwz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F38C: 80C70000  lwz r6, 0(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F390: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82C3F394: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 82C3F398: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 82C3F39C: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82C3F3A0: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C3F3A4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C3F3A8: 4BFFE511  bl 0x82c3d8b8
	ctx.lr = 0x82C3F3AC;
	sub_82C3D8B8(ctx, base);
	// 82C3F3AC: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F3B0: 4BC06401  bl 0x828457b0
	ctx.lr = 0x82C3F3B4;
	sub_828457B0(ctx, base);
	// 82C3F3B4: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82C3F3B8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C3F3BC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82C3F3C0: 48017071  bl 0x82c56430
	ctx.lr = 0x82C3F3C4;
	sub_82C56430(ctx, base);
	// 82C3F3C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F3C8: 4BFC6D49  bl 0x82c06110
	ctx.lr = 0x82C3F3CC;
	sub_82C06110(ctx, base);
	// 82C3F3CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3F3D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F3D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F3D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F3DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F3E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F3E8 size=80
    let mut pc: u32 = 0x82C3F3E8;
    'dispatch: loop {
        match pc {
            0x82C3F3E8 => {
    //   block [0x82C3F3E8..0x82C3F420)
	// 82C3F3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F400: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3F404: 4BFFFF0D  bl 0x82c3f310
	ctx.lr = 0x82C3F408;
	sub_82C3F310(ctx, base);
	// 82C3F408: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3F40C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F410: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F414: 419A000C  beq cr6, 0x82c3f420
	if ctx.cr[6].eq {
	pc = 0x82C3F420; continue 'dispatch;
	}
	// 82C3F418: 4BC06399  bl 0x828457b0
	ctx.lr = 0x82C3F41C;
	sub_828457B0(ctx, base);
	// 82C3F41C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3F420; continue 'dispatch;
            }
            0x82C3F420 => {
    //   block [0x82C3F420..0x82C3F438)
	// 82C3F420: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F424: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F428: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F42C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F430: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F438 size=144
    let mut pc: u32 = 0x82C3F438;
    'dispatch: loop {
        match pc {
            0x82C3F438 => {
    //   block [0x82C3F438..0x82C3F470)
	// 82C3F438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F43C: 48069FD1  bl 0x82ca940c
	ctx.lr = 0x82C3F440;
	sub_82CA93D0(ctx, base);
	// 82C3F440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F444: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C3F448: 38600034  li r3, 0x34
	ctx.r[3].s64 = 52;
	// 82C3F44C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3F450: 83FE0010  lwz r31, 0x10(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C3F454: 4B5DFE05  bl 0x8221f258
	ctx.lr = 0x82C3F458;
	sub_8221F258(ctx, base);
	// 82C3F458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3F45C: 419A0014  beq cr6, 0x82c3f470
	if ctx.cr[6].eq {
	pc = 0x82C3F470; continue 'dispatch;
	}
	// 82C3F460: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3F464: 4BFFE915  bl 0x82c3dd78
	ctx.lr = 0x82C3F468;
	sub_82C3DD78(ctx, base);
	// 82C3F468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F46C: 48000008  b 0x82c3f474
	pc = 0x82C3F474; continue 'dispatch;
            }
            0x82C3F470 => {
    //   block [0x82C3F470..0x82C3F474)
	// 82C3F470: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C3F474; continue 'dispatch;
            }
            0x82C3F474 => {
    //   block [0x82C3F474..0x82C3F4B0)
	// 82C3F474: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C3F478: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3F47C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F480: 4BFFE831  bl 0x82c3dcb0
	ctx.lr = 0x82C3F484;
	sub_82C3DCB0(ctx, base);
	// 82C3F484: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3F488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F48C: 409A0030  bne cr6, 0x82c3f4bc
	if !ctx.cr[6].eq {
	pc = 0x82C3F4BC; continue 'dispatch;
	}
	// 82C3F490: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C3F494: 419A001C  beq cr6, 0x82c3f4b0
	if ctx.cr[6].eq {
	pc = 0x82C3F4B0; continue 'dispatch;
	}
	// 82C3F498: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F49C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C3F4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F4A4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F4A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F4AC: 4E800421  bctrl
	ctx.lr = 0x82C3F4B0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3F4B0 => {
    //   block [0x82C3F4B0..0x82C3F4BC)
	// 82C3F4B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3F4B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F4B8: 48069FA4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3F4BC => {
    //   block [0x82C3F4BC..0x82C3F4C8)
	// 82C3F4BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F4C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F4C4: 48069F98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F4C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F4C8 size=396
    let mut pc: u32 = 0x82C3F4C8;
    'dispatch: loop {
        match pc {
            0x82C3F4C8 => {
    //   block [0x82C3F4C8..0x82C3F530)
	// 82C3F4C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F4CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F4D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F4D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F4D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F4DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F4E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3F4E4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F4E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F4EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F4F0: 4E800421  bctrl
	ctx.lr = 0x82C3F4F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F4F4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F4F8: 41980038  blt cr6, 0x82c3f530
	if ctx.cr[6].lt {
	pc = 0x82C3F530; continue 'dispatch;
	}
	// 82C3F4FC: 409A0118  bne cr6, 0x82c3f614
	if !ctx.cr[6].eq {
	pc = 0x82C3F614; continue 'dispatch;
	}
	// 82C3F500: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F504: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F508: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F50C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F510: 4E800421  bctrl
	ctx.lr = 0x82C3F514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F514: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F518: 41980070  blt cr6, 0x82c3f588
	if ctx.cr[6].lt {
	pc = 0x82C3F588; continue 'dispatch;
	}
	// 82C3F51C: 409A00F8  bne cr6, 0x82c3f614
	if !ctx.cr[6].eq {
	pc = 0x82C3F614; continue 'dispatch;
	}
	// 82C3F520: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3F524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F528: 419A0110  beq cr6, 0x82c3f638
	if ctx.cr[6].eq {
	pc = 0x82C3F638; continue 'dispatch;
	}
	// 82C3F52C: 48000024  b 0x82c3f550
	pc = 0x82C3F550; continue 'dispatch;
            }
            0x82C3F530 => {
    //   block [0x82C3F530..0x82C3F550)
	// 82C3F530: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F538: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F53C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F540: 4E800421  bctrl
	ctx.lr = 0x82C3F544;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F544: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F548: 41980040  blt cr6, 0x82c3f588
	if ctx.cr[6].lt {
	pc = 0x82C3F588; continue 'dispatch;
	}
	// 82C3F54C: 409A00C8  bne cr6, 0x82c3f614
	if !ctx.cr[6].eq {
	pc = 0x82C3F614; continue 'dispatch;
	}
            }
            0x82C3F550 => {
    //   block [0x82C3F550..0x82C3F588)
	// 82C3F550: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3F554: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F558: 4BFE2301  bl 0x82c21858
	ctx.lr = 0x82C3F55C;
	sub_82C21858(ctx, base);
	// 82C3F55C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C3F560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F564: 4BFFCAA5  bl 0x82c3c008
	ctx.lr = 0x82C3F568;
	sub_82C3C008(ctx, base);
	// 82C3F568: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F56C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F570: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3F574: 4BFF90B5  bl 0x82c38628
	ctx.lr = 0x82C3F578;
	sub_82C38628(ctx, base);
	// 82C3F578: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F57C: 4BFEB475  bl 0x82c2a9f0
	ctx.lr = 0x82C3F580;
	sub_82C2A9F0(ctx, base);
	// 82C3F580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F584: 480000B8  b 0x82c3f63c
	pc = 0x82C3F63C; continue 'dispatch;
            }
            0x82C3F588 => {
    //   block [0x82C3F588..0x82C3F60C)
	// 82C3F588: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3F58C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F590: 4BFFD311  bl 0x82c3c8a0
	ctx.lr = 0x82C3F594;
	sub_82C3C8A0(ctx, base);
	// 82C3F594: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C3F598: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F59C: 4BFFCA6D  bl 0x82c3c008
	ctx.lr = 0x82C3F5A0;
	sub_82C3C008(ctx, base);
	// 82C3F5A0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3F5A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F5A8: 419A0064  beq cr6, 0x82c3f60c
	if ctx.cr[6].eq {
	pc = 0x82C3F60C; continue 'dispatch;
	}
	// 82C3F5AC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3F5B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3F5B4: 392AC1E4  addi r9, r10, -0x3e1c
	ctx.r[9].s64 = ctx.r[10].s64 + -15900;
	// 82C3F5B8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C3F5BC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F5C0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C3F5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F5C8: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C3F5CC: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C3F5D0: 480064D9  bl 0x82c45aa8
	ctx.lr = 0x82C3F5D4;
	sub_82C45AA8(ctx, base);
	// 82C3F5D4: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C3F5D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3F5DC: 419A0040  beq cr6, 0x82c3f61c
	if ctx.cr[6].eq {
	pc = 0x82C3F61C; continue 'dispatch;
	}
	// 82C3F5E0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F5E4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3F5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F5EC: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C3F5F0: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C3F5F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3F5F8: 4E800421  bctrl
	ctx.lr = 0x82C3F5FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F5FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3F600: 4BFC61F9  bl 0x82c057f8
	ctx.lr = 0x82C3F604;
	sub_82C057F8(ctx, base);
	// 82C3F604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F608: 4BFFC521  bl 0x82c3bb28
	ctx.lr = 0x82C3F60C;
	sub_82C3BB28(ctx, base);
            }
            0x82C3F60C => {
    //   block [0x82C3F60C..0x82C3F614)
	// 82C3F60C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F610: 4BFFC431  bl 0x82c3ba40
	ctx.lr = 0x82C3F614;
	sub_82C3BA40(ctx, base);
	pc = 0x82C3F614; continue 'dispatch;
            }
            0x82C3F614 => {
    //   block [0x82C3F614..0x82C3F61C)
	// 82C3F614: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3F618: 48000024  b 0x82c3f63c
	pc = 0x82C3F63C; continue 'dispatch;
            }
            0x82C3F61C => {
    //   block [0x82C3F61C..0x82C3F638)
	// 82C3F61C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F620: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3F624: 4BFF9005  bl 0x82c38628
	ctx.lr = 0x82C3F628;
	sub_82C38628(ctx, base);
	// 82C3F628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F62C: 4BFFC4FD  bl 0x82c3bb28
	ctx.lr = 0x82C3F630;
	sub_82C3BB28(ctx, base);
	// 82C3F630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F634: 4BFFC40D  bl 0x82c3ba40
	ctx.lr = 0x82C3F638;
	sub_82C3BA40(ctx, base);
	pc = 0x82C3F638; continue 'dispatch;
            }
            0x82C3F638 => {
    //   block [0x82C3F638..0x82C3F63C)
	// 82C3F638: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C3F63C; continue 'dispatch;
            }
            0x82C3F63C => {
    //   block [0x82C3F63C..0x82C3F654)
	// 82C3F63C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3F640: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F644: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F648: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F64C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F658 size=396
    let mut pc: u32 = 0x82C3F658;
    'dispatch: loop {
        match pc {
            0x82C3F658 => {
    //   block [0x82C3F658..0x82C3F6C0)
	// 82C3F658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F65C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F668: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F670: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3F674: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F678: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F67C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F680: 4E800421  bctrl
	ctx.lr = 0x82C3F684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F684: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F688: 41980038  blt cr6, 0x82c3f6c0
	if ctx.cr[6].lt {
	pc = 0x82C3F6C0; continue 'dispatch;
	}
	// 82C3F68C: 409A0118  bne cr6, 0x82c3f7a4
	if !ctx.cr[6].eq {
	pc = 0x82C3F7A4; continue 'dispatch;
	}
	// 82C3F690: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F698: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F69C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F6A0: 4E800421  bctrl
	ctx.lr = 0x82C3F6A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F6A4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F6A8: 41980070  blt cr6, 0x82c3f718
	if ctx.cr[6].lt {
	pc = 0x82C3F718; continue 'dispatch;
	}
	// 82C3F6AC: 409A00F8  bne cr6, 0x82c3f7a4
	if !ctx.cr[6].eq {
	pc = 0x82C3F7A4; continue 'dispatch;
	}
	// 82C3F6B0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3F6B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F6B8: 419A0110  beq cr6, 0x82c3f7c8
	if ctx.cr[6].eq {
	pc = 0x82C3F7C8; continue 'dispatch;
	}
	// 82C3F6BC: 48000024  b 0x82c3f6e0
	pc = 0x82C3F6E0; continue 'dispatch;
            }
            0x82C3F6C0 => {
    //   block [0x82C3F6C0..0x82C3F6E0)
	// 82C3F6C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F6C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F6C8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3F6CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F6D0: 4E800421  bctrl
	ctx.lr = 0x82C3F6D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F6D4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3F6D8: 41980040  blt cr6, 0x82c3f718
	if ctx.cr[6].lt {
	pc = 0x82C3F718; continue 'dispatch;
	}
	// 82C3F6DC: 409A00C8  bne cr6, 0x82c3f7a4
	if !ctx.cr[6].eq {
	pc = 0x82C3F7A4; continue 'dispatch;
	}
            }
            0x82C3F6E0 => {
    //   block [0x82C3F6E0..0x82C3F718)
	// 82C3F6E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3F6E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F6E8: 4BFE2171  bl 0x82c21858
	ctx.lr = 0x82C3F6EC;
	sub_82C21858(ctx, base);
	// 82C3F6EC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C3F6F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F6F4: 4BFFCC85  bl 0x82c3c378
	ctx.lr = 0x82C3F6F8;
	sub_82C3C378(ctx, base);
	// 82C3F6F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F6FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3F704: 4BFF8F25  bl 0x82c38628
	ctx.lr = 0x82C3F708;
	sub_82C38628(ctx, base);
	// 82C3F708: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F70C: 4BFEB2E5  bl 0x82c2a9f0
	ctx.lr = 0x82C3F710;
	sub_82C2A9F0(ctx, base);
	// 82C3F710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F714: 480000B8  b 0x82c3f7cc
	pc = 0x82C3F7CC; continue 'dispatch;
            }
            0x82C3F718 => {
    //   block [0x82C3F718..0x82C3F79C)
	// 82C3F718: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3F71C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F720: 48007BE9  bl 0x82c47308
	ctx.lr = 0x82C3F724;
	sub_82C47308(ctx, base);
	// 82C3F724: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C3F728: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F72C: 4BFFCC4D  bl 0x82c3c378
	ctx.lr = 0x82C3F730;
	sub_82C3C378(ctx, base);
	// 82C3F730: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3F734: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3F738: 419A0064  beq cr6, 0x82c3f79c
	if ctx.cr[6].eq {
	pc = 0x82C3F79C; continue 'dispatch;
	}
	// 82C3F73C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3F740: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3F744: 392AC380  addi r9, r10, -0x3c80
	ctx.r[9].s64 = ctx.r[10].s64 + -15488;
	// 82C3F748: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C3F74C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F750: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C3F754: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F758: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C3F75C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C3F760: 48006349  bl 0x82c45aa8
	ctx.lr = 0x82C3F764;
	sub_82C45AA8(ctx, base);
	// 82C3F764: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C3F768: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C3F76C: 419A0040  beq cr6, 0x82c3f7ac
	if ctx.cr[6].eq {
	pc = 0x82C3F7AC; continue 'dispatch;
	}
	// 82C3F770: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F774: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3F778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F77C: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C3F780: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C3F784: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3F788: 4E800421  bctrl
	ctx.lr = 0x82C3F78C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F78C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3F790: 4BFC6069  bl 0x82c057f8
	ctx.lr = 0x82C3F794;
	sub_82C057F8(ctx, base);
	// 82C3F794: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F798: 48003181  bl 0x82c42918
	ctx.lr = 0x82C3F79C;
	sub_82C42918(ctx, base);
            }
            0x82C3F79C => {
    //   block [0x82C3F79C..0x82C3F7A4)
	// 82C3F79C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F7A0: 4BFDC821  bl 0x82c1bfc0
	ctx.lr = 0x82C3F7A4;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C3F7A4; continue 'dispatch;
            }
            0x82C3F7A4 => {
    //   block [0x82C3F7A4..0x82C3F7AC)
	// 82C3F7A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3F7A8: 48000024  b 0x82c3f7cc
	pc = 0x82C3F7CC; continue 'dispatch;
            }
            0x82C3F7AC => {
    //   block [0x82C3F7AC..0x82C3F7C8)
	// 82C3F7AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C3F7B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3F7B4: 4BFF8E75  bl 0x82c38628
	ctx.lr = 0x82C3F7B8;
	sub_82C38628(ctx, base);
	// 82C3F7B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3F7BC: 4800315D  bl 0x82c42918
	ctx.lr = 0x82C3F7C0;
	sub_82C42918(ctx, base);
	// 82C3F7C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C3F7C4: 4BFDC7FD  bl 0x82c1bfc0
	ctx.lr = 0x82C3F7C8;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C3F7C8; continue 'dispatch;
            }
            0x82C3F7C8 => {
    //   block [0x82C3F7C8..0x82C3F7CC)
	// 82C3F7C8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C3F7CC; continue 'dispatch;
            }
            0x82C3F7CC => {
    //   block [0x82C3F7CC..0x82C3F7E4)
	// 82C3F7CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C3F7D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F7D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F7D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F7DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F7E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3F7E8 size=16
    let mut pc: u32 = 0x82C3F7E8;
    'dispatch: loop {
        match pc {
            0x82C3F7E8 => {
    //   block [0x82C3F7E8..0x82C3F7F8)
	// 82C3F7E8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3F7EC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3F7F0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C3F7F4: 4BFFFCD4  b 0x82c3f4c8
	sub_82C3F4C8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3F7F8 size=16
    let mut pc: u32 = 0x82C3F7F8;
    'dispatch: loop {
        match pc {
            0x82C3F7F8 => {
    //   block [0x82C3F7F8..0x82C3F808)
	// 82C3F7F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C3F7FC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3F800: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C3F804: 4BFFFE54  b 0x82c3f658
	sub_82C3F658(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3F808 size=12
    let mut pc: u32 = 0x82C3F808;
    'dispatch: loop {
        match pc {
            0x82C3F808 => {
    //   block [0x82C3F808..0x82C3F814)
	// 82C3F808: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C3F80C: 386B4F98  addi r3, r11, 0x4f98
	ctx.r[3].s64 = ctx.r[11].s64 + 20376;
	// 82C3F810: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F818(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C3F818 size=12
    let mut pc: u32 = 0x82C3F818;
    'dispatch: loop {
        match pc {
            0x82C3F818 => {
    //   block [0x82C3F818..0x82C3F824)
	// 82C3F818: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C3F81C: 386B4F94  addi r3, r11, 0x4f94
	ctx.r[3].s64 = ctx.r[11].s64 + 20372;
	// 82C3F820: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F828 size=96
    let mut pc: u32 = 0x82C3F828;
    'dispatch: loop {
        match pc {
            0x82C3F828 => {
    //   block [0x82C3F828..0x82C3F85C)
	// 82C3F828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F82C: 48069BE1  bl 0x82ca940c
	ctx.lr = 0x82C3F830;
	sub_82CA93D0(ctx, base);
	// 82C3F830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F834: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C3F838: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F83C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C3F840: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C3F844: 419A0018  beq cr6, 0x82c3f85c
	if ctx.cr[6].eq {
	pc = 0x82C3F85C; continue 'dispatch;
	}
	// 82C3F848: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F84C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3F850: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F854: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F858: 4E800421  bctrl
	ctx.lr = 0x82C3F85C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3F85C => {
    //   block [0x82C3F85C..0x82C3F878)
	// 82C3F85C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F860: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3F864: 419A0014  beq cr6, 0x82c3f878
	if ctx.cr[6].eq {
	pc = 0x82C3F878; continue 'dispatch;
	}
	// 82C3F868: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F86C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F870: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F874: 4E800421  bctrl
	ctx.lr = 0x82C3F878;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C3F878 => {
    //   block [0x82C3F878..0x82C3F888)
	// 82C3F878: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C3F87C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C3F880: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F884: 48069BD8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F888 size=92
    let mut pc: u32 = 0x82C3F888;
    'dispatch: loop {
        match pc {
            0x82C3F888 => {
    //   block [0x82C3F888..0x82C3F8CC)
	// 82C3F888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F88C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F890: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F894: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F89C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F8A0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3F8A4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C3F8A8: 394BC294  addi r10, r11, -0x3d6c
	ctx.r[10].s64 = ctx.r[11].s64 + -15724;
	// 82C3F8AC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3F8B0: 4BFC6989  bl 0x82c06238
	ctx.lr = 0x82C3F8B4;
	sub_82C06238(ctx, base);
	// 82C3F8B4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C3F8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3F8BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3F8C0: 419A000C  beq cr6, 0x82c3f8cc
	if ctx.cr[6].eq {
	pc = 0x82C3F8CC; continue 'dispatch;
	}
	// 82C3F8C4: 4BC05EED  bl 0x828457b0
	ctx.lr = 0x82C3F8C8;
	sub_828457B0(ctx, base);
	// 82C3F8C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C3F8CC; continue 'dispatch;
            }
            0x82C3F8CC => {
    //   block [0x82C3F8CC..0x82C3F8E4)
	// 82C3F8CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F8D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F8DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F8E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F8E8 size=196
    let mut pc: u32 = 0x82C3F8E8;
    'dispatch: loop {
        match pc {
            0x82C3F8E8 => {
    //   block [0x82C3F8E8..0x82C3F914)
	// 82C3F8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F8EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F8F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3F8F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3F8F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F8FC: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C3F900: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3F904: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C3F908: 816B4F90  lwz r11, 0x4f90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20368 as u32) ) } as u64;
	// 82C3F90C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C3F910: 4099000C  ble cr6, 0x82c3f91c
	if !ctx.cr[6].gt {
	pc = 0x82C3F91C; continue 'dispatch;
	}
	pc = 0x82C3F914; continue 'dispatch;
            }
            0x82C3F914 => {
    //   block [0x82C3F914..0x82C3F91C)
	// 82C3F914: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3F918: 4800007C  b 0x82c3f994
	pc = 0x82C3F994; continue 'dispatch;
            }
            0x82C3F91C => {
    //   block [0x82C3F91C..0x82C3F97C)
	// 82C3F91C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F920: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3F924: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F928: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3F92C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3F930: 4E800421  bctrl
	ctx.lr = 0x82C3F934;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F934: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F938: 4BFCB211  bl 0x82c0ab48
	ctx.lr = 0x82C3F93C;
	sub_82C0AB48(ctx, base);
	// 82C3F93C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3F940: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C3F944: 419AFFD0  beq cr6, 0x82c3f914
	if ctx.cr[6].eq {
	pc = 0x82C3F914; continue 'dispatch;
	}
	// 82C3F948: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C3F94C: 4B5DF90D  bl 0x8221f258
	ctx.lr = 0x82C3F950;
	sub_8221F258(ctx, base);
	// 82C3F950: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3F954: 419A0028  beq cr6, 0x82c3f97c
	if ctx.cr[6].eq {
	pc = 0x82C3F97C; continue 'dispatch;
	}
	// 82C3F958: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3F95C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3F960: 392AC2B8  addi r9, r10, -0x3d48
	ctx.r[9].s64 = ctx.r[10].s64 + -15688;
	// 82C3F964: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3F968: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C3F96C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3F970: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3F974: 90630004  stw r3, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C3F978: 48000008  b 0x82c3f980
	pc = 0x82C3F980; continue 'dispatch;
            }
            0x82C3F97C => {
    //   block [0x82C3F97C..0x82C3F980)
	// 82C3F97C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	pc = 0x82C3F980; continue 'dispatch;
            }
            0x82C3F980 => {
    //   block [0x82C3F980..0x82C3F994)
	// 82C3F980: 93E5000C  stw r31, 0xc(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C3F984: 387E0040  addi r3, r30, 0x40
	ctx.r[3].s64 = ctx.r[30].s64 + 64;
	// 82C3F988: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82C3F98C: 4BFFFE9D  bl 0x82c3f828
	ctx.lr = 0x82C3F990;
	sub_82C3F828(ctx, base);
	// 82C3F990: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C3F994; continue 'dispatch;
            }
            0x82C3F994 => {
    //   block [0x82C3F994..0x82C3F9AC)
	// 82C3F994: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3F998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F99C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F9A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3F9A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3F9A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3F9B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3F9B0 size=84
    let mut pc: u32 = 0x82C3F9B0;
    'dispatch: loop {
        match pc {
            0x82C3F9B0 => {
    //   block [0x82C3F9B0..0x82C3F9F0)
	// 82C3F9B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3F9B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3F9B8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3F9BC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3F9C0: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3F9C4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3F9C8: 388A4F94  addi r4, r10, 0x4f94
	ctx.r[4].s64 = ctx.r[10].s64 + 20372;
	// 82C3F9CC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3F9D0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3F9D4: 4E800421  bctrl
	ctx.lr = 0x82C3F9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3F9D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3F9DC: 409A0014  bne cr6, 0x82c3f9f0
	if !ctx.cr[6].eq {
	pc = 0x82C3F9F0; continue 'dispatch;
	}
	// 82C3F9E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3F9E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F9E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3F9EC: 4E800020  blr
	return;
            }
            0x82C3F9F0 => {
    //   block [0x82C3F9F0..0x82C3FA04)
	// 82C3F9F0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3F9F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3F9F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3F9FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FA00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FA08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FA08 size=144
    let mut pc: u32 = 0x82C3FA08;
    'dispatch: loop {
        match pc {
            0x82C3FA08 => {
    //   block [0x82C3FA08..0x82C3FA40)
	// 82C3FA08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FA0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FA10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3FA14: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FA18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FA1C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3FA20: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3FA24: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C3FA28: 388A4F94  addi r4, r10, 0x4f94
	ctx.r[4].s64 = ctx.r[10].s64 + 20372;
	// 82C3FA2C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3FA30: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3FA34: 4E800421  bctrl
	ctx.lr = 0x82C3FA38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FA38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3FA3C: 409A001C  bne cr6, 0x82c3fa58
	if !ctx.cr[6].eq {
	pc = 0x82C3FA58; continue 'dispatch;
	}
            }
            0x82C3FA40 => {
    //   block [0x82C3FA40..0x82C3FA58)
	// 82C3FA40: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3FA44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3FA48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FA4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FA50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3FA54: 4E800020  blr
	return;
            }
            0x82C3FA58 => {
    //   block [0x82C3FA58..0x82C3FA98)
	// 82C3FA58: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C3FA5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C3FA60: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C3FA64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FA68: 4BFF8FA9  bl 0x82c38a10
	ctx.lr = 0x82C3FA6C;
	sub_82C38A10(ctx, base);
	// 82C3FA6C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3FA70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3FA74: 419AFFCC  beq cr6, 0x82c3fa40
	if ctx.cr[6].eq {
	pc = 0x82C3FA40; continue 'dispatch;
	}
	// 82C3FA78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FA7C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C3FA80: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3FA84: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3FA88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FA8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FA90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3FA94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FA98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FA98 size=76
    let mut pc: u32 = 0x82C3FA98;
    'dispatch: loop {
        match pc {
            0x82C3FA98 => {
    //   block [0x82C3FA98..0x82C3FAD0)
	// 82C3FA98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FA9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FAA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FAA4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C3FAA8: 4B5DF7B1  bl 0x8221f258
	ctx.lr = 0x82C3FAAC;
	sub_8221F258(ctx, base);
	// 82C3FAAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3FAB0: 419A0020  beq cr6, 0x82c3fad0
	if ctx.cr[6].eq {
	pc = 0x82C3FAD0; continue 'dispatch;
	}
	// 82C3FAB4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3FAB8: 394BC294  addi r10, r11, -0x3d6c
	ctx.r[10].s64 = ctx.r[11].s64 + -15724;
	// 82C3FABC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C3FAC0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FAC4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FAC8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FACC: 4E800020  blr
	return;
            }
            0x82C3FAD0 => {
    //   block [0x82C3FAD0..0x82C3FAE4)
	// 82C3FAD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3FAD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FAD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FADC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FAE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FAE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FAE8 size=272
    let mut pc: u32 = 0x82C3FAE8;
    'dispatch: loop {
        match pc {
            0x82C3FAE8 => {
    //   block [0x82C3FAE8..0x82C3FBA4)
	// 82C3FAE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FAEC: 48069921  bl 0x82ca940c
	ctx.lr = 0x82C3FAF0;
	sub_82CA93D0(ctx, base);
	// 82C3FAF0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FAF4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C3FAF8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C3FAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FB00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FB04: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3FB08: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FB0C: 4E800421  bctrl
	ctx.lr = 0x82C3FB10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FB10: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FB14: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C3FB18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FB1C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FB20: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3FB24: 4E800421  bctrl
	ctx.lr = 0x82C3FB28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FB28: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C3FB2C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C3FB30: 3887AF70  addi r4, r7, -0x5090
	ctx.r[4].s64 = ctx.r[7].s64 + -20624;
	// 82C3FB34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FB38: 4BFC7671  bl 0x82c071a8
	ctx.lr = 0x82C3FB3C;
	sub_82C071A8(ctx, base);
	// 82C3FB3C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FB40: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3FB44: 419A0060  beq cr6, 0x82c3fba4
	if ctx.cr[6].eq {
	pc = 0x82C3FBA4; continue 'dispatch;
	}
	// 82C3FB48: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3FB4C: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C3FB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FB54: 388BB3BC  addi r4, r11, -0x4c44
	ctx.r[4].s64 = ctx.r[11].s64 + -19524;
	// 82C3FB58: 409A006C  bne cr6, 0x82c3fbc4
	if !ctx.cr[6].eq {
	pc = 0x82C3FBC4; continue 'dispatch;
	}
	// 82C3FB5C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C3FB60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C3FB64: 4BFC7645  bl 0x82c071a8
	ctx.lr = 0x82C3FB68;
	sub_82C071A8(ctx, base);
	// 82C3FB68: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FB6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3FB70: 409A005C  bne cr6, 0x82c3fbcc
	if !ctx.cr[6].eq {
	pc = 0x82C3FBCC; continue 'dispatch;
	}
	// 82C3FB74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3FB78: 4B5B7C89  bl 0x821f7800
	ctx.lr = 0x82C3FB7C;
	sub_821F7800(ctx, base);
	// 82C3FB7C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3FB80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C3FB84: 388BB3B0  addi r4, r11, -0x4c50
	ctx.r[4].s64 = ctx.r[11].s64 + -19536;
	// 82C3FB88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FB8C: 4BFDB72D  bl 0x82c1b2b8
	ctx.lr = 0x82C3FB90;
	sub_82C1B2B8(ctx, base);
	// 82C3FB90: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FB94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3FB98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3FB9C: 409A0014  bne cr6, 0x82c3fbb0
	if !ctx.cr[6].eq {
	pc = 0x82C3FBB0; continue 'dispatch;
	}
	// 82C3FBA0: 4B5D5239  bl 0x82214dd8
	ctx.lr = 0x82C3FBA4;
	sub_82214DD8(ctx, base);
            }
            0x82C3FBA4 => {
    //   block [0x82C3FBA4..0x82C3FBB0)
	// 82C3FBA4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3FBA8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3FBAC: 480698B0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3FBB0 => {
    //   block [0x82C3FBB0..0x82C3FBC4)
	// 82C3FBB0: 4BFC3C41  bl 0x82c037f0
	ctx.lr = 0x82C3FBB4;
	sub_82C037F0(ctx, base);
	// 82C3FBB4: 907D0000  stw r3, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82C3FBB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C3FBBC: 4B5D521D  bl 0x82214dd8
	ctx.lr = 0x82C3FBC0;
	sub_82214DD8(ctx, base);
	// 82C3FBC0: 4800000C  b 0x82c3fbcc
	pc = 0x82C3FBCC; continue 'dispatch;
            }
            0x82C3FBC4 => {
    //   block [0x82C3FBC4..0x82C3FBCC)
	// 82C3FBC4: 38BE0004  addi r5, r30, 4
	ctx.r[5].s64 = ctx.r[30].s64 + 4;
	// 82C3FBC8: 4BFC75E1  bl 0x82c071a8
	ctx.lr = 0x82C3FBCC;
	sub_82C071A8(ctx, base);
	pc = 0x82C3FBCC; continue 'dispatch;
            }
            0x82C3FBCC => {
    //   block [0x82C3FBCC..0x82C3FBF8)
	// 82C3FBCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C3FBD0: 38BE0008  addi r5, r30, 8
	ctx.r[5].s64 = ctx.r[30].s64 + 8;
	// 82C3FBD4: 388BB3A4  addi r4, r11, -0x4c5c
	ctx.r[4].s64 = ctx.r[11].s64 + -19548;
	// 82C3FBD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FBDC: 4BFDB9D5  bl 0x82c1b5b0
	ctx.lr = 0x82C3FBE0;
	sub_82C1B5B0(ctx, base);
	// 82C3FBE0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FBE4: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 82C3FBE8: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82C3FBEC: 69030001  xori r3, r8, 1
	ctx.r[3].u64 = ctx.r[8].u64 ^ 1;
	// 82C3FBF0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C3FBF4: 48069868  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FBF8 size=148
    let mut pc: u32 = 0x82C3FBF8;
    'dispatch: loop {
        match pc {
            0x82C3FBF8 => {
    //   block [0x82C3FBF8..0x82C3FC6C)
	// 82C3FBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FBFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FC00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C3FC04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3FC08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FC0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3FC10: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C3FC14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FC18: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C3FC1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FC20: 4E800421  bctrl
	ctx.lr = 0x82C3FC24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FC24: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FC28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3FC2C: 419A0040  beq cr6, 0x82c3fc6c
	if ctx.cr[6].eq {
	pc = 0x82C3FC6C; continue 'dispatch;
	}
	// 82C3FC30: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3FC34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C3FC38: 4BFFFEB1  bl 0x82c3fae8
	ctx.lr = 0x82C3FC3C;
	sub_82C3FAE8(ctx, base);
	// 82C3FC3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3FC44: 419A0028  beq cr6, 0x82c3fc6c
	if ctx.cr[6].eq {
	pc = 0x82C3FC6C; continue 'dispatch;
	}
	// 82C3FC48: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FC4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C3FC50: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C3FC54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FC58: 4E800421  bctrl
	ctx.lr = 0x82C3FC5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FC5C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FC60: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C3FC64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C3FC68: 409A0008  bne cr6, 0x82c3fc70
	if !ctx.cr[6].eq {
	pc = 0x82C3FC70; continue 'dispatch;
	}
            }
            0x82C3FC6C => {
    //   block [0x82C3FC6C..0x82C3FC70)
	// 82C3FC6C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C3FC70; continue 'dispatch;
            }
            0x82C3FC70 => {
    //   block [0x82C3FC70..0x82C3FC8C)
	// 82C3FC70: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C3FC74: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C3FC78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FC7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FC80: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C3FC84: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3FC88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FC90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FC90 size=100
    let mut pc: u32 = 0x82C3FC90;
    'dispatch: loop {
        match pc {
            0x82C3FC90 => {
    //   block [0x82C3FC90..0x82C3FCE0)
	// 82C3FC90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FC94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FC98: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FC9C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C3FCA0: 409A0040  bne cr6, 0x82c3fce0
	if !ctx.cr[6].eq {
	pc = 0x82C3FCE0; continue 'dispatch;
	}
	// 82C3FCA4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C3FCA8: 4B5DF5B1  bl 0x8221f258
	ctx.lr = 0x82C3FCAC;
	sub_8221F258(ctx, base);
	// 82C3FCAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3FCB0: 419A0030  beq cr6, 0x82c3fce0
	if ctx.cr[6].eq {
	pc = 0x82C3FCE0; continue 'dispatch;
	}
	// 82C3FCB4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C3FCB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C3FCBC: 392AC2C4  addi r9, r10, -0x3d3c
	ctx.r[9].s64 = ctx.r[10].s64 + -15676;
	// 82C3FCC0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C3FCC4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C3FCC8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C3FCCC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C3FCD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FCD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FCD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FCDC: 4E800020  blr
	return;
            }
            0x82C3FCE0 => {
    //   block [0x82C3FCE0..0x82C3FCF4)
	// 82C3FCE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C3FCE4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FCE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FCEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FCF0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FCF8 size=44
    let mut pc: u32 = 0x82C3FCF8;
    'dispatch: loop {
        match pc {
            0x82C3FCF8 => {
    //   block [0x82C3FCF8..0x82C3FD24)
	// 82C3FCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FD00: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FD04: 4BFFFD05  bl 0x82c3fa08
	ctx.lr = 0x82C3FD08;
	sub_82C3FA08(ctx, base);
	// 82C3FD08: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C3FD0C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82C3FD10: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 82C3FD14: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FD18: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FD1C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FD20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FD28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C3FD28 size=112
    let mut pc: u32 = 0x82C3FD28;
    'dispatch: loop {
        match pc {
            0x82C3FD28 => {
    //   block [0x82C3FD28..0x82C3FD74)
	// 82C3FD28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FD2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C3FD30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C3FD34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FD38: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FD3C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C3FD40: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C3FD44: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C3FD48: 388A4F94  addi r4, r10, 0x4f94
	ctx.r[4].s64 = ctx.r[10].s64 + 20372;
	// 82C3FD4C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3FD50: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C3FD54: 4E800421  bctrl
	ctx.lr = 0x82C3FD58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FD58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3FD5C: 409A0018  bne cr6, 0x82c3fd74
	if !ctx.cr[6].eq {
	pc = 0x82C3FD74; continue 'dispatch;
	}
	// 82C3FD60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FD64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FD68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FD6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3FD70: 4E800020  blr
	return;
            }
            0x82C3FD74 => {
    //   block [0x82C3FD74..0x82C3FD98)
	// 82C3FD74: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3FD78: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C3FD7C: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C3FD80: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FD84: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C3FD88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C3FD8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C3FD90: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C3FD94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C3FD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C3FD98 size=908
    let mut pc: u32 = 0x82C3FD98;
    'dispatch: loop {
        match pc {
            0x82C3FD98 => {
    //   block [0x82C3FD98..0x82C3FE0C)
	// 82C3FD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C3FD9C: 48069661  bl 0x82ca93fc
	ctx.lr = 0x82C3FDA0;
	sub_82CA93D0(ctx, base);
	// 82C3FDA0: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82C3FDA4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C3FDA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C3FDAC: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 82C3FDB0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FDB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FDB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FDBC: 4E800421  bctrl
	ctx.lr = 0x82C3FDC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FDC0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3FDC4: 41980144  blt cr6, 0x82c3ff08
	if ctx.cr[6].lt {
	pc = 0x82C3FF08; continue 'dispatch;
	}
	// 82C3FDC8: 409A02A8  bne cr6, 0x82c40070
	if !ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FDCC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FDD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FDD4: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3FDD8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FDDC: 4E800421  bctrl
	ctx.lr = 0x82C3FDE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FDE0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3FDE4: 4198006C  blt cr6, 0x82c3fe50
	if ctx.cr[6].lt {
	pc = 0x82C3FE50; continue 'dispatch;
	}
	// 82C3FDE8: 409A0288  bne cr6, 0x82c40070
	if !ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FDEC: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3FDF0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3FDF4: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C3FDF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3FDFC: 40990318  ble cr6, 0x82c40114
	if !ctx.cr[6].gt {
	pc = 0x82C40114; continue 'dispatch;
	}
	// 82C3FE00: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3FE04: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3FE08: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3FE0C => {
    //   block [0x82C3FE0C..0x82C3FE50)
	// 82C3FE0C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FE10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3FE14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FE18: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3FE1C: 4BFFFDDD  bl 0x82c3fbf8
	ctx.lr = 0x82C3FE20;
	sub_82C3FBF8(ctx, base);
	// 82C3FE20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FE24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3FE28: 419A0248  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FE2C: 81790008  lwz r11, 8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3FE30: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3FE34: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3FE38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3FE3C: 4198FFD0  blt cr6, 0x82c3fe0c
	if ctx.cr[6].lt {
	pc = 0x82C3FE0C; continue 'dispatch;
	}
	// 82C3FE40: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3FE44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3FE48: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3FE4C: 48069600  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3FE50 => {
    //   block [0x82C3FE50..0x82C3FE9C)
	// 82C3FE50: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FE54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FE58: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C3FE5C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FE60: 4E800421  bctrl
	ctx.lr = 0x82C3FE64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FE64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3FE68: 3B6B5D98  addi r27, r11, 0x5d98
	ctx.r[27].s64 = ctx.r[11].s64 + 23960;
	// 82C3FE6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3FE70: 4BFC8D49  bl 0x82c08bb8
	ctx.lr = 0x82C3FE74;
	sub_82C08BB8(ctx, base);
	// 82C3FE74: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C3FE78: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3FE7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C3FE80: 4BFE6421  bl 0x82c262a0
	ctx.lr = 0x82C3FE84;
	sub_82C262A0(ctx, base);
	// 82C3FE84: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3FE88: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C3FE8C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C3FE90: 419A0284  beq cr6, 0x82c40114
	if ctx.cr[6].eq {
	pc = 0x82C40114; continue 'dispatch;
	}
	// 82C3FE94: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C3FE98: C3EB0C14  lfs f31, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
            }
            0x82C3FE9C => {
    //   block [0x82C3FE9C..0x82C3FEC0)
	// 82C3FE9C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C3FEA0: 4B5DF3B9  bl 0x8221f258
	ctx.lr = 0x82C3FEA4;
	sub_8221F258(ctx, base);
	// 82C3FEA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C3FEA8: 419A0018  beq cr6, 0x82c3fec0
	if ctx.cr[6].eq {
	pc = 0x82C3FEC0; continue 'dispatch;
	}
	// 82C3FEAC: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C3FEB0: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C3FEB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3FEB8: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C3FEBC: 48000008  b 0x82c3fec4
	pc = 0x82C3FEC4; continue 'dispatch;
            }
            0x82C3FEC0 => {
    //   block [0x82C3FEC0..0x82C3FEC4)
	// 82C3FEC0: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82C3FEC4; continue 'dispatch;
            }
            0x82C3FEC4 => {
    //   block [0x82C3FEC4..0x82C3FF08)
	// 82C3FEC4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C3FEC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C3FECC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FED0: 4BFFFD29  bl 0x82c3fbf8
	ctx.lr = 0x82C3FED4;
	sub_82C3FBF8(ctx, base);
	// 82C3FED4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FED8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3FEDC: 419A0194  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FEE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C3FEE4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C3FEE8: 4BFE6801  bl 0x82c266e8
	ctx.lr = 0x82C3FEEC;
	sub_82C266E8(ctx, base);
	// 82C3FEEC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C3FEF0: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C3FEF4: 4198FFA8  blt cr6, 0x82c3fe9c
	if ctx.cr[6].lt {
	pc = 0x82C3FE9C; continue 'dispatch;
	}
	// 82C3FEF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3FEFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3FF00: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3FF04: 48069548  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3FF08 => {
    //   block [0x82C3FF08..0x82C3FF88)
	// 82C3FF08: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FF0C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FF10: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C3FF14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FF18: 4E800421  bctrl
	ctx.lr = 0x82C3FF1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FF1C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C3FF20: 419800AC  blt cr6, 0x82c3ffcc
	if ctx.cr[6].lt {
	pc = 0x82C3FFCC; continue 'dispatch;
	}
	// 82C3FF24: 409A014C  bne cr6, 0x82c40070
	if !ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FF28: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FF2C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FF30: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3FF34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FF38: 4E800421  bctrl
	ctx.lr = 0x82C3FF3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FF3C: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FF40: 81190008  lwz r8, 8(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C3FF44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3FF48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FF4C: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3FF50: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C3FF54: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C3FF58: 4E800421  bctrl
	ctx.lr = 0x82C3FF5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FF5C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FF60: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C3FF64: 419A010C  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FF68: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3FF6C: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C3FF70: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82C3FF74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C3FF78: 419A019C  beq cr6, 0x82c40114
	if ctx.cr[6].eq {
	pc = 0x82C40114; continue 'dispatch;
	}
	// 82C3FF7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C3FF80: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	// 82C3FF84: 3BCB5D98  addi r30, r11, 0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C3FF88 => {
    //   block [0x82C3FF88..0x82C3FFCC)
	// 82C3FF88: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FF8C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C3FF90: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FF94: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C3FF98: 4BFFFC61  bl 0x82c3fbf8
	ctx.lr = 0x82C3FF9C;
	sub_82C3FBF8(ctx, base);
	// 82C3FF9C: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C3FFA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C3FFA4: 419A00CC  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C3FFA8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C3FFAC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C3FFB0: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C3FFB4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C3FFB8: 4198FFD0  blt cr6, 0x82c3ff88
	if ctx.cr[6].lt {
	pc = 0x82C3FF88; continue 'dispatch;
	}
	// 82C3FFBC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C3FFC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C3FFC4: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C3FFC8: 48069484  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C3FFCC => {
    //   block [0x82C3FFCC..0x82C40070)
	// 82C3FFCC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FFD0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FFD4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C3FFD8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C3FFDC: 4E800421  bctrl
	ctx.lr = 0x82C3FFE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FFE0: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C3FFE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C3FFE8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C3FFEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C3FFF0: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C3FFF4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C3FFF8: 4E800421  bctrl
	ctx.lr = 0x82C3FFFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C3FFFC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C40000: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C40004: 419A006C  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C40008: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4000C: 4BFC7D15  bl 0x82c07d20
	ctx.lr = 0x82C40010;
	sub_82C07D20(ctx, base);
	// 82C40010: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40014: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C40018: 40990068  ble cr6, 0x82c40080
	if !ctx.cr[6].gt {
	pc = 0x82C40080; continue 'dispatch;
	}
	// 82C4001C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40020: 4BFC7D01  bl 0x82c07d20
	ctx.lr = 0x82C40024;
	sub_82C07D20(ctx, base);
	// 82C40024: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40028: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4002C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40030: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C40034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C40038: 3BAAB0E8  addi r29, r10, -0x4f18
	ctx.r[29].s64 = ctx.r[10].s64 + -20248;
	// 82C4003C: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C40040: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C40044: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C40048: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4004C: 4E800421  bctrl
	ctx.lr = 0x82C40050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C40050: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C40054: 4BFC57A5  bl 0x82c057f8
	ctx.lr = 0x82C40058;
	sub_82C057F8(ctx, base);
	// 82C40058: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4005C: 4BFC580D  bl 0x82c05868
	ctx.lr = 0x82C40060;
	sub_82C05868(ctx, base);
	// 82C40060: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C40064: 4BFC5795  bl 0x82c057f8
	ctx.lr = 0x82C40068;
	sub_82C057F8(ctx, base);
	// 82C40068: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4006C: 4BFC57FD  bl 0x82c05868
	ctx.lr = 0x82C40070;
	sub_82C05868(ctx, base);
            }
            0x82C40070 => {
    //   block [0x82C40070..0x82C40080)
	// 82C40070: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C40074: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C40078: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C4007C: 480693D0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C40080 => {
    //   block [0x82C40080..0x82C400B4)
	// 82C40080: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C40084: 4BFE621D  bl 0x82c262a0
	ctx.lr = 0x82C40088;
	sub_82C262A0(ctx, base);
	// 82C40088: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4008C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40090: 419A0084  beq cr6, 0x82c40114
	if ctx.cr[6].eq {
	pc = 0x82C40114; continue 'dispatch;
	}
	// 82C40094: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C40098: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4009C: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 82C400A0: 419A0074  beq cr6, 0x82c40114
	if ctx.cr[6].eq {
	pc = 0x82C40114; continue 'dispatch;
	}
	// 82C400A4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C400A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C400AC: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
	// 82C400B0: C3EA0C14  lfs f31, 0xc14(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82C400B4; continue 'dispatch;
            }
            0x82C400B4 => {
    //   block [0x82C400B4..0x82C400D8)
	// 82C400B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C400B8: 4B5DF1A1  bl 0x8221f258
	ctx.lr = 0x82C400BC;
	sub_8221F258(ctx, base);
	// 82C400BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C400C0: 419A0018  beq cr6, 0x82c400d8
	if ctx.cr[6].eq {
	pc = 0x82C400D8; continue 'dispatch;
	}
	// 82C400C4: D3E30008  stfs f31, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C400C8: 93430000  stw r26, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82C400CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C400D0: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 82C400D4: 48000008  b 0x82c400dc
	pc = 0x82C400DC; continue 'dispatch;
            }
            0x82C400D8 => {
    //   block [0x82C400D8..0x82C400DC)
	// 82C400D8: 7F5FD378  mr r31, r26
	ctx.r[31].u64 = ctx.r[26].u64;
	pc = 0x82C400DC; continue 'dispatch;
            }
            0x82C400DC => {
    //   block [0x82C400DC..0x82C40114)
	// 82C400DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C400E0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C400E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C400E8: 4BFFFB11  bl 0x82c3fbf8
	ctx.lr = 0x82C400EC;
	sub_82C3FBF8(ctx, base);
	// 82C400EC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C400F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C400F4: 419AFF7C  beq cr6, 0x82c40070
	if ctx.cr[6].eq {
	pc = 0x82C40070; continue 'dispatch;
	}
	// 82C400F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C400FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C40100: 4BFE65E9  bl 0x82c266e8
	ctx.lr = 0x82C40104;
	sub_82C266E8(ctx, base);
	// 82C40104: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40108: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4010C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40110: 4198FFA4  blt cr6, 0x82c400b4
	if ctx.cr[6].lt {
	pc = 0x82C400B4; continue 'dispatch;
	}
	pc = 0x82C40114; continue 'dispatch;
            }
            0x82C40114 => {
    //   block [0x82C40114..0x82C40124)
	// 82C40114: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C40118: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4011C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82C40120: 4806932C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40128 size=104
    let mut pc: u32 = 0x82C40128;
    'dispatch: loop {
        match pc {
            0x82C40128 => {
    //   block [0x82C40128..0x82C40168)
	// 82C40128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4012C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C40130: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C40134: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40138: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4013C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C40140: 419A003C  beq cr6, 0x82c4017c
	if ctx.cr[6].eq {
	pc = 0x82C4017C; continue 'dispatch;
	}
	// 82C40144: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40148: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4014C: 419A001C  beq cr6, 0x82c40168
	if ctx.cr[6].eq {
	pc = 0x82C40168; continue 'dispatch;
	}
	// 82C40150: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40154: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C40158: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4015C: 4E800421  bctrl
	ctx.lr = 0x82C40160;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C40160: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82C40164: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
            }
            0x82C40168 => {
    //   block [0x82C40168..0x82C4017C)
	// 82C40168: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4016C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40170: 394BA37C  addi r10, r11, -0x5c84
	ctx.r[10].s64 = ctx.r[11].s64 + -23684;
	// 82C40174: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C40178: 4BC05639  bl 0x828457b0
	ctx.lr = 0x82C4017C;
	sub_828457B0(ctx, base);
	pc = 0x82C4017C; continue 'dispatch;
            }
            0x82C4017C => {
    //   block [0x82C4017C..0x82C40190)
	// 82C4017C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C40180: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C40184: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C40188: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4018C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C40190 size=24
    let mut pc: u32 = 0x82C40190;
    'dispatch: loop {
        match pc {
            0x82C40190 => {
    //   block [0x82C40190..0x82C401A8)
	// 82C40190: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40194: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C40198: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4019C: 4C820020  bnelr
	if !ctx.cr[0].eq { return; }
	// 82C401A0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C401A4: 4BFFFF84  b 0x82c40128
	sub_82C40128(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C401B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C401B0 size=92
    let mut pc: u32 = 0x82C401B0;
    'dispatch: loop {
        match pc {
            0x82C401B0 => {
    //   block [0x82C401B0..0x82C401D0)
	// 82C401B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C401B4: 48069255  bl 0x82ca9408
	ctx.lr = 0x82C401B8;
	sub_82CA93D0(ctx, base);
	// 82C401B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C401BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C401C0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C401C4: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C401C8: 419A003C  beq cr6, 0x82c40204
	if ctx.cr[6].eq {
	pc = 0x82C40204; continue 'dispatch;
	}
	// 82C401CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C401D0; continue 'dispatch;
            }
            0x82C401D0 => {
    //   block [0x82C401D0..0x82C401F0)
	// 82C401D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C401D4: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82C401D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C401DC: 419A0014  beq cr6, 0x82c401f0
	if ctx.cr[6].eq {
	pc = 0x82C401F0; continue 'dispatch;
	}
	// 82C401E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C401E4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C401E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C401EC: 4E800421  bctrl
	ctx.lr = 0x82C401F0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C401F0 => {
    //   block [0x82C401F0..0x82C40204)
	// 82C401F0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C401F4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C401F8: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C401FC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C40200: 409AFFD0  bne cr6, 0x82c401d0
	if !ctx.cr[6].eq {
	pc = 0x82C401D0; continue 'dispatch;
	}
	pc = 0x82C40204; continue 'dispatch;
            }
            0x82C40204 => {
    //   block [0x82C40204..0x82C4020C)
	// 82C40204: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C40208: 48069250  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40210 size=132
    let mut pc: u32 = 0x82C40210;
    'dispatch: loop {
        match pc {
            0x82C40210 => {
    //   block [0x82C40210..0x82C40284)
	// 82C40210: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40214: 480691F9  bl 0x82ca940c
	ctx.lr = 0x82C40218;
	sub_82CA93D0(ctx, base);
	// 82C40218: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4021C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C40220: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C40224: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C40228: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C4022C: 392BC2C4  addi r9, r11, -0x3d3c
	ctx.r[9].s64 = ctx.r[11].s64 + -15676;
	// 82C40230: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C40234: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C40238: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4023C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C40240: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C40244: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C40248: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C4024C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C40250: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C40254: 4BFF4085  bl 0x82c342d8
	ctx.lr = 0x82C40258;
	sub_82C342D8(ctx, base);
	// 82C40258: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C4025C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C40260: 38C7C380  addi r6, r7, -0x3c80
	ctx.r[6].s64 = ctx.r[7].s64 + -15488;
	// 82C40264: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C40268: 480026B1  bl 0x82c42918
	ctx.lr = 0x82C4026C;
	sub_82C42918(ctx, base);
	// 82C4026C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40274: 419A0010  beq cr6, 0x82c40284
	if ctx.cr[6].eq {
	pc = 0x82C40284; continue 'dispatch;
	}
	// 82C40278: 4BC05539  bl 0x828457b0
	ctx.lr = 0x82C4027C;
	sub_828457B0(ctx, base);
	// 82C4027C: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C40280: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C40284; continue 'dispatch;
            }
            0x82C40284 => {
    //   block [0x82C40284..0x82C40294)
	// 82C40284: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C40288: 4BFC5E79  bl 0x82c06100
	ctx.lr = 0x82C4028C;
	sub_82C06100(ctx, base);
	// 82C4028C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C40290: 480691CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40298 size=80
    let mut pc: u32 = 0x82C40298;
    'dispatch: loop {
        match pc {
            0x82C40298 => {
    //   block [0x82C40298..0x82C402D0)
	// 82C40298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4029C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C402A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C402A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C402A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C402AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C402B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C402B4: 4BFFFF5D  bl 0x82c40210
	ctx.lr = 0x82C402B8;
	sub_82C40210(ctx, base);
	// 82C402B8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C402BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C402C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C402C4: 419A000C  beq cr6, 0x82c402d0
	if ctx.cr[6].eq {
	pc = 0x82C402D0; continue 'dispatch;
	}
	// 82C402C8: 4BC054E9  bl 0x828457b0
	ctx.lr = 0x82C402CC;
	sub_828457B0(ctx, base);
	// 82C402CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C402D0; continue 'dispatch;
            }
            0x82C402D0 => {
    //   block [0x82C402D0..0x82C402E8)
	// 82C402D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C402D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C402D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C402DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C402E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C402E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C402E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C402E8 size=172
    let mut pc: u32 = 0x82C402E8;
    'dispatch: loop {
        match pc {
            0x82C402E8 => {
    //   block [0x82C402E8..0x82C40394)
	// 82C402E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C402EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C402F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C402F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C402F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C402FC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C40300: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C40304: 392BC2D0  addi r9, r11, -0x3d30
	ctx.r[9].s64 = ctx.r[11].s64 + -15664;
	// 82C40308: 390AB7CC  addi r8, r10, -0x4834
	ctx.r[8].s64 = ctx.r[10].s64 + -18484;
	// 82C4030C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C40310: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C40314: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 82C40318: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C4031C: 4800D78D  bl 0x82c4daa8
	ctx.lr = 0x82C40320;
	sub_82C4DAA8(ctx, base);
	// 82C40320: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C40324: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C40328: 38C7B7CC  addi r6, r7, -0x4834
	ctx.r[6].s64 = ctx.r[7].s64 + -18484;
	// 82C4032C: 3CA08333  lis r5, -0x7ccd
	ctx.r[5].s64 = -2093809664;
	// 82C40330: 90DF0004  stw r6, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 82C40334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40338: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82C4033C: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C40340: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C40344: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82C40348: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82C4034C: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82C40350: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82C40354: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82C40358: 917F003C  stw r11, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 82C4035C: 917F0040  stw r11, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82C40360: 917F0044  stw r11, 0x44(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82C40364: 917F0048  stw r11, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 82C40368: 917F004C  stw r11, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82C4036C: 997F0050  stb r11, 0x50(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 82C40370: 997F0051  stb r11, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82C40374: 81654F90  lwz r11, 0x4f90(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(20368 as u32) ) } as u64;
	// 82C40378: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C4037C: 91654F90  stw r11, 0x4f90(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(20368 as u32), ctx.r[11].u32 ) };
	// 82C40380: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C40384: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C40388: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4038C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C40390: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C40398 size=24
    let mut pc: u32 = 0x82C40398;
    'dispatch: loop {
        match pc {
            0x82C40398 => {
    //   block [0x82C40398..0x82C403B0)
	// 82C40398: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4039C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C403A0: 38800BB8  li r4, 0xbb8
	ctx.r[4].s64 = 3000;
	// 82C403A4: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C403A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C403AC: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C403B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C403B0 size=136
    let mut pc: u32 = 0x82C403B0;
    'dispatch: loop {
        match pc {
            0x82C403B0 => {
    //   block [0x82C403B0..0x82C403D0)
	// 82C403B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C403B4: 48069059  bl 0x82ca940c
	ctx.lr = 0x82C403B8;
	sub_82CA93D0(ctx, base);
	// 82C403B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C403BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C403C0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C403C4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C403C8: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C403CC: 419A0064  beq cr6, 0x82c40430
	if ctx.cr[6].eq {
	pc = 0x82C40430; continue 'dispatch;
	}
	pc = 0x82C403D0; continue 'dispatch;
            }
            0x82C403D0 => {
    //   block [0x82C403D0..0x82C403F8)
	// 82C403D0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C403D4: 419A0050  beq cr6, 0x82c40424
	if ctx.cr[6].eq {
	pc = 0x82C40424; continue 'dispatch;
	}
	// 82C403D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C403DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C403E0: 419A0018  beq cr6, 0x82c403f8
	if ctx.cr[6].eq {
	pc = 0x82C403F8; continue 'dispatch;
	}
	// 82C403E4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C403E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C403EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C403F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C403F4: 4E800421  bctrl
	ctx.lr = 0x82C403F8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C403F8 => {
    //   block [0x82C403F8..0x82C40414)
	// 82C403F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C403FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40400: 419A0014  beq cr6, 0x82c40414
	if ctx.cr[6].eq {
	pc = 0x82C40414; continue 'dispatch;
	}
	// 82C40404: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40408: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4040C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40410: 4E800421  bctrl
	ctx.lr = 0x82C40414;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40414 => {
    //   block [0x82C40414..0x82C40424)
	// 82C40414: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40418: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4041C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40420: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C40424; continue 'dispatch;
            }
            0x82C40424 => {
    //   block [0x82C40424..0x82C40430)
	// 82C40424: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40428: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4042C: 409AFFA4  bne cr6, 0x82c403d0
	if !ctx.cr[6].eq {
	pc = 0x82C403D0; continue 'dispatch;
	}
	pc = 0x82C40430; continue 'dispatch;
            }
            0x82C40430 => {
    //   block [0x82C40430..0x82C40438)
	// 82C40430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40434: 48069028  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40438 size=144
    let mut pc: u32 = 0x82C40438;
    'dispatch: loop {
        match pc {
            0x82C40438 => {
    //   block [0x82C40438..0x82C40458)
	// 82C40438: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4043C: 48068FD1  bl 0x82ca940c
	ctx.lr = 0x82C40440;
	sub_82CA93D0(ctx, base);
	// 82C40440: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40444: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40448: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4044C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C40450: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C40454: 419A0068  beq cr6, 0x82c404bc
	if ctx.cr[6].eq {
	pc = 0x82C404BC; continue 'dispatch;
	}
	pc = 0x82C40458; continue 'dispatch;
            }
            0x82C40458 => {
    //   block [0x82C40458..0x82C40480)
	// 82C40458: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4045C: 419A0050  beq cr6, 0x82c404ac
	if ctx.cr[6].eq {
	pc = 0x82C404AC; continue 'dispatch;
	}
	// 82C40460: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40468: 419A0018  beq cr6, 0x82c40480
	if ctx.cr[6].eq {
	pc = 0x82C40480; continue 'dispatch;
	}
	// 82C4046C: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C40470: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40474: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40478: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4047C: 4E800421  bctrl
	ctx.lr = 0x82C40480;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40480 => {
    //   block [0x82C40480..0x82C4049C)
	// 82C40480: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40484: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40488: 419A0014  beq cr6, 0x82c4049c
	if ctx.cr[6].eq {
	pc = 0x82C4049C; continue 'dispatch;
	}
	// 82C4048C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40490: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40494: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40498: 4E800421  bctrl
	ctx.lr = 0x82C4049C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4049C => {
    //   block [0x82C4049C..0x82C404AC)
	// 82C4049C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C404A0: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C404A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C404A8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C404AC; continue 'dispatch;
            }
            0x82C404AC => {
    //   block [0x82C404AC..0x82C404BC)
	// 82C404AC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C404B0: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82C404B4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C404B8: 409AFFA0  bne cr6, 0x82c40458
	if !ctx.cr[6].eq {
	pc = 0x82C40458; continue 'dispatch;
	}
	pc = 0x82C404BC; continue 'dispatch;
            }
            0x82C404BC => {
    //   block [0x82C404BC..0x82C404C8)
	// 82C404BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C404C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C404C4: 48068F98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C404C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C404C8 size=144
    let mut pc: u32 = 0x82C404C8;
    'dispatch: loop {
        match pc {
            0x82C404C8 => {
    //   block [0x82C404C8..0x82C404E8)
	// 82C404C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C404CC: 48068F41  bl 0x82ca940c
	ctx.lr = 0x82C404D0;
	sub_82CA93D0(ctx, base);
	// 82C404D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C404D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C404D8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C404DC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C404E0: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82C404E4: 419A0068  beq cr6, 0x82c4054c
	if ctx.cr[6].eq {
	pc = 0x82C4054C; continue 'dispatch;
	}
	pc = 0x82C404E8; continue 'dispatch;
            }
            0x82C404E8 => {
    //   block [0x82C404E8..0x82C40518)
	// 82C404E8: 3BFFFFF8  addi r31, r31, -8
	ctx.r[31].s64 = ctx.r[31].s64 + -8;
	// 82C404EC: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 82C404F0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C404F4: 419A0050  beq cr6, 0x82c40544
	if ctx.cr[6].eq {
	pc = 0x82C40544; continue 'dispatch;
	}
	// 82C404F8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C404FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40500: 419A0018  beq cr6, 0x82c40518
	if ctx.cr[6].eq {
	pc = 0x82C40518; continue 'dispatch;
	}
	// 82C40504: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C40508: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4050C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40510: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40514: 4E800421  bctrl
	ctx.lr = 0x82C40518;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40518 => {
    //   block [0x82C40518..0x82C40534)
	// 82C40518: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4051C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40520: 419A0014  beq cr6, 0x82c40534
	if ctx.cr[6].eq {
	pc = 0x82C40534; continue 'dispatch;
	}
	// 82C40524: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40528: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4052C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40530: 4E800421  bctrl
	ctx.lr = 0x82C40534;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40534 => {
    //   block [0x82C40534..0x82C40544)
	// 82C40534: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40538: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C4053C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40540: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82C40544; continue 'dispatch;
            }
            0x82C40544 => {
    //   block [0x82C40544..0x82C4054C)
	// 82C40544: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C40548: 409AFFA0  bne cr6, 0x82c404e8
	if !ctx.cr[6].eq {
	pc = 0x82C404E8; continue 'dispatch;
	}
	pc = 0x82C4054C; continue 'dispatch;
            }
            0x82C4054C => {
    //   block [0x82C4054C..0x82C40558)
	// 82C4054C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C40550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40554: 48068F08  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C40558 size=84
    let mut pc: u32 = 0x82C40558;
    'dispatch: loop {
        match pc {
            0x82C40558 => {
    //   block [0x82C40558..0x82C405AC)
	// 82C40558: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4055C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 82C40560: 3921FFF4  addi r9, r1, -0xc
	ctx.r[9].s64 = ctx.r[1].s64 + -12;
	// 82C40564: 3901FFF4  addi r8, r1, -0xc
	ctx.r[8].s64 = ctx.r[1].s64 + -12;
	// 82C40568: 38E1FFF0  addi r7, r1, -0x10
	ctx.r[7].s64 = ctx.r[1].s64 + -16;
	// 82C4056C: C00B0C18  lfs f0, 0xc18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C40570: 38C00006  li r6, 6
	ctx.r[6].s64 = 6;
	// 82C40574: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C40578: 13E05407  vcmpneb. (lvlx128) v31, v0, v10
	tmp.u32 = ctx.r[10].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C4057C: 90C40000  stw r6, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82C40580: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C40584: 13C04C07  vcmpneb. (lvlx128) v30, v0, v9
	tmp.u32 = ctx.r[9].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C40588: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C4058C: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C405B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C405B0 size=124
    let mut pc: u32 = 0x82C405B0;
    'dispatch: loop {
        match pc {
            0x82C405B0 => {
    //   block [0x82C405B0..0x82C4062C)
	// 82C405B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C405B4: 48068E59  bl 0x82ca940c
	ctx.lr = 0x82C405B8;
	sub_82CA93D0(ctx, base);
	// 82C405B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C405BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C405C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C405C4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C405C8: 4BFCE659  bl 0x82c0ec20
	ctx.lr = 0x82C405CC;
	sub_82C0EC20(ctx, base);
	// 82C405CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C405D0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C405D4: 392BC310  addi r9, r11, -0x3cf0
	ctx.r[9].s64 = ctx.r[11].s64 + -15600;
	// 82C405D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C405DC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C405E0: 390AC304  addi r8, r10, -0x3cfc
	ctx.r[8].s64 = ctx.r[10].s64 + -15612;
	// 82C405E4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C405E8: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C405EC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C405F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C405F4: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C405F8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82C405FC: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 82C40600: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C40604: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82C40608: 93FF0018  stw r31, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 82C4060C: 4BFD16BD  bl 0x82c11cc8
	ctx.lr = 0x82C40610;
	sub_82C11CC8(ctx, base);
	// 82C40610: 3CE08333  lis r7, -0x7ccd
	ctx.r[7].s64 = -2093809664;
	// 82C40614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40618: 81674F88  lwz r11, 0x4f88(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20360 as u32) ) } as u64;
	// 82C4061C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C40620: 91674F88  stw r11, 0x4f88(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(20360 as u32), ctx.r[11].u32 ) };
	// 82C40624: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40628: 48068E34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40630 size=260
    let mut pc: u32 = 0x82C40630;
    'dispatch: loop {
        match pc {
            0x82C40630 => {
    //   block [0x82C40630..0x82C40678)
	// 82C40630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40634: 48068DCD  bl 0x82ca9400
	ctx.lr = 0x82C40638;
	sub_82CA93D0(ctx, base);
	// 82C40638: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4063C: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 82C40640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40644: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C40648: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C4064C: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82C40650: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C40654: 3FC08333  lis r30, -0x7ccd
	ctx.r[30].s64 = -2093809664;
	// 82C40658: 93A80000  stw r29, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C4065C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C40660: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82C40664: 419A006C  beq cr6, 0x82c406d0
	if ctx.cr[6].eq {
	pc = 0x82C406D0; continue 'dispatch;
	}
	// 82C40668: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82C4066C: 419A000C  beq cr6, 0x82c40678
	if ctx.cr[6].eq {
	pc = 0x82C40678; continue 'dispatch;
	}
	// 82C40670: 7D6500D0  neg r11, r5
	ctx.r[11].s64 = -ctx.r[5].s64;
	// 82C40674: 91680000  stw r11, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82C40678; continue 'dispatch;
            }
            0x82C40678 => {
    //   block [0x82C40678..0x82C406D0)
	// 82C40678: 817E4F8C  lwz r11, 0x4f8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20364 as u32) ) } as u64;
	// 82C4067C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C40680: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82C40684: 917E4F8C  stw r11, 0x4f8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20364 as u32), ctx.r[11].u32 ) };
	// 82C40688: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 82C4068C: 814A4F88  lwz r10, 0x4f88(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20360 as u32) ) } as u64;
	// 82C40690: 817E4F8C  lwz r11, 0x4f8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20364 as u32) ) } as u64;
	// 82C40694: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82C40698: 409A003C  bne cr6, 0x82c406d4
	if !ctx.cr[6].eq {
	pc = 0x82C406D4; continue 'dispatch;
	}
	// 82C4069C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C406A0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C406A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82C406A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82C406AC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C406B0: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C406B4: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C406B8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C406BC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C406C0: 4E800421  bctrl
	ctx.lr = 0x82C406C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C406C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C406C8: 917E4F8C  stw r11, 0x4f8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20364 as u32), ctx.r[11].u32 ) };
	// 82C406CC: 48000008  b 0x82c406d4
	pc = 0x82C406D4; continue 'dispatch;
            }
            0x82C406D0 => {
    //   block [0x82C406D0..0x82C406D4)
	// 82C406D0: 817E4F8C  lwz r11, 0x4f8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20364 as u32) ) } as u64;
	pc = 0x82C406D4; continue 'dispatch;
            }
            0x82C406D4 => {
    //   block [0x82C406D4..0x82C406F4)
	// 82C406D4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C406D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C406DC: 409A0018  bne cr6, 0x82c406f4
	if !ctx.cr[6].eq {
	pc = 0x82C406F4; continue 'dispatch;
	}
	// 82C406E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C406E4: 419A0010  beq cr6, 0x82c406f4
	if ctx.cr[6].eq {
	pc = 0x82C406F4; continue 'dispatch;
	}
	// 82C406E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C406EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C406F0: 48068D60  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C406F4 => {
    //   block [0x82C406F4..0x82C40734)
	// 82C406F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C406F8: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 82C406FC: 809F000C  lwz r4, 0xc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40700: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C40704: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C40708: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4070C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40710: 812A002C  lwz r9, 0x2c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C40714: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C40718: 4E800421  bctrl
	ctx.lr = 0x82C4071C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4071C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C40720: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40724: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C40728: 911F0010  stw r8, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	// 82C4072C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C40730: 48068D20  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40738 size=140
    let mut pc: u32 = 0x82C40738;
    'dispatch: loop {
        match pc {
            0x82C40738 => {
    //   block [0x82C40738..0x82C407C4)
	// 82C40738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4073C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C40740: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C40744: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C40748: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4074C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C40750: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C40754: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C40758: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C4075C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40760: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40764: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40768: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4076C: 812A0034  lwz r9, 0x34(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C40770: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C40774: 4E800421  bctrl
	ctx.lr = 0x82C40778;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C40778: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4077C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C40780: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82C40784: 809E000C  lwz r4, 0xc(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40788: 8068000C  lwz r3, 0xc(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4078C: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40790: 80C70030  lwz r6, 0x30(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C40794: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C40798: 4E800421  bctrl
	ctx.lr = 0x82C4079C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4079C: 80A10050  lwz r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C407A0: 80810054  lwz r4, 0x54(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C407A4: 7C6429D6  mullw r3, r4, r5
	ctx.r[3].s32 = ((ctx.r[4].s32 as i64 * ctx.r[5].s32 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C407A8: 5463083C  slwi r3, r3, 1
	ctx.r[3].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C407AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C407B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C407B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C407B8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C407BC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C407C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C407C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C407C8 size=132
    let mut pc: u32 = 0x82C407C8;
    'dispatch: loop {
        match pc {
            0x82C407C8 => {
    //   block [0x82C407C8..0x82C40808)
	// 82C407C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C407CC: 48068C41  bl 0x82ca940c
	ctx.lr = 0x82C407D0;
	sub_82CA93D0(ctx, base);
	// 82C407D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C407D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C407D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C407DC: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C407E0: 392BC310  addi r9, r11, -0x3cf0
	ctx.r[9].s64 = ctx.r[11].s64 + -15600;
	// 82C407E4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C407E8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C407EC: 816A4F88  lwz r11, 0x4f88(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20360 as u32) ) } as u64;
	// 82C407F0: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C407F4: 916A4F88  stw r11, 0x4f88(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20360 as u32), ctx.r[11].u32 ) };
	// 82C407F8: 40820010  bne 0x82c40808
	if !ctx.cr[0].eq {
	pc = 0x82C40808; continue 'dispatch;
	}
	// 82C407FC: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C40800: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C40804: 916A4F8C  stw r11, 0x4f8c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20364 as u32), ctx.r[11].u32 ) };
	pc = 0x82C40808; continue 'dispatch;
            }
            0x82C40808 => {
    //   block [0x82C40808..0x82C40834)
	// 82C40808: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4080C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82C40810: 394BA37C  addi r10, r11, -0x5c84
	ctx.r[10].s64 = ctx.r[11].s64 + -23684;
	// 82C40814: 915F0014  stw r10, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 82C40818: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4081C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40820: 419A0014  beq cr6, 0x82c40834
	if ctx.cr[6].eq {
	pc = 0x82C40834; continue 'dispatch;
	}
	// 82C40824: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40828: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4082C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40830: 4E800421  bctrl
	ctx.lr = 0x82C40834;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40834 => {
    //   block [0x82C40834..0x82C4084C)
	// 82C40834: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C40838: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4083C: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C40840: 4BFCE3E1  bl 0x82c0ec20
	ctx.lr = 0x82C40844;
	sub_82C0EC20(ctx, base);
	// 82C40844: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40848: 48068C14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40850 size=80
    let mut pc: u32 = 0x82C40850;
    'dispatch: loop {
        match pc {
            0x82C40850 => {
    //   block [0x82C40850..0x82C40888)
	// 82C40850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40854: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C40858: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4085C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C40860: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40864: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40868: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4086C: 4BFFFF5D  bl 0x82c407c8
	ctx.lr = 0x82C40870;
	sub_82C407C8(ctx, base);
	// 82C40870: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C40874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40878: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4087C: 419A000C  beq cr6, 0x82c40888
	if ctx.cr[6].eq {
	pc = 0x82C40888; continue 'dispatch;
	}
	// 82C40880: 4BC04F31  bl 0x828457b0
	ctx.lr = 0x82C40884;
	sub_828457B0(ctx, base);
	// 82C40884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C40888; continue 'dispatch;
            }
            0x82C40888 => {
    //   block [0x82C40888..0x82C408A0)
	// 82C40888: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4088C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C40890: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C40894: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C40898: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4089C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C408A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C408A0 size=84
    let mut pc: u32 = 0x82C408A0;
    'dispatch: loop {
        match pc {
            0x82C408A0 => {
    //   block [0x82C408A0..0x82C408F4)
	// 82C408A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C408A4: 48068B69  bl 0x82ca940c
	ctx.lr = 0x82C408A8;
	sub_82CA93D0(ctx, base);
	// 82C408A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C408AC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C408B0: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C408B4: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C408B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C408BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C408C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C408C4: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C408C8: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C408CC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C408D0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C408D4: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C408D8: 4BFFFBF1  bl 0x82c404c8
	ctx.lr = 0x82C408DC;
	sub_82C404C8(ctx, base);
	// 82C408DC: 7D1FF050  subf r8, r31, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82C408E0: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82C408E4: 54E61838  slwi r6, r7, 3
	ctx.r[6].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82C408E8: 7C66E850  subf r3, r6, r29
	ctx.r[3].s64 = ctx.r[29].s64 - ctx.r[6].s64;
	// 82C408EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C408F0: 48068B6C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C408F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C408F8 size=108
    let mut pc: u32 = 0x82C408F8;
    'dispatch: loop {
        match pc {
            0x82C408F8 => {
    //   block [0x82C408F8..0x82C40918)
	// 82C408F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C408FC: 48068B11  bl 0x82ca940c
	ctx.lr = 0x82C40900;
	sub_82CA93D0(ctx, base);
	// 82C40900: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40904: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40908: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4090C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C40910: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C40914: 419A0044  beq cr6, 0x82c40958
	if ctx.cr[6].eq {
	pc = 0x82C40958; continue 'dispatch;
	}
	pc = 0x82C40918; continue 'dispatch;
            }
            0x82C40918 => {
    //   block [0x82C40918..0x82C40948)
	// 82C40918: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4091C: 419A002C  beq cr6, 0x82c40948
	if ctx.cr[6].eq {
	pc = 0x82C40948; continue 'dispatch;
	}
	// 82C40920: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40924: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C40928: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4092C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40930: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C40934: 419A0014  beq cr6, 0x82c40948
	if ctx.cr[6].eq {
	pc = 0x82C40948; continue 'dispatch;
	}
	// 82C40938: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4093C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40940: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40944: 4E800421  bctrl
	ctx.lr = 0x82C40948;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40948 => {
    //   block [0x82C40948..0x82C40958)
	// 82C40948: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C4094C: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 82C40950: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C40954: 409AFFC4  bne cr6, 0x82c40918
	if !ctx.cr[6].eq {
	pc = 0x82C40918; continue 'dispatch;
	}
	pc = 0x82C40958; continue 'dispatch;
            }
            0x82C40958 => {
    //   block [0x82C40958..0x82C40964)
	// 82C40958: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4095C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40960: 48068AFC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40968 size=208
    let mut pc: u32 = 0x82C40968;
    'dispatch: loop {
        match pc {
            0x82C40968 => {
    //   block [0x82C40968..0x82C40988)
	// 82C40968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4096C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C40970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C40974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C40978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4097C: 89630051  lbz r11, 0x51(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40980: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40984: 409A000C  bne cr6, 0x82c40990
	if !ctx.cr[6].eq {
	pc = 0x82C40990; continue 'dispatch;
	}
	pc = 0x82C40988; continue 'dispatch;
            }
            0x82C40988 => {
    //   block [0x82C40988..0x82C40990)
	// 82C40988: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4098C: 48000094  b 0x82c40a20
	pc = 0x82C40A20; continue 'dispatch;
            }
            0x82C40990 => {
    //   block [0x82C40990..0x82C409A8)
	// 82C40990: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40994: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82C40998: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4099C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C409A0: 40990008  ble cr6, 0x82c409a8
	if !ctx.cr[6].gt {
	pc = 0x82C409A8; continue 'dispatch;
	}
	// 82C409A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C409A8; continue 'dispatch;
            }
            0x82C409A8 => {
    //   block [0x82C409A8..0x82C409BC)
	// 82C409A8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C409AC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C409B0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C409B4: 40990008  ble cr6, 0x82c409bc
	if !ctx.cr[6].gt {
	pc = 0x82C409BC; continue 'dispatch;
	}
	// 82C409B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C409BC; continue 'dispatch;
            }
            0x82C409BC => {
    //   block [0x82C409BC..0x82C409C8)
	// 82C409BC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C409C0: 419A0008  beq cr6, 0x82c409c8
	if ctx.cr[6].eq {
	pc = 0x82C409C8; continue 'dispatch;
	}
	// 82C409C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C409C8; continue 'dispatch;
            }
            0x82C409C8 => {
    //   block [0x82C409C8..0x82C409DC)
	// 82C409C8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C409CC: 419A0050  beq cr6, 0x82c40a1c
	if ctx.cr[6].eq {
	pc = 0x82C40A1C; continue 'dispatch;
	}
	// 82C409D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C409D4: 41980008  blt cr6, 0x82c409dc
	if ctx.cr[6].lt {
	pc = 0x82C409DC; continue 'dispatch;
	}
	// 82C409D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C409DC; continue 'dispatch;
            }
            0x82C409DC => {
    //   block [0x82C409DC..0x82C40A04)
	// 82C409DC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C409E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C409E4: 419A0020  beq cr6, 0x82c40a04
	if ctx.cr[6].eq {
	pc = 0x82C40A04; continue 'dispatch;
	}
	// 82C409E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C409EC: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C409F0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C409F4: 4E800421  bctrl
	ctx.lr = 0x82C409F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C409F8: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C409FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C40A00: 419AFF88  beq cr6, 0x82c40988
	if ctx.cr[6].eq {
	pc = 0x82C40988; continue 'dispatch;
	}
            }
            0x82C40A04 => {
    //   block [0x82C40A04..0x82C40A14)
	// 82C40A04: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40A08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40A0C: 41980008  blt cr6, 0x82c40a14
	if ctx.cr[6].lt {
	pc = 0x82C40A14; continue 'dispatch;
	}
	// 82C40A10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40A14; continue 'dispatch;
            }
            0x82C40A14 => {
    //   block [0x82C40A14..0x82C40A1C)
	// 82C40A14: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40A18: 4BFFFF90  b 0x82c409a8
	pc = 0x82C409A8; continue 'dispatch;
            }
            0x82C40A1C => {
    //   block [0x82C40A1C..0x82C40A20)
	// 82C40A1C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C40A20; continue 'dispatch;
            }
            0x82C40A20 => {
    //   block [0x82C40A20..0x82C40A38)
	// 82C40A20: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40A24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C40A28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C40A2C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C40A30: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C40A34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40A38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40A38 size=176
    let mut pc: u32 = 0x82C40A38;
    'dispatch: loop {
        match pc {
            0x82C40A38 => {
    //   block [0x82C40A38..0x82C40A6C)
	// 82C40A38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40A3C: 480689D1  bl 0x82ca940c
	ctx.lr = 0x82C40A40;
	sub_82CA93D0(ctx, base);
	// 82C40A40: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40A44: 89630051  lbz r11, 0x51(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40A48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C40A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40A50: 409A0090  bne cr6, 0x82c40ae0
	if !ctx.cr[6].eq {
	pc = 0x82C40AE0; continue 'dispatch;
	}
	// 82C40A54: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40A58: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82C40A5C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C40A60: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40A64: 40990008  ble cr6, 0x82c40a6c
	if !ctx.cr[6].gt {
	pc = 0x82C40A6C; continue 'dispatch;
	}
	// 82C40A68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40A6C; continue 'dispatch;
            }
            0x82C40A6C => {
    //   block [0x82C40A6C..0x82C40A80)
	// 82C40A6C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40A70: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40A74: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40A78: 40990008  ble cr6, 0x82c40a80
	if !ctx.cr[6].gt {
	pc = 0x82C40A80; continue 'dispatch;
	}
	// 82C40A7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40A80; continue 'dispatch;
            }
            0x82C40A80 => {
    //   block [0x82C40A80..0x82C40A8C)
	// 82C40A80: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C40A84: 419A0008  beq cr6, 0x82c40a8c
	if ctx.cr[6].eq {
	pc = 0x82C40A8C; continue 'dispatch;
	}
	// 82C40A88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40A8C; continue 'dispatch;
            }
            0x82C40A8C => {
    //   block [0x82C40A8C..0x82C40AA0)
	// 82C40A8C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40A90: 419A004C  beq cr6, 0x82c40adc
	if ctx.cr[6].eq {
	pc = 0x82C40ADC; continue 'dispatch;
	}
	// 82C40A94: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40A98: 41980008  blt cr6, 0x82c40aa0
	if ctx.cr[6].lt {
	pc = 0x82C40AA0; continue 'dispatch;
	}
	// 82C40A9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40AA0; continue 'dispatch;
            }
            0x82C40AA0 => {
    //   block [0x82C40AA0..0x82C40AC4)
	// 82C40AA0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40AA8: 419A001C  beq cr6, 0x82c40ac4
	if ctx.cr[6].eq {
	pc = 0x82C40AC4; continue 'dispatch;
	}
	// 82C40AAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40AB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C40AB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C40AB8: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C40ABC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40AC0: 4E800421  bctrl
	ctx.lr = 0x82C40AC4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40AC4 => {
    //   block [0x82C40AC4..0x82C40AD4)
	// 82C40AC4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40AC8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40ACC: 41980008  blt cr6, 0x82c40ad4
	if ctx.cr[6].lt {
	pc = 0x82C40AD4; continue 'dispatch;
	}
	// 82C40AD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40AD4; continue 'dispatch;
            }
            0x82C40AD4 => {
    //   block [0x82C40AD4..0x82C40ADC)
	// 82C40AD4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40AD8: 4BFFFF94  b 0x82c40a6c
	pc = 0x82C40A6C; continue 'dispatch;
            }
            0x82C40ADC => {
    //   block [0x82C40ADC..0x82C40AE0)
	// 82C40ADC: 4BFCE25D  bl 0x82c0ed38
	ctx.lr = 0x82C40AE0;
	sub_82C0ED38(ctx, base);
	pc = 0x82C40AE0; continue 'dispatch;
            }
            0x82C40AE0 => {
    //   block [0x82C40AE0..0x82C40AE8)
	// 82C40AE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40AE4: 48068978  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40AE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40AE8 size=172
    let mut pc: u32 = 0x82C40AE8;
    'dispatch: loop {
        match pc {
            0x82C40AE8 => {
    //   block [0x82C40AE8..0x82C40B1C)
	// 82C40AE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40AEC: 48068921  bl 0x82ca940c
	ctx.lr = 0x82C40AF0;
	sub_82CA93D0(ctx, base);
	// 82C40AF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40AF4: 89630051  lbz r11, 0x51(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40AF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C40AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40B00: 409A008C  bne cr6, 0x82c40b8c
	if !ctx.cr[6].eq {
	pc = 0x82C40B8C; continue 'dispatch;
	}
	// 82C40B04: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40B08: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82C40B0C: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C40B10: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40B14: 40990008  ble cr6, 0x82c40b1c
	if !ctx.cr[6].gt {
	pc = 0x82C40B1C; continue 'dispatch;
	}
	// 82C40B18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40B1C; continue 'dispatch;
            }
            0x82C40B1C => {
    //   block [0x82C40B1C..0x82C40B30)
	// 82C40B1C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40B20: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40B24: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40B28: 40990008  ble cr6, 0x82c40b30
	if !ctx.cr[6].gt {
	pc = 0x82C40B30; continue 'dispatch;
	}
	// 82C40B2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40B30; continue 'dispatch;
            }
            0x82C40B30 => {
    //   block [0x82C40B30..0x82C40B3C)
	// 82C40B30: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C40B34: 419A0008  beq cr6, 0x82c40b3c
	if ctx.cr[6].eq {
	pc = 0x82C40B3C; continue 'dispatch;
	}
	// 82C40B38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40B3C; continue 'dispatch;
            }
            0x82C40B3C => {
    //   block [0x82C40B3C..0x82C40B50)
	// 82C40B3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40B40: 419A004C  beq cr6, 0x82c40b8c
	if ctx.cr[6].eq {
	pc = 0x82C40B8C; continue 'dispatch;
	}
	// 82C40B44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40B48: 41980008  blt cr6, 0x82c40b50
	if ctx.cr[6].lt {
	pc = 0x82C40B50; continue 'dispatch;
	}
	// 82C40B4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40B50; continue 'dispatch;
            }
            0x82C40B50 => {
    //   block [0x82C40B50..0x82C40B74)
	// 82C40B50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40B54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40B58: 419A001C  beq cr6, 0x82c40b74
	if ctx.cr[6].eq {
	pc = 0x82C40B74; continue 'dispatch;
	}
	// 82C40B5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40B60: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C40B64: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82C40B68: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C40B6C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40B70: 4E800421  bctrl
	ctx.lr = 0x82C40B74;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40B74 => {
    //   block [0x82C40B74..0x82C40B84)
	// 82C40B74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40B78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40B7C: 41980008  blt cr6, 0x82c40b84
	if ctx.cr[6].lt {
	pc = 0x82C40B84; continue 'dispatch;
	}
	// 82C40B80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40B84; continue 'dispatch;
            }
            0x82C40B84 => {
    //   block [0x82C40B84..0x82C40B8C)
	// 82C40B84: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40B88: 4BFFFF94  b 0x82c40b1c
	pc = 0x82C40B1C; continue 'dispatch;
            }
            0x82C40B8C => {
    //   block [0x82C40B8C..0x82C40B94)
	// 82C40B8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40B90: 480688CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40B98 size=164
    let mut pc: u32 = 0x82C40B98;
    'dispatch: loop {
        match pc {
            0x82C40B98 => {
    //   block [0x82C40B98..0x82C40BC8)
	// 82C40B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40B9C: 48068871  bl 0x82ca940c
	ctx.lr = 0x82C40BA0;
	sub_82CA93D0(ctx, base);
	// 82C40BA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40BA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C40BA8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C40BAC: 99630051  stb r11, 0x51(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82C40BB0: 3BC30010  addi r30, r3, 0x10
	ctx.r[30].s64 = ctx.r[3].s64 + 16;
	// 82C40BB4: 83E30014  lwz r31, 0x14(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40BB8: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C40BBC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40BC0: 40990008  ble cr6, 0x82c40bc8
	if !ctx.cr[6].gt {
	pc = 0x82C40BC8; continue 'dispatch;
	}
	// 82C40BC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40BC8; continue 'dispatch;
            }
            0x82C40BC8 => {
    //   block [0x82C40BC8..0x82C40BDC)
	// 82C40BC8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40BCC: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40BD0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40BD4: 40990008  ble cr6, 0x82c40bdc
	if !ctx.cr[6].gt {
	pc = 0x82C40BDC; continue 'dispatch;
	}
	// 82C40BD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40BDC; continue 'dispatch;
            }
            0x82C40BDC => {
    //   block [0x82C40BDC..0x82C40BE8)
	// 82C40BDC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C40BE0: 419A0008  beq cr6, 0x82c40be8
	if ctx.cr[6].eq {
	pc = 0x82C40BE8; continue 'dispatch;
	}
	// 82C40BE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40BE8; continue 'dispatch;
            }
            0x82C40BE8 => {
    //   block [0x82C40BE8..0x82C40BFC)
	// 82C40BE8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40BEC: 419A0048  beq cr6, 0x82c40c34
	if ctx.cr[6].eq {
	pc = 0x82C40C34; continue 'dispatch;
	}
	// 82C40BF0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40BF4: 41980008  blt cr6, 0x82c40bfc
	if ctx.cr[6].lt {
	pc = 0x82C40BFC; continue 'dispatch;
	}
	// 82C40BF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40BFC; continue 'dispatch;
            }
            0x82C40BFC => {
    //   block [0x82C40BFC..0x82C40C1C)
	// 82C40BFC: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40C00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40C04: 419A0018  beq cr6, 0x82c40c1c
	if ctx.cr[6].eq {
	pc = 0x82C40C1C; continue 'dispatch;
	}
	// 82C40C08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40C0C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C40C10: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C40C14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40C18: 4E800421  bctrl
	ctx.lr = 0x82C40C1C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40C1C => {
    //   block [0x82C40C1C..0x82C40C2C)
	// 82C40C1C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40C20: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40C24: 41980008  blt cr6, 0x82c40c2c
	if ctx.cr[6].lt {
	pc = 0x82C40C2C; continue 'dispatch;
	}
	// 82C40C28: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40C2C; continue 'dispatch;
            }
            0x82C40C2C => {
    //   block [0x82C40C2C..0x82C40C34)
	// 82C40C2C: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40C30: 4BFFFF98  b 0x82c40bc8
	pc = 0x82C40BC8; continue 'dispatch;
            }
            0x82C40C34 => {
    //   block [0x82C40C34..0x82C40C3C)
	// 82C40C34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40C38: 48068824  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40C40 size=168
    let mut pc: u32 = 0x82C40C40;
    'dispatch: loop {
        match pc {
            0x82C40C40 => {
    //   block [0x82C40C40..0x82C40C74)
	// 82C40C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40C44: 480687C9  bl 0x82ca940c
	ctx.lr = 0x82C40C48;
	sub_82CA93D0(ctx, base);
	// 82C40C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40C50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C40C54: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C40C58: 48015771  bl 0x82c563c8
	ctx.lr = 0x82C40C5C;
	sub_82C563C8(ctx, base);
	// 82C40C5C: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82C40C60: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40C64: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40C68: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40C6C: 40990008  ble cr6, 0x82c40c74
	if !ctx.cr[6].gt {
	pc = 0x82C40C74; continue 'dispatch;
	}
	// 82C40C70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40C74; continue 'dispatch;
            }
            0x82C40C74 => {
    //   block [0x82C40C74..0x82C40C88)
	// 82C40C74: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40C78: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40C7C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40C80: 40990008  ble cr6, 0x82c40c88
	if !ctx.cr[6].gt {
	pc = 0x82C40C88; continue 'dispatch;
	}
	// 82C40C84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40C88; continue 'dispatch;
            }
            0x82C40C88 => {
    //   block [0x82C40C88..0x82C40C94)
	// 82C40C88: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C40C8C: 419A0008  beq cr6, 0x82c40c94
	if ctx.cr[6].eq {
	pc = 0x82C40C94; continue 'dispatch;
	}
	// 82C40C90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40C94; continue 'dispatch;
            }
            0x82C40C94 => {
    //   block [0x82C40C94..0x82C40CA8)
	// 82C40C94: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40C98: 419A0048  beq cr6, 0x82c40ce0
	if ctx.cr[6].eq {
	pc = 0x82C40CE0; continue 'dispatch;
	}
	// 82C40C9C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40CA0: 41980008  blt cr6, 0x82c40ca8
	if ctx.cr[6].lt {
	pc = 0x82C40CA8; continue 'dispatch;
	}
	// 82C40CA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40CA8; continue 'dispatch;
            }
            0x82C40CA8 => {
    //   block [0x82C40CA8..0x82C40CC8)
	// 82C40CA8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40CAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40CB0: 419A0018  beq cr6, 0x82c40cc8
	if ctx.cr[6].eq {
	pc = 0x82C40CC8; continue 'dispatch;
	}
	// 82C40CB4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40CB8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40CBC: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 82C40CC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40CC4: 4E800421  bctrl
	ctx.lr = 0x82C40CC8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40CC8 => {
    //   block [0x82C40CC8..0x82C40CD8)
	// 82C40CC8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40CCC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40CD0: 41980008  blt cr6, 0x82c40cd8
	if ctx.cr[6].lt {
	pc = 0x82C40CD8; continue 'dispatch;
	}
	// 82C40CD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40CD8; continue 'dispatch;
            }
            0x82C40CD8 => {
    //   block [0x82C40CD8..0x82C40CE0)
	// 82C40CD8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40CDC: 4BFFFF98  b 0x82c40c74
	pc = 0x82C40C74; continue 'dispatch;
            }
            0x82C40CE0 => {
    //   block [0x82C40CE0..0x82C40CE8)
	// 82C40CE0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40CE4: 48068778  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40CE8 size=168
    let mut pc: u32 = 0x82C40CE8;
    'dispatch: loop {
        match pc {
            0x82C40CE8 => {
    //   block [0x82C40CE8..0x82C40D1C)
	// 82C40CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40CEC: 48068721  bl 0x82ca940c
	ctx.lr = 0x82C40CF0;
	sub_82CA93D0(ctx, base);
	// 82C40CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40CF4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40CF8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C40CFC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C40D00: 48015A41  bl 0x82c56740
	ctx.lr = 0x82C40D04;
	sub_82C56740(ctx, base);
	// 82C40D04: 3BDF0010  addi r30, r31, 0x10
	ctx.r[30].s64 = ctx.r[31].s64 + 16;
	// 82C40D08: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40D0C: 83FF0014  lwz r31, 0x14(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C40D10: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40D14: 40990008  ble cr6, 0x82c40d1c
	if !ctx.cr[6].gt {
	pc = 0x82C40D1C; continue 'dispatch;
	}
	// 82C40D18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40D1C; continue 'dispatch;
            }
            0x82C40D1C => {
    //   block [0x82C40D1C..0x82C40D30)
	// 82C40D1C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40D20: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40D24: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40D28: 40990008  ble cr6, 0x82c40d30
	if !ctx.cr[6].gt {
	pc = 0x82C40D30; continue 'dispatch;
	}
	// 82C40D2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40D30; continue 'dispatch;
            }
            0x82C40D30 => {
    //   block [0x82C40D30..0x82C40D3C)
	// 82C40D30: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C40D34: 419A0008  beq cr6, 0x82c40d3c
	if ctx.cr[6].eq {
	pc = 0x82C40D3C; continue 'dispatch;
	}
	// 82C40D38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40D3C; continue 'dispatch;
            }
            0x82C40D3C => {
    //   block [0x82C40D3C..0x82C40D50)
	// 82C40D3C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40D40: 419A0048  beq cr6, 0x82c40d88
	if ctx.cr[6].eq {
	pc = 0x82C40D88; continue 'dispatch;
	}
	// 82C40D44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40D48: 41980008  blt cr6, 0x82c40d50
	if ctx.cr[6].lt {
	pc = 0x82C40D50; continue 'dispatch;
	}
	// 82C40D4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40D50; continue 'dispatch;
            }
            0x82C40D50 => {
    //   block [0x82C40D50..0x82C40D70)
	// 82C40D50: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40D54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40D58: 419A0018  beq cr6, 0x82c40d70
	if ctx.cr[6].eq {
	pc = 0x82C40D70; continue 'dispatch;
	}
	// 82C40D5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40D60: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40D64: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C40D68: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40D6C: 4E800421  bctrl
	ctx.lr = 0x82C40D70;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40D70 => {
    //   block [0x82C40D70..0x82C40D80)
	// 82C40D70: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40D74: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40D78: 41980008  blt cr6, 0x82c40d80
	if ctx.cr[6].lt {
	pc = 0x82C40D80; continue 'dispatch;
	}
	// 82C40D7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40D80; continue 'dispatch;
            }
            0x82C40D80 => {
    //   block [0x82C40D80..0x82C40D88)
	// 82C40D80: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40D84: 4BFFFF98  b 0x82c40d1c
	pc = 0x82C40D1C; continue 'dispatch;
            }
            0x82C40D88 => {
    //   block [0x82C40D88..0x82C40D90)
	// 82C40D88: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40D8C: 480686D0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40D90 size=100
    let mut pc: u32 = 0x82C40D90;
    'dispatch: loop {
        match pc {
            0x82C40D90 => {
    //   block [0x82C40D90..0x82C40DB0)
	// 82C40D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40D94: 48068679  bl 0x82ca940c
	ctx.lr = 0x82C40D98;
	sub_82CA93D0(ctx, base);
	// 82C40D98: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40D9C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C40DA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40DA4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C40DA8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C40DAC: 419A0040  beq cr6, 0x82c40dec
	if ctx.cr[6].eq {
	pc = 0x82C40DEC; continue 'dispatch;
	}
	pc = 0x82C40DB0; continue 'dispatch;
            }
            0x82C40DB0 => {
    //   block [0x82C40DB0..0x82C40DE0)
	// 82C40DB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C40DB4: 419A002C  beq cr6, 0x82c40de0
	if ctx.cr[6].eq {
	pc = 0x82C40DE0; continue 'dispatch;
	}
	// 82C40DB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40DBC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C40DC0: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40DC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C40DC8: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 82C40DCC: 419A0014  beq cr6, 0x82c40de0
	if ctx.cr[6].eq {
	pc = 0x82C40DE0; continue 'dispatch;
	}
	// 82C40DD0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40DD4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40DD8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40DDC: 4E800421  bctrl
	ctx.lr = 0x82C40DE0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40DE0 => {
    //   block [0x82C40DE0..0x82C40DEC)
	// 82C40DE0: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C40DE4: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 82C40DE8: 4082FFC8  bne 0x82c40db0
	if !ctx.cr[0].eq {
	pc = 0x82C40DB0; continue 'dispatch;
	}
	pc = 0x82C40DEC; continue 'dispatch;
            }
            0x82C40DEC => {
    //   block [0x82C40DEC..0x82C40DF4)
	// 82C40DEC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40DF0: 4806866C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40DF8 size=100
    let mut pc: u32 = 0x82C40DF8;
    'dispatch: loop {
        match pc {
            0x82C40DF8 => {
    //   block [0x82C40DF8..0x82C40E5C)
	// 82C40DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40DFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C40E00: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C40E04: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C40E08: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40E0C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C40E10: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40E14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C40E18: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C40E1C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C40E20: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C40E24: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C40E28: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C40E2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C40E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C40E34: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40E38: 4BFFFF59  bl 0x82c40d90
	ctx.lr = 0x82C40E3C;
	sub_82C40D90(ctx, base);
	// 82C40E3C: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C40E40: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C40E44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C40E48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C40E4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C40E50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C40E54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C40E58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40E60 size=184
    let mut pc: u32 = 0x82C40E60;
    'dispatch: loop {
        match pc {
            0x82C40E60 => {
    //   block [0x82C40E60..0x82C40E98)
	// 82C40E60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40E64: 4806859D  bl 0x82ca9400
	ctx.lr = 0x82C40E68;
	sub_82CA93D0(ctx, base);
	// 82C40E68: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40E6C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C40E70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C40E74: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C40E78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C40E7C: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C40E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C40E84: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C40E88: 419A0010  beq cr6, 0x82c40e98
	if ctx.cr[6].eq {
	pc = 0x82C40E98; continue 'dispatch;
	}
	// 82C40E8C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C40E90: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C40E94: 419A0008  beq cr6, 0x82c40e9c
	if ctx.cr[6].eq {
	pc = 0x82C40E9C; continue 'dispatch;
	}
	pc = 0x82C40E98; continue 'dispatch;
            }
            0x82C40E98 => {
    //   block [0x82C40E98..0x82C40E9C)
	// 82C40E98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C40E9C; continue 'dispatch;
            }
            0x82C40E9C => {
    //   block [0x82C40E9C..0x82C40F08)
	// 82C40E9C: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C40EA0: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C40EA4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C40EA8: 419A0060  beq cr6, 0x82c40f08
	if ctx.cr[6].eq {
	pc = 0x82C40F08; continue 'dispatch;
	}
	// 82C40EAC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C40EB0: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40EB4: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C40EB8: 835F0008  lwz r26, 8(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C40EC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C40EC4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C40EC8: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C40ECC: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C40ED0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C40ED4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C40ED8: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40EDC: 4BFFF55D  bl 0x82c40438
	ctx.lr = 0x82C40EE0;
	sub_82C40438(ctx, base);
	// 82C40EE0: 7D1CD050  subf r8, r28, r26
	ctx.r[8].s64 = ctx.r[26].s64 - ctx.r[28].s64;
	// 82C40EE4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40EE8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C40EEC: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C40EF0: 7D071E70  srawi r7, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 82C40EF4: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C40EF8: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C40EFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C40F00: 4BFFF2B1  bl 0x82c401b0
	ctx.lr = 0x82C40F04;
	sub_82C401B0(ctx, base);
	// 82C40F04: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82C40F08; continue 'dispatch;
            }
            0x82C40F08 => {
    //   block [0x82C40F08..0x82C40F18)
	// 82C40F08: FB7D0000  std r27, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 82C40F0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C40F10: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C40F14: 4806853C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C40F18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C40F18 size=724
    let mut pc: u32 = 0x82C40F18;
    'dispatch: loop {
        match pc {
            0x82C40F18 => {
    //   block [0x82C40F18..0x82C40F5C)
	// 82C40F18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C40F1C: 480684E1  bl 0x82ca93fc
	ctx.lr = 0x82C40F20;
	sub_82CA93D0(ctx, base);
	// 82C40F20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C40F24: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40F28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C40F2C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40F30: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C40F34: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 82C40F38: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82C40F3C: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82C40F40: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C40F44: 419A0018  beq cr6, 0x82c40f5c
	if ctx.cr[6].eq {
	pc = 0x82C40F5C; continue 'dispatch;
	}
	// 82C40F48: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40F4C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C40F50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C40F54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C40F58: 4E800421  bctrl
	ctx.lr = 0x82C40F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C40F5C => {
    //   block [0x82C40F5C..0x82C40F74)
	// 82C40F5C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C40F60: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C40F64: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C40F68: 409A000C  bne cr6, 0x82c40f74
	if !ctx.cr[6].eq {
	pc = 0x82C40F74; continue 'dispatch;
	}
	// 82C40F6C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 82C40F70: 48000010  b 0x82c40f80
	pc = 0x82C40F80; continue 'dispatch;
            }
            0x82C40F74 => {
    //   block [0x82C40F74..0x82C40F80)
	// 82C40F74: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C40F78: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C40F7C: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82C40F80; continue 'dispatch;
            }
            0x82C40F80 => {
    //   block [0x82C40F80..0x82C40F98)
	// 82C40F80: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C40F84: 419A0244  beq cr6, 0x82c411c8
	if ctx.cr[6].eq {
	pc = 0x82C411C8; continue 'dispatch;
	}
	// 82C40F88: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C40F8C: 409A000C  bne cr6, 0x82c40f98
	if !ctx.cr[6].eq {
	pc = 0x82C40F98; continue 'dispatch;
	}
	// 82C40F90: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C40F94: 48000010  b 0x82c40fa4
	pc = 0x82C40FA4; continue 'dispatch;
            }
            0x82C40F98 => {
    //   block [0x82C40F98..0x82C40FA4)
	// 82C40F98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40F9C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C40FA0: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82C40FA4; continue 'dispatch;
            }
            0x82C40FA4 => {
    //   block [0x82C40FA4..0x82C40FC0)
	// 82C40FA4: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 82C40FA8: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82C40FAC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C40FB0: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C40FB4: 4098000C  bge cr6, 0x82c40fc0
	if !ctx.cr[6].lt {
	pc = 0x82C40FC0; continue 'dispatch;
	}
	// 82C40FB8: 4BFBE4B1  bl 0x82bff468
	ctx.lr = 0x82C40FBC;
	sub_82BFF468(ctx, base);
	// 82C40FBC: 4800020C  b 0x82c411c8
	pc = 0x82C411C8; continue 'dispatch;
            }
            0x82C40FC0 => {
    //   block [0x82C40FC0..0x82C40FD0)
	// 82C40FC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C40FC4: 409A000C  bne cr6, 0x82c40fd0
	if !ctx.cr[6].eq {
	pc = 0x82C40FD0; continue 'dispatch;
	}
	// 82C40FC8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C40FCC: 48000010  b 0x82c40fdc
	pc = 0x82C40FDC; continue 'dispatch;
            }
            0x82C40FD0 => {
    //   block [0x82C40FD0..0x82C40FDC)
	// 82C40FD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C40FD4: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C40FD8: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	pc = 0x82C40FDC; continue 'dispatch;
            }
            0x82C40FDC => {
    //   block [0x82C40FDC..0x82C41000)
	// 82C40FDC: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C40FE0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C40FE4: 4098013C  bge cr6, 0x82c41120
	if !ctx.cr[6].lt {
	pc = 0x82C41120; continue 'dispatch;
	}
	// 82C40FE8: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C40FEC: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 82C40FF0: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C40FF4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C40FF8: 41980008  blt cr6, 0x82c41000
	if ctx.cr[6].lt {
	pc = 0x82C41000; continue 'dispatch;
	}
	// 82C40FFC: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82C41000; continue 'dispatch;
            }
            0x82C41000 => {
    //   block [0x82C41000..0x82C41010)
	// 82C41000: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C41004: 409A000C  bne cr6, 0x82c41010
	if !ctx.cr[6].eq {
	pc = 0x82C41010; continue 'dispatch;
	}
	// 82C41008: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C4100C: 48000010  b 0x82c4101c
	pc = 0x82C4101C; continue 'dispatch;
            }
            0x82C41010 => {
    //   block [0x82C41010..0x82C4101C)
	// 82C41010: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41014: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C41018: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82C4101C; continue 'dispatch;
            }
            0x82C4101C => {
    //   block [0x82C4101C..0x82C41038)
	// 82C4101C: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C41020: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C41024: 40980024  bge cr6, 0x82c41048
	if !ctx.cr[6].lt {
	pc = 0x82C41048; continue 'dispatch;
	}
	// 82C41028: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C4102C: 409A000C  bne cr6, 0x82c41038
	if !ctx.cr[6].eq {
	pc = 0x82C41038; continue 'dispatch;
	}
	// 82C41030: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C41034: 48000010  b 0x82c41044
	pc = 0x82C41044; continue 'dispatch;
            }
            0x82C41038 => {
    //   block [0x82C41038..0x82C41044)
	// 82C41038: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4103C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 82C41040: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82C41044; continue 'dispatch;
            }
            0x82C41044 => {
    //   block [0x82C41044..0x82C41048)
	// 82C41044: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82C41048; continue 'dispatch;
            }
            0x82C41048 => {
    //   block [0x82C41048..0x82C410D0)
	// 82C41048: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4104C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41050: 4BE6F909  bl 0x82ab0958
	ctx.lr = 0x82C41054;
	sub_82AB0958(ctx, base);
	// 82C41054: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C41058: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4105C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C41060: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41064: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C41068: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C4106C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C41070: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C41074: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C41078: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4107C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C41080: 4BFFF879  bl 0x82c408f8
	ctx.lr = 0x82C41084;
	sub_82C408F8(ctx, base);
	// 82C41084: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C41088: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82C4108C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C41090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41094: 4BFFFD65  bl 0x82c40df8
	ctx.lr = 0x82C41098;
	sub_82C40DF8(ctx, base);
	// 82C41098: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C4109C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C410A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C410A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C410A8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C410AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C410B0: 9B490000  stb r26, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C410B4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C410B8: 4BFFF841  bl 0x82c408f8
	ctx.lr = 0x82C410BC;
	sub_82C408F8(ctx, base);
	// 82C410BC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C410C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C410C4: 409A000C  bne cr6, 0x82c410d0
	if !ctx.cr[6].eq {
	pc = 0x82C410D0; continue 'dispatch;
	}
	// 82C410C8: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 82C410CC: 48000010  b 0x82c410dc
	pc = 0x82C410DC; continue 'dispatch;
            }
            0x82C410D0 => {
    //   block [0x82C410D0..0x82C410DC)
	// 82C410D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C410D4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C410D8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x82C410DC; continue 'dispatch;
            }
            0x82C410DC => {
    //   block [0x82C410DC..0x82C41100)
	// 82C410DC: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C410E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C410E4: 419A001C  beq cr6, 0x82c41100
	if ctx.cr[6].eq {
	pc = 0x82C41100; continue 'dispatch;
	}
	// 82C410E8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C410EC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C410F0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C410F4: 4BFFF0BD  bl 0x82c401b0
	ctx.lr = 0x82C410F8;
	sub_82C401B0(ctx, base);
	// 82C410F8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C410FC: 4BC046B5  bl 0x828457b0
	ctx.lr = 0x82C41100;
	sub_828457B0(ctx, base);
	pc = 0x82C41100; continue 'dispatch;
            }
            0x82C41100 => {
    //   block [0x82C41100..0x82C41120)
	// 82C41100: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C41104: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C41108: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4110C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C41110: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C41114: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C41118: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C4111C: 480000AC  b 0x82c411c8
	pc = 0x82C411C8; continue 'dispatch;
            }
            0x82C41120 => {
    //   block [0x82C41120..0x82C41190)
	// 82C41120: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41124: 577C1838  slwi r28, r27, 3
	ctx.r[28].u32 = ctx.r[27].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82C41128: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C4112C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C41130: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C41134: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C41138: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C4113C: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 82C41140: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C41144: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C41148: 9B4B0000  stb r26, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C4114C: 40980044  bge cr6, 0x82c41190
	if !ctx.cr[6].lt {
	pc = 0x82C41190; continue 'dispatch;
	}
	// 82C41150: 7CBCF214  add r5, r28, r30
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82C41154: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C41158: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4115C: 4BFFF79D  bl 0x82c408f8
	ctx.lr = 0x82C41160;
	sub_82C408F8(ctx, base);
	// 82C41160: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41164: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82C41168: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4116C: 7D5E2050  subf r10, r30, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C41170: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 82C41174: 7CA9D850  subf r5, r9, r27
	ctx.r[5].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 82C41178: 4BFFFC81  bl 0x82c40df8
	ctx.lr = 0x82C4117C;
	sub_82C40DF8(ctx, base);
	// 82C4117C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41180: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82C41184: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C41188: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82C4118C: 48000030  b 0x82c411bc
	pc = 0x82C411BC; continue 'dispatch;
            }
            0x82C41190 => {
    //   block [0x82C41190..0x82C411BC)
	// 82C41190: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82C41194: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C41198: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C4119C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C411A0: 4BFFF759  bl 0x82c408f8
	ctx.lr = 0x82C411A4;
	sub_82C408F8(ctx, base);
	// 82C411A4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C411A8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C411AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C411B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C411B4: 4BFFF6ED  bl 0x82c408a0
	ctx.lr = 0x82C411B8;
	sub_82C408A0(ctx, base);
	// 82C411B8: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	pc = 0x82C411BC; continue 'dispatch;
            }
            0x82C411BC => {
    //   block [0x82C411BC..0x82C411C8)
	// 82C411BC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C411C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C411C4: 4BFFF1ED  bl 0x82c403b0
	ctx.lr = 0x82C411C8;
	sub_82C403B0(ctx, base);
	pc = 0x82C411C8; continue 'dispatch;
            }
            0x82C411C8 => {
    //   block [0x82C411C8..0x82C411E4)
	// 82C411C8: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 82C411CC: 419A0018  beq cr6, 0x82c411e4
	if ctx.cr[6].eq {
	pc = 0x82C411E4; continue 'dispatch;
	}
	// 82C411D0: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C411D4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82C411D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C411DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C411E0: 4E800421  bctrl
	ctx.lr = 0x82C411E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C411E4 => {
    //   block [0x82C411E4..0x82C411EC)
	// 82C411E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C411E8: 48068264  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C411F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C411F0 size=288
    let mut pc: u32 = 0x82C411F0;
    'dispatch: loop {
        match pc {
            0x82C411F0 => {
    //   block [0x82C411F0..0x82C41224)
	// 82C411F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C411F4: 48068215  bl 0x82ca9408
	ctx.lr = 0x82C411F8;
	sub_82CA93D0(ctx, base);
	// 82C411F8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C411FC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C41200: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C41204: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C41208: 394BC2D0  addi r10, r11, -0x3d30
	ctx.r[10].s64 = ctx.r[11].s64 + -15664;
	// 82C4120C: 807C004C  lwz r3, 0x4c(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C41210: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C41214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41218: 419A000C  beq cr6, 0x82c41224
	if ctx.cr[6].eq {
	pc = 0x82C41224; continue 'dispatch;
	}
	// 82C4121C: 4BFCDAB5  bl 0x82c0ecd0
	ctx.lr = 0x82C41220;
	sub_82C0ECD0(ctx, base);
	// 82C41220: 93FC004C  stw r31, 0x4c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	pc = 0x82C41224; continue 'dispatch;
            }
            0x82C41224 => {
    //   block [0x82C41224..0x82C41254)
	// 82C41224: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C41228: 3BDC0040  addi r30, r28, 0x40
	ctx.r[30].s64 = ctx.r[28].s64 + 64;
	// 82C4122C: 816A4F90  lwz r11, 0x4f90(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20368 as u32) ) } as u64;
	// 82C41230: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82C41234: 916A4F90  stw r11, 0x4f90(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20368 as u32), ctx.r[11].u32 ) };
	// 82C41238: 807C0044  lwz r3, 0x44(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) } as u64;
	// 82C4123C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41240: 419A0014  beq cr6, 0x82c41254
	if ctx.cr[6].eq {
	pc = 0x82C41254; continue 'dispatch;
	}
	// 82C41244: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41248: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4124C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41250: 4E800421  bctrl
	ctx.lr = 0x82C41254;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41254 => {
    //   block [0x82C41254..0x82C41284)
	// 82C41254: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C41258: 3BBC0030  addi r29, r28, 0x30
	ctx.r[29].s64 = ctx.r[28].s64 + 48;
	// 82C4125C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C41260: 807C0034  lwz r3, 0x34(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C41264: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41268: 419A001C  beq cr6, 0x82c41284
	if ctx.cr[6].eq {
	pc = 0x82C41284; continue 'dispatch;
	}
	// 82C4126C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C41270: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C41274: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41278: 4BFFEF39  bl 0x82c401b0
	ctx.lr = 0x82C4127C;
	sub_82C401B0(ctx, base);
	// 82C4127C: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41280: 4BC04531  bl 0x828457b0
	ctx.lr = 0x82C41284;
	sub_828457B0(ctx, base);
	pc = 0x82C41284; continue 'dispatch;
            }
            0x82C41284 => {
    //   block [0x82C41284..0x82C412B8)
	// 82C41284: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C41288: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 82C4128C: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C41290: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C41294: 807C0024  lwz r3, 0x24(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C41298: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4129C: 419A001C  beq cr6, 0x82c412b8
	if ctx.cr[6].eq {
	pc = 0x82C412B8; continue 'dispatch;
	}
	// 82C412A0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C412A4: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C412A8: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C412AC: 4BFFEF05  bl 0x82c401b0
	ctx.lr = 0x82C412B0;
	sub_82C401B0(ctx, base);
	// 82C412B0: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C412B4: 4BC044FD  bl 0x828457b0
	ctx.lr = 0x82C412B8;
	sub_828457B0(ctx, base);
	pc = 0x82C412B8; continue 'dispatch;
            }
            0x82C412B8 => {
    //   block [0x82C412B8..0x82C412EC)
	// 82C412B8: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C412BC: 3BBC0010  addi r29, r28, 0x10
	ctx.r[29].s64 = ctx.r[28].s64 + 16;
	// 82C412C0: 93FE0008  stw r31, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C412C4: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C412C8: 807C0014  lwz r3, 0x14(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C412CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C412D0: 419A001C  beq cr6, 0x82c412ec
	if ctx.cr[6].eq {
	pc = 0x82C412EC; continue 'dispatch;
	}
	// 82C412D4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C412D8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C412DC: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C412E0: 4BFFEED1  bl 0x82c401b0
	ctx.lr = 0x82C412E4;
	sub_82C401B0(ctx, base);
	// 82C412E4: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C412E8: 4BC044C9  bl 0x828457b0
	ctx.lr = 0x82C412EC;
	sub_828457B0(ctx, base);
	pc = 0x82C412EC; continue 'dispatch;
            }
            0x82C412EC => {
    //   block [0x82C412EC..0x82C41310)
	// 82C412EC: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82C412F0: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 82C412F4: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82C412F8: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82C412FC: 48015135  bl 0x82c56430
	ctx.lr = 0x82C41300;
	sub_82C56430(ctx, base);
	// 82C41300: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C41304: 4BFC4E0D  bl 0x82c06110
	ctx.lr = 0x82C41308;
	sub_82C06110(ctx, base);
	// 82C41308: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4130C: 4806814C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C41310 size=80
    let mut pc: u32 = 0x82C41310;
    'dispatch: loop {
        match pc {
            0x82C41310 => {
    //   block [0x82C41310..0x82C41348)
	// 82C41310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C41318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4131C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C41320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C41324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C41328: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4132C: 4BFFFEC5  bl 0x82c411f0
	ctx.lr = 0x82C41330;
	sub_82C411F0(ctx, base);
	// 82C41330: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C41334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4133C: 419A000C  beq cr6, 0x82c41348
	if ctx.cr[6].eq {
	pc = 0x82C41348; continue 'dispatch;
	}
	// 82C41340: 4BC04471  bl 0x828457b0
	ctx.lr = 0x82C41344;
	sub_828457B0(ctx, base);
	// 82C41344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C41348; continue 'dispatch;
            }
            0x82C41348 => {
    //   block [0x82C41348..0x82C41360)
	// 82C41348: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4134C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C41350: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C41354: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C41358: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4135C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C41360 size=336
    let mut pc: u32 = 0x82C41360;
    'dispatch: loop {
        match pc {
            0x82C41360 => {
    //   block [0x82C41360..0x82C41390)
	// 82C41360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C41368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4136C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C41370: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C41374: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41378: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C4137C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C41380: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41384: 409A000C  bne cr6, 0x82c41390
	if !ctx.cr[6].eq {
	pc = 0x82C41390; continue 'dispatch;
	}
	// 82C41388: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82C4138C: 48000010  b 0x82c4139c
	pc = 0x82C4139C; continue 'dispatch;
            }
            0x82C41390 => {
    //   block [0x82C41390..0x82C4139C)
	// 82C41390: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41394: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41398: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82C4139C; continue 'dispatch;
            }
            0x82C4139C => {
    //   block [0x82C4139C..0x82C413B4)
	// 82C4139C: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C413A0: 4098004C  bge cr6, 0x82c413ec
	if !ctx.cr[6].lt {
	pc = 0x82C413EC; continue 'dispatch;
	}
	// 82C413A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C413A8: 409A000C  bne cr6, 0x82c413b4
	if !ctx.cr[6].eq {
	pc = 0x82C413B4; continue 'dispatch;
	}
	// 82C413AC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82C413B0: 48000010  b 0x82c413c0
	pc = 0x82C413C0; continue 'dispatch;
            }
            0x82C413B4 => {
    //   block [0x82C413B4..0x82C413C0)
	// 82C413B4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C413B8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C413BC: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x82C413C0; continue 'dispatch;
            }
            0x82C413C0 => {
    //   block [0x82C413C0..0x82C413D0)
	// 82C413C0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C413C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C413C8: 40990008  ble cr6, 0x82c413d0
	if !ctx.cr[6].gt {
	pc = 0x82C413D0; continue 'dispatch;
	}
	// 82C413CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C413D0; continue 'dispatch;
            }
            0x82C413D0 => {
    //   block [0x82C413D0..0x82C413EC)
	// 82C413D0: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C413D4: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C413D8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C413DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C413E0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C413E4: 4BFFFB35  bl 0x82c40f18
	ctx.lr = 0x82C413E8;
	sub_82C40F18(ctx, base);
	// 82C413E8: 4800008C  b 0x82c41474
	pc = 0x82C41474; continue 'dispatch;
            }
            0x82C413EC => {
    //   block [0x82C413EC..0x82C41414)
	// 82C413EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C413F0: 419A0084  beq cr6, 0x82c41474
	if ctx.cr[6].eq {
	pc = 0x82C41474; continue 'dispatch;
	}
	// 82C413F4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C413F8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C413FC: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41400: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C41404: 40980070  bge cr6, 0x82c41474
	if !ctx.cr[6].lt {
	pc = 0x82C41474; continue 'dispatch;
	}
	// 82C41408: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4140C: 40990008  ble cr6, 0x82c41414
	if !ctx.cr[6].gt {
	pc = 0x82C41414; continue 'dispatch;
	}
	// 82C41410: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41414; continue 'dispatch;
            }
            0x82C41414 => {
    //   block [0x82C41414..0x82C41428)
	// 82C41414: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82C41418: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4141C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C41420: 40990008  ble cr6, 0x82c41428
	if !ctx.cr[6].gt {
	pc = 0x82C41428; continue 'dispatch;
	}
	// 82C41424: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41428; continue 'dispatch;
            }
            0x82C41428 => {
    //   block [0x82C41428..0x82C41458)
	// 82C41428: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4142C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41430: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C41434: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C41438: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C4143C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C41440: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C41444: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C41448: 41990010  bgt cr6, 0x82c41458
	if ctx.cr[6].gt {
	pc = 0x82C41458; continue 'dispatch;
	}
	// 82C4144C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41450: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C41454: 40980008  bge cr6, 0x82c4145c
	if !ctx.cr[6].lt {
	pc = 0x82C4145C; continue 'dispatch;
	}
	pc = 0x82C41458; continue 'dispatch;
            }
            0x82C41458 => {
    //   block [0x82C41458..0x82C4145C)
	// 82C41458: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4145C; continue 'dispatch;
            }
            0x82C4145C => {
    //   block [0x82C4145C..0x82C41474)
	// 82C4145C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C41460: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C41464: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41468: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C4146C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C41470: 4BFFF9F1  bl 0x82c40e60
	ctx.lr = 0x82C41474;
	sub_82C40E60(ctx, base);
	pc = 0x82C41474; continue 'dispatch;
            }
            0x82C41474 => {
    //   block [0x82C41474..0x82C41490)
	// 82C41474: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41478: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4147C: 419A0014  beq cr6, 0x82c41490
	if ctx.cr[6].eq {
	pc = 0x82C41490; continue 'dispatch;
	}
	// 82C41480: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41484: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41488: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4148C: 4E800421  bctrl
	ctx.lr = 0x82C41490;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41490 => {
    //   block [0x82C41490..0x82C414B0)
	// 82C41490: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C41494: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C41498: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4149C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C414A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C414A4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C414A8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C414AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C414B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C414B0 size=164
    let mut pc: u32 = 0x82C414B0;
    'dispatch: loop {
        match pc {
            0x82C414B0 => {
    //   block [0x82C414B0..0x82C414F4)
	// 82C414B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C414B4: 48067F55  bl 0x82ca9408
	ctx.lr = 0x82C414B8;
	sub_82CA93D0(ctx, base);
	// 82C414B8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C414BC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C414C0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C414C4: 80BD0010  lwz r5, 0x10(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C414C8: 4BFFE541  bl 0x82c3fa08
	ctx.lr = 0x82C414CC;
	sub_82C3FA08(ctx, base);
	// 82C414CC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C414D0: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C414D4: 419A0038  beq cr6, 0x82c4150c
	if ctx.cr[6].eq {
	pc = 0x82C4150C; continue 'dispatch;
	}
	// 82C414D8: 38600054  li r3, 0x54
	ctx.r[3].s64 = 84;
	// 82C414DC: 4B5DDD7D  bl 0x8221f258
	ctx.lr = 0x82C414E0;
	sub_8221F258(ctx, base);
	// 82C414E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C414E4: 419A0010  beq cr6, 0x82c414f4
	if ctx.cr[6].eq {
	pc = 0x82C414F4; continue 'dispatch;
	}
	// 82C414E8: 4BFFEE01  bl 0x82c402e8
	ctx.lr = 0x82C414EC;
	sub_82C402E8(ctx, base);
	// 82C414EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C414F0: 48000008  b 0x82c414f8
	pc = 0x82C414F8; continue 'dispatch;
            }
            0x82C414F4 => {
    //   block [0x82C414F4..0x82C414F8)
	// 82C414F4: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C414F8; continue 'dispatch;
            }
            0x82C414F8 => {
    //   block [0x82C414F8..0x82C41508)
	// 82C414F8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C414FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C41500: 409A0018  bne cr6, 0x82c41518
	if !ctx.cr[6].eq {
	pc = 0x82C41518; continue 'dispatch;
	}
	// 82C41504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	pc = 0x82C41508; continue 'dispatch;
            }
            0x82C41508 => {
    //   block [0x82C41508..0x82C4150C)
	// 82C41508: 4BFF7611  bl 0x82c38b18
	ctx.lr = 0x82C4150C;
	sub_82C38B18(ctx, base);
	pc = 0x82C4150C; continue 'dispatch;
            }
            0x82C4150C => {
    //   block [0x82C4150C..0x82C41518)
	// 82C4150C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C41510: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C41514: 48067F44  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C41518 => {
    //   block [0x82C41518..0x82C41554)
	// 82C41518: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82C4151C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C41520: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C41524: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41528: 4BFFE3C1  bl 0x82c3f8e8
	ctx.lr = 0x82C4152C;
	sub_82C3F8E8(ctx, base);
	// 82C4152C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C41530: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C41534: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41538: 419AFFD0  beq cr6, 0x82c41508
	if ctx.cr[6].eq {
	pc = 0x82C41508; continue 'dispatch;
	}
	// 82C4153C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C41540: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C41544: 4BFF75D5  bl 0x82c38b18
	ctx.lr = 0x82C41548;
	sub_82C38B18(ctx, base);
	// 82C41548: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4154C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C41550: 48067F08  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C41558 size=1076
    let mut pc: u32 = 0x82C41558;
    'dispatch: loop {
        match pc {
            0x82C41558 => {
    //   block [0x82C41558..0x82C41580)
	// 82C41558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4155C: 48067E75  bl 0x82ca93d0
	ctx.lr = 0x82C41560;
	sub_82CA93D0(ctx, base);
	// 82C41560: DBC1FF58  stfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 82C41564: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 82C41568: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4156C: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 82C41570: 9081014C  stw r4, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[4].u32 ) };
	// 82C41574: 89750050  lbz r11, 0x50(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[21].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C41578: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4157C: 419A0018  beq cr6, 0x82c41594
	if ctx.cr[6].eq {
	pc = 0x82C41594; continue 'dispatch;
	}
	pc = 0x82C41580; continue 'dispatch;
            }
            0x82C41580 => {
    //   block [0x82C41580..0x82C41594)
	// 82C41580: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C41584: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82C41588: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82C4158C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82C41590: 48067E90  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C41594 => {
    //   block [0x82C41594..0x82C41664)
	// 82C41594: 81750040  lwz r11, 0x40(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C41598: 3A750048  addi r19, r21, 0x48
	ctx.r[19].s64 = ctx.r[21].s64 + 72;
	// 82C4159C: 3AF50040  addi r23, r21, 0x40
	ctx.r[23].s64 = ctx.r[21].s64 + 64;
	// 82C415A0: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 82C415A4: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C415A8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C415AC: 812A0028  lwz r9, 0x28(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C415B0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C415B4: 4E800421  bctrl
	ctx.lr = 0x82C415B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C415B8: 80950048  lwz r4, 0x48(r21)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C415BC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C415C0: 419AFFC0  beq cr6, 0x82c41580
	if ctx.cr[6].eq {
	pc = 0x82C41580; continue 'dispatch;
	}
	// 82C415C4: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C415C8: 3B750010  addi r27, r21, 0x10
	ctx.r[27].s64 = ctx.r[21].s64 + 16;
	// 82C415CC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82C415D0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C415D4: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82C415D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C415DC: 4BFFFD85  bl 0x82c41360
	ctx.lr = 0x82C415E0;
	sub_82C41360(ctx, base);
	// 82C415E0: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82C415E4: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82C415E8: 39F50020  addi r15, r21, 0x20
	ctx.r[15].s64 = ctx.r[21].s64 + 32;
	// 82C415EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C415F0: 80930000  lwz r4, 0(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C415F4: 7DE37B78  mr r3, r15
	ctx.r[3].u64 = ctx.r[15].u64;
	// 82C415F8: 4BFFFD69  bl 0x82c41360
	ctx.lr = 0x82C415FC;
	sub_82C41360(ctx, base);
	// 82C415FC: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 82C41600: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 82C41604: 3B150030  addi r24, r21, 0x30
	ctx.r[24].s64 = ctx.r[21].s64 + 48;
	// 82C41608: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C4160C: 80930000  lwz r4, 0(r19)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41610: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C41614: 4BFFFD4D  bl 0x82c41360
	ctx.lr = 0x82C41618;
	sub_82C41360(ctx, base);
	// 82C41618: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4161C: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82C41620: 3A000001  li r16, 1
	ctx.r[16].s64 = 1;
	// 82C41624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41628: 40990348  ble cr6, 0x82c41970
	if !ctx.cr[6].gt {
	pc = 0x82C41970; continue 'dispatch;
	}
	// 82C4162C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C41630: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C41634: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C41638: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4163C: 38EB61F4  addi r7, r11, 0x61f4
	ctx.r[7].s64 = ctx.r[11].s64 + 25076;
	// 82C41640: C3C90C18  lfs f30, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C41644: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	// 82C41648: C3E80C14  lfs f31, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C4164C: 7F34CB78  mr r20, r25
	ctx.r[20].u64 = ctx.r[25].u64;
	// 82C41650: 3AC0FFFF  li r22, -1
	ctx.r[22].s64 = -1;
	// 82C41654: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 82C41658: 3A200004  li r17, 4
	ctx.r[17].s64 = 4;
	// 82C4165C: 3A400024  li r18, 0x24
	ctx.r[18].s64 = 36;
	// 82C41660: 39CAC278  addi r14, r10, -0x3d88
	ctx.r[14].s64 = ctx.r[10].s64 + -15752;
            }
            0x82C41664 => {
    //   block [0x82C41664..0x82C41688)
	// 82C41664: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82C41668: 4B5DDBF1  bl 0x8221f258
	ctx.lr = 0x82C4166C;
	sub_8221F258(ctx, base);
	// 82C4166C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41670: 419A0018  beq cr6, 0x82c41688
	if ctx.cr[6].eq {
	pc = 0x82C41688; continue 'dispatch;
	}
	// 82C41674: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C41678: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 82C4167C: 4BFFEF35  bl 0x82c405b0
	ctx.lr = 0x82C41680;
	sub_82C405B0(ctx, base);
	// 82C41680: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C41684: 48000008  b 0x82c4168c
	pc = 0x82C4168C; continue 'dispatch;
            }
            0x82C41688 => {
    //   block [0x82C41688..0x82C4168C)
	// 82C41688: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	pc = 0x82C4168C; continue 'dispatch;
            }
            0x82C4168C => {
    //   block [0x82C4168C..0x82C416AC)
	// 82C4168C: 816F0004  lwz r11, 4(r15)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41690: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41694: 419A0018  beq cr6, 0x82c416ac
	if ctx.cr[6].eq {
	pc = 0x82C416AC; continue 'dispatch;
	}
	// 82C41698: 814F0008  lwz r10, 8(r15)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[15].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4169C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C416A0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C416A4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C416A8: 41980008  blt cr6, 0x82c416b0
	if ctx.cr[6].lt {
	pc = 0x82C416B0; continue 'dispatch;
	}
	pc = 0x82C416AC; continue 'dispatch;
            }
            0x82C416AC => {
    //   block [0x82C416AC..0x82C416B0)
	// 82C416AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C416B0; continue 'dispatch;
            }
            0x82C416B0 => {
    //   block [0x82C416B0..0x82C416D0)
	// 82C416B0: 37DD0014  addic. r30, r29, 0x14
	ctx.xer.ca = (ctx.r[29].u32 > (!(20 as u32)));
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 82C416B4: 7FFA5A14  add r31, r26, r11
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82C416B8: 41820018  beq 0x82c416d0
	if ctx.cr[0].eq {
	pc = 0x82C416D0; continue 'dispatch;
	}
	// 82C416BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C416C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C416C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C416C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C416CC: 4E800421  bctrl
	ctx.lr = 0x82C416D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C416D0 => {
    //   block [0x82C416D0..0x82C416EC)
	// 82C416D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C416D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C416D8: 419A0014  beq cr6, 0x82c416ec
	if ctx.cr[6].eq {
	pc = 0x82C416EC; continue 'dispatch;
	}
	// 82C416DC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C416E0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C416E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C416E8: 4E800421  bctrl
	ctx.lr = 0x82C416EC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C416EC => {
    //   block [0x82C416EC..0x82C41768)
	// 82C416EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C416F0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C416F4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C416F8: 4BFCD539  bl 0x82c0ec30
	ctx.lr = 0x82C416FC;
	sub_82C0EC30(ctx, base);
	// 82C416FC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41700: 38A10074  addi r5, r1, 0x74
	ctx.r[5].s64 = ctx.r[1].s64 + 116;
	// 82C41704: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C41708: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4170C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41710: 812A0030  lwz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C41714: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C41718: 4E800421  bctrl
	ctx.lr = 0x82C4171C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4171C: 81170000  lwz r8, 0(r23)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41720: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C41724: 8068000C  lwz r3, 0xc(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C41728: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4172C: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41730: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C41734: 4E800421  bctrl
	ctx.lr = 0x82C41738;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41738: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4173C: 92C1007C  stw r22, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[22].u32 ) };
	// 82C41740: 92010084  stw r16, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[16].u32 ) };
	// 82C41744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41748: 92210080  stw r17, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[17].u32 ) };
	// 82C4174C: 92410078  stw r18, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[18].u32 ) };
	// 82C41750: 419A0018  beq cr6, 0x82c41768
	if ctx.cr[6].eq {
	pc = 0x82C41768; continue 'dispatch;
	}
	// 82C41754: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41758: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C4175C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41760: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41764: 41980008  blt cr6, 0x82c4176c
	if ctx.cr[6].lt {
	pc = 0x82C4176C; continue 'dispatch;
	}
            }
            0x82C41768 => {
    //   block [0x82C41768..0x82C4176C)
	// 82C41768: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4176C; continue 'dispatch;
            }
            0x82C4176C => {
    //   block [0x82C4176C..0x82C417A4)
	// 82C4176C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C41770: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41774: 7FFA5A14  add r31, r26, r11
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82C41778: 4BFCFBF1  bl 0x82c11368
	ctx.lr = 0x82C4177C;
	sub_82C11368(ctx, base);
	// 82C4177C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C41780: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41784: 4BFD0545  bl 0x82c11cc8
	ctx.lr = 0x82C41788;
	sub_82C11CC8(ctx, base);
	// 82C41788: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 82C4178C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41790: 419A0014  beq cr6, 0x82c417a4
	if ctx.cr[6].eq {
	pc = 0x82C417A4; continue 'dispatch;
	}
	// 82C41794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41798: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4179C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C417A0: 4E800421  bctrl
	ctx.lr = 0x82C417A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C417A4 => {
    //   block [0x82C417A4..0x82C417CC)
	// 82C417A4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C417A8: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 82C417AC: 93210060  stw r25, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82C417B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C417B4: 419A0018  beq cr6, 0x82c417cc
	if ctx.cr[6].eq {
	pc = 0x82C417CC; continue 'dispatch;
	}
	// 82C417B8: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C417BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C417C0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C417C4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C417C8: 41980008  blt cr6, 0x82c417d0
	if ctx.cr[6].lt {
	pc = 0x82C417D0; continue 'dispatch;
	}
	pc = 0x82C417CC; continue 'dispatch;
            }
            0x82C417CC => {
    //   block [0x82C417CC..0x82C417D0)
	// 82C417CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C417D0; continue 'dispatch;
            }
            0x82C417D0 => {
    //   block [0x82C417D0..0x82C417FC)
	// 82C417D0: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C417D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C417D8: 419A0180  beq cr6, 0x82c41958
	if ctx.cr[6].eq {
	pc = 0x82C41958; continue 'dispatch;
	}
	// 82C417DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C417E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C417E4: 419A0018  beq cr6, 0x82c417fc
	if ctx.cr[6].eq {
	pc = 0x82C417FC; continue 'dispatch;
	}
	// 82C417E8: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C417EC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C417F0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C417F4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C417F8: 41980008  blt cr6, 0x82c41800
	if ctx.cr[6].lt {
	pc = 0x82C41800; continue 'dispatch;
	}
	pc = 0x82C417FC; continue 'dispatch;
            }
            0x82C417FC => {
    //   block [0x82C417FC..0x82C41800)
	// 82C417FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41800; continue 'dispatch;
            }
            0x82C41800 => {
    //   block [0x82C41800..0x82C4182C)
	// 82C41800: 7C9A5A14  add r4, r26, r11
	ctx.r[4].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82C41804: 38750004  addi r3, r21, 4
	ctx.r[3].s64 = ctx.r[21].s64 + 4;
	// 82C41808: 48014AE9  bl 0x82c562f0
	ctx.lr = 0x82C4180C;
	sub_82C562F0(ctx, base);
	// 82C4180C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41810: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C41814: 419A0018  beq cr6, 0x82c4182c
	if ctx.cr[6].eq {
	pc = 0x82C4182C; continue 'dispatch;
	}
	// 82C41818: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4181C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C41820: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41824: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C41828: 41980008  blt cr6, 0x82c41830
	if ctx.cr[6].lt {
	pc = 0x82C41830; continue 'dispatch;
	}
	pc = 0x82C4182C; continue 'dispatch;
            }
            0x82C4182C => {
    //   block [0x82C4182C..0x82C41830)
	// 82C4182C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41830; continue 'dispatch;
            }
            0x82C41830 => {
    //   block [0x82C41830..0x82C41854)
	// 82C41830: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41834: 7C9A502E  lwzx r4, r26, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C41838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4183C: 419A0018  beq cr6, 0x82c41854
	if ctx.cr[6].eq {
	pc = 0x82C41854; continue 'dispatch;
	}
	// 82C41840: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41844: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41848: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C4184C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41850: 41980008  blt cr6, 0x82c41858
	if ctx.cr[6].lt {
	pc = 0x82C41858; continue 'dispatch;
	}
	pc = 0x82C41854; continue 'dispatch;
            }
            0x82C41854 => {
    //   block [0x82C41854..0x82C41858)
	// 82C41854: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41858; continue 'dispatch;
            }
            0x82C41858 => {
    //   block [0x82C41858..0x82C41898)
	// 82C41858: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4185C: 7FFA5A14  add r31, r26, r11
	ctx.r[31].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82C41860: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82C41864: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C41868: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4186C: 4E800421  bctrl
	ctx.lr = 0x82C41870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41870: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C41874: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41878: 4BFD0451  bl 0x82c11cc8
	ctx.lr = 0x82C4187C;
	sub_82C11CC8(ctx, base);
	// 82C4187C: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C41880: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41884: 419A0014  beq cr6, 0x82c41898
	if ctx.cr[6].eq {
	pc = 0x82C41898; continue 'dispatch;
	}
	// 82C41888: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4188C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41890: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41894: 4E800421  bctrl
	ctx.lr = 0x82C41898;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41898 => {
    //   block [0x82C41898..0x82C4193C)
	// 82C41898: 9321006C  stw r25, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[25].u32 ) };
	// 82C4189C: 2B1C0007  cmplwi cr6, r28, 7
	ctx.cr[6].compare_u32(ctx.r[28].u32, 7 as u32, &mut ctx.xer);
	// 82C418A0: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 82C418A4: 409800B4  bge cr6, 0x82c41958
	if !ctx.cr[6].lt {
	pc = 0x82C41958; continue 'dispatch;
	}
	// 82C418A8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C418AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82C418B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C418B4: 7C94582E  lwzx r4, r20, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C418B8: 4B5EB619  bl 0x8222ced0
	ctx.lr = 0x82C418BC;
	sub_8222CED0(ctx, base);
	// 82C418BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C418C0: 4B649119  bl 0x8228a9d8
	ctx.lr = 0x82C418C4;
	sub_8228A9D8(ctx, base);
	// 82C418C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C418C8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C418CC: 4B5D350D  bl 0x82214dd8
	ctx.lr = 0x82C418D0;
	sub_82214DD8(ctx, base);
	// 82C418D0: 8061014C  lwz r3, 0x14c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 82C418D4: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C418D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C418DC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C418E0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C418E4: 812A0038  lwz r9, 0x38(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C418E8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C418EC: 4E800421  bctrl
	ctx.lr = 0x82C418F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C418F0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C418F4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C418F8: 419A0060  beq cr6, 0x82c41958
	if ctx.cr[6].eq {
	pc = 0x82C41958; continue 'dispatch;
	}
	// 82C418FC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C41900: 81780004  lwz r11, 4(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41904: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C41908: 7D94742E  lfsx f12, r20, r14
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[20].u32.wrapping_add(ctx.r[14].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C4190C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41910: FD6D07AE  fsel f11, f13, f30, f0
	ctx.f[11].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[0].f64 };
	// 82C41914: ED5F5828  fsubs f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C41918: FD2AFAEE  fsel f9, f10, f11, f31
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[31].f64 };
	// 82C4191C: EC290332  fmuls f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C41920: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C41924: 419A0018  beq cr6, 0x82c4193c
	if ctx.cr[6].eq {
	pc = 0x82C4193C; continue 'dispatch;
	}
	// 82C41928: 81580008  lwz r10, 8(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4192C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41930: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41934: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41938: 41980008  blt cr6, 0x82c41940
	if ctx.cr[6].lt {
	pc = 0x82C41940; continue 'dispatch;
	}
            }
            0x82C4193C => {
    //   block [0x82C4193C..0x82C41940)
	// 82C4193C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41940; continue 'dispatch;
            }
            0x82C41940 => {
    //   block [0x82C41940..0x82C41958)
	// 82C41940: 7C7A582E  lwzx r3, r26, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C41944: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C41948: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4194C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41954: 4E800421  bctrl
	ctx.lr = 0x82C41958;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41958 => {
    //   block [0x82C41958..0x82C41970)
	// 82C41958: 81730000  lwz r11, 0(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4195C: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C41960: 3A940004  addi r20, r20, 4
	ctx.r[20].s64 = ctx.r[20].s64 + 4;
	// 82C41964: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82C41968: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4196C: 4198FCF8  blt cr6, 0x82c41664
	if ctx.cr[6].lt {
	pc = 0x82C41664; continue 'dispatch;
	}
	pc = 0x82C41970; continue 'dispatch;
            }
            0x82C41970 => {
    //   block [0x82C41970..0x82C4198C)
	// 82C41970: 4BFCD3C9  bl 0x82c0ed38
	ctx.lr = 0x82C41974;
	sub_82C0ED38(ctx, base);
	// 82C41974: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C41978: 9A150050  stb r16, 0x50(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(80 as u32), ctx.r[16].u8 ) };
	// 82C4197C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 82C41980: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 82C41984: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 82C41988: 48067A98  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41990(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C41990 size=812
    let mut pc: u32 = 0x82C41990;
    'dispatch: loop {
        match pc {
            0x82C41990 => {
    //   block [0x82C41990..0x82C41A50)
	// 82C41990: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41994: 48067A5D  bl 0x82ca93f0
	ctx.lr = 0x82C41998;
	sub_82CA93D0(ctx, base);
	// 82C41998: DBC1FF98  stfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[30].u64 ) };
	// 82C4199C: DBE1FFA0  stfd f31, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 82C419A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C419A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C419A8: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 82C419AC: 897F0051  lbz r11, 0x51(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C419B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C419B4: 409A02C0  bne cr6, 0x82c41c74
	if !ctx.cr[6].eq {
	pc = 0x82C41C74; continue 'dispatch;
	}
	// 82C419B8: 897F0050  lbz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C419BC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C419C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C419C4: 409A008C  bne cr6, 0x82c41a50
	if !ctx.cr[6].eq {
	pc = 0x82C41A50; continue 'dispatch;
	}
	// 82C419C8: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C419CC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C419D0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C419D4: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C419D8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C419DC: 4E800421  bctrl
	ctx.lr = 0x82C419E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C419E0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C419E4: 419A0290  beq cr6, 0x82c41c74
	if ctx.cr[6].eq {
	pc = 0x82C41C74; continue 'dispatch;
	}
	// 82C419E8: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82C419EC: 419A02B8  beq cr6, 0x82c41ca4
	if ctx.cr[6].eq {
	pc = 0x82C41CA4; continue 'dispatch;
	}
	// 82C419F0: 817F0040  lwz r11, 0x40(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C419F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C419F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C419FC: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C41A00: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41A04: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41A08: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C41A0C: 4E800421  bctrl
	ctx.lr = 0x82C41A10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41A10: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C41A14: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C41A18: 7C6B4051  subf. r3, r11, r8
	ctx.r[3].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C41A1C: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C41A20: 40820264  bne 0x82c41c84
	if !ctx.cr[0].eq {
	pc = 0x82C41C84; continue 'dispatch;
	}
	// 82C41A24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C41A28: 4BFCD2A9  bl 0x82c0ecd0
	ctx.lr = 0x82C41A2C;
	sub_82C0ECD0(ctx, base);
	// 82C41A2C: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 82C41A30: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 82C41A34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41A38: 4BFFFB21  bl 0x82c41558
	ctx.lr = 0x82C41A3C;
	sub_82C41558(ctx, base);
	// 82C41A3C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C41A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41A44: 409A000C  bne cr6, 0x82c41a50
	if !ctx.cr[6].eq {
	pc = 0x82C41A50; continue 'dispatch;
	}
	// 82C41A48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C41A4C: 997F0051  stb r11, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
            }
            0x82C41A50 => {
    //   block [0x82C41A50..0x82C41A88)
	// 82C41A50: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C41A54: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82C41A58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41A5C: 40990218  ble cr6, 0x82c41c74
	if !ctx.cr[6].gt {
	pc = 0x82C41C74; continue 'dispatch;
	}
	// 82C41A60: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C41A64: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C41A68: 3D60832D  lis r11, -0x7cd3
	ctx.r[11].s64 = -2094202880;
	// 82C41A6C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C41A70: 7FDAF378  mr r26, r30
	ctx.r[26].u64 = ctx.r[30].u64;
	// 82C41A74: C3C90C18  lfs f30, 0xc18(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C41A78: 7FD9F378  mr r25, r30
	ctx.r[25].u64 = ctx.r[30].u64;
	// 82C41A7C: C3E80C14  lfs f31, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C41A80: 3AEB61F4  addi r23, r11, 0x61f4
	ctx.r[23].s64 = ctx.r[11].s64 + 25076;
	// 82C41A84: 3B0AC278  addi r24, r10, -0x3d88
	ctx.r[24].s64 = ctx.r[10].s64 + -15752;
	pc = 0x82C41A88; continue 'dispatch;
            }
            0x82C41A88 => {
    //   block [0x82C41A88..0x82C41AA8)
	// 82C41A88: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41A8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41A90: 419A0018  beq cr6, 0x82c41aa8
	if ctx.cr[6].eq {
	pc = 0x82C41AA8; continue 'dispatch;
	}
	// 82C41A94: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C41A98: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41A9C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41AA0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41AA4: 41980008  blt cr6, 0x82c41aac
	if ctx.cr[6].lt {
	pc = 0x82C41AAC; continue 'dispatch;
	}
	pc = 0x82C41AA8; continue 'dispatch;
            }
            0x82C41AA8 => {
    //   block [0x82C41AA8..0x82C41AAC)
	// 82C41AA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41AAC; continue 'dispatch;
            }
            0x82C41AAC => {
    //   block [0x82C41AAC..0x82C41AD8)
	// 82C41AAC: 7D7A582E  lwzx r11, r26, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C41AB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41AB4: 419A01A8  beq cr6, 0x82c41c5c
	if ctx.cr[6].eq {
	pc = 0x82C41C5C; continue 'dispatch;
	}
	// 82C41AB8: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41AC0: 419A0018  beq cr6, 0x82c41ad8
	if ctx.cr[6].eq {
	pc = 0x82C41AD8; continue 'dispatch;
	}
	// 82C41AC4: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C41AC8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41ACC: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41AD0: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41AD4: 41980008  blt cr6, 0x82c41adc
	if ctx.cr[6].lt {
	pc = 0x82C41ADC; continue 'dispatch;
	}
	pc = 0x82C41AD8; continue 'dispatch;
            }
            0x82C41AD8 => {
    //   block [0x82C41AD8..0x82C41ADC)
	// 82C41AD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41ADC; continue 'dispatch;
            }
            0x82C41ADC => {
    //   block [0x82C41ADC..0x82C41B20)
	// 82C41ADC: 7C7A582E  lwzx r3, r26, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C41AE0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C41AE4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41AE8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41AEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41AF0: 4E800421  bctrl
	ctx.lr = 0x82C41AF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41AF4: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C41AF8: 2B090002  cmplwi cr6, r9, 2
	ctx.cr[6].compare_u32(ctx.r[9].u32, 2 as u32, &mut ctx.xer);
	// 82C41AFC: 409800AC  bge cr6, 0x82c41ba8
	if !ctx.cr[6].lt {
	pc = 0x82C41BA8; continue 'dispatch;
	}
	// 82C41B00: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C41B04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41B08: 419A0018  beq cr6, 0x82c41b20
	if ctx.cr[6].eq {
	pc = 0x82C41B20; continue 'dispatch;
	}
	// 82C41B0C: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C41B10: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41B14: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41B18: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41B1C: 41980008  blt cr6, 0x82c41b24
	if ctx.cr[6].lt {
	pc = 0x82C41B24; continue 'dispatch;
	}
            }
            0x82C41B20 => {
    //   block [0x82C41B20..0x82C41B24)
	// 82C41B20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41B24; continue 'dispatch;
            }
            0x82C41B24 => {
    //   block [0x82C41B24..0x82C41B48)
	// 82C41B24: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41B28: 7C7A582E  lwzx r3, r26, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C41B2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C41B30: 419A0018  beq cr6, 0x82c41b48
	if ctx.cr[6].eq {
	pc = 0x82C41B48; continue 'dispatch;
	}
	// 82C41B34: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C41B38: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C41B3C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41B40: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C41B44: 41980008  blt cr6, 0x82c41b4c
	if ctx.cr[6].lt {
	pc = 0x82C41B4C; continue 'dispatch;
	}
	pc = 0x82C41B48; continue 'dispatch;
            }
            0x82C41B48 => {
    //   block [0x82C41B48..0x82C41B4C)
	// 82C41B48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41B4C; continue 'dispatch;
            }
            0x82C41B4C => {
    //   block [0x82C41B4C..0x82C41B70)
	// 82C41B4C: 817F0024  lwz r11, 0x24(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C41B50: 7FDA502E  lwzx r30, r26, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C41B54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41B58: 419A0018  beq cr6, 0x82c41b70
	if ctx.cr[6].eq {
	pc = 0x82C41B70; continue 'dispatch;
	}
	// 82C41B5C: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C41B60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41B64: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41B68: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41B6C: 41980008  blt cr6, 0x82c41b74
	if ctx.cr[6].lt {
	pc = 0x82C41B74; continue 'dispatch;
	}
	pc = 0x82C41B70; continue 'dispatch;
            }
            0x82C41B70 => {
    //   block [0x82C41B70..0x82C41B74)
	// 82C41B70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41B74; continue 'dispatch;
            }
            0x82C41B74 => {
    //   block [0x82C41B74..0x82C41BA8)
	// 82C41B74: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41B78: 7FBA5A14  add r29, r26, r11
	ctx.r[29].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 82C41B7C: 839E0000  lwz r28, 0(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41B80: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41B84: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C41B88: 4E800421  bctrl
	ctx.lr = 0x82C41B8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41B8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C41B90: 811C0008  lwz r8, 8(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41B94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C41B98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C41B9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C41BA0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C41BA4: 4E800421  bctrl
	ctx.lr = 0x82C41BA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41BA8 => {
    //   block [0x82C41BA8..0x82C41C40)
	// 82C41BA8: 2B1B0007  cmplwi cr6, r27, 7
	ctx.cr[6].compare_u32(ctx.r[27].u32, 7 as u32, &mut ctx.xer);
	// 82C41BAC: 409800B0  bge cr6, 0x82c41c5c
	if !ctx.cr[6].lt {
	pc = 0x82C41C5C; continue 'dispatch;
	}
	// 82C41BB0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82C41BB4: 7C99B82E  lwzx r4, r25, r23
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 82C41BB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C41BBC: 4B5EB315  bl 0x8222ced0
	ctx.lr = 0x82C41BC0;
	sub_8222CED0(ctx, base);
	// 82C41BC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C41BC4: 4B648E15  bl 0x8228a9d8
	ctx.lr = 0x82C41BC8;
	sub_8228A9D8(ctx, base);
	// 82C41BC8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C41BCC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82C41BD0: 4B5D3209  bl 0x82214dd8
	ctx.lr = 0x82C41BD4;
	sub_82214DD8(ctx, base);
	// 82C41BD4: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41BD8: D3E10050  stfs f31, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C41BDC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C41BE0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C41BE4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82C41BE8: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C41BEC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41BF0: 4E800421  bctrl
	ctx.lr = 0x82C41BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41BF4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C41BF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C41BFC: 419A0060  beq cr6, 0x82c41c5c
	if ctx.cr[6].eq {
	pc = 0x82C41C5C; continue 'dispatch;
	}
	// 82C41C00: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C41C04: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C41C08: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C41C0C: 7D99C42E  lfsx f12, r25, r24
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[24].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C41C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41C14: FD6D07AE  fsel f11, f13, f30, f0
	ctx.f[11].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[0].f64 };
	// 82C41C18: ED5F5828  fsubs f10, f31, f11
	ctx.f[10].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 82C41C1C: FD2AFAEE  fsel f9, f10, f11, f31
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[31].f64 };
	// 82C41C20: EC290332  fmuls f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C41C24: D0210050  stfs f1, 0x50(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C41C28: 419A0018  beq cr6, 0x82c41c40
	if ctx.cr[6].eq {
	pc = 0x82C41C40; continue 'dispatch;
	}
	// 82C41C2C: 815F0038  lwz r10, 0x38(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 82C41C30: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C41C34: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 82C41C38: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C41C3C: 41980008  blt cr6, 0x82c41c44
	if ctx.cr[6].lt {
	pc = 0x82C41C44; continue 'dispatch;
	}
            }
            0x82C41C40 => {
    //   block [0x82C41C40..0x82C41C44)
	// 82C41C40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C41C44; continue 'dispatch;
            }
            0x82C41C44 => {
    //   block [0x82C41C44..0x82C41C5C)
	// 82C41C44: 7C7A582E  lwzx r3, r26, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C41C48: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C41C4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41C50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41C54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41C58: 4E800421  bctrl
	ctx.lr = 0x82C41C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41C5C => {
    //   block [0x82C41C5C..0x82C41C74)
	// 82C41C5C: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 82C41C60: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C41C64: 3B390004  addi r25, r25, 4
	ctx.r[25].s64 = ctx.r[25].s64 + 4;
	// 82C41C68: 3B5A0008  addi r26, r26, 8
	ctx.r[26].s64 = ctx.r[26].s64 + 8;
	// 82C41C6C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C41C70: 4198FE18  blt cr6, 0x82c41a88
	if ctx.cr[6].lt {
	pc = 0x82C41A88; continue 'dispatch;
	}
	pc = 0x82C41C74; continue 'dispatch;
            }
            0x82C41C74 => {
    //   block [0x82C41C74..0x82C41C84)
	// 82C41C74: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C41C78: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82C41C7C: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82C41C80: 480677C0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C41C84 => {
    //   block [0x82C41C84..0x82C41CA4)
	// 82C41C84: 4BFCCFF5  bl 0x82c0ec78
	ctx.lr = 0x82C41C88;
	sub_82C0EC78(ctx, base);
	// 82C41C88: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C41C8C: 7D435A14  add r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 + ctx.r[11].u64;
	// 82C41C90: 915F004C  stw r10, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[10].u32 ) };
	// 82C41C94: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C41C98: CBC1FF98  lfd f30, -0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82C41C9C: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82C41CA0: 480677A0  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C41CA4 => {
    //   block [0x82C41CA4..0x82C41CBC)
	// 82C41CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C41CA8: 997F0051  stb r11, 0x51(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(81 as u32), ctx.r[11].u8 ) };
	// 82C41CAC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82C41CB0: CBC1FF98  lfd f30, -0x68(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 82C41CB4: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 82C41CB8: 48067788  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C41CC0 size=396
    let mut pc: u32 = 0x82C41CC0;
    'dispatch: loop {
        match pc {
            0x82C41CC0 => {
    //   block [0x82C41CC0..0x82C41D28)
	// 82C41CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C41CC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C41CCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C41CD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C41CD4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C41CD8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C41CDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41CE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41CE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41CE8: 4E800421  bctrl
	ctx.lr = 0x82C41CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41CEC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C41CF0: 41980038  blt cr6, 0x82c41d28
	if ctx.cr[6].lt {
	pc = 0x82C41D28; continue 'dispatch;
	}
	// 82C41CF4: 409A0118  bne cr6, 0x82c41e0c
	if !ctx.cr[6].eq {
	pc = 0x82C41E0C; continue 'dispatch;
	}
	// 82C41CF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41D00: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41D04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41D08: 4E800421  bctrl
	ctx.lr = 0x82C41D0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41D0C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C41D10: 41980070  blt cr6, 0x82c41d80
	if ctx.cr[6].lt {
	pc = 0x82C41D80; continue 'dispatch;
	}
	// 82C41D14: 409A00F8  bne cr6, 0x82c41e0c
	if !ctx.cr[6].eq {
	pc = 0x82C41E0C; continue 'dispatch;
	}
	// 82C41D18: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C41D1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41D20: 419A0110  beq cr6, 0x82c41e30
	if ctx.cr[6].eq {
	pc = 0x82C41E30; continue 'dispatch;
	}
	// 82C41D24: 48000024  b 0x82c41d48
	pc = 0x82C41D48; continue 'dispatch;
            }
            0x82C41D28 => {
    //   block [0x82C41D28..0x82C41D48)
	// 82C41D28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41D2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41D30: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C41D34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41D38: 4E800421  bctrl
	ctx.lr = 0x82C41D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41D3C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C41D40: 41980040  blt cr6, 0x82c41d80
	if ctx.cr[6].lt {
	pc = 0x82C41D80; continue 'dispatch;
	}
	// 82C41D44: 409A00C8  bne cr6, 0x82c41e0c
	if !ctx.cr[6].eq {
	pc = 0x82C41E0C; continue 'dispatch;
	}
            }
            0x82C41D48 => {
    //   block [0x82C41D48..0x82C41D80)
	// 82C41D48: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C41D4C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41D50: 4BFDFB09  bl 0x82c21858
	ctx.lr = 0x82C41D54;
	sub_82C21858(ctx, base);
	// 82C41D54: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C41D58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41D5C: 4BFFE03D  bl 0x82c3fd98
	ctx.lr = 0x82C41D60;
	sub_82C3FD98(ctx, base);
	// 82C41D60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C41D64: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C41D68: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C41D6C: 4BFF68BD  bl 0x82c38628
	ctx.lr = 0x82C41D70;
	sub_82C38628(ctx, base);
	// 82C41D70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41D74: 4BFE8C7D  bl 0x82c2a9f0
	ctx.lr = 0x82C41D78;
	sub_82C2A9F0(ctx, base);
	// 82C41D78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41D7C: 480000B8  b 0x82c41e34
	pc = 0x82C41E34; continue 'dispatch;
            }
            0x82C41D80 => {
    //   block [0x82C41D80..0x82C41E04)
	// 82C41D80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C41D84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41D88: 48005581  bl 0x82c47308
	ctx.lr = 0x82C41D8C;
	sub_82C47308(ctx, base);
	// 82C41D8C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C41D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41D94: 4BFFE005  bl 0x82c3fd98
	ctx.lr = 0x82C41D98;
	sub_82C3FD98(ctx, base);
	// 82C41D98: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C41D9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41DA0: 419A0064  beq cr6, 0x82c41e04
	if ctx.cr[6].eq {
	pc = 0x82C41E04; continue 'dispatch;
	}
	// 82C41DA4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C41DA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C41DAC: 392AC380  addi r9, r10, -0x3c80
	ctx.r[9].s64 = ctx.r[10].s64 + -15488;
	// 82C41DB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C41DB4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C41DB8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C41DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C41DC0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C41DC4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C41DC8: 48003CE1  bl 0x82c45aa8
	ctx.lr = 0x82C41DCC;
	sub_82C45AA8(ctx, base);
	// 82C41DCC: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C41DD0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C41DD4: 419A0040  beq cr6, 0x82c41e14
	if ctx.cr[6].eq {
	pc = 0x82C41E14; continue 'dispatch;
	}
	// 82C41DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41DDC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C41DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C41DE4: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C41DE8: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C41DEC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C41DF0: 4E800421  bctrl
	ctx.lr = 0x82C41DF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C41DF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C41DF8: 4BFC3A01  bl 0x82c057f8
	ctx.lr = 0x82C41DFC;
	sub_82C057F8(ctx, base);
	// 82C41DFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C41E00: 48000B19  bl 0x82c42918
	ctx.lr = 0x82C41E04;
	sub_82C42918(ctx, base);
            }
            0x82C41E04 => {
    //   block [0x82C41E04..0x82C41E0C)
	// 82C41E04: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41E08: 4BFDA1B9  bl 0x82c1bfc0
	ctx.lr = 0x82C41E0C;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C41E0C; continue 'dispatch;
            }
            0x82C41E0C => {
    //   block [0x82C41E0C..0x82C41E14)
	// 82C41E0C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C41E10: 48000024  b 0x82c41e34
	pc = 0x82C41E34; continue 'dispatch;
            }
            0x82C41E14 => {
    //   block [0x82C41E14..0x82C41E30)
	// 82C41E14: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C41E18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C41E1C: 4BFF680D  bl 0x82c38628
	ctx.lr = 0x82C41E20;
	sub_82C38628(ctx, base);
	// 82C41E20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C41E24: 48000AF5  bl 0x82c42918
	ctx.lr = 0x82C41E28;
	sub_82C42918(ctx, base);
	// 82C41E28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C41E2C: 4BFDA195  bl 0x82c1bfc0
	ctx.lr = 0x82C41E30;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C41E30; continue 'dispatch;
            }
            0x82C41E30 => {
    //   block [0x82C41E30..0x82C41E34)
	// 82C41E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C41E34; continue 'dispatch;
            }
            0x82C41E34 => {
    //   block [0x82C41E34..0x82C41E4C)
	// 82C41E34: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C41E38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C41E3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C41E40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C41E44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C41E48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C41E50 size=16
    let mut pc: u32 = 0x82C41E50;
    'dispatch: loop {
        match pc {
            0x82C41E50 => {
    //   block [0x82C41E50..0x82C41E60)
	// 82C41E50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C41E54: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C41E58: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C41E5C: 4BFFFE64  b 0x82c41cc0
	sub_82C41CC0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41E60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C41E60 size=12
    let mut pc: u32 = 0x82C41E60;
    'dispatch: loop {
        match pc {
            0x82C41E60 => {
    //   block [0x82C41E60..0x82C41E6C)
	// 82C41E60: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C41E64: 386B4FA4  addi r3, r11, 0x4fa4
	ctx.r[3].s64 = ctx.r[11].s64 + 20388;
	// 82C41E68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41E70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C41E70 size=28
    let mut pc: u32 = 0x82C41E70;
    'dispatch: loop {
        match pc {
            0x82C41E70 => {
    //   block [0x82C41E70..0x82C41E8C)
	// 82C41E70: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C41E74: 419A0018  beq cr6, 0x82c41e8c
	if ctx.cr[6].eq {
		sub_82C41E8C(ctx, base);
		return;
	}
	// 82C41E78: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82C41E7C: 409A0010  bne cr6, 0x82c41e8c
	if !ctx.cr[6].eq {
		sub_82C41E8C(ctx, base);
		return;
	}
	// 82C41E80: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C41E84: 386B4FA0  addi r3, r11, 0x4fa0
	ctx.r[3].s64 = ctx.r[11].s64 + 20384;
	// 82C41E88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41E8C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C41E8C size=12
    let mut pc: u32 = 0x82C41E8C;
    'dispatch: loop {
        match pc {
            0x82C41E8C => {
    //   block [0x82C41E8C..0x82C41E98)
	// 82C41E8C: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C41E90: 386B4F9C  addi r3, r11, 0x4f9c
	ctx.r[3].s64 = ctx.r[11].s64 + 20380;
	// 82C41E94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41E98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C41E98 size=176
    let mut pc: u32 = 0x82C41E98;
    'dispatch: loop {
        match pc {
            0x82C41E98 => {
    //   block [0x82C41E98..0x82C41EC0)
	// 82C41E98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41E9C: 48067569  bl 0x82ca9404
	ctx.lr = 0x82C41EA0;
	sub_82CA93D0(ctx, base);
	// 82C41EA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C41EA4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C41EA8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C41EAC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C41EB0: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C41EB4: 419A0088  beq cr6, 0x82c41f3c
	if ctx.cr[6].eq {
	pc = 0x82C41F3C; continue 'dispatch;
	}
	// 82C41EB8: 3BFC0008  addi r31, r28, 8
	ctx.r[31].s64 = ctx.r[28].s64 + 8;
	// 82C41EBC: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	pc = 0x82C41EC0; continue 'dispatch;
            }
            0x82C41EC0 => {
    //   block [0x82C41EC0..0x82C41EF8)
	// 82C41EC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41EC4: 395EFFFC  addi r10, r30, -4
	ctx.r[10].s64 = ctx.r[30].s64 + -4;
	// 82C41EC8: 393FFFFC  addi r9, r31, -4
	ctx.r[9].s64 = ctx.r[31].s64 + -4;
	// 82C41ECC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C41ED0: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C41ED4: 419A0050  beq cr6, 0x82c41f24
	if ctx.cr[6].eq {
	pc = 0x82C41F24; continue 'dispatch;
	}
	// 82C41ED8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41EDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41EE0: 419A0018  beq cr6, 0x82c41ef8
	if ctx.cr[6].eq {
	pc = 0x82C41EF8; continue 'dispatch;
	}
	// 82C41EE4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C41EE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41EEC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41EF0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41EF4: 4E800421  bctrl
	ctx.lr = 0x82C41EF8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41EF8 => {
    //   block [0x82C41EF8..0x82C41F14)
	// 82C41EF8: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41EFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41F00: 419A0014  beq cr6, 0x82c41f14
	if ctx.cr[6].eq {
	pc = 0x82C41F14; continue 'dispatch;
	}
	// 82C41F04: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41F08: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41F0C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41F10: 4E800421  bctrl
	ctx.lr = 0x82C41F14;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41F14 => {
    //   block [0x82C41F14..0x82C41F24)
	// 82C41F14: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41F18: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C41F1C: 815EFFFC  lwz r10, -4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C41F20: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C41F24; continue 'dispatch;
            }
            0x82C41F24 => {
    //   block [0x82C41F24..0x82C41F3C)
	// 82C41F24: 3BBD000C  addi r29, r29, 0xc
	ctx.r[29].s64 = ctx.r[29].s64 + 12;
	// 82C41F28: 3B9C000C  addi r28, r28, 0xc
	ctx.r[28].s64 = ctx.r[28].s64 + 12;
	// 82C41F2C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C41F30: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C41F34: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C41F38: 409AFF88  bne cr6, 0x82c41ec0
	if !ctx.cr[6].eq {
	pc = 0x82C41EC0; continue 'dispatch;
	}
	pc = 0x82C41F3C; continue 'dispatch;
            }
            0x82C41F3C => {
    //   block [0x82C41F3C..0x82C41F48)
	// 82C41F3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C41F40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C41F44: 48067510  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C41F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C41F48 size=208
    let mut pc: u32 = 0x82C41F48;
    'dispatch: loop {
        match pc {
            0x82C41F48 => {
    //   block [0x82C41F48..0x82C41F70)
	// 82C41F48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C41F4C: 480674B9  bl 0x82ca9404
	ctx.lr = 0x82C41F50;
	sub_82CA93D0(ctx, base);
	// 82C41F50: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C41F54: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C41F58: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C41F5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C41F60: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C41F64: 419A00A8  beq cr6, 0x82c4200c
	if ctx.cr[6].eq {
	pc = 0x82C4200C; continue 'dispatch;
	}
	// 82C41F68: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 82C41F6C: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	pc = 0x82C41F70; continue 'dispatch;
            }
            0x82C41F70 => {
    //   block [0x82C41F70..0x82C41FC0)
	// 82C41F70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41F74: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 82C41F78: 393EFFFC  addi r9, r30, -4
	ctx.r[9].s64 = ctx.r[30].s64 + -4;
	// 82C41F7C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C41F80: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C41F84: C01FFFF0  lfs f0, -0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C41F88: D01EFFF0  stfs f0, -0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C41F8C: C1BFFFF4  lfs f13, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C41F90: D1BEFFF4  stfs f13, -0xc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C41F94: C19FFFF8  lfs f12, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C41F98: D19EFFF8  stfs f12, -8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C41F9C: 419A0050  beq cr6, 0x82c41fec
	if ctx.cr[6].eq {
	pc = 0x82C41FEC; continue 'dispatch;
	}
	// 82C41FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C41FA8: 419A0018  beq cr6, 0x82c41fc0
	if ctx.cr[6].eq {
	pc = 0x82C41FC0; continue 'dispatch;
	}
	// 82C41FAC: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C41FB0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FB4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41FBC: 4E800421  bctrl
	ctx.lr = 0x82C41FC0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41FC0 => {
    //   block [0x82C41FC0..0x82C41FDC)
	// 82C41FC0: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C41FC8: 419A0014  beq cr6, 0x82c41fdc
	if ctx.cr[6].eq {
	pc = 0x82C41FDC; continue 'dispatch;
	}
	// 82C41FCC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FD0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41FD4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C41FD8: 4E800421  bctrl
	ctx.lr = 0x82C41FDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C41FDC => {
    //   block [0x82C41FDC..0x82C41FEC)
	// 82C41FDC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C41FE0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C41FE4: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C41FE8: 915EFFFC  stw r10, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C41FEC; continue 'dispatch;
            }
            0x82C41FEC => {
    //   block [0x82C41FEC..0x82C4200C)
	// 82C41FEC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C41FF0: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82C41FF4: 3B9C001C  addi r28, r28, 0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + 28;
	// 82C41FF8: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C41FFC: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C42000: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C42004: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C42008: 409AFF68  bne cr6, 0x82c41f70
	if !ctx.cr[6].eq {
	pc = 0x82C41F70; continue 'dispatch;
	}
	pc = 0x82C4200C; continue 'dispatch;
            }
            0x82C4200C => {
    //   block [0x82C4200C..0x82C42018)
	// 82C4200C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42010: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42014: 48067440  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42018 size=176
    let mut pc: u32 = 0x82C42018;
    'dispatch: loop {
        match pc {
            0x82C42018 => {
    //   block [0x82C42018..0x82C42040)
	// 82C42018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4201C: 480673E9  bl 0x82ca9404
	ctx.lr = 0x82C42020;
	sub_82CA93D0(ctx, base);
	// 82C42020: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42024: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C42028: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C4202C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C42030: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C42034: 419A0088  beq cr6, 0x82c420bc
	if ctx.cr[6].eq {
	pc = 0x82C420BC; continue 'dispatch;
	}
	// 82C42038: 3BDC0008  addi r30, r28, 8
	ctx.r[30].s64 = ctx.r[28].s64 + 8;
	// 82C4203C: 3BFD0008  addi r31, r29, 8
	ctx.r[31].s64 = ctx.r[29].s64 + 8;
	pc = 0x82C42040; continue 'dispatch;
            }
            0x82C42040 => {
    //   block [0x82C42040..0x82C42088)
	// 82C42040: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 82C42044: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 82C42048: 3B9CFFF4  addi r28, r28, -0xc
	ctx.r[28].s64 = ctx.r[28].s64 + -12;
	// 82C4204C: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 82C42050: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82C42054: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42058: 393EFFFC  addi r9, r30, -4
	ctx.r[9].s64 = ctx.r[30].s64 + -4;
	// 82C4205C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C42060: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C42064: 419A0050  beq cr6, 0x82c420b4
	if ctx.cr[6].eq {
	pc = 0x82C420B4; continue 'dispatch;
	}
	// 82C42068: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4206C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42070: 419A0018  beq cr6, 0x82c42088
	if ctx.cr[6].eq {
	pc = 0x82C42088; continue 'dispatch;
	}
	// 82C42074: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C42078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4207C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42080: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42084: 4E800421  bctrl
	ctx.lr = 0x82C42088;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C42088 => {
    //   block [0x82C42088..0x82C420A4)
	// 82C42088: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4208C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42090: 419A0014  beq cr6, 0x82c420a4
	if ctx.cr[6].eq {
	pc = 0x82C420A4; continue 'dispatch;
	}
	// 82C42094: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42098: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4209C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C420A0: 4E800421  bctrl
	ctx.lr = 0x82C420A4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C420A4 => {
    //   block [0x82C420A4..0x82C420B4)
	// 82C420A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C420A8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C420AC: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C420B0: 915EFFFC  stw r10, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C420B4; continue 'dispatch;
            }
            0x82C420B4 => {
    //   block [0x82C420B4..0x82C420BC)
	// 82C420B4: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C420B8: 409AFF88  bne cr6, 0x82c42040
	if !ctx.cr[6].eq {
	pc = 0x82C42040; continue 'dispatch;
	}
	pc = 0x82C420BC; continue 'dispatch;
            }
            0x82C420BC => {
    //   block [0x82C420BC..0x82C420C8)
	// 82C420BC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C420C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C420C4: 48067390  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C420C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C420C8 size=208
    let mut pc: u32 = 0x82C420C8;
    'dispatch: loop {
        match pc {
            0x82C420C8 => {
    //   block [0x82C420C8..0x82C420F0)
	// 82C420C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C420CC: 48067339  bl 0x82ca9404
	ctx.lr = 0x82C420D0;
	sub_82CA93D0(ctx, base);
	// 82C420D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C420D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C420D8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C420DC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C420E0: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C420E4: 419A00A8  beq cr6, 0x82c4218c
	if ctx.cr[6].eq {
	pc = 0x82C4218C; continue 'dispatch;
	}
	// 82C420E8: 3BDC0014  addi r30, r28, 0x14
	ctx.r[30].s64 = ctx.r[28].s64 + 20;
	// 82C420EC: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	pc = 0x82C420F0; continue 'dispatch;
            }
            0x82C420F0 => {
    //   block [0x82C420F0..0x82C42150)
	// 82C420F0: 3BBDFFE4  addi r29, r29, -0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + -28;
	// 82C420F4: 3B9CFFE4  addi r28, r28, -0x1c
	ctx.r[28].s64 = ctx.r[28].s64 + -28;
	// 82C420F8: 3BFFFFE4  addi r31, r31, -0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + -28;
	// 82C420FC: 3BDEFFE4  addi r30, r30, -0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + -28;
	// 82C42100: 397FFFFC  addi r11, r31, -4
	ctx.r[11].s64 = ctx.r[31].s64 + -4;
	// 82C42104: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42108: 393EFFFC  addi r9, r30, -4
	ctx.r[9].s64 = ctx.r[30].s64 + -4;
	// 82C4210C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C42110: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C42114: C01FFFF0  lfs f0, -0x10(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C42118: D01EFFF0  stfs f0, -0x10(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C4211C: C1BFFFF4  lfs f13, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C42120: D1BEFFF4  stfs f13, -0xc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C42124: C19FFFF8  lfs f12, -8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C42128: D19EFFF8  stfs f12, -8(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C4212C: 419A0050  beq cr6, 0x82c4217c
	if ctx.cr[6].eq {
	pc = 0x82C4217C; continue 'dispatch;
	}
	// 82C42130: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42138: 419A0018  beq cr6, 0x82c42150
	if ctx.cr[6].eq {
	pc = 0x82C42150; continue 'dispatch;
	}
	// 82C4213C: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C42140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42144: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42148: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4214C: 4E800421  bctrl
	ctx.lr = 0x82C42150;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C42150 => {
    //   block [0x82C42150..0x82C4216C)
	// 82C42150: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42154: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42158: 419A0014  beq cr6, 0x82c4216c
	if ctx.cr[6].eq {
	pc = 0x82C4216C; continue 'dispatch;
	}
	// 82C4215C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42160: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42164: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42168: 4E800421  bctrl
	ctx.lr = 0x82C4216C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4216C => {
    //   block [0x82C4216C..0x82C4217C)
	// 82C4216C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42170: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C42174: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C42178: 915EFFFC  stw r10, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C4217C; continue 'dispatch;
            }
            0x82C4217C => {
    //   block [0x82C4217C..0x82C4218C)
	// 82C4217C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42180: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C42184: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C42188: 409AFF68  bne cr6, 0x82c420f0
	if !ctx.cr[6].eq {
	pc = 0x82C420F0; continue 'dispatch;
	}
	pc = 0x82C4218C; continue 'dispatch;
            }
            0x82C4218C => {
    //   block [0x82C4218C..0x82C42198)
	// 82C4218C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42190: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42194: 480672C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42198 size=92
    let mut pc: u32 = 0x82C42198;
    'dispatch: loop {
        match pc {
            0x82C42198 => {
    //   block [0x82C42198..0x82C421DC)
	// 82C42198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4219C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C421A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C421A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C421A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C421AC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C421B0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C421B4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C421B8: 394BC330  addi r10, r11, -0x3cd0
	ctx.r[10].s64 = ctx.r[11].s64 + -15568;
	// 82C421BC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C421C0: 4BFC4079  bl 0x82c06238
	ctx.lr = 0x82C421C4;
	sub_82C06238(ctx, base);
	// 82C421C4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C421C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C421CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C421D0: 419A000C  beq cr6, 0x82c421dc
	if ctx.cr[6].eq {
	pc = 0x82C421DC; continue 'dispatch;
	}
	// 82C421D4: 4BC035DD  bl 0x828457b0
	ctx.lr = 0x82C421D8;
	sub_828457B0(ctx, base);
	// 82C421D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C421DC; continue 'dispatch;
            }
            0x82C421DC => {
    //   block [0x82C421DC..0x82C421F4)
	// 82C421DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C421E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C421E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C421E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C421EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C421F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C421F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C421F8 size=136
    let mut pc: u32 = 0x82C421F8;
    'dispatch: loop {
        match pc {
            0x82C421F8 => {
    //   block [0x82C421F8..0x82C4225C)
	// 82C421F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C421FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42200: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C42204: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4220C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C42210: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42214: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42218: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C4221C: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C42220: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C42224: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C42228: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4222C: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C42230: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C42234: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C42238: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C4223C: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C42240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42244: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82C42248: 419A0014  beq cr6, 0x82c4225c
	if ctx.cr[6].eq {
	pc = 0x82C4225C; continue 'dispatch;
	}
	// 82C4224C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42250: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42254: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42258: 4E800421  bctrl
	ctx.lr = 0x82C4225C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4225C => {
    //   block [0x82C4225C..0x82C42280)
	// 82C4225C: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C42260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42264: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82C42268: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4226C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42274: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C42278: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4227C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42280 size=120
    let mut pc: u32 = 0x82C42280;
    'dispatch: loop {
        match pc {
            0x82C42280 => {
    //   block [0x82C42280..0x82C422D4)
	// 82C42280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42288: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4228C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42290: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42294: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C42298: 419A003C  beq cr6, 0x82c422d4
	if ctx.cr[6].eq {
	pc = 0x82C422D4; continue 'dispatch;
	}
	// 82C4229C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82C422A0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82C422A4: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 82C422A8: 4098002C  bge cr6, 0x82c422d4
	if !ctx.cr[6].lt {
	pc = 0x82C422D4; continue 'dispatch;
	}
	// 82C422AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C422B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C422B4: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82C422B8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C422BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C422C0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C422C4: 4B6AFB5D  bl 0x822f1e20
	ctx.lr = 0x82C422C8;
	sub_822F1E20(ctx, base);
	// 82C422C8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82C422CC: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82C422D0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82C422D4; continue 'dispatch;
            }
            0x82C422D4 => {
    //   block [0x82C422D4..0x82C422F8)
	// 82C422D4: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C422D8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C422DC: 5563103A  slwi r3, r11, 2
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C422E0: 4B5DCF79  bl 0x8221f258
	ctx.lr = 0x82C422E4;
	sub_8221F258(ctx, base);
	// 82C422E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C422E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C422EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C422F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C422F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C422F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C422F8 size=160
    let mut pc: u32 = 0x82C422F8;
    'dispatch: loop {
        match pc {
            0x82C422F8 => {
    //   block [0x82C422F8..0x82C42320)
	// 82C422F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C422FC: 48067109  bl 0x82ca9404
	ctx.lr = 0x82C42300;
	sub_82CA93D0(ctx, base);
	// 82C42300: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42304: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C42308: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C4230C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C42310: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C42314: 419A007C  beq cr6, 0x82c42390
	if ctx.cr[6].eq {
	pc = 0x82C42390; continue 'dispatch;
	}
	// 82C42318: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 82C4231C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	pc = 0x82C42320; continue 'dispatch;
            }
            0x82C42320 => {
    //   block [0x82C42320..0x82C42354)
	// 82C42320: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42324: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 82C42328: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4232C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C42330: 419A0050  beq cr6, 0x82c42380
	if ctx.cr[6].eq {
	pc = 0x82C42380; continue 'dispatch;
	}
	// 82C42334: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4233C: 419A0018  beq cr6, 0x82c42354
	if ctx.cr[6].eq {
	pc = 0x82C42354; continue 'dispatch;
	}
	// 82C42340: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C42344: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42348: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4234C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42350: 4E800421  bctrl
	ctx.lr = 0x82C42354;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C42354 => {
    //   block [0x82C42354..0x82C42370)
	// 82C42354: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42358: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4235C: 419A0014  beq cr6, 0x82c42370
	if ctx.cr[6].eq {
	pc = 0x82C42370; continue 'dispatch;
	}
	// 82C42360: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42364: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42368: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4236C: 4E800421  bctrl
	ctx.lr = 0x82C42370;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C42370 => {
    //   block [0x82C42370..0x82C42380)
	// 82C42370: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42374: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C42378: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4237C: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C42380; continue 'dispatch;
            }
            0x82C42380 => {
    //   block [0x82C42380..0x82C42390)
	// 82C42380: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C42384: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C42388: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C4238C: 409AFF94  bne cr6, 0x82c42320
	if !ctx.cr[6].eq {
	pc = 0x82C42320; continue 'dispatch;
	}
	pc = 0x82C42390; continue 'dispatch;
            }
            0x82C42390 => {
    //   block [0x82C42390..0x82C42398)
	// 82C42390: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42394: 480670C0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C42398 size=192
    let mut pc: u32 = 0x82C42398;
    'dispatch: loop {
        match pc {
            0x82C42398 => {
    //   block [0x82C42398..0x82C423C0)
	// 82C42398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4239C: 48067069  bl 0x82ca9404
	ctx.lr = 0x82C423A0;
	sub_82CA93D0(ctx, base);
	// 82C423A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C423A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C423A8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C423AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C423B0: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C423B4: 419A009C  beq cr6, 0x82c42450
	if ctx.cr[6].eq {
	pc = 0x82C42450; continue 'dispatch;
	}
	// 82C423B8: 3B9E0010  addi r28, r30, 0x10
	ctx.r[28].s64 = ctx.r[30].s64 + 16;
	// 82C423BC: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	pc = 0x82C423C0; continue 'dispatch;
            }
            0x82C423C0 => {
    //   block [0x82C423C0..0x82C4240C)
	// 82C423C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C423C4: 395FFFFC  addi r10, r31, -4
	ctx.r[10].s64 = ctx.r[31].s64 + -4;
	// 82C423C8: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C423CC: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C423D0: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C423D4: D01FFFF0  stfs f0, -0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82C423D8: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C423DC: D1BFFFF4  stfs f13, -0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 82C423E0: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C423E4: D19FFFF8  stfs f12, -8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82C423E8: 419A0050  beq cr6, 0x82c42438
	if ctx.cr[6].eq {
	pc = 0x82C42438; continue 'dispatch;
	}
	// 82C423EC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C423F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C423F4: 419A0018  beq cr6, 0x82c4240c
	if ctx.cr[6].eq {
	pc = 0x82C4240C; continue 'dispatch;
	}
	// 82C423F8: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82C423FC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42400: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42404: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42408: 4E800421  bctrl
	ctx.lr = 0x82C4240C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4240C => {
    //   block [0x82C4240C..0x82C42428)
	// 82C4240C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42410: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42414: 419A0014  beq cr6, 0x82c42428
	if ctx.cr[6].eq {
	pc = 0x82C42428; continue 'dispatch;
	}
	// 82C42418: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4241C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42420: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42424: 4E800421  bctrl
	ctx.lr = 0x82C42428;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C42428 => {
    //   block [0x82C42428..0x82C42438)
	// 82C42428: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4242C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C42430: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42434: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	pc = 0x82C42438; continue 'dispatch;
            }
            0x82C42438 => {
    //   block [0x82C42438..0x82C42450)
	// 82C42438: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4243C: 3BBD001C  addi r29, r29, 0x1c
	ctx.r[29].s64 = ctx.r[29].s64 + 28;
	// 82C42440: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C42444: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C42448: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C4244C: 409AFF74  bne cr6, 0x82c423c0
	if !ctx.cr[6].eq {
	pc = 0x82C423C0; continue 'dispatch;
	}
	pc = 0x82C42450; continue 'dispatch;
            }
            0x82C42450 => {
    //   block [0x82C42450..0x82C42458)
	// 82C42450: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42454: 48067000  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42458(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42458 size=84
    let mut pc: u32 = 0x82C42458;
    'dispatch: loop {
        match pc {
            0x82C42458 => {
    //   block [0x82C42458..0x82C42498)
	// 82C42458: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4245C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42460: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42464: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42468: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C4246C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C42470: 388A4F9C  addi r4, r10, 0x4f9c
	ctx.r[4].s64 = ctx.r[10].s64 + 20380;
	// 82C42474: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42478: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C4247C: 4E800421  bctrl
	ctx.lr = 0x82C42480;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42480: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42484: 409A0014  bne cr6, 0x82c42498
	if !ctx.cr[6].eq {
	pc = 0x82C42498; continue 'dispatch;
	}
	// 82C42488: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4248C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42490: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42494: 4E800020  blr
	return;
            }
            0x82C42498 => {
    //   block [0x82C42498..0x82C424AC)
	// 82C42498: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4249C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C424A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C424A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C424A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C424B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C424B0 size=144
    let mut pc: u32 = 0x82C424B0;
    'dispatch: loop {
        match pc {
            0x82C424B0 => {
    //   block [0x82C424B0..0x82C424E8)
	// 82C424B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C424B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C424B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C424BC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C424C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C424C4: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C424C8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C424CC: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C424D0: 388A4F9C  addi r4, r10, 0x4f9c
	ctx.r[4].s64 = ctx.r[10].s64 + 20380;
	// 82C424D4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C424D8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C424DC: 4E800421  bctrl
	ctx.lr = 0x82C424E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C424E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C424E4: 409A001C  bne cr6, 0x82c42500
	if !ctx.cr[6].eq {
	pc = 0x82C42500; continue 'dispatch;
	}
            }
            0x82C424E8 => {
    //   block [0x82C424E8..0x82C42500)
	// 82C424E8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C424EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C424F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C424F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C424F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C424FC: 4E800020  blr
	return;
            }
            0x82C42500 => {
    //   block [0x82C42500..0x82C42540)
	// 82C42500: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C42504: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C42508: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C4250C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42510: 4BFF6501  bl 0x82c38a10
	ctx.lr = 0x82C42514;
	sub_82C38A10(ctx, base);
	// 82C42514: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42518: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C4251C: 419AFFCC  beq cr6, 0x82c424e8
	if ctx.cr[6].eq {
	pc = 0x82C424E8; continue 'dispatch;
	}
	// 82C42520: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42524: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C42528: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C4252C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C42530: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42534: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42538: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4253C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42540 size=76
    let mut pc: u32 = 0x82C42540;
    'dispatch: loop {
        match pc {
            0x82C42540 => {
    //   block [0x82C42540..0x82C42578)
	// 82C42540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42548: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4254C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C42550: 4B5DCD09  bl 0x8221f258
	ctx.lr = 0x82C42554;
	sub_8221F258(ctx, base);
	// 82C42554: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42558: 419A0020  beq cr6, 0x82c42578
	if ctx.cr[6].eq {
	pc = 0x82C42578; continue 'dispatch;
	}
	// 82C4255C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42560: 394BC330  addi r10, r11, -0x3cd0
	ctx.r[10].s64 = ctx.r[11].s64 + -15568;
	// 82C42564: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C42568: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4256C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42570: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42574: 4E800020  blr
	return;
            }
            0x82C42578 => {
    //   block [0x82C42578..0x82C4258C)
	// 82C42578: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4257C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42580: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42584: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42590 size=112
    let mut pc: u32 = 0x82C42590;
    'dispatch: loop {
        match pc {
            0x82C42590 => {
    //   block [0x82C42590..0x82C425E4)
	// 82C42590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42598: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C4259C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C425A0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C425A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C425A8: 419A003C  beq cr6, 0x82c425e4
	if ctx.cr[6].eq {
	pc = 0x82C425E4; continue 'dispatch;
	}
	// 82C425AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82C425B0: 7D4BFB96  divwu r10, r11, r31
	ctx.r[10].u32 = ctx.r[11].u32 / ctx.r[31].u32;
	// 82C425B4: 2B0A001C  cmplwi cr6, r10, 0x1c
	ctx.cr[6].compare_u32(ctx.r[10].u32, 28 as u32, &mut ctx.xer);
	// 82C425B8: 4098002C  bge cr6, 0x82c425e4
	if !ctx.cr[6].lt {
	pc = 0x82C425E4; continue 'dispatch;
	}
	// 82C425BC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C425C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C425C4: 392B1714  addi r9, r11, 0x1714
	ctx.r[9].s64 = ctx.r[11].s64 + 5908;
	// 82C425C8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C425CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C425D0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C425D4: 4B6AF84D  bl 0x822f1e20
	ctx.lr = 0x82C425D8;
	sub_822F1E20(ctx, base);
	// 82C425D8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82C425DC: 38E81708  addi r7, r8, 0x1708
	ctx.r[7].s64 = ctx.r[8].s64 + 5896;
	// 82C425E0: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	pc = 0x82C425E4; continue 'dispatch;
            }
            0x82C425E4 => {
    //   block [0x82C425E4..0x82C42600)
	// 82C425E4: 1C7F001C  mulli r3, r31, 0x1c
	ctx.r[3].s32 = ((ctx.r[31].s32 as i64 * 28 as i64) as i32);
	ctx.r[3].s64 = ctx.r[3].s32 as i64;
	// 82C425E8: 4B5DCC71  bl 0x8221f258
	ctx.lr = 0x82C425EC;
	sub_8221F258(ctx, base);
	// 82C425EC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C425F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C425F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C425F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C425FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C42600 size=88
    let mut pc: u32 = 0x82C42600;
    'dispatch: loop {
        match pc {
            0x82C42600 => {
    //   block [0x82C42600..0x82C42618)
	// 82C42600: E9640000  ld r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	// 82C42604: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82C42608: 8121FFF0  lwz r9, -0x10(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 82C4260C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C42610: 409A0008  bne cr6, 0x82c42618
	if !ctx.cr[6].eq {
	pc = 0x82C42618; continue 'dispatch;
	}
	// 82C42614: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C42618; continue 'dispatch;
            }
            0x82C42618 => {
    //   block [0x82C42618..0x82C42644)
	// 82C42618: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4261C: 8141FFF4  lwz r10, -0xc(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 82C42620: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C42624: 7CE55A14  add r7, r5, r11
	ctx.r[7].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 82C42628: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C4262C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C42630: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C42634: 41990010  bgt cr6, 0x82c42644
	if ctx.cr[6].gt {
	pc = 0x82C42644; continue 'dispatch;
	}
	// 82C42638: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4263C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C42640: 40980008  bge cr6, 0x82c42648
	if !ctx.cr[6].lt {
	pc = 0x82C42648; continue 'dispatch;
	}
	pc = 0x82C42644; continue 'dispatch;
            }
            0x82C42644 => {
    //   block [0x82C42644..0x82C42648)
	// 82C42644: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C42648; continue 'dispatch;
            }
            0x82C42648 => {
    //   block [0x82C42648..0x82C42658)
	// 82C42648: 9161FFF4  stw r11, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[11].u32 ) };
	// 82C4264C: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42650: F9630000  std r11, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82C42654: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C42658 size=84
    let mut pc: u32 = 0x82C42658;
    'dispatch: loop {
        match pc {
            0x82C42658 => {
    //   block [0x82C42658..0x82C426AC)
	// 82C42658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4265C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42660: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42664: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42668: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4266C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C42670: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C42674: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C42678: 4B5B5189  bl 0x821f7800
	ctx.lr = 0x82C4267C;
	sub_821F7800(ctx, base);
	// 82C4267C: 3D408204  lis r10, -0x7dfc
	ctx.r[10].s64 = -2113667072;
	// 82C42680: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C42684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42688: C00ABDF4  lfs f0, -0x420c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4268C: C1A90AC8  lfs f13, 0xac8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C42690: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C42694: D1BF000C  stfs f13, 0xc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C42698: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4269C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C426A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C426A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C426A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C426B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C426B0 size=12
    let mut pc: u32 = 0x82C426B0;
    'dispatch: loop {
        match pc {
            0x82C426B0 => {
    //   block [0x82C426B0..0x82C426BC)
	// 82C426B0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C426B4: 386B4F9C  addi r3, r11, 0x4f9c
	ctx.r[3].s64 = ctx.r[11].s64 + 20380;
	// 82C426B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C426C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C426C0 size=144
    let mut pc: u32 = 0x82C426C0;
    'dispatch: loop {
        match pc {
            0x82C426C0 => {
    //   block [0x82C426C0..0x82C42718)
	// 82C426C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C426C4: 48066D49  bl 0x82ca940c
	ctx.lr = 0x82C426C8;
	sub_82CA93D0(ctx, base);
	// 82C426C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C426CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C426D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C426D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C426D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C426DC: 388BAF70  addi r4, r11, -0x5090
	ctx.r[4].s64 = ctx.r[11].s64 + -20624;
	// 82C426E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C426E4: 4BFC4AC5  bl 0x82c071a8
	ctx.lr = 0x82C426E8;
	sub_82C071A8(ctx, base);
	// 82C426E8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C426EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C426F0: 419A0028  beq cr6, 0x82c42718
	if ctx.cr[6].eq {
	pc = 0x82C42718; continue 'dispatch;
	}
	// 82C426F4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C426F8: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C426FC: 388BB430  addi r4, r11, -0x4bd0
	ctx.r[4].s64 = ctx.r[11].s64 + -19408;
	// 82C42700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42704: 4BFD8BB5  bl 0x82c1b2b8
	ctx.lr = 0x82C42708;
	sub_82C1B2B8(ctx, base);
	// 82C42708: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4270C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82C42710: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42714: 409A0008  bne cr6, 0x82c4271c
	if !ctx.cr[6].eq {
	pc = 0x82C4271C; continue 'dispatch;
	}
	pc = 0x82C42718; continue 'dispatch;
            }
            0x82C42718 => {
    //   block [0x82C42718..0x82C4271C)
	// 82C42718: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C4271C; continue 'dispatch;
            }
            0x82C4271C => {
    //   block [0x82C4271C..0x82C42750)
	// 82C4271C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C42720: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C42724: 388B1358  addi r4, r11, 0x1358
	ctx.r[4].s64 = ctx.r[11].s64 + 4952;
	// 82C42728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4272C: 4BFD8E85  bl 0x82c1b5b0
	ctx.lr = 0x82C42730;
	sub_82C1B5B0(ctx, base);
	// 82C42730: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82C42734: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82C42738: 388A8360  addi r4, r10, -0x7ca0
	ctx.r[4].s64 = ctx.r[10].s64 + -31904;
	// 82C4273C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42740: 4BFD8E71  bl 0x82c1b5b0
	ctx.lr = 0x82C42744;
	sub_82C1B5B0(ctx, base);
	// 82C42744: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C42748: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4274C: 48066D10  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42750 size=148
    let mut pc: u32 = 0x82C42750;
    'dispatch: loop {
        match pc {
            0x82C42750 => {
    //   block [0x82C42750..0x82C427C4)
	// 82C42750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42754: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42758: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4275C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42760: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42768: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C4276C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42770: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C42774: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42778: 4E800421  bctrl
	ctx.lr = 0x82C4277C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4277C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42780: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C42784: 419A0040  beq cr6, 0x82c427c4
	if ctx.cr[6].eq {
	pc = 0x82C427C4; continue 'dispatch;
	}
	// 82C42788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C4278C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42790: 4BFFFF31  bl 0x82c426c0
	ctx.lr = 0x82C42794;
	sub_82C426C0(ctx, base);
	// 82C42794: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4279C: 419A0028  beq cr6, 0x82c427c4
	if ctx.cr[6].eq {
	pc = 0x82C427C4; continue 'dispatch;
	}
	// 82C427A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C427A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C427A8: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C427AC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C427B0: 4E800421  bctrl
	ctx.lr = 0x82C427B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C427B4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C427B8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C427BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C427C0: 409A0008  bne cr6, 0x82c427c8
	if !ctx.cr[6].eq {
	pc = 0x82C427C8; continue 'dispatch;
	}
            }
            0x82C427C4 => {
    //   block [0x82C427C4..0x82C427C8)
	// 82C427C4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C427C8; continue 'dispatch;
            }
            0x82C427C8 => {
    //   block [0x82C427C8..0x82C427E4)
	// 82C427C8: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C427CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C427D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C427D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C427D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C427DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C427E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C427E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C427E8 size=12
    let mut pc: u32 = 0x82C427E8;
    'dispatch: loop {
        match pc {
            0x82C427E8 => {
    //   block [0x82C427E8..0x82C427F4)
	// 82C427E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C427EC: 386B4FA0  addi r3, r11, 0x4fa0
	ctx.r[3].s64 = ctx.r[11].s64 + 20384;
	// 82C427F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C427F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C427F8 size=288
    let mut pc: u32 = 0x82C427F8;
    'dispatch: loop {
        match pc {
            0x82C427F8 => {
    //   block [0x82C427F8..0x82C428F8)
	// 82C427F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C427FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42800: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C42804: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4280C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42810: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C42814: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42818: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4281C: 388BB730  addi r4, r11, -0x48d0
	ctx.r[4].s64 = ctx.r[11].s64 + -18640;
	// 82C42820: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42824: 4BFC4985  bl 0x82c071a8
	ctx.lr = 0x82C42828;
	sub_82C071A8(ctx, base);
	// 82C42828: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4282C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42830: 419A00C8  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C42834: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42838: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C4283C: 388BC378  addi r4, r11, -0x3c88
	ctx.r[4].s64 = ctx.r[11].s64 + -15496;
	// 82C42840: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42844: 4BFC4965  bl 0x82c071a8
	ctx.lr = 0x82C42848;
	sub_82C071A8(ctx, base);
	// 82C42848: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4284C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42850: 419A00A8  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C42854: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42858: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C4285C: 388BB710  addi r4, r11, -0x48f0
	ctx.r[4].s64 = ctx.r[11].s64 + -18672;
	// 82C42860: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42864: 4BFC4945  bl 0x82c071a8
	ctx.lr = 0x82C42868;
	sub_82C071A8(ctx, base);
	// 82C42868: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4286C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42870: 419A0088  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C42874: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42878: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82C4287C: 388BC36C  addi r4, r11, -0x3c94
	ctx.r[4].s64 = ctx.r[11].s64 + -15508;
	// 82C42880: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42884: 4BFD8BFD  bl 0x82c1b480
	ctx.lr = 0x82C42888;
	sub_82C1B480(ctx, base);
	// 82C42888: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4288C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42890: 419A0068  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C42894: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42898: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 82C4289C: 388BB4D4  addi r4, r11, -0x4b2c
	ctx.r[4].s64 = ctx.r[11].s64 + -19244;
	// 82C428A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C428A4: 4BFC4905  bl 0x82c071a8
	ctx.lr = 0x82C428A8;
	sub_82C071A8(ctx, base);
	// 82C428A8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C428AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C428B0: 419A0048  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C428B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C428B8: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 82C428BC: 388B1358  addi r4, r11, 0x1358
	ctx.r[4].s64 = ctx.r[11].s64 + 4952;
	// 82C428C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C428C4: 4BFD8CED  bl 0x82c1b5b0
	ctx.lr = 0x82C428C8;
	sub_82C1B5B0(ctx, base);
	// 82C428C8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C428CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C428D0: 419A0028  beq cr6, 0x82c428f8
	if ctx.cr[6].eq {
	pc = 0x82C428F8; continue 'dispatch;
	}
	// 82C428D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C428D8: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 82C428DC: 388B8360  addi r4, r11, -0x7ca0
	ctx.r[4].s64 = ctx.r[11].s64 + -31904;
	// 82C428E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C428E4: 4BFD8CCD  bl 0x82c1b5b0
	ctx.lr = 0x82C428E8;
	sub_82C1B5B0(ctx, base);
	// 82C428E8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C428EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C428F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C428F4: 409A0008  bne cr6, 0x82c428fc
	if !ctx.cr[6].eq {
	pc = 0x82C428FC; continue 'dispatch;
	}
	pc = 0x82C428F8; continue 'dispatch;
            }
            0x82C428F8 => {
    //   block [0x82C428F8..0x82C428FC)
	// 82C428F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C428FC; continue 'dispatch;
            }
            0x82C428FC => {
    //   block [0x82C428FC..0x82C42918)
	// 82C428FC: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C42900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C42904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4290C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C42910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42918 size=136
    let mut pc: u32 = 0x82C42918;
    'dispatch: loop {
        match pc {
            0x82C42918 => {
    //   block [0x82C42918..0x82C42950)
	// 82C42918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4291C: 48066AED  bl 0x82ca9408
	ctx.lr = 0x82C42920;
	sub_82CA93D0(ctx, base);
	// 82C42920: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42924: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42928: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4292C: 394BC380  addi r10, r11, -0x3c80
	ctx.r[10].s64 = ctx.r[11].s64 + -15488;
	// 82C42930: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C42934: 4BFE84D5  bl 0x82c2ae08
	ctx.lr = 0x82C42938;
	sub_82C2AE08(ctx, base);
	// 82C42938: 813F000C  lwz r9, 0xc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4293C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C42940: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C42944: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 82C42948: 40990028  ble cr6, 0x82c42970
	if !ctx.cr[6].gt {
	pc = 0x82C42970; continue 'dispatch;
	}
	// 82C4294C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x82C42950; continue 'dispatch;
            }
            0x82C42950 => {
    //   block [0x82C42950..0x82C42970)
	// 82C42950: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42954: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82C42958: 4BC02E59  bl 0x828457b0
	ctx.lr = 0x82C4295C;
	sub_828457B0(ctx, base);
	// 82C4295C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C42960: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C42964: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C42968: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4296C: 4198FFE4  blt cr6, 0x82c42950
	if ctx.cr[6].lt {
	pc = 0x82C42950; continue 'dispatch;
	}
	pc = 0x82C42970; continue 'dispatch;
            }
            0x82C42970 => {
    //   block [0x82C42970..0x82C42998)
	// 82C42970: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C42974: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	// 82C42978: 394BB008  addi r10, r11, -0x4ff8
	ctx.r[10].s64 = ctx.r[11].s64 + -20472;
	// 82C4297C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C42980: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42988: 419A0010  beq cr6, 0x82c42998
	if ctx.cr[6].eq {
	pc = 0x82C42998; continue 'dispatch;
	}
	// 82C4298C: 4BC02E25  bl 0x828457b0
	ctx.lr = 0x82C42990;
	sub_828457B0(ctx, base);
	// 82C42990: 939F0004  stw r28, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82C42994: 939F000C  stw r28, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[28].u32 ) };
	pc = 0x82C42998; continue 'dispatch;
            }
            0x82C42998 => {
    //   block [0x82C42998..0x82C429A0)
	// 82C42998: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4299C: 48066ABC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C429A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C429A0 size=80
    let mut pc: u32 = 0x82C429A0;
    'dispatch: loop {
        match pc {
            0x82C429A0 => {
    //   block [0x82C429A0..0x82C429D8)
	// 82C429A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C429A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C429A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C429AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C429B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C429B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C429B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C429BC: 4BFFFF5D  bl 0x82c42918
	ctx.lr = 0x82C429C0;
	sub_82C42918(ctx, base);
	// 82C429C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C429C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C429C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C429CC: 419A000C  beq cr6, 0x82c429d8
	if ctx.cr[6].eq {
	pc = 0x82C429D8; continue 'dispatch;
	}
	// 82C429D0: 4BC02DE1  bl 0x828457b0
	ctx.lr = 0x82C429D4;
	sub_828457B0(ctx, base);
	// 82C429D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C429D8; continue 'dispatch;
            }
            0x82C429D8 => {
    //   block [0x82C429D8..0x82C429F0)
	// 82C429D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C429DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C429E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C429E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C429E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C429EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C429F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C429F0 size=148
    let mut pc: u32 = 0x82C429F0;
    'dispatch: loop {
        match pc {
            0x82C429F0 => {
    //   block [0x82C429F0..0x82C42A64)
	// 82C429F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C429F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C429F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C429FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42A00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42A04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42A08: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C42A0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42A10: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C42A14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42A18: 4E800421  bctrl
	ctx.lr = 0x82C42A1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42A1C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42A20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C42A24: 419A0040  beq cr6, 0x82c42a64
	if ctx.cr[6].eq {
	pc = 0x82C42A64; continue 'dispatch;
	}
	// 82C42A28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C42A2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C42A30: 4BFFFDC9  bl 0x82c427f8
	ctx.lr = 0x82C42A34;
	sub_82C427F8(ctx, base);
	// 82C42A34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42A3C: 419A0028  beq cr6, 0x82c42a64
	if ctx.cr[6].eq {
	pc = 0x82C42A64; continue 'dispatch;
	}
	// 82C42A40: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42A48: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C42A4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42A50: 4E800421  bctrl
	ctx.lr = 0x82C42A54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42A54: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42A58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C42A5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C42A60: 409A0008  bne cr6, 0x82c42a68
	if !ctx.cr[6].eq {
	pc = 0x82C42A68; continue 'dispatch;
	}
            }
            0x82C42A64 => {
    //   block [0x82C42A64..0x82C42A68)
	// 82C42A64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C42A68; continue 'dispatch;
            }
            0x82C42A68 => {
    //   block [0x82C42A68..0x82C42A84)
	// 82C42A68: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C42A6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C42A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42A78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C42A7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42A80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42A88 size=168
    let mut pc: u32 = 0x82C42A88;
    'dispatch: loop {
        match pc {
            0x82C42A88 => {
    //   block [0x82C42A88..0x82C42AD8)
	// 82C42A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42A90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42A94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82C42A98: 409A0040  bne cr6, 0x82c42ad8
	if !ctx.cr[6].eq {
	pc = 0x82C42AD8; continue 'dispatch;
	}
	// 82C42A9C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C42AA0: 4B5DC7B9  bl 0x8221f258
	ctx.lr = 0x82C42AA4;
	sub_8221F258(ctx, base);
	// 82C42AA4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42AA8: 419A0074  beq cr6, 0x82c42b1c
	if ctx.cr[6].eq {
	pc = 0x82C42B1C; continue 'dispatch;
	}
	// 82C42AAC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C42AB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C42AB4: 392AC354  addi r9, r10, -0x3cac
	ctx.r[9].s64 = ctx.r[10].s64 + -15532;
	// 82C42AB8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C42ABC: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C42AC0: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C42AC4: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C42AC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42AD4: 4E800020  blr
	return;
            }
            0x82C42AD8 => {
    //   block [0x82C42AD8..0x82C42B1C)
	// 82C42AD8: 2B040001  cmplwi cr6, r4, 1
	ctx.cr[6].compare_u32(ctx.r[4].u32, 1 as u32, &mut ctx.xer);
	// 82C42ADC: 409A0040  bne cr6, 0x82c42b1c
	if !ctx.cr[6].eq {
	pc = 0x82C42B1C; continue 'dispatch;
	}
	// 82C42AE0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C42AE4: 4B5DC775  bl 0x8221f258
	ctx.lr = 0x82C42AE8;
	sub_8221F258(ctx, base);
	// 82C42AE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42AEC: 419A0030  beq cr6, 0x82c42b1c
	if ctx.cr[6].eq {
	pc = 0x82C42B1C; continue 'dispatch;
	}
	// 82C42AF0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C42AF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C42AF8: 392AC360  addi r9, r10, -0x3ca0
	ctx.r[9].s64 = ctx.r[10].s64 + -15520;
	// 82C42AFC: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C42B00: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C42B04: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C42B08: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C42B0C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42B10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42B14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42B18: 4E800020  blr
	return;
            }
            0x82C42B1C => {
    //   block [0x82C42B1C..0x82C42B30)
	// 82C42B1C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C42B20: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42B24: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42B28: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42B2C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42B30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42B30 size=112
    let mut pc: u32 = 0x82C42B30;
    'dispatch: loop {
        match pc {
            0x82C42B30 => {
    //   block [0x82C42B30..0x82C42B64)
	// 82C42B30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42B34: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42B38: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42B3C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42B40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C42B44: 4BFFF96D  bl 0x82c424b0
	ctx.lr = 0x82C42B48;
	sub_82C424B0(ctx, base);
	// 82C42B48: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42B4C: 409A0018  bne cr6, 0x82c42b64
	if !ctx.cr[6].eq {
	pc = 0x82C42B64; continue 'dispatch;
	}
	// 82C42B50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42B54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42B58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42B5C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42B60: 4E800020  blr
	return;
            }
            0x82C42B64 => {
    //   block [0x82C42B64..0x82C42BA0)
	// 82C42B64: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42B68: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C42B6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42B70: 388A4FA0  addi r4, r10, 0x4fa0
	ctx.r[4].s64 = ctx.r[10].s64 + 20384;
	// 82C42B74: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42B78: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C42B7C: 4E800421  bctrl
	ctx.lr = 0x82C42B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42B80: 7C680034  cntlzw r8, r3
	ctx.r[8].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C42B84: 5507DFFE  rlwinm r7, r8, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C42B88: 68E30001  xori r3, r7, 1
	ctx.r[3].u64 = ctx.r[7].u64 ^ 1;
	// 82C42B8C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42B90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42B94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42B98: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42B9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42BA0 size=112
    let mut pc: u32 = 0x82C42BA0;
    'dispatch: loop {
        match pc {
            0x82C42BA0 => {
    //   block [0x82C42BA0..0x82C42BEC)
	// 82C42BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42BA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C42BA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C42BAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42BB0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42BB4: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C42BB8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C42BBC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C42BC0: 388A4F9C  addi r4, r10, 0x4f9c
	ctx.r[4].s64 = ctx.r[10].s64 + 20380;
	// 82C42BC4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42BC8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C42BCC: 4E800421  bctrl
	ctx.lr = 0x82C42BD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42BD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42BD4: 409A0018  bne cr6, 0x82c42bec
	if !ctx.cr[6].eq {
	pc = 0x82C42BEC; continue 'dispatch;
	}
	// 82C42BD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42BE8: 4E800020  blr
	return;
            }
            0x82C42BEC => {
    //   block [0x82C42BEC..0x82C42C10)
	// 82C42BEC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42BF0: 57EA103A  slwi r10, r31, 2
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C42BF4: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82C42BF8: 80690000  lwz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42BFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C42C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C42C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C42C08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C42C0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42C10 size=96
    let mut pc: u32 = 0x82C42C10;
    'dispatch: loop {
        match pc {
            0x82C42C10 => {
    //   block [0x82C42C10..0x82C42C70)
	// 82C42C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42C14: 480667F9  bl 0x82ca940c
	ctx.lr = 0x82C42C18;
	sub_82CA93D0(ctx, base);
	// 82C42C18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42C1C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C42C20: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C42C24: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C42C28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C42C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42C30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C42C34: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C42C38: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C42C3C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C42C40: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42C44: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C42C48: 4BFFF3D1  bl 0x82c42018
	ctx.lr = 0x82C42C4C;
	sub_82C42018(ctx, base);
	// 82C42C4C: 7D1FF050  subf r8, r31, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82C42C50: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82C42C54: 7D683BD6  divw r11, r8, r7
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82C42C58: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C42C5C: 7CCB5214  add r6, r11, r10
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C42C60: 54C5103A  slwi r5, r6, 2
	ctx.r[5].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C42C64: 7C65E850  subf r3, r5, r29
	ctx.r[3].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82C42C68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42C6C: 480667F0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42C70 size=88
    let mut pc: u32 = 0x82C42C70;
    'dispatch: loop {
        match pc {
            0x82C42C70 => {
    //   block [0x82C42C70..0x82C42CC8)
	// 82C42C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42C74: 48066799  bl 0x82ca940c
	ctx.lr = 0x82C42C78;
	sub_82CA93D0(ctx, base);
	// 82C42C78: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42C7C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C42C80: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C42C84: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C42C88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C42C8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42C90: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C42C94: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C42C98: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C42C9C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C42CA0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42CA4: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C42CA8: 4BFFF421  bl 0x82c420c8
	ctx.lr = 0x82C42CAC;
	sub_82C420C8(ctx, base);
	// 82C42CAC: 7D1FF050  subf r8, r31, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 82C42CB0: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 82C42CB4: 7CC83BD6  divw r6, r8, r7
	ctx.r[6].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82C42CB8: 1CA6001C  mulli r5, r6, 0x1c
	ctx.r[5].s32 = ((ctx.r[6].s32 as i64 * 28 as i64) as i32);
	ctx.r[5].s64 = ctx.r[5].s32 as i64;
	// 82C42CBC: 7C65E850  subf r3, r5, r29
	ctx.r[3].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 82C42CC0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C42CC4: 48066798  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C42CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C42CC8 size=828
    let mut pc: u32 = 0x82C42CC8;
    'dispatch: loop {
        match pc {
            0x82C42CC8 => {
    //   block [0x82C42CC8..0x82C42D34)
	// 82C42CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C42CCC: 48066735  bl 0x82ca9400
	ctx.lr = 0x82C42CD0;
	sub_82CA93D0(ctx, base);
	// 82C42CD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C42CD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C42CD8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82C42CDC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42CE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42CE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42CE8: 4E800421  bctrl
	ctx.lr = 0x82C42CEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42CEC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C42CF0: 41980124  blt cr6, 0x82c42e14
	if ctx.cr[6].lt {
	pc = 0x82C42E14; continue 'dispatch;
	}
	// 82C42CF4: 409A0280  bne cr6, 0x82c42f74
	if !ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42CF8: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42CFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42D00: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C42D04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42D08: 4E800421  bctrl
	ctx.lr = 0x82C42D0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42D0C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C42D10: 41980064  blt cr6, 0x82c42d74
	if ctx.cr[6].lt {
	pc = 0x82C42D74; continue 'dispatch;
	}
	// 82C42D14: 409A0260  bne cr6, 0x82c42f74
	if !ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42D18: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C42D1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C42D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42D24: 409902D4  ble cr6, 0x82c42ff8
	if !ctx.cr[6].gt {
	pc = 0x82C42FF8; continue 'dispatch;
	}
	// 82C42D28: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C42D2C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C42D30: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C42D34 => {
    //   block [0x82C42D34..0x82C42D74)
	// 82C42D34: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42D38: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C42D3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42D40: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C42D44: 4BFFFA0D  bl 0x82c42750
	ctx.lr = 0x82C42D48;
	sub_82C42750(ctx, base);
	// 82C42D48: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42D4C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42D50: 419A0224  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42D54: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C42D58: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C42D5C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C42D60: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C42D64: 4198FFD0  blt cr6, 0x82c42d34
	if ctx.cr[6].lt {
	pc = 0x82C42D34; continue 'dispatch;
	}
	// 82C42D68: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C42D6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C42D70: 480666E0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C42D74 => {
    //   block [0x82C42D74..0x82C42DB4)
	// 82C42D74: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42D78: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42D7C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C42D80: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42D84: 4E800421  bctrl
	ctx.lr = 0x82C42D88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42D88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C42D8C: 3B6B5D98  addi r27, r11, 0x5d98
	ctx.r[27].s64 = ctx.r[11].s64 + 23960;
	// 82C42D90: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C42D94: 4BFC5E25  bl 0x82c08bb8
	ctx.lr = 0x82C42D98;
	sub_82C08BB8(ctx, base);
	// 82C42D98: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C42D9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C42DA0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C42DA4: 4BFE34FD  bl 0x82c262a0
	ctx.lr = 0x82C42DA8;
	sub_82C262A0(ctx, base);
	// 82C42DA8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C42DAC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C42DB0: 419A0248  beq cr6, 0x82c42ff8
	if ctx.cr[6].eq {
	pc = 0x82C42FF8; continue 'dispatch;
	}
            }
            0x82C42DB4 => {
    //   block [0x82C42DB4..0x82C42DD0)
	// 82C42DB4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C42DB8: 4B5DC4A1  bl 0x8221f258
	ctx.lr = 0x82C42DBC;
	sub_8221F258(ctx, base);
	// 82C42DBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42DC0: 419A0010  beq cr6, 0x82c42dd0
	if ctx.cr[6].eq {
	pc = 0x82C42DD0; continue 'dispatch;
	}
	// 82C42DC4: 4BFFF895  bl 0x82c42658
	ctx.lr = 0x82C42DC8;
	sub_82C42658(ctx, base);
	// 82C42DC8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42DCC: 48000008  b 0x82c42dd4
	pc = 0x82C42DD4; continue 'dispatch;
            }
            0x82C42DD0 => {
    //   block [0x82C42DD0..0x82C42DD4)
	// 82C42DD0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C42DD4; continue 'dispatch;
            }
            0x82C42DD4 => {
    //   block [0x82C42DD4..0x82C42E14)
	// 82C42DD4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C42DD8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C42DDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42DE0: 4BFFF971  bl 0x82c42750
	ctx.lr = 0x82C42DE4;
	sub_82C42750(ctx, base);
	// 82C42DE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42DEC: 419A0188  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42DF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C42DF4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C42DF8: 4BFE38F1  bl 0x82c266e8
	ctx.lr = 0x82C42DFC;
	sub_82C266E8(ctx, base);
	// 82C42DFC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C42E00: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C42E04: 4198FFB0  blt cr6, 0x82c42db4
	if ctx.cr[6].lt {
	pc = 0x82C42DB4; continue 'dispatch;
	}
	// 82C42E08: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C42E0C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C42E10: 48066640  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C42E14 => {
    //   block [0x82C42E14..0x82C42E90)
	// 82C42E14: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42E18: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42E1C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C42E20: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42E24: 4E800421  bctrl
	ctx.lr = 0x82C42E28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42E28: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C42E2C: 419800A4  blt cr6, 0x82c42ed0
	if ctx.cr[6].lt {
	pc = 0x82C42ED0; continue 'dispatch;
	}
	// 82C42E30: 409A0144  bne cr6, 0x82c42f74
	if !ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42E34: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42E38: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42E3C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C42E40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42E44: 4E800421  bctrl
	ctx.lr = 0x82C42E48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42E48: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42E4C: 811A0008  lwz r8, 8(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C42E50: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C42E54: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42E58: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C42E5C: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C42E60: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C42E64: 4E800421  bctrl
	ctx.lr = 0x82C42E68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42E68: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42E6C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C42E70: 419A0104  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42E74: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42E78: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C42E7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42E80: 419A0178  beq cr6, 0x82c42ff8
	if ctx.cr[6].eq {
	pc = 0x82C42FF8; continue 'dispatch;
	}
	// 82C42E84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C42E88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C42E8C: 3BCB5D98  addi r30, r11, 0x5d98
	ctx.r[30].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C42E90 => {
    //   block [0x82C42E90..0x82C42ED0)
	// 82C42E90: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42E94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C42E98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42E9C: 7CBF582E  lwzx r5, r31, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C42EA0: 4BFFF8B1  bl 0x82c42750
	ctx.lr = 0x82C42EA4;
	sub_82C42750(ctx, base);
	// 82C42EA4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42EA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C42EAC: 419A00C8  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42EB0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42EB4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C42EB8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C42EBC: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C42EC0: 4198FFD0  blt cr6, 0x82c42e90
	if ctx.cr[6].lt {
	pc = 0x82C42E90; continue 'dispatch;
	}
	// 82C42EC4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C42EC8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C42ECC: 48066584  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C42ED0 => {
    //   block [0x82C42ED0..0x82C42F74)
	// 82C42ED0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42ED4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42ED8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C42EDC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C42EE0: 4E800421  bctrl
	ctx.lr = 0x82C42EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42EE4: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42EE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42EEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C42EF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42EF4: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C42EF8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C42EFC: 4E800421  bctrl
	ctx.lr = 0x82C42F00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42F00: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42F04: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C42F08: 419A006C  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42F10: 4BFC4E11  bl 0x82c07d20
	ctx.lr = 0x82C42F14;
	sub_82C07D20(ctx, base);
	// 82C42F14: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42F18: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C42F1C: 40990064  ble cr6, 0x82c42f80
	if !ctx.cr[6].gt {
	pc = 0x82C42F80; continue 'dispatch;
	}
	// 82C42F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C42F24: 4BFC4DFD  bl 0x82c07d20
	ctx.lr = 0x82C42F28;
	sub_82C07D20(ctx, base);
	// 82C42F28: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C42F2C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C42F30: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42F34: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C42F38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C42F3C: 3BAAB0E8  addi r29, r10, -0x4f18
	ctx.r[29].s64 = ctx.r[10].s64 + -20248;
	// 82C42F40: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C42F44: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C42F48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42F4C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C42F50: 4E800421  bctrl
	ctx.lr = 0x82C42F54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C42F54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C42F58: 4BFC28A1  bl 0x82c057f8
	ctx.lr = 0x82C42F5C;
	sub_82C057F8(ctx, base);
	// 82C42F5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C42F60: 4BFC2909  bl 0x82c05868
	ctx.lr = 0x82C42F64;
	sub_82C05868(ctx, base);
	// 82C42F64: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C42F68: 4BFC2891  bl 0x82c057f8
	ctx.lr = 0x82C42F6C;
	sub_82C057F8(ctx, base);
	// 82C42F6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C42F70: 4BFC28F9  bl 0x82c05868
	ctx.lr = 0x82C42F74;
	sub_82C05868(ctx, base);
            }
            0x82C42F74 => {
    //   block [0x82C42F74..0x82C42F80)
	// 82C42F74: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C42F78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C42F7C: 480664D4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C42F80 => {
    //   block [0x82C42F80..0x82C42FA0)
	// 82C42F80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C42F84: 4BFE331D  bl 0x82c262a0
	ctx.lr = 0x82C42F88;
	sub_82C262A0(ctx, base);
	// 82C42F88: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42F90: 419A0068  beq cr6, 0x82c42ff8
	if ctx.cr[6].eq {
	pc = 0x82C42FF8; continue 'dispatch;
	}
	// 82C42F94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C42F98: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C42F9C: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
	pc = 0x82C42FA0; continue 'dispatch;
            }
            0x82C42FA0 => {
    //   block [0x82C42FA0..0x82C42FBC)
	// 82C42FA0: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C42FA4: 4B5DC2B5  bl 0x8221f258
	ctx.lr = 0x82C42FA8;
	sub_8221F258(ctx, base);
	// 82C42FA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C42FAC: 419A0010  beq cr6, 0x82c42fbc
	if ctx.cr[6].eq {
	pc = 0x82C42FBC; continue 'dispatch;
	}
	// 82C42FB0: 4BFFF6A9  bl 0x82c42658
	ctx.lr = 0x82C42FB4;
	sub_82C42658(ctx, base);
	// 82C42FB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C42FB8: 48000008  b 0x82c42fc0
	pc = 0x82C42FC0; continue 'dispatch;
            }
            0x82C42FBC => {
    //   block [0x82C42FBC..0x82C42FC0)
	// 82C42FBC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C42FC0; continue 'dispatch;
            }
            0x82C42FC0 => {
    //   block [0x82C42FC0..0x82C42FF8)
	// 82C42FC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C42FC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C42FC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C42FCC: 4BFFF785  bl 0x82c42750
	ctx.lr = 0x82C42FD0;
	sub_82C42750(ctx, base);
	// 82C42FD0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C42FD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C42FD8: 419AFF9C  beq cr6, 0x82c42f74
	if ctx.cr[6].eq {
	pc = 0x82C42F74; continue 'dispatch;
	}
	// 82C42FDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C42FE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82C42FE4: 4BFE3705  bl 0x82c266e8
	ctx.lr = 0x82C42FE8;
	sub_82C266E8(ctx, base);
	// 82C42FE8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C42FEC: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C42FF0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C42FF4: 4198FFAC  blt cr6, 0x82c42fa0
	if ctx.cr[6].lt {
	pc = 0x82C42FA0; continue 'dispatch;
	}
	pc = 0x82C42FF8; continue 'dispatch;
            }
            0x82C42FF8 => {
    //   block [0x82C42FF8..0x82C43004)
	// 82C42FF8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C42FFC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43000: 48066450  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43008 size=788
    let mut pc: u32 = 0x82C43008;
    'dispatch: loop {
        match pc {
            0x82C43008 => {
    //   block [0x82C43008..0x82C43074)
	// 82C43008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4300C: 480663F5  bl 0x82ca9400
	ctx.lr = 0x82C43010;
	sub_82CA93D0(ctx, base);
	// 82C43010: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43018: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C4301C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43020: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43024: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43028: 4E800421  bctrl
	ctx.lr = 0x82C4302C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4302C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C43030: 41980110  blt cr6, 0x82c43140
	if ctx.cr[6].lt {
	pc = 0x82C43140; continue 'dispatch;
	}
	// 82C43034: 409A026C  bne cr6, 0x82c432a0
	if !ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C43038: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4303C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43040: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C43044: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43048: 4E800421  bctrl
	ctx.lr = 0x82C4304C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4304C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C43050: 41980064  blt cr6, 0x82c430b4
	if ctx.cr[6].lt {
	pc = 0x82C430B4; continue 'dispatch;
	}
	// 82C43054: 409A024C  bne cr6, 0x82c432a0
	if !ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C43058: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4305C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C43060: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43064: 409902AC  ble cr6, 0x82c43310
	if !ctx.cr[6].gt {
	pc = 0x82C43310; continue 'dispatch;
	}
	// 82C43068: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C4306C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C43070: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C43074 => {
    //   block [0x82C43074..0x82C430B4)
	// 82C43074: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43078: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4307C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43080: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C43084: 4BFFF96D  bl 0x82c429f0
	ctx.lr = 0x82C43088;
	sub_82C429F0(ctx, base);
	// 82C43088: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4308C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43090: 419A0210  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C43094: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43098: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C4309C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C430A0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C430A4: 4198FFD0  blt cr6, 0x82c43074
	if ctx.cr[6].lt {
	pc = 0x82C43074; continue 'dispatch;
	}
	// 82C430A8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C430AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C430B0: 480663A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C430B4 => {
    //   block [0x82C430B4..0x82C430F4)
	// 82C430B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C430B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C430BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C430C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C430C4: 4E800421  bctrl
	ctx.lr = 0x82C430C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C430C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C430CC: 3B4B5D98  addi r26, r11, 0x5d98
	ctx.r[26].s64 = ctx.r[11].s64 + 23960;
	// 82C430D0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C430D4: 4BFC5AE5  bl 0x82c08bb8
	ctx.lr = 0x82C430D8;
	sub_82C08BB8(ctx, base);
	// 82C430D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C430DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C430E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C430E4: 4BFE31BD  bl 0x82c262a0
	ctx.lr = 0x82C430E8;
	sub_82C262A0(ctx, base);
	// 82C430E8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C430EC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C430F0: 419A0220  beq cr6, 0x82c43310
	if ctx.cr[6].eq {
	pc = 0x82C43310; continue 'dispatch;
	}
            }
            0x82C430F4 => {
    //   block [0x82C430F4..0x82C43140)
	// 82C430F4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82C430F8: 4B5DC161  bl 0x8221f258
	ctx.lr = 0x82C430FC;
	sub_8221F258(ctx, base);
	// 82C430FC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C43100: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C43104: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C43108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4310C: 4BFFF8E5  bl 0x82c429f0
	ctx.lr = 0x82C43110;
	sub_82C429F0(ctx, base);
	// 82C43110: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C43114: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43118: 419A0188  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C4311C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C43120: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C43124: 4BFE35C5  bl 0x82c266e8
	ctx.lr = 0x82C43128;
	sub_82C266E8(ctx, base);
	// 82C43128: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C4312C: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43130: 4198FFC4  blt cr6, 0x82c430f4
	if ctx.cr[6].lt {
	pc = 0x82C430F4; continue 'dispatch;
	}
	// 82C43134: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C43138: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C4313C: 48066314  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C43140 => {
    //   block [0x82C43140..0x82C431BC)
	// 82C43140: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43148: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4314C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43150: 4E800421  bctrl
	ctx.lr = 0x82C43154;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C43154: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C43158: 419800A4  blt cr6, 0x82c431fc
	if ctx.cr[6].lt {
	pc = 0x82C431FC; continue 'dispatch;
	}
	// 82C4315C: 409A0144  bne cr6, 0x82c432a0
	if !ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C43160: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43164: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43168: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4316C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43170: 4E800421  bctrl
	ctx.lr = 0x82C43174;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C43174: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43178: 811B0008  lwz r8, 8(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4317C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C43180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43184: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C43188: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C4318C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C43190: 4E800421  bctrl
	ctx.lr = 0x82C43194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C43194: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C43198: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C4319C: 419A0104  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C431A0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C431A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C431A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C431AC: 419A0164  beq cr6, 0x82c43310
	if ctx.cr[6].eq {
	pc = 0x82C43310; continue 'dispatch;
	}
	// 82C431B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C431B4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C431B8: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C431BC => {
    //   block [0x82C431BC..0x82C431FC)
	// 82C431BC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C431C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C431C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C431C8: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C431CC: 4BFFF825  bl 0x82c429f0
	ctx.lr = 0x82C431D0;
	sub_82C429F0(ctx, base);
	// 82C431D0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C431D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C431D8: 419A00C8  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C431DC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C431E0: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C431E4: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C431E8: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C431EC: 4198FFD0  blt cr6, 0x82c431bc
	if ctx.cr[6].lt {
	pc = 0x82C431BC; continue 'dispatch;
	}
	// 82C431F0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C431F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C431F8: 48066258  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C431FC => {
    //   block [0x82C431FC..0x82C432A0)
	// 82C431FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43204: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43208: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4320C: 4E800421  bctrl
	ctx.lr = 0x82C43210;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C43210: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43214: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43218: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C4321C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43220: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C43224: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C43228: 4E800421  bctrl
	ctx.lr = 0x82C4322C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4322C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C43230: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C43234: 419A006C  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C43238: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4323C: 4BFC4AE5  bl 0x82c07d20
	ctx.lr = 0x82C43240;
	sub_82C07D20(ctx, base);
	// 82C43240: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43244: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C43248: 40990064  ble cr6, 0x82c432ac
	if !ctx.cr[6].gt {
	pc = 0x82C432AC; continue 'dispatch;
	}
	// 82C4324C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C43250: 4BFC4AD1  bl 0x82c07d20
	ctx.lr = 0x82C43254;
	sub_82C07D20(ctx, base);
	// 82C43254: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43258: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4325C: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43260: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C43264: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C43268: 3B8AB0E8  addi r28, r10, -0x4f18
	ctx.r[28].s64 = ctx.r[10].s64 + -20248;
	// 82C4326C: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C43270: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C43274: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43278: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4327C: 4E800421  bctrl
	ctx.lr = 0x82C43280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C43280: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C43284: 4BFC2575  bl 0x82c057f8
	ctx.lr = 0x82C43288;
	sub_82C057F8(ctx, base);
	// 82C43288: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4328C: 4BFC25DD  bl 0x82c05868
	ctx.lr = 0x82C43290;
	sub_82C05868(ctx, base);
	// 82C43290: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C43294: 4BFC2565  bl 0x82c057f8
	ctx.lr = 0x82C43298;
	sub_82C057F8(ctx, base);
	// 82C43298: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4329C: 4BFC25CD  bl 0x82c05868
	ctx.lr = 0x82C432A0;
	sub_82C05868(ctx, base);
            }
            0x82C432A0 => {
    //   block [0x82C432A0..0x82C432AC)
	// 82C432A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C432A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C432A8: 480661A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C432AC => {
    //   block [0x82C432AC..0x82C432CC)
	// 82C432AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C432B0: 4BFE2FF1  bl 0x82c262a0
	ctx.lr = 0x82C432B4;
	sub_82C262A0(ctx, base);
	// 82C432B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C432B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C432BC: 419A0054  beq cr6, 0x82c43310
	if ctx.cr[6].eq {
	pc = 0x82C43310; continue 'dispatch;
	}
	// 82C432C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C432C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C432C8: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
	pc = 0x82C432CC; continue 'dispatch;
            }
            0x82C432CC => {
    //   block [0x82C432CC..0x82C43310)
	// 82C432CC: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 82C432D0: 4B5DBF89  bl 0x8221f258
	ctx.lr = 0x82C432D4;
	sub_8221F258(ctx, base);
	// 82C432D4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C432D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C432DC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C432E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C432E4: 4BFFF70D  bl 0x82c429f0
	ctx.lr = 0x82C432E8;
	sub_82C429F0(ctx, base);
	// 82C432E8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C432EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C432F0: 419AFFB0  beq cr6, 0x82c432a0
	if ctx.cr[6].eq {
	pc = 0x82C432A0; continue 'dispatch;
	}
	// 82C432F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C432F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C432FC: 4BFE33ED  bl 0x82c266e8
	ctx.lr = 0x82C43300;
	sub_82C266E8(ctx, base);
	// 82C43300: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43304: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C43308: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4330C: 4198FFC0  blt cr6, 0x82c432cc
	if ctx.cr[6].lt {
	pc = 0x82C432CC; continue 'dispatch;
	}
	pc = 0x82C43310; continue 'dispatch;
            }
            0x82C43310 => {
    //   block [0x82C43310..0x82C4331C)
	// 82C43310: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C43314: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43318: 48066138  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43320 size=116
    let mut pc: u32 = 0x82C43320;
    'dispatch: loop {
        match pc {
            0x82C43320 => {
    //   block [0x82C43320..0x82C43340)
	// 82C43320: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43324: 480660E9  bl 0x82ca940c
	ctx.lr = 0x82C43328;
	sub_82CA93D0(ctx, base);
	// 82C43328: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4332C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43330: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C43334: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C43338: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4333C: 419A004C  beq cr6, 0x82c43388
	if ctx.cr[6].eq {
	pc = 0x82C43388; continue 'dispatch;
	}
	pc = 0x82C43340; continue 'dispatch;
            }
            0x82C43340 => {
    //   block [0x82C43340..0x82C43378)
	// 82C43340: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C43344: 419A0034  beq cr6, 0x82c43378
	if ctx.cr[6].eq {
	pc = 0x82C43378; continue 'dispatch;
	}
	// 82C43348: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4334C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C43350: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43354: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C43358: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4335C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43360: 907E0008  stw r3, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C43364: 419A0014  beq cr6, 0x82c43378
	if ctx.cr[6].eq {
	pc = 0x82C43378; continue 'dispatch;
	}
	// 82C43368: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4336C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43370: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43374: 4E800421  bctrl
	ctx.lr = 0x82C43378;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43378 => {
    //   block [0x82C43378..0x82C43388)
	// 82C43378: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C4337C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C43380: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C43384: 409AFFBC  bne cr6, 0x82c43340
	if !ctx.cr[6].eq {
	pc = 0x82C43340; continue 'dispatch;
	}
	pc = 0x82C43388; continue 'dispatch;
            }
            0x82C43388 => {
    //   block [0x82C43388..0x82C43394)
	// 82C43388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4338C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C43390: 480660CC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C43398 size=148
    let mut pc: u32 = 0x82C43398;
    'dispatch: loop {
        match pc {
            0x82C43398 => {
    //   block [0x82C43398..0x82C433B8)
	// 82C43398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4339C: 48066071  bl 0x82ca940c
	ctx.lr = 0x82C433A0;
	sub_82CA93D0(ctx, base);
	// 82C433A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C433A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C433A8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C433AC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C433B0: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C433B4: 419A006C  beq cr6, 0x82c43420
	if ctx.cr[6].eq {
	pc = 0x82C43420; continue 'dispatch;
	}
	pc = 0x82C433B8; continue 'dispatch;
            }
            0x82C433B8 => {
    //   block [0x82C433B8..0x82C43408)
	// 82C433B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C433BC: 419A0054  beq cr6, 0x82c43410
	if ctx.cr[6].eq {
	pc = 0x82C43410; continue 'dispatch;
	}
	// 82C433C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C433C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C433C8: C01F0004  lfs f0, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C433CC: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C433D0: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C433D4: D1BE0008  stfs f13, 8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C433D8: C19F000C  lfs f12, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C433DC: D19E000C  stfs f12, 0xc(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C433E0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C433E4: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C433E8: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C433EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C433F0: 907E0014  stw r3, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82C433F4: 419A0014  beq cr6, 0x82c43408
	if ctx.cr[6].eq {
	pc = 0x82C43408; continue 'dispatch;
	}
	// 82C433F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C433FC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43404: 4E800421  bctrl
	ctx.lr = 0x82C43408;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43408 => {
    //   block [0x82C43408..0x82C43410)
	// 82C43408: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4340C: 917E0018  stw r11, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82C43410; continue 'dispatch;
            }
            0x82C43410 => {
    //   block [0x82C43410..0x82C43420)
	// 82C43410: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C43414: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C43418: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4341C: 409AFF9C  bne cr6, 0x82c433b8
	if !ctx.cr[6].eq {
	pc = 0x82C433B8; continue 'dispatch;
	}
	pc = 0x82C43420; continue 'dispatch;
            }
            0x82C43420 => {
    //   block [0x82C43420..0x82C4342C)
	// 82C43420: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C43424: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C43428: 48066034  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43430 size=96
    let mut pc: u32 = 0x82C43430;
    'dispatch: loop {
        match pc {
            0x82C43430 => {
    //   block [0x82C43430..0x82C43454)
	// 82C43430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43434: 48065FD5  bl 0x82ca9408
	ctx.lr = 0x82C43438;
	sub_82CA93D0(ctx, base);
	// 82C43438: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4343C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43440: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C43444: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43448: 419A0040  beq cr6, 0x82c43488
	if ctx.cr[6].eq {
	pc = 0x82C43488; continue 'dispatch;
	}
	// 82C4344C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82C43450: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C43454; continue 'dispatch;
            }
            0x82C43454 => {
    //   block [0x82C43454..0x82C43470)
	// 82C43454: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43458: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4345C: 419A0014  beq cr6, 0x82c43470
	if ctx.cr[6].eq {
	pc = 0x82C43470; continue 'dispatch;
	}
	// 82C43460: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43464: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43468: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4346C: 4E800421  bctrl
	ctx.lr = 0x82C43470;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43470 => {
    //   block [0x82C43470..0x82C43488)
	// 82C43470: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C43474: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C43478: 93BFFFFC  stw r29, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 82C4347C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C43480: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43484: 409AFFD0  bne cr6, 0x82c43454
	if !ctx.cr[6].eq {
	pc = 0x82C43454; continue 'dispatch;
	}
	pc = 0x82C43488; continue 'dispatch;
            }
            0x82C43488 => {
    //   block [0x82C43488..0x82C43490)
	// 82C43488: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4348C: 48065FCC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43490 size=96
    let mut pc: u32 = 0x82C43490;
    'dispatch: loop {
        match pc {
            0x82C43490 => {
    //   block [0x82C43490..0x82C434B4)
	// 82C43490: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43494: 48065F75  bl 0x82ca9408
	ctx.lr = 0x82C43498;
	sub_82CA93D0(ctx, base);
	// 82C43498: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4349C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C434A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C434A4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C434A8: 419A0040  beq cr6, 0x82c434e8
	if ctx.cr[6].eq {
	pc = 0x82C434E8; continue 'dispatch;
	}
	// 82C434AC: 3BFE0014  addi r31, r30, 0x14
	ctx.r[31].s64 = ctx.r[30].s64 + 20;
	// 82C434B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82C434B4; continue 'dispatch;
            }
            0x82C434B4 => {
    //   block [0x82C434B4..0x82C434D0)
	// 82C434B4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C434B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C434BC: 419A0014  beq cr6, 0x82c434d0
	if ctx.cr[6].eq {
	pc = 0x82C434D0; continue 'dispatch;
	}
	// 82C434C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C434C4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C434C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C434CC: 4E800421  bctrl
	ctx.lr = 0x82C434D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C434D0 => {
    //   block [0x82C434D0..0x82C434E8)
	// 82C434D0: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C434D4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C434D8: 93BFFFFC  stw r29, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 82C434DC: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C434E0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C434E4: 409AFFD0  bne cr6, 0x82c434b4
	if !ctx.cr[6].eq {
	pc = 0x82C434B4; continue 'dispatch;
	}
	pc = 0x82C434E8; continue 'dispatch;
            }
            0x82C434E8 => {
    //   block [0x82C434E8..0x82C434F0)
	// 82C434E8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C434EC: 48065F6C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C434F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C434F0 size=108
    let mut pc: u32 = 0x82C434F0;
    'dispatch: loop {
        match pc {
            0x82C434F0 => {
    //   block [0x82C434F0..0x82C43510)
	// 82C434F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C434F4: 48065F19  bl 0x82ca940c
	ctx.lr = 0x82C434F8;
	sub_82CA93D0(ctx, base);
	// 82C434F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C434FC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C43500: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43504: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C43508: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4350C: 419A0048  beq cr6, 0x82c43554
	if ctx.cr[6].eq {
	pc = 0x82C43554; continue 'dispatch;
	}
	pc = 0x82C43510; continue 'dispatch;
            }
            0x82C43510 => {
    //   block [0x82C43510..0x82C43548)
	// 82C43510: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C43514: 419A0034  beq cr6, 0x82c43548
	if ctx.cr[6].eq {
	pc = 0x82C43548; continue 'dispatch;
	}
	// 82C43518: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4351C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C43520: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43524: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C43528: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4352C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43530: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C43534: 419A0014  beq cr6, 0x82c43548
	if ctx.cr[6].eq {
	pc = 0x82C43548; continue 'dispatch;
	}
	// 82C43538: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4353C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43540: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43544: 4E800421  bctrl
	ctx.lr = 0x82C43548;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43548 => {
    //   block [0x82C43548..0x82C43554)
	// 82C43548: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C4354C: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C43550: 4082FFC0  bne 0x82c43510
	if !ctx.cr[0].eq {
	pc = 0x82C43510; continue 'dispatch;
	}
	pc = 0x82C43554; continue 'dispatch;
            }
            0x82C43554 => {
    //   block [0x82C43554..0x82C4355C)
	// 82C43554: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C43558: 48065F04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43560(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C43560 size=140
    let mut pc: u32 = 0x82C43560;
    'dispatch: loop {
        match pc {
            0x82C43560 => {
    //   block [0x82C43560..0x82C43580)
	// 82C43560: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43564: 48065EA9  bl 0x82ca940c
	ctx.lr = 0x82C43568;
	sub_82CA93D0(ctx, base);
	// 82C43568: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4356C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C43570: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43574: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C43578: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C4357C: 419A0068  beq cr6, 0x82c435e4
	if ctx.cr[6].eq {
	pc = 0x82C435E4; continue 'dispatch;
	}
	pc = 0x82C43580; continue 'dispatch;
            }
            0x82C43580 => {
    //   block [0x82C43580..0x82C435D0)
	// 82C43580: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C43584: 419A0054  beq cr6, 0x82c435d8
	if ctx.cr[6].eq {
	pc = 0x82C435D8; continue 'dispatch;
	}
	// 82C43588: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4358C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C43590: C01E0004  lfs f0, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C43594: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C43598: C1BE0008  lfs f13, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4359C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C435A0: C19E000C  lfs f12, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C435A4: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C435A8: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C435AC: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82C435B0: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C435B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C435B8: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82C435BC: 419A0014  beq cr6, 0x82c435d0
	if ctx.cr[6].eq {
	pc = 0x82C435D0; continue 'dispatch;
	}
	// 82C435C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C435C4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C435C8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C435CC: 4E800421  bctrl
	ctx.lr = 0x82C435D0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C435D0 => {
    //   block [0x82C435D0..0x82C435D8)
	// 82C435D0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C435D4: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x82C435D8; continue 'dispatch;
            }
            0x82C435D8 => {
    //   block [0x82C435D8..0x82C435E4)
	// 82C435D8: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82C435DC: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C435E0: 4082FFA0  bne 0x82c43580
	if !ctx.cr[0].eq {
	pc = 0x82C43580; continue 'dispatch;
	}
	pc = 0x82C435E4; continue 'dispatch;
            }
            0x82C435E4 => {
    //   block [0x82C435E4..0x82C435EC)
	// 82C435E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C435E8: 48065E74  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C435F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C435F0 size=196
    let mut pc: u32 = 0x82C435F0;
    'dispatch: loop {
        match pc {
            0x82C435F0 => {
    //   block [0x82C435F0..0x82C43628)
	// 82C435F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C435F4: 48065E0D  bl 0x82ca9400
	ctx.lr = 0x82C435F8;
	sub_82CA93D0(ctx, base);
	// 82C435F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C435FC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C43600: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C43604: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C43608: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4360C: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C43610: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43614: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C43618: 419A0010  beq cr6, 0x82c43628
	if ctx.cr[6].eq {
	pc = 0x82C43628; continue 'dispatch;
	}
	// 82C4361C: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C43620: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C43624: 419A0008  beq cr6, 0x82c4362c
	if ctx.cr[6].eq {
	pc = 0x82C4362C; continue 'dispatch;
	}
	pc = 0x82C43628; continue 'dispatch;
            }
            0x82C43628 => {
    //   block [0x82C43628..0x82C4362C)
	// 82C43628: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4362C; continue 'dispatch;
            }
            0x82C4362C => {
    //   block [0x82C4362C..0x82C436A4)
	// 82C4362C: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C43630: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C43634: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43638: 419A006C  beq cr6, 0x82c436a4
	if ctx.cr[6].eq {
	pc = 0x82C436A4; continue 'dispatch;
	}
	// 82C4363C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C43640: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C43644: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C43648: 835F0008  lwz r26, 8(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4364C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C43650: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C43654: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C43658: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C4365C: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C43660: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C43664: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43668: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C4366C: 4BFFE82D  bl 0x82c41e98
	ctx.lr = 0x82C43670;
	sub_82C41E98(ctx, base);
	// 82C43670: 7D1CD050  subf r8, r28, r26
	ctx.r[8].s64 = ctx.r[26].s64 - ctx.r[28].s64;
	// 82C43674: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43678: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82C4367C: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C43680: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C43684: 7D683BD6  divw r11, r8, r7
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82C43688: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C4368C: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C43690: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43694: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C43698: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4369C: 4BFFFD95  bl 0x82c43430
	ctx.lr = 0x82C436A0;
	sub_82C43430(ctx, base);
	// 82C436A0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82C436A4; continue 'dispatch;
            }
            0x82C436A4 => {
    //   block [0x82C436A4..0x82C436B4)
	// 82C436A4: FB7D0000  std r27, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 82C436A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C436AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C436B0: 48065DA0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C436B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C436B8 size=188
    let mut pc: u32 = 0x82C436B8;
    'dispatch: loop {
        match pc {
            0x82C436B8 => {
    //   block [0x82C436B8..0x82C436F0)
	// 82C436B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C436BC: 48065D45  bl 0x82ca9400
	ctx.lr = 0x82C436C0;
	sub_82CA93D0(ctx, base);
	// 82C436C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C436C4: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C436C8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C436CC: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 82C436D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C436D4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82C436D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C436DC: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82C436E0: 419A0010  beq cr6, 0x82c436f0
	if ctx.cr[6].eq {
	pc = 0x82C436F0; continue 'dispatch;
	}
	// 82C436E4: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82C436E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C436EC: 419A0008  beq cr6, 0x82c436f4
	if ctx.cr[6].eq {
	pc = 0x82C436F4; continue 'dispatch;
	}
	pc = 0x82C436F0; continue 'dispatch;
            }
            0x82C436F0 => {
    //   block [0x82C436F0..0x82C436F4)
	// 82C436F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C436F4; continue 'dispatch;
            }
            0x82C436F4 => {
    //   block [0x82C436F4..0x82C43764)
	// 82C436F4: 83C100B4  lwz r30, 0xb4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82C436F8: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82C436FC: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43700: 419A0064  beq cr6, 0x82c43764
	if ctx.cr[6].eq {
	pc = 0x82C43764; continue 'dispatch;
	}
	// 82C43704: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C43708: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C4370C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 82C43710: 835F0008  lwz r26, 8(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43714: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C43718: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4371C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C43720: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C43724: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 82C43728: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C4372C: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43730: 88E10051  lbz r7, 0x51(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C43734: 4BFFE815  bl 0x82c41f48
	ctx.lr = 0x82C43738;
	sub_82C41F48(ctx, base);
	// 82C43738: 7D1CD050  subf r8, r28, r26
	ctx.r[8].s64 = ctx.r[26].s64 - ctx.r[28].s64;
	// 82C4373C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43740: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 82C43744: 88C10051  lbz r6, 0x51(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 82C43748: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4374C: 7C683BD6  divw r3, r8, r7
	ctx.r[3].s32 = ctx.r[8].s32 / ctx.r[7].s32;
	// 82C43750: 1D63001C  mulli r11, r3, 0x1c
	ctx.r[11].s32 = ((ctx.r[3].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C43754: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C43758: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4375C: 4BFFFD35  bl 0x82c43490
	ctx.lr = 0x82C43760;
	sub_82C43490(ctx, base);
	// 82C43760: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82C43764; continue 'dispatch;
            }
            0x82C43764 => {
    //   block [0x82C43764..0x82C43774)
	// 82C43764: FB7D0000  std r27, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	// 82C43768: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4376C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43770: 48065CE0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43778 size=108
    let mut pc: u32 = 0x82C43778;
    'dispatch: loop {
        match pc {
            0x82C43778 => {
    //   block [0x82C43778..0x82C437E4)
	// 82C43778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4377C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C43780: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C43784: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C43788: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4378C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C43790: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43794: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C43798: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4379C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C437A0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C437A4: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C437A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C437AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C437B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C437B4: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C437B8: 4BFFFD39  bl 0x82c434f0
	ctx.lr = 0x82C437BC;
	sub_82C434F0(ctx, base);
	// 82C437BC: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C437C0: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 82C437C4: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C437C8: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C437CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C437D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C437D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C437D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C437DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C437E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C437E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C437E8 size=100
    let mut pc: u32 = 0x82C437E8;
    'dispatch: loop {
        match pc {
            0x82C437E8 => {
    //   block [0x82C437E8..0x82C4384C)
	// 82C437E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C437EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C437F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C437F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C437F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C437FC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C43800: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C43808: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4380C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C43810: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 82C43814: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 82C43818: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C4381C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C43820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43824: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43828: 4BFFFD39  bl 0x82c43560
	ctx.lr = 0x82C4382C;
	sub_82C43560(ctx, base);
	// 82C4382C: 1D7E001C  mulli r11, r30, 0x1c
	ctx.r[11].s32 = ((ctx.r[30].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C43830: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C43834: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C43838: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4383C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C43840: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C43844: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C43848: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43850(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43850 size=132
    let mut pc: u32 = 0x82C43850;
    'dispatch: loop {
        match pc {
            0x82C43850 => {
    //   block [0x82C43850..0x82C438C4)
	// 82C43850: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43854: 48065BB9  bl 0x82ca940c
	ctx.lr = 0x82C43858;
	sub_82CA93D0(ctx, base);
	// 82C43858: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4385C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43860: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C43864: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C43868: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C4386C: 392BC354  addi r9, r11, -0x3cac
	ctx.r[9].s64 = ctx.r[11].s64 + -15532;
	// 82C43870: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C43874: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C43878: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4387C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C43880: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C43884: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C43888: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C4388C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C43890: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C43894: 4BFF0A45  bl 0x82c342d8
	ctx.lr = 0x82C43898;
	sub_82C342D8(ctx, base);
	// 82C43898: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C4389C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C438A0: 38C7BB00  addi r6, r7, -0x4500
	ctx.r[6].s64 = ctx.r[7].s64 + -17664;
	// 82C438A4: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C438A8: 4BFEC619  bl 0x82c2fec0
	ctx.lr = 0x82C438AC;
	sub_82C2FEC0(ctx, base);
	// 82C438AC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C438B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C438B4: 419A0010  beq cr6, 0x82c438c4
	if ctx.cr[6].eq {
	pc = 0x82C438C4; continue 'dispatch;
	}
	// 82C438B8: 4BC01EF9  bl 0x828457b0
	ctx.lr = 0x82C438BC;
	sub_828457B0(ctx, base);
	// 82C438BC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C438C0: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C438C4; continue 'dispatch;
            }
            0x82C438C4 => {
    //   block [0x82C438C4..0x82C438D4)
	// 82C438C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C438C8: 4BFC2839  bl 0x82c06100
	ctx.lr = 0x82C438CC;
	sub_82C06100(ctx, base);
	// 82C438CC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C438D0: 48065B8C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C438D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C438D8 size=80
    let mut pc: u32 = 0x82C438D8;
    'dispatch: loop {
        match pc {
            0x82C438D8 => {
    //   block [0x82C438D8..0x82C43910)
	// 82C438D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C438DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C438E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C438E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C438E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C438EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C438F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C438F4: 4BFFFF5D  bl 0x82c43850
	ctx.lr = 0x82C438F8;
	sub_82C43850(ctx, base);
	// 82C438F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C438FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43904: 419A000C  beq cr6, 0x82c43910
	if ctx.cr[6].eq {
	pc = 0x82C43910; continue 'dispatch;
	}
	// 82C43908: 4BC01EA9  bl 0x828457b0
	ctx.lr = 0x82C4390C;
	sub_828457B0(ctx, base);
	// 82C4390C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C43910; continue 'dispatch;
            }
            0x82C43910 => {
    //   block [0x82C43910..0x82C43928)
	// 82C43910: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C43914: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C43918: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4391C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C43920: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C43924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43928 size=132
    let mut pc: u32 = 0x82C43928;
    'dispatch: loop {
        match pc {
            0x82C43928 => {
    //   block [0x82C43928..0x82C4399C)
	// 82C43928: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4392C: 48065AE1  bl 0x82ca940c
	ctx.lr = 0x82C43930;
	sub_82CA93D0(ctx, base);
	// 82C43930: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43934: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43938: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4393C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C43940: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C43944: 392BC360  addi r9, r11, -0x3ca0
	ctx.r[9].s64 = ctx.r[11].s64 + -15520;
	// 82C43948: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C4394C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C43950: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C43954: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C43958: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C4395C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C43960: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C43964: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C43968: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C4396C: 4BFF096D  bl 0x82c342d8
	ctx.lr = 0x82C43970;
	sub_82C342D8(ctx, base);
	// 82C43970: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C43974: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C43978: 38C7C380  addi r6, r7, -0x3c80
	ctx.r[6].s64 = ctx.r[7].s64 + -15488;
	// 82C4397C: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C43980: 4BFFEF99  bl 0x82c42918
	ctx.lr = 0x82C43984;
	sub_82C42918(ctx, base);
	// 82C43984: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4398C: 419A0010  beq cr6, 0x82c4399c
	if ctx.cr[6].eq {
	pc = 0x82C4399C; continue 'dispatch;
	}
	// 82C43990: 4BC01E21  bl 0x828457b0
	ctx.lr = 0x82C43994;
	sub_828457B0(ctx, base);
	// 82C43994: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C43998: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C4399C; continue 'dispatch;
            }
            0x82C4399C => {
    //   block [0x82C4399C..0x82C439AC)
	// 82C4399C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C439A0: 4BFC2761  bl 0x82c06100
	ctx.lr = 0x82C439A4;
	sub_82C06100(ctx, base);
	// 82C439A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C439A8: 48065AB4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C439B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C439B0 size=80
    let mut pc: u32 = 0x82C439B0;
    'dispatch: loop {
        match pc {
            0x82C439B0 => {
    //   block [0x82C439B0..0x82C439E8)
	// 82C439B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C439B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C439B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C439BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C439C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C439C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C439C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C439CC: 4BFFFF5D  bl 0x82c43928
	ctx.lr = 0x82C439D0;
	sub_82C43928(ctx, base);
	// 82C439D0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C439D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C439D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C439DC: 419A000C  beq cr6, 0x82c439e8
	if ctx.cr[6].eq {
	pc = 0x82C439E8; continue 'dispatch;
	}
	// 82C439E0: 4BC01DD1  bl 0x828457b0
	ctx.lr = 0x82C439E4;
	sub_828457B0(ctx, base);
	// 82C439E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C439E8; continue 'dispatch;
            }
            0x82C439E8 => {
    //   block [0x82C439E8..0x82C43A00)
	// 82C439E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C439EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C439F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C439F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C439F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C439FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43A00 size=268
    let mut pc: u32 = 0x82C43A00;
    'dispatch: loop {
        match pc {
            0x82C43A00 => {
    //   block [0x82C43A00..0x82C43A30)
	// 82C43A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43A04: 48065A01  bl 0x82ca9404
	ctx.lr = 0x82C43A08;
	sub_82CA93D0(ctx, base);
	// 82C43A08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43A0C: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 82C43A10: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C43A14: 616A5555  ori r10, r11, 0x5555
	ctx.r[10].u64 = ctx.r[11].u64 | 21845;
	// 82C43A18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43A1C: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C43A20: 40990010  ble cr6, 0x82c43a30
	if !ctx.cr[6].gt {
	pc = 0x82C43A30; continue 'dispatch;
	}
	// 82C43A24: 4BFBBA45  bl 0x82bff468
	ctx.lr = 0x82C43A28;
	sub_82BFF468(ctx, base);
	// 82C43A28: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43A2C: 48065A28  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C43A30 => {
    //   block [0x82C43A30..0x82C43A4C)
	// 82C43A30: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43A34: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 82C43A38: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C43A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43A40: 409A000C  bne cr6, 0x82c43a4c
	if !ctx.cr[6].eq {
	pc = 0x82C43A4C; continue 'dispatch;
	}
	// 82C43A44: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C43A48: 48000010  b 0x82c43a58
	pc = 0x82C43A58; continue 'dispatch;
            }
            0x82C43A4C => {
    //   block [0x82C43A4C..0x82C43A58)
	// 82C43A4C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C43A50: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C43A54: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x82C43A58; continue 'dispatch;
            }
            0x82C43A58 => {
    //   block [0x82C43A58..0x82C43A88)
	// 82C43A58: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43A5C: 409800A8  bge cr6, 0x82c43b04
	if !ctx.cr[6].lt {
	pc = 0x82C43B04; continue 'dispatch;
	}
	// 82C43A60: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C43A64: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C43A68: 4BFFE819  bl 0x82c42280
	ctx.lr = 0x82C43A6C;
	sub_82C42280(ctx, base);
	// 82C43A6C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43A70: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43A74: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43A78: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C43A7C: 4099000C  ble cr6, 0x82c43a88
	if !ctx.cr[6].gt {
	pc = 0x82C43A88; continue 'dispatch;
	}
	// 82C43A80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82C43A84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C43A88; continue 'dispatch;
            }
            0x82C43A88 => {
    //   block [0x82C43A88..0x82C43AD8)
	// 82C43A88: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C43A8C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43A90: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C43A94: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C43A98: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C43A9C: 9BAA0000  stb r29, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82C43AA0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43AA4: 4BFFF87D  bl 0x82c43320
	ctx.lr = 0x82C43AA8;
	sub_82C43320(ctx, base);
	// 82C43AA8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43AAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43AB0: 419A0028  beq cr6, 0x82c43ad8
	if ctx.cr[6].eq {
	pc = 0x82C43AD8; continue 'dispatch;
	}
	// 82C43AB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43AB8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C43ABC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43AC0: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C43AC4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C43AC8: 7FAADBD6  divw r29, r10, r27
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 82C43ACC: 4BFFF965  bl 0x82c43430
	ctx.lr = 0x82C43AD0;
	sub_82C43430(ctx, base);
	// 82C43AD0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43AD4: 4BC01CDD  bl 0x828457b0
	ctx.lr = 0x82C43AD8;
	sub_828457B0(ctx, base);
	pc = 0x82C43AD8; continue 'dispatch;
            }
            0x82C43AD8 => {
    //   block [0x82C43AD8..0x82C43B04)
	// 82C43AD8: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43ADC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C43AE0: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C43AE4: 7D3D5A14  add r9, r29, r11
	ctx.r[9].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C43AE8: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 82C43AEC: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43AF0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C43AF4: 7CEBF214  add r7, r11, r30
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C43AF8: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C43AFC: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 82C43B00: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	pc = 0x82C43B04; continue 'dispatch;
            }
            0x82C43B04 => {
    //   block [0x82C43B04..0x82C43B0C)
	// 82C43B04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43B08: 4806594C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43B10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43B10 size=252
    let mut pc: u32 = 0x82C43B10;
    'dispatch: loop {
        match pc {
            0x82C43B10 => {
    //   block [0x82C43B10..0x82C43B40)
	// 82C43B10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43B14: 480658F1  bl 0x82ca9404
	ctx.lr = 0x82C43B18;
	sub_82CA93D0(ctx, base);
	// 82C43B18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43B1C: 3D600924  lis r11, 0x924
	ctx.r[11].s64 = 153354240;
	// 82C43B20: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C43B24: 616A9249  ori r10, r11, 0x9249
	ctx.r[10].u64 = ctx.r[11].u64 | 37449;
	// 82C43B28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43B2C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C43B30: 40990010  ble cr6, 0x82c43b40
	if !ctx.cr[6].gt {
	pc = 0x82C43B40; continue 'dispatch;
	}
	// 82C43B34: 4BFBB935  bl 0x82bff468
	ctx.lr = 0x82C43B38;
	sub_82BFF468(ctx, base);
	// 82C43B38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43B3C: 48065918  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C43B40 => {
    //   block [0x82C43B40..0x82C43B5C)
	// 82C43B40: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43B44: 3B80001C  li r28, 0x1c
	ctx.r[28].s64 = 28;
	// 82C43B48: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C43B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C43B50: 409A000C  bne cr6, 0x82c43b5c
	if !ctx.cr[6].eq {
	pc = 0x82C43B5C; continue 'dispatch;
	}
	// 82C43B54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82C43B58: 48000010  b 0x82c43b68
	pc = 0x82C43B68; continue 'dispatch;
            }
            0x82C43B5C => {
    //   block [0x82C43B5C..0x82C43B68)
	// 82C43B5C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C43B60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C43B64: 7D69E3D6  divw r11, r9, r28
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[28].s32;
	pc = 0x82C43B68; continue 'dispatch;
            }
            0x82C43B68 => {
    //   block [0x82C43B68..0x82C43B98)
	// 82C43B68: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C43B6C: 40980098  bge cr6, 0x82c43c04
	if !ctx.cr[6].lt {
	pc = 0x82C43C04; continue 'dispatch;
	}
	// 82C43B70: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C43B74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43B78: 4BFFEA19  bl 0x82c42590
	ctx.lr = 0x82C43B7C;
	sub_82C42590(ctx, base);
	// 82C43B7C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43B80: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43B84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43B88: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C43B8C: 4099000C  ble cr6, 0x82c43b98
	if !ctx.cr[6].gt {
	pc = 0x82C43B98; continue 'dispatch;
	}
	// 82C43B90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82C43B94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C43B98; continue 'dispatch;
            }
            0x82C43B98 => {
    //   block [0x82C43B98..0x82C43BE8)
	// 82C43B98: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C43B9C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43BA0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C43BA4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C43BA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C43BAC: 9BAA0000  stb r29, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 82C43BB0: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43BB4: 4BFFF7E5  bl 0x82c43398
	ctx.lr = 0x82C43BB8;
	sub_82C43398(ctx, base);
	// 82C43BB8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43BBC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43BC0: 419A0028  beq cr6, 0x82c43be8
	if ctx.cr[6].eq {
	pc = 0x82C43BE8; continue 'dispatch;
	}
	// 82C43BC4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43BC8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C43BCC: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43BD0: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C43BD4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C43BD8: 7FAAE3D6  divw r29, r10, r28
	ctx.r[29].s32 = ctx.r[10].s32 / ctx.r[28].s32;
	// 82C43BDC: 4BFFF8B5  bl 0x82c43490
	ctx.lr = 0x82C43BE0;
	sub_82C43490(ctx, base);
	// 82C43BE0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43BE4: 4BC01BCD  bl 0x828457b0
	ctx.lr = 0x82C43BE8;
	sub_828457B0(ctx, base);
	pc = 0x82C43BE8; continue 'dispatch;
            }
            0x82C43BE8 => {
    //   block [0x82C43BE8..0x82C43C04)
	// 82C43BE8: 1D5B001C  mulli r10, r27, 0x1c
	ctx.r[10].s32 = ((ctx.r[27].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C43BEC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C43BF0: 1D7D001C  mulli r11, r29, 0x1c
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C43BF4: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C43BF8: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C43BFC: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C43C00: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82C43C04; continue 'dispatch;
            }
            0x82C43C04 => {
    //   block [0x82C43C04..0x82C43C0C)
	// 82C43C04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C43C08: 4806584C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43C10 size=768
    let mut pc: u32 = 0x82C43C10;
    'dispatch: loop {
        match pc {
            0x82C43C10 => {
    //   block [0x82C43C10..0x82C43C5C)
	// 82C43C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43C14: 480657E5  bl 0x82ca93f8
	ctx.lr = 0x82C43C18;
	sub_82CA93D0(ctx, base);
	// 82C43C18: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43C1C: 83060008  lwz r24, 8(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43C20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43C24: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43C28: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82C43C2C: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43C30: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C43C34: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 82C43C38: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 82C43C3C: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C43C40: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C43C44: 419A0018  beq cr6, 0x82c43c5c
	if ctx.cr[6].eq {
	pc = 0x82C43C5C; continue 'dispatch;
	}
	// 82C43C48: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43C4C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C43C50: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43C54: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43C58: 4E800421  bctrl
	ctx.lr = 0x82C43C5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43C5C => {
    //   block [0x82C43C5C..0x82C43C78)
	// 82C43C5C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43C60: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 82C43C64: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C43C68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43C6C: 409A000C  bne cr6, 0x82c43c78
	if !ctx.cr[6].eq {
	pc = 0x82C43C78; continue 'dispatch;
	}
	// 82C43C70: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82C43C74: 48000010  b 0x82c43c84
	pc = 0x82C43C84; continue 'dispatch;
            }
            0x82C43C78 => {
    //   block [0x82C43C78..0x82C43C84)
	// 82C43C78: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C43C7C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43C80: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43C84; continue 'dispatch;
            }
            0x82C43C84 => {
    //   block [0x82C43C84..0x82C43C9C)
	// 82C43C84: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C43C88: 419A0264  beq cr6, 0x82c43eec
	if ctx.cr[6].eq {
	pc = 0x82C43EEC; continue 'dispatch;
	}
	// 82C43C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43C90: 409A000C  bne cr6, 0x82c43c9c
	if !ctx.cr[6].eq {
	pc = 0x82C43C9C; continue 'dispatch;
	}
	// 82C43C94: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43C98: 48000010  b 0x82c43ca8
	pc = 0x82C43CA8; continue 'dispatch;
            }
            0x82C43C9C => {
    //   block [0x82C43C9C..0x82C43CA8)
	// 82C43C9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43CA0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43CA4: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43CA8; continue 'dispatch;
            }
            0x82C43CA8 => {
    //   block [0x82C43CA8..0x82C43CC4)
	// 82C43CA8: 3D201555  lis r9, 0x1555
	ctx.r[9].s64 = 357892096;
	// 82C43CAC: 61295555  ori r9, r9, 0x5555
	ctx.r[9].u64 = ctx.r[9].u64 | 21845;
	// 82C43CB0: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C43CB4: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43CB8: 4098000C  bge cr6, 0x82c43cc4
	if !ctx.cr[6].lt {
	pc = 0x82C43CC4; continue 'dispatch;
	}
	// 82C43CBC: 4BFBB7AD  bl 0x82bff468
	ctx.lr = 0x82C43CC0;
	sub_82BFF468(ctx, base);
	// 82C43CC0: 4800022C  b 0x82c43eec
	pc = 0x82C43EEC; continue 'dispatch;
            }
            0x82C43CC4 => {
    //   block [0x82C43CC4..0x82C43CD4)
	// 82C43CC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43CC8: 409A000C  bne cr6, 0x82c43cd4
	if !ctx.cr[6].eq {
	pc = 0x82C43CD4; continue 'dispatch;
	}
	// 82C43CCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43CD0: 48000010  b 0x82c43ce0
	pc = 0x82C43CE0; continue 'dispatch;
            }
            0x82C43CD4 => {
    //   block [0x82C43CD4..0x82C43CE0)
	// 82C43CD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43CD8: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43CDC: 7D67D3D6  divw r11, r7, r26
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	pc = 0x82C43CE0; continue 'dispatch;
            }
            0x82C43CE0 => {
    //   block [0x82C43CE0..0x82C43D04)
	// 82C43CE0: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C43CE4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C43CE8: 4098014C  bge cr6, 0x82c43e34
	if !ctx.cr[6].lt {
	pc = 0x82C43E34; continue 'dispatch;
	}
	// 82C43CEC: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43CF0: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 82C43CF4: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C43CF8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C43CFC: 41980008  blt cr6, 0x82c43d04
	if ctx.cr[6].lt {
	pc = 0x82C43D04; continue 'dispatch;
	}
	// 82C43D00: 7F6B4214  add r27, r11, r8
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x82C43D04; continue 'dispatch;
            }
            0x82C43D04 => {
    //   block [0x82C43D04..0x82C43D14)
	// 82C43D04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43D08: 409A000C  bne cr6, 0x82c43d14
	if !ctx.cr[6].eq {
	pc = 0x82C43D14; continue 'dispatch;
	}
	// 82C43D0C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43D10: 48000010  b 0x82c43d20
	pc = 0x82C43D20; continue 'dispatch;
            }
            0x82C43D14 => {
    //   block [0x82C43D14..0x82C43D20)
	// 82C43D14: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43D18: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43D1C: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43D20; continue 'dispatch;
            }
            0x82C43D20 => {
    //   block [0x82C43D20..0x82C43D3C)
	// 82C43D20: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C43D24: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C43D28: 40980024  bge cr6, 0x82c43d4c
	if !ctx.cr[6].lt {
	pc = 0x82C43D4C; continue 'dispatch;
	}
	// 82C43D2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43D30: 409A000C  bne cr6, 0x82c43d3c
	if !ctx.cr[6].eq {
	pc = 0x82C43D3C; continue 'dispatch;
	}
	// 82C43D34: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43D38: 48000010  b 0x82c43d48
	pc = 0x82C43D48; continue 'dispatch;
            }
            0x82C43D3C => {
    //   block [0x82C43D3C..0x82C43D48)
	// 82C43D3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43D40: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43D44: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C43D48; continue 'dispatch;
            }
            0x82C43D48 => {
    //   block [0x82C43D48..0x82C43D4C)
	// 82C43D48: 7F6BE214  add r27, r11, r28
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	pc = 0x82C43D4C; continue 'dispatch;
            }
            0x82C43D4C => {
    //   block [0x82C43D4C..0x82C43DD4)
	// 82C43D4C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C43D50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C43D54: 4BFFE52D  bl 0x82c42280
	ctx.lr = 0x82C43D58;
	sub_82C42280(ctx, base);
	// 82C43D58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C43D5C: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43D60: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C43D64: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43D68: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C43D6C: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C43D70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C43D74: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C43D78: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C43D7C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C43D80: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43D84: 4BFFF59D  bl 0x82c43320
	ctx.lr = 0x82C43D88;
	sub_82C43320(ctx, base);
	// 82C43D88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C43D8C: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82C43D90: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C43D94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43D98: 4BFFF9E1  bl 0x82c43778
	ctx.lr = 0x82C43D9C;
	sub_82C43778(ctx, base);
	// 82C43D9C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C43DA0: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43DA4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C43DA8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C43DAC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43DB0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C43DB4: 9B290000  stb r25, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C43DB8: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43DBC: 4BFFF565  bl 0x82c43320
	ctx.lr = 0x82C43DC0;
	sub_82C43320(ctx, base);
	// 82C43DC0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43DC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43DC8: 409A000C  bne cr6, 0x82c43dd4
	if !ctx.cr[6].eq {
	pc = 0x82C43DD4; continue 'dispatch;
	}
	// 82C43DCC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43DD0: 48000010  b 0x82c43de0
	pc = 0x82C43DE0; continue 'dispatch;
            }
            0x82C43DD4 => {
    //   block [0x82C43DD4..0x82C43DE0)
	// 82C43DD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43DD8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C43DDC: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C43DE0; continue 'dispatch;
            }
            0x82C43DE0 => {
    //   block [0x82C43DE0..0x82C43E04)
	// 82C43DE0: 7FABE214  add r29, r11, r28
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C43DE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C43DE8: 419A001C  beq cr6, 0x82c43e04
	if ctx.cr[6].eq {
	pc = 0x82C43E04; continue 'dispatch;
	}
	// 82C43DEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C43DF0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43DF4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43DF8: 4BFFF639  bl 0x82c43430
	ctx.lr = 0x82C43DFC;
	sub_82C43430(ctx, base);
	// 82C43DFC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43E00: 4BC019B1  bl 0x828457b0
	ctx.lr = 0x82C43E04;
	sub_828457B0(ctx, base);
	pc = 0x82C43E04; continue 'dispatch;
            }
            0x82C43E04 => {
    //   block [0x82C43E04..0x82C43E34)
	// 82C43E04: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43E08: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C43E0C: 57AA083C  slwi r10, r29, 1
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C43E10: 7D7B5A14  add r11, r27, r11
	ctx.r[11].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82C43E14: 7D5D5214  add r10, r29, r10
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[10].u64;
	// 82C43E18: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43E1C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C43E20: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C43E24: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C43E28: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 82C43E2C: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C43E30: 480000B8  b 0x82c43ee8
	pc = 0x82C43EE8; continue 'dispatch;
            }
            0x82C43E34 => {
    //   block [0x82C43E34..0x82C43EAC)
	// 82C43E34: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43E38: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C43E3C: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 82C43E40: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43E44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C43E48: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C43E4C: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 82C43E50: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43E54: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C43E58: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C43E5C: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 82C43E60: 9B2A0000  stb r25, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C43E64: 40980048  bge cr6, 0x82c43eac
	if !ctx.cr[6].lt {
	pc = 0x82C43EAC; continue 'dispatch;
	}
	// 82C43E68: 553D103A  slwi r29, r9, 2
	ctx.r[29].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 82C43E6C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C43E70: 7CBDF214  add r5, r29, r30
	ctx.r[5].u64 = ctx.r[29].u64 + ctx.r[30].u64;
	// 82C43E74: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43E78: 4BFFF4A9  bl 0x82c43320
	ctx.lr = 0x82C43E7C;
	sub_82C43320(ctx, base);
	// 82C43E7C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43E80: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82C43E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C43E88: 7D1E2050  subf r8, r30, r4
	ctx.r[8].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C43E8C: 7CE8D3D6  divw r7, r8, r26
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[26].s32;
	// 82C43E90: 7CA7E050  subf r5, r7, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[7].s64;
	// 82C43E94: 4BFFF8E5  bl 0x82c43778
	ctx.lr = 0x82C43E98;
	sub_82C43778(ctx, base);
	// 82C43E98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43E9C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 82C43EA0: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C43EA4: 7C9D5850  subf r4, r29, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 82C43EA8: 48000034  b 0x82c43edc
	pc = 0x82C43EDC; continue 'dispatch;
            }
            0x82C43EAC => {
    //   block [0x82C43EAC..0x82C43EDC)
	// 82C43EAC: 553C103A  slwi r28, r9, 2
	ctx.r[28].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 82C43EB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C43EB4: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82C43EB8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C43EBC: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C43EC0: 4BFFF461  bl 0x82c43320
	ctx.lr = 0x82C43EC4;
	sub_82C43320(ctx, base);
	// 82C43EC4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C43EC8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C43ECC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C43ED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C43ED4: 4BFFED3D  bl 0x82c42c10
	ctx.lr = 0x82C43ED8;
	sub_82C42C10(ctx, base);
	// 82C43ED8: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	pc = 0x82C43EDC; continue 'dispatch;
            }
            0x82C43EDC => {
    //   block [0x82C43EDC..0x82C43EE8)
	// 82C43EDC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82C43EE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C43EE4: 4BFFE415  bl 0x82c422f8
	ctx.lr = 0x82C43EE8;
	sub_82C422F8(ctx, base);
	pc = 0x82C43EE8; continue 'dispatch;
            }
            0x82C43EE8 => {
    //   block [0x82C43EE8..0x82C43EEC)
	// 82C43EE8: 83010060  lwz r24, 0x60(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x82C43EEC; continue 'dispatch;
            }
            0x82C43EEC => {
    //   block [0x82C43EEC..0x82C43F08)
	// 82C43EEC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 82C43EF0: 419A0018  beq cr6, 0x82c43f08
	if ctx.cr[6].eq {
	pc = 0x82C43F08; continue 'dispatch;
	}
	// 82C43EF4: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C43EF8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82C43EFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43F00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C43F04: 4E800421  bctrl
	ctx.lr = 0x82C43F08;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C43F08 => {
    //   block [0x82C43F08..0x82C43F10)
	// 82C43F08: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C43F0C: 4806553C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C43F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C43F10 size=696
    let mut pc: u32 = 0x82C43F10;
    'dispatch: loop {
        match pc {
            0x82C43F10 => {
    //   block [0x82C43F10..0x82C43F50)
	// 82C43F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C43F14: 480654E9  bl 0x82ca93fc
	ctx.lr = 0x82C43F18;
	sub_82CA93D0(ctx, base);
	// 82C43F18: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C43F1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C43F20: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 82C43F24: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 82C43F28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C43F2C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82C43F30: 4BFFE2C9  bl 0x82c421f8
	ctx.lr = 0x82C43F34;
	sub_82C421F8(ctx, base);
	// 82C43F34: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C43F38: 3B40001C  li r26, 0x1c
	ctx.r[26].s64 = 28;
	// 82C43F3C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82C43F40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43F44: 409A000C  bne cr6, 0x82c43f50
	if !ctx.cr[6].eq {
	pc = 0x82C43F50; continue 'dispatch;
	}
	// 82C43F48: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 82C43F4C: 48000010  b 0x82c43f5c
	pc = 0x82C43F5C; continue 'dispatch;
            }
            0x82C43F50 => {
    //   block [0x82C43F50..0x82C43F5C)
	// 82C43F50: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C43F54: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43F58: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43F5C; continue 'dispatch;
            }
            0x82C43F5C => {
    //   block [0x82C43F5C..0x82C43F74)
	// 82C43F5C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C43F60: 419A0244  beq cr6, 0x82c441a4
	if ctx.cr[6].eq {
	pc = 0x82C441A4; continue 'dispatch;
	}
	// 82C43F64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43F68: 409A000C  bne cr6, 0x82c43f74
	if !ctx.cr[6].eq {
	pc = 0x82C43F74; continue 'dispatch;
	}
	// 82C43F6C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43F70: 48000010  b 0x82c43f80
	pc = 0x82C43F80; continue 'dispatch;
            }
            0x82C43F74 => {
    //   block [0x82C43F74..0x82C43F80)
	// 82C43F74: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43F78: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43F7C: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43F80; continue 'dispatch;
            }
            0x82C43F80 => {
    //   block [0x82C43F80..0x82C43F9C)
	// 82C43F80: 3D200924  lis r9, 0x924
	ctx.r[9].s64 = 153354240;
	// 82C43F84: 61299249  ori r9, r9, 0x9249
	ctx.r[9].u64 = ctx.r[9].u64 | 37449;
	// 82C43F88: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C43F8C: 7F07D840  cmplw cr6, r7, r27
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C43F90: 4098000C  bge cr6, 0x82c43f9c
	if !ctx.cr[6].lt {
	pc = 0x82C43F9C; continue 'dispatch;
	}
	// 82C43F94: 4BFBB4D5  bl 0x82bff468
	ctx.lr = 0x82C43F98;
	sub_82BFF468(ctx, base);
	// 82C43F98: 4800020C  b 0x82c441a4
	pc = 0x82C441A4; continue 'dispatch;
            }
            0x82C43F9C => {
    //   block [0x82C43F9C..0x82C43FAC)
	// 82C43F9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43FA0: 409A000C  bne cr6, 0x82c43fac
	if !ctx.cr[6].eq {
	pc = 0x82C43FAC; continue 'dispatch;
	}
	// 82C43FA4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43FA8: 48000010  b 0x82c43fb8
	pc = 0x82C43FB8; continue 'dispatch;
            }
            0x82C43FAC => {
    //   block [0x82C43FAC..0x82C43FB8)
	// 82C43FAC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43FB0: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43FB4: 7D67D3D6  divw r11, r7, r26
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[26].s32;
	pc = 0x82C43FB8; continue 'dispatch;
            }
            0x82C43FB8 => {
    //   block [0x82C43FB8..0x82C43FDC)
	// 82C43FB8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C43FBC: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C43FC0: 4098013C  bge cr6, 0x82c440fc
	if !ctx.cr[6].lt {
	pc = 0x82C440FC; continue 'dispatch;
	}
	// 82C43FC4: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C43FC8: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 82C43FCC: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C43FD0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C43FD4: 41980008  blt cr6, 0x82c43fdc
	if ctx.cr[6].lt {
	pc = 0x82C43FDC; continue 'dispatch;
	}
	// 82C43FD8: 7F8B4214  add r28, r11, r8
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x82C43FDC; continue 'dispatch;
            }
            0x82C43FDC => {
    //   block [0x82C43FDC..0x82C43FEC)
	// 82C43FDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C43FE0: 409A000C  bne cr6, 0x82c43fec
	if !ctx.cr[6].eq {
	pc = 0x82C43FEC; continue 'dispatch;
	}
	// 82C43FE4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C43FE8: 48000010  b 0x82c43ff8
	pc = 0x82C43FF8; continue 'dispatch;
            }
            0x82C43FEC => {
    //   block [0x82C43FEC..0x82C43FF8)
	// 82C43FEC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C43FF0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C43FF4: 7D69D3D6  divw r11, r9, r26
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x82C43FF8; continue 'dispatch;
            }
            0x82C43FF8 => {
    //   block [0x82C43FF8..0x82C44014)
	// 82C43FF8: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C43FFC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44000: 40980024  bge cr6, 0x82c44024
	if !ctx.cr[6].lt {
	pc = 0x82C44024; continue 'dispatch;
	}
	// 82C44004: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C44008: 409A000C  bne cr6, 0x82c44014
	if !ctx.cr[6].eq {
	pc = 0x82C44014; continue 'dispatch;
	}
	// 82C4400C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C44010: 48000010  b 0x82c44020
	pc = 0x82C44020; continue 'dispatch;
            }
            0x82C44014 => {
    //   block [0x82C44014..0x82C44020)
	// 82C44014: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44018: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C4401C: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C44020; continue 'dispatch;
            }
            0x82C44020 => {
    //   block [0x82C44020..0x82C44024)
	// 82C44020: 7F8BDA14  add r28, r11, r27
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x82C44024; continue 'dispatch;
            }
            0x82C44024 => {
    //   block [0x82C44024..0x82C440AC)
	// 82C44024: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C44028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4402C: 4BFFE565  bl 0x82c42590
	ctx.lr = 0x82C44030;
	sub_82C42590(ctx, base);
	// 82C44030: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C44034: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C44038: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C4403C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44040: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C44044: 83A100DC  lwz r29, 0xdc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C44048: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C4404C: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82C44050: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C44054: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C44058: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4405C: 4BFFF33D  bl 0x82c43398
	ctx.lr = 0x82C44060;
	sub_82C43398(ctx, base);
	// 82C44060: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C44064: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C44068: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82C4406C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C44070: 4BFFF779  bl 0x82c437e8
	ctx.lr = 0x82C44074;
	sub_82C437E8(ctx, base);
	// 82C44074: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C44078: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4407C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82C44080: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C44084: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44088: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C4408C: 9B290000  stb r25, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C44090: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C44094: 4BFFF305  bl 0x82c43398
	ctx.lr = 0x82C44098;
	sub_82C43398(ctx, base);
	// 82C44098: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4409C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C440A0: 409A000C  bne cr6, 0x82c440ac
	if !ctx.cr[6].eq {
	pc = 0x82C440AC; continue 'dispatch;
	}
	// 82C440A4: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 82C440A8: 48000010  b 0x82c440b8
	pc = 0x82C440B8; continue 'dispatch;
            }
            0x82C440AC => {
    //   block [0x82C440AC..0x82C440B8)
	// 82C440AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C440B0: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82C440B4: 7D6AD3D6  divw r11, r10, r26
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	pc = 0x82C440B8; continue 'dispatch;
            }
            0x82C440B8 => {
    //   block [0x82C440B8..0x82C440DC)
	// 82C440B8: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82C440BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C440C0: 419A001C  beq cr6, 0x82c440dc
	if ctx.cr[6].eq {
	pc = 0x82C440DC; continue 'dispatch;
	}
	// 82C440C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C440C8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C440CC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C440D0: 4BFFF3C1  bl 0x82c43490
	ctx.lr = 0x82C440D4;
	sub_82C43490(ctx, base);
	// 82C440D4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C440D8: 4BC016D9  bl 0x828457b0
	ctx.lr = 0x82C440DC;
	sub_828457B0(ctx, base);
	pc = 0x82C440DC; continue 'dispatch;
            }
            0x82C440DC => {
    //   block [0x82C440DC..0x82C440FC)
	// 82C440DC: 1D7C001C  mulli r11, r28, 0x1c
	ctx.r[11].s32 = ((ctx.r[28].s32 as i64 * 28 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82C440E0: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C440E4: 1D5D001C  mulli r10, r29, 0x1c
	ctx.r[10].s32 = ((ctx.r[29].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C440E8: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 82C440EC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 82C440F0: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C440F4: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C440F8: 480000AC  b 0x82c441a4
	pc = 0x82C441A4; continue 'dispatch;
            }
            0x82C440FC => {
    //   block [0x82C440FC..0x82C4416C)
	// 82C440FC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44100: 1F9B001C  mulli r28, r27, 0x1c
	ctx.r[28].s32 = ((ctx.r[27].s32 as i64 * 28 as i64) as i32);
	ctx.r[28].s64 = ctx.r[28].s32 as i64;
	// 82C44104: 83C100DC  lwz r30, 0xdc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 82C44108: 88E10050  lbz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4410C: 7D7EE850  subf r11, r30, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[30].s64;
	// 82C44110: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C44114: 7D4BD3D6  divw r10, r11, r26
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[26].s32;
	// 82C44118: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82C4411C: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82C44120: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C44124: 9B2B0000  stb r25, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u8 ) };
	// 82C44128: 40980044  bge cr6, 0x82c4416c
	if !ctx.cr[6].lt {
	pc = 0x82C4416C; continue 'dispatch;
	}
	// 82C4412C: 7CBCF214  add r5, r28, r30
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	// 82C44130: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C44134: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C44138: 4BFFF261  bl 0x82c43398
	ctx.lr = 0x82C4413C;
	sub_82C43398(ctx, base);
	// 82C4413C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44140: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 82C44144: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C44148: 7D5E2050  subf r10, r30, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82C4414C: 7D2AD3D6  divw r9, r10, r26
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 82C44150: 7CA9D850  subf r5, r9, r27
	ctx.r[5].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 82C44154: 4BFFF695  bl 0x82c437e8
	ctx.lr = 0x82C44158;
	sub_82C437E8(ctx, base);
	// 82C44158: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4415C: 7D6BE214  add r11, r11, r28
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 82C44160: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C44164: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 82C44168: 48000030  b 0x82c44198
	pc = 0x82C44198; continue 'dispatch;
            }
            0x82C4416C => {
    //   block [0x82C4416C..0x82C44198)
	// 82C4416C: 7F7CE850  subf r27, r28, r29
	ctx.r[27].s64 = ctx.r[29].s64 - ctx.r[28].s64;
	// 82C44170: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C44174: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C44178: 89010050  lbz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4417C: 4BFFF21D  bl 0x82c43398
	ctx.lr = 0x82C44180;
	sub_82C43398(ctx, base);
	// 82C44180: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 82C44184: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C44188: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4418C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C44190: 4BFFEAE1  bl 0x82c42c70
	ctx.lr = 0x82C44194;
	sub_82C42C70(ctx, base);
	// 82C44194: 7C9CF214  add r4, r28, r30
	ctx.r[4].u64 = ctx.r[28].u64 + ctx.r[30].u64;
	pc = 0x82C44198; continue 'dispatch;
            }
            0x82C44198 => {
    //   block [0x82C44198..0x82C441A4)
	// 82C44198: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C4419C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C441A0: 4BFFE1F9  bl 0x82c42398
	ctx.lr = 0x82C441A4;
	sub_82C42398(ctx, base);
	pc = 0x82C441A4; continue 'dispatch;
            }
            0x82C441A4 => {
    //   block [0x82C441A4..0x82C441C0)
	// 82C441A4: 80610074  lwz r3, 0x74(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 82C441A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C441AC: 419A0014  beq cr6, 0x82c441c0
	if ctx.cr[6].eq {
	pc = 0x82C441C0; continue 'dispatch;
	}
	// 82C441B0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C441B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C441B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C441BC: 4E800421  bctrl
	ctx.lr = 0x82C441C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C441C0 => {
    //   block [0x82C441C0..0x82C441C8)
	// 82C441C0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82C441C4: 48065288  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C441C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C441C8 size=300
    let mut pc: u32 = 0x82C441C8;
    'dispatch: loop {
        match pc {
            0x82C441C8 => {
    //   block [0x82C441C8..0x82C441F8)
	// 82C441C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C441CC: 48065241  bl 0x82ca940c
	ctx.lr = 0x82C441D0;
	sub_82CA93D0(ctx, base);
	// 82C441D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C441D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C441D8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C441DC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 82C441E0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C441E4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C441E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C441EC: 409A000C  bne cr6, 0x82c441f8
	if !ctx.cr[6].eq {
	pc = 0x82C441F8; continue 'dispatch;
	}
	// 82C441F0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 82C441F4: 48000010  b 0x82c44204
	pc = 0x82C44204; continue 'dispatch;
            }
            0x82C441F8 => {
    //   block [0x82C441F8..0x82C44204)
	// 82C441F8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C441FC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44200: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C44204; continue 'dispatch;
            }
            0x82C44204 => {
    //   block [0x82C44204..0x82C4421C)
	// 82C44204: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C44208: 40980050  bge cr6, 0x82c44258
	if !ctx.cr[6].lt {
	pc = 0x82C44258; continue 'dispatch;
	}
	// 82C4420C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44210: 409A000C  bne cr6, 0x82c4421c
	if !ctx.cr[6].eq {
	pc = 0x82C4421C; continue 'dispatch;
	}
	// 82C44214: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 82C44218: 48000010  b 0x82c44228
	pc = 0x82C44228; continue 'dispatch;
            }
            0x82C4421C => {
    //   block [0x82C4421C..0x82C44228)
	// 82C4421C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44220: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44224: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C44228; continue 'dispatch;
            }
            0x82C44228 => {
    //   block [0x82C44228..0x82C44238)
	// 82C44228: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4422C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44230: 40990008  ble cr6, 0x82c44238
	if !ctx.cr[6].gt {
	pc = 0x82C44238; continue 'dispatch;
	}
	// 82C44234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44238; continue 'dispatch;
            }
            0x82C44238 => {
    //   block [0x82C44238..0x82C44258)
	// 82C44238: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C4423C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C44240: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 82C44244: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C44248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4424C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C44250: 4BFFF9C1  bl 0x82c43c10
	ctx.lr = 0x82C44254;
	sub_82C43C10(ctx, base);
	// 82C44254: 48000070  b 0x82c442c4
	pc = 0x82C442C4; continue 'dispatch;
            }
            0x82C44258 => {
    //   block [0x82C44258..0x82C44280)
	// 82C44258: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4425C: 419A0068  beq cr6, 0x82c442c4
	if ctx.cr[6].eq {
	pc = 0x82C442C4; continue 'dispatch;
	}
	// 82C44260: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44264: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44268: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C4426C: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C44270: 40980054  bge cr6, 0x82c442c4
	if !ctx.cr[6].lt {
	pc = 0x82C442C4; continue 'dispatch;
	}
	// 82C44274: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44278: 40990008  ble cr6, 0x82c44280
	if !ctx.cr[6].gt {
	pc = 0x82C44280; continue 'dispatch;
	}
	// 82C4427C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44280; continue 'dispatch;
            }
            0x82C44280 => {
    //   block [0x82C44280..0x82C44294)
	// 82C44280: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C44284: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44288: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C4428C: 40990008  ble cr6, 0x82c44294
	if !ctx.cr[6].gt {
	pc = 0x82C44294; continue 'dispatch;
	}
	// 82C44290: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44294; continue 'dispatch;
            }
            0x82C44294 => {
    //   block [0x82C44294..0x82C442C4)
	// 82C44294: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C44298: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82C4429C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C442A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C442A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C442A8: 4BFFE359  bl 0x82c42600
	ctx.lr = 0x82C442AC;
	sub_82C42600(ctx, base);
	// 82C442AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C442B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C442B4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C442B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C442BC: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82C442C0: 4BFFF331  bl 0x82c435f0
	ctx.lr = 0x82C442C4;
	sub_82C435F0(ctx, base);
	pc = 0x82C442C4; continue 'dispatch;
            }
            0x82C442C4 => {
    //   block [0x82C442C4..0x82C442E4)
	// 82C442C4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C442C8: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82C442CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C442D0: 419A0014  beq cr6, 0x82c442e4
	if ctx.cr[6].eq {
	pc = 0x82C442E4; continue 'dispatch;
	}
	// 82C442D4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C442D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C442DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C442E0: 4E800421  bctrl
	ctx.lr = 0x82C442E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C442E4 => {
    //   block [0x82C442E4..0x82C442F4)
	// 82C442E4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C442E8: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82C442EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C442F0: 4806516C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C442F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C442F8 size=344
    let mut pc: u32 = 0x82C442F8;
    'dispatch: loop {
        match pc {
            0x82C442F8 => {
    //   block [0x82C442F8..0x82C4432C)
	// 82C442F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C442FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C44300: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C44304: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C44308: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4430C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44310: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C44314: 3920001C  li r9, 0x1c
	ctx.r[9].s64 = 28;
	// 82C44318: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C4431C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44320: 409A000C  bne cr6, 0x82c4432c
	if !ctx.cr[6].eq {
	pc = 0x82C4432C; continue 'dispatch;
	}
	// 82C44324: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 82C44328: 48000010  b 0x82c44338
	pc = 0x82C44338; continue 'dispatch;
            }
            0x82C4432C => {
    //   block [0x82C4432C..0x82C44338)
	// 82C4432C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44330: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44334: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C44338; continue 'dispatch;
            }
            0x82C44338 => {
    //   block [0x82C44338..0x82C44350)
	// 82C44338: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 82C4433C: 4098004C  bge cr6, 0x82c44388
	if !ctx.cr[6].lt {
	pc = 0x82C44388; continue 'dispatch;
	}
	// 82C44340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44344: 409A000C  bne cr6, 0x82c44350
	if !ctx.cr[6].eq {
	pc = 0x82C44350; continue 'dispatch;
	}
	// 82C44348: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 82C4434C: 48000010  b 0x82c4435c
	pc = 0x82C4435C; continue 'dispatch;
            }
            0x82C44350 => {
    //   block [0x82C44350..0x82C4435C)
	// 82C44350: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44354: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44358: 7D284BD6  divw r9, r8, r9
	ctx.r[9].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x82C4435C; continue 'dispatch;
            }
            0x82C4435C => {
    //   block [0x82C4435C..0x82C4436C)
	// 82C4435C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44360: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44364: 40990008  ble cr6, 0x82c4436c
	if !ctx.cr[6].gt {
	pc = 0x82C4436C; continue 'dispatch;
	}
	// 82C44368: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4436C; continue 'dispatch;
            }
            0x82C4436C => {
    //   block [0x82C4436C..0x82C44388)
	// 82C4436C: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 82C44370: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C44374: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82C44378: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C4437C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C44380: 4BFFFB91  bl 0x82c43f10
	ctx.lr = 0x82C44384;
	sub_82C43F10(ctx, base);
	// 82C44384: 4800008C  b 0x82c44410
	pc = 0x82C44410; continue 'dispatch;
            }
            0x82C44388 => {
    //   block [0x82C44388..0x82C443B0)
	// 82C44388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4438C: 419A0084  beq cr6, 0x82c44410
	if ctx.cr[6].eq {
	pc = 0x82C44410; continue 'dispatch;
	}
	// 82C44390: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44394: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C44398: 7CE84BD6  divw r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 82C4439C: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82C443A0: 40980070  bge cr6, 0x82c44410
	if !ctx.cr[6].lt {
	pc = 0x82C44410; continue 'dispatch;
	}
	// 82C443A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C443A8: 40990008  ble cr6, 0x82c443b0
	if !ctx.cr[6].gt {
	pc = 0x82C443B0; continue 'dispatch;
	}
	// 82C443AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C443B0; continue 'dispatch;
            }
            0x82C443B0 => {
    //   block [0x82C443B0..0x82C443C4)
	// 82C443B0: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 82C443B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C443B8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82C443BC: 40990008  ble cr6, 0x82c443c4
	if !ctx.cr[6].gt {
	pc = 0x82C443C4; continue 'dispatch;
	}
	// 82C443C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C443C4; continue 'dispatch;
            }
            0x82C443C4 => {
    //   block [0x82C443C4..0x82C443F4)
	// 82C443C4: 1D44001C  mulli r10, r4, 0x1c
	ctx.r[10].s32 = ((ctx.r[4].s32 as i64 * 28 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 82C443C8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C443CC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C443D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 82C443D4: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C443D8: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C443DC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82C443E0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C443E4: 41990010  bgt cr6, 0x82c443f4
	if ctx.cr[6].gt {
	pc = 0x82C443F4; continue 'dispatch;
	}
	// 82C443E8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C443EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C443F0: 40980008  bge cr6, 0x82c443f8
	if !ctx.cr[6].lt {
	pc = 0x82C443F8; continue 'dispatch;
	}
	pc = 0x82C443F4; continue 'dispatch;
            }
            0x82C443F4 => {
    //   block [0x82C443F4..0x82C443F8)
	// 82C443F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C443F8; continue 'dispatch;
            }
            0x82C443F8 => {
    //   block [0x82C443F8..0x82C44410)
	// 82C443F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C443FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C44400: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44404: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C44408: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C4440C: 4BFFF2AD  bl 0x82c436b8
	ctx.lr = 0x82C44410;
	sub_82C436B8(ctx, base);
	pc = 0x82C44410; continue 'dispatch;
            }
            0x82C44410 => {
    //   block [0x82C44410..0x82C44430)
	// 82C44410: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82C44414: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44418: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4441C: 419A0014  beq cr6, 0x82c44430
	if ctx.cr[6].eq {
	pc = 0x82C44430; continue 'dispatch;
	}
	// 82C44420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44424: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44428: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4442C: 4E800421  bctrl
	ctx.lr = 0x82C44430;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C44430 => {
    //   block [0x82C44430..0x82C44450)
	// 82C44430: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C44434: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C44438: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4443C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C44440: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C44444: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C44448: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4444C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44450(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C44450 size=280
    let mut pc: u32 = 0x82C44450;
    'dispatch: loop {
        match pc {
            0x82C44450 => {
    //   block [0x82C44450..0x82C44568)
	// 82C44450: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44454: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C44458: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4445C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C44460: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C44464: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44468: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4446C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C44470: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C44474: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C44478: 390BC384  addi r8, r11, -0x3c7c
	ctx.r[8].s64 = ctx.r[11].s64 + -15484;
	// 82C4447C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C44480: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C44484: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C44488: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 82C4448C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C44490: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C44494: 38A7B7CC  addi r5, r7, -0x4834
	ctx.r[5].s64 = ctx.r[7].s64 + -18484;
	// 82C44498: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82C4449C: C0090AA4  lfs f0, 0xaa4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(2724 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C444A0: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82C444A4: C3EA0C14  lfs f31, 0xc14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3092 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C444A8: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82C444AC: 397F0038  addi r11, r31, 0x38
	ctx.r[11].s64 = ctx.r[31].s64 + 56;
	// 82C444B0: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82C444B4: D3FF0028  stfs f31, 0x28(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C444B8: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C444BC: 90DF0024  stw r6, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[6].u32 ) };
	// 82C444C0: 909F0034  stw r4, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[4].u32 ) };
	// 82C444C4: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 82C444C8: 90BF0038  stw r5, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[5].u32 ) };
	// 82C444CC: 480095DD  bl 0x82c4daa8
	ctx.lr = 0x82C444D0;
	sub_82C4DAA8(ctx, base);
	// 82C444D0: 3C808200  lis r4, -0x7e00
	ctx.r[4].s64 = -2113929216;
	// 82C444D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C444D8: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 82C444DC: 39410054  addi r10, r1, 0x54
	ctx.r[10].s64 = ctx.r[1].s64 + 84;
	// 82C444E0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82C444E4: C0040C18  lfs f0, 0xc18(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C444E8: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C444EC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C444F0: 38E00050  li r7, 0x50
	ctx.r[7].s64 = 80;
	// 82C444F4: 13E01C07  vcmpneb. (lvlx128) v31, v0, v3
	tmp.u32 = ctx.r[3].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C444F8: 38C8B7CC  addi r6, r8, -0x4834
	ctx.r[6].s64 = ctx.r[8].s64 + -18484;
	// 82C444FC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C44500: 13C05C07  vcmpneb. (lvlx128) v30, v0, v11
	tmp.u32 = ctx.r[11].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C44504: 90DF0038  stw r6, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[6].u32 ) };
	// 82C44508: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C4450C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C44568 size=24
    let mut pc: u32 = 0x82C44568;
    'dispatch: loop {
        match pc {
            0x82C44568 => {
    //   block [0x82C44568..0x82C44580)
	// 82C44568: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C4456C: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 82C44570: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C44574: 13E350C7  vcmpequd (lvx128) v31, v3, v10
	tmp.u32 = ctx.r[3].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44580(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C44580 size=8
    let mut pc: u32 = 0x82C44580;
    'dispatch: loop {
        match pc {
            0x82C44580 => {
    //   block [0x82C44580..0x82C44588)
	// 82C44580: 90830024  stw r4, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[4].u32 ) };
	// 82C44584: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C44588 size=248
    let mut pc: u32 = 0x82C44588;
    'dispatch: loop {
        match pc {
            0x82C44588 => {
    //   block [0x82C44588..0x82C445C4)
	// 82C44588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4458C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C44590: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C44594: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C44598: 48069735  bl 0x82cadccc
	ctx.lr = 0x82C4459C;
	sub_82CADCA0(ctx, base);
	// 82C4459C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C445A0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C445A4: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82C445A8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C445AC: FF201090  fmr f25, f2
	ctx.f[25].f64 = ctx.f[2].f64;
	// 82C445B0: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C445B4: 3FE0820A  lis r31, -0x7df6
	ctx.r[31].s64 = -2113273856;
	// 82C445B8: C3AB0C14  lfs f29, 0xc14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C445BC: C36A0C4C  lfs f27, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82C445C0: C3890C20  lfs f28, 0xc20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3104 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	pc = 0x82C445C4; continue 'dispatch;
            }
            0x82C445C4 => {
    //   block [0x82C445C4..0x82C44680)
	// 82C445C4: 48065C0D  bl 0x82caa1d0
	ctx.lr = 0x82C445C8;
	sub_82CAA1D0(ctx, base);
	// 82C445C8: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82C445CC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C445D0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C445D4: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C445D8: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C445DC: ED6C0732  fmuls f11, f12, f28
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[28].f64) as f32) as f64);
	// 82C445E0: EFCBEEF8  fmsubs f30, f11, f27, f29
	ctx.f[30].f64 = (((ctx.f[11].f64 * ctx.f[27].f64 - ctx.f[29].f64) as f32) as f64);
	// 82C445E4: 48065BED  bl 0x82caa1d0
	ctx.lr = 0x82C445E8;
	sub_82CAA1D0(ctx, base);
	// 82C445E8: 7C6A07B4  extsw r10, r3
	ctx.r[10].s64 = ctx.r[3].s32 as i64;
	// 82C445EC: ED5E07B2  fmuls f10, f30, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82C445F0: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 82C445F4: C9210058  lfd f9, 0x58(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82C445F8: FD004E9C  fcfid f8, f9
	ctx.f[8].f64 = (ctx.f[9].s64 as f64);
	// 82C445FC: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 82C44600: ECC70732  fmuls f6, f7, f28
	ctx.f[6].f64 = (((ctx.f[7].f64 * ctx.f[28].f64) as f32) as f64);
	// 82C44604: ECA6EEF8  fmsubs f5, f6, f27, f29
	ctx.f[5].f64 = (((ctx.f[6].f64 * ctx.f[27].f64 - ctx.f[29].f64) as f32) as f64);
	// 82C44608: EFE5517A  fmadds f31, f5, f5, f10
	ctx.f[31].f64 = (((ctx.f[5].f64 * ctx.f[5].f64 + ctx.f[10].f64) as f32) as f64);
	// 82C4460C: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82C44610: 4098FFB4  bge cr6, 0x82c445c4
	if !ctx.cr[6].lt {
	pc = 0x82C445C4; continue 'dispatch;
	}
	// 82C44614: C01F9050  lfs f0, -0x6fb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-28592 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C44618: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82C4461C: 4099FFA8  ble cr6, 0x82c445c4
	if !ctx.cr[6].gt {
	pc = 0x82C445C4; continue 'dispatch;
	}
	// 82C44620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C44624: 4B5C0985  bl 0x82204fa8
	ctx.lr = 0x82C44628;
	sub_82204FA8(ctx, base);
	// 82C44628: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82C4462C: 409AFF98  bne cr6, 0x82c445c4
	if !ctx.cr[6].eq {
	pc = 0x82C445C4; continue 'dispatch;
	}
	// 82C44630: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C44634: 4B5AF77D  bl 0x821f3db0
	ctx.lr = 0x82C44638;
	sub_821F3DB0(ctx, base);
	// 82C44638: FD800818  frsp f12, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C4463C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C44640: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C44644: C00B0C68  lfs f0, 0xc68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C44648: C1AA9044  lfs f13, -0x6fbc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4464C: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C44650: ED4BF824  fdivs f10, f11, f31
	ctx.f[10].f64 = ((ctx.f[11].f64 / ctx.f[31].f64) as f32) as f64;
	// 82C44654: ED20502C  fsqrts f9, f10
	ctx.f[9].f64 = ((ctx.f[10].f64).sqrt() as f32) as f64;
	// 82C44658: ED0907B2  fmuls f8, f9, f30
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[30].f64) as f32) as f64);
	// 82C4465C: ECE86824  fdivs f7, f8, f13
	ctx.f[7].f64 = ((ctx.f[8].f64 / ctx.f[13].f64) as f32) as f64;
	// 82C44660: EC27D67A  fmadds f1, f7, f25, f26
	ctx.f[1].f64 = (((ctx.f[7].f64 * ctx.f[25].f64 + ctx.f[26].f64) as f32) as f64);
	// 82C44664: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C44668: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C4466C: 480696AD  bl 0x82cadd18
	ctx.lr = 0x82C44670;
	sub_82CADCEC(ctx, base);
	// 82C44670: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C44674: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C44678: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4467C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C44680 size=268
    let mut pc: u32 = 0x82C44680;
    'dispatch: loop {
        match pc {
            0x82C44680 => {
    //   block [0x82C44680..0x82C4478C)
	// 82C44680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44684: 48064D89  bl 0x82ca940c
	ctx.lr = 0x82C44688;
	sub_82CA93D0(ctx, base);
	// 82C44688: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82C4468C: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82C44690: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82C44694: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44698: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4469C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C446A0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C446A4: 48065B2D  bl 0x82caa1d0
	ctx.lr = 0x82C446A8;
	sub_82CAA1D0(ctx, base);
	// 82C446A8: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82C446AC: C1BF0060  lfs f13, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C446B0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C446B4: C11F0064  lfs f8, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82C446B8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82C446BC: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C446C0: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82C446C4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C446C8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C446CC: C00A0BFC  lfs f0, 0xbfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C446D0: C3E90C20  lfs f31, 0xc20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3104 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C446D4: ED2D0032  fmuls f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C446D8: ECEA07F2  fmuls f7, f10, f31
	ctx.f[7].f64 = (((ctx.f[10].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C446DC: ECCD49F8  fmsubs f6, f13, f7, f9
	ctx.f[6].f64 = (((ctx.f[13].f64 * ctx.f[7].f64 - ctx.f[9].f64) as f32) as f64);
	// 82C446E0: EFC6402A  fadds f30, f6, f8
	ctx.f[30].f64 = ((ctx.f[6].f64 + ctx.f[8].f64) as f32) as f64;
	// 82C446E4: 48065AED  bl 0x82caa1d0
	ctx.lr = 0x82C446E8;
	sub_82CAA1D0(ctx, base);
	// 82C446E8: 7C6807B4  extsw r8, r3
	ctx.r[8].s64 = ctx.r[3].s32 as i64;
	// 82C446EC: C0BD0008  lfs f5, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C446F0: C09D000C  lfs f4, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C446F4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C446F8: F9010060  std r8, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u64 ) };
	// 82C446FC: C8610060  lfd f3, 0x60(r1)
	ctx.f[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82C44700: FC401E9C  fcfid f2, f3
	ctx.f[2].f64 = (ctx.f[3].s64 as f64);
	// 82C44704: FC001018  frsp f0, f2
	ctx.f[0].f64 = (ctx.f[2].f64 as f32) as f64;
	// 82C44708: EDA42828  fsubs f13, f4, f5
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[5].f64) as f32) as f64);
	// 82C4470C: ED8007F2  fmuls f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C44710: EFAD2B3A  fmadds f29, f13, f12, f5
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64);
	// 82C44714: 4B5F579D  bl 0x82239eb0
	ctx.lr = 0x82C44718;
	sub_82239EB0(ctx, base);
	// 82C44718: FD600818  frsp f11, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C4471C: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C44720: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C44724: C3E70C18  lfs f31, 0xc18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C44728: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82C4472C: ED4B0772  fmuls f10, f11, f29
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[29].f64) as f32) as f64);
	// 82C44730: D1410050  stfs f10, 0x50(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82C44734: 4B5F585D  bl 0x82239f90
	ctx.lr = 0x82C44738;
	sub_82239F90(ctx, base);
	// 82C44738: FD200818  frsp f9, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[9].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82C4473C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82C44740: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82C44744: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C44748: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 82C4474C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44750: 13E03407  vcmpneb. (lvlx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	// load shuffled into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C44754: 13A02407  vcmpneb. (lvlx128) v29, v0, v4
	tmp.u32 = ctx.r[4].u32;
	// load shuffled into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C44758: 13C02C07  vcmpneb. (lvlx128) v30, v0, v5
	tmp.u32 = ctx.r[5].u32;
	// load shuffled into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44790(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C44790 size=624
    let mut pc: u32 = 0x82C44790;
    'dispatch: loop {
        match pc {
            0x82C44790 => {
    //   block [0x82C44790..0x82C447F4)
	// 82C44790: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44794: 48064C75  bl 0x82ca9408
	ctx.lr = 0x82C44798;
	sub_82CA93D0(ctx, base);
	// 82C44798: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82C4479C: 4806953D  bl 0x82cadcd8
	ctx.lr = 0x82C447A0;
	sub_82CADCA0(ctx, base);
	// 82C447A0: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C447A4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C447A8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C447AC: 817D0024  lwz r11, 0x24(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 82C447B0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82C447B4: 41980040  blt cr6, 0x82c447f4
	if ctx.cr[6].lt {
	pc = 0x82C447F4; continue 'dispatch;
	}
	// 82C447B8: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 82C447BC: 41990038  bgt cr6, 0x82c447f4
	if ctx.cr[6].gt {
	pc = 0x82C447F4; continue 'dispatch;
	}
	// 82C447C0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C447C4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C447C8: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C447CC: C00B9044  lfs f0, -0x6fbc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C447D0: C1AA0C18  lfs f13, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C447D4: C1890C14  lfs f12, 0xc14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3092 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C447D8: D01D0060  stfs f0, 0x60(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82C447DC: D1BD0064  stfs f13, 0x64(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82C447E0: D19D0068  stfs f12, 0x68(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82C447E4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82C447E8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82C447EC: 48069539  bl 0x82cadd24
	ctx.lr = 0x82C447F0;
	sub_82CADCEC(ctx, base);
	// 82C447F0: 48064C68  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C447F4 => {
    //   block [0x82C447F4..0x82C44820)
	// 82C447F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82C447F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C447FC: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 82C44800: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C44804: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82C44808: 409A0018  bne cr6, 0x82c44820
	if !ctx.cr[6].eq {
	pc = 0x82C44820; continue 'dispatch;
	}
	// 82C4480C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C44810: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82C44814: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44818: 4E800421  bctrl
	ctx.lr = 0x82C4481C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4481C: 48000010  b 0x82c4482c
	pc = 0x82C4482C; continue 'dispatch;
            }
            0x82C44820 => {
    //   block [0x82C44820..0x82C4482C)
	// 82C44820: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82C44824: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44828: 4E800421  bctrl
	ctx.lr = 0x82C4482C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4482C => {
    //   block [0x82C4482C..0x82C44A00)
	// 82C4482C: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 82C44830: C05D002C  lfs f2, 0x2c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C44834: 39400050  li r10, 0x50
	ctx.r[10].s64 = 80;
	// 82C44838: C03D0028  lfs f1, 0x28(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C4483C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82C44840: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 82C44844: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C44848: 13E058C7  vcmpequd (lvx128) v31, v0, v11
	tmp.u32 = ctx.r[11].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C4484C: 13DD50C7  vcmpequd (lvx128) v30, v29, v10
	tmp.u32 = ctx.r[29].u32 + ctx.r[10].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C44A00 size=212
    let mut pc: u32 = 0x82C44A00;
    'dispatch: loop {
        match pc {
            0x82C44A00 => {
    //   block [0x82C44A00..0x82C44A58)
	// 82C44A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44A04: 48064A09  bl 0x82ca940c
	ctx.lr = 0x82C44A08;
	sub_82CA93D0(ctx, base);
	// 82C44A08: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44A0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C44A10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44A14: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C44A18: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C44A1C: 4B5914ED  bl 0x821d5f08
	ctx.lr = 0x82C44A20;
	sub_821D5F08(ctx, base);
	// 82C44A20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C44A24: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44A28: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44A2C: 4BFBDEA5  bl 0x82c028d0
	ctx.lr = 0x82C44A30;
	sub_82C028D0(ctx, base);
	// 82C44A30: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82C44A34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44A38: 4BFBDEB1  bl 0x82c028e8
	ctx.lr = 0x82C44A3C;
	sub_82C028E8(ctx, base);
	// 82C44A3C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44A40: 4BFBDF89  bl 0x82c029c8
	ctx.lr = 0x82C44A44;
	sub_82C029C8(ctx, base);
	// 82C44A44: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C44A48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44A4C: 419A000C  beq cr6, 0x82c44a58
	if ctx.cr[6].eq {
	pc = 0x82C44A58; continue 'dispatch;
	}
	// 82C44A50: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44A54: 4BFBDF85  bl 0x82c029d8
	ctx.lr = 0x82C44A58;
	sub_82C029D8(ctx, base);
	pc = 0x82C44A58; continue 'dispatch;
            }
            0x82C44A58 => {
    //   block [0x82C44A58..0x82C44AA0)
	// 82C44A58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44A5C: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82C44A60: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C44A64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C44A68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C44A6C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44A70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44A74: 4E800421  bctrl
	ctx.lr = 0x82C44A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C44A78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C44A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C44A80: 4BFCD249  bl 0x82c11cc8
	ctx.lr = 0x82C44A84;
	sub_82C11CC8(ctx, base);
	// 82C44A84: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C44A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44A8C: 419A0014  beq cr6, 0x82c44aa0
	if ctx.cr[6].eq {
	pc = 0x82C44AA0; continue 'dispatch;
	}
	// 82C44A90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44A94: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44A98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44A9C: 4E800421  bctrl
	ctx.lr = 0x82C44AA0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C44AA0 => {
    //   block [0x82C44AA0..0x82C44AC4)
	// 82C44AA0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44AA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C44AA8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C44AAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C44AB0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C44AB4: 419A0010  beq cr6, 0x82c44ac4
	if ctx.cr[6].eq {
	pc = 0x82C44AC4; continue 'dispatch;
	}
	// 82C44AB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C44ABC: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 82C44AC0: 480117C9  bl 0x82c56288
	ctx.lr = 0x82C44AC4;
	sub_82C56288(ctx, base);
	pc = 0x82C44AC4; continue 'dispatch;
            }
            0x82C44AC4 => {
    //   block [0x82C44AC4..0x82C44AD4)
	// 82C44AC4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C44AC8: 4B644F81  bl 0x82289a48
	ctx.lr = 0x82C44ACC;
	sub_82289A48(ctx, base);
	// 82C44ACC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82C44AD0: 4806498C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C44AD8 size=312
    let mut pc: u32 = 0x82C44AD8;
    'dispatch: loop {
        match pc {
            0x82C44AD8 => {
    //   block [0x82C44AD8..0x82C44BC8)
	// 82C44AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44ADC: 48064931  bl 0x82ca940c
	ctx.lr = 0x82C44AE0;
	sub_82CA93D0(ctx, base);
	// 82C44AE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44AE4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C44AE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C44AEC: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C44AF0: C03F0004  lfs f1, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C44AF4: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	// 82C44AF8: 4BFFFA91  bl 0x82c44588
	ctx.lr = 0x82C44AFC;
	sub_82C44588(ctx, base);
	// 82C44AFC: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 82C44B00: FC00081E  fctiwz f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].s64 = if ctx.f[1].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[1].f64.trunc() as i32 as i64 };
	// 82C44B04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82C44B08: 7C1F5FAE  stfiwx f0, r31, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32), tmp.u32) };
	// 82C44B0C: C80A9058  lfd f0, -0x6fa8(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-28584 as u32) ) };
	// 82C44B10: C1BE0068  lfs f13, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C44B14: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82C44B18: 419800B0  blt cr6, 0x82c44bc8
	if ctx.cr[6].lt {
	pc = 0x82C44BC8; continue 'dispatch;
	}
	// 82C44B1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C44B20: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C44B24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C44B28: 4BFFFB59  bl 0x82c44680
	ctx.lr = 0x82C44B2C;
	sub_82C44680(ctx, base);
	// 82C44B2C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C44B30: 4B5913D9  bl 0x821d5f08
	ctx.lr = 0x82C44B34;
	sub_821D5F08(ctx, base);
	// 82C44B34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C44B38: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C44B3C: 80BF0000  lwz r5, 0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44B40: 4BFBDD91  bl 0x82c028d0
	ctx.lr = 0x82C44B44;
	sub_82C028D0(ctx, base);
	// 82C44B44: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82C44B48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C44B4C: 4BFBDD9D  bl 0x82c028e8
	ctx.lr = 0x82C44B50;
	sub_82C028E8(ctx, base);
	// 82C44B50: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82C44B54: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	pc = 0x82C44BC8; continue 'dispatch;
            }
            0x82C44BC8 => {
    //   block [0x82C44BC8..0x82C44C10)
	// 82C44BC8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C44BCC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C44BD0: 4806488C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
	// 82C44BD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C44BD8: 387E0038  addi r3, r30, 0x38
	ctx.r[3].s64 = ctx.r[30].s64 + 56;
	// 82C44BDC: 480116AD  bl 0x82c56288
	ctx.lr = 0x82C44BE0;
	sub_82C56288(ctx, base);
	// 82C44BE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44BE4: C03E0068  lfs f1, 0x68(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C44BE8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C44BEC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44BF0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44BF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44BF8: 4E800421  bctrl
	ctx.lr = 0x82C44BFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C44BFC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82C44C00: 4B644E49  bl 0x82289a48
	ctx.lr = 0x82C44C04;
	sub_82289A48(ctx, base);
	// 82C44C04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C44C08: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82C44C0C: 48064850  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C44C10 size=332
    let mut pc: u32 = 0x82C44C10;
    'dispatch: loop {
        match pc {
            0x82C44C10 => {
    //   block [0x82C44C10..0x82C44C2C)
	// 82C44C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44C14: 480647F9  bl 0x82ca940c
	ctx.lr = 0x82C44C18;
	sub_82CA93D0(ctx, base);
	// 82C44C18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44C1C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C44C20: 897D006D  lbz r11, 0x6d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C44C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44C28: 409A0010  bne cr6, 0x82c44c38
	if !ctx.cr[6].eq {
	pc = 0x82C44C38; continue 'dispatch;
	}
	pc = 0x82C44C2C; continue 'dispatch;
            }
            0x82C44C2C => {
    //   block [0x82C44C2C..0x82C44C38)
	// 82C44C2C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C44C30: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C44C34: 48064828  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C44C38 => {
    //   block [0x82C44C38..0x82C44C50)
	// 82C44C38: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44C3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C44C40: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44C44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44C48: 40990008  ble cr6, 0x82c44c50
	if !ctx.cr[6].gt {
	pc = 0x82C44C50; continue 'dispatch;
	}
	// 82C44C4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44C50; continue 'dispatch;
            }
            0x82C44C50 => {
    //   block [0x82C44C50..0x82C44C64)
	// 82C44C50: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44C54: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44C58: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44C5C: 40990008  ble cr6, 0x82c44c64
	if !ctx.cr[6].gt {
	pc = 0x82C44C64; continue 'dispatch;
	}
	// 82C44C60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44C64; continue 'dispatch;
            }
            0x82C44C64 => {
    //   block [0x82C44C64..0x82C44C70)
	// 82C44C64: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44C68: 419A0008  beq cr6, 0x82c44c70
	if ctx.cr[6].eq {
	pc = 0x82C44C70; continue 'dispatch;
	}
	// 82C44C6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44C70; continue 'dispatch;
            }
            0x82C44C70 => {
    //   block [0x82C44C70..0x82C44C84)
	// 82C44C70: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44C74: 419A0050  beq cr6, 0x82c44cc4
	if ctx.cr[6].eq {
	pc = 0x82C44CC4; continue 'dispatch;
	}
	// 82C44C78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44C7C: 41980008  blt cr6, 0x82c44c84
	if ctx.cr[6].lt {
	pc = 0x82C44C84; continue 'dispatch;
	}
	// 82C44C80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44C84; continue 'dispatch;
            }
            0x82C44C84 => {
    //   block [0x82C44C84..0x82C44CAC)
	// 82C44C84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44C88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44C8C: 419A0020  beq cr6, 0x82c44cac
	if ctx.cr[6].eq {
	pc = 0x82C44CAC; continue 'dispatch;
	}
	// 82C44C90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44C94: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44C98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44C9C: 4E800421  bctrl
	ctx.lr = 0x82C44CA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C44CA0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C44CA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C44CA8: 419AFF84  beq cr6, 0x82c44c2c
	if ctx.cr[6].eq {
	pc = 0x82C44C2C; continue 'dispatch;
	}
            }
            0x82C44CAC => {
    //   block [0x82C44CAC..0x82C44CBC)
	// 82C44CAC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44CB0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44CB4: 41980008  blt cr6, 0x82c44cbc
	if ctx.cr[6].lt {
	pc = 0x82C44CBC; continue 'dispatch;
	}
	// 82C44CB8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44CBC; continue 'dispatch;
            }
            0x82C44CBC => {
    //   block [0x82C44CBC..0x82C44CC4)
	// 82C44CBC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C44CC0: 4BFFFF90  b 0x82c44c50
	pc = 0x82C44C50; continue 'dispatch;
            }
            0x82C44CC4 => {
    //   block [0x82C44CC4..0x82C44CDC)
	// 82C44CC4: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C44CC8: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 82C44CCC: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C44CD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44CD4: 40990008  ble cr6, 0x82c44cdc
	if !ctx.cr[6].gt {
	pc = 0x82C44CDC; continue 'dispatch;
	}
	// 82C44CD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44CDC; continue 'dispatch;
            }
            0x82C44CDC => {
    //   block [0x82C44CDC..0x82C44CF0)
	// 82C44CDC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44CE0: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44CE4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44CE8: 40990008  ble cr6, 0x82c44cf0
	if !ctx.cr[6].gt {
	pc = 0x82C44CF0; continue 'dispatch;
	}
	// 82C44CEC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44CF0; continue 'dispatch;
            }
            0x82C44CF0 => {
    //   block [0x82C44CF0..0x82C44CFC)
	// 82C44CF0: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44CF4: 419A0008  beq cr6, 0x82c44cfc
	if ctx.cr[6].eq {
	pc = 0x82C44CFC; continue 'dispatch;
	}
	// 82C44CF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44CFC; continue 'dispatch;
            }
            0x82C44CFC => {
    //   block [0x82C44CFC..0x82C44D10)
	// 82C44CFC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44D00: 419A0050  beq cr6, 0x82c44d50
	if ctx.cr[6].eq {
	pc = 0x82C44D50; continue 'dispatch;
	}
	// 82C44D04: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44D08: 41980008  blt cr6, 0x82c44d10
	if ctx.cr[6].lt {
	pc = 0x82C44D10; continue 'dispatch;
	}
	// 82C44D0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44D10; continue 'dispatch;
            }
            0x82C44D10 => {
    //   block [0x82C44D10..0x82C44D38)
	// 82C44D10: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C44D14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44D18: 419A0020  beq cr6, 0x82c44d38
	if ctx.cr[6].eq {
	pc = 0x82C44D38; continue 'dispatch;
	}
	// 82C44D1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44D20: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44D24: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44D28: 4E800421  bctrl
	ctx.lr = 0x82C44D2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C44D2C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C44D30: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C44D34: 419AFEF8  beq cr6, 0x82c44c2c
	if ctx.cr[6].eq {
	pc = 0x82C44C2C; continue 'dispatch;
	}
            }
            0x82C44D38 => {
    //   block [0x82C44D38..0x82C44D48)
	// 82C44D38: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44D3C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44D40: 41980008  blt cr6, 0x82c44d48
	if ctx.cr[6].lt {
	pc = 0x82C44D48; continue 'dispatch;
	}
	// 82C44D44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44D48; continue 'dispatch;
            }
            0x82C44D48 => {
    //   block [0x82C44D48..0x82C44D50)
	// 82C44D48: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C44D4C: 4BFFFF90  b 0x82c44cdc
	pc = 0x82C44CDC; continue 'dispatch;
            }
            0x82C44D50 => {
    //   block [0x82C44D50..0x82C44D5C)
	// 82C44D50: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C44D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C44D58: 48064704  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C44D60 size=180
    let mut pc: u32 = 0x82C44D60;
    'dispatch: loop {
        match pc {
            0x82C44D60 => {
    //   block [0x82C44D60..0x82C44D98)
	// 82C44D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44D64: 480646A5  bl 0x82ca9408
	ctx.lr = 0x82C44D68;
	sub_82CA93D0(ctx, base);
	// 82C44D68: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44D6C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C44D70: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C44D74: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C44D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44D7C: 419A0090  beq cr6, 0x82c44e0c
	if ctx.cr[6].eq {
	pc = 0x82C44E0C; continue 'dispatch;
	}
	// 82C44D80: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44D84: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C44D88: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44D8C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44D90: 40990008  ble cr6, 0x82c44d98
	if !ctx.cr[6].gt {
	pc = 0x82C44D98; continue 'dispatch;
	}
	// 82C44D94: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44D98; continue 'dispatch;
            }
            0x82C44D98 => {
    //   block [0x82C44D98..0x82C44DAC)
	// 82C44D98: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44D9C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44DA0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44DA4: 40990008  ble cr6, 0x82c44dac
	if !ctx.cr[6].gt {
	pc = 0x82C44DAC; continue 'dispatch;
	}
	// 82C44DA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44DAC; continue 'dispatch;
            }
            0x82C44DAC => {
    //   block [0x82C44DAC..0x82C44DB8)
	// 82C44DAC: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44DB0: 419A0008  beq cr6, 0x82c44db8
	if ctx.cr[6].eq {
	pc = 0x82C44DB8; continue 'dispatch;
	}
	// 82C44DB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44DB8; continue 'dispatch;
            }
            0x82C44DB8 => {
    //   block [0x82C44DB8..0x82C44DCC)
	// 82C44DB8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44DBC: 419A0048  beq cr6, 0x82c44e04
	if ctx.cr[6].eq {
	pc = 0x82C44E04; continue 'dispatch;
	}
	// 82C44DC0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44DC4: 41980008  blt cr6, 0x82c44dcc
	if ctx.cr[6].lt {
	pc = 0x82C44DCC; continue 'dispatch;
	}
	// 82C44DC8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44DCC; continue 'dispatch;
            }
            0x82C44DCC => {
    //   block [0x82C44DCC..0x82C44DEC)
	// 82C44DCC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44DD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44DD4: 419A0018  beq cr6, 0x82c44dec
	if ctx.cr[6].eq {
	pc = 0x82C44DEC; continue 'dispatch;
	}
	// 82C44DD8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44DDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C44DE0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C44DE4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44DE8: 4E800421  bctrl
	ctx.lr = 0x82C44DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C44DEC => {
    //   block [0x82C44DEC..0x82C44DFC)
	// 82C44DEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44DF0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44DF4: 41980008  blt cr6, 0x82c44dfc
	if ctx.cr[6].lt {
	pc = 0x82C44DFC; continue 'dispatch;
	}
	// 82C44DF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44DFC; continue 'dispatch;
            }
            0x82C44DFC => {
    //   block [0x82C44DFC..0x82C44E04)
	// 82C44DFC: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C44E00: 4BFFFF98  b 0x82c44d98
	pc = 0x82C44D98; continue 'dispatch;
            }
            0x82C44E04 => {
    //   block [0x82C44E04..0x82C44E0C)
	// 82C44E04: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C44E08: 997D006C  stb r11, 0x6c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	pc = 0x82C44E0C; continue 'dispatch;
            }
            0x82C44E0C => {
    //   block [0x82C44E0C..0x82C44E14)
	// 82C44E0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C44E10: 48064648  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C44E18 size=348
    let mut pc: u32 = 0x82C44E18;
    'dispatch: loop {
        match pc {
            0x82C44E18 => {
    //   block [0x82C44E18..0x82C44E50)
	// 82C44E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44E1C: 480645ED  bl 0x82ca9408
	ctx.lr = 0x82C44E20;
	sub_82CA93D0(ctx, base);
	// 82C44E20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44E24: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C44E28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C44E2C: 897D006C  lbz r11, 0x6c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C44E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44E34: 409A0138  bne cr6, 0x82c44f6c
	if !ctx.cr[6].eq {
	pc = 0x82C44F6C; continue 'dispatch;
	}
	// 82C44E38: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44E3C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C44E40: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44E44: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44E48: 40990008  ble cr6, 0x82c44e50
	if !ctx.cr[6].gt {
	pc = 0x82C44E50; continue 'dispatch;
	}
	// 82C44E4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44E50; continue 'dispatch;
            }
            0x82C44E50 => {
    //   block [0x82C44E50..0x82C44E64)
	// 82C44E50: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44E54: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44E58: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44E5C: 40990008  ble cr6, 0x82c44e64
	if !ctx.cr[6].gt {
	pc = 0x82C44E64; continue 'dispatch;
	}
	// 82C44E60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44E64; continue 'dispatch;
            }
            0x82C44E64 => {
    //   block [0x82C44E64..0x82C44E70)
	// 82C44E64: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44E68: 419A0008  beq cr6, 0x82c44e70
	if ctx.cr[6].eq {
	pc = 0x82C44E70; continue 'dispatch;
	}
	// 82C44E6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44E70; continue 'dispatch;
            }
            0x82C44E70 => {
    //   block [0x82C44E70..0x82C44E84)
	// 82C44E70: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44E74: 419A0048  beq cr6, 0x82c44ebc
	if ctx.cr[6].eq {
	pc = 0x82C44EBC; continue 'dispatch;
	}
	// 82C44E78: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44E7C: 41980008  blt cr6, 0x82c44e84
	if ctx.cr[6].lt {
	pc = 0x82C44E84; continue 'dispatch;
	}
	// 82C44E80: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44E84; continue 'dispatch;
            }
            0x82C44E84 => {
    //   block [0x82C44E84..0x82C44EA4)
	// 82C44E84: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44E88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44E8C: 419A0018  beq cr6, 0x82c44ea4
	if ctx.cr[6].eq {
	pc = 0x82C44EA4; continue 'dispatch;
	}
	// 82C44E90: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44E94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C44E98: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C44E9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44EA0: 4E800421  bctrl
	ctx.lr = 0x82C44EA4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C44EA4 => {
    //   block [0x82C44EA4..0x82C44EB4)
	// 82C44EA4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44EA8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44EAC: 41980008  blt cr6, 0x82c44eb4
	if ctx.cr[6].lt {
	pc = 0x82C44EB4; continue 'dispatch;
	}
	// 82C44EB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44EB4; continue 'dispatch;
            }
            0x82C44EB4 => {
    //   block [0x82C44EB4..0x82C44EBC)
	// 82C44EB4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C44EB8: 4BFFFF98  b 0x82c44e50
	pc = 0x82C44E50; continue 'dispatch;
            }
            0x82C44EBC => {
    //   block [0x82C44EBC..0x82C44ED4)
	// 82C44EBC: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C44EC0: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 82C44EC4: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C44EC8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44ECC: 40990008  ble cr6, 0x82c44ed4
	if !ctx.cr[6].gt {
	pc = 0x82C44ED4; continue 'dispatch;
	}
	// 82C44ED0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44ED4; continue 'dispatch;
            }
            0x82C44ED4 => {
    //   block [0x82C44ED4..0x82C44EE8)
	// 82C44ED4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44ED8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44EDC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44EE0: 40990008  ble cr6, 0x82c44ee8
	if !ctx.cr[6].gt {
	pc = 0x82C44EE8; continue 'dispatch;
	}
	// 82C44EE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44EE8; continue 'dispatch;
            }
            0x82C44EE8 => {
    //   block [0x82C44EE8..0x82C44EF4)
	// 82C44EE8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44EEC: 419A0008  beq cr6, 0x82c44ef4
	if ctx.cr[6].eq {
	pc = 0x82C44EF4; continue 'dispatch;
	}
	// 82C44EF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44EF4; continue 'dispatch;
            }
            0x82C44EF4 => {
    //   block [0x82C44EF4..0x82C44F08)
	// 82C44EF4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44EF8: 419A006C  beq cr6, 0x82c44f64
	if ctx.cr[6].eq {
	pc = 0x82C44F64; continue 'dispatch;
	}
	// 82C44EFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44F00: 41980008  blt cr6, 0x82c44f08
	if ctx.cr[6].lt {
	pc = 0x82C44F08; continue 'dispatch;
	}
	// 82C44F04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44F08; continue 'dispatch;
            }
            0x82C44F08 => {
    //   block [0x82C44F08..0x82C44F4C)
	// 82C44F08: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C44F0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44F10: 419A003C  beq cr6, 0x82c44f4c
	if ctx.cr[6].eq {
	pc = 0x82C44F4C; continue 'dispatch;
	}
	// 82C44F14: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44F18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44F1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44F20: 4E800421  bctrl
	ctx.lr = 0x82C44F24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C44F24: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C44F28: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C44F2C: 409A0020  bne cr6, 0x82c44f4c
	if !ctx.cr[6].eq {
	pc = 0x82C44F4C; continue 'dispatch;
	}
	// 82C44F30: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C44F34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C44F38: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C44F3C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44F40: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C44F44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C44F48: 4E800421  bctrl
	ctx.lr = 0x82C44F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C44F4C => {
    //   block [0x82C44F4C..0x82C44F5C)
	// 82C44F4C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44F50: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44F54: 41980008  blt cr6, 0x82c44f5c
	if ctx.cr[6].lt {
	pc = 0x82C44F5C; continue 'dispatch;
	}
	// 82C44F58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44F5C; continue 'dispatch;
            }
            0x82C44F5C => {
    //   block [0x82C44F5C..0x82C44F64)
	// 82C44F5C: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C44F60: 4BFFFF74  b 0x82c44ed4
	pc = 0x82C44ED4; continue 'dispatch;
            }
            0x82C44F64 => {
    //   block [0x82C44F64..0x82C44F6C)
	// 82C44F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C44F68: 997D006C  stb r11, 0x6c(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	pc = 0x82C44F6C; continue 'dispatch;
            }
            0x82C44F6C => {
    //   block [0x82C44F6C..0x82C44F74)
	// 82C44F6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C44F70: 480644E8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C44F78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C44F78 size=364
    let mut pc: u32 = 0x82C44F78;
    'dispatch: loop {
        match pc {
            0x82C44F78 => {
    //   block [0x82C44F78..0x82C44FB4)
	// 82C44F78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C44F7C: 48064491  bl 0x82ca940c
	ctx.lr = 0x82C44F80;
	sub_82CA93D0(ctx, base);
	// 82C44F80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C44F84: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C44F88: 897D006D  lbz r11, 0x6d(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C44F8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C44F90: 409A014C  bne cr6, 0x82c450dc
	if !ctx.cr[6].eq {
	pc = 0x82C450DC; continue 'dispatch;
	}
	// 82C44F94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C44F98: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C44F9C: 997D006D  stb r11, 0x6d(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 82C44FA0: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44FA4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C44FA8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44FAC: 40990008  ble cr6, 0x82c44fb4
	if !ctx.cr[6].gt {
	pc = 0x82C44FB4; continue 'dispatch;
	}
	// 82C44FB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44FB4; continue 'dispatch;
            }
            0x82C44FB4 => {
    //   block [0x82C44FB4..0x82C44FC8)
	// 82C44FB4: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C44FB8: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44FBC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44FC0: 40990008  ble cr6, 0x82c44fc8
	if !ctx.cr[6].gt {
	pc = 0x82C44FC8; continue 'dispatch;
	}
	// 82C44FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44FC8; continue 'dispatch;
            }
            0x82C44FC8 => {
    //   block [0x82C44FC8..0x82C44FD4)
	// 82C44FC8: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C44FCC: 419A0008  beq cr6, 0x82c44fd4
	if ctx.cr[6].eq {
	pc = 0x82C44FD4; continue 'dispatch;
	}
	// 82C44FD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44FD4; continue 'dispatch;
            }
            0x82C44FD4 => {
    //   block [0x82C44FD4..0x82C44FE8)
	// 82C44FD4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C44FD8: 419A0064  beq cr6, 0x82c4503c
	if ctx.cr[6].eq {
	pc = 0x82C4503C; continue 'dispatch;
	}
	// 82C44FDC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C44FE0: 41980008  blt cr6, 0x82c44fe8
	if ctx.cr[6].lt {
	pc = 0x82C44FE8; continue 'dispatch;
	}
	// 82C44FE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C44FE8; continue 'dispatch;
            }
            0x82C44FE8 => {
    //   block [0x82C44FE8..0x82C45024)
	// 82C44FE8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C44FEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C44FF0: 419A0034  beq cr6, 0x82c45024
	if ctx.cr[6].eq {
	pc = 0x82C45024; continue 'dispatch;
	}
	// 82C44FF4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44FF8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C44FFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45000: 4E800421  bctrl
	ctx.lr = 0x82C45004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45004: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C45008: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4500C: 409A0018  bne cr6, 0x82c45024
	if !ctx.cr[6].eq {
	pc = 0x82C45024; continue 'dispatch;
	}
	// 82C45010: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45014: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45018: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C4501C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45020: 4E800421  bctrl
	ctx.lr = 0x82C45024;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C45024 => {
    //   block [0x82C45024..0x82C45034)
	// 82C45024: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45028: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4502C: 41980008  blt cr6, 0x82c45034
	if ctx.cr[6].lt {
	pc = 0x82C45034; continue 'dispatch;
	}
	// 82C45030: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45034; continue 'dispatch;
            }
            0x82C45034 => {
    //   block [0x82C45034..0x82C4503C)
	// 82C45034: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C45038: 4BFFFF7C  b 0x82c44fb4
	pc = 0x82C44FB4; continue 'dispatch;
            }
            0x82C4503C => {
    //   block [0x82C4503C..0x82C45054)
	// 82C4503C: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C45040: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 82C45044: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C45048: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4504C: 40990008  ble cr6, 0x82c45054
	if !ctx.cr[6].gt {
	pc = 0x82C45054; continue 'dispatch;
	}
	// 82C45050: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45054; continue 'dispatch;
            }
            0x82C45054 => {
    //   block [0x82C45054..0x82C45068)
	// 82C45054: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45058: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4505C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45060: 40990008  ble cr6, 0x82c45068
	if !ctx.cr[6].gt {
	pc = 0x82C45068; continue 'dispatch;
	}
	// 82C45064: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45068; continue 'dispatch;
            }
            0x82C45068 => {
    //   block [0x82C45068..0x82C45074)
	// 82C45068: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4506C: 419A0008  beq cr6, 0x82c45074
	if ctx.cr[6].eq {
	pc = 0x82C45074; continue 'dispatch;
	}
	// 82C45070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45074; continue 'dispatch;
            }
            0x82C45074 => {
    //   block [0x82C45074..0x82C45088)
	// 82C45074: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45078: 419A0064  beq cr6, 0x82c450dc
	if ctx.cr[6].eq {
	pc = 0x82C450DC; continue 'dispatch;
	}
	// 82C4507C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45080: 41980008  blt cr6, 0x82c45088
	if ctx.cr[6].lt {
	pc = 0x82C45088; continue 'dispatch;
	}
	// 82C45084: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45088; continue 'dispatch;
            }
            0x82C45088 => {
    //   block [0x82C45088..0x82C450C4)
	// 82C45088: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4508C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45090: 419A0034  beq cr6, 0x82c450c4
	if ctx.cr[6].eq {
	pc = 0x82C450C4; continue 'dispatch;
	}
	// 82C45094: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45098: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4509C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C450A0: 4E800421  bctrl
	ctx.lr = 0x82C450A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C450A4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C450A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C450AC: 409A0018  bne cr6, 0x82c450c4
	if !ctx.cr[6].eq {
	pc = 0x82C450C4; continue 'dispatch;
	}
	// 82C450B0: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C450B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C450B8: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C450BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C450C0: 4E800421  bctrl
	ctx.lr = 0x82C450C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C450C4 => {
    //   block [0x82C450C4..0x82C450D4)
	// 82C450C4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C450C8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C450CC: 41980008  blt cr6, 0x82c450d4
	if ctx.cr[6].lt {
	pc = 0x82C450D4; continue 'dispatch;
	}
	// 82C450D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C450D4; continue 'dispatch;
            }
            0x82C450D4 => {
    //   block [0x82C450D4..0x82C450DC)
	// 82C450D4: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C450D8: 4BFFFF7C  b 0x82c45054
	pc = 0x82C45054; continue 'dispatch;
            }
            0x82C450DC => {
    //   block [0x82C450DC..0x82C450E4)
	// 82C450DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C450E0: 4806437C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C450E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C450E8 size=476
    let mut pc: u32 = 0x82C450E8;
    'dispatch: loop {
        match pc {
            0x82C450E8 => {
    //   block [0x82C450E8..0x82C45128)
	// 82C450E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C450EC: 48064315  bl 0x82ca9400
	ctx.lr = 0x82C450F0;
	sub_82CA93D0(ctx, base);
	// 82C450F0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C450F4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C450F8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82C450FC: 897C006D  lbz r11, 0x6d(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C45100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45104: 409A01B8  bne cr6, 0x82c452bc
	if !ctx.cr[6].eq {
	pc = 0x82C452BC; continue 'dispatch;
	}
	// 82C45108: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C4510C: 3BBC0004  addi r29, r28, 4
	ctx.r[29].s64 = ctx.r[28].s64 + 4;
	// 82C45110: 997C006D  stb r11, 0x6d(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(109 as u32), ctx.r[11].u8 ) };
	// 82C45114: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45118: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4511C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45120: 40990008  ble cr6, 0x82c45128
	if !ctx.cr[6].gt {
	pc = 0x82C45128; continue 'dispatch;
	}
	// 82C45124: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45128; continue 'dispatch;
            }
            0x82C45128 => {
    //   block [0x82C45128..0x82C45130)
	// 82C45128: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82C4512C: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	pc = 0x82C45130; continue 'dispatch;
            }
            0x82C45130 => {
    //   block [0x82C45130..0x82C45144)
	// 82C45130: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45134: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45138: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4513C: 40990008  ble cr6, 0x82c45144
	if !ctx.cr[6].gt {
	pc = 0x82C45144; continue 'dispatch;
	}
	// 82C45140: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45144; continue 'dispatch;
            }
            0x82C45144 => {
    //   block [0x82C45144..0x82C45150)
	// 82C45144: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C45148: 419A0008  beq cr6, 0x82c45150
	if ctx.cr[6].eq {
	pc = 0x82C45150; continue 'dispatch;
	}
	// 82C4514C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45150; continue 'dispatch;
            }
            0x82C45150 => {
    //   block [0x82C45150..0x82C45164)
	// 82C45150: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45154: 419A0094  beq cr6, 0x82c451e8
	if ctx.cr[6].eq {
	pc = 0x82C451E8; continue 'dispatch;
	}
	// 82C45158: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4515C: 41980008  blt cr6, 0x82c45164
	if ctx.cr[6].lt {
	pc = 0x82C45164; continue 'dispatch;
	}
	// 82C45160: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45164; continue 'dispatch;
            }
            0x82C45164 => {
    //   block [0x82C45164..0x82C451C8)
	// 82C45164: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45168: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 82C4516C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45170: 419A0060  beq cr6, 0x82c451d0
	if ctx.cr[6].eq {
	pc = 0x82C451D0; continue 'dispatch;
	}
	// 82C45174: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45178: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4517C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45180: 4E800421  bctrl
	ctx.lr = 0x82C45184;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45184: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C45188: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C4518C: 409A0044  bne cr6, 0x82c451d0
	if !ctx.cr[6].eq {
	pc = 0x82C451D0; continue 'dispatch;
	}
	// 82C45190: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45194: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C45198: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4519C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C451A0: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C451A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C451A8: 4E800421  bctrl
	ctx.lr = 0x82C451AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C451AC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C451B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C451B4: 419A0014  beq cr6, 0x82c451c8
	if ctx.cr[6].eq {
	pc = 0x82C451C8; continue 'dispatch;
	}
	// 82C451B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C451BC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C451C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C451C4: 4E800421  bctrl
	ctx.lr = 0x82C451C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C451C8 => {
    //   block [0x82C451C8..0x82C451D0)
	// 82C451C8: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C451CC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82C451D0; continue 'dispatch;
            }
            0x82C451D0 => {
    //   block [0x82C451D0..0x82C451E0)
	// 82C451D0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C451D4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C451D8: 41980008  blt cr6, 0x82c451e0
	if ctx.cr[6].lt {
	pc = 0x82C451E0; continue 'dispatch;
	}
	// 82C451DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C451E0; continue 'dispatch;
            }
            0x82C451E0 => {
    //   block [0x82C451E0..0x82C451E8)
	// 82C451E0: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 82C451E4: 4BFFFF4C  b 0x82c45130
	pc = 0x82C45130; continue 'dispatch;
            }
            0x82C451E8 => {
    //   block [0x82C451E8..0x82C45200)
	// 82C451E8: 815C0018  lwz r10, 0x18(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C451EC: 3BBC0014  addi r29, r28, 0x14
	ctx.r[29].s64 = ctx.r[28].s64 + 20;
	// 82C451F0: 817C001C  lwz r11, 0x1c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C451F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C451F8: 40990008  ble cr6, 0x82c45200
	if !ctx.cr[6].gt {
	pc = 0x82C45200; continue 'dispatch;
	}
	// 82C451FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45200; continue 'dispatch;
            }
            0x82C45200 => {
    //   block [0x82C45200..0x82C45204)
	// 82C45200: 7D5E5378  mr r30, r10
	ctx.r[30].u64 = ctx.r[10].u64;
	pc = 0x82C45204; continue 'dispatch;
            }
            0x82C45204 => {
    //   block [0x82C45204..0x82C45218)
	// 82C45204: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45208: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4520C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45210: 40990008  ble cr6, 0x82c45218
	if !ctx.cr[6].gt {
	pc = 0x82C45218; continue 'dispatch;
	}
	// 82C45214: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45218; continue 'dispatch;
            }
            0x82C45218 => {
    //   block [0x82C45218..0x82C45224)
	// 82C45218: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82C4521C: 419A0008  beq cr6, 0x82c45224
	if ctx.cr[6].eq {
	pc = 0x82C45224; continue 'dispatch;
	}
	// 82C45220: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45224; continue 'dispatch;
            }
            0x82C45224 => {
    //   block [0x82C45224..0x82C45238)
	// 82C45224: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45228: 419A0094  beq cr6, 0x82c452bc
	if ctx.cr[6].eq {
	pc = 0x82C452BC; continue 'dispatch;
	}
	// 82C4522C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45230: 41980008  blt cr6, 0x82c45238
	if ctx.cr[6].lt {
	pc = 0x82C45238; continue 'dispatch;
	}
	// 82C45234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45238; continue 'dispatch;
            }
            0x82C45238 => {
    //   block [0x82C45238..0x82C4529C)
	// 82C45238: 807E0010  lwz r3, 0x10(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C4523C: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 82C45240: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45244: 419A0060  beq cr6, 0x82c452a4
	if ctx.cr[6].eq {
	pc = 0x82C452A4; continue 'dispatch;
	}
	// 82C45248: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4524C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45250: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45254: 4E800421  bctrl
	ctx.lr = 0x82C45258;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45258: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4525C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C45260: 409A0044  bne cr6, 0x82c452a4
	if !ctx.cr[6].eq {
	pc = 0x82C452A4; continue 'dispatch;
	}
	// 82C45264: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45268: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C4526C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C45270: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45274: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C45278: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4527C: 4E800421  bctrl
	ctx.lr = 0x82C45280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45280: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45284: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45288: 419A0014  beq cr6, 0x82c4529c
	if ctx.cr[6].eq {
	pc = 0x82C4529C; continue 'dispatch;
	}
	// 82C4528C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45290: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45294: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45298: 4E800421  bctrl
	ctx.lr = 0x82C4529C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C4529C => {
    //   block [0x82C4529C..0x82C452A4)
	// 82C4529C: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82C452A0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x82C452A4; continue 'dispatch;
            }
            0x82C452A4 => {
    //   block [0x82C452A4..0x82C452B4)
	// 82C452A4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C452A8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C452AC: 41980008  blt cr6, 0x82c452b4
	if ctx.cr[6].lt {
	pc = 0x82C452B4; continue 'dispatch;
	}
	// 82C452B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C452B4; continue 'dispatch;
            }
            0x82C452B4 => {
    //   block [0x82C452B4..0x82C452BC)
	// 82C452B4: 3BDE001C  addi r30, r30, 0x1c
	ctx.r[30].s64 = ctx.r[30].s64 + 28;
	// 82C452B8: 4BFFFF4C  b 0x82c45204
	pc = 0x82C45204; continue 'dispatch;
            }
            0x82C452BC => {
    //   block [0x82C452BC..0x82C452C4)
	// 82C452BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C452C0: 48064190  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C452C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C452C8 size=300
    let mut pc: u32 = 0x82C452C8;
    'dispatch: loop {
        match pc {
            0x82C452C8 => {
    //   block [0x82C452C8..0x82C452FC)
	// 82C452C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C452CC: 4806413D  bl 0x82ca9408
	ctx.lr = 0x82C452D0;
	sub_82CA93D0(ctx, base);
	// 82C452D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C452D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C452D8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C452DC: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 82C452E0: 480110E9  bl 0x82c563c8
	ctx.lr = 0x82C452E4;
	sub_82C563C8(ctx, base);
	// 82C452E4: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C452E8: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C452EC: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C452F0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C452F4: 40990008  ble cr6, 0x82c452fc
	if !ctx.cr[6].gt {
	pc = 0x82C452FC; continue 'dispatch;
	}
	// 82C452F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C452FC; continue 'dispatch;
            }
            0x82C452FC => {
    //   block [0x82C452FC..0x82C45310)
	// 82C452FC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45300: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45304: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45308: 40990008  ble cr6, 0x82c45310
	if !ctx.cr[6].gt {
	pc = 0x82C45310; continue 'dispatch;
	}
	// 82C4530C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45310; continue 'dispatch;
            }
            0x82C45310 => {
    //   block [0x82C45310..0x82C4531C)
	// 82C45310: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C45314: 419A0008  beq cr6, 0x82c4531c
	if ctx.cr[6].eq {
	pc = 0x82C4531C; continue 'dispatch;
	}
	// 82C45318: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4531C; continue 'dispatch;
            }
            0x82C4531C => {
    //   block [0x82C4531C..0x82C45330)
	// 82C4531C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45320: 419A0048  beq cr6, 0x82c45368
	if ctx.cr[6].eq {
	pc = 0x82C45368; continue 'dispatch;
	}
	// 82C45324: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45328: 41980008  blt cr6, 0x82c45330
	if ctx.cr[6].lt {
	pc = 0x82C45330; continue 'dispatch;
	}
	// 82C4532C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45330; continue 'dispatch;
            }
            0x82C45330 => {
    //   block [0x82C45330..0x82C45350)
	// 82C45330: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45334: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45338: 419A0018  beq cr6, 0x82c45350
	if ctx.cr[6].eq {
	pc = 0x82C45350; continue 'dispatch;
	}
	// 82C4533C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45340: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C45344: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45348: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4534C: 4E800421  bctrl
	ctx.lr = 0x82C45350;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C45350 => {
    //   block [0x82C45350..0x82C45360)
	// 82C45350: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45354: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45358: 41980008  blt cr6, 0x82c45360
	if ctx.cr[6].lt {
	pc = 0x82C45360; continue 'dispatch;
	}
	// 82C4535C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45360; continue 'dispatch;
            }
            0x82C45360 => {
    //   block [0x82C45360..0x82C45368)
	// 82C45360: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C45364: 4BFFFF98  b 0x82c452fc
	pc = 0x82C452FC; continue 'dispatch;
            }
            0x82C45368 => {
    //   block [0x82C45368..0x82C45380)
	// 82C45368: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4536C: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 82C45370: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C45374: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45378: 40990008  ble cr6, 0x82c45380
	if !ctx.cr[6].gt {
	pc = 0x82C45380; continue 'dispatch;
	}
	// 82C4537C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45380; continue 'dispatch;
            }
            0x82C45380 => {
    //   block [0x82C45380..0x82C45394)
	// 82C45380: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45384: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45388: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4538C: 40990008  ble cr6, 0x82c45394
	if !ctx.cr[6].gt {
	pc = 0x82C45394; continue 'dispatch;
	}
	// 82C45390: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45394; continue 'dispatch;
            }
            0x82C45394 => {
    //   block [0x82C45394..0x82C453A0)
	// 82C45394: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C45398: 419A0008  beq cr6, 0x82c453a0
	if ctx.cr[6].eq {
	pc = 0x82C453A0; continue 'dispatch;
	}
	// 82C4539C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C453A0; continue 'dispatch;
            }
            0x82C453A0 => {
    //   block [0x82C453A0..0x82C453B4)
	// 82C453A0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C453A4: 419A0048  beq cr6, 0x82c453ec
	if ctx.cr[6].eq {
	pc = 0x82C453EC; continue 'dispatch;
	}
	// 82C453A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C453AC: 41980008  blt cr6, 0x82c453b4
	if ctx.cr[6].lt {
	pc = 0x82C453B4; continue 'dispatch;
	}
	// 82C453B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C453B4; continue 'dispatch;
            }
            0x82C453B4 => {
    //   block [0x82C453B4..0x82C453D4)
	// 82C453B4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C453B8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C453BC: 419A0018  beq cr6, 0x82c453d4
	if ctx.cr[6].eq {
	pc = 0x82C453D4; continue 'dispatch;
	}
	// 82C453C0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C453C4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C453C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C453CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C453D0: 4E800421  bctrl
	ctx.lr = 0x82C453D4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C453D4 => {
    //   block [0x82C453D4..0x82C453E4)
	// 82C453D4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C453D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C453DC: 41980008  blt cr6, 0x82c453e4
	if ctx.cr[6].lt {
	pc = 0x82C453E4; continue 'dispatch;
	}
	// 82C453E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C453E4; continue 'dispatch;
            }
            0x82C453E4 => {
    //   block [0x82C453E4..0x82C453EC)
	// 82C453E4: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C453E8: 4BFFFF98  b 0x82c45380
	pc = 0x82C45380; continue 'dispatch;
            }
            0x82C453EC => {
    //   block [0x82C453EC..0x82C453F4)
	// 82C453EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C453F0: 48064068  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C453F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C453F8 size=300
    let mut pc: u32 = 0x82C453F8;
    'dispatch: loop {
        match pc {
            0x82C453F8 => {
    //   block [0x82C453F8..0x82C4542C)
	// 82C453F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C453FC: 4806400D  bl 0x82ca9408
	ctx.lr = 0x82C45400;
	sub_82CA93D0(ctx, base);
	// 82C45400: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45404: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C45408: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C4540C: 387D0038  addi r3, r29, 0x38
	ctx.r[3].s64 = ctx.r[29].s64 + 56;
	// 82C45410: 48011331  bl 0x82c56740
	ctx.lr = 0x82C45414;
	sub_82C56740(ctx, base);
	// 82C45414: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45418: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C4541C: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45420: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45424: 40990008  ble cr6, 0x82c4542c
	if !ctx.cr[6].gt {
	pc = 0x82C4542C; continue 'dispatch;
	}
	// 82C45428: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4542C; continue 'dispatch;
            }
            0x82C4542C => {
    //   block [0x82C4542C..0x82C45440)
	// 82C4542C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45430: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45434: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45438: 40990008  ble cr6, 0x82c45440
	if !ctx.cr[6].gt {
	pc = 0x82C45440; continue 'dispatch;
	}
	// 82C4543C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45440; continue 'dispatch;
            }
            0x82C45440 => {
    //   block [0x82C45440..0x82C4544C)
	// 82C45440: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C45444: 419A0008  beq cr6, 0x82c4544c
	if ctx.cr[6].eq {
	pc = 0x82C4544C; continue 'dispatch;
	}
	// 82C45448: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C4544C; continue 'dispatch;
            }
            0x82C4544C => {
    //   block [0x82C4544C..0x82C45460)
	// 82C4544C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45450: 419A0048  beq cr6, 0x82c45498
	if ctx.cr[6].eq {
	pc = 0x82C45498; continue 'dispatch;
	}
	// 82C45454: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45458: 41980008  blt cr6, 0x82c45460
	if ctx.cr[6].lt {
	pc = 0x82C45460; continue 'dispatch;
	}
	// 82C4545C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45460; continue 'dispatch;
            }
            0x82C45460 => {
    //   block [0x82C45460..0x82C45480)
	// 82C45460: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45464: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45468: 419A0018  beq cr6, 0x82c45480
	if ctx.cr[6].eq {
	pc = 0x82C45480; continue 'dispatch;
	}
	// 82C4546C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45470: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C45474: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45478: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4547C: 4E800421  bctrl
	ctx.lr = 0x82C45480;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C45480 => {
    //   block [0x82C45480..0x82C45490)
	// 82C45480: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45484: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45488: 41980008  blt cr6, 0x82c45490
	if ctx.cr[6].lt {
	pc = 0x82C45490; continue 'dispatch;
	}
	// 82C4548C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45490; continue 'dispatch;
            }
            0x82C45490 => {
    //   block [0x82C45490..0x82C45498)
	// 82C45490: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C45494: 4BFFFF98  b 0x82c4542c
	pc = 0x82C4542C; continue 'dispatch;
            }
            0x82C45498 => {
    //   block [0x82C45498..0x82C454B0)
	// 82C45498: 83FD0018  lwz r31, 0x18(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4549C: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 82C454A0: 817D001C  lwz r11, 0x1c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C454A4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C454A8: 40990008  ble cr6, 0x82c454b0
	if !ctx.cr[6].gt {
	pc = 0x82C454B0; continue 'dispatch;
	}
	// 82C454AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C454B0; continue 'dispatch;
            }
            0x82C454B0 => {
    //   block [0x82C454B0..0x82C454C4)
	// 82C454B0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C454B4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C454B8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C454BC: 40990008  ble cr6, 0x82c454c4
	if !ctx.cr[6].gt {
	pc = 0x82C454C4; continue 'dispatch;
	}
	// 82C454C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C454C4; continue 'dispatch;
            }
            0x82C454C4 => {
    //   block [0x82C454C4..0x82C454D0)
	// 82C454C4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C454C8: 419A0008  beq cr6, 0x82c454d0
	if ctx.cr[6].eq {
	pc = 0x82C454D0; continue 'dispatch;
	}
	// 82C454CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C454D0; continue 'dispatch;
            }
            0x82C454D0 => {
    //   block [0x82C454D0..0x82C454E4)
	// 82C454D0: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C454D4: 419A0048  beq cr6, 0x82c4551c
	if ctx.cr[6].eq {
	pc = 0x82C4551C; continue 'dispatch;
	}
	// 82C454D8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C454DC: 41980008  blt cr6, 0x82c454e4
	if ctx.cr[6].lt {
	pc = 0x82C454E4; continue 'dispatch;
	}
	// 82C454E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C454E4; continue 'dispatch;
            }
            0x82C454E4 => {
    //   block [0x82C454E4..0x82C45504)
	// 82C454E4: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C454E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C454EC: 419A0018  beq cr6, 0x82c45504
	if ctx.cr[6].eq {
	pc = 0x82C45504; continue 'dispatch;
	}
	// 82C454F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C454F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C454F8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C454FC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45500: 4E800421  bctrl
	ctx.lr = 0x82C45504;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C45504 => {
    //   block [0x82C45504..0x82C45514)
	// 82C45504: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45508: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4550C: 41980008  blt cr6, 0x82c45514
	if ctx.cr[6].lt {
	pc = 0x82C45514; continue 'dispatch;
	}
	// 82C45510: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45514; continue 'dispatch;
            }
            0x82C45514 => {
    //   block [0x82C45514..0x82C4551C)
	// 82C45514: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C45518: 4BFFFF98  b 0x82c454b0
	pc = 0x82C454B0; continue 'dispatch;
            }
            0x82C4551C => {
    //   block [0x82C4551C..0x82C45524)
	// 82C4551C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C45520: 48063F38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C45528 size=220
    let mut pc: u32 = 0x82C45528;
    'dispatch: loop {
        match pc {
            0x82C45528 => {
    //   block [0x82C45528..0x82C45554)
	// 82C45528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4552C: 48063EDD  bl 0x82ca9408
	ctx.lr = 0x82C45530;
	sub_82CA93D0(ctx, base);
	// 82C45530: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45534: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C45538: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82C4553C: 3BDD0004  addi r30, r29, 4
	ctx.r[30].s64 = ctx.r[29].s64 + 4;
	// 82C45540: 83FD0008  lwz r31, 8(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45544: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45548: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4554C: 40990008  ble cr6, 0x82c45554
	if !ctx.cr[6].gt {
	pc = 0x82C45554; continue 'dispatch;
	}
	// 82C45550: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45554; continue 'dispatch;
            }
            0x82C45554 => {
    //   block [0x82C45554..0x82C45568)
	// 82C45554: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45558: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4555C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45560: 40990008  ble cr6, 0x82c45568
	if !ctx.cr[6].gt {
	pc = 0x82C45568; continue 'dispatch;
	}
	// 82C45564: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45568; continue 'dispatch;
            }
            0x82C45568 => {
    //   block [0x82C45568..0x82C45574)
	// 82C45568: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C4556C: 419A0008  beq cr6, 0x82c45574
	if ctx.cr[6].eq {
	pc = 0x82C45574; continue 'dispatch;
	}
	// 82C45570: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45574; continue 'dispatch;
            }
            0x82C45574 => {
    //   block [0x82C45574..0x82C45588)
	// 82C45574: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45578: 419A0084  beq cr6, 0x82c455fc
	if ctx.cr[6].eq {
	pc = 0x82C455FC; continue 'dispatch;
	}
	// 82C4557C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45580: 41980008  blt cr6, 0x82c45588
	if ctx.cr[6].lt {
	pc = 0x82C45588; continue 'dispatch;
	}
	// 82C45584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45588; continue 'dispatch;
            }
            0x82C45588 => {
    //   block [0x82C45588..0x82C455B0)
	// 82C45588: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4558C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45590: 419A0020  beq cr6, 0x82c455b0
	if ctx.cr[6].eq {
	pc = 0x82C455B0; continue 'dispatch;
	}
	// 82C45594: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45598: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4559C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C455A0: 4E800421  bctrl
	ctx.lr = 0x82C455A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C455A4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C455A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C455AC: 419A0014  beq cr6, 0x82c455c0
	if ctx.cr[6].eq {
	pc = 0x82C455C0; continue 'dispatch;
	}
            }
            0x82C455B0 => {
    //   block [0x82C455B0..0x82C455C0)
	// 82C455B0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C455B4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C455B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C455BC: 4BFFF445  bl 0x82c44a00
	ctx.lr = 0x82C455C0;
	sub_82C44A00(ctx, base);
	pc = 0x82C455C0; continue 'dispatch;
            }
            0x82C455C0 => {
    //   block [0x82C455C0..0x82C455E4)
	// 82C455C0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C455C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C455C8: 419A001C  beq cr6, 0x82c455e4
	if ctx.cr[6].eq {
	pc = 0x82C455E4; continue 'dispatch;
	}
	// 82C455CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C455D0: C03D0068  lfs f1, 0x68(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C455D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C455D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C455DC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C455E0: 4E800421  bctrl
	ctx.lr = 0x82C455E4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C455E4 => {
    //   block [0x82C455E4..0x82C455F4)
	// 82C455E4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C455E8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C455EC: 41980008  blt cr6, 0x82c455f4
	if ctx.cr[6].lt {
	pc = 0x82C455F4; continue 'dispatch;
	}
	// 82C455F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C455F4; continue 'dispatch;
            }
            0x82C455F4 => {
    //   block [0x82C455F4..0x82C455FC)
	// 82C455F4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 82C455F8: 4BFFFF5C  b 0x82c45554
	pc = 0x82C45554; continue 'dispatch;
            }
            0x82C455FC => {
    //   block [0x82C455FC..0x82C45604)
	// 82C455FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C45600: 48063E58  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C45608 size=320
    let mut pc: u32 = 0x82C45608;
    'dispatch: loop {
        match pc {
            0x82C45608 => {
    //   block [0x82C45608..0x82C45640)
	// 82C45608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4560C: 48063DF5  bl 0x82ca9400
	ctx.lr = 0x82C45610;
	sub_82CA93D0(ctx, base);
	// 82C45610: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45614: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C45618: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82C4561C: 897B006C  lbz r11, 0x6c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(108 as u32) ) } as u64;
	// 82C45620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45624: 409A011C  bne cr6, 0x82c45740
	if !ctx.cr[6].eq {
	pc = 0x82C45740; continue 'dispatch;
	}
	// 82C45628: 83FB0018  lwz r31, 0x18(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C4562C: 3B9B0014  addi r28, r27, 0x14
	ctx.r[28].s64 = ctx.r[27].s64 + 20;
	// 82C45630: 815B001C  lwz r10, 0x1c(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C45634: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45638: 40990008  ble cr6, 0x82c45640
	if !ctx.cr[6].gt {
	pc = 0x82C45640; continue 'dispatch;
	}
	// 82C4563C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45640; continue 'dispatch;
            }
            0x82C45640 => {
    //   block [0x82C45640..0x82C45654)
	// 82C45640: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45644: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45648: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4564C: 40990008  ble cr6, 0x82c45654
	if !ctx.cr[6].gt {
	pc = 0x82C45654; continue 'dispatch;
	}
	// 82C45650: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45654; continue 'dispatch;
            }
            0x82C45654 => {
    //   block [0x82C45654..0x82C45660)
	// 82C45654: 7F1CE040  cmplw cr6, r28, r28
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C45658: 419A0008  beq cr6, 0x82c45660
	if ctx.cr[6].eq {
	pc = 0x82C45660; continue 'dispatch;
	}
	// 82C4565C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45660; continue 'dispatch;
            }
            0x82C45660 => {
    //   block [0x82C45660..0x82C45674)
	// 82C45660: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45664: 419A00DC  beq cr6, 0x82c45740
	if ctx.cr[6].eq {
	pc = 0x82C45740; continue 'dispatch;
	}
	// 82C45668: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C4566C: 41980008  blt cr6, 0x82c45674
	if ctx.cr[6].lt {
	pc = 0x82C45674; continue 'dispatch;
	}
	// 82C45670: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45674; continue 'dispatch;
            }
            0x82C45674 => {
    //   block [0x82C45674..0x82C456B0)
	// 82C45674: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C45678: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C4567C: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 82C45680: 69490001  xori r9, r10, 1
	ctx.r[9].u64 = ctx.r[10].u64 ^ 1;
	// 82C45684: 553E063E  clrlwi r30, r9, 0x18
	ctx.r[30].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 82C45688: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C4568C: 419A0024  beq cr6, 0x82c456b0
	if ctx.cr[6].eq {
	pc = 0x82C456B0; continue 'dispatch;
	}
	// 82C45690: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45694: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45698: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4569C: 4E800421  bctrl
	ctx.lr = 0x82C456A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C456A0: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C456A4: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 82C456A8: 550BDFFE  rlwinm r11, r8, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 82C456AC: 48000008  b 0x82c456b4
	pc = 0x82C456B4; continue 'dispatch;
            }
            0x82C456B0 => {
    //   block [0x82C456B0..0x82C456B4)
	// 82C456B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C456B4; continue 'dispatch;
            }
            0x82C456B4 => {
    //   block [0x82C456B4..0x82C456E8)
	// 82C456B4: 557D063E  clrlwi r29, r11, 0x18
	ctx.r[29].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C456B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C456BC: 419A002C  beq cr6, 0x82c456e8
	if ctx.cr[6].eq {
	pc = 0x82C456E8; continue 'dispatch;
	}
	// 82C456C0: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C456C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C456C8: 419A0020  beq cr6, 0x82c456e8
	if ctx.cr[6].eq {
	pc = 0x82C456E8; continue 'dispatch;
	}
	// 82C456CC: 807F0010  lwz r3, 0x10(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C456D0: C03B0068  lfs f1, 0x68(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C456D4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82C456D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C456DC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C456E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C456E4: 4E800421  bctrl
	ctx.lr = 0x82C456E8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C456E8 => {
    //   block [0x82C456E8..0x82C45704)
	// 82C456E8: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C456EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C456F0: 40990014  ble cr6, 0x82c45704
	if !ctx.cr[6].gt {
	pc = 0x82C45704; continue 'dispatch;
	}
	// 82C456F4: 815B0030  lwz r10, 0x30(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C456F8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C456FC: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 82C45700: 48000028  b 0x82c45728
	pc = 0x82C45728; continue 'dispatch;
            }
            0x82C45704 => {
    //   block [0x82C45704..0x82C45718)
	// 82C45704: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C45708: 419A0010  beq cr6, 0x82c45718
	if ctx.cr[6].eq {
	pc = 0x82C45718; continue 'dispatch;
	}
	// 82C4570C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82C45710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45714: 409A0014  bne cr6, 0x82c45728
	if !ctx.cr[6].eq {
	pc = 0x82C45728; continue 'dispatch;
	}
	pc = 0x82C45718; continue 'dispatch;
            }
            0x82C45718 => {
    //   block [0x82C45718..0x82C45728)
	// 82C45718: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C4571C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C45720: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C45724: 4BFFF3B5  bl 0x82c44ad8
	ctx.lr = 0x82C45728;
	sub_82C44AD8(ctx, base);
	pc = 0x82C45728; continue 'dispatch;
            }
            0x82C45728 => {
    //   block [0x82C45728..0x82C45738)
	// 82C45728: 815C0008  lwz r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4572C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45730: 41980008  blt cr6, 0x82c45738
	if ctx.cr[6].lt {
	pc = 0x82C45738; continue 'dispatch;
	}
	// 82C45734: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45738; continue 'dispatch;
            }
            0x82C45738 => {
    //   block [0x82C45738..0x82C45740)
	// 82C45738: 3BFF001C  addi r31, r31, 0x1c
	ctx.r[31].s64 = ctx.r[31].s64 + 28;
	// 82C4573C: 4BFFFF04  b 0x82c45640
	pc = 0x82C45640; continue 'dispatch;
            }
            0x82C45740 => {
    //   block [0x82C45740..0x82C45748)
	// 82C45740: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C45744: 48063D0C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45748(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45748 size=92
    let mut pc: u32 = 0x82C45748;
    'dispatch: loop {
        match pc {
            0x82C45748 => {
    //   block [0x82C45748..0x82C4578C)
	// 82C45748: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4574C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C45750: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C45754: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C45758: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4575C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45760: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C45764: 897F006D  lbz r11, 0x6d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(109 as u32) ) } as u64;
	// 82C45768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4576C: 409A0020  bne cr6, 0x82c4578c
	if !ctx.cr[6].eq {
	pc = 0x82C4578C; continue 'dispatch;
	}
	// 82C45770: 4BFFF021  bl 0x82c44790
	ctx.lr = 0x82C45774;
	sub_82C44790(ctx, base);
	// 82C45774: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4577C: 4BFFFDAD  bl 0x82c45528
	ctx.lr = 0x82C45780;
	sub_82C45528(ctx, base);
	// 82C45780: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45784: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45788: 4BFFFE81  bl 0x82c45608
	ctx.lr = 0x82C4578C;
	sub_82C45608(ctx, base);
	pc = 0x82C4578C; continue 'dispatch;
            }
            0x82C4578C => {
    //   block [0x82C4578C..0x82C457A4)
	// 82C4578C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C45790: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C45794: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C45798: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4579C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C457A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C457A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C457A8 size=160
    let mut pc: u32 = 0x82C457A8;
    'dispatch: loop {
        match pc {
            0x82C457A8 => {
    //   block [0x82C457A8..0x82C457F4)
	// 82C457A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C457AC: 48063C5D  bl 0x82ca9408
	ctx.lr = 0x82C457B0;
	sub_82CA93D0(ctx, base);
	// 82C457B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C457B4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C457B8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C457BC: 387C0038  addi r3, r28, 0x38
	ctx.r[3].s64 = ctx.r[28].s64 + 56;
	// 82C457C0: 394BC384  addi r10, r11, -0x3c7c
	ctx.r[10].s64 = ctx.r[11].s64 + -15484;
	// 82C457C4: 915C0000  stw r10, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C457C8: 48010C69  bl 0x82c56430
	ctx.lr = 0x82C457CC;
	sub_82C56430(ctx, base);
	// 82C457CC: 807C0018  lwz r3, 0x18(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C457D0: 3BFC0014  addi r31, r28, 0x14
	ctx.r[31].s64 = ctx.r[28].s64 + 20;
	// 82C457D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C457D8: 419A001C  beq cr6, 0x82c457f4
	if ctx.cr[6].eq {
	pc = 0x82C457F4; continue 'dispatch;
	}
	// 82C457DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C457E0: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C457E4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C457E8: 4BFFDCA9  bl 0x82c43490
	ctx.lr = 0x82C457EC;
	sub_82C43490(ctx, base);
	// 82C457EC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C457F0: 4BBFFFC1  bl 0x828457b0
	ctx.lr = 0x82C457F4;
	sub_828457B0(ctx, base);
	pc = 0x82C457F4; continue 'dispatch;
            }
            0x82C457F4 => {
    //   block [0x82C457F4..0x82C4582C)
	// 82C457F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C457F8: 3BDC0004  addi r30, r28, 4
	ctx.r[30].s64 = ctx.r[28].s64 + 4;
	// 82C457FC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C45800: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C45804: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C45808: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4580C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45810: 419A001C  beq cr6, 0x82c4582c
	if ctx.cr[6].eq {
	pc = 0x82C4582C; continue 'dispatch;
	}
	// 82C45814: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C45818: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4581C: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45820: 4BFFDC11  bl 0x82c43430
	ctx.lr = 0x82C45824;
	sub_82C43430(ctx, base);
	// 82C45824: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45828: 4BBFFF89  bl 0x828457b0
	ctx.lr = 0x82C4582C;
	sub_828457B0(ctx, base);
	pc = 0x82C4582C; continue 'dispatch;
            }
            0x82C4582C => {
    //   block [0x82C4582C..0x82C45848)
	// 82C4582C: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82C45830: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C45834: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82C45838: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82C4583C: 4BFC08D5  bl 0x82c06110
	ctx.lr = 0x82C45840;
	sub_82C06110(ctx, base);
	// 82C45840: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C45844: 48063C14  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45848 size=80
    let mut pc: u32 = 0x82C45848;
    'dispatch: loop {
        match pc {
            0x82C45848 => {
    //   block [0x82C45848..0x82C45880)
	// 82C45848: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4584C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C45850: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C45854: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C45858: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4585C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45860: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C45864: 4BFFFF45  bl 0x82c457a8
	ctx.lr = 0x82C45868;
	sub_82C457A8(ctx, base);
	// 82C45868: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C4586C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45874: 419A000C  beq cr6, 0x82c45880
	if ctx.cr[6].eq {
	pc = 0x82C45880; continue 'dispatch;
	}
	// 82C45878: 4BBFFF39  bl 0x828457b0
	ctx.lr = 0x82C4587C;
	sub_828457B0(ctx, base);
	// 82C4587C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C45880; continue 'dispatch;
            }
            0x82C45880 => {
    //   block [0x82C45880..0x82C45898)
	// 82C45880: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C45884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C45888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4588C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C45890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C45894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45898 size=212
    let mut pc: u32 = 0x82C45898;
    'dispatch: loop {
        match pc {
            0x82C45898 => {
    //   block [0x82C45898..0x82C458CC)
	// 82C45898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4589C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C458A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C458A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C458A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C458AC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C458B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C458B4: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C458B8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C458BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C458C0: 409A000C  bne cr6, 0x82c458cc
	if !ctx.cr[6].eq {
	pc = 0x82C458CC; continue 'dispatch;
	}
	// 82C458C4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C458C8: 48000014  b 0x82c458dc
	pc = 0x82C458DC; continue 'dispatch;
            }
            0x82C458CC => {
    //   block [0x82C458CC..0x82C458DC)
	// 82C458CC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C458D0: 3900000C  li r8, 0xc
	ctx.r[8].s64 = 12;
	// 82C458D4: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C458D8: 7D6743D6  divw r11, r7, r8
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	pc = 0x82C458DC; continue 'dispatch;
            }
            0x82C458DC => {
    //   block [0x82C458DC..0x82C45908)
	// 82C458DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82C458E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C458E4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 82C458E8: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82C458EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C458F0: 4BFFE8D9  bl 0x82c441c8
	ctx.lr = 0x82C458F4;
	sub_82C441C8(ctx, base);
	// 82C458F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C458F8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C458FC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45900: 40990008  ble cr6, 0x82c45908
	if !ctx.cr[6].gt {
	pc = 0x82C45908; continue 'dispatch;
	}
	// 82C45904: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45908; continue 'dispatch;
            }
            0x82C45908 => {
    //   block [0x82C45908..0x82C45934)
	// 82C45908: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4590C: 394BFFF4  addi r10, r11, -0xc
	ctx.r[10].s64 = ctx.r[11].s64 + -12;
	// 82C45910: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C45914: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C45918: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C4591C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C45920: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C45924: 41990010  bgt cr6, 0x82c45934
	if ctx.cr[6].gt {
	pc = 0x82C45934; continue 'dispatch;
	}
	// 82C45928: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4592C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C45930: 40980008  bge cr6, 0x82c45938
	if !ctx.cr[6].lt {
	pc = 0x82C45938; continue 'dispatch;
	}
	pc = 0x82C45934; continue 'dispatch;
            }
            0x82C45934 => {
    //   block [0x82C45934..0x82C45938)
	// 82C45934: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45938; continue 'dispatch;
            }
            0x82C45938 => {
    //   block [0x82C45938..0x82C45950)
	// 82C45938: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4593C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 82C45940: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45944: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C45948: 41980008  blt cr6, 0x82c45950
	if ctx.cr[6].lt {
	pc = 0x82C45950; continue 'dispatch;
	}
	// 82C4594C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45950; continue 'dispatch;
            }
            0x82C45950 => {
    //   block [0x82C45950..0x82C4596C)
	// 82C45950: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C45954: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C45958: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4595C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C45960: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C45964: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C45968: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45970(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C45970 size=312
    let mut pc: u32 = 0x82C45970;
    'dispatch: loop {
        match pc {
            0x82C45970 => {
    //   block [0x82C45970..0x82C459BC)
	// 82C45970: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C45974: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C45978: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4597C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C45980: DBA1FFD0  stfd f29, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[29].u64 ) };
	// 82C45984: DBC1FFD8  stfd f30, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 82C45988: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82C4598C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45990: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C45994: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C45998: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82C4599C: 3BE30014  addi r31, r3, 0x14
	ctx.r[31].s64 = ctx.r[3].s64 + 20;
	// 82C459A0: FFC01090  fmr f30, f2
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82C459A4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C459A8: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82C459AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C459B0: 409A000C  bne cr6, 0x82c459bc
	if !ctx.cr[6].eq {
	pc = 0x82C459BC; continue 'dispatch;
	}
	// 82C459B4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82C459B8: 48000014  b 0x82c459cc
	pc = 0x82C459CC; continue 'dispatch;
            }
            0x82C459BC => {
    //   block [0x82C459BC..0x82C459CC)
	// 82C459BC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C459C0: 3900001C  li r8, 0x1c
	ctx.r[8].s64 = 28;
	// 82C459C4: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C459C8: 7D6743D6  divw r11, r7, r8
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[8].s32;
	pc = 0x82C459CC; continue 'dispatch;
            }
            0x82C459CC => {
    //   block [0x82C459CC..0x82C459F8)
	// 82C459CC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 82C459D0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82C459D4: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82C459D8: 388B0001  addi r4, r11, 1
	ctx.r[4].s64 = ctx.r[11].s64 + 1;
	// 82C459DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C459E0: 4BFFE919  bl 0x82c442f8
	ctx.lr = 0x82C459E4;
	sub_82C442F8(ctx, base);
	// 82C459E4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C459E8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C459EC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C459F0: 40990008  ble cr6, 0x82c459f8
	if !ctx.cr[6].gt {
	pc = 0x82C459F8; continue 'dispatch;
	}
	// 82C459F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C459F8; continue 'dispatch;
            }
            0x82C459F8 => {
    //   block [0x82C459F8..0x82C45A24)
	// 82C459F8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C459FC: 394BFFE4  addi r10, r11, -0x1c
	ctx.r[10].s64 = ctx.r[11].s64 + -28;
	// 82C45A00: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C45A04: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C45A08: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C45A0C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C45A10: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 82C45A14: 41990010  bgt cr6, 0x82c45a24
	if ctx.cr[6].gt {
	pc = 0x82C45A24; continue 'dispatch;
	}
	// 82C45A18: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45A1C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C45A20: 40980008  bge cr6, 0x82c45a28
	if !ctx.cr[6].lt {
	pc = 0x82C45A28; continue 'dispatch;
	}
	pc = 0x82C45A24; continue 'dispatch;
            }
            0x82C45A24 => {
    //   block [0x82C45A24..0x82C45A28)
	// 82C45A24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45A28; continue 'dispatch;
            }
            0x82C45A28 => {
    //   block [0x82C45A28..0x82C45A40)
	// 82C45A28: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C45A2C: 3BEBFFE4  addi r31, r11, -0x1c
	ctx.r[31].s64 = ctx.r[11].s64 + -28;
	// 82C45A30: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45A34: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82C45A38: 41980008  blt cr6, 0x82c45a40
	if ctx.cr[6].lt {
	pc = 0x82C45A40; continue 'dispatch;
	}
	// 82C45A3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82C45A40; continue 'dispatch;
            }
            0x82C45A40 => {
    //   block [0x82C45A40..0x82C45AA8)
	// 82C45A40: D3FF0004  stfs f31, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C45A44: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82C45A48: D3DF0008  stfs f30, 8(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C45A4C: D3BF000C  stfs f29, 0xc(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C45A50: 48064781  bl 0x82caa1d0
	ctx.lr = 0x82C45A54;
	sub_82CAA1D0(ctx, base);
	// 82C45A54: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82C45A58: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C45A5C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C45A60: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C45A64: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C45A68: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 82C45A6C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C45A70: C00A0C20  lfs f0, 0xc20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C45A74: ED6C0032  fmuls f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C45A78: ED4B07F2  fmuls f10, f11, f31
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 82C45A7C: FD20501E  fctiwz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82C45A80: 7D3F4FAE  stfiwx f9, r31, r9
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 82C45A84: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C45A88: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C45A8C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C45A90: CBA1FFD0  lfd f29, -0x30(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C45A94: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 82C45A98: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 82C45A9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C45AA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C45AA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45AA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45AA8 size=516
    let mut pc: u32 = 0x82C45AA8;
    'dispatch: loop {
        match pc {
            0x82C45AA8 => {
    //   block [0x82C45AA8..0x82C45B00)
	// 82C45AA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C45AAC: 48063951  bl 0x82ca93fc
	ctx.lr = 0x82C45AB0;
	sub_82CA93D0(ctx, base);
	// 82C45AB0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45AB4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82C45AB8: 3BA40004  addi r29, r4, 4
	ctx.r[29].s64 = ctx.r[4].s64 + 4;
	// 82C45ABC: 3B990004  addi r28, r25, 4
	ctx.r[28].s64 = ctx.r[25].s64 + 4;
	// 82C45AC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C45AC4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C45AC8: 4BFEE811  bl 0x82c342d8
	ctx.lr = 0x82C45ACC;
	sub_82C342D8(ctx, base);
	// 82C45ACC: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45AD0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 82C45AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45AD8: 419A0028  beq cr6, 0x82c45b00
	if ctx.cr[6].eq {
	pc = 0x82C45B00; continue 'dispatch;
	}
	// 82C45ADC: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C45AE0: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45AE4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C45AE8: 7C8B1A14  add r4, r11, r3
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 82C45AEC: 9B4A0000  stb r26, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C45AF0: 7D232050  subf r9, r3, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 82C45AF4: 7D251670  srawi r5, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82C45AF8: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C45AFC: 4BFDBE85  bl 0x82c21980
	ctx.lr = 0x82C45B00;
	sub_82C21980(ctx, base);
	pc = 0x82C45B00; continue 'dispatch;
            }
            0x82C45B00 => {
    //   block [0x82C45B00..0x82C45B14)
	// 82C45B00: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45B04: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82C45B08: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82C45B0C: 4099009C  ble cr6, 0x82c45ba8
	if !ctx.cr[6].gt {
	pc = 0x82C45BA8; continue 'dispatch;
	}
	// 82C45B10: 3BC00004  li r30, 4
	ctx.r[30].s64 = 4;
	pc = 0x82C45B14; continue 'dispatch;
            }
            0x82C45B14 => {
    //   block [0x82C45B14..0x82C45B60)
	// 82C45B14: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B18: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C45B1C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B20: 83EBFFFC  lwz r31, -4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C45B24: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B2C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45B30: 41990064  bgt cr6, 0x82c45b94
	if ctx.cr[6].gt {
	pc = 0x82C45B94; continue 'dispatch;
	}
	// 82C45B34: 41980060  blt cr6, 0x82c45b94
	if ctx.cr[6].lt {
	pc = 0x82C45B94; continue 'dispatch;
	}
	// 82C45B38: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45B3C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45B40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82C45B44: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82C45B48: 40980024  bge cr6, 0x82c45b6c
	if !ctx.cr[6].lt {
	pc = 0x82C45B6C; continue 'dispatch;
	}
	// 82C45B4C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 82C45B50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C45B54: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45B58: 40980008  bge cr6, 0x82c45b60
	if !ctx.cr[6].lt {
	pc = 0x82C45B60; continue 'dispatch;
	}
	// 82C45B5C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82C45B60; continue 'dispatch;
            }
            0x82C45B60 => {
    //   block [0x82C45B60..0x82C45B6C)
	// 82C45B60: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C45B64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C45B68: 4BFE0739  bl 0x82c262a0
	ctx.lr = 0x82C45B6C;
	sub_82C262A0(ctx, base);
	pc = 0x82C45B6C; continue 'dispatch;
            }
            0x82C45B6C => {
    //   block [0x82C45B6C..0x82C45B94)
	// 82C45B6C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45B70: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B74: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82C45B78: 7FE9512E  stwx r31, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
	// 82C45B7C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45B80: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82C45B84: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 82C45B88: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45B8C: 7CFE5A14  add r7, r30, r11
	ctx.r[7].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 82C45B90: 9347FFFC  stw r26, -4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-4 as u32), ctx.r[26].u32 ) };
	pc = 0x82C45B94; continue 'dispatch;
            }
            0x82C45B94 => {
    //   block [0x82C45B94..0x82C45BA8)
	// 82C45B94: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45B98: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 82C45B9C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C45BA0: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45BA4: 4198FF70  blt cr6, 0x82c45b14
	if ctx.cr[6].lt {
	pc = 0x82C45B14; continue 'dispatch;
	}
	pc = 0x82C45BA8; continue 'dispatch;
            }
            0x82C45BA8 => {
    //   block [0x82C45BA8..0x82C45BD0)
	// 82C45BA8: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45BAC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82C45BB0: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82C45BB4: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 82C45BB8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 82C45BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45BC0: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 82C45BC4: 4099003C  ble cr6, 0x82c45c00
	if !ctx.cr[6].gt {
	pc = 0x82C45C00; continue 'dispatch;
	}
	// 82C45BC8: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 82C45BCC: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x82C45BD0; continue 'dispatch;
            }
            0x82C45BD0 => {
    //   block [0x82C45BD0..0x82C45BEC)
	// 82C45BD0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45BD4: 7D49582E  lwzx r10, r9, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C45BD8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C45BDC: 419A0010  beq cr6, 0x82c45bec
	if ctx.cr[6].eq {
	pc = 0x82C45BEC; continue 'dispatch;
	}
	// 82C45BE0: 7D48592E  stwx r10, r8, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32), ctx.r[10].u32) };
	// 82C45BE4: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 82C45BE8: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	pc = 0x82C45BEC; continue 'dispatch;
            }
            0x82C45BEC => {
    //   block [0x82C45BEC..0x82C45C00)
	// 82C45BEC: 8179000C  lwz r11, 0xc(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45BF0: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82C45BF4: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82C45BF8: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45BFC: 4198FFD4  blt cr6, 0x82c45bd0
	if ctx.cr[6].lt {
	pc = 0x82C45BD0; continue 'dispatch;
	}
	pc = 0x82C45C00; continue 'dispatch;
            }
            0x82C45C00 => {
    //   block [0x82C45C00..0x82C45C44)
	// 82C45C00: 90F9000C  stw r7, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82C45C04: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C45C08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82C45C0C: 4BFEE6CD  bl 0x82c342d8
	ctx.lr = 0x82C45C10;
	sub_82C342D8(ctx, base);
	// 82C45C10: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 82C45C14: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C45C18: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C45C1C: 419A0028  beq cr6, 0x82c45c44
	if ctx.cr[6].eq {
	pc = 0x82C45C44; continue 'dispatch;
	}
	// 82C45C20: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82C45C24: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C45C28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45C2C: 7C8BFA14  add r4, r11, r31
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 82C45C30: 9B4A0000  stb r26, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[26].u8 ) };
	// 82C45C34: 7D3F2050  subf r9, r31, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 82C45C38: 7D251670  srawi r5, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 82C45C3C: 88C10050  lbz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C45C40: 4BFDBD41  bl 0x82c21980
	ctx.lr = 0x82C45C44;
	sub_82C21980(ctx, base);
	pc = 0x82C45C44; continue 'dispatch;
            }
            0x82C45C44 => {
    //   block [0x82C45C44..0x82C45C54)
	// 82C45C44: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C45C48: 2B1E0001  cmplwi cr6, r30, 1
	ctx.cr[6].compare_u32(ctx.r[30].u32, 1 as u32, &mut ctx.xer);
	// 82C45C4C: 40990030  ble cr6, 0x82c45c7c
	if !ctx.cr[6].gt {
	pc = 0x82C45C7C; continue 'dispatch;
	}
	// 82C45C50: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	pc = 0x82C45C54; continue 'dispatch;
            }
            0x82C45C54 => {
    //   block [0x82C45C54..0x82C45C7C)
	// 82C45C54: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82C45C58: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45C5C: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45C60: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45C64: 7F073040  cmplw cr6, r7, r6
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82C45C68: 40980014  bge cr6, 0x82c45c7c
	if !ctx.cr[6].lt {
	pc = 0x82C45C7C; continue 'dispatch;
	}
	// 82C45C6C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82C45C70: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82C45C74: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82C45C78: 4198FFDC  blt cr6, 0x82c45c54
	if ctx.cr[6].lt {
	pc = 0x82C45C54; continue 'dispatch;
	}
	pc = 0x82C45C7C; continue 'dispatch;
            }
            0x82C45C7C => {
    //   block [0x82C45C7C..0x82C45CA4)
	// 82C45C7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C45C80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C45C84: 4BFEE655  bl 0x82c342d8
	ctx.lr = 0x82C45C88;
	sub_82C342D8(ctx, base);
	// 82C45C88: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C45C8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C45C90: 4BFEE649  bl 0x82c342d8
	ctx.lr = 0x82C45C94;
	sub_82C342D8(ctx, base);
	// 82C45C94: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C45C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45C9C: 419A0008  beq cr6, 0x82c45ca4
	if ctx.cr[6].eq {
	pc = 0x82C45CA4; continue 'dispatch;
	}
	// 82C45CA0: 4BBFFB11  bl 0x828457b0
	ctx.lr = 0x82C45CA4;
	sub_828457B0(ctx, base);
	pc = 0x82C45CA4; continue 'dispatch;
            }
            0x82C45CA4 => {
    //   block [0x82C45CA4..0x82C45CAC)
	// 82C45CA4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82C45CA8: 480637A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C45CB0 size=328
    let mut pc: u32 = 0x82C45CB0;
    'dispatch: loop {
        match pc {
            0x82C45CB0 => {
    //   block [0x82C45CB0..0x82C45CEC)
	// 82C45CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C45CB4: 48063751  bl 0x82ca9404
	ctx.lr = 0x82C45CB8;
	sub_82CA93D0(ctx, base);
	// 82C45CB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45CBC: 83640000  lwz r27, 0(r4)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45CC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45CC4: 81640020  lwz r11, 0x20(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C45CC8: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 82C45CCC: 576A06F6  rlwinm r10, r27, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 82C45CD0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C45CD4: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82C45CD8: 419A0014  beq cr6, 0x82c45cec
	if ctx.cr[6].eq {
	pc = 0x82C45CEC; continue 'dispatch;
	}
	// 82C45CDC: C0040024  lfs f0, 0x24(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C45CE0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C45CE4: C1A40028  lfs f13, 0x28(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C45CE8: 48000010  b 0x82c45cf8
	pc = 0x82C45CF8; continue 'dispatch;
            }
            0x82C45CEC => {
    //   block [0x82C45CEC..0x82C45CF8)
	// 82C45CEC: C0050008  lfs f0, 8(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C45CF0: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C45CF4: C1A5000C  lfs f13, 0xc(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x82C45CF8; continue 'dispatch;
            }
            0x82C45CF8 => {
    //   block [0x82C45CF8..0x82C45D18)
	// 82C45CF8: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C45CFC: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45D00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82C45D04: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C45D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45D0C: 419A0040  beq cr6, 0x82c45d4c
	if ctx.cr[6].eq {
	pc = 0x82C45D4C; continue 'dispatch;
	}
	// 82C45D10: 811F0034  lwz r8, 0x34(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C45D14: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82C45D18; continue 'dispatch;
            }
            0x82C45D18 => {
    //   block [0x82C45D18..0x82C45D3C)
	// 82C45D18: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45D1C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45D20: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82C45D24: 409A001C  bne cr6, 0x82c45d40
	if !ctx.cr[6].eq {
	pc = 0x82C45D40; continue 'dispatch;
	}
	// 82C45D28: 8929000C  lbz r9, 0xc(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45D2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C45D30: 419A000C  beq cr6, 0x82c45d3c
	if ctx.cr[6].eq {
	pc = 0x82C45D3C; continue 'dispatch;
	}
	// 82C45D34: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82C45D38: 48000008  b 0x82c45d40
	pc = 0x82C45D40; continue 'dispatch;
            }
            0x82C45D3C => {
    //   block [0x82C45D3C..0x82C45D40)
	// 82C45D3C: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	pc = 0x82C45D40; continue 'dispatch;
            }
            0x82C45D40 => {
    //   block [0x82C45D40..0x82C45D4C)
	// 82C45D40: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82C45D44: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82C45D48: 4082FFD0  bne 0x82c45d18
	if !ctx.cr[0].eq {
	pc = 0x82C45D18; continue 'dispatch;
	}
	pc = 0x82C45D4C; continue 'dispatch;
            }
            0x82C45D4C => {
    //   block [0x82C45D4C..0x82C45D74)
	// 82C45D4C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82C45D50: 4BFFDCB1  bl 0x82c43a00
	ctx.lr = 0x82C45D54;
	sub_82C43A00(ctx, base);
	// 82C45D54: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45D58: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82C45D5C: 4BFFDDB5  bl 0x82c43b10
	ctx.lr = 0x82C45D60;
	sub_82C43B10(ctx, base);
	// 82C45D60: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45D64: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C45D68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45D6C: 40990070  ble cr6, 0x82c45ddc
	if !ctx.cr[6].gt {
	pc = 0x82C45DDC; continue 'dispatch;
	}
	// 82C45D70: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82C45D74; continue 'dispatch;
            }
            0x82C45D74 => {
    //   block [0x82C45D74..0x82C45DA8)
	// 82C45D74: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45D78: 815F0034  lwz r10, 0x34(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 82C45D7C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C45D80: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45D84: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C45D88: 409A0040  bne cr6, 0x82c45dc8
	if !ctx.cr[6].eq {
	pc = 0x82C45DC8; continue 'dispatch;
	}
	// 82C45D8C: 894B000C  lbz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45D94: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45D98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C45D9C: 419A000C  beq cr6, 0x82c45da8
	if ctx.cr[6].eq {
	pc = 0x82C45DA8; continue 'dispatch;
	}
	// 82C45DA0: 4BFFFAF9  bl 0x82c45898
	ctx.lr = 0x82C45DA4;
	sub_82C45898(ctx, base);
	// 82C45DA4: 48000024  b 0x82c45dc8
	pc = 0x82C45DC8; continue 'dispatch;
            }
            0x82C45DA8 => {
    //   block [0x82C45DA8..0x82C45DC8)
	// 82C45DA8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C45DAC: C06B0018  lfs f3, 0x18(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C45DB0: C04B0014  lfs f2, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82C45DB4: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82C45DB8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C45DBC: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82C45DC0: FC206818  frsp f1, f13
	ctx.f[1].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82C45DC4: 4BFFFBAD  bl 0x82c45970
	ctx.lr = 0x82C45DC8;
	sub_82C45970(ctx, base);
	pc = 0x82C45DC8; continue 'dispatch;
            }
            0x82C45DC8 => {
    //   block [0x82C45DC8..0x82C45DDC)
	// 82C45DC8: 817C000C  lwz r11, 0xc(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C45DCC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C45DD0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C45DD4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C45DD8: 4198FF9C  blt cr6, 0x82c45d74
	if ctx.cr[6].lt {
	pc = 0x82C45D74; continue 'dispatch;
	}
	pc = 0x82C45DDC; continue 'dispatch;
            }
            0x82C45DDC => {
    //   block [0x82C45DDC..0x82C45DF8)
	// 82C45DDC: 576B97FE  rlwinm r11, r27, 0x12, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00003FFFu64;
	// 82C45DE0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C45DE4: 997F006C  stb r11, 0x6c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u8 ) };
	// 82C45DE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C45DEC: 995F006D  stb r10, 0x6d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(109 as u32), ctx.r[10].u8 ) };
	// 82C45DF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C45DF4: 48063660  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45DF8 size=212
    let mut pc: u32 = 0x82C45DF8;
    'dispatch: loop {
        match pc {
            0x82C45DF8 => {
    //   block [0x82C45DF8..0x82C45E6C)
	// 82C45DF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C45DFC: 48063609  bl 0x82ca9404
	ctx.lr = 0x82C45E00;
	sub_82CA93D0(ctx, base);
	// 82C45E00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45E04: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82C45E08: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C45E0C: 83DD0010  lwz r30, 0x10(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C45E10: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C45E14: 4BFFC69D  bl 0x82c424b0
	ctx.lr = 0x82C45E18;
	sub_82C424B0(ctx, base);
	// 82C45E18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C45E1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C45E20: 419A0064  beq cr6, 0x82c45e84
	if ctx.cr[6].eq {
	pc = 0x82C45E84; continue 'dispatch;
	}
	// 82C45E24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45E28: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C45E2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45E30: 388A4FA0  addi r4, r10, 0x4fa0
	ctx.r[4].s64 = ctx.r[10].s64 + 20384;
	// 82C45E34: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C45E38: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C45E3C: 4E800421  bctrl
	ctx.lr = 0x82C45E40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45E40: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82C45E44: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82C45E48: 419A003C  beq cr6, 0x82c45e84
	if ctx.cr[6].eq {
	pc = 0x82C45E84; continue 'dispatch;
	}
	// 82C45E4C: 38600070  li r3, 0x70
	ctx.r[3].s64 = 112;
	// 82C45E50: 4B5D9409  bl 0x8221f258
	ctx.lr = 0x82C45E54;
	sub_8221F258(ctx, base);
	// 82C45E54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C45E58: 419A0014  beq cr6, 0x82c45e6c
	if ctx.cr[6].eq {
	pc = 0x82C45E6C; continue 'dispatch;
	}
	// 82C45E5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45E60: 4BFFE5F1  bl 0x82c44450
	ctx.lr = 0x82C45E64;
	sub_82C44450(ctx, base);
	// 82C45E64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45E68: 48000008  b 0x82c45e70
	pc = 0x82C45E70; continue 'dispatch;
            }
            0x82C45E6C => {
    //   block [0x82C45E6C..0x82C45E70)
	// 82C45E6C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C45E70; continue 'dispatch;
            }
            0x82C45E70 => {
    //   block [0x82C45E70..0x82C45E80)
	// 82C45E70: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82C45E74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82C45E78: 409A0018  bne cr6, 0x82c45e90
	if !ctx.cr[6].eq {
	pc = 0x82C45E90; continue 'dispatch;
	}
	// 82C45E7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	pc = 0x82C45E80; continue 'dispatch;
            }
            0x82C45E80 => {
    //   block [0x82C45E80..0x82C45E84)
	// 82C45E80: 4BFF2C99  bl 0x82c38b18
	ctx.lr = 0x82C45E84;
	sub_82C38B18(ctx, base);
	pc = 0x82C45E84; continue 'dispatch;
            }
            0x82C45E84 => {
    //   block [0x82C45E84..0x82C45E90)
	// 82C45E84: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C45E88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C45E8C: 480635C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C45E90 => {
    //   block [0x82C45E90..0x82C45ECC)
	// 82C45E90: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82C45E94: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82C45E98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C45E9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45EA0: 4BFFFE11  bl 0x82c45cb0
	ctx.lr = 0x82C45EA4;
	sub_82C45CB0(ctx, base);
	// 82C45EA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C45EA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C45EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45EB0: 419AFFD0  beq cr6, 0x82c45e80
	if ctx.cr[6].eq {
	pc = 0x82C45E80; continue 'dispatch;
	}
	// 82C45EB4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C45EB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C45EBC: 4BFF2C5D  bl 0x82c38b18
	ctx.lr = 0x82C45EC0;
	sub_82C38B18(ctx, base);
	// 82C45EC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45EC4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C45EC8: 4806358C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C45ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C45ED0 size=396
    let mut pc: u32 = 0x82C45ED0;
    'dispatch: loop {
        match pc {
            0x82C45ED0 => {
    //   block [0x82C45ED0..0x82C45F38)
	// 82C45ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C45ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C45ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C45EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C45EE0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C45EE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45EE8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C45EEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45EF0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45EF4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45EF8: 4E800421  bctrl
	ctx.lr = 0x82C45EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45EFC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C45F00: 41980038  blt cr6, 0x82c45f38
	if ctx.cr[6].lt {
	pc = 0x82C45F38; continue 'dispatch;
	}
	// 82C45F04: 409A0118  bne cr6, 0x82c4601c
	if !ctx.cr[6].eq {
	pc = 0x82C4601C; continue 'dispatch;
	}
	// 82C45F08: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45F0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45F10: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C45F14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45F18: 4E800421  bctrl
	ctx.lr = 0x82C45F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45F1C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C45F20: 41980070  blt cr6, 0x82c45f90
	if ctx.cr[6].lt {
	pc = 0x82C45F90; continue 'dispatch;
	}
	// 82C45F24: 409A00F8  bne cr6, 0x82c4601c
	if !ctx.cr[6].eq {
	pc = 0x82C4601C; continue 'dispatch;
	}
	// 82C45F28: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C45F2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45F30: 419A0110  beq cr6, 0x82c46040
	if ctx.cr[6].eq {
	pc = 0x82C46040; continue 'dispatch;
	}
	// 82C45F34: 48000024  b 0x82c45f58
	pc = 0x82C45F58; continue 'dispatch;
            }
            0x82C45F38 => {
    //   block [0x82C45F38..0x82C45F58)
	// 82C45F38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45F40: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C45F44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C45F48: 4E800421  bctrl
	ctx.lr = 0x82C45F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C45F4C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C45F50: 41980040  blt cr6, 0x82c45f90
	if ctx.cr[6].lt {
	pc = 0x82C45F90; continue 'dispatch;
	}
	// 82C45F54: 409A00C8  bne cr6, 0x82c4601c
	if !ctx.cr[6].eq {
	pc = 0x82C4601C; continue 'dispatch;
	}
            }
            0x82C45F58 => {
    //   block [0x82C45F58..0x82C45F90)
	// 82C45F58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45F5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C45F60: 4BFDB8F9  bl 0x82c21858
	ctx.lr = 0x82C45F64;
	sub_82C21858(ctx, base);
	// 82C45F64: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C45F68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45F6C: 4BFFCD5D  bl 0x82c42cc8
	ctx.lr = 0x82C45F70;
	sub_82C42CC8(ctx, base);
	// 82C45F70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C45F74: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C45F78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C45F7C: 4BFF26AD  bl 0x82c38628
	ctx.lr = 0x82C45F80;
	sub_82C38628(ctx, base);
	// 82C45F80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C45F84: 4BFE4A6D  bl 0x82c2a9f0
	ctx.lr = 0x82C45F88;
	sub_82C2A9F0(ctx, base);
	// 82C45F88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45F8C: 480000B8  b 0x82c46044
	pc = 0x82C46044; continue 'dispatch;
            }
            0x82C45F90 => {
    //   block [0x82C45F90..0x82C46014)
	// 82C45F90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C45F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C45F98: 4BFDAF39  bl 0x82c20ed0
	ctx.lr = 0x82C45F9C;
	sub_82C20ED0(ctx, base);
	// 82C45F9C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C45FA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45FA4: 4BFFCD25  bl 0x82c42cc8
	ctx.lr = 0x82C45FA8;
	sub_82C42CC8(ctx, base);
	// 82C45FA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C45FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C45FB0: 419A0064  beq cr6, 0x82c46014
	if ctx.cr[6].eq {
	pc = 0x82C46014; continue 'dispatch;
	}
	// 82C45FB4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C45FB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C45FBC: 392ABB00  addi r9, r10, -0x4500
	ctx.r[9].s64 = ctx.r[10].s64 + -17664;
	// 82C45FC0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C45FC4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C45FC8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C45FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C45FD0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C45FD4: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C45FD8: 4BFFFAD1  bl 0x82c45aa8
	ctx.lr = 0x82C45FDC;
	sub_82C45AA8(ctx, base);
	// 82C45FDC: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C45FE0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C45FE4: 419A0040  beq cr6, 0x82c46024
	if ctx.cr[6].eq {
	pc = 0x82C46024; continue 'dispatch;
	}
	// 82C45FE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C45FEC: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C45FF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C45FF4: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C45FF8: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C45FFC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C46000: 4E800421  bctrl
	ctx.lr = 0x82C46004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46004: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46008: 4BFBF7F1  bl 0x82c057f8
	ctx.lr = 0x82C4600C;
	sub_82C057F8(ctx, base);
	// 82C4600C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46010: 4BFE9EB1  bl 0x82c2fec0
	ctx.lr = 0x82C46014;
	sub_82C2FEC0(ctx, base);
            }
            0x82C46014 => {
    //   block [0x82C46014..0x82C4601C)
	// 82C46014: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C46018: 4BFF0759  bl 0x82c36770
	ctx.lr = 0x82C4601C;
	sub_82C36770(ctx, base);
	pc = 0x82C4601C; continue 'dispatch;
            }
            0x82C4601C => {
    //   block [0x82C4601C..0x82C46024)
	// 82C4601C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C46020: 48000024  b 0x82c46044
	pc = 0x82C46044; continue 'dispatch;
            }
            0x82C46024 => {
    //   block [0x82C46024..0x82C46040)
	// 82C46024: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C46028: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4602C: 4BFF25FD  bl 0x82c38628
	ctx.lr = 0x82C46030;
	sub_82C38628(ctx, base);
	// 82C46030: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46034: 4BFE9E8D  bl 0x82c2fec0
	ctx.lr = 0x82C46038;
	sub_82C2FEC0(ctx, base);
	// 82C46038: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C4603C: 4BFF0735  bl 0x82c36770
	ctx.lr = 0x82C46040;
	sub_82C36770(ctx, base);
	pc = 0x82C46040; continue 'dispatch;
            }
            0x82C46040 => {
    //   block [0x82C46040..0x82C46044)
	// 82C46040: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C46044; continue 'dispatch;
            }
            0x82C46044 => {
    //   block [0x82C46044..0x82C4605C)
	// 82C46044: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C46048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4604C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46050: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46054: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46058: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46060 size=396
    let mut pc: u32 = 0x82C46060;
    'dispatch: loop {
        match pc {
            0x82C46060 => {
    //   block [0x82C46060..0x82C460C8)
	// 82C46060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46064: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46068: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4606C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46070: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46078: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4607C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46080: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46084: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46088: 4E800421  bctrl
	ctx.lr = 0x82C4608C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4608C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C46090: 41980038  blt cr6, 0x82c460c8
	if ctx.cr[6].lt {
	pc = 0x82C460C8; continue 'dispatch;
	}
	// 82C46094: 409A0118  bne cr6, 0x82c461ac
	if !ctx.cr[6].eq {
	pc = 0x82C461AC; continue 'dispatch;
	}
	// 82C46098: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4609C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C460A0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C460A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C460A8: 4E800421  bctrl
	ctx.lr = 0x82C460AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C460AC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C460B0: 41980070  blt cr6, 0x82c46120
	if ctx.cr[6].lt {
	pc = 0x82C46120; continue 'dispatch;
	}
	// 82C460B4: 409A00F8  bne cr6, 0x82c461ac
	if !ctx.cr[6].eq {
	pc = 0x82C461AC; continue 'dispatch;
	}
	// 82C460B8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C460BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C460C0: 419A0110  beq cr6, 0x82c461d0
	if ctx.cr[6].eq {
	pc = 0x82C461D0; continue 'dispatch;
	}
	// 82C460C4: 48000024  b 0x82c460e8
	pc = 0x82C460E8; continue 'dispatch;
            }
            0x82C460C8 => {
    //   block [0x82C460C8..0x82C460E8)
	// 82C460C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C460CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C460D0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C460D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C460D8: 4E800421  bctrl
	ctx.lr = 0x82C460DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C460DC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C460E0: 41980040  blt cr6, 0x82c46120
	if ctx.cr[6].lt {
	pc = 0x82C46120; continue 'dispatch;
	}
	// 82C460E4: 409A00C8  bne cr6, 0x82c461ac
	if !ctx.cr[6].eq {
	pc = 0x82C461AC; continue 'dispatch;
	}
            }
            0x82C460E8 => {
    //   block [0x82C460E8..0x82C46120)
	// 82C460E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C460EC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C460F0: 4BFDB769  bl 0x82c21858
	ctx.lr = 0x82C460F4;
	sub_82C21858(ctx, base);
	// 82C460F4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C460F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C460FC: 4BFFCF0D  bl 0x82c43008
	ctx.lr = 0x82C46100;
	sub_82C43008(ctx, base);
	// 82C46100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46104: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C46108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C4610C: 4BFF251D  bl 0x82c38628
	ctx.lr = 0x82C46110;
	sub_82C38628(ctx, base);
	// 82C46110: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C46114: 4BFE48DD  bl 0x82c2a9f0
	ctx.lr = 0x82C46118;
	sub_82C2A9F0(ctx, base);
	// 82C46118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4611C: 480000B8  b 0x82c461d4
	pc = 0x82C461D4; continue 'dispatch;
            }
            0x82C46120 => {
    //   block [0x82C46120..0x82C461A4)
	// 82C46120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C46124: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C46128: 480011E1  bl 0x82c47308
	ctx.lr = 0x82C4612C;
	sub_82C47308(ctx, base);
	// 82C4612C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C46130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46134: 4BFFCED5  bl 0x82c43008
	ctx.lr = 0x82C46138;
	sub_82C43008(ctx, base);
	// 82C46138: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4613C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46140: 419A0064  beq cr6, 0x82c461a4
	if ctx.cr[6].eq {
	pc = 0x82C461A4; continue 'dispatch;
	}
	// 82C46144: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C46148: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4614C: 392AC380  addi r9, r10, -0x3c80
	ctx.r[9].s64 = ctx.r[10].s64 + -15488;
	// 82C46150: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C46154: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C46158: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C4615C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46160: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C46164: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C46168: 4BFFF941  bl 0x82c45aa8
	ctx.lr = 0x82C4616C;
	sub_82C45AA8(ctx, base);
	// 82C4616C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C46170: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C46174: 419A0040  beq cr6, 0x82c461b4
	if ctx.cr[6].eq {
	pc = 0x82C461B4; continue 'dispatch;
	}
	// 82C46178: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4617C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C46180: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46184: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C46188: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C4618C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C46190: 4E800421  bctrl
	ctx.lr = 0x82C46194;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46198: 4BFBF661  bl 0x82c057f8
	ctx.lr = 0x82C4619C;
	sub_82C057F8(ctx, base);
	// 82C4619C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C461A0: 4BFFC779  bl 0x82c42918
	ctx.lr = 0x82C461A4;
	sub_82C42918(ctx, base);
            }
            0x82C461A4 => {
    //   block [0x82C461A4..0x82C461AC)
	// 82C461A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C461A8: 4BFD5E19  bl 0x82c1bfc0
	ctx.lr = 0x82C461AC;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C461AC; continue 'dispatch;
            }
            0x82C461AC => {
    //   block [0x82C461AC..0x82C461B4)
	// 82C461AC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C461B0: 48000024  b 0x82c461d4
	pc = 0x82C461D4; continue 'dispatch;
            }
            0x82C461B4 => {
    //   block [0x82C461B4..0x82C461D0)
	// 82C461B4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C461B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C461BC: 4BFF246D  bl 0x82c38628
	ctx.lr = 0x82C461C0;
	sub_82C38628(ctx, base);
	// 82C461C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C461C4: 4BFFC755  bl 0x82c42918
	ctx.lr = 0x82C461C8;
	sub_82C42918(ctx, base);
	// 82C461C8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C461CC: 4BFD5DF5  bl 0x82c1bfc0
	ctx.lr = 0x82C461D0;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C461D0; continue 'dispatch;
            }
            0x82C461D0 => {
    //   block [0x82C461D0..0x82C461D4)
	// 82C461D0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C461D4; continue 'dispatch;
            }
            0x82C461D4 => {
    //   block [0x82C461D4..0x82C461EC)
	// 82C461D4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C461D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C461DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C461E0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C461E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C461E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C461F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C461F0 size=16
    let mut pc: u32 = 0x82C461F0;
    'dispatch: loop {
        match pc {
            0x82C461F0 => {
    //   block [0x82C461F0..0x82C46200)
	// 82C461F0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C461F4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C461F8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C461FC: 4BFFFCD4  b 0x82c45ed0
	sub_82C45ED0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C46200 size=16
    let mut pc: u32 = 0x82C46200;
    'dispatch: loop {
        match pc {
            0x82C46200 => {
    //   block [0x82C46200..0x82C46210)
	// 82C46200: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C46204: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C46208: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C4620C: 4BFFFE54  b 0x82c46060
	sub_82C46060(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46210(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C46210 size=128
    let mut pc: u32 = 0x82C46210;
    'dispatch: loop {
        match pc {
            0x82C46210 => {
    //   block [0x82C46210..0x82C4623C)
	// 82C46210: 89630030  lbz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C46214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46218: 419A003C  beq cr6, 0x82c46254
	if ctx.cr[6].eq {
	pc = 0x82C46254; continue 'dispatch;
	}
	// 82C4621C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C46220: C00B9040  lfs f0, -0x6fc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46224: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C46228: 41980014  blt cr6, 0x82c4623c
	if ctx.cr[6].lt {
	pc = 0x82C4623C; continue 'dispatch;
	}
	// 82C4622C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46230: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46234: EC200B7C  fnmsubs f1, f0, f13, f1
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C46238: 4800001C  b 0x82c46254
	pc = 0x82C46254; continue 'dispatch;
            }
            0x82C4623C => {
    //   block [0x82C4623C..0x82C46254)
	// 82C4623C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C46240: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82C46244: 40980010  bge cr6, 0x82c46254
	if !ctx.cr[6].lt {
	pc = 0x82C46254; continue 'dispatch;
	}
	// 82C46248: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4624C: C1AB0C4C  lfs f13, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46250: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	pc = 0x82C46254; continue 'dispatch;
            }
            0x82C46254 => {
    //   block [0x82C46254..0x82C46290)
	// 82C46254: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46258: D0230004  stfs f1, 4(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C4625C: D0230000  stfs f1, 0(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C46260: D023001C  stfs f1, 0x1c(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C46264: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46268: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C4626C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46270: D003002C  stfs f0, 0x2c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82C46274: D0030028  stfs f0, 0x28(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82C46278: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C4627C: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82C46280: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C46284: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C46288: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4628C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C46290 size=12
    let mut pc: u32 = 0x82C46290;
    'dispatch: loop {
        match pc {
            0x82C46290 => {
    //   block [0x82C46290..0x82C4629C)
	// 82C46290: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C46294: 386B4FAC  addi r3, r11, 0x4fac
	ctx.r[3].s64 = ctx.r[11].s64 + 20396;
	// 82C46298: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C462A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C462A0 size=12
    let mut pc: u32 = 0x82C462A0;
    'dispatch: loop {
        match pc {
            0x82C462A0 => {
    //   block [0x82C462A0..0x82C462AC)
	// 82C462A0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C462A4: 386B4FA8  addi r3, r11, 0x4fa8
	ctx.r[3].s64 = ctx.r[11].s64 + 20392;
	// 82C462A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C462B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C462B0 size=92
    let mut pc: u32 = 0x82C462B0;
    'dispatch: loop {
        match pc {
            0x82C462B0 => {
    //   block [0x82C462B0..0x82C462F4)
	// 82C462B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C462B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C462B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C462BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C462C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C462C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C462C8: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C462CC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C462D0: 394BC3D4  addi r10, r11, -0x3c2c
	ctx.r[10].s64 = ctx.r[11].s64 + -15404;
	// 82C462D4: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C462D8: 4BFBFF61  bl 0x82c06238
	ctx.lr = 0x82C462DC;
	sub_82C06238(ctx, base);
	// 82C462DC: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C462E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C462E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C462E8: 419A000C  beq cr6, 0x82c462f4
	if ctx.cr[6].eq {
	pc = 0x82C462F4; continue 'dispatch;
	}
	// 82C462EC: 4BBFF4C5  bl 0x828457b0
	ctx.lr = 0x82C462F0;
	sub_828457B0(ctx, base);
	// 82C462F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C462F4; continue 'dispatch;
            }
            0x82C462F4 => {
    //   block [0x82C462F4..0x82C4630C)
	// 82C462F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C462F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C462FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46300: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46304: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46308: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C46310 size=208
    let mut pc: u32 = 0x82C46310;
    'dispatch: loop {
        match pc {
            0x82C46310 => {
    //   block [0x82C46310..0x82C463C4)
	// 82C46310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4631C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46324: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C46328: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4632C: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C46330: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C46334: 3909C3FC  addi r8, r9, -0x3c04
	ctx.r[8].s64 = ctx.r[9].s64 + -15364;
	// 82C46338: C00A0C18  lfs f0, 0xc18(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4633C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82C46340: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C46344: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82C46348: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4634C: D01F000C  stfs f0, 0xc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C46350: 997F004C  stb r11, 0x4c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[11].u8 ) };
	// 82C46354: 917F0050  stw r11, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82C46358: 917F0054  stw r11, 0x54(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C4635C: 4B5423A5  bl 0x82188700
	ctx.lr = 0x82C46360;
	sub_82188700(ctx, base);
	// 82C46360: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C46364: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C46368: C17F0004  lfs f11, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4636C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82C46370: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C46374: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 82C46378: C0070BFC  lfs f0, 0xbfc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4637C: C1A60C14  lfs f13, 0xc14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3092 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46380: C185C3F8  lfs f12, -0x3c08(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-15368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46384: EC2B683C  fnmsubs f1, f11, f0, f13
	ctx.f[1].f64 = -(((ctx.f[11].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C46388: D03F0018  stfs f1, 0x18(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C4638C: D19F0014  stfs f12, 0x14(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46390: 4BFFFE81  bl 0x82c46210
	ctx.lr = 0x82C46394;
	sub_82C46210(ctx, base);
	// 82C46394: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46398: 4BFBFC09  bl 0x82c05fa0
	ctx.lr = 0x82C4639C;
	sub_82C05FA0(ctx, base);
	// 82C4639C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C463A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C463A4: 4BFCB925  bl 0x82c11cc8
	ctx.lr = 0x82C463A8;
	sub_82C11CC8(ctx, base);
	// 82C463A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C463AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C463B0: 419A0014  beq cr6, 0x82c463c4
	if ctx.cr[6].eq {
	pc = 0x82C463C4; continue 'dispatch;
	}
	// 82C463B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C463B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C463BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C463C0: 4E800421  bctrl
	ctx.lr = 0x82C463C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C463C4 => {
    //   block [0x82C463C4..0x82C463E0)
	// 82C463C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C463C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C463CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C463D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C463D4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C463D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C463DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C463E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C463E0 size=88
    let mut pc: u32 = 0x82C463E0;
    'dispatch: loop {
        match pc {
            0x82C463E0 => {
    //   block [0x82C463E0..0x82C463F8)
	// 82C463E0: C1A30018  lfs f13, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C463E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C463E8: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C463EC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C463F0: 40980008  bge cr6, 0x82c463f8
	if !ctx.cr[6].lt {
	pc = 0x82C463F8; continue 'dispatch;
	}
	// 82C463F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x82C463F8; continue 'dispatch;
            }
            0x82C463F8 => {
    //   block [0x82C463F8..0x82C46438)
	// 82C463F8: EC00082A  fadds f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[1].f64) as f32) as f64;
	// 82C463FC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46400: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C46404: 41980044  blt cr6, 0x82c46448
	if ctx.cr[6].lt {
		sub_82C46448(ctx, base);
		return;
	}
	// 82C46408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C4640C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46410: 419A0028  beq cr6, 0x82c46438
	if ctx.cr[6].eq {
		sub_82C46438(ctx, base);
		return;
	}
	// 82C46414: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46418: C0030004  lfs f0, 4(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4641C: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C46420: C1830008  lfs f12, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46424: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C46428: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C4642C: C00B0C18  lfs f0, 0xc18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46430: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82C46434: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46438(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C46438 size=16
    let mut pc: u32 = 0x82C46438;
    'dispatch: loop {
        match pc {
            0x82C46438 => {
    //   block [0x82C46438..0x82C46448)
	// 82C46438: C0030000  lfs f0, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4643C: D0030004  stfs f0, 4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C46440: D1A30014  stfs f13, 0x14(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82C46448 size=116
    let mut pc: u32 = 0x82C46448;
    'dispatch: loop {
        match pc {
            0x82C46448 => {
    //   block [0x82C46448..0x82C464BC)
	// 82C46448: ED400032  fmuls f10, f0, f0
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C4644C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46450: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C46454: C1230020  lfs f9, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82C46458: ED090032  fmuls f8, f9, f0
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C4645C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C46460: C0E3002C  lfs f7, 0x2c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82C46464: C0C30028  lfs f6, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82C46468: C1AB0BFC  lfs f13, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C4646C: C18AC40C  lfs f12, -0x3bf4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-15348 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46470: C1690CA8  lfs f11, 0xca8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3240 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C46474: C0A30024  lfs f5, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82C46478: C083001C  lfs f4, 0x1c(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82C4647C: EC6A0372  fmuls f3, f10, f13
	ctx.f[3].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C46480: EC4300F2  fmuls f2, f3, f3
	ctx.f[2].f64 = (((ctx.f[3].f64 * ctx.f[3].f64) as f32) as f64);
	// 82C46484: EC2000F2  fmuls f1, f0, f3
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[3].f64) as f32) as f64);
	// 82C46488: EDA600F2  fmuls f13, f6, f3
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[3].f64) as f32) as f64);
	// 82C4648C: ED820332  fmuls f12, f2, f12
	ctx.f[12].f64 = (((ctx.f[2].f64 * ctx.f[12].f64) as f32) as f64);
	// 82C46490: ED6102F2  fmuls f11, f1, f11
	ctx.f[11].f64 = (((ctx.f[1].f64 * ctx.f[11].f64) as f32) as f64);
	// 82C46494: ED45683A  fmadds f10, f5, f0, f13
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C46498: ED0C41FA  fmadds f8, f12, f7, f8
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[7].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C4649C: ECE752FA  fmadds f7, f7, f11, f10
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[11].f64 + ctx.f[10].f64) as f32) as f64);
	// 82C464A0: ECC642FA  fmadds f6, f6, f11, f8
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 82C464A4: EC47482A  fadds f2, f7, f9
	ctx.f[2].f64 = ((ctx.f[7].f64 + ctx.f[9].f64) as f32) as f64;
	// 82C464A8: D043000C  stfs f2, 0xc(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C464AC: EC2530FA  fmadds f1, f5, f3, f6
	ctx.f[1].f64 = (((ctx.f[5].f64 * ctx.f[3].f64 + ctx.f[6].f64) as f32) as f64);
	// 82C464B0: EC01202A  fadds f0, f1, f4
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[4].f64) as f32) as f64;
	// 82C464B4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82C464B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C464C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C464C0 size=484
    let mut pc: u32 = 0x82C464C0;
    'dispatch: loop {
        match pc {
            0x82C464C0 => {
    //   block [0x82C464C0..0x82C466A4)
	// 82C464C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C464C4: 48062F45  bl 0x82ca9408
	ctx.lr = 0x82C464C8;
	sub_82CA93D0(ctx, base);
	// 82C464C8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82C464CC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C464D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C464D4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C464D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C464DC: 807E0050  lwz r3, 0x50(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C464E0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C464E4: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C464E8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C464EC: 4E800421  bctrl
	ctx.lr = 0x82C464F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C464F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C464F4: 4BFBF23D  bl 0x82c05730
	ctx.lr = 0x82C464F8;
	sub_82C05730(ctx, base);
	// 82C464F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C464FC: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C46500: 3889AD58  addi r4, r9, -0x52a8
	ctx.r[4].s64 = ctx.r[9].s64 + -21160;
	// 82C46504: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46508: 3BE8AD60  addi r31, r8, -0x52a0
	ctx.r[31].s64 = ctx.r[8].s64 + -21152;
	// 82C4650C: C3E10058  lfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C46510: 4BFBF2E9  bl 0x82c057f8
	ctx.lr = 0x82C46514;
	sub_82C057F8(ctx, base);
	// 82C46514: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C46518: 4BFBF489  bl 0x82c059a0
	ctx.lr = 0x82C4651C;
	sub_82C059A0(ctx, base);
	// 82C4651C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46520: 4BFBF2D9  bl 0x82c057f8
	ctx.lr = 0x82C46524;
	sub_82C057F8(ctx, base);
	// 82C46524: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C46528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4652C: 3B870C88  addi r28, r7, 0xc88
	ctx.r[28].s64 = ctx.r[7].s64 + 3208;
	// 82C46530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C46534: 4BFBF2C5  bl 0x82c057f8
	ctx.lr = 0x82C46538;
	sub_82C057F8(ctx, base);
	// 82C46538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4653C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46540: 4BFBF581  bl 0x82c05ac0
	ctx.lr = 0x82C46544;
	sub_82C05AC0(ctx, base);
	// 82C46544: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C46548: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4654C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C46550: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C46554: 4E800421  bctrl
	ctx.lr = 0x82C46558;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46558: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4655C: 4BFBF215  bl 0x82c05770
	ctx.lr = 0x82C46560;
	sub_82C05770(ctx, base);
	// 82C46560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46564: 4BFBF1CD  bl 0x82c05730
	ctx.lr = 0x82C46568;
	sub_82C05730(ctx, base);
	// 82C46568: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82C4656C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46570: 3885C470  addi r4, r5, -0x3b90
	ctx.r[4].s64 = ctx.r[5].s64 + -15248;
	// 82C46574: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46578: 3BEBC460  addi r31, r11, -0x3ba0
	ctx.r[31].s64 = ctx.r[11].s64 + -15264;
	// 82C4657C: C3FE0004  lfs f31, 4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C46580: 4BFBF279  bl 0x82c057f8
	ctx.lr = 0x82C46584;
	sub_82C057F8(ctx, base);
	// 82C46584: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C46588: 4BFBF419  bl 0x82c059a0
	ctx.lr = 0x82C4658C;
	sub_82C059A0(ctx, base);
	// 82C4658C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46590: 4BFBF269  bl 0x82c057f8
	ctx.lr = 0x82C46594;
	sub_82C057F8(ctx, base);
	// 82C46594: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C46598: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4659C: 4BFBF25D  bl 0x82c057f8
	ctx.lr = 0x82C465A0;
	sub_82C057F8(ctx, base);
	// 82C465A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C465A4: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C465A8: 4BFBF519  bl 0x82c05ac0
	ctx.lr = 0x82C465AC;
	sub_82C05AC0(ctx, base);
	// 82C465AC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C465B0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C465B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C465B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C465BC: 4E800421  bctrl
	ctx.lr = 0x82C465C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C465C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C465C4: 4BFBF1AD  bl 0x82c05770
	ctx.lr = 0x82C465C8;
	sub_82C05770(ctx, base);
	// 82C465C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C465CC: 4BFBF165  bl 0x82c05730
	ctx.lr = 0x82C465D0;
	sub_82C05730(ctx, base);
	// 82C465D0: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C465D4: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C465D8: 3889C448  addi r4, r9, -0x3bb8
	ctx.r[4].s64 = ctx.r[9].s64 + -15288;
	// 82C465DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C465E0: 3BE8C430  addi r31, r8, -0x3bd0
	ctx.r[31].s64 = ctx.r[8].s64 + -15312;
	// 82C465E4: C3FE0008  lfs f31, 8(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C465E8: 4BFBF211  bl 0x82c057f8
	ctx.lr = 0x82C465EC;
	sub_82C057F8(ctx, base);
	// 82C465EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C465F0: 4BFBF3B1  bl 0x82c059a0
	ctx.lr = 0x82C465F4;
	sub_82C059A0(ctx, base);
	// 82C465F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C465F8: 4BFBF201  bl 0x82c057f8
	ctx.lr = 0x82C465FC;
	sub_82C057F8(ctx, base);
	// 82C465FC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C46600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46604: 4BFBF1F5  bl 0x82c057f8
	ctx.lr = 0x82C46608;
	sub_82C057F8(ctx, base);
	// 82C46608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4660C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46610: 4BFBF4B1  bl 0x82c05ac0
	ctx.lr = 0x82C46614;
	sub_82C05AC0(ctx, base);
	// 82C46614: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C46618: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4661C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C46620: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C46624: 4E800421  bctrl
	ctx.lr = 0x82C46628;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46628: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4662C: 4BFBF145  bl 0x82c05770
	ctx.lr = 0x82C46630;
	sub_82C05770(ctx, base);
	// 82C46630: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46634: 4BFBF0FD  bl 0x82c05730
	ctx.lr = 0x82C46638;
	sub_82C05730(ctx, base);
	// 82C46638: 3CC08201  lis r6, -0x7dff
	ctx.r[6].s64 = -2113863680;
	// 82C4663C: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82C46640: 3886C420  addi r4, r6, -0x3be0
	ctx.r[4].s64 = ctx.r[6].s64 + -15328;
	// 82C46644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46648: 3BE5C410  addi r31, r5, -0x3bf0
	ctx.r[31].s64 = ctx.r[5].s64 + -15344;
	// 82C4664C: C3FE000C  lfs f31, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C46650: 4BFBF1A9  bl 0x82c057f8
	ctx.lr = 0x82C46654;
	sub_82C057F8(ctx, base);
	// 82C46654: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C46658: 4BFBF349  bl 0x82c059a0
	ctx.lr = 0x82C4665C;
	sub_82C059A0(ctx, base);
	// 82C4665C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46660: 4BFBF199  bl 0x82c057f8
	ctx.lr = 0x82C46664;
	sub_82C057F8(ctx, base);
	// 82C46664: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C46668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4666C: 4BFBF18D  bl 0x82c057f8
	ctx.lr = 0x82C46670;
	sub_82C057F8(ctx, base);
	// 82C46670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46674: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46678: 4BFBF449  bl 0x82c05ac0
	ctx.lr = 0x82C4667C;
	sub_82C05AC0(ctx, base);
	// 82C4667C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C46680: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C46684: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C46688: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82C4668C: 4E800421  bctrl
	ctx.lr = 0x82C46690;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46694: 4BFBF0DD  bl 0x82c05770
	ctx.lr = 0x82C46698;
	sub_82C05770(ctx, base);
	// 82C46698: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C4669C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82C466A0: 48062DB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C466A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C466A8 size=644
    let mut pc: u32 = 0x82C466A8;
    'dispatch: loop {
        match pc {
            0x82C466A8 => {
    //   block [0x82C466A8..0x82C466E0)
	// 82C466A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C466AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C466B0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C466B4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C466B8: 4806761D  bl 0x82cadcd4
	ctx.lr = 0x82C466BC;
	sub_82CADCA0(ctx, base);
	// 82C466BC: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C466C0: FFC01890  fmr f30, f3
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[3].f64;
	// 82C466C4: 3D608204  lis r11, -0x7dfc
	ctx.r[11].s64 = -2113667072;
	// 82C466C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C466CC: C00BBE14  lfs f0, -0x41ec(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C466D0: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 82C466D4: 4098000C  bge cr6, 0x82c466e0
	if !ctx.cr[6].lt {
	pc = 0x82C466E0; continue 'dispatch;
	}
	// 82C466D8: 4BFFFB39  bl 0x82c46210
	ctx.lr = 0x82C466DC;
	sub_82C46210(ctx, base);
	// 82C466DC: 48000234  b 0x82c46910
	pc = 0x82C46910; continue 'dispatch;
            }
            0x82C466E0 => {
    //   block [0x82C466E0..0x82C4670C)
	// 82C466E0: 897F0030  lbz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82C466E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C466E8: 419A0060  beq cr6, 0x82c46748
	if ctx.cr[6].eq {
	pc = 0x82C46748; continue 'dispatch;
	}
	// 82C466EC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C466F0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C466F4: C00B9040  lfs f0, -0x6fc0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C466F8: C16A0C4C  lfs f11, 0xc4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3148 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C466FC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 82C46700: 4198000C  blt cr6, 0x82c4670c
	if ctx.cr[6].lt {
	pc = 0x82C4670C; continue 'dispatch;
	}
	// 82C46704: EC200AFC  fnmsubs f1, f0, f11, f1
	ctx.f[1].f64 = -(((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[1].f64) as f32) as f64);
	// 82C46708: 48000014  b 0x82c4671c
	pc = 0x82C4671C; continue 'dispatch;
            }
            0x82C4670C => {
    //   block [0x82C4670C..0x82C4671C)
	// 82C4670C: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C46710: FF016800  fcmpu cr6, f1, f13
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[13].f64);
	// 82C46714: 40980008  bge cr6, 0x82c4671c
	if !ctx.cr[6].lt {
	pc = 0x82C4671C; continue 'dispatch;
	}
	// 82C46718: EC200AFA  fmadds f1, f0, f11, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[1].f64) as f32) as f64);
	pc = 0x82C4671C; continue 'dispatch;
            }
            0x82C4671C => {
    //   block [0x82C4671C..0x82C46734)
	// 82C4671C: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46720: ED816828  fsubs f12, f1, f13
	ctx.f[12].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 82C46724: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82C46728: 4198000C  blt cr6, 0x82c46734
	if ctx.cr[6].lt {
	pc = 0x82C46734; continue 'dispatch;
	}
	// 82C4672C: EC006AFA  fmadds f0, f0, f11, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82C46730: 48000014  b 0x82c46744
	pc = 0x82C46744; continue 'dispatch;
            }
            0x82C46734 => {
    //   block [0x82C46734..0x82C46744)
	// 82C46734: FD400050  fneg f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C46738: FF0C5000  fcmpu cr6, f12, f10
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[10].f64);
	// 82C4673C: 4098000C  bge cr6, 0x82c46748
	if !ctx.cr[6].lt {
	pc = 0x82C46748; continue 'dispatch;
	}
	// 82C46740: EC006AFC  fnmsubs f0, f0, f11, f13
	ctx.f[0].f64 = -(((ctx.f[0].f64 * ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82C46744; continue 'dispatch;
            }
            0x82C46744 => {
    //   block [0x82C46744..0x82C46748)
	// 82C46744: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x82C46748; continue 'dispatch;
            }
            0x82C46748 => {
    //   block [0x82C46748..0x82C46910)
	// 82C46748: EDBE07B2  fmuls f13, f30, f30
	ctx.f[13].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 82C4674C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46750: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C46754: C19F0000  lfs f12, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46758: C17F000C  lfs f11, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82C4675C: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C46760: D19F001C  stfs f12, 0x1c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82C46764: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C46768: D17F0020  stfs f11, 0x20(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82C4676C: C00B0BFC  lfs f0, 0xbfc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3068 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46770: C3EA0C18  lfs f31, 0xc18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3096 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C46774: D03F0004  stfs f1, 4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C46778: D05F0008  stfs f2, 8(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C4677C: D3DF0018  stfs f30, 0x18(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82C46780: EF8D0032  fmuls f28, f13, f0
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C46784: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46788: C0090CA8  lfs f0, 0xca8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(3240 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C4678C: ED5C07B2  fmuls f10, f28, f30
	ctx.f[10].f64 = (((ctx.f[28].f64 * ctx.f[30].f64) as f32) as f64);
	// 82C46790: EF6A0032  fmuls f27, f10, f0
	ctx.f[27].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C46794: 4B5F561D  bl 0x8223bdb0
	ctx.lr = 0x82C46798;
	sub_8223BDB0(ctx, base);
	// 82C46798: EC3C0732  fmuls f1, f28, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[28].f64 * ctx.f[28].f64) as f32) as f64);
	// 82C4679C: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C467A0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C467A4: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82C467A8: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C467AC: D3E10084  stfs f31, 0x84(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82C467B0: FCA0D890  fmr f5, f27
	ctx.f[5].f64 = ctx.f[27].f64;
	// 82C467B4: FD20E090  fmr f9, f28
	ctx.f[9].f64 = ctx.f[28].f64;
	// 82C467B8: C3A80C14  lfs f29, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C467BC: FCC0E090  fmr f6, f28
	ctx.f[6].f64 = ctx.f[28].f64;
	// 82C467C0: C007C40C  lfs f0, -0x3bf4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-15348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C467C4: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 82C467C8: D3A10094  stfs f29, 0x94(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82C467CC: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 82C467D0: FD40F090  fmr f10, f30
	ctx.f[10].f64 = ctx.f[30].f64;
	// 82C467D4: FD60E890  fmr f11, f29
	ctx.f[11].f64 = ctx.f[29].f64;
	// 82C467D8: FD00F890  fmr f8, f31
	ctx.f[8].f64 = ctx.f[31].f64;
	// 82C467DC: FCE0F090  fmr f7, f30
	ctx.f[7].f64 = ctx.f[30].f64;
	// 82C467E0: FC80F890  fmr f4, f31
	ctx.f[4].f64 = ctx.f[31].f64;
	// 82C467E4: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82C467E8: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82C467EC: EC210032  fmuls f1, f1, f0
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C467F0: 4B556EA1  bl 0x8219d690
	ctx.lr = 0x82C467F4;
	sub_8219D690(ctx, base);
	// 82C467F4: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82C467F8: 4B636389  bl 0x8227cb80
	ctx.lr = 0x82C467FC;
	sub_8227CB80(ctx, base);
	// 82C467FC: 38C100C0  addi r6, r1, 0xc0
	ctx.r[6].s64 = ctx.r[1].s64 + 192;
	// 82C46800: 38A100E0  addi r5, r1, 0xe0
	ctx.r[5].s64 = ctx.r[1].s64 + 224;
	// 82C46804: C01F0020  lfs f0, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46808: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82C4680C: C1BF0008  lfs f13, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46810: 386100F0  addi r3, r1, 0xf0
	ctx.r[3].s64 = ctx.r[1].s64 + 240;
	// 82C46814: C19F0004  lfs f12, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46818: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C4681C: C15F001C  lfs f10, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82C46820: 13E030C7  vcmpequd (lvx128) v31, v0, v6
	tmp.u32 = ctx.r[6].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[63] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C46824: 394100A8  addi r10, r1, 0xa8
	ctx.r[10].s64 = ctx.r[1].s64 + 168;
	// 82C46828: 13C028C7  vcmpequd (lvx128) v30, v0, v5
	tmp.u32 = ctx.r[5].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[62] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C4682C: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 82C46830: 13A020C7  vcmpequd (lvx128) v29, v0, v4
	tmp.u32 = ctx.r[4].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[61] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C46834: 390100A4  addi r8, r1, 0xa4
	ctx.r[8].s64 = ctx.r[1].s64 + 164;
	// 82C46838: 138018C7  vcmpequd (lvx128) v28, v0, v3
	tmp.u32 = ctx.r[3].u32;
	tmp.u32 &= !0xFu32;
	// load 16B at tmp.u32 into ctx.v[60] using VectorMaskL[(tmp.u32 & 0xF)]
	// 82C4683C: 38EB9170  addi r7, r11, -0x6e90
	ctx.r[7].s64 = ctx.r[11].s64 + -28304;
	pc = 0x82C46910; continue 'dispatch;
            }
            0x82C46910 => {
    //   block [0x82C46910..0x82C4692C)
	// 82C46910: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 82C46914: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 82C46918: 48067409  bl 0x82cadd20
	ctx.lr = 0x82C4691C;
	sub_82CADCEC(ctx, base);
	// 82C4691C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46924: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46928: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46930 size=112
    let mut pc: u32 = 0x82C46930;
    'dispatch: loop {
        match pc {
            0x82C46930 => {
    //   block [0x82C46930..0x82C46974)
	// 82C46930: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46934: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46938: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4693C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46940: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46944: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46948: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4694C: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 82C46950: 394BC3FC  addi r10, r11, -0x3c04
	ctx.r[10].s64 = ctx.r[11].s64 + -15364;
	// 82C46954: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C46958: 807F0054  lwz r3, 0x54(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C4695C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46960: 419A0014  beq cr6, 0x82c46974
	if ctx.cr[6].eq {
	pc = 0x82C46974; continue 'dispatch;
	}
	// 82C46964: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46968: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C4696C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46970: 4E800421  bctrl
	ctx.lr = 0x82C46974;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C46974 => {
    //   block [0x82C46974..0x82C469A0)
	// 82C46974: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C46978: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4697C: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C46980: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82C46984: 4BFBF8A5  bl 0x82c06228
	ctx.lr = 0x82C46988;
	sub_82C06228(ctx, base);
	// 82C46988: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4698C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46990: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46994: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46998: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4699C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C469A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C469A0 size=80
    let mut pc: u32 = 0x82C469A0;
    'dispatch: loop {
        match pc {
            0x82C469A0 => {
    //   block [0x82C469A0..0x82C469D8)
	// 82C469A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C469A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C469A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C469AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C469B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C469B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C469B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C469BC: 4BFFFF75  bl 0x82c46930
	ctx.lr = 0x82C469C0;
	sub_82C46930(ctx, base);
	// 82C469C0: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C469C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C469C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C469CC: 419A000C  beq cr6, 0x82c469d8
	if ctx.cr[6].eq {
	pc = 0x82C469D8; continue 'dispatch;
	}
	// 82C469D0: 4BBFEDE1  bl 0x828457b0
	ctx.lr = 0x82C469D4;
	sub_828457B0(ctx, base);
	// 82C469D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C469D8; continue 'dispatch;
            }
            0x82C469D8 => {
    //   block [0x82C469D8..0x82C469F0)
	// 82C469D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C469DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C469E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C469E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C469E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C469EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C469F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C469F0 size=144
    let mut pc: u32 = 0x82C469F0;
    'dispatch: loop {
        match pc {
            0x82C469F0 => {
    //   block [0x82C469F0..0x82C46A28)
	// 82C469F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C469F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C469F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C469FC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46A00: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46A04: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C46A08: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C46A0C: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C46A10: 388A4FA8  addi r4, r10, 0x4fa8
	ctx.r[4].s64 = ctx.r[10].s64 + 20392;
	// 82C46A14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C46A18: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C46A1C: 4E800421  bctrl
	ctx.lr = 0x82C46A20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46A20: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46A24: 409A001C  bne cr6, 0x82c46a40
	if !ctx.cr[6].eq {
	pc = 0x82C46A40; continue 'dispatch;
	}
            }
            0x82C46A28 => {
    //   block [0x82C46A28..0x82C46A40)
	// 82C46A28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C46A2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C46A30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46A34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46A38: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46A3C: 4E800020  blr
	return;
            }
            0x82C46A40 => {
    //   block [0x82C46A40..0x82C46A80)
	// 82C46A40: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C46A44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C46A48: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C46A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46A50: 4BFF1FC1  bl 0x82c38a10
	ctx.lr = 0x82C46A54;
	sub_82C38A10(ctx, base);
	// 82C46A54: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C46A58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C46A5C: 419AFFCC  beq cr6, 0x82c46a28
	if ctx.cr[6].eq {
	pc = 0x82C46A28; continue 'dispatch;
	}
	// 82C46A60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46A64: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C46A68: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C46A6C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C46A70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46A74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46A78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46A7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46A80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46A80 size=84
    let mut pc: u32 = 0x82C46A80;
    'dispatch: loop {
        match pc {
            0x82C46A80 => {
    //   block [0x82C46A80..0x82C46AC0)
	// 82C46A80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46A84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46A88: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46A8C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46A90: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C46A94: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C46A98: 388A4FA8  addi r4, r10, 0x4fa8
	ctx.r[4].s64 = ctx.r[10].s64 + 20392;
	// 82C46A9C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C46AA0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C46AA4: 4E800421  bctrl
	ctx.lr = 0x82C46AA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46AA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46AAC: 409A0014  bne cr6, 0x82c46ac0
	if !ctx.cr[6].eq {
	pc = 0x82C46AC0; continue 'dispatch;
	}
	// 82C46AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46ABC: 4E800020  blr
	return;
            }
            0x82C46AC0 => {
    //   block [0x82C46AC0..0x82C46AD4)
	// 82C46AC0: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C46AC4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46AC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46ACC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46AD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46AD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C46AD8 size=264
    let mut pc: u32 = 0x82C46AD8;
    'dispatch: loop {
        match pc {
            0x82C46AD8 => {
    //   block [0x82C46AD8..0x82C46B6C)
	// 82C46AD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46ADC: 48062931  bl 0x82ca940c
	ctx.lr = 0x82C46AE0;
	sub_82CA93D0(ctx, base);
	// 82C46AE0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46AE4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C46AE8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C46AEC: 4BFFFF05  bl 0x82c469f0
	ctx.lr = 0x82C46AF0;
	sub_82C469F0(ctx, base);
	// 82C46AF0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C46AF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C46AF8: 409A0074  bne cr6, 0x82c46b6c
	if !ctx.cr[6].eq {
	pc = 0x82C46B6C; continue 'dispatch;
	}
	// 82C46AFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46B00: 4BFBEC31  bl 0x82c05730
	ctx.lr = 0x82C46B04;
	sub_82C05730(ctx, base);
	// 82C46B04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46B08: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82C46B0C: 388BC50C  addi r4, r11, -0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + -15092;
	// 82C46B10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46B14: 3BAA934C  addi r29, r10, -0x6cb4
	ctx.r[29].s64 = ctx.r[10].s64 + -27828;
	// 82C46B18: 4BFBECE1  bl 0x82c057f8
	ctx.lr = 0x82C46B1C;
	sub_82C057F8(ctx, base);
	// 82C46B1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46B20: 4BFBED49  bl 0x82c05868
	ctx.lr = 0x82C46B24;
	sub_82C05868(ctx, base);
	// 82C46B24: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C46B28: 4BFBECD1  bl 0x82c057f8
	ctx.lr = 0x82C46B2C;
	sub_82C057F8(ctx, base);
	// 82C46B2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46B30: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46B34: 4BFBEF8D  bl 0x82c05ac0
	ctx.lr = 0x82C46B38;
	sub_82C05AC0(ctx, base);
	// 82C46B38: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C46B3C: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C46B40: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C46B44: 3889C480  addi r4, r9, -0x3b80
	ctx.r[4].s64 = ctx.r[9].s64 + -15232;
	// 82C46B48: 38A000D5  li r5, 0xd5
	ctx.r[5].s64 = 213;
	// 82C46B4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46B50: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C46B54: 4E800421  bctrl
	ctx.lr = 0x82C46B58;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46B58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C46B5C: 4BFBEC15  bl 0x82c05770
	ctx.lr = 0x82C46B60;
	sub_82C05770(ctx, base);
	// 82C46B60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C46B64: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C46B68: 480628F4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C46B6C => {
    //   block [0x82C46B6C..0x82C46B88)
	// 82C46B6C: 38600058  li r3, 0x58
	ctx.r[3].s64 = 88;
	// 82C46B70: 4B5D86E9  bl 0x8221f258
	ctx.lr = 0x82C46B74;
	sub_8221F258(ctx, base);
	// 82C46B74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46B78: 419A0010  beq cr6, 0x82c46b88
	if ctx.cr[6].eq {
	pc = 0x82C46B88; continue 'dispatch;
	}
	// 82C46B7C: 4BFFF795  bl 0x82c46310
	ctx.lr = 0x82C46B80;
	sub_82C46310(ctx, base);
	// 82C46B80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46B84: 48000008  b 0x82c46b8c
	pc = 0x82C46B8C; continue 'dispatch;
            }
            0x82C46B88 => {
    //   block [0x82C46B88..0x82C46B8C)
	// 82C46B88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x82C46B8C; continue 'dispatch;
            }
            0x82C46B8C => {
    //   block [0x82C46B8C..0x82C46BD4)
	// 82C46B8C: C01D0004  lfs f0, 4(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46B90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46B94: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82C46B98: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46B9C: D1BF0008  stfs f13, 8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82C46BA0: C19D000C  lfs f12, 0xc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46BA4: D19F000C  stfs f12, 0xc(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82C46BA8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46BAC: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C46BB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46BB4: 4E800421  bctrl
	ctx.lr = 0x82C46BB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46BB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46BBC: 419A0018  beq cr6, 0x82c46bd4
	if ctx.cr[6].eq {
	pc = 0x82C46BD4; continue 'dispatch;
	}
	// 82C46BC0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46BC4: 389F0050  addi r4, r31, 0x50
	ctx.r[4].s64 = ctx.r[31].s64 + 80;
	// 82C46BC8: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C46BCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46BD0: 4E800421  bctrl
	ctx.lr = 0x82C46BD4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C46BD4 => {
    //   block [0x82C46BD4..0x82C46BE0)
	// 82C46BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46BD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C46BDC: 48062880  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46BE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C46BE0 size=388
    let mut pc: u32 = 0x82C46BE0;
    'dispatch: loop {
        match pc {
            0x82C46BE0 => {
    //   block [0x82C46BE0..0x82C46CA0)
	// 82C46BE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46BE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46BE8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C46BEC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46BF0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82C46BF4: 480670E5  bl 0x82cadcd8
	ctx.lr = 0x82C46BF8;
	sub_82CADCA0(ctx, base);
	// 82C46BF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46BFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46C00: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C46C04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46C08: 419A0134  beq cr6, 0x82c46d3c
	if ctx.cr[6].eq {
	pc = 0x82C46D3C; continue 'dispatch;
	}
	// 82C46C0C: 4B541AF5  bl 0x82188700
	ctx.lr = 0x82C46C10;
	sub_82188700(ctx, base);
	// 82C46C10: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C46C14: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 82C46C18: C1BF0014  lfs f13, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46C1C: 7D2B1850  subf r9, r11, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[11].s64;
	// 82C46C20: C19F0008  lfs f12, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46C24: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 82C46C28: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 82C46C2C: 79270020  clrldi r7, r9, 0x20
	ctx.r[7].u64 = ctx.r[9].u64 & 0x00000000FFFFFFFFu64;
	// 82C46C30: 3CC08200  lis r6, -0x7e00
	ctx.r[6].s64 = -2113929216;
	// 82C46C34: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 82C46C38: C9610050  lfd f11, 0x50(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C46C3C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 82C46C40: C00A9404  lfs f0, -0x6bfc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46C44: FFE05018  frsp f31, f10
	ctx.f[31].f64 = (ctx.f[10].f64 as f32) as f64;
	// 82C46C48: C3A80C14  lfs f29, 0xc14(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3092 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82C46C4C: ED2C0032  fmuls f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82C46C50: C3C60C18  lfs f30, 0xc18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(3096 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82C46C54: ED1F682A  fadds f8, f31, f13
	ctx.f[8].f64 = ((ctx.f[31].f64 + ctx.f[13].f64) as f32) as f64;
	// 82C46C58: D11F0014  stfs f8, 0x14(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46C5C: FF084800  fcmpu cr6, f8, f9
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[9].f64);
	// 82C46C60: 40990040  ble cr6, 0x82c46ca0
	if !ctx.cr[6].gt {
	pc = 0x82C46CA0; continue 'dispatch;
	}
	// 82C46C64: D3DF0014  stfs f30, 0x14(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82C46C68: C01F0004  lfs f0, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46C6C: EF9D0028  fsubs f28, f29, f0
	ctx.f[28].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C46C70: 48063561  bl 0x82caa1d0
	ctx.lr = 0x82C46C74;
	sub_82CAA1D0(ctx, base);
	// 82C46C74: 7C6B07B4  extsw r11, r3
	ctx.r[11].s64 = ctx.r[3].s32 as i64;
	// 82C46C78: C1BF0004  lfs f13, 4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46C7C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 82C46C80: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82C46C84: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82C46C88: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82C46C8C: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82C46C90: C00A0C20  lfs f0, 0xc20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(3104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46C94: ED2A0372  fmuls f9, f10, f13
	ctx.f[9].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82C46C98: ED09E03A  fmadds f8, f9, f0, f28
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 82C46C9C: D11F0018  stfs f8, 0x18(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	pc = 0x82C46CA0; continue 'dispatch;
            }
            0x82C46CA0 => {
    //   block [0x82C46CA0..0x82C46CF4)
	// 82C46CA0: 3BDF001C  addi r30, r31, 0x1c
	ctx.r[30].s64 = ctx.r[31].s64 + 28;
	// 82C46CA4: C07F000C  lfs f3, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82C46CA8: C03F0018  lfs f1, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C46CAC: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 82C46CB0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46CB4: 4BFFF9F5  bl 0x82c466a8
	ctx.lr = 0x82C46CB8;
	sub_82C466A8(ctx, base);
	// 82C46CB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46CBC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C46CC0: 4BFFF721  bl 0x82c463e0
	ctx.lr = 0x82C46CC4;
	sub_82C463E0(ctx, base);
	// 82C46CC4: 897F004C  lbz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 82C46CC8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82C46CCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46CD0: 419A003C  beq cr6, 0x82c46d0c
	if ctx.cr[6].eq {
	pc = 0x82C46D0C; continue 'dispatch;
	}
	// 82C46CD4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82C46CD8: C1AB9040  lfs f13, -0x6fc0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28608 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82C46CDC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82C46CE0: 41980014  blt cr6, 0x82c46cf4
	if ctx.cr[6].lt {
	pc = 0x82C46CF4; continue 'dispatch;
	}
	// 82C46CE4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46CE8: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46CEC: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82C46CF0: 4800001C  b 0x82c46d0c
	pc = 0x82C46D0C; continue 'dispatch;
            }
            0x82C46CF4 => {
    //   block [0x82C46CF4..0x82C46D0C)
	// 82C46CF4: FD806850  fneg f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82C46CF8: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82C46CFC: 40980010  bge cr6, 0x82c46d0c
	if !ctx.cr[6].lt {
	pc = 0x82C46D0C; continue 'dispatch;
	}
	// 82C46D00: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C46D04: C18B0C4C  lfs f12, 0xc4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82C46D08: EC0D033A  fmadds f0, f13, f12, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	pc = 0x82C46D0C; continue 'dispatch;
            }
            0x82C46D0C => {
    //   block [0x82C46D0C..0x82C46D24)
	// 82C46D0C: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 82C46D10: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82C46D14: 40990048  ble cr6, 0x82c46d5c
	if !ctx.cr[6].gt {
	pc = 0x82C46D5C; continue 'dispatch;
	}
	// 82C46D18: FF01E800  fcmpu cr6, f1, f29
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[29].f64);
	// 82C46D1C: 41980008  blt cr6, 0x82c46d24
	if ctx.cr[6].lt {
	pc = 0x82C46D24; continue 'dispatch;
	}
	// 82C46D20: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	pc = 0x82C46D24; continue 'dispatch;
            }
            0x82C46D24 => {
    //   block [0x82C46D24..0x82C46D3C)
	// 82C46D24: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C46D28: 38A00064  li r5, 0x64
	ctx.r[5].s64 = 100;
	// 82C46D2C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46D30: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C46D34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46D38: 4E800421  bctrl
	ctx.lr = 0x82C46D3C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C46D3C => {
    //   block [0x82C46D3C..0x82C46D5C)
	// 82C46D3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C46D40: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82C46D44: 48066FE1  bl 0x82cadd24
	ctx.lr = 0x82C46D48;
	sub_82CADCEC(ctx, base);
	// 82C46D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46D50: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46D54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46D58: 4E800020  blr
	return;
            }
            0x82C46D5C => {
    //   block [0x82C46D5C..0x82C46D64)
	// 82C46D5C: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82C46D60: 4BFFFFC4  b 0x82c46d24
	pc = 0x82C46D24; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46D68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46D68 size=36
    let mut pc: u32 = 0x82C46D68;
    'dispatch: loop {
        match pc {
            0x82C46D68 => {
    //   block [0x82C46D68..0x82C46D8C)
	// 82C46D68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46D6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46D70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46D74: 4BFFFC7D  bl 0x82c469f0
	ctx.lr = 0x82C46D78;
	sub_82C469F0(ctx, base);
	// 82C46D78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C46D7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46D80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46D84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46D88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46D90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46D90 size=84
    let mut pc: u32 = 0x82C46D90;
    'dispatch: loop {
        match pc {
            0x82C46D90 => {
    //   block [0x82C46D90..0x82C46DE4)
	// 82C46D90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46D94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46D98: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46D9C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46DA0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46DA4: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C46DA8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C46DAC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C46DB0: 388A4FA8  addi r4, r10, 0x4fa8
	ctx.r[4].s64 = ctx.r[10].s64 + 20392;
	// 82C46DB4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C46DB8: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C46DBC: 4E800421  bctrl
	ctx.lr = 0x82C46DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46DC0: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C46DC4: 57E7103A  slwi r7, r31, 2
	ctx.r[7].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C46DC8: 7CC8382E  lwzx r6, r8, r7
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82C46DCC: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46DD0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46DD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46DD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46DDC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46DE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46DE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46DE8 size=192
    let mut pc: u32 = 0x82C46DE8;
    'dispatch: loop {
        match pc {
            0x82C46DE8 => {
    //   block [0x82C46DE8..0x82C46E88)
	// 82C46DE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46DEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46DF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C46DF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46DF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46E00: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C46E04: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46E08: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C46E0C: 388BAF9C  addi r4, r11, -0x5064
	ctx.r[4].s64 = ctx.r[11].s64 + -20580;
	// 82C46E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46E14: 4BFC0395  bl 0x82c071a8
	ctx.lr = 0x82C46E18;
	sub_82C071A8(ctx, base);
	// 82C46E18: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46E1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C46E20: 419A0068  beq cr6, 0x82c46e88
	if ctx.cr[6].eq {
	pc = 0x82C46E88; continue 'dispatch;
	}
	// 82C46E24: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46E28: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C46E2C: 388BC550  addi r4, r11, -0x3ab0
	ctx.r[4].s64 = ctx.r[11].s64 + -15024;
	// 82C46E30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46E34: 4BFD477D  bl 0x82c1b5b0
	ctx.lr = 0x82C46E38;
	sub_82C1B5B0(ctx, base);
	// 82C46E38: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46E3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C46E40: 419A0048  beq cr6, 0x82c46e88
	if ctx.cr[6].eq {
	pc = 0x82C46E88; continue 'dispatch;
	}
	// 82C46E44: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46E48: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 82C46E4C: 388BC53C  addi r4, r11, -0x3ac4
	ctx.r[4].s64 = ctx.r[11].s64 + -15044;
	// 82C46E50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46E54: 4BFD475D  bl 0x82c1b5b0
	ctx.lr = 0x82C46E58;
	sub_82C1B5B0(ctx, base);
	// 82C46E58: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46E5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C46E60: 419A0028  beq cr6, 0x82c46e88
	if ctx.cr[6].eq {
	pc = 0x82C46E88; continue 'dispatch;
	}
	// 82C46E64: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46E68: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 82C46E6C: 388BC530  addi r4, r11, -0x3ad0
	ctx.r[4].s64 = ctx.r[11].s64 + -15056;
	// 82C46E70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46E74: 4BFD473D  bl 0x82c1b5b0
	ctx.lr = 0x82C46E78;
	sub_82C1B5B0(ctx, base);
	// 82C46E78: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46E7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C46E80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C46E84: 409A0008  bne cr6, 0x82c46e8c
	if !ctx.cr[6].eq {
	pc = 0x82C46E8C; continue 'dispatch;
	}
	pc = 0x82C46E88; continue 'dispatch;
            }
            0x82C46E88 => {
    //   block [0x82C46E88..0x82C46E8C)
	// 82C46E88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C46E8C; continue 'dispatch;
            }
            0x82C46E8C => {
    //   block [0x82C46E8C..0x82C46EA8)
	// 82C46E8C: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C46E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C46E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46E9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46EA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46EA8 size=148
    let mut pc: u32 = 0x82C46EA8;
    'dispatch: loop {
        match pc {
            0x82C46EA8 => {
    //   block [0x82C46EA8..0x82C46F1C)
	// 82C46EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46EB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C46EB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C46EB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46EBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46EC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C46EC4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46EC8: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C46ECC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46ED0: 4E800421  bctrl
	ctx.lr = 0x82C46ED4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46ED4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46ED8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C46EDC: 419A0040  beq cr6, 0x82c46f1c
	if ctx.cr[6].eq {
	pc = 0x82C46F1C; continue 'dispatch;
	}
	// 82C46EE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C46EE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C46EE8: 4BFFFF01  bl 0x82c46de8
	ctx.lr = 0x82C46EEC;
	sub_82C46DE8(ctx, base);
	// 82C46EEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46EF4: 419A0028  beq cr6, 0x82c46f1c
	if ctx.cr[6].eq {
	pc = 0x82C46F1C; continue 'dispatch;
	}
	// 82C46EF8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46EFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46F00: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C46F04: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46F08: 4E800421  bctrl
	ctx.lr = 0x82C46F0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46F0C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C46F10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C46F14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C46F18: 409A0008  bne cr6, 0x82c46f20
	if !ctx.cr[6].eq {
	pc = 0x82C46F20; continue 'dispatch;
	}
            }
            0x82C46F1C => {
    //   block [0x82C46F1C..0x82C46F20)
	// 82C46F1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C46F20; continue 'dispatch;
            }
            0x82C46F20 => {
    //   block [0x82C46F20..0x82C46F3C)
	// 82C46F20: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C46F24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C46F28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46F2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46F30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C46F34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C46F38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46F40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46F40 size=76
    let mut pc: u32 = 0x82C46F40;
    'dispatch: loop {
        match pc {
            0x82C46F40 => {
    //   block [0x82C46F40..0x82C46F78)
	// 82C46F40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46F44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C46F48: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46F4C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C46F50: 4B5D8309  bl 0x8221f258
	ctx.lr = 0x82C46F54;
	sub_8221F258(ctx, base);
	// 82C46F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C46F58: 419A0020  beq cr6, 0x82c46f78
	if ctx.cr[6].eq {
	pc = 0x82C46F78; continue 'dispatch;
	}
	// 82C46F5C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C46F60: 394BC3D4  addi r10, r11, -0x3c2c
	ctx.r[10].s64 = ctx.r[11].s64 + -15404;
	// 82C46F64: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C46F68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46F74: 4E800020  blr
	return;
            }
            0x82C46F78 => {
    //   block [0x82C46F78..0x82C46F8C)
	// 82C46F78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C46F7C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C46F80: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C46F84: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C46F88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C46F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C46F90 size=788
    let mut pc: u32 = 0x82C46F90;
    'dispatch: loop {
        match pc {
            0x82C46F90 => {
    //   block [0x82C46F90..0x82C46FFC)
	// 82C46F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C46F94: 4806246D  bl 0x82ca9400
	ctx.lr = 0x82C46F98;
	sub_82CA93D0(ctx, base);
	// 82C46F98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C46F9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C46FA0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C46FA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46FA8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46FAC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46FB0: 4E800421  bctrl
	ctx.lr = 0x82C46FB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46FB4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C46FB8: 41980110  blt cr6, 0x82c470c8
	if ctx.cr[6].lt {
	pc = 0x82C470C8; continue 'dispatch;
	}
	// 82C46FBC: 409A026C  bne cr6, 0x82c47228
	if !ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C46FC0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C46FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C46FC8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C46FCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C46FD0: 4E800421  bctrl
	ctx.lr = 0x82C46FD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C46FD4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C46FD8: 41980064  blt cr6, 0x82c4703c
	if ctx.cr[6].lt {
	pc = 0x82C4703C; continue 'dispatch;
	}
	// 82C46FDC: 409A024C  bne cr6, 0x82c47228
	if !ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C46FE0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C46FE4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C46FE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C46FEC: 409902AC  ble cr6, 0x82c47298
	if !ctx.cr[6].gt {
	pc = 0x82C47298; continue 'dispatch;
	}
	// 82C46FF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C46FF4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C46FF8: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C46FFC => {
    //   block [0x82C46FFC..0x82C4703C)
	// 82C46FFC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47000: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47008: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C4700C: 4BFFFE9D  bl 0x82c46ea8
	ctx.lr = 0x82C47010;
	sub_82C46EA8(ctx, base);
	// 82C47010: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47014: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47018: 419A0210  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C4701C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47020: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C47024: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C47028: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C4702C: 4198FFD0  blt cr6, 0x82c46ffc
	if ctx.cr[6].lt {
	pc = 0x82C46FFC; continue 'dispatch;
	}
	// 82C47030: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C47034: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47038: 48062418  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C4703C => {
    //   block [0x82C4703C..0x82C4707C)
	// 82C4703C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47040: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47044: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C47048: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4704C: 4E800421  bctrl
	ctx.lr = 0x82C47050;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C47054: 3B4B5D98  addi r26, r11, 0x5d98
	ctx.r[26].s64 = ctx.r[11].s64 + 23960;
	// 82C47058: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4705C: 4BFC1B5D  bl 0x82c08bb8
	ctx.lr = 0x82C47060;
	sub_82C08BB8(ctx, base);
	// 82C47060: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C47064: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47068: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4706C: 4BFDF235  bl 0x82c262a0
	ctx.lr = 0x82C47070;
	sub_82C262A0(ctx, base);
	// 82C47070: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C47074: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C47078: 419A0220  beq cr6, 0x82c47298
	if ctx.cr[6].eq {
	pc = 0x82C47298; continue 'dispatch;
	}
            }
            0x82C4707C => {
    //   block [0x82C4707C..0x82C470C8)
	// 82C4707C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C47080: 4B5D81D9  bl 0x8221f258
	ctx.lr = 0x82C47084;
	sub_8221F258(ctx, base);
	// 82C47084: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C47088: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C4708C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C47090: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47094: 4BFFFE15  bl 0x82c46ea8
	ctx.lr = 0x82C47098;
	sub_82C46EA8(ctx, base);
	// 82C47098: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4709C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C470A0: 419A0188  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C470A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C470A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C470AC: 4BFDF63D  bl 0x82c266e8
	ctx.lr = 0x82C470B0;
	sub_82C266E8(ctx, base);
	// 82C470B0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C470B4: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C470B8: 4198FFC4  blt cr6, 0x82c4707c
	if ctx.cr[6].lt {
	pc = 0x82C4707C; continue 'dispatch;
	}
	// 82C470BC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C470C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C470C4: 4806238C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C470C8 => {
    //   block [0x82C470C8..0x82C47144)
	// 82C470C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C470CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C470D0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C470D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C470D8: 4E800421  bctrl
	ctx.lr = 0x82C470DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C470DC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C470E0: 419800A4  blt cr6, 0x82c47184
	if ctx.cr[6].lt {
	pc = 0x82C47184; continue 'dispatch;
	}
	// 82C470E4: 409A0144  bne cr6, 0x82c47228
	if !ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C470E8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C470EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C470F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C470F4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C470F8: 4E800421  bctrl
	ctx.lr = 0x82C470FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C470FC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47100: 811B0008  lwz r8, 8(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47104: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C47108: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4710C: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C47110: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C47114: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C47118: 4E800421  bctrl
	ctx.lr = 0x82C4711C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4711C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47120: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C47124: 419A0104  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C47128: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4712C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C47130: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47134: 419A0164  beq cr6, 0x82c47298
	if ctx.cr[6].eq {
	pc = 0x82C47298; continue 'dispatch;
	}
	// 82C47138: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C4713C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C47140: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C47144 => {
    //   block [0x82C47144..0x82C47184)
	// 82C47144: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4714C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47150: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C47154: 4BFFFD55  bl 0x82c46ea8
	ctx.lr = 0x82C47158;
	sub_82C46EA8(ctx, base);
	// 82C47158: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4715C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47160: 419A00C8  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C47164: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47168: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C4716C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C47170: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C47174: 4198FFD0  blt cr6, 0x82c47144
	if ctx.cr[6].lt {
	pc = 0x82C47144; continue 'dispatch;
	}
	// 82C47178: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4717C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47180: 480622D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47184 => {
    //   block [0x82C47184..0x82C47228)
	// 82C47184: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47188: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4718C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47190: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47194: 4E800421  bctrl
	ctx.lr = 0x82C47198;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47198: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4719C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C471A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C471A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C471A8: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C471AC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C471B0: 4E800421  bctrl
	ctx.lr = 0x82C471B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C471B4: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C471B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C471BC: 419A006C  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C471C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C471C4: 4BFC0B5D  bl 0x82c07d20
	ctx.lr = 0x82C471C8;
	sub_82C07D20(ctx, base);
	// 82C471C8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C471CC: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C471D0: 40990064  ble cr6, 0x82c47234
	if !ctx.cr[6].gt {
	pc = 0x82C47234; continue 'dispatch;
	}
	// 82C471D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C471D8: 4BFC0B49  bl 0x82c07d20
	ctx.lr = 0x82C471DC;
	sub_82C07D20(ctx, base);
	// 82C471DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C471E0: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C471E4: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C471E8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C471EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C471F0: 3B8AB0E8  addi r28, r10, -0x4f18
	ctx.r[28].s64 = ctx.r[10].s64 + -20248;
	// 82C471F4: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C471F8: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C471FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47200: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C47204: 4E800421  bctrl
	ctx.lr = 0x82C47208;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47208: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C4720C: 4BFBE5ED  bl 0x82c057f8
	ctx.lr = 0x82C47210;
	sub_82C057F8(ctx, base);
	// 82C47210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C47214: 4BFBE655  bl 0x82c05868
	ctx.lr = 0x82C47218;
	sub_82C05868(ctx, base);
	// 82C47218: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C4721C: 4BFBE5DD  bl 0x82c057f8
	ctx.lr = 0x82C47220;
	sub_82C057F8(ctx, base);
	// 82C47220: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C47224: 4BFBE645  bl 0x82c05868
	ctx.lr = 0x82C47228;
	sub_82C05868(ctx, base);
            }
            0x82C47228 => {
    //   block [0x82C47228..0x82C47234)
	// 82C47228: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C4722C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47230: 48062220  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47234 => {
    //   block [0x82C47234..0x82C47254)
	// 82C47234: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47238: 4BFDF069  bl 0x82c262a0
	ctx.lr = 0x82C4723C;
	sub_82C262A0(ctx, base);
	// 82C4723C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47240: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47244: 419A0054  beq cr6, 0x82c47298
	if ctx.cr[6].eq {
	pc = 0x82C47298; continue 'dispatch;
	}
	// 82C47248: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C4724C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C47250: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
	pc = 0x82C47254; continue 'dispatch;
            }
            0x82C47254 => {
    //   block [0x82C47254..0x82C47298)
	// 82C47254: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C47258: 4B5D8001  bl 0x8221f258
	ctx.lr = 0x82C4725C;
	sub_8221F258(ctx, base);
	// 82C4725C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C47260: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47264: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C47268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4726C: 4BFFFC3D  bl 0x82c46ea8
	ctx.lr = 0x82C47270;
	sub_82C46EA8(ctx, base);
	// 82C47270: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47274: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47278: 419AFFB0  beq cr6, 0x82c47228
	if ctx.cr[6].eq {
	pc = 0x82C47228; continue 'dispatch;
	}
	// 82C4727C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C47280: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47284: 4BFDF465  bl 0x82c266e8
	ctx.lr = 0x82C47288;
	sub_82C266E8(ctx, base);
	// 82C47288: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C4728C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C47290: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C47294: 4198FFC0  blt cr6, 0x82c47254
	if ctx.cr[6].lt {
	pc = 0x82C47254; continue 'dispatch;
	}
	pc = 0x82C47298; continue 'dispatch;
            }
            0x82C47298 => {
    //   block [0x82C47298..0x82C472A4)
	// 82C47298: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4729C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C472A0: 480621B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C472A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C472A8 size=92
    let mut pc: u32 = 0x82C472A8;
    'dispatch: loop {
        match pc {
            0x82C472A8 => {
    //   block [0x82C472A8..0x82C472F0)
	// 82C472A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C472AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C472B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C472B4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C472B8: 4B5D7FA1  bl 0x8221f258
	ctx.lr = 0x82C472BC;
	sub_8221F258(ctx, base);
	// 82C472BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C472C0: 419A0030  beq cr6, 0x82c472f0
	if ctx.cr[6].eq {
	pc = 0x82C472F0; continue 'dispatch;
	}
	// 82C472C4: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C472C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C472CC: 392AC524  addi r9, r10, -0x3adc
	ctx.r[9].s64 = ctx.r[10].s64 + -15068;
	// 82C472D0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C472D4: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C472D8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C472DC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C472E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C472E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C472E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C472EC: 4E800020  blr
	return;
            }
            0x82C472F0 => {
    //   block [0x82C472F0..0x82C47304)
	// 82C472F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C472F4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C472F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C472FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47300: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47308 size=100
    let mut pc: u32 = 0x82C47308;
    'dispatch: loop {
        match pc {
            0x82C47308 => {
    //   block [0x82C47308..0x82C4736C)
	// 82C47308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4730C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47310: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47314: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47318: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C4731C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47320: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82C47324: 392BB820  addi r9, r11, -0x47e0
	ctx.r[9].s64 = ctx.r[11].s64 + -18400;
	// 82C47328: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82C4732C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C47330: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C47334: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82C47338: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82C4733C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82C47340: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82C47344: 4BFECF95  bl 0x82c342d8
	ctx.lr = 0x82C47348;
	sub_82C342D8(ctx, base);
	// 82C47348: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C4734C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47350: 38E8B000  addi r7, r8, -0x5000
	ctx.r[7].s64 = ctx.r[8].s64 + -20480;
	// 82C47354: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82C47358: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C4735C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47360: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47364: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47370 size=132
    let mut pc: u32 = 0x82C47370;
    'dispatch: loop {
        match pc {
            0x82C47370 => {
    //   block [0x82C47370..0x82C473E4)
	// 82C47370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47374: 48062099  bl 0x82ca940c
	ctx.lr = 0x82C47378;
	sub_82CA93D0(ctx, base);
	// 82C47378: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4737C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C47380: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47384: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C47388: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C4738C: 392BC524  addi r9, r11, -0x3adc
	ctx.r[9].s64 = ctx.r[11].s64 + -15068;
	// 82C47390: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C47394: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C47398: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C4739C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C473A0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C473A4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C473A8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C473AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C473B0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C473B4: 4BFECF25  bl 0x82c342d8
	ctx.lr = 0x82C473B8;
	sub_82C342D8(ctx, base);
	// 82C473B8: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C473BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C473C0: 38C7C380  addi r6, r7, -0x3c80
	ctx.r[6].s64 = ctx.r[7].s64 + -15488;
	// 82C473C4: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C473C8: 4BFFB551  bl 0x82c42918
	ctx.lr = 0x82C473CC;
	sub_82C42918(ctx, base);
	// 82C473CC: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C473D0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C473D4: 419A0010  beq cr6, 0x82c473e4
	if ctx.cr[6].eq {
	pc = 0x82C473E4; continue 'dispatch;
	}
	// 82C473D8: 4BBFE3D9  bl 0x828457b0
	ctx.lr = 0x82C473DC;
	sub_828457B0(ctx, base);
	// 82C473DC: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C473E0: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C473E4; continue 'dispatch;
            }
            0x82C473E4 => {
    //   block [0x82C473E4..0x82C473F4)
	// 82C473E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C473E8: 4BFBED19  bl 0x82c06100
	ctx.lr = 0x82C473EC;
	sub_82C06100(ctx, base);
	// 82C473EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C473F0: 4806206C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C473F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C473F8 size=80
    let mut pc: u32 = 0x82C473F8;
    'dispatch: loop {
        match pc {
            0x82C473F8 => {
    //   block [0x82C473F8..0x82C47430)
	// 82C473F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C473FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47400: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47404: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47408: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4740C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47410: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47414: 4BFFFF5D  bl 0x82c47370
	ctx.lr = 0x82C47418;
	sub_82C47370(ctx, base);
	// 82C47418: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C4741C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47424: 419A000C  beq cr6, 0x82c47430
	if ctx.cr[6].eq {
	pc = 0x82C47430; continue 'dispatch;
	}
	// 82C47428: 4BBFE389  bl 0x828457b0
	ctx.lr = 0x82C4742C;
	sub_828457B0(ctx, base);
	// 82C4742C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C47430; continue 'dispatch;
            }
            0x82C47430 => {
    //   block [0x82C47430..0x82C47448)
	// 82C47430: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47434: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47438: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4743C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C47440: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47444: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47448(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47448 size=396
    let mut pc: u32 = 0x82C47448;
    'dispatch: loop {
        match pc {
            0x82C47448 => {
    //   block [0x82C47448..0x82C474B0)
	// 82C47448: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4744C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47450: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47454: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47458: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4745C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47460: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47464: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47468: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4746C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47470: 4E800421  bctrl
	ctx.lr = 0x82C47474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47474: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C47478: 41980038  blt cr6, 0x82c474b0
	if ctx.cr[6].lt {
	pc = 0x82C474B0; continue 'dispatch;
	}
	// 82C4747C: 409A0118  bne cr6, 0x82c47594
	if !ctx.cr[6].eq {
	pc = 0x82C47594; continue 'dispatch;
	}
	// 82C47480: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47488: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C4748C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47490: 4E800421  bctrl
	ctx.lr = 0x82C47494;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47494: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C47498: 41980070  blt cr6, 0x82c47508
	if ctx.cr[6].lt {
	pc = 0x82C47508; continue 'dispatch;
	}
	// 82C4749C: 409A00F8  bne cr6, 0x82c47594
	if !ctx.cr[6].eq {
	pc = 0x82C47594; continue 'dispatch;
	}
	// 82C474A0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C474A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C474A8: 419A0110  beq cr6, 0x82c475b8
	if ctx.cr[6].eq {
	pc = 0x82C475B8; continue 'dispatch;
	}
	// 82C474AC: 48000024  b 0x82c474d0
	pc = 0x82C474D0; continue 'dispatch;
            }
            0x82C474B0 => {
    //   block [0x82C474B0..0x82C474D0)
	// 82C474B0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C474B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C474B8: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C474BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C474C0: 4E800421  bctrl
	ctx.lr = 0x82C474C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C474C4: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C474C8: 41980040  blt cr6, 0x82c47508
	if ctx.cr[6].lt {
	pc = 0x82C47508; continue 'dispatch;
	}
	// 82C474CC: 409A00C8  bne cr6, 0x82c47594
	if !ctx.cr[6].eq {
	pc = 0x82C47594; continue 'dispatch;
	}
            }
            0x82C474D0 => {
    //   block [0x82C474D0..0x82C47508)
	// 82C474D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C474D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C474D8: 4BFDA381  bl 0x82c21858
	ctx.lr = 0x82C474DC;
	sub_82C21858(ctx, base);
	// 82C474DC: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C474E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C474E4: 4BFFFAAD  bl 0x82c46f90
	ctx.lr = 0x82C474E8;
	sub_82C46F90(ctx, base);
	// 82C474E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C474EC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C474F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C474F4: 4BFF1135  bl 0x82c38628
	ctx.lr = 0x82C474F8;
	sub_82C38628(ctx, base);
	// 82C474F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C474FC: 4BFE34F5  bl 0x82c2a9f0
	ctx.lr = 0x82C47500;
	sub_82C2A9F0(ctx, base);
	// 82C47500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47504: 480000B8  b 0x82c475bc
	pc = 0x82C475BC; continue 'dispatch;
            }
            0x82C47508 => {
    //   block [0x82C47508..0x82C4758C)
	// 82C47508: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C4750C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C47510: 4BFFFDF9  bl 0x82c47308
	ctx.lr = 0x82C47514;
	sub_82C47308(ctx, base);
	// 82C47514: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C47518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4751C: 4BFFFA75  bl 0x82c46f90
	ctx.lr = 0x82C47520;
	sub_82C46F90(ctx, base);
	// 82C47520: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47524: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47528: 419A0064  beq cr6, 0x82c4758c
	if ctx.cr[6].eq {
	pc = 0x82C4758C; continue 'dispatch;
	}
	// 82C4752C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C47530: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C47534: 392AC380  addi r9, r10, -0x3c80
	ctx.r[9].s64 = ctx.r[10].s64 + -15488;
	// 82C47538: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C4753C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C47540: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C47544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47548: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C4754C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C47550: 4BFFE559  bl 0x82c45aa8
	ctx.lr = 0x82C47554;
	sub_82C45AA8(ctx, base);
	// 82C47554: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C47558: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C4755C: 419A0040  beq cr6, 0x82c4759c
	if ctx.cr[6].eq {
	pc = 0x82C4759C; continue 'dispatch;
	}
	// 82C47560: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47564: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C47568: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4756C: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C47570: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C47574: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C47578: 4E800421  bctrl
	ctx.lr = 0x82C4757C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4757C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C47580: 4BFBE279  bl 0x82c057f8
	ctx.lr = 0x82C47584;
	sub_82C057F8(ctx, base);
	// 82C47584: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47588: 4BFFB391  bl 0x82c42918
	ctx.lr = 0x82C4758C;
	sub_82C42918(ctx, base);
            }
            0x82C4758C => {
    //   block [0x82C4758C..0x82C47594)
	// 82C4758C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C47590: 4BFD4A31  bl 0x82c1bfc0
	ctx.lr = 0x82C47594;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C47594; continue 'dispatch;
            }
            0x82C47594 => {
    //   block [0x82C47594..0x82C4759C)
	// 82C47594: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47598: 48000024  b 0x82c475bc
	pc = 0x82C475BC; continue 'dispatch;
            }
            0x82C4759C => {
    //   block [0x82C4759C..0x82C475B8)
	// 82C4759C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C475A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C475A4: 4BFF1085  bl 0x82c38628
	ctx.lr = 0x82C475A8;
	sub_82C38628(ctx, base);
	// 82C475A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C475AC: 4BFFB36D  bl 0x82c42918
	ctx.lr = 0x82C475B0;
	sub_82C42918(ctx, base);
	// 82C475B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C475B4: 4BFD4A0D  bl 0x82c1bfc0
	ctx.lr = 0x82C475B8;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C475B8; continue 'dispatch;
            }
            0x82C475B8 => {
    //   block [0x82C475B8..0x82C475BC)
	// 82C475B8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C475BC; continue 'dispatch;
            }
            0x82C475BC => {
    //   block [0x82C475BC..0x82C475D4)
	// 82C475BC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C475C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C475C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C475C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C475CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C475D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C475D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C475D8 size=16
    let mut pc: u32 = 0x82C475D8;
    'dispatch: loop {
        match pc {
            0x82C475D8 => {
    //   block [0x82C475D8..0x82C475E8)
	// 82C475D8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C475DC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C475E0: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C475E4: 4BFFFE64  b 0x82c47448
	sub_82C47448(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C475E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C475E8 size=12
    let mut pc: u32 = 0x82C475E8;
    'dispatch: loop {
        match pc {
            0x82C475E8 => {
    //   block [0x82C475E8..0x82C475F4)
	// 82C475E8: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C475EC: 386B4FB4  addi r3, r11, 0x4fb4
	ctx.r[3].s64 = ctx.r[11].s64 + 20404;
	// 82C475F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C475F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C475F8 size=136
    let mut pc: u32 = 0x82C475F8;
    'dispatch: loop {
        match pc {
            0x82C475F8 => {
    //   block [0x82C475F8..0x82C47680)
	// 82C475F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C475FC: 48061E11  bl 0x82ca940c
	ctx.lr = 0x82C47600;
	sub_82CA93D0(ctx, base);
	// 82C47600: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47604: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47608: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4760C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47610: 4BFBE121  bl 0x82c05730
	ctx.lr = 0x82C47614;
	sub_82C05730(ctx, base);
	// 82C47614: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47618: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C4761C: 388BC5D4  addi r4, r11, -0x3a2c
	ctx.r[4].s64 = ctx.r[11].s64 + -14892;
	// 82C47620: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47624: 3BAAC5C0  addi r29, r10, -0x3a40
	ctx.r[29].s64 = ctx.r[10].s64 + -14912;
	// 82C47628: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4762C: 4BFBE1CD  bl 0x82c057f8
	ctx.lr = 0x82C47630;
	sub_82C057F8(ctx, base);
	// 82C47630: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C47634: 4BFBE235  bl 0x82c05868
	ctx.lr = 0x82C47638;
	sub_82C05868(ctx, base);
	// 82C47638: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C4763C: 4BFBE1BD  bl 0x82c057f8
	ctx.lr = 0x82C47640;
	sub_82C057F8(ctx, base);
	// 82C47640: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 82C47644: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47648: 38890C88  addi r4, r9, 0xc88
	ctx.r[4].s64 = ctx.r[9].s64 + 3208;
	// 82C4764C: 4BFBE1AD  bl 0x82c057f8
	ctx.lr = 0x82C47650;
	sub_82C057F8(ctx, base);
	// 82C47650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47654: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47658: 4BFBE469  bl 0x82c05ac0
	ctx.lr = 0x82C4765C;
	sub_82C05AC0(ctx, base);
	// 82C4765C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C47660: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47668: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C4766C: 4E800421  bctrl
	ctx.lr = 0x82C47670;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47674: 4BFBE0FD  bl 0x82c05770
	ctx.lr = 0x82C47678;
	sub_82C05770(ctx, base);
	// 82C47678: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4767C: 48061DE0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47680(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47680 size=56
    let mut pc: u32 = 0x82C47680;
    'dispatch: loop {
        match pc {
            0x82C47680 => {
    //   block [0x82C47680..0x82C476B8)
	// 82C47680: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47684: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47688: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4768C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47690: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C47694: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C47698: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4769C: 4E800421  bctrl
	ctx.lr = 0x82C476A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C476A0: 7C690034  cntlzw r9, r3
	ctx.r[9].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 82C476A4: 5523DFFE  rlwinm r3, r9, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 82C476A8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C476AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C476B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C476B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C476B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C476B8 size=92
    let mut pc: u32 = 0x82C476B8;
    'dispatch: loop {
        match pc {
            0x82C476B8 => {
    //   block [0x82C476B8..0x82C476FC)
	// 82C476B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C476BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C476C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C476C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C476C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C476CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C476D0: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C476D4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C476D8: 394BC5B0  addi r10, r11, -0x3a50
	ctx.r[10].s64 = ctx.r[11].s64 + -14928;
	// 82C476DC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C476E0: 4BFBEB49  bl 0x82c06228
	ctx.lr = 0x82C476E4;
	sub_82C06228(ctx, base);
	// 82C476E4: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C476E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C476EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C476F0: 419A000C  beq cr6, 0x82c476fc
	if ctx.cr[6].eq {
	pc = 0x82C476FC; continue 'dispatch;
	}
	// 82C476F4: 4BBFE0BD  bl 0x828457b0
	ctx.lr = 0x82C476F8;
	sub_828457B0(ctx, base);
	// 82C476F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C476FC; continue 'dispatch;
            }
            0x82C476FC => {
    //   block [0x82C476FC..0x82C47714)
	// 82C476FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47700: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47704: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47708: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4770C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47710: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47718 size=92
    let mut pc: u32 = 0x82C47718;
    'dispatch: loop {
        match pc {
            0x82C47718 => {
    //   block [0x82C47718..0x82C4775C)
	// 82C47718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4771C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47720: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47724: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47728: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4772C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47730: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47734: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47738: 394BC58C  addi r10, r11, -0x3a74
	ctx.r[10].s64 = ctx.r[11].s64 + -14964;
	// 82C4773C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C47740: 4BFBEAF9  bl 0x82c06238
	ctx.lr = 0x82C47744;
	sub_82C06238(ctx, base);
	// 82C47744: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C47748: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4774C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C47750: 419A000C  beq cr6, 0x82c4775c
	if ctx.cr[6].eq {
	pc = 0x82C4775C; continue 'dispatch;
	}
	// 82C47754: 4BBFE05D  bl 0x828457b0
	ctx.lr = 0x82C47758;
	sub_828457B0(ctx, base);
	// 82C47758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C4775C; continue 'dispatch;
            }
            0x82C4775C => {
    //   block [0x82C4775C..0x82C47774)
	// 82C4775C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47768: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C4776C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47778 size=140
    let mut pc: u32 = 0x82C47778;
    'dispatch: loop {
        match pc {
            0x82C47778 => {
    //   block [0x82C47778..0x82C477FC)
	// 82C47778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4777C: 48061C91  bl 0x82ca940c
	ctx.lr = 0x82C47780;
	sub_82CA93D0(ctx, base);
	// 82C47780: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47784: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C47788: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C4778C: 897D0004  lbz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47790: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47794: 409A0068  bne cr6, 0x82c477fc
	if !ctx.cr[6].eq {
	pc = 0x82C477FC; continue 'dispatch;
	}
	// 82C47798: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4779C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C477A0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C477A4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C477A8: 4E800421  bctrl
	ctx.lr = 0x82C477AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C477AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C477B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82C477B4: 419A0048  beq cr6, 0x82c477fc
	if ctx.cr[6].eq {
	pc = 0x82C477FC; continue 'dispatch;
	}
	// 82C477B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C477BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C477C0: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C477C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C477C8: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C477CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C477D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C477D4: 4E800421  bctrl
	ctx.lr = 0x82C477D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C477D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C477DC: 813F001C  lwz r9, 0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C477E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C477E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C477E8: 4E800421  bctrl
	ctx.lr = 0x82C477EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C477EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C477F0: 4BFBE709  bl 0x82c05ef8
	ctx.lr = 0x82C477F4;
	sub_82C05EF8(ctx, base);
	// 82C477F4: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82C477F8: 991D0004  stb r8, 4(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
            }
            0x82C477FC => {
    //   block [0x82C477FC..0x82C47804)
	// 82C477FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47800: 48061C5C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47808 size=144
    let mut pc: u32 = 0x82C47808;
    'dispatch: loop {
        match pc {
            0x82C47808 => {
    //   block [0x82C47808..0x82C47840)
	// 82C47808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4780C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47810: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47814: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47818: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4781C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C47820: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C47824: 90A10094  stw r5, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[5].u32 ) };
	// 82C47828: 388A4FB0  addi r4, r10, 0x4fb0
	ctx.r[4].s64 = ctx.r[10].s64 + 20400;
	// 82C4782C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47830: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C47834: 4E800421  bctrl
	ctx.lr = 0x82C47838;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47838: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4783C: 409A001C  bne cr6, 0x82c47858
	if !ctx.cr[6].eq {
	pc = 0x82C47858; continue 'dispatch;
	}
            }
            0x82C47840 => {
    //   block [0x82C47840..0x82C47858)
	// 82C47840: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47844: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47848: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4784C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47850: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47854: 4E800020  blr
	return;
            }
            0x82C47858 => {
    //   block [0x82C47858..0x82C47898)
	// 82C47858: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 82C4785C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82C47860: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 82C47864: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47868: 4BFF11A9  bl 0x82c38a10
	ctx.lr = 0x82C4786C;
	sub_82C38A10(ctx, base);
	// 82C4786C: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47870: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47874: 419AFFCC  beq cr6, 0x82c47840
	if ctx.cr[6].eq {
	pc = 0x82C47840; continue 'dispatch;
	}
	// 82C47878: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4787C: 546A103A  slwi r10, r3, 2
	ctx.r[10].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82C47880: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C47884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47888: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4788C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47890: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47894: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47898 size=180
    let mut pc: u32 = 0x82C47898;
    'dispatch: loop {
        match pc {
            0x82C47898 => {
    //   block [0x82C47898..0x82C4792C)
	// 82C47898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4789C: 48061B71  bl 0x82ca940c
	ctx.lr = 0x82C478A0;
	sub_82CA93D0(ctx, base);
	// 82C478A0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C478A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C478A8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C478AC: 4BFFFF5D  bl 0x82c47808
	ctx.lr = 0x82C478B0;
	sub_82C47808(ctx, base);
	// 82C478B0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C478B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C478B8: 409A0074  bne cr6, 0x82c4792c
	if !ctx.cr[6].eq {
	pc = 0x82C4792C; continue 'dispatch;
	}
	// 82C478BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C478C0: 4BFBDE71  bl 0x82c05730
	ctx.lr = 0x82C478C4;
	sub_82C05730(ctx, base);
	// 82C478C4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C478C8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82C478CC: 388BC50C  addi r4, r11, -0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + -15092;
	// 82C478D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C478D4: 3BAA934C  addi r29, r10, -0x6cb4
	ctx.r[29].s64 = ctx.r[10].s64 + -27828;
	// 82C478D8: 4BFBDF21  bl 0x82c057f8
	ctx.lr = 0x82C478DC;
	sub_82C057F8(ctx, base);
	// 82C478DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C478E0: 4BFBDF89  bl 0x82c05868
	ctx.lr = 0x82C478E4;
	sub_82C05868(ctx, base);
	// 82C478E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C478E8: 4BFBDF11  bl 0x82c057f8
	ctx.lr = 0x82C478EC;
	sub_82C057F8(ctx, base);
	// 82C478EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C478F0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C478F4: 4BFBE1CD  bl 0x82c05ac0
	ctx.lr = 0x82C478F8;
	sub_82C05AC0(ctx, base);
	// 82C478F8: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C478FC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47900: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C47904: 3889C5E8  addi r4, r9, -0x3a18
	ctx.r[4].s64 = ctx.r[9].s64 + -14872;
	// 82C47908: 38A00084  li r5, 0x84
	ctx.r[5].s64 = 132;
	// 82C4790C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47910: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C47914: 4E800421  bctrl
	ctx.lr = 0x82C47918;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47918: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4791C: 4BFBDE55  bl 0x82c05770
	ctx.lr = 0x82C47920;
	sub_82C05770(ctx, base);
	// 82C47920: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47924: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47928: 48061B34  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C4792C => {
    //   block [0x82C4792C..0x82C4794C)
	// 82C4792C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47934: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47938: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C4793C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C47940: 4E800421  bctrl
	ctx.lr = 0x82C47944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47944: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47948: 48061B14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47950 size=84
    let mut pc: u32 = 0x82C47950;
    'dispatch: loop {
        match pc {
            0x82C47950 => {
    //   block [0x82C47950..0x82C47990)
	// 82C47950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47958: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4795C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47960: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C47964: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C47968: 388A4FB0  addi r4, r10, 0x4fb0
	ctx.r[4].s64 = ctx.r[10].s64 + 20400;
	// 82C4796C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47970: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C47974: 4E800421  bctrl
	ctx.lr = 0x82C47978;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47978: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4797C: 409A0014  bne cr6, 0x82c47990
	if !ctx.cr[6].eq {
	pc = 0x82C47990; continue 'dispatch;
	}
	// 82C47980: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C47984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4798C: 4E800020  blr
	return;
            }
            0x82C47990 => {
    //   block [0x82C47990..0x82C479A4)
	// 82C47990: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C47994: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C47998: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4799C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C479A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C479A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C479A8 size=224
    let mut pc: u32 = 0x82C479A8;
    'dispatch: loop {
        match pc {
            0x82C479A8 => {
    //   block [0x82C479A8..0x82C47A3C)
	// 82C479A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C479AC: 48061A61  bl 0x82ca940c
	ctx.lr = 0x82C479B0;
	sub_82CA93D0(ctx, base);
	// 82C479B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C479B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82C479B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C479BC: 4BFFFE4D  bl 0x82c47808
	ctx.lr = 0x82C479C0;
	sub_82C47808(ctx, base);
	// 82C479C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C479C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82C479C8: 409A0074  bne cr6, 0x82c47a3c
	if !ctx.cr[6].eq {
	pc = 0x82C47A3C; continue 'dispatch;
	}
	// 82C479CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C479D0: 4BFBDD61  bl 0x82c05730
	ctx.lr = 0x82C479D4;
	sub_82C05730(ctx, base);
	// 82C479D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C479D8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82C479DC: 388BC50C  addi r4, r11, -0x3af4
	ctx.r[4].s64 = ctx.r[11].s64 + -15092;
	// 82C479E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C479E4: 3BAA934C  addi r29, r10, -0x6cb4
	ctx.r[29].s64 = ctx.r[10].s64 + -27828;
	// 82C479E8: 4BFBDE11  bl 0x82c057f8
	ctx.lr = 0x82C479EC;
	sub_82C057F8(ctx, base);
	// 82C479EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C479F0: 4BFBDE79  bl 0x82c05868
	ctx.lr = 0x82C479F4;
	sub_82C05868(ctx, base);
	// 82C479F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C479F8: 4BFBDE01  bl 0x82c057f8
	ctx.lr = 0x82C479FC;
	sub_82C057F8(ctx, base);
	// 82C479FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47A00: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47A04: 4BFBE0BD  bl 0x82c05ac0
	ctx.lr = 0x82C47A08;
	sub_82C05AC0(ctx, base);
	// 82C47A08: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C47A0C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47A10: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82C47A14: 3889C5E8  addi r4, r9, -0x3a18
	ctx.r[4].s64 = ctx.r[9].s64 + -14872;
	// 82C47A18: 38A0009C  li r5, 0x9c
	ctx.r[5].s64 = 156;
	// 82C47A1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47A20: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C47A24: 4E800421  bctrl
	ctx.lr = 0x82C47A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47A28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C47A2C: 4BFBDD45  bl 0x82c05770
	ctx.lr = 0x82C47A30;
	sub_82C05770(ctx, base);
	// 82C47A30: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47A34: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47A38: 48061A24  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47A3C => {
    //   block [0x82C47A3C..0x82C47A74)
	// 82C47A3C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82C47A40: 4B5D7819  bl 0x8221f258
	ctx.lr = 0x82C47A44;
	sub_8221F258(ctx, base);
	// 82C47A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C47A48: 419A002C  beq cr6, 0x82c47a74
	if ctx.cr[6].eq {
	pc = 0x82C47A74; continue 'dispatch;
	}
	// 82C47A4C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C47A50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C47A54: 392AC5B0  addi r9, r10, -0x3a50
	ctx.r[9].s64 = ctx.r[10].s64 + -14928;
	// 82C47A58: 99630004  stb r11, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u8 ) };
	// 82C47A5C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C47A60: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C47A64: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47A68: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C47A6C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47A70: 480619EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47A74 => {
    //   block [0x82C47A74..0x82C47A88)
	// 82C47A74: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47A78: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47A7C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C47A80: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C47A84: 480619D8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47A88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47A88 size=84
    let mut pc: u32 = 0x82C47A88;
    'dispatch: loop {
        match pc {
            0x82C47A88 => {
    //   block [0x82C47A88..0x82C47ADC)
	// 82C47A88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47A8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47A90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47A94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47A98: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47A9C: 3D408333  lis r10, -0x7ccd
	ctx.r[10].s64 = -2093809664;
	// 82C47AA0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C47AA4: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82C47AA8: 388A4FB0  addi r4, r10, 0x4fb0
	ctx.r[4].s64 = ctx.r[10].s64 + 20400;
	// 82C47AAC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47AB0: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C47AB4: 4E800421  bctrl
	ctx.lr = 0x82C47AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47AB8: 81030004  lwz r8, 4(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47ABC: 57E7103A  slwi r7, r31, 2
	ctx.r[7].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 82C47AC0: 7CC8382E  lwzx r6, r8, r7
	ctx.r[6].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 82C47AC4: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47AC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C47ACC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47AD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47AD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47AD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47AE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C47AE0 size=12
    let mut pc: u32 = 0x82C47AE0;
    'dispatch: loop {
        match pc {
            0x82C47AE0 => {
    //   block [0x82C47AE0..0x82C47AEC)
	// 82C47AE0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C47AE4: 386B4FB0  addi r3, r11, 0x4fb0
	ctx.r[3].s64 = ctx.r[11].s64 + 20400;
	// 82C47AE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47AF0 size=128
    let mut pc: u32 = 0x82C47AF0;
    'dispatch: loop {
        match pc {
            0x82C47AF0 => {
    //   block [0x82C47AF0..0x82C47B50)
	// 82C47AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47AF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47AF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47AFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47B00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47B04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47B08: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47B0C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47B10: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82C47B14: 388BAF9C  addi r4, r11, -0x5064
	ctx.r[4].s64 = ctx.r[11].s64 + -20580;
	// 82C47B18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47B1C: 4BFBF68D  bl 0x82c071a8
	ctx.lr = 0x82C47B20;
	sub_82C071A8(ctx, base);
	// 82C47B20: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47B24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47B28: 419A0028  beq cr6, 0x82c47b50
	if ctx.cr[6].eq {
	pc = 0x82C47B50; continue 'dispatch;
	}
	// 82C47B2C: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47B30: 38BF0004  addi r5, r31, 4
	ctx.r[5].s64 = ctx.r[31].s64 + 4;
	// 82C47B34: 388BC66C  addi r4, r11, -0x3994
	ctx.r[4].s64 = ctx.r[11].s64 + -14740;
	// 82C47B38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47B3C: 4BFBF66D  bl 0x82c071a8
	ctx.lr = 0x82C47B40;
	sub_82C071A8(ctx, base);
	// 82C47B40: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47B44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C47B48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47B4C: 409A0008  bne cr6, 0x82c47b54
	if !ctx.cr[6].eq {
	pc = 0x82C47B54; continue 'dispatch;
	}
	pc = 0x82C47B50; continue 'dispatch;
            }
            0x82C47B50 => {
    //   block [0x82C47B50..0x82C47B54)
	// 82C47B50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C47B54; continue 'dispatch;
            }
            0x82C47B54 => {
    //   block [0x82C47B54..0x82C47B70)
	// 82C47B54: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C47B58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47B5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47B60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47B64: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C47B68: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47B6C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47B70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47B70 size=164
    let mut pc: u32 = 0x82C47B70;
    'dispatch: loop {
        match pc {
            0x82C47B70 => {
    //   block [0x82C47B70..0x82C47BC0)
	// 82C47B70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47B74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47B78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47B7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47B80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47B84: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C47B88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47B8C: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47B90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47B94: 419A0068  beq cr6, 0x82c47bfc
	if ctx.cr[6].eq {
	pc = 0x82C47BFC; continue 'dispatch;
	}
	// 82C47B98: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47B9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47BA0: 7D0B4850  subf r8, r11, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 82C47BA4: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82C47BA8: 40980024  bge cr6, 0x82c47bcc
	if !ctx.cr[6].lt {
	pc = 0x82C47BCC; continue 'dispatch;
	}
	// 82C47BAC: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82C47BB0: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 82C47BB4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C47BB8: 40980008  bge cr6, 0x82c47bc0
	if !ctx.cr[6].lt {
	pc = 0x82C47BC0; continue 'dispatch;
	}
	// 82C47BBC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	pc = 0x82C47BC0; continue 'dispatch;
            }
            0x82C47BC0 => {
    //   block [0x82C47BC0..0x82C47BCC)
	// 82C47BC0: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C47BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47BC8: 4BFDE6D9  bl 0x82c262a0
	ctx.lr = 0x82C47BCC;
	sub_82C262A0(ctx, base);
	pc = 0x82C47BCC; continue 'dispatch;
            }
            0x82C47BCC => {
    //   block [0x82C47BCC..0x82C47BFC)
	// 82C47BCC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47BD0: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47BD4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47BD8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82C47BDC: 5525103A  slwi r5, r9, 2
	ctx.r[5].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 82C47BE0: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47BE4: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C47BE8: 48061899  bl 0x82ca9480
	ctx.lr = 0x82C47BEC;
	sub_82CA9480(ctx, base);
	// 82C47BEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47BF0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47BF4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82C47BF8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x82C47BFC; continue 'dispatch;
            }
            0x82C47BFC => {
    //   block [0x82C47BFC..0x82C47C14)
	// 82C47BFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47C08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C47C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47C18 size=148
    let mut pc: u32 = 0x82C47C18;
    'dispatch: loop {
        match pc {
            0x82C47C18 => {
    //   block [0x82C47C18..0x82C47C8C)
	// 82C47C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47C1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47C20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C47C24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C47C28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47C2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47C30: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82C47C34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47C38: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82C47C3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47C40: 4E800421  bctrl
	ctx.lr = 0x82C47C44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47C44: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47C48: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C47C4C: 419A0040  beq cr6, 0x82c47c8c
	if ctx.cr[6].eq {
	pc = 0x82C47C8C; continue 'dispatch;
	}
	// 82C47C50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C47C54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47C58: 4BFFFE99  bl 0x82c47af0
	ctx.lr = 0x82C47C5C;
	sub_82C47AF0(ctx, base);
	// 82C47C5C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47C64: 419A0028  beq cr6, 0x82c47c8c
	if ctx.cr[6].eq {
	pc = 0x82C47C8C; continue 'dispatch;
	}
	// 82C47C68: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47C6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47C70: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 82C47C74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47C78: 4E800421  bctrl
	ctx.lr = 0x82C47C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47C7C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47C80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82C47C84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C47C88: 409A0008  bne cr6, 0x82c47c90
	if !ctx.cr[6].eq {
	pc = 0x82C47C90; continue 'dispatch;
	}
            }
            0x82C47C8C => {
    //   block [0x82C47C8C..0x82C47C90)
	// 82C47C8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82C47C90; continue 'dispatch;
            }
            0x82C47C90 => {
    //   block [0x82C47C90..0x82C47CAC)
	// 82C47C90: 5563063E  clrlwi r3, r11, 0x18
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82C47C94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C47C98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47C9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47CA0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C47CA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C47CA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47CB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47CB0 size=76
    let mut pc: u32 = 0x82C47CB0;
    'dispatch: loop {
        match pc {
            0x82C47CB0 => {
    //   block [0x82C47CB0..0x82C47CE8)
	// 82C47CB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47CB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C47CB8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47CBC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82C47CC0: 4B5D7599  bl 0x8221f258
	ctx.lr = 0x82C47CC4;
	sub_8221F258(ctx, base);
	// 82C47CC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C47CC8: 419A0020  beq cr6, 0x82c47ce8
	if ctx.cr[6].eq {
	pc = 0x82C47CE8; continue 'dispatch;
	}
	// 82C47CCC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C47CD0: 394BC58C  addi r10, r11, -0x3a74
	ctx.r[10].s64 = ctx.r[11].s64 + -14964;
	// 82C47CD4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C47CD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C47CDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47CE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47CE4: 4E800020  blr
	return;
            }
            0x82C47CE8 => {
    //   block [0x82C47CE8..0x82C47CFC)
	// 82C47CE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47CEC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C47CF0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C47CF4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C47CF8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C47D00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C47D00 size=788
    let mut pc: u32 = 0x82C47D00;
    'dispatch: loop {
        match pc {
            0x82C47D00 => {
    //   block [0x82C47D00..0x82C47D6C)
	// 82C47D00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C47D04: 480616FD  bl 0x82ca9400
	ctx.lr = 0x82C47D08;
	sub_82CA93D0(ctx, base);
	// 82C47D08: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C47D0C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C47D10: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82C47D14: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47D18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47D1C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47D20: 4E800421  bctrl
	ctx.lr = 0x82C47D24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47D24: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C47D28: 41980110  blt cr6, 0x82c47e38
	if ctx.cr[6].lt {
	pc = 0x82C47E38; continue 'dispatch;
	}
	// 82C47D2C: 409A026C  bne cr6, 0x82c47f98
	if !ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47D30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47D38: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C47D3C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47D40: 4E800421  bctrl
	ctx.lr = 0x82C47D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47D44: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C47D48: 41980064  blt cr6, 0x82c47dac
	if ctx.cr[6].lt {
	pc = 0x82C47DAC; continue 'dispatch;
	}
	// 82C47D4C: 409A024C  bne cr6, 0x82c47f98
	if !ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47D50: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47D54: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C47D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47D5C: 409902AC  ble cr6, 0x82c48008
	if !ctx.cr[6].gt {
	pc = 0x82C48008; continue 'dispatch;
	}
	// 82C47D60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C47D64: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C47D68: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C47D6C => {
    //   block [0x82C47D6C..0x82C47DAC)
	// 82C47D6C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47D70: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47D74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47D78: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C47D7C: 4BFFFE9D  bl 0x82c47c18
	ctx.lr = 0x82C47D80;
	sub_82C47C18(ctx, base);
	// 82C47D80: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47D84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47D88: 419A0210  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47D8C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47D90: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C47D94: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C47D98: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C47D9C: 4198FFD0  blt cr6, 0x82c47d6c
	if ctx.cr[6].lt {
	pc = 0x82C47D6C; continue 'dispatch;
	}
	// 82C47DA0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C47DA4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47DA8: 480616A8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47DAC => {
    //   block [0x82C47DAC..0x82C47DEC)
	// 82C47DAC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47DB4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C47DB8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47DBC: 4E800421  bctrl
	ctx.lr = 0x82C47DC0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47DC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C47DC4: 3B4B5D98  addi r26, r11, 0x5d98
	ctx.r[26].s64 = ctx.r[11].s64 + 23960;
	// 82C47DC8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C47DCC: 4BFC0DED  bl 0x82c08bb8
	ctx.lr = 0x82C47DD0;
	sub_82C08BB8(ctx, base);
	// 82C47DD0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82C47DD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47DD8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47DDC: 4BFDE4C5  bl 0x82c262a0
	ctx.lr = 0x82C47DE0;
	sub_82C262A0(ctx, base);
	// 82C47DE0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C47DE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82C47DE8: 419A0220  beq cr6, 0x82c48008
	if ctx.cr[6].eq {
	pc = 0x82C48008; continue 'dispatch;
	}
            }
            0x82C47DEC => {
    //   block [0x82C47DEC..0x82C47E38)
	// 82C47DEC: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82C47DF0: 4B5D7469  bl 0x8221f258
	ctx.lr = 0x82C47DF4;
	sub_8221F258(ctx, base);
	// 82C47DF4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C47DF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 82C47DFC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82C47E00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47E04: 4BFFFE15  bl 0x82c47c18
	ctx.lr = 0x82C47E08;
	sub_82C47C18(ctx, base);
	// 82C47E08: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47E0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47E10: 419A0188  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47E14: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C47E18: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47E1C: 4BFDE8CD  bl 0x82c266e8
	ctx.lr = 0x82C47E20;
	sub_82C266E8(ctx, base);
	// 82C47E20: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 82C47E24: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82C47E28: 4198FFC4  blt cr6, 0x82c47dec
	if ctx.cr[6].lt {
	pc = 0x82C47DEC; continue 'dispatch;
	}
	// 82C47E2C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C47E30: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47E34: 4806161C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47E38 => {
    //   block [0x82C47E38..0x82C47EB4)
	// 82C47E38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47E3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47E40: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C47E44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47E48: 4E800421  bctrl
	ctx.lr = 0x82C47E4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47E4C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C47E50: 419800A4  blt cr6, 0x82c47ef4
	if ctx.cr[6].lt {
	pc = 0x82C47EF4; continue 'dispatch;
	}
	// 82C47E54: 409A0144  bne cr6, 0x82c47f98
	if !ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47E58: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47E5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47E60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47E64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47E68: 4E800421  bctrl
	ctx.lr = 0x82C47E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47E6C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47E70: 811B0008  lwz r8, 8(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C47E74: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C47E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47E7C: 80E90020  lwz r7, 0x20(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C47E80: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C47E84: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C47E88: 4E800421  bctrl
	ctx.lr = 0x82C47E8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47E8C: 5466063E  clrlwi r6, r3, 0x18
	ctx.r[6].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47E90: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82C47E94: 419A0104  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47E98: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47E9C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82C47EA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47EA4: 419A0164  beq cr6, 0x82c48008
	if ctx.cr[6].eq {
	pc = 0x82C48008; continue 'dispatch;
	}
	// 82C47EA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C47EAC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C47EB0: 3BAB5D98  addi r29, r11, 0x5d98
	ctx.r[29].s64 = ctx.r[11].s64 + 23960;
            }
            0x82C47EB4 => {
    //   block [0x82C47EB4..0x82C47EF4)
	// 82C47EB4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47EB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C47EBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47EC0: 7CBE582E  lwzx r5, r30, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82C47EC4: 4BFFFD55  bl 0x82c47c18
	ctx.lr = 0x82C47EC8;
	sub_82C47C18(ctx, base);
	// 82C47EC8: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47ECC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C47ED0: 419A00C8  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47ED4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47ED8: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 82C47EDC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 82C47EE0: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C47EE4: 4198FFD0  blt cr6, 0x82c47eb4
	if ctx.cr[6].lt {
	pc = 0x82C47EB4; continue 'dispatch;
	}
	// 82C47EE8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C47EEC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47EF0: 48061560  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47EF4 => {
    //   block [0x82C47EF4..0x82C47F98)
	// 82C47EF4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47EF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47EFC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C47F00: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C47F04: 4E800421  bctrl
	ctx.lr = 0x82C47F08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47F08: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47F0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C47F10: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C47F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47F18: 81090020  lwz r8, 0x20(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 82C47F1C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C47F20: 4E800421  bctrl
	ctx.lr = 0x82C47F24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47F24: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47F28: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82C47F2C: 419A006C  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47F30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47F34: 4BFBFDED  bl 0x82c07d20
	ctx.lr = 0x82C47F38;
	sub_82C07D20(ctx, base);
	// 82C47F38: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47F3C: 7F041840  cmplw cr6, r4, r3
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82C47F40: 40990064  ble cr6, 0x82c47fa4
	if !ctx.cr[6].gt {
	pc = 0x82C47FA4; continue 'dispatch;
	}
	// 82C47F44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C47F48: 4BFBFDD9  bl 0x82c07d20
	ctx.lr = 0x82C47F4C;
	sub_82C07D20(ctx, base);
	// 82C47F4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C47F50: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C47F54: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47F58: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C47F5C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82C47F60: 3B8AB0E8  addi r28, r10, -0x4f18
	ctx.r[28].s64 = ctx.r[10].s64 + -20248;
	// 82C47F64: 810B0040  lwz r8, 0x40(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C47F68: 3B69B0C8  addi r27, r9, -0x4f38
	ctx.r[27].s64 = ctx.r[9].s64 + -20280;
	// 82C47F6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47F70: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C47F74: 4E800421  bctrl
	ctx.lr = 0x82C47F78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C47F78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C47F7C: 4BFBD87D  bl 0x82c057f8
	ctx.lr = 0x82C47F80;
	sub_82C057F8(ctx, base);
	// 82C47F80: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C47F84: 4BFBD8E5  bl 0x82c05868
	ctx.lr = 0x82C47F88;
	sub_82C05868(ctx, base);
	// 82C47F88: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47F8C: 4BFBD86D  bl 0x82c057f8
	ctx.lr = 0x82C47F90;
	sub_82C057F8(ctx, base);
	// 82C47F90: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82C47F94: 4BFBD8D5  bl 0x82c05868
	ctx.lr = 0x82C47F98;
	sub_82C05868(ctx, base);
            }
            0x82C47F98 => {
    //   block [0x82C47F98..0x82C47FA4)
	// 82C47F98: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C47F9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C47FA0: 480614B0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82C47FA4 => {
    //   block [0x82C47FA4..0x82C47FC4)
	// 82C47FA4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47FA8: 4BFDE2F9  bl 0x82c262a0
	ctx.lr = 0x82C47FAC;
	sub_82C262A0(ctx, base);
	// 82C47FAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47FB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47FB4: 419A0054  beq cr6, 0x82c48008
	if ctx.cr[6].eq {
	pc = 0x82C48008; continue 'dispatch;
	}
	// 82C47FB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82C47FBC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82C47FC0: 3B8B5D98  addi r28, r11, 0x5d98
	ctx.r[28].s64 = ctx.r[11].s64 + 23960;
	pc = 0x82C47FC4; continue 'dispatch;
            }
            0x82C47FC4 => {
    //   block [0x82C47FC4..0x82C48008)
	// 82C47FC4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 82C47FC8: 4B5D7291  bl 0x8221f258
	ctx.lr = 0x82C47FCC;
	sub_8221F258(ctx, base);
	// 82C47FCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C47FD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C47FD4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82C47FD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C47FDC: 4BFFFC3D  bl 0x82c47c18
	ctx.lr = 0x82C47FE0;
	sub_82C47C18(ctx, base);
	// 82C47FE0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C47FE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C47FE8: 419AFFB0  beq cr6, 0x82c47f98
	if ctx.cr[6].eq {
	pc = 0x82C47F98; continue 'dispatch;
	}
	// 82C47FEC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C47FF0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82C47FF4: 4BFDE6F5  bl 0x82c266e8
	ctx.lr = 0x82C47FF8;
	sub_82C266E8(ctx, base);
	// 82C47FF8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82C47FFC: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82C48000: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82C48004: 4198FFC0  blt cr6, 0x82c47fc4
	if ctx.cr[6].lt {
	pc = 0x82C47FC4; continue 'dispatch;
	}
	pc = 0x82C48008; continue 'dispatch;
            }
            0x82C48008 => {
    //   block [0x82C48008..0x82C48014)
	// 82C48008: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82C4800C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C48010: 48061440  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48018 size=92
    let mut pc: u32 = 0x82C48018;
    'dispatch: loop {
        match pc {
            0x82C48018 => {
    //   block [0x82C48018..0x82C48060)
	// 82C48018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4801C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C48020: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48024: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 82C48028: 4B5D7231  bl 0x8221f258
	ctx.lr = 0x82C4802C;
	sub_8221F258(ctx, base);
	// 82C4802C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C48030: 419A0030  beq cr6, 0x82c48060
	if ctx.cr[6].eq {
	pc = 0x82C48060; continue 'dispatch;
	}
	// 82C48034: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C48038: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4803C: 392AC660  addi r9, r10, -0x39a0
	ctx.r[9].s64 = ctx.r[10].s64 + -14752;
	// 82C48040: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C48044: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82C48048: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82C4804C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82C48050: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C48054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C48058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C4805C: 4E800020  blr
	return;
            }
            0x82C48060 => {
    //   block [0x82C48060..0x82C48074)
	// 82C48060: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C48064: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82C48068: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4806C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C48070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48078 size=132
    let mut pc: u32 = 0x82C48078;
    'dispatch: loop {
        match pc {
            0x82C48078 => {
    //   block [0x82C48078..0x82C480EC)
	// 82C48078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C4807C: 48061391  bl 0x82ca940c
	ctx.lr = 0x82C48080;
	sub_82CA93D0(ctx, base);
	// 82C48080: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48084: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C48088: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4808C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C48090: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82C48094: 392BC660  addi r9, r11, -0x39a0
	ctx.r[9].s64 = ctx.r[11].s64 + -14752;
	// 82C48098: 390AB008  addi r8, r10, -0x4ff8
	ctx.r[8].s64 = ctx.r[10].s64 + -20472;
	// 82C4809C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82C480A0: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82C480A4: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 82C480A8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 82C480AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82C480B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82C480B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C480B8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 82C480BC: 4BFEC21D  bl 0x82c342d8
	ctx.lr = 0x82C480C0;
	sub_82C342D8(ctx, base);
	// 82C480C0: 3CE08201  lis r7, -0x7dff
	ctx.r[7].s64 = -2113863680;
	// 82C480C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C480C8: 38C7C380  addi r6, r7, -0x3c80
	ctx.r[6].s64 = ctx.r[7].s64 + -15488;
	// 82C480CC: 90C10050  stw r6, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u32 ) };
	// 82C480D0: 4BFFA849  bl 0x82c42918
	ctx.lr = 0x82C480D4;
	sub_82C42918(ctx, base);
	// 82C480D4: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C480D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C480DC: 419A0010  beq cr6, 0x82c480ec
	if ctx.cr[6].eq {
	pc = 0x82C480EC; continue 'dispatch;
	}
	// 82C480E0: 4BBFD6D1  bl 0x828457b0
	ctx.lr = 0x82C480E4;
	sub_828457B0(ctx, base);
	// 82C480E4: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82C480E8: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	pc = 0x82C480EC; continue 'dispatch;
            }
            0x82C480EC => {
    //   block [0x82C480EC..0x82C480FC)
	// 82C480EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C480F0: 4BFBE011  bl 0x82c06100
	ctx.lr = 0x82C480F4;
	sub_82C06100(ctx, base);
	// 82C480F4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C480F8: 48061364  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48100 size=80
    let mut pc: u32 = 0x82C48100;
    'dispatch: loop {
        match pc {
            0x82C48100 => {
    //   block [0x82C48100..0x82C48138)
	// 82C48100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C48104: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C48108: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4810C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C48110: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48114: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C48118: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4811C: 4BFFFF5D  bl 0x82c48078
	ctx.lr = 0x82C48120;
	sub_82C48078(ctx, base);
	// 82C48120: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C48124: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48128: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C4812C: 419A000C  beq cr6, 0x82c48138
	if ctx.cr[6].eq {
	pc = 0x82C48138; continue 'dispatch;
	}
	// 82C48130: 4BBFD681  bl 0x828457b0
	ctx.lr = 0x82C48134;
	sub_828457B0(ctx, base);
	// 82C48134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C48138; continue 'dispatch;
            }
            0x82C48138 => {
    //   block [0x82C48138..0x82C48150)
	// 82C48138: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C4813C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C48140: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C48144: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C48148: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4814C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48150 size=396
    let mut pc: u32 = 0x82C48150;
    'dispatch: loop {
        match pc {
            0x82C48150 => {
    //   block [0x82C48150..0x82C481B8)
	// 82C48150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C48154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C48158: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4815C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C48160: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48164: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C48168: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C4816C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48170: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48174: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C48178: 4E800421  bctrl
	ctx.lr = 0x82C4817C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4817C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C48180: 41980038  blt cr6, 0x82c481b8
	if ctx.cr[6].lt {
	pc = 0x82C481B8; continue 'dispatch;
	}
	// 82C48184: 409A0118  bne cr6, 0x82c4829c
	if !ctx.cr[6].eq {
	pc = 0x82C4829C; continue 'dispatch;
	}
	// 82C48188: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4818C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48190: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C48194: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C48198: 4E800421  bctrl
	ctx.lr = 0x82C4819C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C4819C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C481A0: 41980070  blt cr6, 0x82c48210
	if ctx.cr[6].lt {
	pc = 0x82C48210; continue 'dispatch;
	}
	// 82C481A4: 409A00F8  bne cr6, 0x82c4829c
	if !ctx.cr[6].eq {
	pc = 0x82C4829C; continue 'dispatch;
	}
	// 82C481A8: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C481AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C481B0: 419A0110  beq cr6, 0x82c482c0
	if ctx.cr[6].eq {
	pc = 0x82C482C0; continue 'dispatch;
	}
	// 82C481B4: 48000024  b 0x82c481d8
	pc = 0x82C481D8; continue 'dispatch;
            }
            0x82C481B8 => {
    //   block [0x82C481B8..0x82C481D8)
	// 82C481B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C481BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C481C0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82C481C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C481C8: 4E800421  bctrl
	ctx.lr = 0x82C481CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C481CC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 82C481D0: 41980040  blt cr6, 0x82c48210
	if ctx.cr[6].lt {
	pc = 0x82C48210; continue 'dispatch;
	}
	// 82C481D4: 409A00C8  bne cr6, 0x82c4829c
	if !ctx.cr[6].eq {
	pc = 0x82C4829C; continue 'dispatch;
	}
            }
            0x82C481D8 => {
    //   block [0x82C481D8..0x82C48210)
	// 82C481D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C481DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C481E0: 4BFD9679  bl 0x82c21858
	ctx.lr = 0x82C481E4;
	sub_82C21858(ctx, base);
	// 82C481E4: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C481E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C481EC: 4BFFFB15  bl 0x82c47d00
	ctx.lr = 0x82C481F0;
	sub_82C47D00(ctx, base);
	// 82C481F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C481F4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C481F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C481FC: 4BFF042D  bl 0x82c38628
	ctx.lr = 0x82C48200;
	sub_82C38628(ctx, base);
	// 82C48200: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C48204: 4BFE27ED  bl 0x82c2a9f0
	ctx.lr = 0x82C48208;
	sub_82C2A9F0(ctx, base);
	// 82C48208: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C4820C: 480000B8  b 0x82c482c4
	pc = 0x82C482C4; continue 'dispatch;
            }
            0x82C48210 => {
    //   block [0x82C48210..0x82C48294)
	// 82C48210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C48214: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C48218: 4BFFF0F1  bl 0x82c47308
	ctx.lr = 0x82C4821C;
	sub_82C47308(ctx, base);
	// 82C4821C: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 82C48220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48224: 4BFFFADD  bl 0x82c47d00
	ctx.lr = 0x82C48228;
	sub_82C47D00(ctx, base);
	// 82C48228: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82C4822C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C48230: 419A0064  beq cr6, 0x82c48294
	if ctx.cr[6].eq {
	pc = 0x82C48294; continue 'dispatch;
	}
	// 82C48234: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C48238: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82C4823C: 392AC380  addi r9, r10, -0x3c80
	ctx.r[9].s64 = ctx.r[10].s64 + -15488;
	// 82C48240: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82C48244: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C48248: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82C4824C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48250: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82C48254: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82C48258: 4BFFD851  bl 0x82c45aa8
	ctx.lr = 0x82C4825C;
	sub_82C45AA8(ctx, base);
	// 82C4825C: 8101005C  lwz r8, 0x5c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82C48260: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C48264: 419A0040  beq cr6, 0x82c482a4
	if ctx.cr[6].eq {
	pc = 0x82C482A4; continue 'dispatch;
	}
	// 82C48268: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C4826C: 3D408201  lis r10, -0x7dff
	ctx.r[10].s64 = -2113863680;
	// 82C48270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48274: 3BEAB124  addi r31, r10, -0x4edc
	ctx.r[31].s64 = ctx.r[10].s64 + -20188;
	// 82C48278: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82C4827C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C48280: 4E800421  bctrl
	ctx.lr = 0x82C48284;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48284: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C48288: 4BFBD571  bl 0x82c057f8
	ctx.lr = 0x82C4828C;
	sub_82C057F8(ctx, base);
	// 82C4828C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48290: 4BFFA689  bl 0x82c42918
	ctx.lr = 0x82C48294;
	sub_82C42918(ctx, base);
            }
            0x82C48294 => {
    //   block [0x82C48294..0x82C4829C)
	// 82C48294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C48298: 4BFD3D29  bl 0x82c1bfc0
	ctx.lr = 0x82C4829C;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C4829C; continue 'dispatch;
            }
            0x82C4829C => {
    //   block [0x82C4829C..0x82C482A4)
	// 82C4829C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82C482A0: 48000024  b 0x82c482c4
	pc = 0x82C482C4; continue 'dispatch;
            }
            0x82C482A4 => {
    //   block [0x82C482A4..0x82C482C0)
	// 82C482A4: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82C482A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C482AC: 4BFF037D  bl 0x82c38628
	ctx.lr = 0x82C482B0;
	sub_82C38628(ctx, base);
	// 82C482B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C482B4: 4BFFA665  bl 0x82c42918
	ctx.lr = 0x82C482B8;
	sub_82C42918(ctx, base);
	// 82C482B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82C482BC: 4BFD3D05  bl 0x82c1bfc0
	ctx.lr = 0x82C482C0;
	sub_82C1BFC0(ctx, base);
	pc = 0x82C482C0; continue 'dispatch;
            }
            0x82C482C0 => {
    //   block [0x82C482C0..0x82C482C4)
	// 82C482C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82C482C4; continue 'dispatch;
            }
            0x82C482C4 => {
    //   block [0x82C482C4..0x82C482DC)
	// 82C482C4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82C482C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C482CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C482D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C482D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C482D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C482E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C482E0 size=16
    let mut pc: u32 = 0x82C482E0;
    'dispatch: loop {
        match pc {
            0x82C482E0 => {
    //   block [0x82C482E0..0x82C482F0)
	// 82C482E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82C482E4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C482E8: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 82C482EC: 4BFFFE64  b 0x82c48150
	sub_82C48150(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C482F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82C482F0 size=12
    let mut pc: u32 = 0x82C482F0;
    'dispatch: loop {
        match pc {
            0x82C482F0 => {
    //   block [0x82C482F0..0x82C482FC)
	// 82C482F0: 3D608333  lis r11, -0x7ccd
	ctx.r[11].s64 = -2093809664;
	// 82C482F4: 386B4FBC  addi r3, r11, 0x4fbc
	ctx.r[3].s64 = ctx.r[11].s64 + 20412;
	// 82C482F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48300 size=92
    let mut pc: u32 = 0x82C48300;
    'dispatch: loop {
        match pc {
            0x82C48300 => {
    //   block [0x82C48300..0x82C48344)
	// 82C48300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C48304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C48308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C4830C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C48310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48314: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C48318: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C4831C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82C48320: 394BC690  addi r10, r11, -0x3970
	ctx.r[10].s64 = ctx.r[11].s64 + -14704;
	// 82C48324: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C48328: 4BFBDF11  bl 0x82c06238
	ctx.lr = 0x82C4832C;
	sub_82C06238(ctx, base);
	// 82C4832C: 57C907FE  clrlwi r9, r30, 0x1f
	ctx.r[9].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 82C48330: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48334: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82C48338: 419A000C  beq cr6, 0x82c48344
	if ctx.cr[6].eq {
	pc = 0x82C48344; continue 'dispatch;
	}
	// 82C4833C: 4BBFD475  bl 0x828457b0
	ctx.lr = 0x82C48340;
	sub_828457B0(ctx, base);
	// 82C48340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x82C48344; continue 'dispatch;
            }
            0x82C48344 => {
    //   block [0x82C48344..0x82C4835C)
	// 82C48344: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82C48348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C4834C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C48350: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C48354: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C48358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82C48360 size=188
    let mut pc: u32 = 0x82C48360;
    'dispatch: loop {
        match pc {
            0x82C48360 => {
    //   block [0x82C48360..0x82C483C4)
	// 82C48360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C48364: 480610A9  bl 0x82ca940c
	ctx.lr = 0x82C48368;
	sub_82CA93D0(ctx, base);
	// 82C48368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C4836C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C48370: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C48374: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82C48378: 394BC6C8  addi r10, r11, -0x3938
	ctx.r[10].s64 = ctx.r[11].s64 + -14648;
	// 82C4837C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48380: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82C48384: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 82C48388: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82C4838C: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82C48390: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82C48394: 9BDF0010  stb r30, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u8 ) };
	// 82C48398: 4BFBDC09  bl 0x82c05fa0
	ctx.lr = 0x82C4839C;
	sub_82C05FA0(ctx, base);
	// 82C4839C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C483A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C483A4: 4BFC9925  bl 0x82c11cc8
	ctx.lr = 0x82C483A8;
	sub_82C11CC8(ctx, base);
	// 82C483A8: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82C483AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C483B0: 419A0014  beq cr6, 0x82c483c4
	if ctx.cr[6].eq {
	pc = 0x82C483C4; continue 'dispatch;
	}
	// 82C483B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C483B8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C483BC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C483C0: 4E800421  bctrl
	ctx.lr = 0x82C483C4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C483C4 => {
    //   block [0x82C483C4..0x82C4841C)
	// 82C483C4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 82C483C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C483CC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 82C483D0: 4BFBD361  bl 0x82c05730
	ctx.lr = 0x82C483D4;
	sub_82C05730(ctx, base);
	// 82C483D4: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C483D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C483DC: 388BC6B4  addi r4, r11, -0x394c
	ctx.r[4].s64 = ctx.r[11].s64 + -14668;
	// 82C483E0: 4BFBD419  bl 0x82c057f8
	ctx.lr = 0x82C483E4;
	sub_82C057F8(ctx, base);
	// 82C483E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C483E8: 83DD0000  lwz r30, 0(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C483EC: 83BE0000  lwz r29, 0(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C483F0: 4BC03E91  bl 0x8284c280
	ctx.lr = 0x82C483F4;
	sub_8284C280(ctx, base);
	// 82C483F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C483F8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C483FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C48400: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C48404: 4E800421  bctrl
	ctx.lr = 0x82C48408;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48408: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82C4840C: 4BFBD365  bl 0x82c05770
	ctx.lr = 0x82C48410;
	sub_82C05770(ctx, base);
	// 82C48410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82C48414: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C48418: 48061044  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C48420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C48420 size=380
    let mut pc: u32 = 0x82C48420;
    'dispatch: loop {
        match pc {
            0x82C48420 => {
    //   block [0x82C48420..0x82C4859C)
	// 82C48420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C48424: 48060FE1  bl 0x82ca9404
	ctx.lr = 0x82C48428;
	sub_82CA93D0(ctx, base);
	// 82C48428: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82C4842C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C48430: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82C48434: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82C48438: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82C4843C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C48440: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48444: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C48448: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4844C: 4E800421  bctrl
	ctx.lr = 0x82C48450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48450: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48454: 4BFBD2DD  bl 0x82c05730
	ctx.lr = 0x82C48458;
	sub_82C05730(ctx, base);
	// 82C48458: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C4845C: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C48460: 3889C718  addi r4, r9, -0x38e8
	ctx.r[4].s64 = ctx.r[9].s64 + -14568;
	// 82C48464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48468: 3BE8C70C  addi r31, r8, -0x38f4
	ctx.r[31].s64 = ctx.r[8].s64 + -14580;
	// 82C4846C: C3E10058  lfs f31, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82C48470: 4BFBD389  bl 0x82c057f8
	ctx.lr = 0x82C48474;
	sub_82C057F8(ctx, base);
	// 82C48474: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82C48478: 4BFBD529  bl 0x82c059a0
	ctx.lr = 0x82C4847C;
	sub_82C059A0(ctx, base);
	// 82C4847C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C48480: 4BFBD379  bl 0x82c057f8
	ctx.lr = 0x82C48484;
	sub_82C057F8(ctx, base);
	// 82C48484: 3CE08200  lis r7, -0x7e00
	ctx.r[7].s64 = -2113929216;
	// 82C48488: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4848C: 3B870C88  addi r28, r7, 0xc88
	ctx.r[28].s64 = ctx.r[7].s64 + 3208;
	// 82C48490: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C48494: 4BFBD365  bl 0x82c057f8
	ctx.lr = 0x82C48498;
	sub_82C057F8(ctx, base);
	// 82C48498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4849C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C484A0: 4BFBD621  bl 0x82c05ac0
	ctx.lr = 0x82C484A4;
	sub_82C05AC0(ctx, base);
	// 82C484A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C484A8: 80DF0008  lwz r6, 8(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C484AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C484B0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 82C484B4: 4E800421  bctrl
	ctx.lr = 0x82C484B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C484B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C484BC: 4BFBD2B5  bl 0x82c05770
	ctx.lr = 0x82C484C0;
	sub_82C05770(ctx, base);
	// 82C484C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C484C4: 4BFBD26D  bl 0x82c05730
	ctx.lr = 0x82C484C8;
	sub_82C05730(ctx, base);
	// 82C484C8: 3CA08201  lis r5, -0x7dff
	ctx.r[5].s64 = -2113863680;
	// 82C484CC: 3D608201  lis r11, -0x7dff
	ctx.r[11].s64 = -2113863680;
	// 82C484D0: 3885C700  addi r4, r5, -0x3900
	ctx.r[4].s64 = ctx.r[5].s64 + -14592;
	// 82C484D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C484D8: 3BEBC6F0  addi r31, r11, -0x3910
	ctx.r[31].s64 = ctx.r[11].s64 + -14608;
	// 82C484DC: 837E000C  lwz r27, 0xc(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C484E0: 4BFBD319  bl 0x82c057f8
	ctx.lr = 0x82C484E4;
	sub_82C057F8(ctx, base);
	// 82C484E4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82C484E8: 4BFBD381  bl 0x82c05868
	ctx.lr = 0x82C484EC;
	sub_82C05868(ctx, base);
	// 82C484EC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C484F0: 4BFBD309  bl 0x82c057f8
	ctx.lr = 0x82C484F4;
	sub_82C057F8(ctx, base);
	// 82C484F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C484F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C484FC: 4BFBD2FD  bl 0x82c057f8
	ctx.lr = 0x82C48500;
	sub_82C057F8(ctx, base);
	// 82C48500: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48504: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48508: 4BFBD5B9  bl 0x82c05ac0
	ctx.lr = 0x82C4850C;
	sub_82C05AC0(ctx, base);
	// 82C4850C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C48510: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C48514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C48518: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C4851C: 4E800421  bctrl
	ctx.lr = 0x82C48520;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48520: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48524: 4BFBD24D  bl 0x82c05770
	ctx.lr = 0x82C48528;
	sub_82C05770(ctx, base);
	// 82C48528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4852C: 4BFBD205  bl 0x82c05730
	ctx.lr = 0x82C48530;
	sub_82C05730(ctx, base);
	// 82C48530: 3D208201  lis r9, -0x7dff
	ctx.r[9].s64 = -2113863680;
	// 82C48534: 3D008201  lis r8, -0x7dff
	ctx.r[8].s64 = -2113863680;
	// 82C48538: 3889C6E4  addi r4, r9, -0x391c
	ctx.r[4].s64 = ctx.r[9].s64 + -14620;
	// 82C4853C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48540: 3BE8C6D8  addi r31, r8, -0x3928
	ctx.r[31].s64 = ctx.r[8].s64 + -14632;
	// 82C48544: 8BDE0010  lbz r30, 0x10(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C48548: 4BFBD2B1  bl 0x82c057f8
	ctx.lr = 0x82C4854C;
	sub_82C057F8(ctx, base);
	// 82C4854C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82C48550: 4BFBD4A1  bl 0x82c059f0
	ctx.lr = 0x82C48554;
	sub_82C059F0(ctx, base);
	// 82C48554: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82C48558: 4BFBD2A1  bl 0x82c057f8
	ctx.lr = 0x82C4855C;
	sub_82C057F8(ctx, base);
	// 82C4855C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82C48560: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C48564: 4BFBD295  bl 0x82c057f8
	ctx.lr = 0x82C48568;
	sub_82C057F8(ctx, base);
	// 82C48568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4856C: 83FD0000  lwz r31, 0(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48570: 4BFBD551  bl 0x82c05ac0
	ctx.lr = 0x82C48574;
	sub_82C05AC0(ctx, base);
	// 82C48574: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82C48578: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C4857C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82C48580: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 82C48584: 4E800421  bctrl
	ctx.lr = 0x82C48588;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82C4858C: 4BFBD1E5  bl 0x82c05770
	ctx.lr = 0x82C48590;
	sub_82C05770(ctx, base);
	// 82C48590: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82C48594: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82C48598: 48060EBC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82C485A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82C485A0 size=192
    let mut pc: u32 = 0x82C485A0;
    'dispatch: loop {
        match pc {
            0x82C485A0 => {
    //   block [0x82C485A0..0x82C48604)
	// 82C485A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82C485A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82C485A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82C485AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82C485B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82C485B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82C485B8: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 82C485BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C485C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82C485C4: 419A0084  beq cr6, 0x82c48648
	if ctx.cr[6].eq {
	pc = 0x82C48648; continue 'dispatch;
	}
	// 82C485C8: 895F0010  lbz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C485CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82C485D0: 419A0034  beq cr6, 0x82c48604
	if ctx.cr[6].eq {
	pc = 0x82C48604; continue 'dispatch;
	}
	// 82C485D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C485D8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82C485DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82C485E0: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82C485E4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 82C485E8: 4E800421  bctrl
	ctx.lr = 0x82C485EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C485EC: 81010058  lwz r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82C485F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82C485F4: 409A0054  bne cr6, 0x82c48648
	if !ctx.cr[6].eq {
	pc = 0x82C48648; continue 'dispatch;
	}
	// 82C485F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82C485FC: 4BFBD8FD  bl 0x82c05ef8
	ctx.lr = 0x82C48600;
	sub_82C05EF8(ctx, base);
	// 82C48600: 48000048  b 0x82c48648
	pc = 0x82C48648; continue 'dispatch;
            }
            0x82C48604 => {
    //   block [0x82C48604..0x82C48648)
	// 82C48604: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48608: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82C4860C: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82C48610: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82C48614: 4E800421  bctrl
	ctx.lr = 0x82C48618;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82C48618: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82C4861C: 409A002C  bne cr6, 0x82c48648
	if !ctx.cr[6].eq {
	pc = 0x82C48648; continue 'dispatch;
	}
	// 82C48620: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48624: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82C48628: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 82C4862C: 80BF000C  lwz r5, 0xc(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82C48630: 995F0010  stb r10, 0x10(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 82C48634: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82C48638: C02B0C14  lfs f1, 0xc14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3092 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82C4863C: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82C48640: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 82C48644: 4E800421  bctrl
	ctx.lr = 0x82C48648;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82C48648 => {
    //   block [0x82C48648..0x82C48660)
	// 82C48648: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82C4864C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82C48650: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82C48654: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82C48658: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82C4865C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


