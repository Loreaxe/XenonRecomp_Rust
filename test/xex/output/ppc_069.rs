pub fn sub_827ED9F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827ED9F8 size=576
    let mut pc: u32 = 0x827ED9F8;
    'dispatch: loop {
        match pc {
            0x827ED9F8 => {
    //   block [0x827ED9F8..0x827EDC38)
	// 827ED9F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827ED9FC: 484BBA09  bl 0x82ca9404
	ctx.lr = 0x827EDA00;
	sub_82CA93D0(ctx, base);
	// 827EDA00: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 827EDA04: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 827EDA08: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EDC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EDC38 size=624
    let mut pc: u32 = 0x827EDC38;
    'dispatch: loop {
        match pc {
            0x827EDC38 => {
    //   block [0x827EDC38..0x827EDEA8)
	// 827EDC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EDC3C: 484BB7C9  bl 0x82ca9404
	ctx.lr = 0x827EDC40;
	sub_82CA93D0(ctx, base);
	// 827EDC40: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 827EDC44: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EDEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EDEA8 size=284
    let mut pc: u32 = 0x827EDEA8;
    'dispatch: loop {
        match pc {
            0x827EDEA8 => {
    //   block [0x827EDEA8..0x827EDFC4)
	// 827EDEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EDEAC: 484BB55D  bl 0x82ca9408
	ctx.lr = 0x827EDEB0;
	sub_82CA93D0(ctx, base);
	// 827EDEB0: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EDFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EDFC8 size=612
    let mut pc: u32 = 0x827EDFC8;
    'dispatch: loop {
        match pc {
            0x827EDFC8 => {
    //   block [0x827EDFC8..0x827EE22C)
	// 827EDFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EDFCC: 484BB42D  bl 0x82ca93f8
	ctx.lr = 0x827EDFD0;
	sub_82CA93D0(ctx, base);
	// 827EDFD0: 3980FF90  li r12, -0x70
	ctx.r[12].s64 = -112;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE230(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EE230 size=60
    let mut pc: u32 = 0x827EE230;
    'dispatch: loop {
        match pc {
            0x827EE230 => {
    //   block [0x827EE230..0x827EE26C)
	// 827EE230: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE234: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EE238: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EE23C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE240: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EE244: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE248: 388B94F8  addi r4, r11, -0x6b08
	ctx.r[4].s64 = ctx.r[11].s64 + -27400;
	// 827EE24C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EE250: 4BA3EC81  bl 0x8222ced0
	ctx.lr = 0x827EE254;
	sub_8222CED0(ctx, base);
	// 827EE254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE258: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EE25C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EE260: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EE264: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EE268: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EE270 size=492
    let mut pc: u32 = 0x827EE270;
    'dispatch: loop {
        match pc {
            0x827EE270 => {
    //   block [0x827EE270..0x827EE2CC)
	// 827EE270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE274: 484BB195  bl 0x82ca9408
	ctx.lr = 0x827EE278;
	sub_82CA93D0(ctx, base);
	// 827EE278: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE27C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827EE280: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EE284: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EE288: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827EE28C: 894B6D3B  lbz r10, 0x6d3b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27963 as u32) ) } as u64;
	// 827EE290: 839F000C  lwz r28, 0xc(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EE294: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EE298: 419A0034  beq cr6, 0x827ee2cc
	if ctx.cr[6].eq {
	pc = 0x827EE2CC; continue 'dispatch;
	}
	// 827EE29C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827EE2A0: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE2A4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827EE2A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EE2AC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827EE2B0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE2B4: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EE2B8: 4BA444C1  bl 0x82232778
	ctx.lr = 0x827EE2BC;
	sub_82232778(ctx, base);
	// 827EE2BC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827EE2C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EE2C4: 419A0008  beq cr6, 0x827ee2cc
	if ctx.cr[6].eq {
	pc = 0x827EE2CC; continue 'dispatch;
	}
	// 827EE2C8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x827EE2CC; continue 'dispatch;
            }
            0x827EE2CC => {
    //   block [0x827EE2CC..0x827EE2E0)
	// 827EE2CC: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827EE2D0: 41990010  bgt cr6, 0x827ee2e0
	if ctx.cr[6].gt {
	pc = 0x827EE2E0; continue 'dispatch;
	}
	// 827EE2D4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 827EE2D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE2DC: 409A0038  bne cr6, 0x827ee314
	if !ctx.cr[6].eq {
	pc = 0x827EE314; continue 'dispatch;
	}
	pc = 0x827EE2E0; continue 'dispatch;
            }
            0x827EE2E0 => {
    //   block [0x827EE2E0..0x827EE314)
	// 827EE2E0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EE2E4: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EE2E8: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 827EE2EC: 5528003E  slwi r8, r9, 0
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EE2F0: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 827EE2F4: 7D07FE70  srawi r7, r8, 0x1f
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 31) as i64;
	// 827EE2F8: 7CE64038  and r6, r7, r8
	ctx.r[6].u64 = ctx.r[7].u64 & ctx.r[8].u64;
	// 827EE2FC: 7D664050  subf r11, r6, r8
	ctx.r[11].s64 = ctx.r[8].s64 - ctx.r[6].s64;
	// 827EE300: 7CAB5050  subf r5, r11, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827EE304: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 827EE308: 7C8A2838  and r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 & ctx.r[5].u64;
	// 827EE30C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EE310: 907F000C  stw r3, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[3].u32 ) };
	pc = 0x827EE314; continue 'dispatch;
            }
            0x827EE314 => {
    //   block [0x827EE314..0x827EE374)
	// 827EE314: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EE318: 7F0BE000  cmpw cr6, r11, r28
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[28].s32, &mut ctx.xer);
	// 827EE31C: 419A0138  beq cr6, 0x827ee454
	if ctx.cr[6].eq {
	pc = 0x827EE454; continue 'dispatch;
	}
	// 827EE320: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 827EE324: 7CABE051  subf. r5, r11, r28
	ctx.r[5].s64 = ctx.r[28].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 827EE328: 915F0028  stw r10, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[10].u32 ) };
	// 827EE32C: 40810128  ble 0x827ee454
	if !ctx.cr[0].gt {
	pc = 0x827EE454; continue 'dispatch;
	}
	// 827EE330: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE334: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827EE338: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 827EE33C: 55493FFE  rlwinm r9, r10, 7, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x01FFFFFFu64;
	// 827EE340: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827EE344: 419A00F8  beq cr6, 0x827ee43c
	if ctx.cr[6].eq {
	pc = 0x827EE43C; continue 'dispatch;
	}
	// 827EE348: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EE34C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EE350: 419A0024  beq cr6, 0x827ee374
	if ctx.cr[6].eq {
	pc = 0x827EE374; continue 'dispatch;
	}
	// 827EE354: 894A0039  lbz r10, 0x39(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(57 as u32) ) } as u64;
	// 827EE358: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EE35C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827EE360: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EE364: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE368: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EE36C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EE370: 480000D0  b 0x827ee440
	pc = 0x827EE440; continue 'dispatch;
            }
            0x827EE374 => {
    //   block [0x827EE374..0x827EE394)
	// 827EE374: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EE378: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827EE37C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EE380: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827EE384: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EE388: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EE38C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EE390: 40810054  ble 0x827ee3e4
	if !ctx.cr[0].gt {
	pc = 0x827EE3E4; continue 'dispatch;
	}
	pc = 0x827EE394; continue 'dispatch;
            }
            0x827EE394 => {
    //   block [0x827EE394..0x827EE3B4)
	// 827EE394: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EE398: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EE39C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EE3A0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EE3A4: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 827EE3A8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EE3AC: 41980008  blt cr6, 0x827ee3b4
	if ctx.cr[6].lt {
	pc = 0x827EE3B4; continue 'dispatch;
	}
	// 827EE3B0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827EE3B4; continue 'dispatch;
            }
            0x827EE3B4 => {
    //   block [0x827EE3B4..0x827EE3D0)
	// 827EE3B4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EE3B8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EE3BC: 419A0014  beq cr6, 0x827ee3d0
	if ctx.cr[6].eq {
	pc = 0x827EE3D0; continue 'dispatch;
	}
	// 827EE3C0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EE3C4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EE3C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EE3CC: 4800000C  b 0x827ee3d8
	pc = 0x827EE3D8; continue 'dispatch;
            }
            0x827EE3D0 => {
    //   block [0x827EE3D0..0x827EE3D8)
	// 827EE3D0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EE3D4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EE3D8; continue 'dispatch;
            }
            0x827EE3D8 => {
    //   block [0x827EE3D8..0x827EE3E4)
	// 827EE3D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EE3DC: 4199FFB8  bgt cr6, 0x827ee394
	if ctx.cr[6].gt {
	pc = 0x827EE394; continue 'dispatch;
	}
	// 827EE3E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EE3E4; continue 'dispatch;
            }
            0x827EE3E4 => {
    //   block [0x827EE3E4..0x827EE400)
	// 827EE3E4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EE3E8: 419A0040  beq cr6, 0x827ee428
	if ctx.cr[6].eq {
	pc = 0x827EE428; continue 'dispatch;
	}
	// 827EE3EC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EE3F0: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 827EE3F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EE3F8: 41990008  bgt cr6, 0x827ee400
	if ctx.cr[6].gt {
	pc = 0x827EE400; continue 'dispatch;
	}
	// 827EE3FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EE400; continue 'dispatch;
            }
            0x827EE400 => {
    //   block [0x827EE400..0x827EE428)
	// 827EE400: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EE404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE408: 409A0020  bne cr6, 0x827ee428
	if !ctx.cr[6].eq {
	pc = 0x827EE428; continue 'dispatch;
	}
	// 827EE40C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EE410: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EE414: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EE418: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE41C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EE420: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EE424: 4800001C  b 0x827ee440
	pc = 0x827EE440; continue 'dispatch;
            }
            0x827EE428 => {
    //   block [0x827EE428..0x827EE43C)
	// 827EE428: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EE42C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE430: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EE434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EE438: 48000008  b 0x827ee440
	pc = 0x827EE440; continue 'dispatch;
            }
            0x827EE43C => {
    //   block [0x827EE43C..0x827EE440)
	// 827EE43C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EE440; continue 'dispatch;
            }
            0x827EE440 => {
    //   block [0x827EE440..0x827EE454)
	// 827EE440: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EE444: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE448: 419A000C  beq cr6, 0x827ee454
	if ctx.cr[6].eq {
	pc = 0x827EE454; continue 'dispatch;
	}
	// 827EE44C: 38800007  li r4, 7
	ctx.r[4].s64 = 7;
	// 827EE450: 4BAEA9B9  bl 0x822d8e08
	ctx.lr = 0x827EE454;
	sub_822D8E08(ctx, base);
	pc = 0x827EE454; continue 'dispatch;
            }
            0x827EE454 => {
    //   block [0x827EE454..0x827EE45C)
	// 827EE454: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EE458: 484BB000  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EE460 size=68
    let mut pc: u32 = 0x827EE460;
    'dispatch: loop {
        match pc {
            0x827EE460 => {
    //   block [0x827EE460..0x827EE4A4)
	// 827EE460: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EE464: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 827EE468: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 827EE46C: 548B003E  slwi r11, r4, 0
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827EE470: 81030018  lwz r8, 0x18(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 827EE474: 90830014  stw r4, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 827EE478: 7D6AFE70  srawi r10, r11, 0x1f
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 31) as i64;
	// 827EE47C: 7D495838  and r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[11].u64;
	// 827EE480: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EE484: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 827EE488: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 827EE48C: 7CCA3838  and r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 827EE490: 7CAA5A14  add r5, r10, r11
	ctx.r[5].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EE494: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 827EE498: 80830024  lwz r4, 0x24(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 827EE49C: 90830028  stw r4, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[4].u32 ) };
	// 827EE4A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EE4A8 size=396
    let mut pc: u32 = 0x827EE4A8;
    'dispatch: loop {
        match pc {
            0x827EE4A8 => {
    //   block [0x827EE4A8..0x827EE634)
	// 827EE4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EE4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EE4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EE4B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE4BC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EE4C4: 3BCB9EC0  addi r30, r11, -0x6140
	ctx.r[30].s64 = ctx.r[11].s64 + -24896;
	// 827EE4C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE4CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE4D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EE4D4: 4BA3E9FD  bl 0x8222ced0
	ctx.lr = 0x827EE4D8;
	sub_8222CED0(ctx, base);
	// 827EE4D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE4DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EE4E0: 48000489  bl 0x827ee968
	ctx.lr = 0x827EE4E4;
	sub_827EE968(ctx, base);
	// 827EE4E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE4E8: 4BA268F1  bl 0x82214dd8
	ctx.lr = 0x827EE4EC;
	sub_82214DD8(ctx, base);
	// 827EE4EC: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 827EE4F0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE4F4: 388A10D8  addi r4, r10, 0x10d8
	ctx.r[4].s64 = ctx.r[10].s64 + 4312;
	// 827EE4F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE4FC: 4BA3E9D5  bl 0x8222ced0
	ctx.lr = 0x827EE500;
	sub_8222CED0(ctx, base);
	// 827EE500: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EE504: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE508: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE50C: 4BA3E9C5  bl 0x8222ced0
	ctx.lr = 0x827EE510;
	sub_8222CED0(ctx, base);
	// 827EE510: 3D2082EB  lis r9, -0x7d15
	ctx.r[9].s64 = -2098528256;
	// 827EE514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE518: 38C955A8  addi r6, r9, 0x55a8
	ctx.r[6].s64 = ctx.r[9].s64 + 21928;
	// 827EE51C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827EE520: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EE524: 4800068D  bl 0x827eebb0
	ctx.lr = 0x827EE528;
	sub_827EEBB0(ctx, base);
	// 827EE528: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE52C: 4BA268AD  bl 0x82214dd8
	ctx.lr = 0x827EE530;
	sub_82214DD8(ctx, base);
	// 827EE530: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE534: 4BA268A5  bl 0x82214dd8
	ctx.lr = 0x827EE538;
	sub_82214DD8(ctx, base);
	// 827EE538: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 827EE53C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE540: 3888CA9C  addi r4, r8, -0x3564
	ctx.r[4].s64 = ctx.r[8].s64 + -13668;
	// 827EE544: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE548: 4BA3E989  bl 0x8222ced0
	ctx.lr = 0x827EE54C;
	sub_8222CED0(ctx, base);
	// 827EE54C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EE550: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE554: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE558: 4BA3E979  bl 0x8222ced0
	ctx.lr = 0x827EE55C;
	sub_8222CED0(ctx, base);
	// 827EE55C: 3CE08291  lis r7, -0x7d6f
	ctx.r[7].s64 = -2104426496;
	// 827EE560: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE564: 38C7DD08  addi r6, r7, -0x22f8
	ctx.r[6].s64 = ctx.r[7].s64 + -8952;
	// 827EE568: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EE56C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EE570: 48000641  bl 0x827eebb0
	ctx.lr = 0x827EE574;
	sub_827EEBB0(ctx, base);
	// 827EE574: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE578: 4BA26861  bl 0x82214dd8
	ctx.lr = 0x827EE57C;
	sub_82214DD8(ctx, base);
	// 827EE57C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE580: 4BA26859  bl 0x82214dd8
	ctx.lr = 0x827EE584;
	sub_82214DD8(ctx, base);
	// 827EE584: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 827EE588: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE58C: 3886CAA4  addi r4, r6, -0x355c
	ctx.r[4].s64 = ctx.r[6].s64 + -13660;
	// 827EE590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE594: 4BA3E93D  bl 0x8222ced0
	ctx.lr = 0x827EE598;
	sub_8222CED0(ctx, base);
	// 827EE598: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EE59C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE5A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE5A4: 4BA3E92D  bl 0x8222ced0
	ctx.lr = 0x827EE5A8;
	sub_8222CED0(ctx, base);
	// 827EE5A8: 3C80827F  lis r4, -0x7d81
	ctx.r[4].s64 = -2105606144;
	// 827EE5AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EE5B0: 38C4E460  addi r6, r4, -0x1ba0
	ctx.r[6].s64 = ctx.r[4].s64 + -7072;
	// 827EE5B4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EE5B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE5BC: 480007F5  bl 0x827eedb0
	ctx.lr = 0x827EE5C0;
	sub_827EEDB0(ctx, base);
	// 827EE5C0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE5C4: 4BA26815  bl 0x82214dd8
	ctx.lr = 0x827EE5C8;
	sub_82214DD8(ctx, base);
	// 827EE5C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE5CC: 4BA2680D  bl 0x82214dd8
	ctx.lr = 0x827EE5D0;
	sub_82214DD8(ctx, base);
	// 827EE5D0: 3C60820B  lis r3, -0x7df5
	ctx.r[3].s64 = -2113208320;
	// 827EE5D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE5D8: 388328CC  addi r4, r3, 0x28cc
	ctx.r[4].s64 = ctx.r[3].s64 + 10444;
	// 827EE5DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE5E0: 4BA3E8F1  bl 0x8222ced0
	ctx.lr = 0x827EE5E4;
	sub_8222CED0(ctx, base);
	// 827EE5E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EE5E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE5EC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE5F0: 4BA3E8E1  bl 0x8222ced0
	ctx.lr = 0x827EE5F4;
	sub_8222CED0(ctx, base);
	// 827EE5F4: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EE5F8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EE5FC: 38CBE270  addi r6, r11, -0x1d90
	ctx.r[6].s64 = ctx.r[11].s64 + -7568;
	// 827EE600: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EE604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EE608: 480007A9  bl 0x827eedb0
	ctx.lr = 0x827EE60C;
	sub_827EEDB0(ctx, base);
	// 827EE60C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EE610: 4BA267C9  bl 0x82214dd8
	ctx.lr = 0x827EE614;
	sub_82214DD8(ctx, base);
	// 827EE614: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE618: 4BA267C1  bl 0x82214dd8
	ctx.lr = 0x827EE61C;
	sub_82214DD8(ctx, base);
	// 827EE61C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EE620: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EE624: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EE628: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EE62C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EE630: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EE638 size=260
    let mut pc: u32 = 0x827EE638;
    'dispatch: loop {
        match pc {
            0x827EE638 => {
    //   block [0x827EE638..0x827EE6AC)
	// 827EE638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EE640: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EE644: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EE648: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE64C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EE650: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EE654: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827EE658: 419A0054  beq cr6, 0x827ee6ac
	if ctx.cr[6].eq {
	pc = 0x827EE6AC; continue 'dispatch;
	}
	// 827EE65C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE660: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 827EE664: 388B9EC0  addi r4, r11, -0x6140
	ctx.r[4].s64 = ctx.r[11].s64 + -24896;
	// 827EE668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE66C: 4BBBEDFD  bl 0x823ad468
	ctx.lr = 0x827EE670;
	sub_823AD468(ctx, base);
	// 827EE670: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827EE674: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 827EE678: 388A9EC8  addi r4, r10, -0x6138
	ctx.r[4].s64 = ctx.r[10].s64 + -24888;
	// 827EE67C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE680: 4BBBEDE9  bl 0x823ad468
	ctx.lr = 0x827EE684;
	sub_823AD468(ctx, base);
	// 827EE684: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827EE688: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 827EE68C: 38899ED0  addi r4, r9, -0x6130
	ctx.r[4].s64 = ctx.r[9].s64 + -24880;
	// 827EE690: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE694: 4BBBEDD5  bl 0x823ad468
	ctx.lr = 0x827EE698;
	sub_823AD468(ctx, base);
	// 827EE698: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827EE69C: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 827EE6A0: 38889EE0  addi r4, r8, -0x6120
	ctx.r[4].s64 = ctx.r[8].s64 + -24864;
	// 827EE6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE6A8: 4BBBEDC1  bl 0x823ad468
	ctx.lr = 0x827EE6AC;
	sub_823AD468(ctx, base);
	pc = 0x827EE6AC; continue 'dispatch;
            }
            0x827EE6AC => {
    //   block [0x827EE6AC..0x827EE73C)
	// 827EE6AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827EE6B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE6B4: 388B3FBC  addi r4, r11, 0x3fbc
	ctx.r[4].s64 = ctx.r[11].s64 + 16316;
	// 827EE6B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE6BC: 4BA3E815  bl 0x8222ced0
	ctx.lr = 0x827EE6C0;
	sub_8222CED0(ctx, base);
	// 827EE6C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EE6C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EE6C8: 4B9ADF21  bl 0x8219c5e8
	ctx.lr = 0x827EE6CC;
	sub_8219C5E8(ctx, base);
	// 827EE6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE6D0: 4BA26709  bl 0x82214dd8
	ctx.lr = 0x827EE6D4;
	sub_82214DD8(ctx, base);
	// 827EE6D4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827EE6D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EE6DC: 38EA9EF0  addi r7, r10, -0x6110
	ctx.r[7].s64 = ctx.r[10].s64 + -24848;
	// 827EE6E0: 4B9C3E19  bl 0x821b24f8
	ctx.lr = 0x827EE6E4;
	sub_821B24F8(ctx, base);
	// 827EE6E4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 827EE6E8: 4BBD1139  bl 0x823bf820
	ctx.lr = 0x827EE6EC;
	sub_823BF820(ctx, base);
	// 827EE6EC: 80DF0024  lwz r6, 0x24(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 827EE6F0: 3CA08332  lis r5, -0x7cce
	ctx.r[5].s64 = -2093875200;
	// 827EE6F4: 809F0014  lwz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EE6F8: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 827EE6FC: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 827EE700: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 827EE704: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827EE708: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 827EE70C: C8059660  lfd f0, -0x69a0(r5)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(-27040 as u32) ) };
	// 827EE710: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 827EE714: FD8D0032  fmul f12, f13, f0
	ctx.f[12].f64 = ctx.f[13].f64 * ctx.f[0].f64;
	// 827EE718: FD60601E  fctiwz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 827EE71C: 39800024  li r12, 0x24
	ctx.r[12].s64 = 36;
	// 827EE720: 7D7F67AE  stfiwx f11, r31, r12
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 827EE724: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EE728: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EE72C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EE730: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EE734: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EE738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EE740 size=464
    let mut pc: u32 = 0x827EE740;
    'dispatch: loop {
        match pc {
            0x827EE740 => {
    //   block [0x827EE740..0x827EE78C)
	// 827EE740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE744: 484BACC9  bl 0x82ca940c
	ctx.lr = 0x827EE748;
	sub_82CA93D0(ctx, base);
	// 827EE748: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE74C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EE750: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EE754: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827EE758: 409A01B0  bne cr6, 0x827ee908
	if !ctx.cr[6].eq {
	pc = 0x827EE908; continue 'dispatch;
	}
	// 827EE75C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE760: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE764: 388B9EC0  addi r4, r11, -0x6140
	ctx.r[4].s64 = ctx.r[11].s64 + -24896;
	// 827EE768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE76C: 4BA3E765  bl 0x8222ced0
	ctx.lr = 0x827EE770;
	sub_8222CED0(ctx, base);
	// 827EE770: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827EE774: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 827EE778: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE77C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE784: 419A0008  beq cr6, 0x827ee78c
	if ctx.cr[6].eq {
	pc = 0x827EE78C; continue 'dispatch;
	}
	// 827EE788: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE78C; continue 'dispatch;
            }
            0x827EE78C => {
    //   block [0x827EE78C..0x827EE7C8)
	// 827EE78C: 38BF000C  addi r5, r31, 0xc
	ctx.r[5].s64 = ctx.r[31].s64 + 12;
	// 827EE790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE794: 4BC92035  bl 0x824807c8
	ctx.lr = 0x827EE798;
	sub_824807C8(ctx, base);
	// 827EE798: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE79C: 4BA2663D  bl 0x82214dd8
	ctx.lr = 0x827EE7A0;
	sub_82214DD8(ctx, base);
	// 827EE7A0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE7A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE7A8: 388B9EC8  addi r4, r11, -0x6138
	ctx.r[4].s64 = ctx.r[11].s64 + -24888;
	// 827EE7AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE7B0: 4BA3E721  bl 0x8222ced0
	ctx.lr = 0x827EE7B4;
	sub_8222CED0(ctx, base);
	// 827EE7B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE7B8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE7BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE7C0: 419A0008  beq cr6, 0x827ee7c8
	if ctx.cr[6].eq {
	pc = 0x827EE7C8; continue 'dispatch;
	}
	// 827EE7C4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE7C8; continue 'dispatch;
            }
            0x827EE7C8 => {
    //   block [0x827EE7C8..0x827EE804)
	// 827EE7C8: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 827EE7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE7D0: 4BC91FF9  bl 0x824807c8
	ctx.lr = 0x827EE7D4;
	sub_824807C8(ctx, base);
	// 827EE7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE7D8: 4BA26601  bl 0x82214dd8
	ctx.lr = 0x827EE7DC;
	sub_82214DD8(ctx, base);
	// 827EE7DC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE7E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE7E4: 388B9EFC  addi r4, r11, -0x6104
	ctx.r[4].s64 = ctx.r[11].s64 + -24836;
	// 827EE7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE7EC: 4BA3E6E5  bl 0x8222ced0
	ctx.lr = 0x827EE7F0;
	sub_8222CED0(ctx, base);
	// 827EE7F0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE7F4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE7F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE7FC: 419A0008  beq cr6, 0x827ee804
	if ctx.cr[6].eq {
	pc = 0x827EE804; continue 'dispatch;
	}
	// 827EE800: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE804; continue 'dispatch;
            }
            0x827EE804 => {
    //   block [0x827EE804..0x827EE840)
	// 827EE804: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 827EE808: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE80C: 4BC91FBD  bl 0x824807c8
	ctx.lr = 0x827EE810;
	sub_824807C8(ctx, base);
	// 827EE810: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE814: 4BA265C5  bl 0x82214dd8
	ctx.lr = 0x827EE818;
	sub_82214DD8(ctx, base);
	// 827EE818: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE81C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE820: 388B9F08  addi r4, r11, -0x60f8
	ctx.r[4].s64 = ctx.r[11].s64 + -24824;
	// 827EE824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE828: 4BA3E6A9  bl 0x8222ced0
	ctx.lr = 0x827EE82C;
	sub_8222CED0(ctx, base);
	// 827EE82C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE830: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE838: 419A0008  beq cr6, 0x827ee840
	if ctx.cr[6].eq {
	pc = 0x827EE840; continue 'dispatch;
	}
	// 827EE83C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE840; continue 'dispatch;
            }
            0x827EE840 => {
    //   block [0x827EE840..0x827EE87C)
	// 827EE840: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 827EE844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE848: 4BC91F81  bl 0x824807c8
	ctx.lr = 0x827EE84C;
	sub_824807C8(ctx, base);
	// 827EE84C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE850: 4BA26589  bl 0x82214dd8
	ctx.lr = 0x827EE854;
	sub_82214DD8(ctx, base);
	// 827EE854: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE858: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE85C: 388B9F1C  addi r4, r11, -0x60e4
	ctx.r[4].s64 = ctx.r[11].s64 + -24804;
	// 827EE860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE864: 4BA3E66D  bl 0x8222ced0
	ctx.lr = 0x827EE868;
	sub_8222CED0(ctx, base);
	// 827EE868: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE86C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE870: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE874: 419A0008  beq cr6, 0x827ee87c
	if ctx.cr[6].eq {
	pc = 0x827EE87C; continue 'dispatch;
	}
	// 827EE878: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE87C; continue 'dispatch;
            }
            0x827EE87C => {
    //   block [0x827EE87C..0x827EE8B8)
	// 827EE87C: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 827EE880: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE884: 4BC91F45  bl 0x824807c8
	ctx.lr = 0x827EE888;
	sub_824807C8(ctx, base);
	// 827EE888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE88C: 4BA2654D  bl 0x82214dd8
	ctx.lr = 0x827EE890;
	sub_82214DD8(ctx, base);
	// 827EE890: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE894: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE898: 388B9ED0  addi r4, r11, -0x6130
	ctx.r[4].s64 = ctx.r[11].s64 + -24880;
	// 827EE89C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE8A0: 4BA3E631  bl 0x8222ced0
	ctx.lr = 0x827EE8A4;
	sub_8222CED0(ctx, base);
	// 827EE8A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE8A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE8B0: 419A0008  beq cr6, 0x827ee8b8
	if ctx.cr[6].eq {
	pc = 0x827EE8B8; continue 'dispatch;
	}
	// 827EE8B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE8B8; continue 'dispatch;
            }
            0x827EE8B8 => {
    //   block [0x827EE8B8..0x827EE8F4)
	// 827EE8B8: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 827EE8BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE8C0: 4BC91F09  bl 0x824807c8
	ctx.lr = 0x827EE8C4;
	sub_824807C8(ctx, base);
	// 827EE8C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE8C8: 4BA26511  bl 0x82214dd8
	ctx.lr = 0x827EE8CC;
	sub_82214DD8(ctx, base);
	// 827EE8CC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EE8D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EE8D4: 388B9EE0  addi r4, r11, -0x6120
	ctx.r[4].s64 = ctx.r[11].s64 + -24864;
	// 827EE8D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE8DC: 4BA3E5F5  bl 0x8222ced0
	ctx.lr = 0x827EE8E0;
	sub_8222CED0(ctx, base);
	// 827EE8E0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EE8E4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EE8E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE8EC: 419A0008  beq cr6, 0x827ee8f4
	if ctx.cr[6].eq {
	pc = 0x827EE8F4; continue 'dispatch;
	}
	// 827EE8F0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE8F4; continue 'dispatch;
            }
            0x827EE8F4 => {
    //   block [0x827EE8F4..0x827EE908)
	// 827EE8F4: 38BF001C  addi r5, r31, 0x1c
	ctx.r[5].s64 = ctx.r[31].s64 + 28;
	// 827EE8F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EE8FC: 4BC91ECD  bl 0x824807c8
	ctx.lr = 0x827EE900;
	sub_824807C8(ctx, base);
	// 827EE900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE904: 4BA264D5  bl 0x82214dd8
	ctx.lr = 0x827EE908;
	sub_82214DD8(ctx, base);
	pc = 0x827EE908; continue 'dispatch;
            }
            0x827EE908 => {
    //   block [0x827EE908..0x827EE910)
	// 827EE908: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EE90C: 484BAB50  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EE910 size=24
    let mut pc: u32 = 0x827EE910;
    'dispatch: loop {
        match pc {
            0x827EE910 => {
    //   block [0x827EE910..0x827EE928)
	// 827EE910: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827EE914: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EE918: 40990010  ble cr6, 0x827ee928
	if !ctx.cr[6].gt {
		sub_827EE928(ctx, base);
		return;
	}
	// 827EE91C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EE920: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 827EE924: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EE928 size=64
    let mut pc: u32 = 0x827EE928;
    'dispatch: loop {
        match pc {
            0x827EE928 => {
    //   block [0x827EE928..0x827EE968)
	// 827EE928: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 827EE92C: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827EE930: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 827EE934: 81230014  lwz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 827EE938: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827EE93C: 5507003E  slwi r7, r8, 0
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 827EE940: 9103000C  stw r8, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 827EE944: 7CE6FE70  srawi r6, r7, 0x1f
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[7].s32 >> 31) as i64;
	// 827EE948: 7CC53838  and r5, r6, r7
	ctx.r[5].u64 = ctx.r[6].u64 & ctx.r[7].u64;
	// 827EE94C: 7D653850  subf r11, r5, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[5].s64;
	// 827EE950: 7C8B4850  subf r4, r11, r9
	ctx.r[4].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 827EE954: 7C8AFE70  srawi r10, r4, 0x1f
	ctx.xer.ca = (ctx.r[4].s32 < 0) && ((ctx.r[4].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[4].s32 >> 31) as i64;
	// 827EE958: 7D4A2038  and r10, r10, r4
	ctx.r[10].u64 = ctx.r[10].u64 & ctx.r[4].u64;
	// 827EE95C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EE960: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 827EE964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EE968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EE968 size=584
    let mut pc: u32 = 0x827EE968;
    'dispatch: loop {
        match pc {
            0x827EE968 => {
    //   block [0x827EE968..0x827EE990)
	// 827EE968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EE96C: 484BAA95  bl 0x82ca9400
	ctx.lr = 0x827EE970;
	sub_82CA93D0(ctx, base);
	// 827EE970: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EE974: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EE978: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827EE97C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EE980: 409A0010  bne cr6, 0x827ee990
	if !ctx.cr[6].eq {
	pc = 0x827EE990; continue 'dispatch;
	}
	// 827EE984: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827EE988: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 827EE98C: 48000008  b 0x827ee994
	pc = 0x827EE994; continue 'dispatch;
            }
            0x827EE990 => {
    //   block [0x827EE990..0x827EE994)
	// 827EE990: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EE994; continue 'dispatch;
            }
            0x827EE994 => {
    //   block [0x827EE994..0x827EEA0C)
	// 827EE994: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EE998: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EE99C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EE9A0: 4BBDFC21  bl 0x823ce5c0
	ctx.lr = 0x827EE9A4;
	sub_823CE5C0(ctx, base);
	// 827EE9A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EE9A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EE9AC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EE9B0: 4BBDF851  bl 0x823ce200
	ctx.lr = 0x827EE9B4;
	sub_823CE200(ctx, base);
	// 827EE9B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EE9B8: 4B9C9161  bl 0x821b7b18
	ctx.lr = 0x827EE9BC;
	sub_821B7B18(ctx, base);
	// 827EE9BC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 827EE9C0: 4BA30899  bl 0x8221f258
	ctx.lr = 0x827EE9C4;
	sub_8221F258(ctx, base);
	// 827EE9C4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EE9C8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EE9CC: 419A0040  beq cr6, 0x827eea0c
	if ctx.cr[6].eq {
	pc = 0x827EEA0C; continue 'dispatch;
	}
	// 827EE9D0: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 827EE9D4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EE9D8: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 827EE9DC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EE9E0: 4BA30879  bl 0x8221f258
	ctx.lr = 0x827EE9E4;
	sub_8221F258(ctx, base);
	// 827EE9E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EE9E8: 419A0028  beq cr6, 0x827eea10
	if ctx.cr[6].eq {
	pc = 0x827EEA10; continue 'dispatch;
	}
	// 827EE9EC: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EE9F0: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827EE9F4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EE9F8: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EE9FC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EEA00: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827EEA04: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EEA08: 4800000C  b 0x827eea14
	pc = 0x827EEA14; continue 'dispatch;
            }
            0x827EEA0C => {
    //   block [0x827EEA0C..0x827EEA10)
	// 827EEA0C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EEA10; continue 'dispatch;
            }
            0x827EEA10 => {
    //   block [0x827EEA10..0x827EEA14)
	// 827EEA10: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EEA14; continue 'dispatch;
            }
            0x827EEA14 => {
    //   block [0x827EEA14..0x827EEB18)
	// 827EEA14: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EEA18: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EEA1C: 419A00FC  beq cr6, 0x827eeb18
	if ctx.cr[6].eq {
	pc = 0x827EEB18; continue 'dispatch;
	}
	// 827EEA20: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEA24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EEA28: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEA2C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EEA30: 4BA3A6D9  bl 0x82229108
	ctx.lr = 0x827EEA34;
	sub_82229108(ctx, base);
	// 827EEA34: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EEA38: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EEA3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EEA40: 3BCBEFB0  addi r30, r11, -0x1050
	ctx.r[30].s64 = ctx.r[11].s64 + -4176;
	// 827EEA44: 4BA38E3D  bl 0x82227880
	ctx.lr = 0x827EEA48;
	sub_82227880(ctx, base);
	// 827EEA48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EEA4C: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 827EEA50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EEA54: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 827EEA58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EEA5C: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827EEA60: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EEA64: 4B9AC01D  bl 0x8219aa80
	ctx.lr = 0x827EEA68;
	sub_8219AA80(ctx, base);
	// 827EEA68: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 827EEA6C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827EEA70: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 827EEA74: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EEA78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EEA7C: 4BBDF9A5  bl 0x823ce420
	ctx.lr = 0x827EEA80;
	sub_823CE420(ctx, base);
	// 827EEA80: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EEA84: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EEA88: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EEA8C: 48235C3D  bl 0x82a246c8
	ctx.lr = 0x827EEA90;
	sub_82A246C8(ctx, base);
	// 827EEA90: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EEA94: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EEA98: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 827EEA9C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 827EEAA0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEAA4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEAA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EEAAC: 4BA3A65D  bl 0x82229108
	ctx.lr = 0x827EEAB0;
	sub_82229108(ctx, base);
	// 827EEAB0: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EEAB4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EEAB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EEABC: 3BEBEFF0  addi r31, r11, -0x1010
	ctx.r[31].s64 = ctx.r[11].s64 + -4112;
	// 827EEAC0: 4BA38DC1  bl 0x82227880
	ctx.lr = 0x827EEAC4;
	sub_82227880(ctx, base);
	// 827EEAC4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827EEAC8: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 827EEACC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EEAD0: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 827EEAD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EEAD8: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827EEADC: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827EEAE0: 4B9ABFA1  bl 0x8219aa80
	ctx.lr = 0x827EEAE4;
	sub_8219AA80(ctx, base);
	// 827EEAE4: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 827EEAE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EEAEC: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 827EEAF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EEAF4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEAF8: 4BBDF929  bl 0x823ce420
	ctx.lr = 0x827EEAFC;
	sub_823CE420(ctx, base);
	// 827EEAFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEB00: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EEB04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EEB08: 48235BC1  bl 0x82a246c8
	ctx.lr = 0x827EEB0C;
	sub_82A246C8(ctx, base);
	// 827EEB0C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EEB10: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 827EEB14: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x827EEB18; continue 'dispatch;
            }
            0x827EEB18 => {
    //   block [0x827EEB18..0x827EEB28)
	// 827EEB18: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 827EEB1C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827EEB20: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 827EEB24: 419A0020  beq cr6, 0x827eeb44
	if ctx.cr[6].eq {
	pc = 0x827EEB44; continue 'dispatch;
	}
	pc = 0x827EEB28; continue 'dispatch;
            }
            0x827EEB28 => {
    //   block [0x827EEB28..0x827EEB44)
	// 827EEB28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EEB2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEB30: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EEB34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EEB38: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EEB3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEB40: 4082FFE8  bne 0x827eeb28
	if !ctx.cr[0].eq {
	pc = 0x827EEB28; continue 'dispatch;
	}
	pc = 0x827EEB44; continue 'dispatch;
            }
            0x827EEB44 => {
    //   block [0x827EEB44..0x827EEB64)
	// 827EEB44: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEB48: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827EEB4C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EEB50: 4BB06DF9  bl 0x822f5948
	ctx.lr = 0x827EEB54;
	sub_822F5948(ctx, base);
	// 827EEB54: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEB58: 4B9C8FC1  bl 0x821b7b18
	ctx.lr = 0x827EEB5C;
	sub_821B7B18(ctx, base);
	// 827EEB5C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827EEB60: 419A0040  beq cr6, 0x827eeba0
	if ctx.cr[6].eq {
	pc = 0x827EEBA0; continue 'dispatch;
	}
	pc = 0x827EEB64; continue 'dispatch;
            }
            0x827EEB64 => {
    //   block [0x827EEB64..0x827EEBA0)
	// 827EEB64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EEB68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEB6C: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EEB70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EEB74: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EEB78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEB7C: 4082FFE8  bne 0x827eeb64
	if !ctx.cr[0].eq {
	pc = 0x827EEB64; continue 'dispatch;
	}
	// 827EEB80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EEB84: 409A001C  bne cr6, 0x827eeba0
	if !ctx.cr[6].eq {
	pc = 0x827EEBA0; continue 'dispatch;
	}
	// 827EEB88: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EEB8C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEB90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EEB94: 4E800421  bctrl
	ctx.lr = 0x827EEB98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EEB98: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827EEB9C: 4BA2D19D  bl 0x8221bd38
	ctx.lr = 0x827EEBA0;
	sub_8221BD38(ctx, base);
            }
            0x827EEBA0 => {
    //   block [0x827EEBA0..0x827EEBB0)
	// 827EEBA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EEBA4: 4B9C8F75  bl 0x821b7b18
	ctx.lr = 0x827EEBA8;
	sub_821B7B18(ctx, base);
	// 827EEBA8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EEBAC: 484BA8A4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEBB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EEBB0 size=512
    let mut pc: u32 = 0x827EEBB0;
    'dispatch: loop {
        match pc {
            0x827EEBB0 => {
    //   block [0x827EEBB0..0x827EEBE8)
	// 827EEBB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EEBB4: 484BA849  bl 0x82ca93fc
	ctx.lr = 0x827EEBB8;
	sub_82CA93D0(ctx, base);
	// 827EEBB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EEBBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EEBC0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 827EEBC4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827EEBC8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 827EEBCC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827EEBD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEBD4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827EEBD8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EEBDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEBE0: 419A0008  beq cr6, 0x827eebe8
	if ctx.cr[6].eq {
	pc = 0x827EEBE8; continue 'dispatch;
	}
	// 827EEBE4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EEBE8; continue 'dispatch;
            }
            0x827EEBE8 => {
    //   block [0x827EEBE8..0x827EEC7C)
	// 827EEBE8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEBEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EEBF0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEBF4: 4BBDF9CD  bl 0x823ce5c0
	ctx.lr = 0x827EEBF8;
	sub_823CE5C0(ctx, base);
	// 827EEBF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EEBFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEC00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEC04: 4BBDF50D  bl 0x823ce110
	ctx.lr = 0x827EEC08;
	sub_823CE110(ctx, base);
	// 827EEC08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EEC0C: 4B9C8F0D  bl 0x821b7b18
	ctx.lr = 0x827EEC10;
	sub_821B7B18(ctx, base);
	// 827EEC10: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827EEC14: 4BA30645  bl 0x8221f258
	ctx.lr = 0x827EEC18;
	sub_8221F258(ctx, base);
	// 827EEC18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EEC1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EEC20: 419A005C  beq cr6, 0x827eec7c
	if ctx.cr[6].eq {
	pc = 0x827EEC7C; continue 'dispatch;
	}
	// 827EEC24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EEC28: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827EEC2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EEC30: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 827EEC34: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827EEC38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EEC3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827EEC40: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EEC44: 4BA015FD  bl 0x821f0240
	ctx.lr = 0x827EEC48;
	sub_821F0240(ctx, base);
	// 827EEC48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EEC4C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827EEC50: 4BA30609  bl 0x8221f258
	ctx.lr = 0x827EEC54;
	sub_8221F258(ctx, base);
	// 827EEC54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EEC58: 419A0028  beq cr6, 0x827eec80
	if ctx.cr[6].eq {
	pc = 0x827EEC80; continue 'dispatch;
	}
	// 827EEC5C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EEC60: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 827EEC64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EEC68: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EEC6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EEC70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EEC74: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EEC78: 4800000C  b 0x827eec84
	pc = 0x827EEC84; continue 'dispatch;
            }
            0x827EEC7C => {
    //   block [0x827EEC7C..0x827EEC80)
	// 827EEC7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EEC80; continue 'dispatch;
            }
            0x827EEC80 => {
    //   block [0x827EEC80..0x827EEC84)
	// 827EEC80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EEC84; continue 'dispatch;
            }
            0x827EEC84 => {
    //   block [0x827EEC84..0x827EEC98)
	// 827EEC84: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEC88: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EEC8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEC90: 419A0008  beq cr6, 0x827eec98
	if ctx.cr[6].eq {
	pc = 0x827EEC98; continue 'dispatch;
	}
	// 827EEC94: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EEC98; continue 'dispatch;
            }
            0x827EEC98 => {
    //   block [0x827EEC98..0x827EED18)
	// 827EEC98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827EEC9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EECA0: 419A0078  beq cr6, 0x827eed18
	if ctx.cr[6].eq {
	pc = 0x827EED18; continue 'dispatch;
	}
	// 827EECA4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EECA8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EECAC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EECB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EECB4: 4BA3A455  bl 0x82229108
	ctx.lr = 0x827EECB8;
	sub_82229108(ctx, base);
	// 827EECB8: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EECBC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EECC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EECC4: 3BCBEFF8  addi r30, r11, -0x1008
	ctx.r[30].s64 = ctx.r[11].s64 + -4104;
	// 827EECC8: 4BA38BB9  bl 0x82227880
	ctx.lr = 0x827EECCC;
	sub_82227880(ctx, base);
	// 827EECCC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EECD0: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 827EECD4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EECD8: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 827EECDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EECE0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827EECE4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EECE8: 4B9ABD99  bl 0x8219aa80
	ctx.lr = 0x827EECEC;
	sub_8219AA80(ctx, base);
	// 827EECEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EECF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EECF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EECF8: 4BBDF729  bl 0x823ce420
	ctx.lr = 0x827EECFC;
	sub_823CE420(ctx, base);
	// 827EECFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EED00: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EED04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EED08: 482359C1  bl 0x82a246c8
	ctx.lr = 0x827EED0C;
	sub_82A246C8(ctx, base);
	// 827EED0C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EED10: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 827EED14: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x827EED18; continue 'dispatch;
            }
            0x827EED18 => {
    //   block [0x827EED18..0x827EED28)
	// 827EED18: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827EED1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EED20: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827EED24: 419A0020  beq cr6, 0x827eed44
	if ctx.cr[6].eq {
	pc = 0x827EED44; continue 'dispatch;
	}
	pc = 0x827EED28; continue 'dispatch;
            }
            0x827EED28 => {
    //   block [0x827EED28..0x827EED44)
	// 827EED28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EED2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EED30: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EED34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EED38: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EED3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EED40: 4082FFE8  bne 0x827eed28
	if !ctx.cr[0].eq {
	pc = 0x827EED28; continue 'dispatch;
	}
	pc = 0x827EED44; continue 'dispatch;
            }
            0x827EED44 => {
    //   block [0x827EED44..0x827EED64)
	// 827EED44: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EED48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EED4C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EED50: 4BB06BF9  bl 0x822f5948
	ctx.lr = 0x827EED54;
	sub_822F5948(ctx, base);
	// 827EED54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EED58: 4B9C8DC1  bl 0x821b7b18
	ctx.lr = 0x827EED5C;
	sub_821B7B18(ctx, base);
	// 827EED5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EED60: 419A0040  beq cr6, 0x827eeda0
	if ctx.cr[6].eq {
	pc = 0x827EEDA0; continue 'dispatch;
	}
	pc = 0x827EED64; continue 'dispatch;
            }
            0x827EED64 => {
    //   block [0x827EED64..0x827EEDA0)
	// 827EED64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EED68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EED6C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EED70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EED74: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EED78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EED7C: 4082FFE8  bne 0x827eed64
	if !ctx.cr[0].eq {
	pc = 0x827EED64; continue 'dispatch;
	}
	// 827EED80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EED84: 409A001C  bne cr6, 0x827eeda0
	if !ctx.cr[6].eq {
	pc = 0x827EEDA0; continue 'dispatch;
	}
	// 827EED88: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EED8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EED90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EED94: 4E800421  bctrl
	ctx.lr = 0x827EED98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EED98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EED9C: 4BA2CF9D  bl 0x8221bd38
	ctx.lr = 0x827EEDA0;
	sub_8221BD38(ctx, base);
            }
            0x827EEDA0 => {
    //   block [0x827EEDA0..0x827EEDB0)
	// 827EEDA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEDA4: 4B9C8D75  bl 0x821b7b18
	ctx.lr = 0x827EEDA8;
	sub_821B7B18(ctx, base);
	// 827EEDA8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EEDAC: 484BA6A0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEDB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EEDB0 size=512
    let mut pc: u32 = 0x827EEDB0;
    'dispatch: loop {
        match pc {
            0x827EEDB0 => {
    //   block [0x827EEDB0..0x827EEDE8)
	// 827EEDB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EEDB4: 484BA649  bl 0x82ca93fc
	ctx.lr = 0x827EEDB8;
	sub_82CA93D0(ctx, base);
	// 827EEDB8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EEDBC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EEDC0: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 827EEDC4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827EEDC8: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 827EEDCC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827EEDD0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEDD4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827EEDD8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EEDDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEDE0: 419A0008  beq cr6, 0x827eede8
	if ctx.cr[6].eq {
	pc = 0x827EEDE8; continue 'dispatch;
	}
	// 827EEDE4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EEDE8; continue 'dispatch;
            }
            0x827EEDE8 => {
    //   block [0x827EEDE8..0x827EEE7C)
	// 827EEDE8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEDEC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EEDF0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEDF4: 4BBDF7CD  bl 0x823ce5c0
	ctx.lr = 0x827EEDF8;
	sub_823CE5C0(ctx, base);
	// 827EEDF8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EEDFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEE00: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEE04: 4BBDF30D  bl 0x823ce110
	ctx.lr = 0x827EEE08;
	sub_823CE110(ctx, base);
	// 827EEE08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EEE0C: 4B9C8D0D  bl 0x821b7b18
	ctx.lr = 0x827EEE10;
	sub_821B7B18(ctx, base);
	// 827EEE10: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827EEE14: 4BA30445  bl 0x8221f258
	ctx.lr = 0x827EEE18;
	sub_8221F258(ctx, base);
	// 827EEE18: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EEE1C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EEE20: 419A005C  beq cr6, 0x827eee7c
	if ctx.cr[6].eq {
	pc = 0x827EEE7C; continue 'dispatch;
	}
	// 827EEE24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EEE28: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 827EEE2C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EEE30: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 827EEE34: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827EEE38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EEE3C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827EEE40: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EEE44: 4BA013FD  bl 0x821f0240
	ctx.lr = 0x827EEE48;
	sub_821F0240(ctx, base);
	// 827EEE48: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EEE4C: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827EEE50: 4BA30409  bl 0x8221f258
	ctx.lr = 0x827EEE54;
	sub_8221F258(ctx, base);
	// 827EEE54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EEE58: 419A0028  beq cr6, 0x827eee80
	if ctx.cr[6].eq {
	pc = 0x827EEE80; continue 'dispatch;
	}
	// 827EEE5C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EEE60: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 827EEE64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EEE68: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EEE6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EEE70: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EEE74: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EEE78: 4800000C  b 0x827eee84
	pc = 0x827EEE84; continue 'dispatch;
            }
            0x827EEE7C => {
    //   block [0x827EEE7C..0x827EEE80)
	// 827EEE7C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EEE80; continue 'dispatch;
            }
            0x827EEE80 => {
    //   block [0x827EEE80..0x827EEE84)
	// 827EEE80: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EEE84; continue 'dispatch;
            }
            0x827EEE84 => {
    //   block [0x827EEE84..0x827EEE98)
	// 827EEE84: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEE88: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EEE8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEE90: 419A0008  beq cr6, 0x827eee98
	if ctx.cr[6].eq {
	pc = 0x827EEE98; continue 'dispatch;
	}
	// 827EEE94: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EEE98; continue 'dispatch;
            }
            0x827EEE98 => {
    //   block [0x827EEE98..0x827EEF18)
	// 827EEE98: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827EEE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEEA0: 419A0078  beq cr6, 0x827eef18
	if ctx.cr[6].eq {
	pc = 0x827EEF18; continue 'dispatch;
	}
	// 827EEEA4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EEEA8: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EEEAC: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEEB0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EEEB4: 4BA3A255  bl 0x82229108
	ctx.lr = 0x827EEEB8;
	sub_82229108(ctx, base);
	// 827EEEB8: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EEEBC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EEEC0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EEEC4: 3BCBF170  addi r30, r11, -0xe90
	ctx.r[30].s64 = ctx.r[11].s64 + -3728;
	// 827EEEC8: 4BA389B9  bl 0x82227880
	ctx.lr = 0x827EEECC;
	sub_82227880(ctx, base);
	// 827EEECC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EEED0: 3D40825F  lis r10, -0x7da1
	ctx.r[10].s64 = -2107703296;
	// 827EEED4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EEED8: 388A8BA8  addi r4, r10, -0x7458
	ctx.r[4].s64 = ctx.r[10].s64 + -29784;
	// 827EEEDC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EEEE0: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827EEEE4: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EEEE8: 4B9ABB99  bl 0x8219aa80
	ctx.lr = 0x827EEEEC;
	sub_8219AA80(ctx, base);
	// 827EEEEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEEF0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EEEF4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEEF8: 4BBDF529  bl 0x823ce420
	ctx.lr = 0x827EEEFC;
	sub_823CE420(ctx, base);
	// 827EEEFC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EEF00: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EEF04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EEF08: 482357C1  bl 0x82a246c8
	ctx.lr = 0x827EEF0C;
	sub_82A246C8(ctx, base);
	// 827EEF0C: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EEF10: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 827EEF14: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x827EEF18; continue 'dispatch;
            }
            0x827EEF18 => {
    //   block [0x827EEF18..0x827EEF28)
	// 827EEF18: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827EEF1C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EEF20: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827EEF24: 419A0020  beq cr6, 0x827eef44
	if ctx.cr[6].eq {
	pc = 0x827EEF44; continue 'dispatch;
	}
	pc = 0x827EEF28; continue 'dispatch;
            }
            0x827EEF28 => {
    //   block [0x827EEF28..0x827EEF44)
	// 827EEF28: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EEF2C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEF30: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EEF34: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EEF38: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EEF3C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEF40: 4082FFE8  bne 0x827eef28
	if !ctx.cr[0].eq {
	pc = 0x827EEF28; continue 'dispatch;
	}
	pc = 0x827EEF44; continue 'dispatch;
            }
            0x827EEF44 => {
    //   block [0x827EEF44..0x827EEF64)
	// 827EEF44: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEF48: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EEF4C: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EEF50: 4BB069F9  bl 0x822f5948
	ctx.lr = 0x827EEF54;
	sub_822F5948(ctx, base);
	// 827EEF54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EEF58: 4B9C8BC1  bl 0x821b7b18
	ctx.lr = 0x827EEF5C;
	sub_821B7B18(ctx, base);
	// 827EEF5C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EEF60: 419A0040  beq cr6, 0x827eefa0
	if ctx.cr[6].eq {
	pc = 0x827EEFA0; continue 'dispatch;
	}
	pc = 0x827EEF64; continue 'dispatch;
            }
            0x827EEF64 => {
    //   block [0x827EEF64..0x827EEFA0)
	// 827EEF64: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EEF68: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEF6C: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EEF70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EEF74: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EEF78: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EEF7C: 4082FFE8  bne 0x827eef64
	if !ctx.cr[0].eq {
	pc = 0x827EEF64; continue 'dispatch;
	}
	// 827EEF80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EEF84: 409A001C  bne cr6, 0x827eefa0
	if !ctx.cr[6].eq {
	pc = 0x827EEFA0; continue 'dispatch;
	}
	// 827EEF88: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EEF8C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EEF90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EEF94: 4E800421  bctrl
	ctx.lr = 0x827EEF98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EEF98: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EEF9C: 4BA2CD9D  bl 0x8221bd38
	ctx.lr = 0x827EEFA0;
	sub_8221BD38(ctx, base);
            }
            0x827EEFA0 => {
    //   block [0x827EEFA0..0x827EEFB0)
	// 827EEFA0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EEFA4: 4B9C8B75  bl 0x821b7b18
	ctx.lr = 0x827EEFA8;
	sub_821B7B18(ctx, base);
	// 827EEFA8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EEFAC: 484BA4A0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEFB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EEFB0 size=56
    let mut pc: u32 = 0x827EEFB0;
    'dispatch: loop {
        match pc {
            0x827EEFB0 => {
    //   block [0x827EEFB0..0x827EEFCC)
	// 827EEFB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827EEFB4: 419A0018  beq cr6, 0x827eefcc
	if ctx.cr[6].eq {
	pc = 0x827EEFCC; continue 'dispatch;
	}
	// 827EEFB8: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827EEFBC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827EEFC0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EEFC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EEFC8: 409A0008  bne cr6, 0x827eefd0
	if !ctx.cr[6].eq {
	pc = 0x827EEFD0; continue 'dispatch;
	}
	pc = 0x827EEFCC; continue 'dispatch;
            }
            0x827EEFCC => {
    //   block [0x827EEFCC..0x827EEFD0)
	// 827EEFCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EEFD0; continue 'dispatch;
            }
            0x827EEFD0 => {
    //   block [0x827EEFD0..0x827EEFE8)
	// 827EEFD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EEFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EEFD8: 419A0010  beq cr6, 0x827eefe8
	if ctx.cr[6].eq {
		sub_827EEFE8(ctx, base);
		return;
	}
	// 827EEFDC: 8164002C  lwz r11, 0x2c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 827EEFE0: 55631FFE  rlwinm r3, r11, 3, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 827EEFE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EEFE8 size=8
    let mut pc: u32 = 0x827EEFE8;
    'dispatch: loop {
        match pc {
            0x827EEFE8 => {
    //   block [0x827EEFE8..0x827EEFF0)
	// 827EEFE8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827EEFEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEFF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827EEFF0 size=8
    let mut pc: u32 = 0x827EEFF0;
    'dispatch: loop {
        match pc {
            0x827EEFF0 => {
    //   block [0x827EEFF0..0x827EEFF8)
	// 827EEFF0: 3860005D  li r3, 0x5d
	ctx.r[3].s64 = 93;
	// 827EEFF4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EEFF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EEFF8 size=372
    let mut pc: u32 = 0x827EEFF8;
    'dispatch: loop {
        match pc {
            0x827EEFF8 => {
    //   block [0x827EEFF8..0x827EF020)
	// 827EEFF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EEFFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF000: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF004: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827EF008: 419A0018  beq cr6, 0x827ef020
	if ctx.cr[6].eq {
	pc = 0x827EF020; continue 'dispatch;
	}
	// 827EF00C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827EF010: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827EF014: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF018: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF01C: 409A0008  bne cr6, 0x827ef024
	if !ctx.cr[6].eq {
	pc = 0x827EF024; continue 'dispatch;
	}
	pc = 0x827EF020; continue 'dispatch;
            }
            0x827EF020 => {
    //   block [0x827EF020..0x827EF024)
	// 827EF020: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EF024; continue 'dispatch;
            }
            0x827EF024 => {
    //   block [0x827EF024..0x827EF06C)
	// 827EF024: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF02C: 419A012C  beq cr6, 0x827ef158
	if ctx.cr[6].eq {
	pc = 0x827EF158; continue 'dispatch;
	}
	// 827EF030: 8144002C  lwz r10, 0x2c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(44 as u32) ) } as u64;
	// 827EF034: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EF038: 55491FFE  rlwinm r9, r10, 3, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x1FFFFFFFu64;
	// 827EF03C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827EF040: 419A00E8  beq cr6, 0x827ef128
	if ctx.cr[6].eq {
	pc = 0x827EF128; continue 'dispatch;
	}
	// 827EF044: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EF048: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF050: 419A001C  beq cr6, 0x827ef06c
	if ctx.cr[6].eq {
	pc = 0x827EF06C; continue 'dispatch;
	}
	// 827EF054: 896B005D  lbz r11, 0x5d(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(93 as u32) ) } as u64;
	// 827EF058: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827EF05C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827EF060: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF064: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EF068: 480000C4  b 0x827ef12c
	pc = 0x827EF12C; continue 'dispatch;
            }
            0x827EF06C => {
    //   block [0x827EF06C..0x827EF088)
	// 827EF06C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EF070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827EF074: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EF078: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EF07C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827EF080: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF084: 40810054  ble 0x827ef0d8
	if !ctx.cr[0].gt {
	pc = 0x827EF0D8; continue 'dispatch;
	}
	pc = 0x827EF088; continue 'dispatch;
            }
            0x827EF088 => {
    //   block [0x827EF088..0x827EF0A8)
	// 827EF088: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EF08C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EF090: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EF094: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF098: 2F07005D  cmpwi cr6, r7, 0x5d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 93, &mut ctx.xer);
	// 827EF09C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EF0A0: 41980008  blt cr6, 0x827ef0a8
	if ctx.cr[6].lt {
	pc = 0x827EF0A8; continue 'dispatch;
	}
	// 827EF0A4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827EF0A8; continue 'dispatch;
            }
            0x827EF0A8 => {
    //   block [0x827EF0A8..0x827EF0C4)
	// 827EF0A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EF0AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EF0B0: 419A0014  beq cr6, 0x827ef0c4
	if ctx.cr[6].eq {
	pc = 0x827EF0C4; continue 'dispatch;
	}
	// 827EF0B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EF0B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EF0BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EF0C0: 4800000C  b 0x827ef0cc
	pc = 0x827EF0CC; continue 'dispatch;
            }
            0x827EF0C4 => {
    //   block [0x827EF0C4..0x827EF0CC)
	// 827EF0C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EF0C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EF0CC; continue 'dispatch;
            }
            0x827EF0CC => {
    //   block [0x827EF0CC..0x827EF0D8)
	// 827EF0CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF0D0: 4199FFB8  bgt cr6, 0x827ef088
	if ctx.cr[6].gt {
	pc = 0x827EF088; continue 'dispatch;
	}
	// 827EF0D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EF0D8; continue 'dispatch;
            }
            0x827EF0D8 => {
    //   block [0x827EF0D8..0x827EF0F4)
	// 827EF0D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EF0DC: 419A003C  beq cr6, 0x827ef118
	if ctx.cr[6].eq {
	pc = 0x827EF118; continue 'dispatch;
	}
	// 827EF0E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF0E4: 2F0B005D  cmpwi cr6, r11, 0x5d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 93, &mut ctx.xer);
	// 827EF0E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF0EC: 41990008  bgt cr6, 0x827ef0f4
	if ctx.cr[6].gt {
	pc = 0x827EF0F4; continue 'dispatch;
	}
	// 827EF0F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EF0F4; continue 'dispatch;
            }
            0x827EF0F4 => {
    //   block [0x827EF0F4..0x827EF118)
	// 827EF0F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF0F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF0FC: 409A001C  bne cr6, 0x827ef118
	if !ctx.cr[6].eq {
	pc = 0x827EF118; continue 'dispatch;
	}
	// 827EF100: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EF104: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EF108: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EF10C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EF110: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF114: 48000018  b 0x827ef12c
	pc = 0x827EF12C; continue 'dispatch;
            }
            0x827EF118 => {
    //   block [0x827EF118..0x827EF128)
	// 827EF118: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EF11C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EF120: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF124: 48000008  b 0x827ef12c
	pc = 0x827EF12C; continue 'dispatch;
            }
            0x827EF128 => {
    //   block [0x827EF128..0x827EF12C)
	// 827EF128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827EF12C; continue 'dispatch;
            }
            0x827EF12C => {
    //   block [0x827EF12C..0x827EF158)
	// 827EF12C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827EF130: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF134: 419A0024  beq cr6, 0x827ef158
	if ctx.cr[6].eq {
	pc = 0x827EF158; continue 'dispatch;
	}
	// 827EF138: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EF13C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EF140: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827EF144: 4E800421  bctrl
	ctx.lr = 0x827EF148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EF148: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF14C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF154: 4E800020  blr
	return;
            }
            0x827EF158 => {
    //   block [0x827EF158..0x827EF16C)
	// 827EF158: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827EF15C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF160: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF164: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF168: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF170(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF170 size=376
    let mut pc: u32 = 0x827EF170;
    'dispatch: loop {
        match pc {
            0x827EF170 => {
    //   block [0x827EF170..0x827EF19C)
	// 827EF170: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF174: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF178: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF17C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 827EF180: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF184: 419A0018  beq cr6, 0x827ef19c
	if ctx.cr[6].eq {
	pc = 0x827EF19C; continue 'dispatch;
	}
	// 827EF188: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 827EF18C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 827EF190: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EF194: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827EF198: 409A0008  bne cr6, 0x827ef1a0
	if !ctx.cr[6].eq {
	pc = 0x827EF1A0; continue 'dispatch;
	}
	pc = 0x827EF19C; continue 'dispatch;
            }
            0x827EF19C => {
    //   block [0x827EF19C..0x827EF1A0)
	// 827EF19C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827EF1A0; continue 'dispatch;
            }
            0x827EF1A0 => {
    //   block [0x827EF1A0..0x827EF1EC)
	// 827EF1A0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827EF1A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF1A8: 419A0130  beq cr6, 0x827ef2d8
	if ctx.cr[6].eq {
	pc = 0x827EF2D8; continue 'dispatch;
	}
	// 827EF1AC: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 827EF1B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EF1B4: 55281FFE  rlwinm r8, r9, 3, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x1FFFFFFFu64;
	// 827EF1B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827EF1BC: 419A00F8  beq cr6, 0x827ef2b4
	if ctx.cr[6].eq {
	pc = 0x827EF2B4; continue 'dispatch;
	}
	// 827EF1C0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EF1C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF1C8: 419A0024  beq cr6, 0x827ef1ec
	if ctx.cr[6].eq {
	pc = 0x827EF1EC; continue 'dispatch;
	}
	// 827EF1CC: 892A005D  lbz r9, 0x5d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(93 as u32) ) } as u64;
	// 827EF1D0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF1D4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 827EF1D8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827EF1DC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF1E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827EF1E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF1E8: 480000D0  b 0x827ef2b8
	pc = 0x827EF2B8; continue 'dispatch;
            }
            0x827EF1EC => {
    //   block [0x827EF1EC..0x827EF20C)
	// 827EF1EC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF1F0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827EF1F4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EF1F8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827EF1FC: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EF200: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EF204: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF208: 40810054  ble 0x827ef25c
	if !ctx.cr[0].gt {
	pc = 0x827EF25C; continue 'dispatch;
	}
	pc = 0x827EF20C; continue 'dispatch;
            }
            0x827EF20C => {
    //   block [0x827EF20C..0x827EF22C)
	// 827EF20C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EF210: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EF214: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EF218: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF21C: 2F07005D  cmpwi cr6, r7, 0x5d
	ctx.cr[6].compare_i32(ctx.r[7].s32, 93, &mut ctx.xer);
	// 827EF220: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EF224: 41980008  blt cr6, 0x827ef22c
	if ctx.cr[6].lt {
	pc = 0x827EF22C; continue 'dispatch;
	}
	// 827EF228: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827EF22C; continue 'dispatch;
            }
            0x827EF22C => {
    //   block [0x827EF22C..0x827EF248)
	// 827EF22C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EF230: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EF234: 419A0014  beq cr6, 0x827ef248
	if ctx.cr[6].eq {
	pc = 0x827EF248; continue 'dispatch;
	}
	// 827EF238: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EF23C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EF240: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EF244: 4800000C  b 0x827ef250
	pc = 0x827EF250; continue 'dispatch;
            }
            0x827EF248 => {
    //   block [0x827EF248..0x827EF250)
	// 827EF248: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EF24C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EF250; continue 'dispatch;
            }
            0x827EF250 => {
    //   block [0x827EF250..0x827EF25C)
	// 827EF250: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF254: 4199FFB8  bgt cr6, 0x827ef20c
	if ctx.cr[6].gt {
	pc = 0x827EF20C; continue 'dispatch;
	}
	// 827EF258: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EF25C; continue 'dispatch;
            }
            0x827EF25C => {
    //   block [0x827EF25C..0x827EF278)
	// 827EF25C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EF260: 419A0040  beq cr6, 0x827ef2a0
	if ctx.cr[6].eq {
	pc = 0x827EF2A0; continue 'dispatch;
	}
	// 827EF264: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF268: 2F0B005D  cmpwi cr6, r11, 0x5d
	ctx.cr[6].compare_i32(ctx.r[11].s32, 93, &mut ctx.xer);
	// 827EF26C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF270: 41990008  bgt cr6, 0x827ef278
	if ctx.cr[6].gt {
	pc = 0x827EF278; continue 'dispatch;
	}
	// 827EF274: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EF278; continue 'dispatch;
            }
            0x827EF278 => {
    //   block [0x827EF278..0x827EF2A0)
	// 827EF278: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF27C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF280: 409A0020  bne cr6, 0x827ef2a0
	if !ctx.cr[6].eq {
	pc = 0x827EF2A0; continue 'dispatch;
	}
	// 827EF284: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EF288: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EF28C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EF290: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF294: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827EF298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF29C: 4800001C  b 0x827ef2b8
	pc = 0x827EF2B8; continue 'dispatch;
            }
            0x827EF2A0 => {
    //   block [0x827EF2A0..0x827EF2B4)
	// 827EF2A0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EF2A4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF2A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827EF2AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF2B0: 48000008  b 0x827ef2b8
	pc = 0x827EF2B8; continue 'dispatch;
            }
            0x827EF2B4 => {
    //   block [0x827EF2B4..0x827EF2B8)
	// 827EF2B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827EF2B8; continue 'dispatch;
            }
            0x827EF2B8 => {
    //   block [0x827EF2B8..0x827EF2D8)
	// 827EF2B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF2C0: 419A0018  beq cr6, 0x827ef2d8
	if ctx.cr[6].eq {
	pc = 0x827EF2D8; continue 'dispatch;
	}
	// 827EF2C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF2C8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 827EF2CC: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 827EF2D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EF2D4: 4E800421  bctrl
	ctx.lr = 0x827EF2D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827EF2D8 => {
    //   block [0x827EF2D8..0x827EF2E8)
	// 827EF2D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF2DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF2E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF2E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF2E8 size=60
    let mut pc: u32 = 0x827EF2E8;
    'dispatch: loop {
        match pc {
            0x827EF2E8 => {
    //   block [0x827EF2E8..0x827EF324)
	// 827EF2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF2F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EF2F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF2F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EF2FC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF300: 388B9CE4  addi r4, r11, -0x631c
	ctx.r[4].s64 = ctx.r[11].s64 + -25372;
	// 827EF304: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EF308: 4BA3DBC9  bl 0x8222ced0
	ctx.lr = 0x827EF30C;
	sub_8222CED0(ctx, base);
	// 827EF30C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF310: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF314: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF318: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF31C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EF320: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF328(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EF328 size=68
    let mut pc: u32 = 0x827EF328;
    'dispatch: loop {
        match pc {
            0x827EF328 => {
    //   block [0x827EF328..0x827EF354)
	// 827EF328: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF32C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF330: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF334: 480000BD  bl 0x827ef3f0
	ctx.lr = 0x827EF338;
	sub_827EF3F0(ctx, base);
	// 827EF338: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EF33C: 419A0018  beq cr6, 0x827ef354
	if ctx.cr[6].eq {
	pc = 0x827EF354; continue 'dispatch;
	}
	// 827EF340: 4BA4DFE1  bl 0x8223d320
	ctx.lr = 0x827EF344;
	sub_8223D320(ctx, base);
	// 827EF344: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF348: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF34C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF350: 4E800020  blr
	return;
            }
            0x827EF354 => {
    //   block [0x827EF354..0x827EF36C)
	// 827EF354: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827EF358: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827EF35C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF360: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF364: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827EF370 size=92
    let mut pc: u32 = 0x827EF370;
    'dispatch: loop {
        match pc {
            0x827EF370 => {
    //   block [0x827EF370..0x827EF3AC)
	// 827EF370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF374: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF378: DBC1FFE8  stfd f30, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[30].u64 ) };
	// 827EF37C: DBE1FFF0  stfd f31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[31].u64 ) };
	// 827EF380: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF384: 4800006D  bl 0x827ef3f0
	ctx.lr = 0x827EF388;
	sub_827EF3F0(ctx, base);
	// 827EF388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EF38C: 419A0020  beq cr6, 0x827ef3ac
	if ctx.cr[6].eq {
	pc = 0x827EF3AC; continue 'dispatch;
	}
	// 827EF390: C3E30018  lfs f31, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827EF394: C3C30014  lfs f30, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827EF398: 4BA4DF89  bl 0x8223d320
	ctx.lr = 0x827EF39C;
	sub_8223D320(ctx, base);
	// 827EF39C: EC01F028  fsubs f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[30].f64) as f32) as f64);
	// 827EF3A0: EDBFF028  fsubs f13, f31, f30
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 827EF3A4: EC206824  fdivs f1, f0, f13
	ctx.f[1].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 827EF3A8: 4800000C  b 0x827ef3b4
	pc = 0x827EF3B4; continue 'dispatch;
            }
            0x827EF3AC => {
    //   block [0x827EF3AC..0x827EF3B4)
	// 827EF3AC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827EF3B0: C02B92D4  lfs f1, -0x6d2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27948 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x827EF3B4; continue 'dispatch;
            }
            0x827EF3B4 => {
    //   block [0x827EF3B4..0x827EF3CC)
	// 827EF3B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EF3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF3C0: CBC1FFE8  lfd f30, -0x18(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EF3C4: CBE1FFF0  lfd f31, -0x10(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EF3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF3F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF3F0 size=664
    let mut pc: u32 = 0x827EF3F0;
    'dispatch: loop {
        match pc {
            0x827EF3F0 => {
    //   block [0x827EF3F0..0x827EF44C)
	// 827EF3F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF3F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF3F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EF3FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EF400: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF404: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF408: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827EF40C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 827EF410: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827EF414: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 827EF418: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827EF41C: 419A00F4  beq cr6, 0x827ef510
	if ctx.cr[6].eq {
	pc = 0x827EF510; continue 'dispatch;
	}
	// 827EF420: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EF424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF428: 419A0024  beq cr6, 0x827ef44c
	if ctx.cr[6].eq {
	pc = 0x827EF44C; continue 'dispatch;
	}
	// 827EF42C: 894A0061  lbz r10, 0x61(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(97 as u32) ) } as u64;
	// 827EF430: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF434: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827EF438: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EF43C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF440: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827EF444: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF448: 480000CC  b 0x827ef514
	pc = 0x827EF514; continue 'dispatch;
            }
            0x827EF44C => {
    //   block [0x827EF44C..0x827EF468)
	// 827EF44C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF450: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EF454: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827EF458: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EF45C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EF460: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF464: 40810054  ble 0x827ef4b8
	if !ctx.cr[0].gt {
	pc = 0x827EF4B8; continue 'dispatch;
	}
	pc = 0x827EF468; continue 'dispatch;
            }
            0x827EF468 => {
    //   block [0x827EF468..0x827EF488)
	// 827EF468: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EF46C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EF470: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EF474: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF478: 2F070061  cmpwi cr6, r7, 0x61
	ctx.cr[6].compare_i32(ctx.r[7].s32, 97, &mut ctx.xer);
	// 827EF47C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EF480: 41980008  blt cr6, 0x827ef488
	if ctx.cr[6].lt {
	pc = 0x827EF488; continue 'dispatch;
	}
	// 827EF484: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x827EF488; continue 'dispatch;
            }
            0x827EF488 => {
    //   block [0x827EF488..0x827EF4A4)
	// 827EF488: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EF48C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EF490: 419A0014  beq cr6, 0x827ef4a4
	if ctx.cr[6].eq {
	pc = 0x827EF4A4; continue 'dispatch;
	}
	// 827EF494: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EF498: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EF49C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EF4A0: 4800000C  b 0x827ef4ac
	pc = 0x827EF4AC; continue 'dispatch;
            }
            0x827EF4A4 => {
    //   block [0x827EF4A4..0x827EF4AC)
	// 827EF4A4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EF4A8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EF4AC; continue 'dispatch;
            }
            0x827EF4AC => {
    //   block [0x827EF4AC..0x827EF4B8)
	// 827EF4AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF4B0: 4199FFB8  bgt cr6, 0x827ef468
	if ctx.cr[6].gt {
	pc = 0x827EF468; continue 'dispatch;
	}
	// 827EF4B4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EF4B8; continue 'dispatch;
            }
            0x827EF4B8 => {
    //   block [0x827EF4B8..0x827EF4D4)
	// 827EF4B8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EF4BC: 419A0040  beq cr6, 0x827ef4fc
	if ctx.cr[6].eq {
	pc = 0x827EF4FC; continue 'dispatch;
	}
	// 827EF4C0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF4C4: 2F0B0061  cmpwi cr6, r11, 0x61
	ctx.cr[6].compare_i32(ctx.r[11].s32, 97, &mut ctx.xer);
	// 827EF4C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF4CC: 41990008  bgt cr6, 0x827ef4d4
	if ctx.cr[6].gt {
	pc = 0x827EF4D4; continue 'dispatch;
	}
	// 827EF4D0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827EF4D4; continue 'dispatch;
            }
            0x827EF4D4 => {
    //   block [0x827EF4D4..0x827EF4FC)
	// 827EF4D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF4D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF4DC: 409A0020  bne cr6, 0x827ef4fc
	if !ctx.cr[6].eq {
	pc = 0x827EF4FC; continue 'dispatch;
	}
	// 827EF4E0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EF4E4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EF4E8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EF4EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF4F0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827EF4F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF4F8: 4800001C  b 0x827ef514
	pc = 0x827EF514; continue 'dispatch;
            }
            0x827EF4FC => {
    //   block [0x827EF4FC..0x827EF510)
	// 827EF4FC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EF500: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF504: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827EF508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF50C: 48000008  b 0x827ef514
	pc = 0x827EF514; continue 'dispatch;
            }
            0x827EF510 => {
    //   block [0x827EF510..0x827EF514)
	// 827EF510: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827EF514; continue 'dispatch;
            }
            0x827EF514 => {
    //   block [0x827EF514..0x827EF544)
	// 827EF514: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF51C: 419A0150  beq cr6, 0x827ef66c
	if ctx.cr[6].eq {
	pc = 0x827EF66C; continue 'dispatch;
	}
	// 827EF520: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EF524: 4B984EED  bl 0x82174410
	ctx.lr = 0x827EF528;
	sub_82174410(ctx, base);
	// 827EF528: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EF52C: 419A0018  beq cr6, 0x827ef544
	if ctx.cr[6].eq {
	pc = 0x827EF544; continue 'dispatch;
	}
	// 827EF530: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 827EF534: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827EF538: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF53C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF540: 409A0008  bne cr6, 0x827ef548
	if !ctx.cr[6].eq {
	pc = 0x827EF548; continue 'dispatch;
	}
	pc = 0x827EF544; continue 'dispatch;
            }
            0x827EF544 => {
    //   block [0x827EF544..0x827EF548)
	// 827EF544: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827EF548; continue 'dispatch;
            }
            0x827EF548 => {
    //   block [0x827EF548..0x827EF598)
	// 827EF548: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF54C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF550: 419A011C  beq cr6, 0x827ef66c
	if ctx.cr[6].eq {
	pc = 0x827EF66C; continue 'dispatch;
	}
	// 827EF554: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EF558: 4B984EB9  bl 0x82174410
	ctx.lr = 0x827EF55C;
	sub_82174410(ctx, base);
	// 827EF55C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 827EF560: 556A3FFE  rlwinm r10, r11, 7, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x01FFFFFFu64;
	// 827EF564: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF568: 419A00F0  beq cr6, 0x827ef658
	if ctx.cr[6].eq {
	pc = 0x827EF658; continue 'dispatch;
	}
	// 827EF56C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EF570: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF578: 419A0020  beq cr6, 0x827ef598
	if ctx.cr[6].eq {
	pc = 0x827EF598; continue 'dispatch;
	}
	// 827EF57C: 896B0039  lbz r11, 0x39(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(57 as u32) ) } as u64;
	// 827EF580: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827EF584: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827EF588: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF58C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827EF590: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF594: 480000C8  b 0x827ef65c
	pc = 0x827EF65C; continue 'dispatch;
            }
            0x827EF598 => {
    //   block [0x827EF598..0x827EF5B0)
	// 827EF598: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EF59C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827EF5A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EF5A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EF5A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF5AC: 40810054  ble 0x827ef600
	if !ctx.cr[0].gt {
	pc = 0x827EF600; continue 'dispatch;
	}
	pc = 0x827EF5B0; continue 'dispatch;
            }
            0x827EF5B0 => {
    //   block [0x827EF5B0..0x827EF5D0)
	// 827EF5B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EF5B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EF5B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EF5BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF5C0: 2F070039  cmpwi cr6, r7, 0x39
	ctx.cr[6].compare_i32(ctx.r[7].s32, 57, &mut ctx.xer);
	// 827EF5C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EF5C8: 41980008  blt cr6, 0x827ef5d0
	if ctx.cr[6].lt {
	pc = 0x827EF5D0; continue 'dispatch;
	}
	// 827EF5CC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x827EF5D0; continue 'dispatch;
            }
            0x827EF5D0 => {
    //   block [0x827EF5D0..0x827EF5EC)
	// 827EF5D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EF5D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EF5D8: 419A0014  beq cr6, 0x827ef5ec
	if ctx.cr[6].eq {
	pc = 0x827EF5EC; continue 'dispatch;
	}
	// 827EF5DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EF5E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EF5E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EF5E8: 4800000C  b 0x827ef5f4
	pc = 0x827EF5F4; continue 'dispatch;
            }
            0x827EF5EC => {
    //   block [0x827EF5EC..0x827EF5F4)
	// 827EF5EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EF5F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EF5F4; continue 'dispatch;
            }
            0x827EF5F4 => {
    //   block [0x827EF5F4..0x827EF600)
	// 827EF5F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF5F8: 4199FFB8  bgt cr6, 0x827ef5b0
	if ctx.cr[6].gt {
	pc = 0x827EF5B0; continue 'dispatch;
	}
	// 827EF5FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EF600; continue 'dispatch;
            }
            0x827EF600 => {
    //   block [0x827EF600..0x827EF61C)
	// 827EF600: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EF604: 419A0040  beq cr6, 0x827ef644
	if ctx.cr[6].eq {
	pc = 0x827EF644; continue 'dispatch;
	}
	// 827EF608: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF60C: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 827EF610: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF614: 41990008  bgt cr6, 0x827ef61c
	if ctx.cr[6].gt {
	pc = 0x827EF61C; continue 'dispatch;
	}
	// 827EF618: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827EF61C; continue 'dispatch;
            }
            0x827EF61C => {
    //   block [0x827EF61C..0x827EF644)
	// 827EF61C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF624: 409A0020  bne cr6, 0x827ef644
	if !ctx.cr[6].eq {
	pc = 0x827EF644; continue 'dispatch;
	}
	// 827EF628: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EF62C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EF630: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EF634: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF638: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827EF63C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF640: 4800001C  b 0x827ef65c
	pc = 0x827EF65C; continue 'dispatch;
            }
            0x827EF644 => {
    //   block [0x827EF644..0x827EF658)
	// 827EF644: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EF648: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF64C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827EF650: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF654: 48000008  b 0x827ef65c
	pc = 0x827EF65C; continue 'dispatch;
            }
            0x827EF658 => {
    //   block [0x827EF658..0x827EF65C)
	// 827EF658: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827EF65C; continue 'dispatch;
            }
            0x827EF65C => {
    //   block [0x827EF65C..0x827EF66C)
	// 827EF65C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF660: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF668: 409A0008  bne cr6, 0x827ef670
	if !ctx.cr[6].eq {
	pc = 0x827EF670; continue 'dispatch;
	}
	pc = 0x827EF66C; continue 'dispatch;
            }
            0x827EF66C => {
    //   block [0x827EF66C..0x827EF670)
	// 827EF66C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827EF670; continue 'dispatch;
            }
            0x827EF670 => {
    //   block [0x827EF670..0x827EF688)
	// 827EF670: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EF674: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF678: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF67C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EF680: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EF684: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF688 size=320
    let mut pc: u32 = 0x827EF688;
    'dispatch: loop {
        match pc {
            0x827EF688 => {
    //   block [0x827EF688..0x827EF7C8)
	// 827EF688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF690: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827EF694: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827EF698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF69C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827EF6A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EF6A4: 3BCB9F30  addi r30, r11, -0x60d0
	ctx.r[30].s64 = ctx.r[11].s64 + -24784;
	// 827EF6A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF6AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF6B0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EF6B4: 4BA3D81D  bl 0x8222ced0
	ctx.lr = 0x827EF6B8;
	sub_8222CED0(ctx, base);
	// 827EF6B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF6BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EF6C0: 48000319  bl 0x827ef9d8
	ctx.lr = 0x827EF6C4;
	sub_827EF9D8(ctx, base);
	// 827EF6C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF6C8: 4BA25711  bl 0x82214dd8
	ctx.lr = 0x827EF6CC;
	sub_82214DD8(ctx, base);
	// 827EF6CC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 827EF6D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF6D4: 388ADF90  addi r4, r10, -0x2070
	ctx.r[4].s64 = ctx.r[10].s64 + -8304;
	// 827EF6D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF6DC: 4BA3D7F5  bl 0x8222ced0
	ctx.lr = 0x827EF6E0;
	sub_8222CED0(ctx, base);
	// 827EF6E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EF6E4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF6E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF6EC: 4BA3D7E5  bl 0x8222ced0
	ctx.lr = 0x827EF6F0;
	sub_8222CED0(ctx, base);
	// 827EF6F0: 3D20827F  lis r9, -0x7d81
	ctx.r[9].s64 = -2105606144;
	// 827EF6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF6F8: 38C9F328  addi r6, r9, -0xcd8
	ctx.r[6].s64 = ctx.r[9].s64 + -3288;
	// 827EF6FC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827EF700: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EF704: 4800051D  bl 0x827efc20
	ctx.lr = 0x827EF708;
	sub_827EFC20(ctx, base);
	// 827EF708: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF70C: 4BA256CD  bl 0x82214dd8
	ctx.lr = 0x827EF710;
	sub_82214DD8(ctx, base);
	// 827EF710: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF714: 4BA256C5  bl 0x82214dd8
	ctx.lr = 0x827EF718;
	sub_82214DD8(ctx, base);
	// 827EF718: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 827EF71C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF720: 3888E05C  addi r4, r8, -0x1fa4
	ctx.r[4].s64 = ctx.r[8].s64 + -8100;
	// 827EF724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF728: 4BA3D7A9  bl 0x8222ced0
	ctx.lr = 0x827EF72C;
	sub_8222CED0(ctx, base);
	// 827EF72C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EF730: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF734: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF738: 4BA3D799  bl 0x8222ced0
	ctx.lr = 0x827EF73C;
	sub_8222CED0(ctx, base);
	// 827EF73C: 3CE0827F  lis r7, -0x7d81
	ctx.r[7].s64 = -2105606144;
	// 827EF740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF744: 38C7F3D0  addi r6, r7, -0xc30
	ctx.r[6].s64 = ctx.r[7].s64 + -3120;
	// 827EF748: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EF74C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EF750: 480006D9  bl 0x827efe28
	ctx.lr = 0x827EF754;
	sub_827EFE28(ctx, base);
	// 827EF754: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF758: 4BA25681  bl 0x82214dd8
	ctx.lr = 0x827EF75C;
	sub_82214DD8(ctx, base);
	// 827EF75C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF760: 4BA25679  bl 0x82214dd8
	ctx.lr = 0x827EF764;
	sub_82214DD8(ctx, base);
	// 827EF764: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 827EF768: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF76C: 38863748  addi r4, r6, 0x3748
	ctx.r[4].s64 = ctx.r[6].s64 + 14152;
	// 827EF770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF774: 4BA3D75D  bl 0x8222ced0
	ctx.lr = 0x827EF778;
	sub_8222CED0(ctx, base);
	// 827EF778: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EF77C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF780: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF784: 4BA3D74D  bl 0x8222ced0
	ctx.lr = 0x827EF788;
	sub_8222CED0(ctx, base);
	// 827EF788: 3C80827F  lis r4, -0x7d81
	ctx.r[4].s64 = -2105606144;
	// 827EF78C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827EF790: 38C4F3E8  addi r6, r4, -0xc18
	ctx.r[6].s64 = ctx.r[4].s64 + -3096;
	// 827EF794: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827EF798: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827EF79C: 48000895  bl 0x827f0030
	ctx.lr = 0x827EF7A0;
	sub_827F0030(ctx, base);
	// 827EF7A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827EF7A4: 4BA25635  bl 0x82214dd8
	ctx.lr = 0x827EF7A8;
	sub_82214DD8(ctx, base);
	// 827EF7A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF7AC: 4BA2562D  bl 0x82214dd8
	ctx.lr = 0x827EF7B0;
	sub_82214DD8(ctx, base);
	// 827EF7B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827EF7B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF7B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF7BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827EF7C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827EF7C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF7C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF7C8 size=200
    let mut pc: u32 = 0x827EF7C8;
    'dispatch: loop {
        match pc {
            0x827EF7C8 => {
    //   block [0x827EF7C8..0x827EF838)
	// 827EF7C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF7CC: 484B9C41  bl 0x82ca940c
	ctx.lr = 0x827EF7D0;
	sub_82CA93D0(ctx, base);
	// 827EF7D0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF7D4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 827EF7D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EF7DC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EF7E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF7E4: 388BD4E4  addi r4, r11, -0x2b1c
	ctx.r[4].s64 = ctx.r[11].s64 + -11036;
	// 827EF7E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF7EC: 4BA3D6E5  bl 0x8222ced0
	ctx.lr = 0x827EF7F0;
	sub_8222CED0(ctx, base);
	// 827EF7F0: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 827EF7F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EF7F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF7FC: 4822D8AD  bl 0x82a1d0a8
	ctx.lr = 0x827EF800;
	sub_82A1D0A8(ctx, base);
	// 827EF800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF804: 4BA255D5  bl 0x82214dd8
	ctx.lr = 0x827EF808;
	sub_82214DD8(ctx, base);
	// 827EF808: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 827EF80C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF810: 388AD4EC  addi r4, r10, -0x2b14
	ctx.r[4].s64 = ctx.r[10].s64 + -11028;
	// 827EF814: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF818: 4BA3D6B9  bl 0x8222ced0
	ctx.lr = 0x827EF81C;
	sub_8222CED0(ctx, base);
	// 827EF81C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827EF820: 3BABFFDF  addi r29, r11, -0x21
	ctx.r[29].s64 = ctx.r[11].s64 + -33;
	// 827EF824: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EF828: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EF82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF830: 419A0008  beq cr6, 0x827ef838
	if ctx.cr[6].eq {
	pc = 0x827EF838; continue 'dispatch;
	}
	// 827EF834: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EF838; continue 'dispatch;
            }
            0x827EF838 => {
    //   block [0x827EF838..0x827EF874)
	// 827EF838: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 827EF83C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EF840: 4BC91011  bl 0x82480850
	ctx.lr = 0x827EF844;
	sub_82480850(ctx, base);
	// 827EF844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF848: 4BA25591  bl 0x82214dd8
	ctx.lr = 0x827EF84C;
	sub_82214DD8(ctx, base);
	// 827EF84C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 827EF850: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827EF854: 388BD4FC  addi r4, r11, -0x2b04
	ctx.r[4].s64 = ctx.r[11].s64 + -11012;
	// 827EF858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF85C: 4BA3D675  bl 0x8222ced0
	ctx.lr = 0x827EF860;
	sub_8222CED0(ctx, base);
	// 827EF860: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EF864: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827EF868: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF86C: 419A0008  beq cr6, 0x827ef874
	if ctx.cr[6].eq {
	pc = 0x827EF874; continue 'dispatch;
	}
	// 827EF870: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EF874; continue 'dispatch;
            }
            0x827EF874 => {
    //   block [0x827EF874..0x827EF890)
	// 827EF874: 38BF0024  addi r5, r31, 0x24
	ctx.r[5].s64 = ctx.r[31].s64 + 36;
	// 827EF878: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EF87C: 4BC90F4D  bl 0x824807c8
	ctx.lr = 0x827EF880;
	sub_824807C8(ctx, base);
	// 827EF880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EF884: 4BA25555  bl 0x82214dd8
	ctx.lr = 0x827EF888;
	sub_82214DD8(ctx, base);
	// 827EF888: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827EF88C: 484B9BD0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF890 size=324
    let mut pc: u32 = 0x827EF890;
    'dispatch: loop {
        match pc {
            0x827EF890 => {
    //   block [0x827EF890..0x827EF8E0)
	// 827EF890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF894: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827EF898: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF89C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF8A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827EF8A4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827EF8A8: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 827EF8AC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827EF8B0: 419A00F4  beq cr6, 0x827ef9a4
	if ctx.cr[6].eq {
	pc = 0x827EF9A4; continue 'dispatch;
	}
	// 827EF8B4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827EF8B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827EF8BC: 419A0024  beq cr6, 0x827ef8e0
	if ctx.cr[6].eq {
	pc = 0x827EF8E0; continue 'dispatch;
	}
	// 827EF8C0: 894A0074  lbz r10, 0x74(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 827EF8C4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF8C8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827EF8CC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827EF8D0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF8D4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EF8D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF8DC: 480000CC  b 0x827ef9a8
	pc = 0x827EF9A8; continue 'dispatch;
            }
            0x827EF8E0 => {
    //   block [0x827EF8E0..0x827EF8FC)
	// 827EF8E0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827EF8E4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827EF8E8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827EF8EC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827EF8F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827EF8F4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF8F8: 40810054  ble 0x827ef94c
	if !ctx.cr[0].gt {
	pc = 0x827EF94C; continue 'dispatch;
	}
	pc = 0x827EF8FC; continue 'dispatch;
            }
            0x827EF8FC => {
    //   block [0x827EF8FC..0x827EF91C)
	// 827EF8FC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827EF900: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827EF904: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827EF908: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF90C: 2F070074  cmpwi cr6, r7, 0x74
	ctx.cr[6].compare_i32(ctx.r[7].s32, 116, &mut ctx.xer);
	// 827EF910: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827EF914: 41980008  blt cr6, 0x827ef91c
	if ctx.cr[6].lt {
	pc = 0x827EF91C; continue 'dispatch;
	}
	// 827EF918: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x827EF91C; continue 'dispatch;
            }
            0x827EF91C => {
    //   block [0x827EF91C..0x827EF938)
	// 827EF91C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827EF920: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827EF924: 419A0014  beq cr6, 0x827ef938
	if ctx.cr[6].eq {
	pc = 0x827EF938; continue 'dispatch;
	}
	// 827EF928: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827EF92C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827EF930: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EF934: 4800000C  b 0x827ef940
	pc = 0x827EF940; continue 'dispatch;
            }
            0x827EF938 => {
    //   block [0x827EF938..0x827EF940)
	// 827EF938: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827EF93C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827EF940; continue 'dispatch;
            }
            0x827EF940 => {
    //   block [0x827EF940..0x827EF94C)
	// 827EF940: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EF944: 4199FFB8  bgt cr6, 0x827ef8fc
	if ctx.cr[6].gt {
	pc = 0x827EF8FC; continue 'dispatch;
	}
	// 827EF948: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827EF94C; continue 'dispatch;
            }
            0x827EF94C => {
    //   block [0x827EF94C..0x827EF968)
	// 827EF94C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827EF950: 419A0040  beq cr6, 0x827ef990
	if ctx.cr[6].eq {
	pc = 0x827EF990; continue 'dispatch;
	}
	// 827EF954: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF958: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 827EF95C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF960: 41990008  bgt cr6, 0x827ef968
	if ctx.cr[6].gt {
	pc = 0x827EF968; continue 'dispatch;
	}
	// 827EF964: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x827EF968; continue 'dispatch;
            }
            0x827EF968 => {
    //   block [0x827EF968..0x827EF990)
	// 827EF968: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF96C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF970: 409A0020  bne cr6, 0x827ef990
	if !ctx.cr[6].eq {
	pc = 0x827EF990; continue 'dispatch;
	}
	// 827EF974: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827EF978: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827EF97C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827EF980: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF984: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EF988: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF98C: 4800001C  b 0x827ef9a8
	pc = 0x827EF9A8; continue 'dispatch;
            }
            0x827EF990 => {
    //   block [0x827EF990..0x827EF9A4)
	// 827EF990: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827EF994: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EF998: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827EF99C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF9A0: 48000008  b 0x827ef9a8
	pc = 0x827EF9A8; continue 'dispatch;
            }
            0x827EF9A4 => {
    //   block [0x827EF9A4..0x827EF9A8)
	// 827EF9A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x827EF9A8; continue 'dispatch;
            }
            0x827EF9A8 => {
    //   block [0x827EF9A8..0x827EF9C4)
	// 827EF9A8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827EF9AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF9B0: 419A0014  beq cr6, 0x827ef9c4
	if ctx.cr[6].eq {
	pc = 0x827EF9C4; continue 'dispatch;
	}
	// 827EF9B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827EF9B8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827EF9BC: 99630010  stb r11, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u8 ) };
	// 827EF9C0: 4BE02B59  bl 0x825f2518
	ctx.lr = 0x827EF9C4;
	sub_825F2518(ctx, base);
	pc = 0x827EF9C4; continue 'dispatch;
            }
            0x827EF9C4 => {
    //   block [0x827EF9C4..0x827EF9D4)
	// 827EF9C4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827EF9C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827EF9CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827EF9D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EF9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EF9D8 size=584
    let mut pc: u32 = 0x827EF9D8;
    'dispatch: loop {
        match pc {
            0x827EF9D8 => {
    //   block [0x827EF9D8..0x827EFA00)
	// 827EF9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EF9DC: 484B9A25  bl 0x82ca9400
	ctx.lr = 0x827EF9E0;
	sub_82CA93D0(ctx, base);
	// 827EF9E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EF9E4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EF9E8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827EF9EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EF9F0: 409A0010  bne cr6, 0x827efa00
	if !ctx.cr[6].eq {
	pc = 0x827EFA00; continue 'dispatch;
	}
	// 827EF9F4: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827EF9F8: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 827EF9FC: 48000008  b 0x827efa04
	pc = 0x827EFA04; continue 'dispatch;
            }
            0x827EFA00 => {
    //   block [0x827EFA00..0x827EFA04)
	// 827EFA00: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EFA04; continue 'dispatch;
            }
            0x827EFA04 => {
    //   block [0x827EFA04..0x827EFA7C)
	// 827EFA04: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFA08: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFA0C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFA10: 4BBDEBB1  bl 0x823ce5c0
	ctx.lr = 0x827EFA14;
	sub_823CE5C0(ctx, base);
	// 827EFA14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EFA18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFA1C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFA20: 4BBDE7E1  bl 0x823ce200
	ctx.lr = 0x827EFA24;
	sub_823CE200(ctx, base);
	// 827EFA24: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFA28: 4B9C80F1  bl 0x821b7b18
	ctx.lr = 0x827EFA2C;
	sub_821B7B18(ctx, base);
	// 827EFA2C: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 827EFA30: 4BA2F829  bl 0x8221f258
	ctx.lr = 0x827EFA34;
	sub_8221F258(ctx, base);
	// 827EFA34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EFA38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EFA3C: 419A0040  beq cr6, 0x827efa7c
	if ctx.cr[6].eq {
	pc = 0x827EFA7C; continue 'dispatch;
	}
	// 827EFA40: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 827EFA44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EFA48: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 827EFA4C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EFA50: 4BA2F809  bl 0x8221f258
	ctx.lr = 0x827EFA54;
	sub_8221F258(ctx, base);
	// 827EFA54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EFA58: 419A0028  beq cr6, 0x827efa80
	if ctx.cr[6].eq {
	pc = 0x827EFA80; continue 'dispatch;
	}
	// 827EFA5C: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EFA60: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827EFA64: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EFA68: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EFA6C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EFA70: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827EFA74: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EFA78: 4800000C  b 0x827efa84
	pc = 0x827EFA84; continue 'dispatch;
            }
            0x827EFA7C => {
    //   block [0x827EFA7C..0x827EFA80)
	// 827EFA7C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EFA80; continue 'dispatch;
            }
            0x827EFA80 => {
    //   block [0x827EFA80..0x827EFA84)
	// 827EFA80: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EFA84; continue 'dispatch;
            }
            0x827EFA84 => {
    //   block [0x827EFA84..0x827EFB88)
	// 827EFA84: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827EFA88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EFA8C: 419A00FC  beq cr6, 0x827efb88
	if ctx.cr[6].eq {
	pc = 0x827EFB88; continue 'dispatch;
	}
	// 827EFA90: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFA94: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EFA98: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFA9C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EFAA0: 4BA39669  bl 0x82229108
	ctx.lr = 0x827EFAA4;
	sub_82229108(ctx, base);
	// 827EFAA4: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EFAA8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EFAAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EFAB0: 3BCB0238  addi r30, r11, 0x238
	ctx.r[30].s64 = ctx.r[11].s64 + 568;
	// 827EFAB4: 4BA37DCD  bl 0x82227880
	ctx.lr = 0x827EFAB8;
	sub_82227880(ctx, base);
	// 827EFAB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EFABC: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 827EFAC0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EFAC4: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 827EFAC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EFACC: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827EFAD0: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EFAD4: 4B9AAFAD  bl 0x8219aa80
	ctx.lr = 0x827EFAD8;
	sub_8219AA80(ctx, base);
	// 827EFAD8: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 827EFADC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827EFAE0: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 827EFAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFAE8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EFAEC: 4BBDE935  bl 0x823ce420
	ctx.lr = 0x827EFAF0;
	sub_823CE420(ctx, base);
	// 827EFAF0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827EFAF4: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EFAF8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827EFAFC: 48234BCD  bl 0x82a246c8
	ctx.lr = 0x827EFB00;
	sub_82A246C8(ctx, base);
	// 827EFB00: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFB04: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EFB08: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 827EFB0C: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 827EFB10: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFB14: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFB18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EFB1C: 4BA395ED  bl 0x82229108
	ctx.lr = 0x827EFB20;
	sub_82229108(ctx, base);
	// 827EFB20: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EFB24: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EFB28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EFB2C: 3BEB0278  addi r31, r11, 0x278
	ctx.r[31].s64 = ctx.r[11].s64 + 632;
	// 827EFB30: 4BA37D51  bl 0x82227880
	ctx.lr = 0x827EFB34;
	sub_82227880(ctx, base);
	// 827EFB34: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827EFB38: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 827EFB3C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EFB40: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 827EFB44: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EFB48: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827EFB4C: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827EFB50: 4B9AAF31  bl 0x8219aa80
	ctx.lr = 0x827EFB54;
	sub_8219AA80(ctx, base);
	// 827EFB54: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 827EFB58: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EFB5C: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 827EFB60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFB64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFB68: 4BBDE8B9  bl 0x823ce420
	ctx.lr = 0x827EFB6C;
	sub_823CE420(ctx, base);
	// 827EFB6C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFB70: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EFB74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827EFB78: 48234B51  bl 0x82a246c8
	ctx.lr = 0x827EFB7C;
	sub_82A246C8(ctx, base);
	// 827EFB7C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFB80: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 827EFB84: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x827EFB88; continue 'dispatch;
            }
            0x827EFB88 => {
    //   block [0x827EFB88..0x827EFB98)
	// 827EFB88: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 827EFB8C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827EFB90: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 827EFB94: 419A0020  beq cr6, 0x827efbb4
	if ctx.cr[6].eq {
	pc = 0x827EFBB4; continue 'dispatch;
	}
	pc = 0x827EFB98; continue 'dispatch;
            }
            0x827EFB98 => {
    //   block [0x827EFB98..0x827EFBB4)
	// 827EFB98: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFB9C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFBA0: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFBA4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EFBA8: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFBAC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFBB0: 4082FFE8  bne 0x827efb98
	if !ctx.cr[0].eq {
	pc = 0x827EFB98; continue 'dispatch;
	}
	pc = 0x827EFBB4; continue 'dispatch;
            }
            0x827EFBB4 => {
    //   block [0x827EFBB4..0x827EFBD4)
	// 827EFBB4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFBB8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827EFBBC: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EFBC0: 4BB05D89  bl 0x822f5948
	ctx.lr = 0x827EFBC4;
	sub_822F5948(ctx, base);
	// 827EFBC4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFBC8: 4B9C7F51  bl 0x821b7b18
	ctx.lr = 0x827EFBCC;
	sub_821B7B18(ctx, base);
	// 827EFBCC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827EFBD0: 419A0040  beq cr6, 0x827efc10
	if ctx.cr[6].eq {
	pc = 0x827EFC10; continue 'dispatch;
	}
	pc = 0x827EFBD4; continue 'dispatch;
            }
            0x827EFBD4 => {
    //   block [0x827EFBD4..0x827EFC10)
	// 827EFBD4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFBD8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFBDC: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFBE0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EFBE4: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFBE8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFBEC: 4082FFE8  bne 0x827efbd4
	if !ctx.cr[0].eq {
	pc = 0x827EFBD4; continue 'dispatch;
	}
	// 827EFBF0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EFBF4: 409A001C  bne cr6, 0x827efc10
	if !ctx.cr[6].eq {
	pc = 0x827EFC10; continue 'dispatch;
	}
	// 827EFBF8: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFBFC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFC00: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EFC04: 4E800421  bctrl
	ctx.lr = 0x827EFC08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EFC08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827EFC0C: 4BA2C12D  bl 0x8221bd38
	ctx.lr = 0x827EFC10;
	sub_8221BD38(ctx, base);
            }
            0x827EFC10 => {
    //   block [0x827EFC10..0x827EFC20)
	// 827EFC10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFC14: 4B9C7F05  bl 0x821b7b18
	ctx.lr = 0x827EFC18;
	sub_821B7B18(ctx, base);
	// 827EFC18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827EFC1C: 484B9834  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EFC20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EFC20 size=516
    let mut pc: u32 = 0x827EFC20;
    'dispatch: loop {
        match pc {
            0x827EFC20 => {
    //   block [0x827EFC20..0x827EFC5C)
	// 827EFC20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EFC24: 484B97D9  bl 0x82ca93fc
	ctx.lr = 0x827EFC28;
	sub_82CA93D0(ctx, base);
	// 827EFC28: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EFC2C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EFC30: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 827EFC34: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 827EFC38: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 827EFC3C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827EFC40: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFC44: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827EFC48: 3BAAF328  addi r29, r10, -0xcd8
	ctx.r[29].s64 = ctx.r[10].s64 + -3288;
	// 827EFC4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFC50: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EFC54: 419A0008  beq cr6, 0x827efc5c
	if ctx.cr[6].eq {
	pc = 0x827EFC5C; continue 'dispatch;
	}
	// 827EFC58: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EFC5C; continue 'dispatch;
            }
            0x827EFC5C => {
    //   block [0x827EFC5C..0x827EFCF0)
	// 827EFC5C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFC60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFC64: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFC68: 4BBDE959  bl 0x823ce5c0
	ctx.lr = 0x827EFC6C;
	sub_823CE5C0(ctx, base);
	// 827EFC6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EFC70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFC74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFC78: 4BBDE499  bl 0x823ce110
	ctx.lr = 0x827EFC7C;
	sub_823CE110(ctx, base);
	// 827EFC7C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFC80: 4B9C7E99  bl 0x821b7b18
	ctx.lr = 0x827EFC84;
	sub_821B7B18(ctx, base);
	// 827EFC84: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827EFC88: 4BA2F5D1  bl 0x8221f258
	ctx.lr = 0x827EFC8C;
	sub_8221F258(ctx, base);
	// 827EFC8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EFC90: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EFC94: 419A005C  beq cr6, 0x827efcf0
	if ctx.cr[6].eq {
	pc = 0x827EFCF0; continue 'dispatch;
	}
	// 827EFC98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EFC9C: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827EFCA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EFCA4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 827EFCA8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827EFCAC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EFCB0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827EFCB4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EFCB8: 4BA00589  bl 0x821f0240
	ctx.lr = 0x827EFCBC;
	sub_821F0240(ctx, base);
	// 827EFCBC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EFCC0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827EFCC4: 4BA2F595  bl 0x8221f258
	ctx.lr = 0x827EFCC8;
	sub_8221F258(ctx, base);
	// 827EFCC8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EFCCC: 419A0028  beq cr6, 0x827efcf4
	if ctx.cr[6].eq {
	pc = 0x827EFCF4; continue 'dispatch;
	}
	// 827EFCD0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EFCD4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 827EFCD8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EFCDC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EFCE0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EFCE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EFCE8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EFCEC: 4800000C  b 0x827efcf8
	pc = 0x827EFCF8; continue 'dispatch;
            }
            0x827EFCF0 => {
    //   block [0x827EFCF0..0x827EFCF4)
	// 827EFCF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EFCF4; continue 'dispatch;
            }
            0x827EFCF4 => {
    //   block [0x827EFCF4..0x827EFCF8)
	// 827EFCF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EFCF8; continue 'dispatch;
            }
            0x827EFCF8 => {
    //   block [0x827EFCF8..0x827EFD0C)
	// 827EFCF8: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFCFC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EFD00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFD04: 419A0008  beq cr6, 0x827efd0c
	if ctx.cr[6].eq {
	pc = 0x827EFD0C; continue 'dispatch;
	}
	// 827EFD08: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EFD0C; continue 'dispatch;
            }
            0x827EFD0C => {
    //   block [0x827EFD0C..0x827EFD8C)
	// 827EFD0C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827EFD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFD14: 419A0078  beq cr6, 0x827efd8c
	if ctx.cr[6].eq {
	pc = 0x827EFD8C; continue 'dispatch;
	}
	// 827EFD18: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFD1C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EFD20: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFD24: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFD28: 4BA393E1  bl 0x82229108
	ctx.lr = 0x827EFD2C;
	sub_82229108(ctx, base);
	// 827EFD2C: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EFD30: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EFD34: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFD38: 3BCB0280  addi r30, r11, 0x280
	ctx.r[30].s64 = ctx.r[11].s64 + 640;
	// 827EFD3C: 4BA37B45  bl 0x82227880
	ctx.lr = 0x827EFD40;
	sub_82227880(ctx, base);
	// 827EFD40: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EFD44: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 827EFD48: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EFD4C: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 827EFD50: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFD54: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827EFD58: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EFD5C: 4B9AAD25  bl 0x8219aa80
	ctx.lr = 0x827EFD60;
	sub_8219AA80(ctx, base);
	// 827EFD60: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFD64: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EFD68: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFD6C: 4BBDE6B5  bl 0x823ce420
	ctx.lr = 0x827EFD70;
	sub_823CE420(ctx, base);
	// 827EFD70: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFD74: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EFD78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFD7C: 4823494D  bl 0x82a246c8
	ctx.lr = 0x827EFD80;
	sub_82A246C8(ctx, base);
	// 827EFD80: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFD84: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 827EFD88: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x827EFD8C; continue 'dispatch;
            }
            0x827EFD8C => {
    //   block [0x827EFD8C..0x827EFD9C)
	// 827EFD8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827EFD90: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EFD94: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827EFD98: 419A0020  beq cr6, 0x827efdb8
	if ctx.cr[6].eq {
	pc = 0x827EFDB8; continue 'dispatch;
	}
	pc = 0x827EFD9C; continue 'dispatch;
            }
            0x827EFD9C => {
    //   block [0x827EFD9C..0x827EFDB8)
	// 827EFD9C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFDA0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFDA4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFDA8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EFDAC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFDB0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFDB4: 4082FFE8  bne 0x827efd9c
	if !ctx.cr[0].eq {
	pc = 0x827EFD9C; continue 'dispatch;
	}
	pc = 0x827EFDB8; continue 'dispatch;
            }
            0x827EFDB8 => {
    //   block [0x827EFDB8..0x827EFDD8)
	// 827EFDB8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFDBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EFDC0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EFDC4: 4BB05B85  bl 0x822f5948
	ctx.lr = 0x827EFDC8;
	sub_822F5948(ctx, base);
	// 827EFDC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFDCC: 4B9C7D4D  bl 0x821b7b18
	ctx.lr = 0x827EFDD0;
	sub_821B7B18(ctx, base);
	// 827EFDD0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EFDD4: 419A0040  beq cr6, 0x827efe14
	if ctx.cr[6].eq {
	pc = 0x827EFE14; continue 'dispatch;
	}
	pc = 0x827EFDD8; continue 'dispatch;
            }
            0x827EFDD8 => {
    //   block [0x827EFDD8..0x827EFE14)
	// 827EFDD8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFDDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFDE0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFDE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EFDE8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFDEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFDF0: 4082FFE8  bne 0x827efdd8
	if !ctx.cr[0].eq {
	pc = 0x827EFDD8; continue 'dispatch;
	}
	// 827EFDF4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827EFDF8: 409A001C  bne cr6, 0x827efe14
	if !ctx.cr[6].eq {
	pc = 0x827EFE14; continue 'dispatch;
	}
	// 827EFDFC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFE00: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFE04: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827EFE08: 4E800421  bctrl
	ctx.lr = 0x827EFE0C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827EFE0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827EFE10: 4BA2BF29  bl 0x8221bd38
	ctx.lr = 0x827EFE14;
	sub_8221BD38(ctx, base);
            }
            0x827EFE14 => {
    //   block [0x827EFE14..0x827EFE24)
	// 827EFE14: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFE18: 4B9C7D01  bl 0x821b7b18
	ctx.lr = 0x827EFE1C;
	sub_821B7B18(ctx, base);
	// 827EFE1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827EFE20: 484B962C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827EFE28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827EFE28 size=516
    let mut pc: u32 = 0x827EFE28;
    'dispatch: loop {
        match pc {
            0x827EFE28 => {
    //   block [0x827EFE28..0x827EFE64)
	// 827EFE28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827EFE2C: 484B95D1  bl 0x82ca93fc
	ctx.lr = 0x827EFE30;
	sub_82CA93D0(ctx, base);
	// 827EFE30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827EFE34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827EFE38: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 827EFE3C: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 827EFE40: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 827EFE44: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827EFE48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFE4C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827EFE50: 3BAAF3D0  addi r29, r10, -0xc30
	ctx.r[29].s64 = ctx.r[10].s64 + -3120;
	// 827EFE54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFE58: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EFE5C: 419A0008  beq cr6, 0x827efe64
	if ctx.cr[6].eq {
	pc = 0x827EFE64; continue 'dispatch;
	}
	// 827EFE60: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EFE64; continue 'dispatch;
            }
            0x827EFE64 => {
    //   block [0x827EFE64..0x827EFEF8)
	// 827EFE64: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFE68: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFE6C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFE70: 4BBDE751  bl 0x823ce5c0
	ctx.lr = 0x827EFE74;
	sub_823CE5C0(ctx, base);
	// 827EFE74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827EFE78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFE7C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFE80: 4BBDE291  bl 0x823ce110
	ctx.lr = 0x827EFE84;
	sub_823CE110(ctx, base);
	// 827EFE84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827EFE88: 4B9C7C91  bl 0x821b7b18
	ctx.lr = 0x827EFE8C;
	sub_821B7B18(ctx, base);
	// 827EFE8C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827EFE90: 4BA2F3C9  bl 0x8221f258
	ctx.lr = 0x827EFE94;
	sub_8221F258(ctx, base);
	// 827EFE94: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827EFE98: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827EFE9C: 419A005C  beq cr6, 0x827efef8
	if ctx.cr[6].eq {
	pc = 0x827EFEF8; continue 'dispatch;
	}
	// 827EFEA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827EFEA4: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827EFEA8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827EFEAC: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 827EFEB0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827EFEB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827EFEB8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827EFEBC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827EFEC0: 4BA00381  bl 0x821f0240
	ctx.lr = 0x827EFEC4;
	sub_821F0240(ctx, base);
	// 827EFEC4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827EFEC8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827EFECC: 4BA2F38D  bl 0x8221f258
	ctx.lr = 0x827EFED0;
	sub_8221F258(ctx, base);
	// 827EFED0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827EFED4: 419A0028  beq cr6, 0x827efefc
	if ctx.cr[6].eq {
	pc = 0x827EFEFC; continue 'dispatch;
	}
	// 827EFED8: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827EFEDC: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 827EFEE0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827EFEE4: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827EFEE8: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827EFEEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827EFEF0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827EFEF4: 4800000C  b 0x827eff00
	pc = 0x827EFF00; continue 'dispatch;
            }
            0x827EFEF8 => {
    //   block [0x827EFEF8..0x827EFEFC)
	// 827EFEF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827EFEFC; continue 'dispatch;
            }
            0x827EFEFC => {
    //   block [0x827EFEFC..0x827EFF00)
	// 827EFEFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827EFF00; continue 'dispatch;
            }
            0x827EFF00 => {
    //   block [0x827EFF00..0x827EFF14)
	// 827EFF00: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFF04: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827EFF08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFF0C: 419A0008  beq cr6, 0x827eff14
	if ctx.cr[6].eq {
	pc = 0x827EFF14; continue 'dispatch;
	}
	// 827EFF10: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827EFF14; continue 'dispatch;
            }
            0x827EFF14 => {
    //   block [0x827EFF14..0x827EFF94)
	// 827EFF14: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827EFF18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827EFF1C: 419A0078  beq cr6, 0x827eff94
	if ctx.cr[6].eq {
	pc = 0x827EFF94; continue 'dispatch;
	}
	// 827EFF20: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827EFF24: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827EFF28: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFF2C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFF30: 4BA391D9  bl 0x82229108
	ctx.lr = 0x827EFF34;
	sub_82229108(ctx, base);
	// 827EFF34: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827EFF38: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827EFF3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFF40: 3BCB0400  addi r30, r11, 0x400
	ctx.r[30].s64 = ctx.r[11].s64 + 1024;
	// 827EFF44: 4BA3793D  bl 0x82227880
	ctx.lr = 0x827EFF48;
	sub_82227880(ctx, base);
	// 827EFF48: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827EFF4C: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 827EFF50: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827EFF54: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 827EFF58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFF5C: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827EFF60: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827EFF64: 4B9AAB1D  bl 0x8219aa80
	ctx.lr = 0x827EFF68;
	sub_8219AA80(ctx, base);
	// 827EFF68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFF6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827EFF70: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827EFF74: 4BBDE4AD  bl 0x823ce420
	ctx.lr = 0x827EFF78;
	sub_823CE420(ctx, base);
	// 827EFF78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827EFF7C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827EFF80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827EFF84: 48234745  bl 0x82a246c8
	ctx.lr = 0x827EFF88;
	sub_82A246C8(ctx, base);
	// 827EFF88: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827EFF8C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 827EFF90: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x827EFF94; continue 'dispatch;
            }
            0x827EFF94 => {
    //   block [0x827EFF94..0x827EFFA4)
	// 827EFF94: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827EFF98: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EFF9C: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827EFFA0: 419A0020  beq cr6, 0x827effc0
	if ctx.cr[6].eq {
	pc = 0x827EFFC0; continue 'dispatch;
	}
	pc = 0x827EFFA4; continue 'dispatch;
            }
            0x827EFFA4 => {
    //   block [0x827EFFA4..0x827EFFC0)
	// 827EFFA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFFA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFFAC: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFFB0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827EFFB4: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFFB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFFBC: 4082FFE8  bne 0x827effa4
	if !ctx.cr[0].eq {
	pc = 0x827EFFA4; continue 'dispatch;
	}
	pc = 0x827EFFC0; continue 'dispatch;
            }
            0x827EFFC0 => {
    //   block [0x827EFFC0..0x827EFFE0)
	// 827EFFC0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827EFFC4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827EFFC8: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827EFFCC: 4BB0597D  bl 0x822f5948
	ctx.lr = 0x827EFFD0;
	sub_822F5948(ctx, base);
	// 827EFFD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827EFFD4: 4B9C7B45  bl 0x821b7b18
	ctx.lr = 0x827EFFD8;
	sub_821B7B18(ctx, base);
	// 827EFFD8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827EFFDC: 419A0040  beq cr6, 0x827f001c
	if ctx.cr[6].eq {
	pc = 0x827F001C; continue 'dispatch;
	}
	pc = 0x827EFFE0; continue 'dispatch;
            }
            0x827EFFE0 => {
    //   block [0x827EFFE0..0x827F001C)
	// 827EFFE0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827EFFE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFFE8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827EFFEC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827EFFF0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827EFFF4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827EFFF8: 4082FFE8  bne 0x827effe0
	if !ctx.cr[0].eq {
	pc = 0x827EFFE0; continue 'dispatch;
	}
	// 827EFFFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F0000: 409A001C  bne cr6, 0x827f001c
	if !ctx.cr[6].eq {
	pc = 0x827F001C; continue 'dispatch;
	}
	// 827F0004: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0008: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F000C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827F0010: 4E800421  bctrl
	ctx.lr = 0x827F0014;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0014: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F0018: 4BA2BD21  bl 0x8221bd38
	ctx.lr = 0x827F001C;
	sub_8221BD38(ctx, base);
            }
            0x827F001C => {
    //   block [0x827F001C..0x827F002C)
	// 827F001C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F0020: 4B9C7AF9  bl 0x821b7b18
	ctx.lr = 0x827F0024;
	sub_821B7B18(ctx, base);
	// 827F0024: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F0028: 484B9424  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0030 size=516
    let mut pc: u32 = 0x827F0030;
    'dispatch: loop {
        match pc {
            0x827F0030 => {
    //   block [0x827F0030..0x827F006C)
	// 827F0030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0034: 484B93C9  bl 0x82ca93fc
	ctx.lr = 0x827F0038;
	sub_82CA93D0(ctx, base);
	// 827F0038: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F003C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F0040: 3D208209  lis r9, -0x7df7
	ctx.r[9].s64 = -2113339392;
	// 827F0044: 3D40827F  lis r10, -0x7d81
	ctx.r[10].s64 = -2105606144;
	// 827F0048: 3B69FFDF  addi r27, r9, -0x21
	ctx.r[27].s64 = ctx.r[9].s64 + -33;
	// 827F004C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827F0050: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0054: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827F0058: 3BAAF3E8  addi r29, r10, -0xc18
	ctx.r[29].s64 = ctx.r[10].s64 + -3096;
	// 827F005C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0060: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827F0064: 419A0008  beq cr6, 0x827f006c
	if ctx.cr[6].eq {
	pc = 0x827F006C; continue 'dispatch;
	}
	// 827F0068: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F006C; continue 'dispatch;
            }
            0x827F006C => {
    //   block [0x827F006C..0x827F0100)
	// 827F006C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0070: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F0074: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0078: 4BBDE549  bl 0x823ce5c0
	ctx.lr = 0x827F007C;
	sub_823CE5C0(ctx, base);
	// 827F007C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F0080: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F0084: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F0088: 4BBDE089  bl 0x823ce110
	ctx.lr = 0x827F008C;
	sub_823CE110(ctx, base);
	// 827F008C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F0090: 4B9C7A89  bl 0x821b7b18
	ctx.lr = 0x827F0094;
	sub_821B7B18(ctx, base);
	// 827F0094: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F0098: 4BA2F1C1  bl 0x8221f258
	ctx.lr = 0x827F009C;
	sub_8221F258(ctx, base);
	// 827F009C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F00A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827F00A4: 419A005C  beq cr6, 0x827f0100
	if ctx.cr[6].eq {
	pc = 0x827F0100; continue 'dispatch;
	}
	// 827F00A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827F00AC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 827F00B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F00B4: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 827F00B8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F00BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F00C0: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F00C4: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827F00C8: 4BA00179  bl 0x821f0240
	ctx.lr = 0x827F00CC;
	sub_821F0240(ctx, base);
	// 827F00CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F00D0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827F00D4: 4BA2F185  bl 0x8221f258
	ctx.lr = 0x827F00D8;
	sub_8221F258(ctx, base);
	// 827F00D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F00DC: 419A0028  beq cr6, 0x827f0104
	if ctx.cr[6].eq {
	pc = 0x827F0104; continue 'dispatch;
	}
	// 827F00E0: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 827F00E4: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 827F00E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F00EC: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 827F00F0: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F00F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F00F8: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F00FC: 4800000C  b 0x827f0108
	pc = 0x827F0108; continue 'dispatch;
            }
            0x827F0100 => {
    //   block [0x827F0100..0x827F0104)
	// 827F0100: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x827F0104; continue 'dispatch;
            }
            0x827F0104 => {
    //   block [0x827F0104..0x827F0108)
	// 827F0104: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x827F0108; continue 'dispatch;
            }
            0x827F0108 => {
    //   block [0x827F0108..0x827F011C)
	// 827F0108: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F010C: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827F0110: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0114: 419A0008  beq cr6, 0x827f011c
	if ctx.cr[6].eq {
	pc = 0x827F011C; continue 'dispatch;
	}
	// 827F0118: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F011C; continue 'dispatch;
            }
            0x827F011C => {
    //   block [0x827F011C..0x827F019C)
	// 827F011C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F0120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0124: 419A0078  beq cr6, 0x827f019c
	if ctx.cr[6].eq {
	pc = 0x827F019C; continue 'dispatch;
	}
	// 827F0128: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F012C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 827F0130: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0134: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F0138: 4BA38FD1  bl 0x82229108
	ctx.lr = 0x827F013C;
	sub_82229108(ctx, base);
	// 827F013C: 3D60827F  lis r11, -0x7d81
	ctx.r[11].s64 = -2105606144;
	// 827F0140: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 827F0144: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F0148: 3BCB0578  addi r30, r11, 0x578
	ctx.r[30].s64 = ctx.r[11].s64 + 1400;
	// 827F014C: 4BA37735  bl 0x82227880
	ctx.lr = 0x827F0150;
	sub_82227880(ctx, base);
	// 827F0150: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F0154: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 827F0158: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F015C: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 827F0160: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F0164: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F0168: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F016C: 4B9AA915  bl 0x8219aa80
	ctx.lr = 0x827F0170;
	sub_8219AA80(ctx, base);
	// 827F0170: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F0174: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F0178: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F017C: 4BBDE2A5  bl 0x823ce420
	ctx.lr = 0x827F0180;
	sub_823CE420(ctx, base);
	// 827F0180: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F0184: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 827F0188: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F018C: 4823453D  bl 0x82a246c8
	ctx.lr = 0x827F0190;
	sub_82A246C8(ctx, base);
	// 827F0190: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0194: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 827F0198: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x827F019C; continue 'dispatch;
            }
            0x827F019C => {
    //   block [0x827F019C..0x827F01AC)
	// 827F019C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F01A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F01A4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827F01A8: 419A0020  beq cr6, 0x827f01c8
	if ctx.cr[6].eq {
	pc = 0x827F01C8; continue 'dispatch;
	}
	pc = 0x827F01AC; continue 'dispatch;
            }
            0x827F01AC => {
    //   block [0x827F01AC..0x827F01C8)
	// 827F01AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F01B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F01B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F01B8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F01BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F01C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F01C4: 4082FFE8  bne 0x827f01ac
	if !ctx.cr[0].eq {
	pc = 0x827F01AC; continue 'dispatch;
	}
	pc = 0x827F01C8; continue 'dispatch;
            }
            0x827F01C8 => {
    //   block [0x827F01C8..0x827F01E8)
	// 827F01C8: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F01CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F01D0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 827F01D4: 4BB05775  bl 0x822f5948
	ctx.lr = 0x827F01D8;
	sub_822F5948(ctx, base);
	// 827F01D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F01DC: 4B9C793D  bl 0x821b7b18
	ctx.lr = 0x827F01E0;
	sub_821B7B18(ctx, base);
	// 827F01E0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F01E4: 419A0040  beq cr6, 0x827f0224
	if ctx.cr[6].eq {
	pc = 0x827F0224; continue 'dispatch;
	}
	pc = 0x827F01E8; continue 'dispatch;
            }
            0x827F01E8 => {
    //   block [0x827F01E8..0x827F0224)
	// 827F01E8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F01EC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F01F0: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F01F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F01F8: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F01FC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F0200: 4082FFE8  bne 0x827f01e8
	if !ctx.cr[0].eq {
	pc = 0x827F01E8; continue 'dispatch;
	}
	// 827F0204: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F0208: 409A001C  bne cr6, 0x827f0224
	if !ctx.cr[6].eq {
	pc = 0x827F0224; continue 'dispatch;
	}
	// 827F020C: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0210: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0214: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827F0218: 4E800421  bctrl
	ctx.lr = 0x827F021C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F021C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F0220: 4BA2BB19  bl 0x8221bd38
	ctx.lr = 0x827F0224;
	sub_8221BD38(ctx, base);
            }
            0x827F0224 => {
    //   block [0x827F0224..0x827F0234)
	// 827F0224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F0228: 4B9C78F1  bl 0x821b7b18
	ctx.lr = 0x827F022C;
	sub_821B7B18(ctx, base);
	// 827F022C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F0230: 484B921C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F0238 size=56
    let mut pc: u32 = 0x827F0238;
    'dispatch: loop {
        match pc {
            0x827F0238 => {
    //   block [0x827F0238..0x827F0254)
	// 827F0238: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F023C: 419A0018  beq cr6, 0x827f0254
	if ctx.cr[6].eq {
	pc = 0x827F0254; continue 'dispatch;
	}
	// 827F0240: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827F0244: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F0248: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F024C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F0250: 409A0008  bne cr6, 0x827f0258
	if !ctx.cr[6].eq {
	pc = 0x827F0258; continue 'dispatch;
	}
	pc = 0x827F0254; continue 'dispatch;
            }
            0x827F0254 => {
    //   block [0x827F0254..0x827F0258)
	// 827F0254: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F0258; continue 'dispatch;
            }
            0x827F0258 => {
    //   block [0x827F0258..0x827F0270)
	// 827F0258: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F025C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0260: 419A0010  beq cr6, 0x827f0270
	if ctx.cr[6].eq {
		sub_827F0270(ctx, base);
		return;
	}
	// 827F0264: 8164003C  lwz r11, 0x3c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 827F0268: 55634FFE  rlwinm r3, r11, 9, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 827F026C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F0270 size=8
    let mut pc: u32 = 0x827F0270;
    'dispatch: loop {
        match pc {
            0x827F0270 => {
    //   block [0x827F0270..0x827F0278)
	// 827F0270: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827F0274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F0278 size=8
    let mut pc: u32 = 0x827F0278;
    'dispatch: loop {
        match pc {
            0x827F0278 => {
    //   block [0x827F0278..0x827F0280)
	// 827F0278: 386000D7  li r3, 0xd7
	ctx.r[3].s64 = 215;
	// 827F027C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0280(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F0280 size=380
    let mut pc: u32 = 0x827F0280;
    'dispatch: loop {
        match pc {
            0x827F0280 => {
    //   block [0x827F0280..0x827F02A8)
	// 827F0280: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0284: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0288: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F028C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F0290: 419A0018  beq cr6, 0x827f02a8
	if ctx.cr[6].eq {
	pc = 0x827F02A8; continue 'dispatch;
	}
	// 827F0294: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827F0298: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F029C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F02A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F02A4: 409A0008  bne cr6, 0x827f02ac
	if !ctx.cr[6].eq {
	pc = 0x827F02AC; continue 'dispatch;
	}
	pc = 0x827F02A8; continue 'dispatch;
            }
            0x827F02A8 => {
    //   block [0x827F02A8..0x827F02AC)
	// 827F02A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F02AC; continue 'dispatch;
            }
            0x827F02AC => {
    //   block [0x827F02AC..0x827F02F4)
	// 827F02AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F02B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F02B4: 419A0130  beq cr6, 0x827f03e4
	if ctx.cr[6].eq {
	pc = 0x827F03E4; continue 'dispatch;
	}
	// 827F02B8: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 827F02BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F02C0: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 827F02C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F02C8: 419A00EC  beq cr6, 0x827f03b4
	if ctx.cr[6].eq {
	pc = 0x827F03B4; continue 'dispatch;
	}
	// 827F02CC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F02D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F02D4: 419A0020  beq cr6, 0x827f02f4
	if ctx.cr[6].eq {
	pc = 0x827F02F4; continue 'dispatch;
	}
	// 827F02D8: 894B00D7  lbz r10, 0xd7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(215 as u32) ) } as u64;
	// 827F02DC: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F02E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F02E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F02E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F02EC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F02F0: 480000C8  b 0x827f03b8
	pc = 0x827F03B8; continue 'dispatch;
            }
            0x827F02F4 => {
    //   block [0x827F02F4..0x827F0314)
	// 827F02F4: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F02F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F02FC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F0300: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F0304: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F0308: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F030C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F0310: 40810054  ble 0x827f0364
	if !ctx.cr[0].gt {
	pc = 0x827F0364; continue 'dispatch;
	}
	pc = 0x827F0314; continue 'dispatch;
            }
            0x827F0314 => {
    //   block [0x827F0314..0x827F0334)
	// 827F0314: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F0318: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F031C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F0320: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0324: 2F0700D7  cmpwi cr6, r7, 0xd7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 215, &mut ctx.xer);
	// 827F0328: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F032C: 41980008  blt cr6, 0x827f0334
	if ctx.cr[6].lt {
	pc = 0x827F0334; continue 'dispatch;
	}
	// 827F0330: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F0334; continue 'dispatch;
            }
            0x827F0334 => {
    //   block [0x827F0334..0x827F0350)
	// 827F0334: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F0338: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F033C: 419A0014  beq cr6, 0x827f0350
	if ctx.cr[6].eq {
	pc = 0x827F0350; continue 'dispatch;
	}
	// 827F0340: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F0344: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F0348: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F034C: 4800000C  b 0x827f0358
	pc = 0x827F0358; continue 'dispatch;
            }
            0x827F0350 => {
    //   block [0x827F0350..0x827F0358)
	// 827F0350: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F0354: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F0358; continue 'dispatch;
            }
            0x827F0358 => {
    //   block [0x827F0358..0x827F0364)
	// 827F0358: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F035C: 4199FFB8  bgt cr6, 0x827f0314
	if ctx.cr[6].gt {
	pc = 0x827F0314; continue 'dispatch;
	}
	// 827F0360: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F0364; continue 'dispatch;
            }
            0x827F0364 => {
    //   block [0x827F0364..0x827F0380)
	// 827F0364: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F0368: 419A003C  beq cr6, 0x827f03a4
	if ctx.cr[6].eq {
	pc = 0x827F03A4; continue 'dispatch;
	}
	// 827F036C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0370: 2F0B00D7  cmpwi cr6, r11, 0xd7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 215, &mut ctx.xer);
	// 827F0374: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F0378: 41990008  bgt cr6, 0x827f0380
	if ctx.cr[6].gt {
	pc = 0x827F0380; continue 'dispatch;
	}
	// 827F037C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F0380; continue 'dispatch;
            }
            0x827F0380 => {
    //   block [0x827F0380..0x827F03A4)
	// 827F0380: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F0384: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0388: 409A001C  bne cr6, 0x827f03a4
	if !ctx.cr[6].eq {
	pc = 0x827F03A4; continue 'dispatch;
	}
	// 827F038C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F0390: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F0394: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F0398: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F039C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F03A0: 48000018  b 0x827f03b8
	pc = 0x827F03B8; continue 'dispatch;
            }
            0x827F03A4 => {
    //   block [0x827F03A4..0x827F03B4)
	// 827F03A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F03A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F03AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F03B0: 48000008  b 0x827f03b8
	pc = 0x827F03B8; continue 'dispatch;
            }
            0x827F03B4 => {
    //   block [0x827F03B4..0x827F03B8)
	// 827F03B4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F03B8; continue 'dispatch;
            }
            0x827F03B8 => {
    //   block [0x827F03B8..0x827F03E4)
	// 827F03B8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F03BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F03C0: 419A0024  beq cr6, 0x827f03e4
	if ctx.cr[6].eq {
	pc = 0x827F03E4; continue 'dispatch;
	}
	// 827F03C4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F03C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F03CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F03D0: 4E800421  bctrl
	ctx.lr = 0x827F03D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F03D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F03D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F03DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F03E0: 4E800020  blr
	return;
            }
            0x827F03E4 => {
    //   block [0x827F03E4..0x827F03FC)
	// 827F03E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F03E8: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F03EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F03F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F03F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F03F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0400 size=372
    let mut pc: u32 = 0x827F0400;
    'dispatch: loop {
        match pc {
            0x827F0400 => {
    //   block [0x827F0400..0x827F0428)
	// 827F0400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0408: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F040C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F0410: 419A0018  beq cr6, 0x827f0428
	if ctx.cr[6].eq {
	pc = 0x827F0428; continue 'dispatch;
	}
	// 827F0414: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827F0418: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F041C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F0420: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F0424: 409A0008  bne cr6, 0x827f042c
	if !ctx.cr[6].eq {
	pc = 0x827F042C; continue 'dispatch;
	}
	pc = 0x827F0428; continue 'dispatch;
            }
            0x827F0428 => {
    //   block [0x827F0428..0x827F042C)
	// 827F0428: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F042C; continue 'dispatch;
            }
            0x827F042C => {
    //   block [0x827F042C..0x827F0474)
	// 827F042C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F0430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0434: 419A012C  beq cr6, 0x827f0560
	if ctx.cr[6].eq {
	pc = 0x827F0560; continue 'dispatch;
	}
	// 827F0438: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 827F043C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F0440: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 827F0444: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F0448: 419A00E8  beq cr6, 0x827f0530
	if ctx.cr[6].eq {
	pc = 0x827F0530; continue 'dispatch;
	}
	// 827F044C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F0450: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F0454: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0458: 419A001C  beq cr6, 0x827f0474
	if ctx.cr[6].eq {
	pc = 0x827F0474; continue 'dispatch;
	}
	// 827F045C: 896B00D7  lbz r11, 0xd7(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(215 as u32) ) } as u64;
	// 827F0460: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827F0464: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827F0468: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F046C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F0470: 480000C4  b 0x827f0534
	pc = 0x827F0534; continue 'dispatch;
            }
            0x827F0474 => {
    //   block [0x827F0474..0x827F0490)
	// 827F0474: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F0478: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F047C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F0480: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F0484: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F0488: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F048C: 40810054  ble 0x827f04e0
	if !ctx.cr[0].gt {
	pc = 0x827F04E0; continue 'dispatch;
	}
	pc = 0x827F0490; continue 'dispatch;
            }
            0x827F0490 => {
    //   block [0x827F0490..0x827F04B0)
	// 827F0490: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F0494: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F0498: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F049C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F04A0: 2F0700D7  cmpwi cr6, r7, 0xd7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 215, &mut ctx.xer);
	// 827F04A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F04A8: 41980008  blt cr6, 0x827f04b0
	if ctx.cr[6].lt {
	pc = 0x827F04B0; continue 'dispatch;
	}
	// 827F04AC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F04B0; continue 'dispatch;
            }
            0x827F04B0 => {
    //   block [0x827F04B0..0x827F04CC)
	// 827F04B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F04B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F04B8: 419A0014  beq cr6, 0x827f04cc
	if ctx.cr[6].eq {
	pc = 0x827F04CC; continue 'dispatch;
	}
	// 827F04BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F04C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F04C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F04C8: 4800000C  b 0x827f04d4
	pc = 0x827F04D4; continue 'dispatch;
            }
            0x827F04CC => {
    //   block [0x827F04CC..0x827F04D4)
	// 827F04CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F04D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F04D4; continue 'dispatch;
            }
            0x827F04D4 => {
    //   block [0x827F04D4..0x827F04E0)
	// 827F04D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F04D8: 4199FFB8  bgt cr6, 0x827f0490
	if ctx.cr[6].gt {
	pc = 0x827F0490; continue 'dispatch;
	}
	// 827F04DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F04E0; continue 'dispatch;
            }
            0x827F04E0 => {
    //   block [0x827F04E0..0x827F04FC)
	// 827F04E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F04E4: 419A003C  beq cr6, 0x827f0520
	if ctx.cr[6].eq {
	pc = 0x827F0520; continue 'dispatch;
	}
	// 827F04E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F04EC: 2F0B00D7  cmpwi cr6, r11, 0xd7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 215, &mut ctx.xer);
	// 827F04F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F04F4: 41990008  bgt cr6, 0x827f04fc
	if ctx.cr[6].gt {
	pc = 0x827F04FC; continue 'dispatch;
	}
	// 827F04F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F04FC; continue 'dispatch;
            }
            0x827F04FC => {
    //   block [0x827F04FC..0x827F0520)
	// 827F04FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F0500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0504: 409A001C  bne cr6, 0x827f0520
	if !ctx.cr[6].eq {
	pc = 0x827F0520; continue 'dispatch;
	}
	// 827F0508: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F050C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F0510: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F0514: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F0518: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F051C: 48000018  b 0x827f0534
	pc = 0x827F0534; continue 'dispatch;
            }
            0x827F0520 => {
    //   block [0x827F0520..0x827F0530)
	// 827F0520: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F0524: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F0528: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F052C: 48000008  b 0x827f0534
	pc = 0x827F0534; continue 'dispatch;
            }
            0x827F0530 => {
    //   block [0x827F0530..0x827F0534)
	// 827F0530: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F0534; continue 'dispatch;
            }
            0x827F0534 => {
    //   block [0x827F0534..0x827F0560)
	// 827F0534: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F0538: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F053C: 419A0024  beq cr6, 0x827f0560
	if ctx.cr[6].eq {
	pc = 0x827F0560; continue 'dispatch;
	}
	// 827F0540: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0544: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F0548: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F054C: 4E800421  bctrl
	ctx.lr = 0x827F0550;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0550: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F055C: 4E800020  blr
	return;
            }
            0x827F0560 => {
    //   block [0x827F0560..0x827F0574)
	// 827F0560: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827F0564: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0568: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F056C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0570: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0578 size=352
    let mut pc: u32 = 0x827F0578;
    'dispatch: loop {
        match pc {
            0x827F0578 => {
    //   block [0x827F0578..0x827F05A0)
	// 827F0578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F057C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0580: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0584: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F0588: 419A0018  beq cr6, 0x827f05a0
	if ctx.cr[6].eq {
	pc = 0x827F05A0; continue 'dispatch;
	}
	// 827F058C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 827F0590: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F0594: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F0598: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F059C: 409A0008  bne cr6, 0x827f05a4
	if !ctx.cr[6].eq {
	pc = 0x827F05A4; continue 'dispatch;
	}
	pc = 0x827F05A0; continue 'dispatch;
            }
            0x827F05A0 => {
    //   block [0x827F05A0..0x827F05A4)
	// 827F05A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F05A4; continue 'dispatch;
            }
            0x827F05A4 => {
    //   block [0x827F05A4..0x827F05EC)
	// 827F05A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F05A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F05AC: 419A011C  beq cr6, 0x827f06c8
	if ctx.cr[6].eq {
	pc = 0x827F06C8; continue 'dispatch;
	}
	// 827F05B0: 8144003C  lwz r10, 0x3c(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(60 as u32) ) } as u64;
	// 827F05B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F05B8: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 827F05BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F05C0: 419A00E8  beq cr6, 0x827f06a8
	if ctx.cr[6].eq {
	pc = 0x827F06A8; continue 'dispatch;
	}
	// 827F05C4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F05C8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F05CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F05D0: 419A001C  beq cr6, 0x827f05ec
	if ctx.cr[6].eq {
	pc = 0x827F05EC; continue 'dispatch;
	}
	// 827F05D4: 896B00D7  lbz r11, 0xd7(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(215 as u32) ) } as u64;
	// 827F05D8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827F05DC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827F05E0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F05E4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F05E8: 480000C4  b 0x827f06ac
	pc = 0x827F06AC; continue 'dispatch;
            }
            0x827F05EC => {
    //   block [0x827F05EC..0x827F0608)
	// 827F05EC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F05F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F05F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F05F8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F05FC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F0600: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F0604: 40810054  ble 0x827f0658
	if !ctx.cr[0].gt {
	pc = 0x827F0658; continue 'dispatch;
	}
	pc = 0x827F0608; continue 'dispatch;
            }
            0x827F0608 => {
    //   block [0x827F0608..0x827F0628)
	// 827F0608: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F060C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F0610: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F0614: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0618: 2F0700D7  cmpwi cr6, r7, 0xd7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 215, &mut ctx.xer);
	// 827F061C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F0620: 41980008  blt cr6, 0x827f0628
	if ctx.cr[6].lt {
	pc = 0x827F0628; continue 'dispatch;
	}
	// 827F0624: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F0628; continue 'dispatch;
            }
            0x827F0628 => {
    //   block [0x827F0628..0x827F0644)
	// 827F0628: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F062C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F0630: 419A0014  beq cr6, 0x827f0644
	if ctx.cr[6].eq {
	pc = 0x827F0644; continue 'dispatch;
	}
	// 827F0634: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F0638: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F063C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F0640: 4800000C  b 0x827f064c
	pc = 0x827F064C; continue 'dispatch;
            }
            0x827F0644 => {
    //   block [0x827F0644..0x827F064C)
	// 827F0644: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F0648: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F064C; continue 'dispatch;
            }
            0x827F064C => {
    //   block [0x827F064C..0x827F0658)
	// 827F064C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F0650: 4199FFB8  bgt cr6, 0x827f0608
	if ctx.cr[6].gt {
	pc = 0x827F0608; continue 'dispatch;
	}
	// 827F0654: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F0658; continue 'dispatch;
            }
            0x827F0658 => {
    //   block [0x827F0658..0x827F0674)
	// 827F0658: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F065C: 419A003C  beq cr6, 0x827f0698
	if ctx.cr[6].eq {
	pc = 0x827F0698; continue 'dispatch;
	}
	// 827F0660: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0664: 2F0B00D7  cmpwi cr6, r11, 0xd7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 215, &mut ctx.xer);
	// 827F0668: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F066C: 41990008  bgt cr6, 0x827f0674
	if ctx.cr[6].gt {
	pc = 0x827F0674; continue 'dispatch;
	}
	// 827F0670: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F0674; continue 'dispatch;
            }
            0x827F0674 => {
    //   block [0x827F0674..0x827F0698)
	// 827F0674: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F0678: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F067C: 409A001C  bne cr6, 0x827f0698
	if !ctx.cr[6].eq {
	pc = 0x827F0698; continue 'dispatch;
	}
	// 827F0680: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F0684: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F0688: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F068C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F0690: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0694: 48000018  b 0x827f06ac
	pc = 0x827F06AC; continue 'dispatch;
            }
            0x827F0698 => {
    //   block [0x827F0698..0x827F06A8)
	// 827F0698: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F069C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F06A0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F06A4: 48000008  b 0x827f06ac
	pc = 0x827F06AC; continue 'dispatch;
            }
            0x827F06A8 => {
    //   block [0x827F06A8..0x827F06AC)
	// 827F06A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F06AC; continue 'dispatch;
            }
            0x827F06AC => {
    //   block [0x827F06AC..0x827F06C8)
	// 827F06AC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F06B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F06B4: 419A0014  beq cr6, 0x827f06c8
	if ctx.cr[6].eq {
	pc = 0x827F06C8; continue 'dispatch;
	}
	// 827F06B8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F06BC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F06C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F06C4: 4E800421  bctrl
	ctx.lr = 0x827F06C8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F06C8 => {
    //   block [0x827F06C8..0x827F06D8)
	// 827F06C8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F06CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F06D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F06D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F06D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F06D8 size=156
    let mut pc: u32 = 0x827F06D8;
    'dispatch: loop {
        match pc {
            0x827F06D8 => {
    //   block [0x827F06D8..0x827F0714)
	// 827F06D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F06DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F06E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F06E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F06E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F06EC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F06F0: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 827F06F4: 394BA150  addi r10, r11, -0x5eb0
	ctx.r[10].s64 = ctx.r[11].s64 + -24240;
	// 827F06F8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F06FC: 4BA2EB5D  bl 0x8221f258
	ctx.lr = 0x827F0700;
	sub_8221F258(ctx, base);
	// 827F0700: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F0704: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F0708: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F070C: 419A0008  beq cr6, 0x827f0714
	if ctx.cr[6].eq {
	pc = 0x827F0714; continue 'dispatch;
	}
	// 827F0710: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827F0714; continue 'dispatch;
            }
            0x827F0714 => {
    //   block [0x827F0714..0x827F0720)
	// 827F0714: 352B0004  addic. r9, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827F0718: 41820008  beq 0x827f0720
	if ctx.cr[0].eq {
	pc = 0x827F0720; continue 'dispatch;
	}
	// 827F071C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827F0720; continue 'dispatch;
            }
            0x827F0720 => {
    //   block [0x827F0720..0x827F072C)
	// 827F0720: 352B0008  addic. r9, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827F0724: 41820008  beq 0x827f072c
	if ctx.cr[0].eq {
	pc = 0x827F072C; continue 'dispatch;
	}
	// 827F0728: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827F072C; continue 'dispatch;
            }
            0x827F072C => {
    //   block [0x827F072C..0x827F0774)
	// 827F072C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827F0730: 994B0015  stb r10, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 827F0734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0738: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 827F073C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F0740: 992B0015  stb r9, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 827F0744: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0748: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F074C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0750: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F0754: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0758: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 827F075C: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 827F0760: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0764: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0768: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F076C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0778 size=60
    let mut pc: u32 = 0x827F0778;
    'dispatch: loop {
        match pc {
            0x827F0778 => {
    //   block [0x827F0778..0x827F07B4)
	// 827F0778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F077C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0780: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0784: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0788: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 827F078C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0790: 388B3C2C  addi r4, r11, 0x3c2c
	ctx.r[4].s64 = ctx.r[11].s64 + 15404;
	// 827F0794: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0798: 4BA3C739  bl 0x8222ced0
	ctx.lr = 0x827F079C;
	sub_8222CED0(ctx, base);
	// 827F079C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F07A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F07A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F07A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F07AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F07B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F07B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F07B8 size=80
    let mut pc: u32 = 0x827F07B8;
    'dispatch: loop {
        match pc {
            0x827F07B8 => {
    //   block [0x827F07B8..0x827F07FC)
	// 827F07B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F07BC: 484B8C51  bl 0x82ca940c
	ctx.lr = 0x827F07C0;
	sub_82CA93D0(ctx, base);
	// 827F07C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F07C4: 38600050  li r3, 0x50
	ctx.r[3].s64 = 80;
	// 827F07C8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F07CC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827F07D0: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827F07D4: 4BA2EA85  bl 0x8221f258
	ctx.lr = 0x827F07D8;
	sub_8221F258(ctx, base);
	// 827F07D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F07DC: 419A0020  beq cr6, 0x827f07fc
	if ctx.cr[6].eq {
	pc = 0x827F07FC; continue 'dispatch;
	}
	// 827F07E0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F07E4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F07E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F07EC: 4804F1FD  bl 0x8283f9e8
	ctx.lr = 0x827F07F0;
	sub_8283F9E8(ctx, base);
	// 827F07F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F07F4: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827F07F8: 409A0008  bne cr6, 0x827f0800
	if !ctx.cr[6].eq {
	pc = 0x827F0800; continue 'dispatch;
	}
	pc = 0x827F07FC; continue 'dispatch;
            }
            0x827F07FC => {
    //   block [0x827F07FC..0x827F0800)
	// 827F07FC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0800; continue 'dispatch;
            }
            0x827F0800 => {
    //   block [0x827F0800..0x827F0808)
	// 827F0800: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0804: 484B8C58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0808 size=80
    let mut pc: u32 = 0x827F0808;
    'dispatch: loop {
        match pc {
            0x827F0808 => {
    //   block [0x827F0808..0x827F0840)
	// 827F0808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F080C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F0814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F081C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0820: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F0824: 4BC0B92D  bl 0x823fc150
	ctx.lr = 0x827F0828;
	sub_823FC150(ctx, base);
	// 827F0828: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 827F082C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0830: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0834: 419A000C  beq cr6, 0x827f0840
	if ctx.cr[6].eq {
	pc = 0x827F0840; continue 'dispatch;
	}
	// 827F0838: 4BA2B501  bl 0x8221bd38
	ctx.lr = 0x827F083C;
	sub_8221BD38(ctx, base);
	// 827F083C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x827F0840; continue 'dispatch;
            }
            0x827F0840 => {
    //   block [0x827F0840..0x827F0858)
	// 827F0840: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0844: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0848: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F084C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0850: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0858 size=60
    let mut pc: u32 = 0x827F0858;
    'dispatch: loop {
        match pc {
            0x827F0858 => {
    //   block [0x827F0858..0x827F0894)
	// 827F0858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F085C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0860: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0864: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0868: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F086C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0870: 388B9F3C  addi r4, r11, -0x60c4
	ctx.r[4].s64 = ctx.r[11].s64 + -24772;
	// 827F0874: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0878: 4BA3C659  bl 0x8222ced0
	ctx.lr = 0x827F087C;
	sub_8222CED0(ctx, base);
	// 827F087C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0880: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0884: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0888: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F088C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0890: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0898(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F0898 size=132
    let mut pc: u32 = 0x827F0898;
    'dispatch: loop {
        match pc {
            0x827F0898 => {
    //   block [0x827F0898..0x827F0900)
	// 827F0898: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F089C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F08A0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F08A4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F08A8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F08AC: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 827F08B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F08B4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F08B8: 4BA2E9A1  bl 0x8221f258
	ctx.lr = 0x827F08BC;
	sub_8221F258(ctx, base);
	// 827F08BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F08C0: 419A0040  beq cr6, 0x827f0900
	if ctx.cr[6].eq {
	pc = 0x827F0900; continue 'dispatch;
	}
	// 827F08C4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F08C8: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F08CC: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 827F08D0: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F08D4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F08D8: 39091540  addi r8, r9, 0x1540
	ctx.r[8].s64 = ctx.r[9].s64 + 5440;
	// 827F08DC: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827F08E0: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F08E4: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F08E8: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 827F08EC: 99630020  stb r11, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u8 ) };
	// 827F08F0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 827F08F4: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 827F08F8: D003001C  stfs f0, 0x1c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 827F08FC: 48000008  b 0x827f0904
	pc = 0x827F0904; continue 'dispatch;
            }
            0x827F0900 => {
    //   block [0x827F0900..0x827F0904)
	// 827F0900: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0904; continue 'dispatch;
            }
            0x827F0904 => {
    //   block [0x827F0904..0x827F091C)
	// 827F0904: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0908: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F090C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0910: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0914: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0918: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0920 size=60
    let mut pc: u32 = 0x827F0920;
    'dispatch: loop {
        match pc {
            0x827F0920 => {
    //   block [0x827F0920..0x827F095C)
	// 827F0920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0924: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0928: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F092C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0930: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0934: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0938: 388B9F48  addi r4, r11, -0x60b8
	ctx.r[4].s64 = ctx.r[11].s64 + -24760;
	// 827F093C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0940: 4BA3C591  bl 0x8222ced0
	ctx.lr = 0x827F0944;
	sub_8222CED0(ctx, base);
	// 827F0944: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0948: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F094C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0950: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0960 size=96
    let mut pc: u32 = 0x827F0960;
    'dispatch: loop {
        match pc {
            0x827F0960 => {
    //   block [0x827F0960..0x827F09A4)
	// 827F0960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0968: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F096C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0970: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0974: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F0978: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F097C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F0980: 4BA2E8D9  bl 0x8221f258
	ctx.lr = 0x827F0984;
	sub_8221F258(ctx, base);
	// 827F0984: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0988: 419A001C  beq cr6, 0x827f09a4
	if ctx.cr[6].eq {
	pc = 0x827F09A4; continue 'dispatch;
	}
	// 827F098C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0990: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F0994: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0998: 394BA0D8  addi r10, r11, -0x5f28
	ctx.r[10].s64 = ctx.r[11].s64 + -24360;
	// 827F099C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F09A0: 48000008  b 0x827f09a8
	pc = 0x827F09A8; continue 'dispatch;
            }
            0x827F09A4 => {
    //   block [0x827F09A4..0x827F09A8)
	// 827F09A4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F09A8; continue 'dispatch;
            }
            0x827F09A8 => {
    //   block [0x827F09A8..0x827F09C0)
	// 827F09A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F09AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F09B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F09B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F09B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F09BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F09C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F09C0 size=60
    let mut pc: u32 = 0x827F09C0;
    'dispatch: loop {
        match pc {
            0x827F09C0 => {
    //   block [0x827F09C0..0x827F09FC)
	// 827F09C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F09C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F09C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F09CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F09D0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F09D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F09D8: 388B9F58  addi r4, r11, -0x60a8
	ctx.r[4].s64 = ctx.r[11].s64 + -24744;
	// 827F09DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F09E0: 4BA3C4F1  bl 0x8222ced0
	ctx.lr = 0x827F09E4;
	sub_8222CED0(ctx, base);
	// 827F09E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F09E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F09EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F09F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F09F4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F09F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0A00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0A00 size=96
    let mut pc: u32 = 0x827F0A00;
    'dispatch: loop {
        match pc {
            0x827F0A00 => {
    //   block [0x827F0A00..0x827F0A44)
	// 827F0A00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0A04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0A08: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F0A0C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0A10: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0A14: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F0A18: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F0A1C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F0A20: 4BA2E839  bl 0x8221f258
	ctx.lr = 0x827F0A24;
	sub_8221F258(ctx, base);
	// 827F0A24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0A28: 419A001C  beq cr6, 0x827f0a44
	if ctx.cr[6].eq {
	pc = 0x827F0A44; continue 'dispatch;
	}
	// 827F0A2C: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827F0A30: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F0A34: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0A38: 394B1574  addi r10, r11, 0x1574
	ctx.r[10].s64 = ctx.r[11].s64 + 5492;
	// 827F0A3C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F0A40: 48000008  b 0x827f0a48
	pc = 0x827F0A48; continue 'dispatch;
            }
            0x827F0A44 => {
    //   block [0x827F0A44..0x827F0A48)
	// 827F0A44: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0A48; continue 'dispatch;
            }
            0x827F0A48 => {
    //   block [0x827F0A48..0x827F0A60)
	// 827F0A48: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0A4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0A50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0A54: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0A58: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0A5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0A60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0A60 size=60
    let mut pc: u32 = 0x827F0A60;
    'dispatch: loop {
        match pc {
            0x827F0A60 => {
    //   block [0x827F0A60..0x827F0A9C)
	// 827F0A60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0A64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0A68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0A6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0A70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0A74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0A78: 388B9F68  addi r4, r11, -0x6098
	ctx.r[4].s64 = ctx.r[11].s64 + -24728;
	// 827F0A7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0A80: 4BA3C451  bl 0x8222ced0
	ctx.lr = 0x827F0A84;
	sub_8222CED0(ctx, base);
	// 827F0A84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0A88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0A8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0A90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0A94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0A98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0AA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F0AA0 size=124
    let mut pc: u32 = 0x827F0AA0;
    'dispatch: loop {
        match pc {
            0x827F0AA0 => {
    //   block [0x827F0AA0..0x827F0B00)
	// 827F0AA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0AA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0AA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F0AAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0AB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0AB4: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 827F0AB8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F0ABC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F0AC0: 4BA2E799  bl 0x8221f258
	ctx.lr = 0x827F0AC4;
	sub_8221F258(ctx, base);
	// 827F0AC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0AC8: 419A0038  beq cr6, 0x827f0b00
	if ctx.cr[6].eq {
	pc = 0x827F0B00; continue 'dispatch;
	}
	// 827F0ACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F0AD0: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F0AD4: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F0AD8: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0ADC: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 827F0AE0: 390A14D0  addi r8, r10, 0x14d0
	ctx.r[8].s64 = ctx.r[10].s64 + 5328;
	// 827F0AE4: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 827F0AE8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F0AEC: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F0AF0: D0030010  stfs f0, 0x10(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 827F0AF4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 827F0AF8: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 827F0AFC: 48000008  b 0x827f0b04
	pc = 0x827F0B04; continue 'dispatch;
            }
            0x827F0B00 => {
    //   block [0x827F0B00..0x827F0B04)
	// 827F0B00: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0B04; continue 'dispatch;
            }
            0x827F0B04 => {
    //   block [0x827F0B04..0x827F0B1C)
	// 827F0B04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0B08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0B0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0B10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0B14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0B18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0B20 size=60
    let mut pc: u32 = 0x827F0B20;
    'dispatch: loop {
        match pc {
            0x827F0B20 => {
    //   block [0x827F0B20..0x827F0B5C)
	// 827F0B20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0B24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0B28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0B2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0B30: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0B34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0B38: 388B9F74  addi r4, r11, -0x608c
	ctx.r[4].s64 = ctx.r[11].s64 + -24716;
	// 827F0B3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0B40: 4BA3C391  bl 0x8222ced0
	ctx.lr = 0x827F0B44;
	sub_8222CED0(ctx, base);
	// 827F0B44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0B48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0B4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0B50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0B54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0B58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0B60 size=76
    let mut pc: u32 = 0x827F0B60;
    'dispatch: loop {
        match pc {
            0x827F0B60 => {
    //   block [0x827F0B60..0x827F0BA0)
	// 827F0B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0B64: 484B88A9  bl 0x82ca940c
	ctx.lr = 0x827F0B68;
	sub_82CA93D0(ctx, base);
	// 827F0B68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0B6C: 38600030  li r3, 0x30
	ctx.r[3].s64 = 48;
	// 827F0B70: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F0B74: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827F0B78: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827F0B7C: 4BA2E6DD  bl 0x8221f258
	ctx.lr = 0x827F0B80;
	sub_8221F258(ctx, base);
	// 827F0B80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0B84: 419A001C  beq cr6, 0x827f0ba0
	if ctx.cr[6].eq {
	pc = 0x827F0BA0; continue 'dispatch;
	}
	// 827F0B88: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F0B8C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F0B90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F0B94: 4BC0D96D  bl 0x823fe500
	ctx.lr = 0x827F0B98;
	sub_823FE500(ctx, base);
	// 827F0B98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0B9C: 484B88C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F0BA0 => {
    //   block [0x827F0BA0..0x827F0BAC)
	// 827F0BA0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 827F0BA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0BA8: 484B88B4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0BB0 size=60
    let mut pc: u32 = 0x827F0BB0;
    'dispatch: loop {
        match pc {
            0x827F0BB0 => {
    //   block [0x827F0BB0..0x827F0BEC)
	// 827F0BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0BB8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0BBC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0BC0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0BC4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0BC8: 388B9F7C  addi r4, r11, -0x6084
	ctx.r[4].s64 = ctx.r[11].s64 + -24708;
	// 827F0BCC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0BD0: 4BA3C301  bl 0x8222ced0
	ctx.lr = 0x827F0BD4;
	sub_8222CED0(ctx, base);
	// 827F0BD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0BD8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0BDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0BE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0BE4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0BE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0BF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0BF0 size=144
    let mut pc: u32 = 0x827F0BF0;
    'dispatch: loop {
        match pc {
            0x827F0BF0 => {
    //   block [0x827F0BF0..0x827F0C44)
	// 827F0BF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0BF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0BF8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F0BFC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0C00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0C04: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 827F0C08: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F0C0C: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F0C10: 4BA2E649  bl 0x8221f258
	ctx.lr = 0x827F0C14;
	sub_8221F258(ctx, base);
	// 827F0C14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0C18: 419A004C  beq cr6, 0x827f0c64
	if ctx.cr[6].eq {
	pc = 0x827F0C64; continue 'dispatch;
	}
	// 827F0C1C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F0C20: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F0C24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F0C28: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0C2C: 38EA1D78  addi r7, r10, 0x1d78
	ctx.r[7].s64 = ctx.r[10].s64 + 7544;
	// 827F0C30: 3CC08349  lis r6, -0x7cb7
	ctx.r[6].s64 = -2092367872;
	// 827F0C34: 9963000C  stb r11, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u8 ) };
	// 827F0C38: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 827F0C3C: 38A6708C  addi r5, r6, 0x708c
	ctx.r[5].s64 = ctx.r[6].s64 + 28812;
	// 827F0C40: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x827F0C44; continue 'dispatch;
            }
            0x827F0C44 => {
    //   block [0x827F0C44..0x827F0C64)
	// 827F0C44: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827F0C48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F0C4C: 7D202828  lwarx r9, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827F0C50: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827F0C54: 7D20292D  stwcx. r9, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F0C58: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F0C5C: 4082FFE8  bne 0x827f0c44
	if !ctx.cr[0].eq {
	pc = 0x827F0C44; continue 'dispatch;
	}
	// 827F0C60: 48000008  b 0x827f0c68
	pc = 0x827F0C68; continue 'dispatch;
            }
            0x827F0C64 => {
    //   block [0x827F0C64..0x827F0C68)
	// 827F0C64: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0C68; continue 'dispatch;
            }
            0x827F0C68 => {
    //   block [0x827F0C68..0x827F0C80)
	// 827F0C68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0C6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0C70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0C74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0C78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0C80 size=60
    let mut pc: u32 = 0x827F0C80;
    'dispatch: loop {
        match pc {
            0x827F0C80 => {
    //   block [0x827F0C80..0x827F0CBC)
	// 827F0C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0C88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0C8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0C90: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0C94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0C98: 388B9F88  addi r4, r11, -0x6078
	ctx.r[4].s64 = ctx.r[11].s64 + -24696;
	// 827F0C9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0CA0: 4BA3C231  bl 0x8222ced0
	ctx.lr = 0x827F0CA4;
	sub_8222CED0(ctx, base);
	// 827F0CA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0CA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0CAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0CB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0CB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0CC0 size=96
    let mut pc: u32 = 0x827F0CC0;
    'dispatch: loop {
        match pc {
            0x827F0CC0 => {
    //   block [0x827F0CC0..0x827F0D04)
	// 827F0CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0CC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F0CCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0CD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0CD4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F0CD8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F0CDC: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F0CE0: 4BA2E579  bl 0x8221f258
	ctx.lr = 0x827F0CE4;
	sub_8221F258(ctx, base);
	// 827F0CE4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0CE8: 419A001C  beq cr6, 0x827f0d04
	if ctx.cr[6].eq {
	pc = 0x827F0D04; continue 'dispatch;
	}
	// 827F0CEC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0CF0: 93E30004  stw r31, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F0CF4: 93C30008  stw r30, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0CF8: 394BE740  addi r10, r11, -0x18c0
	ctx.r[10].s64 = ctx.r[11].s64 + -6336;
	// 827F0CFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F0D00: 48000008  b 0x827f0d08
	pc = 0x827F0D08; continue 'dispatch;
            }
            0x827F0D04 => {
    //   block [0x827F0D04..0x827F0D08)
	// 827F0D04: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x827F0D08; continue 'dispatch;
            }
            0x827F0D08 => {
    //   block [0x827F0D08..0x827F0D20)
	// 827F0D08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0D0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0D10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0D14: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F0D18: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0D1C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0D20 size=60
    let mut pc: u32 = 0x827F0D20;
    'dispatch: loop {
        match pc {
            0x827F0D20 => {
    //   block [0x827F0D20..0x827F0D5C)
	// 827F0D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0D28: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0D2C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0D30: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0D34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0D38: 388B9F94  addi r4, r11, -0x606c
	ctx.r[4].s64 = ctx.r[11].s64 + -24684;
	// 827F0D3C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0D40: 4BA3C191  bl 0x8222ced0
	ctx.lr = 0x827F0D44;
	sub_8222CED0(ctx, base);
	// 827F0D44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0D48: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0D4C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0D50: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0D54: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0D58: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0D60 size=60
    let mut pc: u32 = 0x827F0D60;
    'dispatch: loop {
        match pc {
            0x827F0D60 => {
    //   block [0x827F0D60..0x827F0D9C)
	// 827F0D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0D68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0D6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0D70: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0D74: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0D78: 388B9FA4  addi r4, r11, -0x605c
	ctx.r[4].s64 = ctx.r[11].s64 + -24668;
	// 827F0D7C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0D80: 4BA3C151  bl 0x8222ced0
	ctx.lr = 0x827F0D84;
	sub_8222CED0(ctx, base);
	// 827F0D84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0D88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0D8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0D90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0D94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0D98: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0DA0 size=60
    let mut pc: u32 = 0x827F0DA0;
    'dispatch: loop {
        match pc {
            0x827F0DA0 => {
    //   block [0x827F0DA0..0x827F0DDC)
	// 827F0DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0DA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0DA8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0DAC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0DB0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0DB4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0DB8: 388B9FB4  addi r4, r11, -0x604c
	ctx.r[4].s64 = ctx.r[11].s64 + -24652;
	// 827F0DBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0DC0: 4BA3C111  bl 0x8222ced0
	ctx.lr = 0x827F0DC4;
	sub_8222CED0(ctx, base);
	// 827F0DC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0DC8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0DCC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0DD0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0DD4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0DD8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0DE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0DE0 size=60
    let mut pc: u32 = 0x827F0DE0;
    'dispatch: loop {
        match pc {
            0x827F0DE0 => {
    //   block [0x827F0DE0..0x827F0E1C)
	// 827F0DE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0DE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F0DE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F0DEC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0DF0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0DF4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F0DF8: 388B9FC4  addi r4, r11, -0x603c
	ctx.r[4].s64 = ctx.r[11].s64 + -24636;
	// 827F0DFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0E00: 4BA3C0D1  bl 0x8222ced0
	ctx.lr = 0x827F0E04;
	sub_8222CED0(ctx, base);
	// 827F0E04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0E08: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F0E0C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F0E10: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F0E14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F0E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0E20 size=220
    let mut pc: u32 = 0x827F0E20;
    'dispatch: loop {
        match pc {
            0x827F0E20 => {
    //   block [0x827F0E20..0x827F0E48)
	// 827F0E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0E24: 484B85E9  bl 0x82ca940c
	ctx.lr = 0x827F0E28;
	sub_82CA93D0(ctx, base);
	// 827F0E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0E2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F0E30: 3BFD0018  addi r31, r29, 0x18
	ctx.r[31].s64 = ctx.r[29].s64 + 24;
	// 827F0E34: 83DD001C  lwz r30, 0x1c(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F0E38: 817D0020  lwz r11, 0x20(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F0E3C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F0E40: 40990008  ble cr6, 0x827f0e48
	if !ctx.cr[6].gt {
	pc = 0x827F0E48; continue 'dispatch;
	}
	// 827F0E44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F0E48; continue 'dispatch;
            }
            0x827F0E48 => {
    //   block [0x827F0E48..0x827F0E5C)
	// 827F0E48: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0E4C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0E50: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F0E54: 40990008  ble cr6, 0x827f0e5c
	if !ctx.cr[6].gt {
	pc = 0x827F0E5C; continue 'dispatch;
	}
	// 827F0E58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F0E5C; continue 'dispatch;
            }
            0x827F0E5C => {
    //   block [0x827F0E5C..0x827F0E68)
	// 827F0E5C: 7F1FF840  cmplw cr6, r31, r31
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F0E60: 419A0008  beq cr6, 0x827f0e68
	if ctx.cr[6].eq {
	pc = 0x827F0E68; continue 'dispatch;
	}
	// 827F0E64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F0E68; continue 'dispatch;
            }
            0x827F0E68 => {
    //   block [0x827F0E68..0x827F0E7C)
	// 827F0E68: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F0E6C: 419A0048  beq cr6, 0x827f0eb4
	if ctx.cr[6].eq {
	pc = 0x827F0EB4; continue 'dispatch;
	}
	// 827F0E70: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F0E74: 41980008  blt cr6, 0x827f0e7c
	if ctx.cr[6].lt {
	pc = 0x827F0E7C; continue 'dispatch;
	}
	// 827F0E78: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F0E7C; continue 'dispatch;
            }
            0x827F0E7C => {
    //   block [0x827F0E7C..0x827F0E9C)
	// 827F0E7C: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0E80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0E84: 419A0018  beq cr6, 0x827f0e9c
	if ctx.cr[6].eq {
	pc = 0x827F0E9C; continue 'dispatch;
	}
	// 827F0E88: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0E8C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 827F0E90: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0E94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F0E98: 4E800421  bctrl
	ctx.lr = 0x827F0E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F0E9C => {
    //   block [0x827F0E9C..0x827F0EAC)
	// 827F0E9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F0EA0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F0EA4: 41980008  blt cr6, 0x827f0eac
	if ctx.cr[6].lt {
	pc = 0x827F0EAC; continue 'dispatch;
	}
	// 827F0EA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F0EAC; continue 'dispatch;
            }
            0x827F0EAC => {
    //   block [0x827F0EAC..0x827F0EB4)
	// 827F0EAC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827F0EB0: 4BFFFF98  b 0x827f0e48
	pc = 0x827F0E48; continue 'dispatch;
            }
            0x827F0EB4 => {
    //   block [0x827F0EB4..0x827F0EC4)
	// 827F0EB4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0EBC: 419A0008  beq cr6, 0x827f0ec4
	if ctx.cr[6].eq {
	pc = 0x827F0EC4; continue 'dispatch;
	}
	// 827F0EC0: 4BA2AE79  bl 0x8221bd38
	ctx.lr = 0x827F0EC4;
	sub_8221BD38(ctx, base);
	pc = 0x827F0EC4; continue 'dispatch;
            }
            0x827F0EC4 => {
    //   block [0x827F0EC4..0x827F0EE8)
	// 827F0EC4: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827F0EC8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827F0ECC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F0ED0: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0ED4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 827F0ED8: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0EDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F0EE0: 419A0008  beq cr6, 0x827f0ee8
	if ctx.cr[6].eq {
	pc = 0x827F0EE8; continue 'dispatch;
	}
	// 827F0EE4: 4BA2AE55  bl 0x8221bd38
	ctx.lr = 0x827F0EE8;
	sub_8221BD38(ctx, base);
	pc = 0x827F0EE8; continue 'dispatch;
            }
            0x827F0EE8 => {
    //   block [0x827F0EE8..0x827F0EFC)
	// 827F0EE8: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F0EEC: 93DD0008  stw r30, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 827F0EF0: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 827F0EF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F0EF8: 484B8564  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F0F00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F0F00 size=1736
    let mut pc: u32 = 0x827F0F00;
    'dispatch: loop {
        match pc {
            0x827F0F00 => {
    //   block [0x827F0F00..0x827F0FE8)
	// 827F0F00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F0F04: 484B84F1  bl 0x82ca93f4
	ctx.lr = 0x827F0F08;
	sub_82CA93D0(ctx, base);
	// 827F0F08: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F0F0C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827F0F10: 89790014  lbz r11, 0x14(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F0F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0F18: 419A06A8  beq cr6, 0x827f15c0
	if ctx.cr[6].eq {
	pc = 0x827F15C0; continue 'dispatch;
	}
	// 827F0F1C: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0F20: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 827F0F24: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F0F28: 830A0004  lwz r24, 4(r10)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0F2C: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 827F0F30: 419A068C  beq cr6, 0x827f15bc
	if ctx.cr[6].eq {
	pc = 0x827F15BC; continue 'dispatch;
	}
	// 827F0F34: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0F38: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F0F3C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F0F40: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F0F44: 4E800421  bctrl
	ctx.lr = 0x827F0F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0F48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F0F4C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0F50: 81090044  lwz r8, 0x44(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 827F0F54: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827F0F58: 4E800421  bctrl
	ctx.lr = 0x827F0F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F0F60: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F0F64: 419A065C  beq cr6, 0x827f15c0
	if ctx.cr[6].eq {
	pc = 0x827F15C0; continue 'dispatch;
	}
	// 827F0F68: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827F0F6C: 83BF0000  lwz r29, 0(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0F70: 386B2304  addi r3, r11, 0x2304
	ctx.r[3].s64 = ctx.r[11].s64 + 8964;
	// 827F0F74: 4B9981CD  bl 0x82189140
	ctx.lr = 0x827F0F78;
	sub_82189140(ctx, base);
	// 827F0F78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F0F7C: 815D0054  lwz r10, 0x54(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F0F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0F84: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F0F88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F0F8C: 4E800421  bctrl
	ctx.lr = 0x827F0F90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0F90: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827F0F94: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827F0F98: 419A0628  beq cr6, 0x827f15c0
	if ctx.cr[6].eq {
	pc = 0x827F15C0; continue 'dispatch;
	}
	// 827F0F9C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F0FA0: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F0FA4: 386B9FD0  addi r3, r11, -0x6030
	ctx.r[3].s64 = ctx.r[11].s64 + -24624;
	// 827F0FA8: 4B998199  bl 0x82189140
	ctx.lr = 0x827F0FAC;
	sub_82189140(ctx, base);
	// 827F0FAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F0FB0: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F0FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F0FB8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F0FBC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F0FC0: 4E800421  bctrl
	ctx.lr = 0x827F0FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F0FC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F0FC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F0FCC: 419A05F4  beq cr6, 0x827f15c0
	if ctx.cr[6].eq {
	pc = 0x827F15C0; continue 'dispatch;
	}
	// 827F0FD0: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827F0FD4: 9AE10054  stb r23, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u8 ) };
	// 827F0FD8: 3BF90004  addi r31, r25, 4
	ctx.r[31].s64 = ctx.r[25].s64 + 4;
	// 827F0FDC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 827F0FE0: 3BA00013  li r29, 0x13
	ctx.r[29].s64 = 19;
	// 827F0FE4: EB610050  ld r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
            }
            0x827F0FE8 => {
    //   block [0x827F0FE8..0x827F0FFC)
	// 827F0FE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F0FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F0FF0: 409A000C  bne cr6, 0x827f0ffc
	if !ctx.cr[6].eq {
	pc = 0x827F0FFC; continue 'dispatch;
	}
	// 827F0FF4: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 827F0FF8: 48000010  b 0x827f1008
	pc = 0x827F1008; continue 'dispatch;
            }
            0x827F0FFC => {
    //   block [0x827F0FFC..0x827F1008)
	// 827F0FFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1000: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1004: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F1008; continue 'dispatch;
            }
            0x827F1008 => {
    //   block [0x827F1008..0x827F1034)
	// 827F1008: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F100C: 419A0034  beq cr6, 0x827f1040
	if ctx.cr[6].eq {
	pc = 0x827F1040; continue 'dispatch;
	}
	// 827F1010: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1014: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1018: 7D0A1E70  srawi r10, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 827F101C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1020: 40980020  bge cr6, 0x827f1040
	if !ctx.cr[6].lt {
	pc = 0x827F1040; continue 'dispatch;
	}
	// 827F1024: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1028: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F102C: 419A0008  beq cr6, 0x827f1034
	if ctx.cr[6].eq {
	pc = 0x827F1034; continue 'dispatch;
	}
	// 827F1030: FB6B0000  std r27, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u64 ) };
	pc = 0x827F1034; continue 'dispatch;
            }
            0x827F1034 => {
    //   block [0x827F1034..0x827F1040)
	// 827F1034: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 827F1038: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F103C: 48000030  b 0x827f106c
	pc = 0x827F106C; continue 'dispatch;
            }
            0x827F1040 => {
    //   block [0x827F1040..0x827F1050)
	// 827F1040: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1044: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1048: 40990008  ble cr6, 0x827f1050
	if !ctx.cr[6].gt {
	pc = 0x827F1050; continue 'dispatch;
	}
	// 827F104C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1050; continue 'dispatch;
            }
            0x827F1050 => {
    //   block [0x827F1050..0x827F106C)
	// 827F1050: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F1054: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 827F1058: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827F105C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F1060: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F1064: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F1068: 4BCACB51  bl 0x8249dbb8
	ctx.lr = 0x827F106C;
	sub_8249DBB8(ctx, base);
	pc = 0x827F106C; continue 'dispatch;
            }
            0x827F106C => {
    //   block [0x827F106C..0x827F10B4)
	// 827F106C: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827F1070: 4082FF78  bne 0x827f0fe8
	if !ctx.cr[0].eq {
	pc = 0x827F0FE8; continue 'dispatch;
	}
	// 827F1074: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F1078: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827F107C: 48000B95  bl 0x827f1c10
	ctx.lr = 0x827F1080;
	sub_827F1C10(ctx, base);
	// 827F1080: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F1084: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827F1088: 48000C89  bl 0x827f1d10
	ctx.lr = 0x827F108C;
	sub_827F1D10(ctx, base);
	// 827F108C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1090: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1094: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827F1098: 48000D81  bl 0x827f1e18
	ctx.lr = 0x827F109C;
	sub_827F1E18(ctx, base);
	// 827F109C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F10A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827F10A4: 4800104D  bl 0x827f20f0
	ctx.lr = 0x827F10A8;
	sub_827F20F0(ctx, base);
	// 827F10A8: 3BF90018  addi r31, r25, 0x18
	ctx.r[31].s64 = ctx.r[25].s64 + 24;
	// 827F10AC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 827F10B0: 3BC0000D  li r30, 0xd
	ctx.r[30].s64 = 13;
	pc = 0x827F10B4; continue 'dispatch;
            }
            0x827F10B4 => {
    //   block [0x827F10B4..0x827F10C8)
	// 827F10B4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F10B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F10BC: 409A000C  bne cr6, 0x827f10c8
	if !ctx.cr[6].eq {
	pc = 0x827F10C8; continue 'dispatch;
	}
	// 827F10C0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 827F10C4: 48000010  b 0x827f10d4
	pc = 0x827F10D4; continue 'dispatch;
            }
            0x827F10C8 => {
    //   block [0x827F10C8..0x827F10D4)
	// 827F10C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F10CC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F10D0: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x827F10D4; continue 'dispatch;
            }
            0x827F10D4 => {
    //   block [0x827F10D4..0x827F1104)
	// 827F10D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F10D8: 419A002C  beq cr6, 0x827f1104
	if ctx.cr[6].eq {
	pc = 0x827F1104; continue 'dispatch;
	}
	// 827F10DC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F10E0: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F10E4: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F10E8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F10EC: 40980018  bge cr6, 0x827f1104
	if !ctx.cr[6].lt {
	pc = 0x827F1104; continue 'dispatch;
	}
	// 827F10F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F10F4: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 827F10F8: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 827F10FC: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F1100: 48000030  b 0x827f1130
	pc = 0x827F1130; continue 'dispatch;
            }
            0x827F1104 => {
    //   block [0x827F1104..0x827F1114)
	// 827F1104: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1108: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F110C: 40990008  ble cr6, 0x827f1114
	if !ctx.cr[6].gt {
	pc = 0x827F1114; continue 'dispatch;
	}
	// 827F1110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1114; continue 'dispatch;
            }
            0x827F1114 => {
    //   block [0x827F1114..0x827F1130)
	// 827F1114: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 827F1118: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F111C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F1120: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827F1124: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F1128: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F112C: 480011AD  bl 0x827f22d8
	ctx.lr = 0x827F1130;
	sub_827F22D8(ctx, base);
	pc = 0x827F1130; continue 'dispatch;
            }
            0x827F1130 => {
    //   block [0x827F1130..0x827F1164)
	// 827F1130: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 827F1134: 4082FF80  bne 0x827f10b4
	if !ctx.cr[0].eq {
	pc = 0x827F10B4; continue 'dispatch;
	}
	// 827F1138: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F113C: 4BA2E11D  bl 0x8221f258
	ctx.lr = 0x827F1140;
	sub_8221F258(ctx, base);
	// 827F1140: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1144: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F1148: 419A001C  beq cr6, 0x827f1164
	if ctx.cr[6].eq {
	pc = 0x827F1164; continue 'dispatch;
	}
	// 827F114C: 4BFFF58D  bl 0x827f06d8
	ctx.lr = 0x827F1150;
	sub_827F06D8(ctx, base);
	// 827F1150: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1154: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F1158: 394BA0B0  addi r10, r11, -0x5f50
	ctx.r[10].s64 = ctx.r[11].s64 + -24400;
	// 827F115C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F1160: 48000008  b 0x827f1168
	pc = 0x827F1168; continue 'dispatch;
            }
            0x827F1164 => {
    //   block [0x827F1164..0x827F1168)
	// 827F1164: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F1168; continue 'dispatch;
            }
            0x827F1168 => {
    //   block [0x827F1168..0x827F1184)
	// 827F1168: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F116C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1170: 419A0014  beq cr6, 0x827f1184
	if ctx.cr[6].eq {
	pc = 0x827F1184; continue 'dispatch;
	}
	// 827F1174: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1178: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F117C: 7D0A1671  srawi. r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F1180: 40820008  bne 0x827f1188
	if !ctx.cr[0].eq {
	pc = 0x827F1188; continue 'dispatch;
	}
	pc = 0x827F1184; continue 'dispatch;
            }
            0x827F1184 => {
    //   block [0x827F1184..0x827F1188)
	// 827F1184: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1188; continue 'dispatch;
            }
            0x827F1188 => {
    //   block [0x827F1188..0x827F11B8)
	// 827F1188: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F118C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1190: 4BA2E0C9  bl 0x8221f258
	ctx.lr = 0x827F1194;
	sub_8221F258(ctx, base);
	// 827F1194: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1198: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F119C: 419A001C  beq cr6, 0x827f11b8
	if ctx.cr[6].eq {
	pc = 0x827F11B8; continue 'dispatch;
	}
	// 827F11A0: 4BFFF539  bl 0x827f06d8
	ctx.lr = 0x827F11A4;
	sub_827F06D8(ctx, base);
	// 827F11A4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F11A8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F11AC: 394BA0C4  addi r10, r11, -0x5f3c
	ctx.r[10].s64 = ctx.r[11].s64 + -24380;
	// 827F11B0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F11B4: 48000008  b 0x827f11bc
	pc = 0x827F11BC; continue 'dispatch;
            }
            0x827F11B8 => {
    //   block [0x827F11B8..0x827F11BC)
	// 827F11B8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F11BC; continue 'dispatch;
            }
            0x827F11BC => {
    //   block [0x827F11BC..0x827F11DC)
	// 827F11BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F11C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F11C4: 419A0018  beq cr6, 0x827f11dc
	if ctx.cr[6].eq {
	pc = 0x827F11DC; continue 'dispatch;
	}
	// 827F11C8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F11CC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F11D0: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F11D4: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827F11D8: 41990008  bgt cr6, 0x827f11e0
	if ctx.cr[6].gt {
	pc = 0x827F11E0; continue 'dispatch;
	}
	pc = 0x827F11DC; continue 'dispatch;
            }
            0x827F11DC => {
    //   block [0x827F11DC..0x827F11E0)
	// 827F11DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F11E0; continue 'dispatch;
            }
            0x827F11E0 => {
    //   block [0x827F11E0..0x827F1210)
	// 827F11E0: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F11E4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F11E8: 4BA2E071  bl 0x8221f258
	ctx.lr = 0x827F11EC;
	sub_8221F258(ctx, base);
	// 827F11EC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F11F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F11F4: 419A001C  beq cr6, 0x827f1210
	if ctx.cr[6].eq {
	pc = 0x827F1210; continue 'dispatch;
	}
	// 827F11F8: 4BFFF4E1  bl 0x827f06d8
	ctx.lr = 0x827F11FC;
	sub_827F06D8(ctx, base);
	// 827F11FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1200: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F1204: 394BA0EC  addi r10, r11, -0x5f14
	ctx.r[10].s64 = ctx.r[11].s64 + -24340;
	// 827F1208: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F120C: 48000008  b 0x827f1214
	pc = 0x827F1214; continue 'dispatch;
            }
            0x827F1210 => {
    //   block [0x827F1210..0x827F1214)
	// 827F1210: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F1214; continue 'dispatch;
            }
            0x827F1214 => {
    //   block [0x827F1214..0x827F1234)
	// 827F1214: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F121C: 419A0018  beq cr6, 0x827f1234
	if ctx.cr[6].eq {
	pc = 0x827F1234; continue 'dispatch;
	}
	// 827F1220: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1224: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1228: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F122C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 827F1230: 41990008  bgt cr6, 0x827f1238
	if ctx.cr[6].gt {
	pc = 0x827F1238; continue 'dispatch;
	}
	pc = 0x827F1234; continue 'dispatch;
            }
            0x827F1234 => {
    //   block [0x827F1234..0x827F1238)
	// 827F1234: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1238; continue 'dispatch;
            }
            0x827F1238 => {
    //   block [0x827F1238..0x827F1268)
	// 827F1238: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 827F123C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1240: 4BA2E019  bl 0x8221f258
	ctx.lr = 0x827F1244;
	sub_8221F258(ctx, base);
	// 827F1244: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1248: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F124C: 419A001C  beq cr6, 0x827f1268
	if ctx.cr[6].eq {
	pc = 0x827F1268; continue 'dispatch;
	}
	// 827F1250: 4BFFF489  bl 0x827f06d8
	ctx.lr = 0x827F1254;
	sub_827F06D8(ctx, base);
	// 827F1254: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1258: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F125C: 394BA100  addi r10, r11, -0x5f00
	ctx.r[10].s64 = ctx.r[11].s64 + -24320;
	// 827F1260: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F1264: 48000008  b 0x827f126c
	pc = 0x827F126C; continue 'dispatch;
            }
            0x827F1268 => {
    //   block [0x827F1268..0x827F126C)
	// 827F1268: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F126C; continue 'dispatch;
            }
            0x827F126C => {
    //   block [0x827F126C..0x827F128C)
	// 827F126C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1274: 419A0018  beq cr6, 0x827f128c
	if ctx.cr[6].eq {
	pc = 0x827F128C; continue 'dispatch;
	}
	// 827F1278: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F127C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1280: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F1284: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 827F1288: 41990008  bgt cr6, 0x827f1290
	if ctx.cr[6].gt {
	pc = 0x827F1290; continue 'dispatch;
	}
	pc = 0x827F128C; continue 'dispatch;
            }
            0x827F128C => {
    //   block [0x827F128C..0x827F1290)
	// 827F128C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1290; continue 'dispatch;
            }
            0x827F1290 => {
    //   block [0x827F1290..0x827F12C0)
	// 827F1290: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 827F1294: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1298: 4BA2DFC1  bl 0x8221f258
	ctx.lr = 0x827F129C;
	sub_8221F258(ctx, base);
	// 827F129C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F12A0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F12A4: 419A001C  beq cr6, 0x827f12c0
	if ctx.cr[6].eq {
	pc = 0x827F12C0; continue 'dispatch;
	}
	// 827F12A8: 4BFFF431  bl 0x827f06d8
	ctx.lr = 0x827F12AC;
	sub_827F06D8(ctx, base);
	// 827F12AC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F12B0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F12B4: 394BA114  addi r10, r11, -0x5eec
	ctx.r[10].s64 = ctx.r[11].s64 + -24300;
	// 827F12B8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F12BC: 48000008  b 0x827f12c4
	pc = 0x827F12C4; continue 'dispatch;
            }
            0x827F12C0 => {
    //   block [0x827F12C0..0x827F12C4)
	// 827F12C0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F12C4; continue 'dispatch;
            }
            0x827F12C4 => {
    //   block [0x827F12C4..0x827F12E4)
	// 827F12C4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F12C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F12CC: 419A0018  beq cr6, 0x827f12e4
	if ctx.cr[6].eq {
	pc = 0x827F12E4; continue 'dispatch;
	}
	// 827F12D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F12D4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F12D8: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F12DC: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 827F12E0: 41990008  bgt cr6, 0x827f12e8
	if ctx.cr[6].gt {
	pc = 0x827F12E8; continue 'dispatch;
	}
	pc = 0x827F12E4; continue 'dispatch;
            }
            0x827F12E4 => {
    //   block [0x827F12E4..0x827F12E8)
	// 827F12E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F12E8; continue 'dispatch;
            }
            0x827F12E8 => {
    //   block [0x827F12E8..0x827F1318)
	// 827F12E8: 912B0010  stw r9, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 827F12EC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F12F0: 4BA2DF69  bl 0x8221f258
	ctx.lr = 0x827F12F4;
	sub_8221F258(ctx, base);
	// 827F12F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F12F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F12FC: 419A001C  beq cr6, 0x827f1318
	if ctx.cr[6].eq {
	pc = 0x827F1318; continue 'dispatch;
	}
	// 827F1300: 4BFFF3D9  bl 0x827f06d8
	ctx.lr = 0x827F1304;
	sub_827F06D8(ctx, base);
	// 827F1304: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1308: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F130C: 394BA128  addi r10, r11, -0x5ed8
	ctx.r[10].s64 = ctx.r[11].s64 + -24280;
	// 827F1310: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F1314: 48000008  b 0x827f131c
	pc = 0x827F131C; continue 'dispatch;
            }
            0x827F1318 => {
    //   block [0x827F1318..0x827F131C)
	// 827F1318: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F131C; continue 'dispatch;
            }
            0x827F131C => {
    //   block [0x827F131C..0x827F133C)
	// 827F131C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1324: 419A0018  beq cr6, 0x827f133c
	if ctx.cr[6].eq {
	pc = 0x827F133C; continue 'dispatch;
	}
	// 827F1328: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F132C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1330: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F1334: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 827F1338: 41990008  bgt cr6, 0x827f1340
	if ctx.cr[6].gt {
	pc = 0x827F1340; continue 'dispatch;
	}
	pc = 0x827F133C; continue 'dispatch;
            }
            0x827F133C => {
    //   block [0x827F133C..0x827F1340)
	// 827F133C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1340; continue 'dispatch;
            }
            0x827F1340 => {
    //   block [0x827F1340..0x827F1370)
	// 827F1340: 912B0014  stw r9, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 827F1344: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1348: 4BA2DF11  bl 0x8221f258
	ctx.lr = 0x827F134C;
	sub_8221F258(ctx, base);
	// 827F134C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1350: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F1354: 419A001C  beq cr6, 0x827f1370
	if ctx.cr[6].eq {
	pc = 0x827F1370; continue 'dispatch;
	}
	// 827F1358: 4BFFF381  bl 0x827f06d8
	ctx.lr = 0x827F135C;
	sub_827F06D8(ctx, base);
	// 827F135C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1360: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F1364: 394BA13C  addi r10, r11, -0x5ec4
	ctx.r[10].s64 = ctx.r[11].s64 + -24260;
	// 827F1368: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F136C: 48000008  b 0x827f1374
	pc = 0x827F1374; continue 'dispatch;
            }
            0x827F1370 => {
    //   block [0x827F1370..0x827F1374)
	// 827F1370: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F1374; continue 'dispatch;
            }
            0x827F1374 => {
    //   block [0x827F1374..0x827F1394)
	// 827F1374: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F137C: 419A0018  beq cr6, 0x827f1394
	if ctx.cr[6].eq {
	pc = 0x827F1394; continue 'dispatch;
	}
	// 827F1380: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1384: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1388: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F138C: 2B0A0006  cmplwi cr6, r10, 6
	ctx.cr[6].compare_u32(ctx.r[10].u32, 6 as u32, &mut ctx.xer);
	// 827F1390: 41990008  bgt cr6, 0x827f1398
	if ctx.cr[6].gt {
	pc = 0x827F1398; continue 'dispatch;
	}
	pc = 0x827F1394; continue 'dispatch;
            }
            0x827F1394 => {
    //   block [0x827F1394..0x827F1398)
	// 827F1394: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1398; continue 'dispatch;
            }
            0x827F1398 => {
    //   block [0x827F1398..0x827F13C8)
	// 827F1398: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 827F139C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F13A0: 4BA2DEB9  bl 0x8221f258
	ctx.lr = 0x827F13A4;
	sub_8221F258(ctx, base);
	// 827F13A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F13A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F13AC: 419A001C  beq cr6, 0x827f13c8
	if ctx.cr[6].eq {
	pc = 0x827F13C8; continue 'dispatch;
	}
	// 827F13B0: 4BFFF329  bl 0x827f06d8
	ctx.lr = 0x827F13B4;
	sub_827F06D8(ctx, base);
	// 827F13B4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F13B8: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F13BC: 394BA150  addi r10, r11, -0x5eb0
	ctx.r[10].s64 = ctx.r[11].s64 + -24240;
	// 827F13C0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F13C4: 48000008  b 0x827f13cc
	pc = 0x827F13CC; continue 'dispatch;
            }
            0x827F13C8 => {
    //   block [0x827F13C8..0x827F13CC)
	// 827F13C8: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F13CC; continue 'dispatch;
            }
            0x827F13CC => {
    //   block [0x827F13CC..0x827F13EC)
	// 827F13CC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F13D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F13D4: 419A0018  beq cr6, 0x827f13ec
	if ctx.cr[6].eq {
	pc = 0x827F13EC; continue 'dispatch;
	}
	// 827F13D8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F13DC: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F13E0: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F13E4: 2B0A0007  cmplwi cr6, r10, 7
	ctx.cr[6].compare_u32(ctx.r[10].u32, 7 as u32, &mut ctx.xer);
	// 827F13E8: 41990008  bgt cr6, 0x827f13f0
	if ctx.cr[6].gt {
	pc = 0x827F13F0; continue 'dispatch;
	}
	pc = 0x827F13EC; continue 'dispatch;
            }
            0x827F13EC => {
    //   block [0x827F13EC..0x827F13F0)
	// 827F13EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F13F0; continue 'dispatch;
            }
            0x827F13F0 => {
    //   block [0x827F13F0..0x827F1420)
	// 827F13F0: 912B001C  stw r9, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 827F13F4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F13F8: 4BA2DE61  bl 0x8221f258
	ctx.lr = 0x827F13FC;
	sub_8221F258(ctx, base);
	// 827F13FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1400: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F1404: 419A001C  beq cr6, 0x827f1420
	if ctx.cr[6].eq {
	pc = 0x827F1420; continue 'dispatch;
	}
	// 827F1408: 4BFFF2D1  bl 0x827f06d8
	ctx.lr = 0x827F140C;
	sub_827F06D8(ctx, base);
	// 827F140C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1410: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F1414: 394BA15C  addi r10, r11, -0x5ea4
	ctx.r[10].s64 = ctx.r[11].s64 + -24228;
	// 827F1418: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F141C: 48000008  b 0x827f1424
	pc = 0x827F1424; continue 'dispatch;
            }
            0x827F1420 => {
    //   block [0x827F1420..0x827F1424)
	// 827F1420: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F1424; continue 'dispatch;
            }
            0x827F1424 => {
    //   block [0x827F1424..0x827F1444)
	// 827F1424: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F142C: 419A0018  beq cr6, 0x827f1444
	if ctx.cr[6].eq {
	pc = 0x827F1444; continue 'dispatch;
	}
	// 827F1430: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1434: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1438: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F143C: 2B0A0008  cmplwi cr6, r10, 8
	ctx.cr[6].compare_u32(ctx.r[10].u32, 8 as u32, &mut ctx.xer);
	// 827F1440: 41990008  bgt cr6, 0x827f1448
	if ctx.cr[6].gt {
	pc = 0x827F1448; continue 'dispatch;
	}
	pc = 0x827F1444; continue 'dispatch;
            }
            0x827F1444 => {
    //   block [0x827F1444..0x827F1448)
	// 827F1444: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1448; continue 'dispatch;
            }
            0x827F1448 => {
    //   block [0x827F1448..0x827F1478)
	// 827F1448: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 827F144C: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1450: 4BA2DE09  bl 0x8221f258
	ctx.lr = 0x827F1454;
	sub_8221F258(ctx, base);
	// 827F1454: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1458: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F145C: 419A001C  beq cr6, 0x827f1478
	if ctx.cr[6].eq {
	pc = 0x827F1478; continue 'dispatch;
	}
	// 827F1460: 4BFFF279  bl 0x827f06d8
	ctx.lr = 0x827F1464;
	sub_827F06D8(ctx, base);
	// 827F1464: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1468: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F146C: 394BA170  addi r10, r11, -0x5e90
	ctx.r[10].s64 = ctx.r[11].s64 + -24208;
	// 827F1470: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F1474: 48000008  b 0x827f147c
	pc = 0x827F147C; continue 'dispatch;
            }
            0x827F1478 => {
    //   block [0x827F1478..0x827F147C)
	// 827F1478: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F147C; continue 'dispatch;
            }
            0x827F147C => {
    //   block [0x827F147C..0x827F149C)
	// 827F147C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1480: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1484: 419A0018  beq cr6, 0x827f149c
	if ctx.cr[6].eq {
	pc = 0x827F149C; continue 'dispatch;
	}
	// 827F1488: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F148C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1490: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F1494: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 827F1498: 41990008  bgt cr6, 0x827f14a0
	if ctx.cr[6].gt {
	pc = 0x827F14A0; continue 'dispatch;
	}
	pc = 0x827F149C; continue 'dispatch;
            }
            0x827F149C => {
    //   block [0x827F149C..0x827F14A0)
	// 827F149C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F14A0; continue 'dispatch;
            }
            0x827F14A0 => {
    //   block [0x827F14A0..0x827F14D0)
	// 827F14A0: 912B0024  stw r9, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 827F14A4: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F14A8: 4BA2DDB1  bl 0x8221f258
	ctx.lr = 0x827F14AC;
	sub_8221F258(ctx, base);
	// 827F14AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F14B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F14B4: 419A001C  beq cr6, 0x827f14d0
	if ctx.cr[6].eq {
	pc = 0x827F14D0; continue 'dispatch;
	}
	// 827F14B8: 4BFFF221  bl 0x827f06d8
	ctx.lr = 0x827F14BC;
	sub_827F06D8(ctx, base);
	// 827F14BC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F14C0: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F14C4: 394BA184  addi r10, r11, -0x5e7c
	ctx.r[10].s64 = ctx.r[11].s64 + -24188;
	// 827F14C8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F14CC: 48000008  b 0x827f14d4
	pc = 0x827F14D4; continue 'dispatch;
            }
            0x827F14D0 => {
    //   block [0x827F14D0..0x827F14D4)
	// 827F14D0: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F14D4; continue 'dispatch;
            }
            0x827F14D4 => {
    //   block [0x827F14D4..0x827F14F4)
	// 827F14D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F14D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F14DC: 419A0018  beq cr6, 0x827f14f4
	if ctx.cr[6].eq {
	pc = 0x827F14F4; continue 'dispatch;
	}
	// 827F14E0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F14E4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F14E8: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F14EC: 2B0A000A  cmplwi cr6, r10, 0xa
	ctx.cr[6].compare_u32(ctx.r[10].u32, 10 as u32, &mut ctx.xer);
	// 827F14F0: 41990008  bgt cr6, 0x827f14f8
	if ctx.cr[6].gt {
	pc = 0x827F14F8; continue 'dispatch;
	}
	pc = 0x827F14F4; continue 'dispatch;
            }
            0x827F14F4 => {
    //   block [0x827F14F4..0x827F14F8)
	// 827F14F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F14F8; continue 'dispatch;
            }
            0x827F14F8 => {
    //   block [0x827F14F8..0x827F1528)
	// 827F14F8: 912B0028  stw r9, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 827F14FC: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1500: 4BA2DD59  bl 0x8221f258
	ctx.lr = 0x827F1504;
	sub_8221F258(ctx, base);
	// 827F1504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1508: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F150C: 419A001C  beq cr6, 0x827f1528
	if ctx.cr[6].eq {
	pc = 0x827F1528; continue 'dispatch;
	}
	// 827F1510: 4BFFF1C9  bl 0x827f06d8
	ctx.lr = 0x827F1514;
	sub_827F06D8(ctx, base);
	// 827F1514: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1518: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F151C: 394BA198  addi r10, r11, -0x5e68
	ctx.r[10].s64 = ctx.r[11].s64 + -24168;
	// 827F1520: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F1524: 48000008  b 0x827f152c
	pc = 0x827F152C; continue 'dispatch;
            }
            0x827F1528 => {
    //   block [0x827F1528..0x827F152C)
	// 827F1528: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F152C; continue 'dispatch;
            }
            0x827F152C => {
    //   block [0x827F152C..0x827F154C)
	// 827F152C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1530: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1534: 419A0018  beq cr6, 0x827f154c
	if ctx.cr[6].eq {
	pc = 0x827F154C; continue 'dispatch;
	}
	// 827F1538: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F153C: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1540: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F1544: 2B0A000B  cmplwi cr6, r10, 0xb
	ctx.cr[6].compare_u32(ctx.r[10].u32, 11 as u32, &mut ctx.xer);
	// 827F1548: 41990008  bgt cr6, 0x827f1550
	if ctx.cr[6].gt {
	pc = 0x827F1550; continue 'dispatch;
	}
	pc = 0x827F154C; continue 'dispatch;
            }
            0x827F154C => {
    //   block [0x827F154C..0x827F1550)
	// 827F154C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1550; continue 'dispatch;
            }
            0x827F1550 => {
    //   block [0x827F1550..0x827F1580)
	// 827F1550: 912B002C  stw r9, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 827F1554: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 827F1558: 4BA2DD01  bl 0x8221f258
	ctx.lr = 0x827F155C;
	sub_8221F258(ctx, base);
	// 827F155C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1560: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F1564: 419A001C  beq cr6, 0x827f1580
	if ctx.cr[6].eq {
	pc = 0x827F1580; continue 'dispatch;
	}
	// 827F1568: 4BFFF171  bl 0x827f06d8
	ctx.lr = 0x827F156C;
	sub_827F06D8(ctx, base);
	// 827F156C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1570: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	// 827F1574: 394BA1AC  addi r10, r11, -0x5e54
	ctx.r[10].s64 = ctx.r[11].s64 + -24148;
	// 827F1578: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F157C: 48000008  b 0x827f1584
	pc = 0x827F1584; continue 'dispatch;
            }
            0x827F1580 => {
    //   block [0x827F1580..0x827F1584)
	// 827F1580: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	pc = 0x827F1584; continue 'dispatch;
            }
            0x827F1584 => {
    //   block [0x827F1584..0x827F15A4)
	// 827F1584: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F158C: 419A0018  beq cr6, 0x827f15a4
	if ctx.cr[6].eq {
	pc = 0x827F15A4; continue 'dispatch;
	}
	// 827F1590: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1594: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1598: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F159C: 2B0A000C  cmplwi cr6, r10, 0xc
	ctx.cr[6].compare_u32(ctx.r[10].u32, 12 as u32, &mut ctx.xer);
	// 827F15A0: 41990008  bgt cr6, 0x827f15a8
	if ctx.cr[6].gt {
	pc = 0x827F15A8; continue 'dispatch;
	}
	pc = 0x827F15A4; continue 'dispatch;
            }
            0x827F15A4 => {
    //   block [0x827F15A4..0x827F15A8)
	// 827F15A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F15A8; continue 'dispatch;
            }
            0x827F15A8 => {
    //   block [0x827F15A8..0x827F15BC)
	// 827F15A8: 912B0030  stw r9, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[9].u32 ) };
	// 827F15AC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827F15B0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827F15B4: 480002CD  bl 0x827f1880
	ctx.lr = 0x827F15B8;
	sub_827F1880(ctx, base);
	// 827F15B8: 9B590014  stb r26, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	pc = 0x827F15BC; continue 'dispatch;
            }
            0x827F15BC => {
    //   block [0x827F15BC..0x827F15C0)
	// 827F15BC: 9AF90015  stb r23, 0x15(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(21 as u32), ctx.r[23].u8 ) };
	pc = 0x827F15C0; continue 'dispatch;
            }
            0x827F15C0 => {
    //   block [0x827F15C0..0x827F15C8)
	// 827F15C0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827F15C4: 484B7E80  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F15C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F15C8 size=300
    let mut pc: u32 = 0x827F15C8;
    'dispatch: loop {
        match pc {
            0x827F15C8 => {
    //   block [0x827F15C8..0x827F15EC)
	// 827F15C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F15CC: 484B7E35  bl 0x82ca9400
	ctx.lr = 0x827F15D0;
	sub_82CA93D0(ctx, base);
	// 827F15D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F15D4: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F15D8: 3B430018  addi r26, r3, 0x18
	ctx.r[26].s64 = ctx.r[3].s64 + 24;
	// 827F15DC: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F15E0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F15E4: 40990008  ble cr6, 0x827f15ec
	if !ctx.cr[6].gt {
	pc = 0x827F15EC; continue 'dispatch;
	}
	// 827F15E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F15EC; continue 'dispatch;
            }
            0x827F15EC => {
    //   block [0x827F15EC..0x827F15F0)
	// 827F15EC: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	pc = 0x827F15F0; continue 'dispatch;
            }
            0x827F15F0 => {
    //   block [0x827F15F0..0x827F1604)
	// 827F15F0: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F15F4: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F15F8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F15FC: 40990008  ble cr6, 0x827f1604
	if !ctx.cr[6].gt {
	pc = 0x827F1604; continue 'dispatch;
	}
	// 827F1600: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1604; continue 'dispatch;
            }
            0x827F1604 => {
    //   block [0x827F1604..0x827F1610)
	// 827F1604: 7F1AD040  cmplw cr6, r26, r26
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F1608: 419A0008  beq cr6, 0x827f1610
	if ctx.cr[6].eq {
	pc = 0x827F1610; continue 'dispatch;
	}
	// 827F160C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1610; continue 'dispatch;
            }
            0x827F1610 => {
    //   block [0x827F1610..0x827F1624)
	// 827F1610: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1614: 419A00D8  beq cr6, 0x827f16ec
	if ctx.cr[6].eq {
	pc = 0x827F16EC; continue 'dispatch;
	}
	// 827F1618: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F161C: 41980008  blt cr6, 0x827f1624
	if ctx.cr[6].lt {
	pc = 0x827F1624; continue 'dispatch;
	}
	// 827F1620: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1624; continue 'dispatch;
            }
            0x827F1624 => {
    //   block [0x827F1624..0x827F1640)
	// 827F1624: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1628: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 827F162C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 827F1630: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1634: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827F1638: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F163C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x827F1640; continue 'dispatch;
            }
            0x827F1640 => {
    //   block [0x827F1640..0x827F1654)
	// 827F1640: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1644: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1648: 419A000C  beq cr6, 0x827f1654
	if ctx.cr[6].eq {
	pc = 0x827F1654; continue 'dispatch;
	}
	// 827F164C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827F1650: 419A0008  beq cr6, 0x827f1658
	if ctx.cr[6].eq {
	pc = 0x827F1658; continue 'dispatch;
	}
	pc = 0x827F1654; continue 'dispatch;
            }
            0x827F1654 => {
    //   block [0x827F1654..0x827F1658)
	// 827F1654: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1658; continue 'dispatch;
            }
            0x827F1658 => {
    //   block [0x827F1658..0x827F166C)
	// 827F1658: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F165C: 419A0078  beq cr6, 0x827f16d4
	if ctx.cr[6].eq {
	pc = 0x827F16D4; continue 'dispatch;
	}
	// 827F1660: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1664: 409A0008  bne cr6, 0x827f166c
	if !ctx.cr[6].eq {
	pc = 0x827F166C; continue 'dispatch;
	}
	// 827F1668: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F166C; continue 'dispatch;
            }
            0x827F166C => {
    //   block [0x827F166C..0x827F167C)
	// 827F166C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1670: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1674: 409A0008  bne cr6, 0x827f167c
	if !ctx.cr[6].eq {
	pc = 0x827F167C; continue 'dispatch;
	}
	// 827F1678: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F167C; continue 'dispatch;
            }
            0x827F167C => {
    //   block [0x827F167C..0x827F1684)
	// 827F167C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F1680: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x827F1684; continue 'dispatch;
            }
            0x827F1684 => {
    //   block [0x827F1684..0x827F1694)
	// 827F1684: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1688: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F168C: 409A0008  bne cr6, 0x827f1694
	if !ctx.cr[6].eq {
	pc = 0x827F1694; continue 'dispatch;
	}
	// 827F1690: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1694; continue 'dispatch;
            }
            0x827F1694 => {
    //   block [0x827F1694..0x827F16C0)
	// 827F1694: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F1698: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F169C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F16A0: 419A0020  beq cr6, 0x827f16c0
	if ctx.cr[6].eq {
	pc = 0x827F16C0; continue 'dispatch;
	}
	// 827F16A4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F16A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F16AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F16B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F16B4: 4E800421  bctrl
	ctx.lr = 0x827F16B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F16B8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827F16BC: 4BFFFFC8  b 0x827f1684
	pc = 0x827F1684; continue 'dispatch;
            }
            0x827F16C0 => {
    //   block [0x827F16C0..0x827F16D4)
	// 827F16C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F16C4: 4BD65195  bl 0x82556858
	ctx.lr = 0x827F16C8;
	sub_82556858(ctx, base);
	// 827F16C8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F16CC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F16D0: 4BFFFF70  b 0x827f1640
	pc = 0x827F1640; continue 'dispatch;
            }
            0x827F16D4 => {
    //   block [0x827F16D4..0x827F16E4)
	// 827F16D4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F16D8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F16DC: 41980008  blt cr6, 0x827f16e4
	if ctx.cr[6].lt {
	pc = 0x827F16E4; continue 'dispatch;
	}
	// 827F16E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F16E4; continue 'dispatch;
            }
            0x827F16E4 => {
    //   block [0x827F16E4..0x827F16EC)
	// 827F16E4: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 827F16E8: 4BFFFF08  b 0x827f15f0
	pc = 0x827F15F0; continue 'dispatch;
            }
            0x827F16EC => {
    //   block [0x827F16EC..0x827F16F4)
	// 827F16EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F16F0: 484B7D60  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F16F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F16F8 size=300
    let mut pc: u32 = 0x827F16F8;
    'dispatch: loop {
        match pc {
            0x827F16F8 => {
    //   block [0x827F16F8..0x827F171C)
	// 827F16F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F16FC: 484B7D05  bl 0x82ca9400
	ctx.lr = 0x827F1700;
	sub_82CA93D0(ctx, base);
	// 827F1700: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1704: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F1708: 3B430018  addi r26, r3, 0x18
	ctx.r[26].s64 = ctx.r[3].s64 + 24;
	// 827F170C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1710: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1714: 40990008  ble cr6, 0x827f171c
	if !ctx.cr[6].gt {
	pc = 0x827F171C; continue 'dispatch;
	}
	// 827F1718: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F171C; continue 'dispatch;
            }
            0x827F171C => {
    //   block [0x827F171C..0x827F1720)
	// 827F171C: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	pc = 0x827F1720; continue 'dispatch;
            }
            0x827F1720 => {
    //   block [0x827F1720..0x827F1734)
	// 827F1720: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1724: 813A0004  lwz r9, 4(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1728: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F172C: 40990008  ble cr6, 0x827f1734
	if !ctx.cr[6].gt {
	pc = 0x827F1734; continue 'dispatch;
	}
	// 827F1730: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1734; continue 'dispatch;
            }
            0x827F1734 => {
    //   block [0x827F1734..0x827F1740)
	// 827F1734: 7F1AD040  cmplw cr6, r26, r26
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F1738: 419A0008  beq cr6, 0x827f1740
	if ctx.cr[6].eq {
	pc = 0x827F1740; continue 'dispatch;
	}
	// 827F173C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1740; continue 'dispatch;
            }
            0x827F1740 => {
    //   block [0x827F1740..0x827F1754)
	// 827F1740: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1744: 419A00D8  beq cr6, 0x827f181c
	if ctx.cr[6].eq {
	pc = 0x827F181C; continue 'dispatch;
	}
	// 827F1748: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F174C: 41980008  blt cr6, 0x827f1754
	if ctx.cr[6].lt {
	pc = 0x827F1754; continue 'dispatch;
	}
	// 827F1750: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1754; continue 'dispatch;
            }
            0x827F1754 => {
    //   block [0x827F1754..0x827F1770)
	// 827F1754: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1758: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 827F175C: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 827F1760: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1764: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827F1768: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F176C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	pc = 0x827F1770; continue 'dispatch;
            }
            0x827F1770 => {
    //   block [0x827F1770..0x827F1784)
	// 827F1770: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1774: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1778: 419A000C  beq cr6, 0x827f1784
	if ctx.cr[6].eq {
	pc = 0x827F1784; continue 'dispatch;
	}
	// 827F177C: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827F1780: 419A0008  beq cr6, 0x827f1788
	if ctx.cr[6].eq {
	pc = 0x827F1788; continue 'dispatch;
	}
	pc = 0x827F1784; continue 'dispatch;
            }
            0x827F1784 => {
    //   block [0x827F1784..0x827F1788)
	// 827F1784: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1788; continue 'dispatch;
            }
            0x827F1788 => {
    //   block [0x827F1788..0x827F179C)
	// 827F1788: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F178C: 419A0078  beq cr6, 0x827f1804
	if ctx.cr[6].eq {
	pc = 0x827F1804; continue 'dispatch;
	}
	// 827F1790: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1794: 409A0008  bne cr6, 0x827f179c
	if !ctx.cr[6].eq {
	pc = 0x827F179C; continue 'dispatch;
	}
	// 827F1798: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F179C; continue 'dispatch;
            }
            0x827F179C => {
    //   block [0x827F179C..0x827F17AC)
	// 827F179C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F17A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F17A4: 409A0008  bne cr6, 0x827f17ac
	if !ctx.cr[6].eq {
	pc = 0x827F17AC; continue 'dispatch;
	}
	// 827F17A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F17AC; continue 'dispatch;
            }
            0x827F17AC => {
    //   block [0x827F17AC..0x827F17B4)
	// 827F17AC: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F17B0: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x827F17B4; continue 'dispatch;
            }
            0x827F17B4 => {
    //   block [0x827F17B4..0x827F17C4)
	// 827F17B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F17B8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F17BC: 409A0008  bne cr6, 0x827f17c4
	if !ctx.cr[6].eq {
	pc = 0x827F17C4; continue 'dispatch;
	}
	// 827F17C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F17C4; continue 'dispatch;
            }
            0x827F17C4 => {
    //   block [0x827F17C4..0x827F17F0)
	// 827F17C4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F17C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F17CC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F17D0: 419A0020  beq cr6, 0x827f17f0
	if ctx.cr[6].eq {
	pc = 0x827F17F0; continue 'dispatch;
	}
	// 827F17D4: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F17D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F17DC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F17E0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F17E4: 4E800421  bctrl
	ctx.lr = 0x827F17E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F17E8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827F17EC: 4BFFFFC8  b 0x827f17b4
	pc = 0x827F17B4; continue 'dispatch;
            }
            0x827F17F0 => {
    //   block [0x827F17F0..0x827F1804)
	// 827F17F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F17F4: 4BD65065  bl 0x82556858
	ctx.lr = 0x827F17F8;
	sub_82556858(ctx, base);
	// 827F17F8: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F17FC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F1800: 4BFFFF70  b 0x827f1770
	pc = 0x827F1770; continue 'dispatch;
            }
            0x827F1804 => {
    //   block [0x827F1804..0x827F1814)
	// 827F1804: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1808: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F180C: 41980008  blt cr6, 0x827f1814
	if ctx.cr[6].lt {
	pc = 0x827F1814; continue 'dispatch;
	}
	// 827F1810: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1814; continue 'dispatch;
            }
            0x827F1814 => {
    //   block [0x827F1814..0x827F181C)
	// 827F1814: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 827F1818: 4BFFFF08  b 0x827f1720
	pc = 0x827F1720; continue 'dispatch;
            }
            0x827F181C => {
    //   block [0x827F181C..0x827F1824)
	// 827F181C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F1820: 484B7C30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F1828 size=80
    let mut pc: u32 = 0x827F1828;
    'dispatch: loop {
        match pc {
            0x827F1828 => {
    //   block [0x827F1828..0x827F1868)
	// 827F1828: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F182C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1830: 419A0048  beq cr6, 0x827f1878
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x827F1878);
		return;
	}
	// 827F1834: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1838: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F183C: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F1840: 7F045840  cmplw cr6, r4, r11
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1844: 40980034  bge cr6, 0x827f1878
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x827F1878);
		return;
	}
	// 827F1848: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F184C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1850: 419A0018  beq cr6, 0x827f1868
	if ctx.cr[6].eq {
	pc = 0x827F1868; continue 'dispatch;
	}
	// 827F1854: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F1858: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F185C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F1860: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1864: 41980008  blt cr6, 0x827f186c
	if ctx.cr[6].lt {
	pc = 0x827F186C; continue 'dispatch;
	}
	pc = 0x827F1868; continue 'dispatch;
            }
            0x827F1868 => {
    //   block [0x827F1868..0x827F186C)
	// 827F1868: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F186C; continue 'dispatch;
            }
            0x827F186C => {
    //   block [0x827F186C..0x827F1878)
	// 827F186C: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F1870: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827F1874: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1880(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F1880 size=104
    let mut pc: u32 = 0x827F1880;
    'dispatch: loop {
        match pc {
            0x827F1880 => {
    //   block [0x827F1880..0x827F18E8)
	// 827F1880: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1884: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F1888: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F188C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F1890: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F1898: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F189C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F18A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F18A4: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F18A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F18AC: 4E800421  bctrl
	ctx.lr = 0x827F18B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F18B0: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F18B4: 81090044  lwz r8, 0x44(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 827F18B8: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827F18BC: 4E800421  bctrl
	ctx.lr = 0x827F18C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F18C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F18C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F18C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F18CC: 4800001D  bl 0x827f18e8
	ctx.lr = 0x827F18D0;
	sub_827F18E8(ctx, base);
	// 827F18D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F18D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F18D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F18DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F18E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F18E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F18E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F18E8 size=348
    let mut pc: u32 = 0x827F18E8;
    'dispatch: loop {
        match pc {
            0x827F18E8 => {
    //   block [0x827F18E8..0x827F1918)
	// 827F18E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F18EC: 484B7B15  bl 0x82ca9400
	ctx.lr = 0x827F18F0;
	sub_82CA93D0(ctx, base);
	// 827F18F0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F18F4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827F18F8: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827F18FC: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827F1900: 3BDA0018  addi r30, r26, 0x18
	ctx.r[30].s64 = ctx.r[26].s64 + 24;
	// 827F1904: 83FA001C  lwz r31, 0x1c(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F1908: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F190C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1910: 40990008  ble cr6, 0x827f1918
	if !ctx.cr[6].gt {
	pc = 0x827F1918; continue 'dispatch;
	}
	// 827F1914: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1918; continue 'dispatch;
            }
            0x827F1918 => {
    //   block [0x827F1918..0x827F192C)
	// 827F1918: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F191C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1920: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1924: 40990008  ble cr6, 0x827f192c
	if !ctx.cr[6].gt {
	pc = 0x827F192C; continue 'dispatch;
	}
	// 827F1928: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F192C; continue 'dispatch;
            }
            0x827F192C => {
    //   block [0x827F192C..0x827F1938)
	// 827F192C: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F1930: 419A0008  beq cr6, 0x827f1938
	if ctx.cr[6].eq {
	pc = 0x827F1938; continue 'dispatch;
	}
	// 827F1934: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1938; continue 'dispatch;
            }
            0x827F1938 => {
    //   block [0x827F1938..0x827F194C)
	// 827F1938: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F193C: 419A0044  beq cr6, 0x827f1980
	if ctx.cr[6].eq {
	pc = 0x827F1980; continue 'dispatch;
	}
	// 827F1940: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1944: 41980008  blt cr6, 0x827f194c
	if ctx.cr[6].lt {
	pc = 0x827F194C; continue 'dispatch;
	}
	// 827F1948: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F194C; continue 'dispatch;
            }
            0x827F194C => {
    //   block [0x827F194C..0x827F1978)
	// 827F194C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1950: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F1954: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F1958: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F195C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1960: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F1964: 4E800421  bctrl
	ctx.lr = 0x827F1968;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F1968: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F196C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1970: 41980008  blt cr6, 0x827f1978
	if ctx.cr[6].lt {
	pc = 0x827F1978; continue 'dispatch;
	}
	// 827F1974: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827F1978 => {
    //   block [0x827F1978..0x827F1980)
	// 827F1978: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827F197C: 4BFFFF9C  b 0x827f1918
	pc = 0x827F1918; continue 'dispatch;
            }
            0x827F1980 => {
    //   block [0x827F1980..0x827F19F8)
	// 827F1980: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F1984: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827F1988: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 827F198C: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 827F1990: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 827F1994: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 827F1998: 38CA2310  addi r6, r10, 0x2310
	ctx.r[6].s64 = ctx.r[10].s64 + 8976;
	// 827F199C: C00BBE40  lfs f0, -0x41c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F19A0: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 827F19A4: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827F19A8: 38A9231C  addi r5, r9, 0x231c
	ctx.r[5].s64 = ctx.r[9].s64 + 8988;
	// 827F19AC: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 827F19B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F19B4: 484B8D25  bl 0x82caa6d8
	ctx.lr = 0x827F19B8;
	sub_82CAA6D8(ctx, base);
	// 827F19B8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F19BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827F19C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F19C4: 4BC35C1D  bl 0x824275e0
	ctx.lr = 0x827F19C8;
	sub_824275E0(ctx, base);
	// 827F19C8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F19CC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F19D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F19D4: 4BC34EC5  bl 0x82426898
	ctx.lr = 0x827F19D8;
	sub_82426898(ctx, base);
	// 827F19D8: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F19DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F19E0: 419A0040  beq cr6, 0x827f1a20
	if ctx.cr[6].eq {
	pc = 0x827F1A20; continue 'dispatch;
	}
	// 827F19E4: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827F19E8: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 827F19EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F19F0: 40990030  ble cr6, 0x827f1a20
	if !ctx.cr[6].gt {
	pc = 0x827F1A20; continue 'dispatch;
	}
	// 827F19F4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x827F19F8; continue 'dispatch;
            }
            0x827F19F8 => {
    //   block [0x827F19F8..0x827F1A20)
	// 827F19F8: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F19FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F1A00: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F1A04: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827F1A08: 4BFFFEE1  bl 0x827f18e8
	ctx.lr = 0x827F1A0C;
	sub_827F18E8(ctx, base);
	// 827F1A0C: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827F1A10: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 827F1A14: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827F1A18: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 827F1A1C: 4198FFDC  blt cr6, 0x827f19f8
	if ctx.cr[6].lt {
	pc = 0x827F19F8; continue 'dispatch;
	}
	pc = 0x827F1A20; continue 'dispatch;
            }
            0x827F1A20 => {
    //   block [0x827F1A20..0x827F1A44)
	// 827F1A20: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 827F1A24: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F1A28: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F1A2C: 483BD435  bl 0x82baee60
	ctx.lr = 0x827F1A30;
	sub_82BAEE60(ctx, base);
	// 827F1A30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F1A34: 57E5103A  slwi r5, r31, 2
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 827F1A38: 483BDD79  bl 0x82baf7b0
	ctx.lr = 0x827F1A3C;
	sub_82BAF7B0(ctx, base);
	// 827F1A3C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827F1A40: 484B7A10  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1A48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F1A48 size=104
    let mut pc: u32 = 0x827F1A48;
    'dispatch: loop {
        match pc {
            0x827F1A48 => {
    //   block [0x827F1A48..0x827F1AB0)
	// 827F1A48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1A4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F1A50: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F1A54: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F1A58: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1A5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F1A60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F1A64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F1A68: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1A6C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1A70: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F1A74: 4E800421  bctrl
	ctx.lr = 0x827F1A78;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F1A78: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1A7C: 81090044  lwz r8, 0x44(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) } as u64;
	// 827F1A80: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827F1A84: 4E800421  bctrl
	ctx.lr = 0x827F1A88;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F1A88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F1A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F1A90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1A94: 4800001D  bl 0x827f1ab0
	ctx.lr = 0x827F1A98;
	sub_827F1AB0(ctx, base);
	// 827F1A98: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F1A9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F1AA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F1AA4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F1AA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F1AAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1AB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F1AB0 size=348
    let mut pc: u32 = 0x827F1AB0;
    'dispatch: loop {
        match pc {
            0x827F1AB0 => {
    //   block [0x827F1AB0..0x827F1AE0)
	// 827F1AB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1AB4: 484B794D  bl 0x82ca9400
	ctx.lr = 0x827F1AB8;
	sub_82CA93D0(ctx, base);
	// 827F1AB8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1ABC: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827F1AC0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827F1AC4: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827F1AC8: 3BDA0018  addi r30, r26, 0x18
	ctx.r[30].s64 = ctx.r[26].s64 + 24;
	// 827F1ACC: 83FA001C  lwz r31, 0x1c(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F1AD0: 817A0020  lwz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1AD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1AD8: 40990008  ble cr6, 0x827f1ae0
	if !ctx.cr[6].gt {
	pc = 0x827F1AE0; continue 'dispatch;
	}
	// 827F1ADC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1AE0; continue 'dispatch;
            }
            0x827F1AE0 => {
    //   block [0x827F1AE0..0x827F1AF4)
	// 827F1AE0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1AE4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1AE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1AEC: 40990008  ble cr6, 0x827f1af4
	if !ctx.cr[6].gt {
	pc = 0x827F1AF4; continue 'dispatch;
	}
	// 827F1AF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1AF4; continue 'dispatch;
            }
            0x827F1AF4 => {
    //   block [0x827F1AF4..0x827F1B00)
	// 827F1AF4: 7F1EF040  cmplw cr6, r30, r30
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F1AF8: 419A0008  beq cr6, 0x827f1b00
	if ctx.cr[6].eq {
	pc = 0x827F1B00; continue 'dispatch;
	}
	// 827F1AFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1B00; continue 'dispatch;
            }
            0x827F1B00 => {
    //   block [0x827F1B00..0x827F1B14)
	// 827F1B00: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F1B04: 419A0044  beq cr6, 0x827f1b48
	if ctx.cr[6].eq {
	pc = 0x827F1B48; continue 'dispatch;
	}
	// 827F1B08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1B0C: 41980008  blt cr6, 0x827f1b14
	if ctx.cr[6].lt {
	pc = 0x827F1B14; continue 'dispatch;
	}
	// 827F1B10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1B14; continue 'dispatch;
            }
            0x827F1B14 => {
    //   block [0x827F1B14..0x827F1B40)
	// 827F1B14: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1B18: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F1B1C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F1B20: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1B24: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1B28: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F1B2C: 4E800421  bctrl
	ctx.lr = 0x827F1B30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F1B30: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1B34: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F1B38: 41980008  blt cr6, 0x827f1b40
	if ctx.cr[6].lt {
	pc = 0x827F1B40; continue 'dispatch;
	}
	// 827F1B3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827F1B40 => {
    //   block [0x827F1B40..0x827F1B48)
	// 827F1B40: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827F1B44: 4BFFFF9C  b 0x827f1ae0
	pc = 0x827F1AE0; continue 'dispatch;
            }
            0x827F1B48 => {
    //   block [0x827F1B48..0x827F1BC0)
	// 827F1B48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F1B4C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827F1B50: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 827F1B54: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 827F1B58: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 827F1B5C: 93810074  stw r28, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 827F1B60: 38CA2310  addi r6, r10, 0x2310
	ctx.r[6].s64 = ctx.r[10].s64 + 8976;
	// 827F1B64: C00BBE40  lfs f0, -0x41c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F1B68: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 827F1B6C: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 827F1B70: 38A9231C  addi r5, r9, 0x231c
	ctx.r[5].s64 = ctx.r[9].s64 + 8988;
	// 827F1B74: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 827F1B78: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1B7C: 484B8B5D  bl 0x82caa6d8
	ctx.lr = 0x827F1B80;
	sub_82CAA6D8(ctx, base);
	// 827F1B80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F1B84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827F1B88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1B8C: 4BC35A55  bl 0x824275e0
	ctx.lr = 0x827F1B90;
	sub_824275E0(ctx, base);
	// 827F1B90: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F1B94: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F1B98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1B9C: 4BC34CFD  bl 0x82426898
	ctx.lr = 0x827F1BA0;
	sub_82426898(ctx, base);
	// 827F1BA0: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F1BA4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F1BA8: 419A0040  beq cr6, 0x827f1be8
	if ctx.cr[6].eq {
	pc = 0x827F1BE8; continue 'dispatch;
	}
	// 827F1BAC: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827F1BB0: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 827F1BB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F1BB8: 40990030  ble cr6, 0x827f1be8
	if !ctx.cr[6].gt {
	pc = 0x827F1BE8; continue 'dispatch;
	}
	// 827F1BBC: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x827F1BC0; continue 'dispatch;
            }
            0x827F1BC0 => {
    //   block [0x827F1BC0..0x827F1BE8)
	// 827F1BC0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F1BC4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F1BC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F1BCC: 7C9F582E  lwzx r4, r31, r11
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827F1BD0: 4BFFFEE1  bl 0x827f1ab0
	ctx.lr = 0x827F1BD4;
	sub_827F1AB0(ctx, base);
	// 827F1BD4: 81410078  lwz r10, 0x78(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827F1BD8: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 827F1BDC: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827F1BE0: 7F1E5000  cmpw cr6, r30, r10
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[10].s32, &mut ctx.xer);
	// 827F1BE4: 4198FFDC  blt cr6, 0x827f1bc0
	if ctx.cr[6].lt {
	pc = 0x827F1BC0; continue 'dispatch;
	}
	pc = 0x827F1BE8; continue 'dispatch;
            }
            0x827F1BE8 => {
    //   block [0x827F1BE8..0x827F1C0C)
	// 827F1BE8: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 827F1BEC: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F1BF0: 83C10070  lwz r30, 0x70(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F1BF4: 483BD26D  bl 0x82baee60
	ctx.lr = 0x827F1BF8;
	sub_82BAEE60(ctx, base);
	// 827F1BF8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F1BFC: 57E5103A  slwi r5, r31, 2
	ctx.r[5].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 827F1C00: 483BDBB1  bl 0x82baf7b0
	ctx.lr = 0x827F1C04;
	sub_82BAF7B0(ctx, base);
	// 827F1C04: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827F1C08: 484B7848  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F1C10 size=256
    let mut pc: u32 = 0x827F1C10;
    'dispatch: loop {
        match pc {
            0x827F1C10 => {
    //   block [0x827F1C10..0x827F1CA0)
	// 827F1C10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1C14: 484B77F9  bl 0x82ca940c
	ctx.lr = 0x827F1C18;
	sub_82CA93D0(ctx, base);
	// 827F1C18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1C1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1C20: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F1C24: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827F1C28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1C2C: 388A9FE0  addi r4, r10, -0x6020
	ctx.r[4].s64 = ctx.r[10].s64 + -24608;
	// 827F1C30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1C38: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1C3C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1C40: 4BA3B291  bl 0x8222ced0
	ctx.lr = 0x827F1C44;
	sub_8222CED0(ctx, base);
	// 827F1C44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1C48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1C4C: 4BC34955  bl 0x824265a0
	ctx.lr = 0x827F1C50;
	sub_824265A0(ctx, base);
	// 827F1C50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F1C54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1C58: 419A00B0  beq cr6, 0x827f1d08
	if ctx.cr[6].eq {
	pc = 0x827F1D08; continue 'dispatch;
	}
	// 827F1C5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 827F1C60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1C64: 388BCA94  addi r4, r11, -0x356c
	ctx.r[4].s64 = ctx.r[11].s64 + -13676;
	// 827F1C68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F1C6C: 4BA3B265  bl 0x8222ced0
	ctx.lr = 0x827F1C70;
	sub_8222CED0(ctx, base);
	// 827F1C70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1C74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1C78: 4BC34929  bl 0x824265a0
	ctx.lr = 0x827F1C7C;
	sub_824265A0(ctx, base);
	// 827F1C7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F1C80: 419A0038  beq cr6, 0x827f1cb8
	if ctx.cr[6].eq {
	pc = 0x827F1CB8; continue 'dispatch;
	}
	// 827F1C84: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1C88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1C8C: 419A0014  beq cr6, 0x827f1ca0
	if ctx.cr[6].eq {
	pc = 0x827F1CA0; continue 'dispatch;
	}
	// 827F1C90: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1C94: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1C98: 7D2A1E71  srawi. r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F1C9C: 40820008  bne 0x827f1ca4
	if !ctx.cr[0].eq {
	pc = 0x827F1CA4; continue 'dispatch;
	}
	pc = 0x827F1CA0; continue 'dispatch;
            }
            0x827F1CA0 => {
    //   block [0x827F1CA0..0x827F1CA4)
	// 827F1CA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1CA4; continue 'dispatch;
            }
            0x827F1CA4 => {
    //   block [0x827F1CA4..0x827F1CB8)
	// 827F1CA4: 906B0000  stw r3, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 827F1CA8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F1CAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F1CB0: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F1CB4: 4BC343C5  bl 0x82426078
	ctx.lr = 0x827F1CB8;
	sub_82426078(ctx, base);
	pc = 0x827F1CB8; continue 'dispatch;
            }
            0x827F1CB8 => {
    //   block [0x827F1CB8..0x827F1D00)
	// 827F1CB8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1CBC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1CC0: 388B9EC0  addi r4, r11, -0x6140
	ctx.r[4].s64 = ctx.r[11].s64 + -24896;
	// 827F1CC4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F1CC8: 4BA3B209  bl 0x8222ced0
	ctx.lr = 0x827F1CCC;
	sub_8222CED0(ctx, base);
	// 827F1CCC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1CD0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1CD4: 4BC348CD  bl 0x824265a0
	ctx.lr = 0x827F1CD8;
	sub_824265A0(ctx, base);
	// 827F1CD8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F1CDC: 419A002C  beq cr6, 0x827f1d08
	if ctx.cr[6].eq {
	pc = 0x827F1D08; continue 'dispatch;
	}
	// 827F1CE0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1CE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1CE8: 419A0018  beq cr6, 0x827f1d00
	if ctx.cr[6].eq {
	pc = 0x827F1D00; continue 'dispatch;
	}
	// 827F1CEC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1CF0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1CF4: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F1CF8: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827F1CFC: 41990008  bgt cr6, 0x827f1d04
	if ctx.cr[6].gt {
	pc = 0x827F1D04; continue 'dispatch;
	}
	pc = 0x827F1D00; continue 'dispatch;
            }
            0x827F1D00 => {
    //   block [0x827F1D00..0x827F1D04)
	// 827F1D00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1D04; continue 'dispatch;
            }
            0x827F1D04 => {
    //   block [0x827F1D04..0x827F1D08)
	// 827F1D04: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x827F1D08; continue 'dispatch;
            }
            0x827F1D08 => {
    //   block [0x827F1D08..0x827F1D10)
	// 827F1D08: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F1D0C: 484B7750  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F1D10 size=260
    let mut pc: u32 = 0x827F1D10;
    'dispatch: loop {
        match pc {
            0x827F1D10 => {
    //   block [0x827F1D10..0x827F1DA4)
	// 827F1D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1D14: 484B76F9  bl 0x82ca940c
	ctx.lr = 0x827F1D18;
	sub_82CA93D0(ctx, base);
	// 827F1D18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1D1C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F1D20: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F1D24: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827F1D28: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1D2C: 388A9FFC  addi r4, r10, -0x6004
	ctx.r[4].s64 = ctx.r[10].s64 + -24580;
	// 827F1D30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1D34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1D38: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1D3C: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1D40: 4BA3B191  bl 0x8222ced0
	ctx.lr = 0x827F1D44;
	sub_8222CED0(ctx, base);
	// 827F1D44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1D48: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1D4C: 4BC34855  bl 0x824265a0
	ctx.lr = 0x827F1D50;
	sub_824265A0(ctx, base);
	// 827F1D50: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F1D54: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1D58: 419A00B4  beq cr6, 0x827f1e0c
	if ctx.cr[6].eq {
	pc = 0x827F1E0C; continue 'dispatch;
	}
	// 827F1D5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 827F1D60: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1D64: 388BCA94  addi r4, r11, -0x356c
	ctx.r[4].s64 = ctx.r[11].s64 + -13676;
	// 827F1D68: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F1D6C: 4BA3B165  bl 0x8222ced0
	ctx.lr = 0x827F1D70;
	sub_8222CED0(ctx, base);
	// 827F1D70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1D74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1D78: 4BC34829  bl 0x824265a0
	ctx.lr = 0x827F1D7C;
	sub_824265A0(ctx, base);
	// 827F1D7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F1D80: 419A003C  beq cr6, 0x827f1dbc
	if ctx.cr[6].eq {
	pc = 0x827F1DBC; continue 'dispatch;
	}
	// 827F1D84: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1D8C: 419A0018  beq cr6, 0x827f1da4
	if ctx.cr[6].eq {
	pc = 0x827F1DA4; continue 'dispatch;
	}
	// 827F1D90: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1D94: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1D98: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F1D9C: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 827F1DA0: 41990008  bgt cr6, 0x827f1da8
	if ctx.cr[6].gt {
	pc = 0x827F1DA8; continue 'dispatch;
	}
	pc = 0x827F1DA4; continue 'dispatch;
            }
            0x827F1DA4 => {
    //   block [0x827F1DA4..0x827F1DA8)
	// 827F1DA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1DA8; continue 'dispatch;
            }
            0x827F1DA8 => {
    //   block [0x827F1DA8..0x827F1DBC)
	// 827F1DA8: 906B0010  stw r3, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 827F1DAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F1DB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F1DB4: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F1DB8: 4BC342C1  bl 0x82426078
	ctx.lr = 0x827F1DBC;
	sub_82426078(ctx, base);
	pc = 0x827F1DBC; continue 'dispatch;
            }
            0x827F1DBC => {
    //   block [0x827F1DBC..0x827F1E04)
	// 827F1DBC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1DC0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1DC4: 388B9EC0  addi r4, r11, -0x6140
	ctx.r[4].s64 = ctx.r[11].s64 + -24896;
	// 827F1DC8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F1DCC: 4BA3B105  bl 0x8222ced0
	ctx.lr = 0x827F1DD0;
	sub_8222CED0(ctx, base);
	// 827F1DD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1DD4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F1DD8: 4BC347C9  bl 0x824265a0
	ctx.lr = 0x827F1DDC;
	sub_824265A0(ctx, base);
	// 827F1DDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F1DE0: 419A002C  beq cr6, 0x827f1e0c
	if ctx.cr[6].eq {
	pc = 0x827F1E0C; continue 'dispatch;
	}
	// 827F1DE4: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1DE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F1DEC: 419A0018  beq cr6, 0x827f1e04
	if ctx.cr[6].eq {
	pc = 0x827F1E04; continue 'dispatch;
	}
	// 827F1DF0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1DF4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F1DF8: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F1DFC: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 827F1E00: 41990008  bgt cr6, 0x827f1e08
	if ctx.cr[6].gt {
	pc = 0x827F1E08; continue 'dispatch;
	}
	pc = 0x827F1E04; continue 'dispatch;
            }
            0x827F1E04 => {
    //   block [0x827F1E04..0x827F1E08)
	// 827F1E04: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1E08; continue 'dispatch;
            }
            0x827F1E08 => {
    //   block [0x827F1E08..0x827F1E0C)
	// 827F1E08: 906B0018  stw r3, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	pc = 0x827F1E0C; continue 'dispatch;
            }
            0x827F1E0C => {
    //   block [0x827F1E0C..0x827F1E14)
	// 827F1E0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F1E10: 484B764C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F1E18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F1E18 size=724
    let mut pc: u32 = 0x827F1E18;
    'dispatch: loop {
        match pc {
            0x827F1E18 => {
    //   block [0x827F1E18..0x827F1E7C)
	// 827F1E18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F1E1C: 484B75ED  bl 0x82ca9408
	ctx.lr = 0x827F1E20;
	sub_82CA93D0(ctx, base);
	// 827F1E20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F1E24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F1E28: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F1E2C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827F1E30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827F1E34: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1E38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F1E3C: 388A9FE0  addi r4, r10, -0x6020
	ctx.r[4].s64 = ctx.r[10].s64 + -24608;
	// 827F1E40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1E44: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F1E48: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F1E4C: 4BA3B085  bl 0x8222ced0
	ctx.lr = 0x827F1E50;
	sub_8222CED0(ctx, base);
	// 827F1E50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F1E54: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1E58: 4BC34749  bl 0x824265a0
	ctx.lr = 0x827F1E5C;
	sub_824265A0(ctx, base);
	// 827F1E5C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1E60: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1E64: 419A0018  beq cr6, 0x827f1e7c
	if ctx.cr[6].eq {
	pc = 0x827F1E7C; continue 'dispatch;
	}
	// 827F1E68: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1E6C: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1E70: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1E74: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 827F1E78: 41990008  bgt cr6, 0x827f1e80
	if ctx.cr[6].gt {
	pc = 0x827F1E80; continue 'dispatch;
	}
	pc = 0x827F1E7C; continue 'dispatch;
            }
            0x827F1E7C => {
    //   block [0x827F1E7C..0x827F1E80)
	// 827F1E7C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1E80; continue 'dispatch;
            }
            0x827F1E80 => {
    //   block [0x827F1E80..0x827F1EC4)
	// 827F1E80: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1E84: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1E88: 388BA01C  addi r4, r11, -0x5fe4
	ctx.r[4].s64 = ctx.r[11].s64 + -24548;
	// 827F1E8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1E90: 4BA3B041  bl 0x8222ced0
	ctx.lr = 0x827F1E94;
	sub_8222CED0(ctx, base);
	// 827F1E94: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1E98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1E9C: 4BC34705  bl 0x824265a0
	ctx.lr = 0x827F1EA0;
	sub_824265A0(ctx, base);
	// 827F1EA0: 907D0020  stw r3, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 827F1EA4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1EA8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1EAC: 419A0018  beq cr6, 0x827f1ec4
	if ctx.cr[6].eq {
	pc = 0x827F1EC4; continue 'dispatch;
	}
	// 827F1EB0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1EB4: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1EB8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1EBC: 2B0B0005  cmplwi cr6, r11, 5
	ctx.cr[6].compare_u32(ctx.r[11].u32, 5 as u32, &mut ctx.xer);
	// 827F1EC0: 41990008  bgt cr6, 0x827f1ec8
	if ctx.cr[6].gt {
	pc = 0x827F1EC8; continue 'dispatch;
	}
	pc = 0x827F1EC4; continue 'dispatch;
            }
            0x827F1EC4 => {
    //   block [0x827F1EC4..0x827F1EC8)
	// 827F1EC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1EC8; continue 'dispatch;
            }
            0x827F1EC8 => {
    //   block [0x827F1EC8..0x827F1F0C)
	// 827F1EC8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1ECC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1ED0: 388BA02C  addi r4, r11, -0x5fd4
	ctx.r[4].s64 = ctx.r[11].s64 + -24532;
	// 827F1ED4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1ED8: 4BA3AFF9  bl 0x8222ced0
	ctx.lr = 0x827F1EDC;
	sub_8222CED0(ctx, base);
	// 827F1EDC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1EE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1EE4: 4BC346BD  bl 0x824265a0
	ctx.lr = 0x827F1EE8;
	sub_824265A0(ctx, base);
	// 827F1EE8: 907D0028  stw r3, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 827F1EEC: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1EF0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1EF4: 419A0018  beq cr6, 0x827f1f0c
	if ctx.cr[6].eq {
	pc = 0x827F1F0C; continue 'dispatch;
	}
	// 827F1EF8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1EFC: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1F00: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1F04: 2B0B0006  cmplwi cr6, r11, 6
	ctx.cr[6].compare_u32(ctx.r[11].u32, 6 as u32, &mut ctx.xer);
	// 827F1F08: 41990008  bgt cr6, 0x827f1f10
	if ctx.cr[6].gt {
	pc = 0x827F1F10; continue 'dispatch;
	}
	pc = 0x827F1F0C; continue 'dispatch;
            }
            0x827F1F0C => {
    //   block [0x827F1F0C..0x827F1F10)
	// 827F1F0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1F10; continue 'dispatch;
            }
            0x827F1F10 => {
    //   block [0x827F1F10..0x827F1F54)
	// 827F1F10: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1F14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1F18: 388BA034  addi r4, r11, -0x5fcc
	ctx.r[4].s64 = ctx.r[11].s64 + -24524;
	// 827F1F1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1F20: 4BA3AFB1  bl 0x8222ced0
	ctx.lr = 0x827F1F24;
	sub_8222CED0(ctx, base);
	// 827F1F24: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1F28: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1F2C: 4BC34675  bl 0x824265a0
	ctx.lr = 0x827F1F30;
	sub_824265A0(ctx, base);
	// 827F1F30: 907D0030  stw r3, 0x30(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), ctx.r[3].u32 ) };
	// 827F1F34: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1F38: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1F3C: 419A0018  beq cr6, 0x827f1f54
	if ctx.cr[6].eq {
	pc = 0x827F1F54; continue 'dispatch;
	}
	// 827F1F40: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1F44: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1F48: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1F4C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 827F1F50: 41990008  bgt cr6, 0x827f1f58
	if ctx.cr[6].gt {
	pc = 0x827F1F58; continue 'dispatch;
	}
	pc = 0x827F1F54; continue 'dispatch;
            }
            0x827F1F54 => {
    //   block [0x827F1F54..0x827F1F58)
	// 827F1F54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1F58; continue 'dispatch;
            }
            0x827F1F58 => {
    //   block [0x827F1F58..0x827F1F9C)
	// 827F1F58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F1F5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1F60: 388BA040  addi r4, r11, -0x5fc0
	ctx.r[4].s64 = ctx.r[11].s64 + -24512;
	// 827F1F64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1F68: 4BA3AF69  bl 0x8222ced0
	ctx.lr = 0x827F1F6C;
	sub_8222CED0(ctx, base);
	// 827F1F6C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1F70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1F74: 4BC3462D  bl 0x824265a0
	ctx.lr = 0x827F1F78;
	sub_824265A0(ctx, base);
	// 827F1F78: 907D0038  stw r3, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	// 827F1F7C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1F80: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1F84: 419A0018  beq cr6, 0x827f1f9c
	if ctx.cr[6].eq {
	pc = 0x827F1F9C; continue 'dispatch;
	}
	// 827F1F88: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1F8C: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1F90: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1F94: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 827F1F98: 41990008  bgt cr6, 0x827f1fa0
	if ctx.cr[6].gt {
	pc = 0x827F1FA0; continue 'dispatch;
	}
	pc = 0x827F1F9C; continue 'dispatch;
            }
            0x827F1F9C => {
    //   block [0x827F1F9C..0x827F1FA0)
	// 827F1F9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1FA0; continue 'dispatch;
            }
            0x827F1FA0 => {
    //   block [0x827F1FA0..0x827F1FE4)
	// 827F1FA0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827F1FA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1FA8: 388BEEF0  addi r4, r11, -0x1110
	ctx.r[4].s64 = ctx.r[11].s64 + -4368;
	// 827F1FAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1FB0: 4BA3AF21  bl 0x8222ced0
	ctx.lr = 0x827F1FB4;
	sub_8222CED0(ctx, base);
	// 827F1FB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F1FB8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F1FBC: 4BC345E5  bl 0x824265a0
	ctx.lr = 0x827F1FC0;
	sub_824265A0(ctx, base);
	// 827F1FC0: 907D0040  stw r3, 0x40(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), ctx.r[3].u32 ) };
	// 827F1FC4: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F1FC8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F1FCC: 419A0018  beq cr6, 0x827f1fe4
	if ctx.cr[6].eq {
	pc = 0x827F1FE4; continue 'dispatch;
	}
	// 827F1FD0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F1FD4: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F1FD8: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F1FDC: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 827F1FE0: 41990008  bgt cr6, 0x827f1fe8
	if ctx.cr[6].gt {
	pc = 0x827F1FE8; continue 'dispatch;
	}
	pc = 0x827F1FE4; continue 'dispatch;
            }
            0x827F1FE4 => {
    //   block [0x827F1FE4..0x827F1FE8)
	// 827F1FE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F1FE8; continue 'dispatch;
            }
            0x827F1FE8 => {
    //   block [0x827F1FE8..0x827F202C)
	// 827F1FE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827F1FEC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F1FF0: 388BE2EC  addi r4, r11, -0x1d14
	ctx.r[4].s64 = ctx.r[11].s64 + -7444;
	// 827F1FF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F1FF8: 4BA3AED9  bl 0x8222ced0
	ctx.lr = 0x827F1FFC;
	sub_8222CED0(ctx, base);
	// 827F1FFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F2000: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F2004: 4BC3459D  bl 0x824265a0
	ctx.lr = 0x827F2008;
	sub_824265A0(ctx, base);
	// 827F2008: 907D0058  stw r3, 0x58(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 827F200C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2010: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F2014: 419A0018  beq cr6, 0x827f202c
	if ctx.cr[6].eq {
	pc = 0x827F202C; continue 'dispatch;
	}
	// 827F2018: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F201C: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F2020: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F2024: 2B0B000C  cmplwi cr6, r11, 0xc
	ctx.cr[6].compare_u32(ctx.r[11].u32, 12 as u32, &mut ctx.xer);
	// 827F2028: 41990008  bgt cr6, 0x827f2030
	if ctx.cr[6].gt {
	pc = 0x827F2030; continue 'dispatch;
	}
	pc = 0x827F202C; continue 'dispatch;
            }
            0x827F202C => {
    //   block [0x827F202C..0x827F2030)
	// 827F202C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2030; continue 'dispatch;
            }
            0x827F2030 => {
    //   block [0x827F2030..0x827F2074)
	// 827F2030: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827F2034: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2038: 388BE428  addi r4, r11, -0x1bd8
	ctx.r[4].s64 = ctx.r[11].s64 + -7128;
	// 827F203C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F2040: 4BA3AE91  bl 0x8222ced0
	ctx.lr = 0x827F2044;
	sub_8222CED0(ctx, base);
	// 827F2044: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F2048: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F204C: 4BC34555  bl 0x824265a0
	ctx.lr = 0x827F2050;
	sub_824265A0(ctx, base);
	// 827F2050: 907D0060  stw r3, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827F2054: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2058: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F205C: 419A0018  beq cr6, 0x827f2074
	if ctx.cr[6].eq {
	pc = 0x827F2074; continue 'dispatch;
	}
	// 827F2060: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F2064: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F2068: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F206C: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 827F2070: 41990008  bgt cr6, 0x827f2078
	if ctx.cr[6].gt {
	pc = 0x827F2078; continue 'dispatch;
	}
	pc = 0x827F2074; continue 'dispatch;
            }
            0x827F2074 => {
    //   block [0x827F2074..0x827F2078)
	// 827F2074: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2078; continue 'dispatch;
            }
            0x827F2078 => {
    //   block [0x827F2078..0x827F20BC)
	// 827F2078: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F207C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2080: 388BA04C  addi r4, r11, -0x5fb4
	ctx.r[4].s64 = ctx.r[11].s64 + -24500;
	// 827F2084: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F2088: 4BA3AE49  bl 0x8222ced0
	ctx.lr = 0x827F208C;
	sub_8222CED0(ctx, base);
	// 827F208C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F2090: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F2094: 4BC3450D  bl 0x824265a0
	ctx.lr = 0x827F2098;
	sub_824265A0(ctx, base);
	// 827F2098: 907D0048  stw r3, 0x48(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), ctx.r[3].u32 ) };
	// 827F209C: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F20A0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F20A4: 419A0018  beq cr6, 0x827f20bc
	if ctx.cr[6].eq {
	pc = 0x827F20BC; continue 'dispatch;
	}
	// 827F20A8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F20AC: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F20B0: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F20B4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 827F20B8: 41990008  bgt cr6, 0x827f20c0
	if ctx.cr[6].gt {
	pc = 0x827F20C0; continue 'dispatch;
	}
	pc = 0x827F20BC; continue 'dispatch;
            }
            0x827F20BC => {
    //   block [0x827F20BC..0x827F20C0)
	// 827F20BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F20C0; continue 'dispatch;
            }
            0x827F20C0 => {
    //   block [0x827F20C0..0x827F20EC)
	// 827F20C0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F20C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F20C8: 388BA064  addi r4, r11, -0x5f9c
	ctx.r[4].s64 = ctx.r[11].s64 + -24476;
	// 827F20CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F20D0: 4BA3AE01  bl 0x8222ced0
	ctx.lr = 0x827F20D4;
	sub_8222CED0(ctx, base);
	// 827F20D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F20D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F20DC: 4BC344C5  bl 0x824265a0
	ctx.lr = 0x827F20E0;
	sub_824265A0(ctx, base);
	// 827F20E0: 907D0050  stw r3, 0x50(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827F20E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F20E8: 484B7370  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F20F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F20F0 size=484
    let mut pc: u32 = 0x827F20F0;
    'dispatch: loop {
        match pc {
            0x827F20F0 => {
    //   block [0x827F20F0..0x827F2154)
	// 827F20F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F20F4: 484B7311  bl 0x82ca9404
	ctx.lr = 0x827F20F8;
	sub_82CA93D0(ctx, base);
	// 827F20F8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F20FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F2100: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F2104: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F2108: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F210C: 388AA080  addi r4, r10, -0x5f80
	ctx.r[4].s64 = ctx.r[10].s64 + -24448;
	// 827F2110: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F2114: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F2118: 812B0020  lwz r9, 0x20(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F211C: 83890004  lwz r28, 4(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2120: 4BA3ADB1  bl 0x8222ced0
	ctx.lr = 0x827F2124;
	sub_8222CED0(ctx, base);
	// 827F2124: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F2128: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F212C: 4BC34475  bl 0x824265a0
	ctx.lr = 0x827F2130;
	sub_824265A0(ctx, base);
	// 827F2130: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2134: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F2138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F213C: 419A0018  beq cr6, 0x827f2154
	if ctx.cr[6].eq {
	pc = 0x827F2154; continue 'dispatch;
	}
	// 827F2140: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F2144: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F2148: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F214C: 2B0A000D  cmplwi cr6, r10, 0xd
	ctx.cr[6].compare_u32(ctx.r[10].u32, 13 as u32, &mut ctx.xer);
	// 827F2150: 41990008  bgt cr6, 0x827f2158
	if ctx.cr[6].gt {
	pc = 0x827F2158; continue 'dispatch;
	}
	pc = 0x827F2154; continue 'dispatch;
            }
            0x827F2154 => {
    //   block [0x827F2154..0x827F2158)
	// 827F2154: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2158; continue 'dispatch;
            }
            0x827F2158 => {
    //   block [0x827F2158..0x827F21A0)
	// 827F2158: 93CB0068  stw r30, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 827F215C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2160: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2164: 388BA088  addi r4, r11, -0x5f78
	ctx.r[4].s64 = ctx.r[11].s64 + -24440;
	// 827F2168: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F216C: 4BA3AD65  bl 0x8222ced0
	ctx.lr = 0x827F2170;
	sub_8222CED0(ctx, base);
	// 827F2170: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F2174: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F2178: 4BC34429  bl 0x824265a0
	ctx.lr = 0x827F217C;
	sub_824265A0(ctx, base);
	// 827F217C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2180: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F2184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F2188: 419A0018  beq cr6, 0x827f21a0
	if ctx.cr[6].eq {
	pc = 0x827F21A0; continue 'dispatch;
	}
	// 827F218C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F2190: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F2194: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F2198: 2B0A000E  cmplwi cr6, r10, 0xe
	ctx.cr[6].compare_u32(ctx.r[10].u32, 14 as u32, &mut ctx.xer);
	// 827F219C: 41990008  bgt cr6, 0x827f21a4
	if ctx.cr[6].gt {
	pc = 0x827F21A4; continue 'dispatch;
	}
	pc = 0x827F21A0; continue 'dispatch;
            }
            0x827F21A0 => {
    //   block [0x827F21A0..0x827F21A4)
	// 827F21A0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F21A4; continue 'dispatch;
            }
            0x827F21A4 => {
    //   block [0x827F21A4..0x827F21EC)
	// 827F21A4: 936B0070  stw r27, 0x70(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), ctx.r[27].u32 ) };
	// 827F21A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F21AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F21B0: 388BA090  addi r4, r11, -0x5f70
	ctx.r[4].s64 = ctx.r[11].s64 + -24432;
	// 827F21B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F21B8: 4BA3AD19  bl 0x8222ced0
	ctx.lr = 0x827F21BC;
	sub_8222CED0(ctx, base);
	// 827F21BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F21C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F21C4: 4BC343DD  bl 0x824265a0
	ctx.lr = 0x827F21C8;
	sub_824265A0(ctx, base);
	// 827F21C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F21CC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F21D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F21D4: 419A0018  beq cr6, 0x827f21ec
	if ctx.cr[6].eq {
	pc = 0x827F21EC; continue 'dispatch;
	}
	// 827F21D8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F21DC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F21E0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F21E4: 2B0A000F  cmplwi cr6, r10, 0xf
	ctx.cr[6].compare_u32(ctx.r[10].u32, 15 as u32, &mut ctx.xer);
	// 827F21E8: 41990008  bgt cr6, 0x827f21f0
	if ctx.cr[6].gt {
	pc = 0x827F21F0; continue 'dispatch;
	}
	pc = 0x827F21EC; continue 'dispatch;
            }
            0x827F21EC => {
    //   block [0x827F21EC..0x827F21F0)
	// 827F21EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F21F0; continue 'dispatch;
            }
            0x827F21F0 => {
    //   block [0x827F21F0..0x827F2214)
	// 827F21F0: 93AB0078  stw r29, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 827F21F4: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F21F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F21FC: 419A0018  beq cr6, 0x827f2214
	if ctx.cr[6].eq {
	pc = 0x827F2214; continue 'dispatch;
	}
	// 827F2200: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F2204: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827F2208: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F220C: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 827F2210: 41990008  bgt cr6, 0x827f2218
	if ctx.cr[6].gt {
	pc = 0x827F2218; continue 'dispatch;
	}
	pc = 0x827F2214; continue 'dispatch;
            }
            0x827F2214 => {
    //   block [0x827F2214..0x827F2218)
	// 827F2214: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2218; continue 'dispatch;
            }
            0x827F2218 => {
    //   block [0x827F2218..0x827F225C)
	// 827F2218: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F221C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2220: 388B47E8  addi r4, r11, 0x47e8
	ctx.r[4].s64 = ctx.r[11].s64 + 18408;
	// 827F2224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F2228: 4BA3ACA9  bl 0x8222ced0
	ctx.lr = 0x827F222C;
	sub_8222CED0(ctx, base);
	// 827F222C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F2230: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F2234: 4BC3436D  bl 0x824265a0
	ctx.lr = 0x827F2238;
	sub_824265A0(ctx, base);
	// 827F2238: 907E0088  stw r3, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[3].u32 ) };
	// 827F223C: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2240: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F2244: 419A0018  beq cr6, 0x827f225c
	if ctx.cr[6].eq {
	pc = 0x827F225C; continue 'dispatch;
	}
	// 827F2248: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F224C: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827F2250: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F2254: 2B0B0010  cmplwi cr6, r11, 0x10
	ctx.cr[6].compare_u32(ctx.r[11].u32, 16 as u32, &mut ctx.xer);
	// 827F2258: 41990008  bgt cr6, 0x827f2260
	if ctx.cr[6].gt {
	pc = 0x827F2260; continue 'dispatch;
	}
	pc = 0x827F225C; continue 'dispatch;
            }
            0x827F225C => {
    //   block [0x827F225C..0x827F2260)
	// 827F225C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2260; continue 'dispatch;
            }
            0x827F2260 => {
    //   block [0x827F2260..0x827F22A4)
	// 827F2260: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827F2264: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2268: 388BDCFC  addi r4, r11, -0x2304
	ctx.r[4].s64 = ctx.r[11].s64 + -8964;
	// 827F226C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F2270: 4BA3AC61  bl 0x8222ced0
	ctx.lr = 0x827F2274;
	sub_8222CED0(ctx, base);
	// 827F2274: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F2278: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F227C: 4BC34325  bl 0x824265a0
	ctx.lr = 0x827F2280;
	sub_824265A0(ctx, base);
	// 827F2280: 907E0080  stw r3, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 827F2284: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2288: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F228C: 419A0018  beq cr6, 0x827f22a4
	if ctx.cr[6].eq {
	pc = 0x827F22A4; continue 'dispatch;
	}
	// 827F2290: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F2294: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827F2298: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F229C: 2B0B0012  cmplwi cr6, r11, 0x12
	ctx.cr[6].compare_u32(ctx.r[11].u32, 18 as u32, &mut ctx.xer);
	// 827F22A0: 41990008  bgt cr6, 0x827f22a8
	if ctx.cr[6].gt {
	pc = 0x827F22A8; continue 'dispatch;
	}
	pc = 0x827F22A4; continue 'dispatch;
            }
            0x827F22A4 => {
    //   block [0x827F22A4..0x827F22A8)
	// 827F22A4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F22A8; continue 'dispatch;
            }
            0x827F22A8 => {
    //   block [0x827F22A8..0x827F22D4)
	// 827F22A8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F22AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F22B0: 388BA0A0  addi r4, r11, -0x5f60
	ctx.r[4].s64 = ctx.r[11].s64 + -24416;
	// 827F22B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F22B8: 4BA3AC19  bl 0x8222ced0
	ctx.lr = 0x827F22BC;
	sub_8222CED0(ctx, base);
	// 827F22BC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F22C0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F22C4: 4BC342DD  bl 0x824265a0
	ctx.lr = 0x827F22C8;
	sub_824265A0(ctx, base);
	// 827F22C8: 907E0090  stw r3, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[3].u32 ) };
	// 827F22CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F22D0: 484B7184  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F22D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F22D8 size=220
    let mut pc: u32 = 0x827F22D8;
    'dispatch: loop {
        match pc {
            0x827F22D8 => {
    //   block [0x827F22D8..0x827F2310)
	// 827F22D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F22DC: 484B7131  bl 0x82ca940c
	ctx.lr = 0x827F22E0;
	sub_82CA93D0(ctx, base);
	// 827F22E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F22E4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F22E8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 827F22EC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F22F0: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 827F22F4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F22F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F22FC: 419A0014  beq cr6, 0x827f2310
	if ctx.cr[6].eq {
	pc = 0x827F2310; continue 'dispatch;
	}
	// 827F2300: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2304: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F2308: 7D291671  srawi. r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827F230C: 4082000C  bne 0x827f2318
	if !ctx.cr[0].eq {
	pc = 0x827F2318; continue 'dispatch;
	}
	pc = 0x827F2310; continue 'dispatch;
            }
            0x827F2310 => {
    //   block [0x827F2310..0x827F2318)
	// 827F2310: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827F2314: 48000034  b 0x827f2348
	pc = 0x827F2348; continue 'dispatch;
            }
            0x827F2318 => {
    //   block [0x827F2318..0x827F2324)
	// 827F2318: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F231C: 40990008  ble cr6, 0x827f2324
	if !ctx.cr[6].gt {
	pc = 0x827F2324; continue 'dispatch;
	}
	// 827F2320: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2324; continue 'dispatch;
            }
            0x827F2324 => {
    //   block [0x827F2324..0x827F2338)
	// 827F2324: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 827F2328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F232C: 419A000C  beq cr6, 0x827f2338
	if ctx.cr[6].eq {
	pc = 0x827F2338; continue 'dispatch;
	}
	// 827F2330: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F2334: 419A0008  beq cr6, 0x827f233c
	if ctx.cr[6].eq {
	pc = 0x827F233C; continue 'dispatch;
	}
	pc = 0x827F2338; continue 'dispatch;
            }
            0x827F2338 => {
    //   block [0x827F2338..0x827F233C)
	// 827F2338: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F233C; continue 'dispatch;
            }
            0x827F233C => {
    //   block [0x827F233C..0x827F2348)
	// 827F233C: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827F2340: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F2344: 7D3E1670  srawi r30, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x827F2348; continue 'dispatch;
            }
            0x827F2348 => {
    //   block [0x827F2348..0x827F2368)
	// 827F2348: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F234C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F2350: 48000069  bl 0x827f23b8
	ctx.lr = 0x827F2354;
	sub_827F23B8(ctx, base);
	// 827F2354: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2358: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F235C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F2360: 40990008  ble cr6, 0x827f2368
	if !ctx.cr[6].gt {
	pc = 0x827F2368; continue 'dispatch;
	}
	// 827F2364: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2368; continue 'dispatch;
            }
            0x827F2368 => {
    //   block [0x827F2368..0x827F2398)
	// 827F2368: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F236C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2370: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827F2374: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F2378: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F237C: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F2380: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F2384: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 827F2388: 41990010  bgt cr6, 0x827f2398
	if ctx.cr[6].gt {
	pc = 0x827F2398; continue 'dispatch;
	}
	// 827F238C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2390: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F2394: 40980008  bge cr6, 0x827f239c
	if !ctx.cr[6].lt {
	pc = 0x827F239C; continue 'dispatch;
	}
	pc = 0x827F2398; continue 'dispatch;
            }
            0x827F2398 => {
    //   block [0x827F2398..0x827F239C)
	// 827F2398: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F239C; continue 'dispatch;
            }
            0x827F239C => {
    //   block [0x827F239C..0x827F23B4)
	// 827F239C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F23A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F23A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F23A8: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 827F23AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F23B0: 484B70AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F23B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F23B8 size=692
    let mut pc: u32 = 0x827F23B8;
    'dispatch: loop {
        match pc {
            0x827F23B8 => {
    //   block [0x827F23B8..0x827F23E4)
	// 827F23B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F23BC: 484B7045  bl 0x82ca9400
	ctx.lr = 0x827F23C0;
	sub_82CA93D0(ctx, base);
	// 827F23C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F23C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F23C8: 83460000  lwz r26, 0(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F23CC: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 827F23D0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F23D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F23D8: 409A000C  bne cr6, 0x827f23e4
	if !ctx.cr[6].eq {
	pc = 0x827F23E4; continue 'dispatch;
	}
	// 827F23DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F23E0: 48000010  b 0x827f23f0
	pc = 0x827F23F0; continue 'dispatch;
            }
            0x827F23E4 => {
    //   block [0x827F23E4..0x827F23F0)
	// 827F23E4: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F23E8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F23EC: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x827F23F0; continue 'dispatch;
            }
            0x827F23F0 => {
    //   block [0x827F23F0..0x827F2400)
	// 827F23F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F23F4: 409A000C  bne cr6, 0x827f2400
	if !ctx.cr[6].eq {
	pc = 0x827F2400; continue 'dispatch;
	}
	// 827F23F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F23FC: 48000010  b 0x827f240c
	pc = 0x827F240C; continue 'dispatch;
            }
            0x827F2400 => {
    //   block [0x827F2400..0x827F240C)
	// 827F2400: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2404: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F2408: 7D0B1670  srawi r11, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 2) as i64;
	pc = 0x827F240C; continue 'dispatch;
            }
            0x827F240C => {
    //   block [0x827F240C..0x827F242C)
	// 827F240C: 3D003FFF  lis r8, 0x3fff
	ctx.r[8].s64 = 1073676288;
	// 827F2410: 6108FFFF  ori r8, r8, 0xffff
	ctx.r[8].u64 = ctx.r[8].u64 | 65535;
	// 827F2414: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 827F2418: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 827F241C: 40980010  bge cr6, 0x827f242c
	if !ctx.cr[6].lt {
	pc = 0x827F242C; continue 'dispatch;
	}
	// 827F2420: 4BD026B1  bl 0x824f4ad0
	ctx.lr = 0x827F2424;
	sub_824F4AD0(ctx, base);
	// 827F2424: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F2428: 484B7028  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F242C => {
    //   block [0x827F242C..0x827F243C)
	// 827F242C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F2430: 409A000C  bne cr6, 0x827f243c
	if !ctx.cr[6].eq {
	pc = 0x827F243C; continue 'dispatch;
	}
	// 827F2434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F2438: 48000010  b 0x827f2448
	pc = 0x827F2448; continue 'dispatch;
            }
            0x827F243C => {
    //   block [0x827F243C..0x827F2448)
	// 827F243C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2440: 7CEA5850  subf r7, r10, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F2444: 7CEB1670  srawi r11, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 2) as i64;
	pc = 0x827F2448; continue 'dispatch;
            }
            0x827F2448 => {
    //   block [0x827F2448..0x827F246C)
	// 827F2448: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F244C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F2450: 40980114  bge cr6, 0x827f2564
	if !ctx.cr[6].lt {
	pc = 0x827F2564; continue 'dispatch;
	}
	// 827F2454: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F2458: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 827F245C: 7D0B4050  subf r8, r11, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 827F2460: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F2464: 41980008  blt cr6, 0x827f246c
	if ctx.cr[6].lt {
	pc = 0x827F246C; continue 'dispatch;
	}
	// 827F2468: 7F6B4A14  add r27, r11, r9
	ctx.r[27].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x827F246C; continue 'dispatch;
            }
            0x827F246C => {
    //   block [0x827F246C..0x827F247C)
	// 827F246C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F2470: 409A000C  bne cr6, 0x827f247c
	if !ctx.cr[6].eq {
	pc = 0x827F247C; continue 'dispatch;
	}
	// 827F2474: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F2478: 48000010  b 0x827f2488
	pc = 0x827F2488; continue 'dispatch;
            }
            0x827F247C => {
    //   block [0x827F247C..0x827F2488)
	// 827F247C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2480: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F2484: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x827F2488; continue 'dispatch;
            }
            0x827F2488 => {
    //   block [0x827F2488..0x827F24A4)
	// 827F2488: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F248C: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F2490: 40980024  bge cr6, 0x827f24b4
	if !ctx.cr[6].lt {
	pc = 0x827F24B4; continue 'dispatch;
	}
	// 827F2494: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F2498: 409A000C  bne cr6, 0x827f24a4
	if !ctx.cr[6].eq {
	pc = 0x827F24A4; continue 'dispatch;
	}
	// 827F249C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F24A0: 48000010  b 0x827f24b0
	pc = 0x827F24B0; continue 'dispatch;
            }
            0x827F24A4 => {
    //   block [0x827F24A4..0x827F24B0)
	// 827F24A4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F24A8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F24AC: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	pc = 0x827F24B0; continue 'dispatch;
            }
            0x827F24B0 => {
    //   block [0x827F24B0..0x827F24B4)
	// 827F24B0: 3B6B0001  addi r27, r11, 1
	ctx.r[27].s64 = ctx.r[11].s64 + 1;
	pc = 0x827F24B4; continue 'dispatch;
            }
            0x827F24B4 => {
    //   block [0x827F24B4..0x827F24E8)
	// 827F24B4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F24B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F24BC: 48293B5D  bl 0x82a86018
	ctx.lr = 0x827F24C0;
	sub_82A86018(ctx, base);
	// 827F24C0: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F24C4: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 827F24C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F24CC: 7D65E850  subf r11, r5, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[5].s64;
	// 827F24D0: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F24D4: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 827F24D8: 7F86F214  add r28, r6, r30
	ctx.r[28].u64 = ctx.r[6].u64 + ctx.r[30].u64;
	// 827F24DC: 4182000C  beq 0x827f24e8
	if ctx.cr[0].eq {
	pc = 0x827F24E8; continue 'dispatch;
	}
	// 827F24E0: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 827F24E4: 484B7B45  bl 0x82caa028
	ctx.lr = 0x827F24E8;
	sub_82CAA028(ctx, base);
	pc = 0x827F24E8; continue 'dispatch;
            }
            0x827F24E8 => {
    //   block [0x827F24E8..0x827F2510)
	// 827F24E8: 935C0000  stw r26, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 827F24EC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F24F0: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F24F4: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F24F8: 41820018  beq 0x827f2510
	if ctx.cr[0].eq {
	pc = 0x827F2510; continue 'dispatch;
	}
	// 827F24FC: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 827F2500: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F2504: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 827F2508: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 827F250C: 484B7B1D  bl 0x82caa028
	ctx.lr = 0x827F2510;
	sub_82CAA028(ctx, base);
	pc = 0x827F2510; continue 'dispatch;
            }
            0x827F2510 => {
    //   block [0x827F2510..0x827F2524)
	// 827F2510: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F2518: 409A000C  bne cr6, 0x827f2524
	if !ctx.cr[6].eq {
	pc = 0x827F2524; continue 'dispatch;
	}
	// 827F251C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F2520: 48000010  b 0x827f2530
	pc = 0x827F2530; continue 'dispatch;
            }
            0x827F2524 => {
    //   block [0x827F2524..0x827F2530)
	// 827F2524: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2528: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 827F252C: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	pc = 0x827F2530; continue 'dispatch;
            }
            0x827F2530 => {
    //   block [0x827F2530..0x827F2540)
	// 827F2530: 3BAB0001  addi r29, r11, 1
	ctx.r[29].s64 = ctx.r[11].s64 + 1;
	// 827F2534: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F2538: 419A0008  beq cr6, 0x827f2540
	if ctx.cr[6].eq {
	pc = 0x827F2540; continue 'dispatch;
	}
	// 827F253C: 4BA297FD  bl 0x8221bd38
	ctx.lr = 0x827F2540;
	sub_8221BD38(ctx, base);
	pc = 0x827F2540; continue 'dispatch;
            }
            0x827F2540 => {
    //   block [0x827F2540..0x827F2564)
	// 827F2540: 576B103A  slwi r11, r27, 2
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F2544: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F2548: 57AA103A  slwi r10, r29, 2
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F254C: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827F2550: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 827F2554: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827F2558: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F255C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F2560: 484B6EF0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F2564 => {
    //   block [0x827F2564..0x827F2598)
	// 827F2564: 83A100AC  lwz r29, 0xac(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 827F2568: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F256C: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 827F2570: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 827F2574: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827F2578: 4098007C  bge cr6, 0x827f25f4
	if !ctx.cr[6].lt {
	pc = 0x827F25F4; continue 'dispatch;
	}
	// 827F257C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F2580: 419A0018  beq cr6, 0x827f2598
	if ctx.cr[6].eq {
	pc = 0x827F2598; continue 'dispatch;
	}
	// 827F2584: 5564103A  slwi r4, r11, 2
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 827F2588: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F258C: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 827F2590: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 827F2594: 484B7A95  bl 0x82caa028
	ctx.lr = 0x827F2598;
	sub_82CAA028(ctx, base);
	pc = 0x827F2598; continue 'dispatch;
            }
            0x827F2598 => {
    //   block [0x827F2598..0x827F25B4)
	// 827F2598: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F259C: 7D5D5850  subf r10, r29, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F25A0: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 827F25A4: 21490001  subfic r10, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[9].s64;
	// 827F25A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F25AC: 419A0014  beq cr6, 0x827f25c0
	if ctx.cr[6].eq {
	pc = 0x827F25C0; continue 'dispatch;
	}
	// 827F25B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x827F25B4; continue 'dispatch;
            }
            0x827F25B4 => {
    //   block [0x827F25B4..0x827F25C0)
	// 827F25B4: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 827F25B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827F25BC: 4200FFF8  bdnz 0x827f25b4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x827F25B4; continue 'dispatch;
	}
	pc = 0x827F25C0; continue 'dispatch;
            }
            0x827F25C0 => {
    //   block [0x827F25C0..0x827F25DC)
	// 827F25C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F25C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827F25C8: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 827F25CC: 392AFFFC  addi r9, r10, -4
	ctx.r[9].s64 = ctx.r[10].s64 + -4;
	// 827F25D0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F25D4: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F25D8: 419A008C  beq cr6, 0x827f2664
	if ctx.cr[6].eq {
	pc = 0x827F2664; continue 'dispatch;
	}
	pc = 0x827F25DC; continue 'dispatch;
            }
            0x827F25DC => {
    //   block [0x827F25DC..0x827F25F4)
	// 827F25DC: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 827F25E0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827F25E4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F25E8: 409AFFF4  bne cr6, 0x827f25dc
	if !ctx.cr[6].eq {
	pc = 0x827F25DC; continue 'dispatch;
	}
	// 827F25EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F25F0: 484B6E60  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F25F4 => {
    //   block [0x827F25F4..0x827F261C)
	// 827F25F4: 3B9EFFFC  addi r28, r30, -4
	ctx.r[28].s64 = ctx.r[30].s64 + -4;
	// 827F25F8: 7D7CF050  subf r11, r28, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[28].s64;
	// 827F25FC: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F2600: 5566103A  slwi r6, r11, 2
	ctx.r[6].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 827F2604: 7F66F214  add r27, r6, r30
	ctx.r[27].u64 = ctx.r[6].u64 + ctx.r[30].u64;
	// 827F2608: 41820014  beq 0x827f261c
	if ctx.cr[0].eq {
	pc = 0x827F261C; continue 'dispatch;
	}
	// 827F260C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F2610: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 827F2614: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F2618: 484B7A11  bl 0x82caa028
	ctx.lr = 0x827F261C;
	sub_82CAA028(ctx, base);
	pc = 0x827F261C; continue 'dispatch;
            }
            0x827F261C => {
    //   block [0x827F261C..0x827F2644)
	// 827F261C: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 827F2620: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 827F2624: 7D6B1671  srawi. r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F2628: 4081001C  ble 0x827f2644
	if !ctx.cr[0].gt {
	pc = 0x827F2644; continue 'dispatch;
	}
	// 827F262C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F2630: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F2634: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 827F2638: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827F263C: 7C6BF050  subf r3, r11, r30
	ctx.r[3].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 827F2640: 484B79E9  bl 0x82caa028
	ctx.lr = 0x827F2644;
	sub_82CAA028(ctx, base);
	pc = 0x827F2644; continue 'dispatch;
            }
            0x827F2644 => {
    //   block [0x827F2644..0x827F2654)
	// 827F2644: 395D0004  addi r10, r29, 4
	ctx.r[10].s64 = ctx.r[29].s64 + 4;
	// 827F2648: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827F264C: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F2650: 419A0014  beq cr6, 0x827f2664
	if ctx.cr[6].eq {
	pc = 0x827F2664; continue 'dispatch;
	}
	pc = 0x827F2654; continue 'dispatch;
            }
            0x827F2654 => {
    //   block [0x827F2654..0x827F2664)
	// 827F2654: 934B0000  stw r26, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 827F2658: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827F265C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F2660: 409AFFF4  bne cr6, 0x827f2654
	if !ctx.cr[6].eq {
	pc = 0x827F2654; continue 'dispatch;
	}
	pc = 0x827F2664; continue 'dispatch;
            }
            0x827F2664 => {
    //   block [0x827F2664..0x827F266C)
	// 827F2664: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F2668: 484B6DE8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F2670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F2670 size=96
    let mut pc: u32 = 0x827F2670;
    'dispatch: loop {
        match pc {
            0x827F2670 => {
    //   block [0x827F2670..0x827F26B0)
	// 827F2670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F2674: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F2678: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F267C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 827F2680: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 827F2684: 48231A5D  bl 0x82a240e0
	ctx.lr = 0x827F2688;
	sub_82A240E0(ctx, base);
	// 827F2688: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F268C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 827F2690: 419A0020  beq cr6, 0x827f26b0
	if ctx.cr[6].eq {
	pc = 0x827F26B0; continue 'dispatch;
	}
	// 827F2694: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F2698: 4BA3AEA1  bl 0x8222d538
	ctx.lr = 0x827F269C;
	sub_8222D538(ctx, base);
	// 827F269C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F26A0: 409A0010  bne cr6, 0x827f26b0
	if !ctx.cr[6].eq {
	pc = 0x827F26B0; continue 'dispatch;
	}
	// 827F26A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F26A8: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F26AC: 48000008  b 0x827f26b4
	pc = 0x827F26B4; continue 'dispatch;
            }
            0x827F26B0 => {
    //   block [0x827F26B0..0x827F26B4)
	// 827F26B0: C0030000  lfs f0, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x827F26B4; continue 'dispatch;
            }
            0x827F26B4 => {
    //   block [0x827F26B4..0x827F26D0)
	// 827F26B4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 827F26B8: D8010050  stfd f0, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.f[0].u64 ) };
	// 827F26BC: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F26C0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F26C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F26C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F26CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F26D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F26D0 size=136
    let mut pc: u32 = 0x827F26D0;
    'dispatch: loop {
        match pc {
            0x827F26D0 => {
    //   block [0x827F26D0..0x827F26FC)
	// 827F26D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F26D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F26D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F26DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F26E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F26E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F26E8: 3BDF00C0  addi r30, r31, 0xc0
	ctx.r[30].s64 = ctx.r[31].s64 + 192;
	// 827F26EC: 807F00C4  lwz r3, 0xc4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) } as u64;
	// 827F26F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F26F4: 419A0008  beq cr6, 0x827f26fc
	if ctx.cr[6].eq {
	pc = 0x827F26FC; continue 'dispatch;
	}
	// 827F26F8: 4BA29641  bl 0x8221bd38
	ctx.lr = 0x827F26FC;
	sub_8221BD38(ctx, base);
	pc = 0x827F26FC; continue 'dispatch;
            }
            0x827F26FC => {
    //   block [0x827F26FC..0x827F2758)
	// 827F26FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F2700: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 827F2704: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F2708: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F270C: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827F2710: 4BB210F9  bl 0x82313808
	ctx.lr = 0x827F2714;
	sub_82313808(ctx, base);
	// 827F2714: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 827F2718: 4B9C5401  bl 0x821b7b18
	ctx.lr = 0x827F271C;
	sub_821B7B18(ctx, base);
	// 827F271C: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 827F2720: 4B9C53F9  bl 0x821b7b18
	ctx.lr = 0x827F2724;
	sub_821B7B18(ctx, base);
	// 827F2724: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 827F2728: 4BA226B1  bl 0x82214dd8
	ctx.lr = 0x827F272C;
	sub_82214DD8(ctx, base);
	// 827F272C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2730: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 827F2734: 394BF058  addi r10, r11, -0xfa8
	ctx.r[10].s64 = ctx.r[11].s64 + -4008;
	// 827F2738: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F273C: 4BA2269D  bl 0x82214dd8
	ctx.lr = 0x827F2740;
	sub_82214DD8(ctx, base);
	// 827F2740: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F2744: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F2748: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F274C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F2750: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F2754: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F2758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F2758 size=140
    let mut pc: u32 = 0x827F2758;
    'dispatch: loop {
        match pc {
            0x827F2758 => {
    //   block [0x827F2758..0x827F27E4)
	// 827F2758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F275C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F2760: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F2764: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 827F2768: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827F276C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F2770: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 827F2774: C1610098  lfs f11, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F2778: F8A100A0  std r5, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[5].u64 ) };
	// 827F277C: C18100A0  lfs f12, 0xa0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827F2780: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F2784: C00100A4  lfs f0, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F2788: C1A1009C  lfs f13, 0x9c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F278C: EFE06828  fsubs f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 827F2790: EFCC5828  fsubs f30, f12, f11
	ctx.f[30].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 827F2794: D3C10050  stfs f30, 0x50(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 827F2798: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 827F279C: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F27A0: F89F0008  std r4, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u64 ) };
	// 827F27A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F27A8: F95F0000  std r10, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 827F27AC: C02B9A80  lfs f1, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F27B0: 4BAB6989  bl 0x822a9138
	ctx.lr = 0x827F27B4;
	sub_822A9138(ctx, base);
	// 827F27B4: ED5E07B2  fmuls f10, f30, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 827F27B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F27BC: ED3F57FA  fmadds f9, f31, f31, f10
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 827F27C0: ED00482C  fsqrts f8, f9
	ctx.f[8].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 827F27C4: D11F0010  stfs f8, 0x10(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 827F27C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F27CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F27D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F27D4: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 827F27D8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F27DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F27E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F27E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F27E8 size=360
    let mut pc: u32 = 0x827F27E8;
    'dispatch: loop {
        match pc {
            0x827F27E8 => {
    //   block [0x827F27E8..0x827F2950)
	// 827F27E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F27EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F27F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F27F4: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 827F27F8: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 827F27FC: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827F2800: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F2950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F2950 size=112
    let mut pc: u32 = 0x827F2950;
    'dispatch: loop {
        match pc {
            0x827F2950 => {
    //   block [0x827F2950..0x827F29C0)
	// 827F2950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F2954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F2958: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F295C: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 827F2960: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 827F2964: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F2968: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 827F296C: C3E1008C  lfs f31, 0x8c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F2970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F2974: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827F2978: 4BA47539  bl 0x82239eb0
	ctx.lr = 0x827F297C;
	sub_82239EB0(ctx, base);
	// 827F297C: FFC00818  frsp f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (ctx.f[1].f64 as f32) as f64;
	// 827F2980: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827F2984: 4BA4760D  bl 0x82239f90
	ctx.lr = 0x827F2988;
	sub_82239F90(ctx, base);
	// 827F2988: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 827F298C: C0010088  lfs f0, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F2990: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 827F2994: D19F0004  stfs f12, 4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 827F2998: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F299C: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 827F29A0: D17F0000  stfs f11, 0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827F29A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F29A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F29AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F29B0: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 827F29B4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F29B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F29BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F29C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F29C0 size=228
    let mut pc: u32 = 0x827F29C0;
    'dispatch: loop {
        match pc {
            0x827F29C0 => {
    //   block [0x827F29C0..0x827F2AA4)
	// 827F29C0: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 827F29C4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 827F29C8: 409A00E8  bne cr6, 0x827f2ab0
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x827F2AB0);
		return;
	}
	// 827F29CC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F29D0: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 827F29D4: 39200030  li r9, 0x30
	ctx.r[9].s64 = 48;
	// 827F29D8: 38EA90F0  addi r7, r10, -0x6f10
	ctx.r[7].s64 = ctx.r[10].s64 + -28432;
	// 827F29DC: 39000070  li r8, 0x70
	ctx.r[8].s64 = 112;
	// 827F29E0: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 827F29E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F2AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F2AC0 size=244
    let mut pc: u32 = 0x827F2AC0;
    'dispatch: loop {
        match pc {
            0x827F2AC0 => {
    //   block [0x827F2AC0..0x827F2BB4)
	// 827F2AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F2AC4: 484B6945  bl 0x82ca9408
	ctx.lr = 0x827F2AC8;
	sub_82CA93D0(ctx, base);
	// 827F2AC8: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F2ACC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F2AD0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 827F2AD4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 827F2AD8: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 827F2ADC: 38E99160  addi r7, r9, -0x6ea0
	ctx.r[7].s64 = ctx.r[9].s64 + -28320;
	// 827F2AE0: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F2AE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F2AE8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 827F2AEC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F2BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F2BB8 size=2524
    let mut pc: u32 = 0x827F2BB8;
    'dispatch: loop {
        match pc {
            0x827F2BB8 => {
    //   block [0x827F2BB8..0x827F2C94)
	// 827F2BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F2BBC: 484B6829  bl 0x82ca93e4
	ctx.lr = 0x827F2BC0;
	sub_82CA93D0(ctx, base);
	// 827F2BC0: 3981FF90  addi r12, r1, -0x70
	ctx.r[12].s64 = ctx.r[1].s64 + -112;
	// 827F2BC4: 484BB115  bl 0x82cadcd8
	ctx.lr = 0x827F2BC8;
	sub_82CADCA0(ctx, base);
	// 827F2BC8: 9421FE90  stwu r1, -0x170(r1)
	ea = ctx.r[1].u32.wrapping_add(-368 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F2BCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F2BD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F2BD4: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 827F2BD8: 3ACBBC68  addi r22, r11, -0x4398
	ctx.r[22].s64 = ctx.r[11].s64 + -17304;
	// 827F2BDC: 3D208210  lis r9, -0x7df0
	ctx.r[9].s64 = -2112880640;
	// 827F2BE0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827F2BE4: 3A7F00D0  addi r19, r31, 0xd0
	ctx.r[19].s64 = ctx.r[31].s64 + 208;
	// 827F2BE8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 827F2BEC: C3AA1000  lfs f29, 0x1000(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4096 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 827F2BF0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827F2BF4: C3F61960  lfs f31, 0x1960(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(6496 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F2BF8: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 827F2BFC: D3FF0034  stfs f31, 0x34(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 827F2C00: D3BF0038  stfs f29, 0x38(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 827F2C04: 93BF00C4  stw r29, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[29].u32 ) };
	// 827F2C08: C3890FFC  lfs f28, 0xffc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4092 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 827F2C0C: 93BF00C8  stw r29, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[29].u32 ) };
	// 827F2C10: D3FF003C  stfs f31, 0x3c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 827F2C14: 93BF00CC  stw r29, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[29].u32 ) };
	// 827F2C18: D39F0040  stfs f28, 0x40(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 827F2C1C: 7E639B78  mr r3, r19
	ctx.r[3].u64 = ctx.r[19].u64;
	// 827F2C20: D3FF0044  stfs f31, 0x44(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 827F2C24: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 827F2C28: D3BF0048  stfs f29, 0x48(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 827F2C2C: 3B3F0080  addi r25, r31, 0x80
	ctx.r[25].s64 = ctx.r[31].s64 + 128;
	// 827F2C30: D3FF004C  stfs f31, 0x4c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 827F2C34: 3B1F0090  addi r24, r31, 0x90
	ctx.r[24].s64 = ctx.r[31].s64 + 144;
	// 827F2C38: D39F0050  stfs f28, 0x50(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 827F2C3C: 3A9F00C0  addi r20, r31, 0xc0
	ctx.r[20].s64 = ctx.r[31].s64 + 192;
	// 827F2C40: D3FF0080  stfs f31, 0x80(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 827F2C44: D3BF0084  stfs f29, 0x84(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 827F2C48: D3FF0088  stfs f31, 0x88(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 827F2C4C: D39F008C  stfs f28, 0x8c(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 827F2C50: D3FF0090  stfs f31, 0x90(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 827F2C54: D3BF0094  stfs f29, 0x94(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 827F2C58: D3FF0098  stfs f31, 0x98(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 827F2C5C: D39F009C  stfs f28, 0x9c(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 827F2C60: 4BBB0419  bl 0x823a3078
	ctx.lr = 0x827F2C64;
	sub_823A3078(ctx, base);
	// 827F2C64: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 827F2C68: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827F2C6C: 38A81034  addi r5, r8, 0x1034
	ctx.r[5].s64 = ctx.r[8].s64 + 4148;
	// 827F2C70: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827F2C74: 4BBDB49D  bl 0x823ce110
	ctx.lr = 0x827F2C78;
	sub_823CE110(ctx, base);
	// 827F2C78: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827F2C7C: 4BC65745  bl 0x824583c0
	ctx.lr = 0x827F2C80;
	sub_824583C0(ctx, base);
	// 827F2C80: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F2C84: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 827F2C88: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827F2C8C: 3AAB7088  addi r21, r11, 0x7088
	ctx.r[21].s64 = ctx.r[11].s64 + 28808;
	// 827F2C90: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	pc = 0x827F2C94; continue 'dispatch;
            }
            0x827F2C94 => {
    //   block [0x827F2C94..0x827F2CD0)
	// 827F2C94: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 827F2C98: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2C9C: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 827F2CA0: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 827F2CA4: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F2CA8: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2CAC: 4082FFE8  bne 0x827f2c94
	if !ctx.cr[0].eq {
	pc = 0x827F2C94; continue 'dispatch;
	}
	// 827F2CB0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827F2CB4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F2CB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F2CBC: 4BBCC3B5  bl 0x823bf070
	ctx.lr = 0x827F2CC0;
	sub_823BF070(ctx, base);
	// 827F2CC0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827F2CC4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827F2CC8: 419A00B4  beq cr6, 0x827f2d7c
	if ctx.cr[6].eq {
	pc = 0x827F2D7C; continue 'dispatch;
	}
	// 827F2CCC: 7FBBEB78  mr r27, r29
	ctx.r[27].u64 = ctx.r[29].u64;
	pc = 0x827F2CD0; continue 'dispatch;
            }
            0x827F2CD0 => {
    //   block [0x827F2CD0..0x827F2CD8)
	// 827F2CD0: 7EA8AB78  mr r8, r21
	ctx.r[8].u64 = ctx.r[21].u64;
	// 827F2CD4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	pc = 0x827F2CD8; continue 'dispatch;
            }
            0x827F2CD8 => {
    //   block [0x827F2CD8..0x827F2D14)
	// 827F2CD8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F2CDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2CE0: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F2CE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F2CE8: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F2CEC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2CF0: 4082FFE8  bne 0x827f2cd8
	if !ctx.cr[0].eq {
	pc = 0x827F2CD8; continue 'dispatch;
	}
	// 827F2CF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2CF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F2CFC: 419A0018  beq cr6, 0x827f2d14
	if ctx.cr[6].eq {
	pc = 0x827F2D14; continue 'dispatch;
	}
	// 827F2D00: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2D04: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 827F2D08: 7D091670  srawi r9, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 827F2D0C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F2D10: 41980008  blt cr6, 0x827f2d18
	if ctx.cr[6].lt {
	pc = 0x827F2D18; continue 'dispatch;
	}
	pc = 0x827F2D14; continue 'dispatch;
            }
            0x827F2D14 => {
    //   block [0x827F2D14..0x827F2D18)
	// 827F2D14: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F2D18; continue 'dispatch;
            }
            0x827F2D18 => {
    //   block [0x827F2D18..0x827F2D4C)
	// 827F2D18: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 827F2D1C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 827F2D20: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F2D24: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 827F2D28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F2D2C: 7F5B5214  add r26, r27, r10
	ctx.r[26].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 827F2D30: 4BC71199  bl 0x82463ec8
	ctx.lr = 0x827F2D34;
	sub_82463EC8(ctx, base);
	// 827F2D34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F2D38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F2D3C: 4BA72465  bl 0x822651a0
	ctx.lr = 0x827F2D40;
	sub_822651A0(ctx, base);
	// 827F2D40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F2D44: 4B9D3A25  bl 0x821c6768
	ctx.lr = 0x827F2D48;
	sub_821C6768(ctx, base);
	// 827F2D48: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	pc = 0x827F2D4C; continue 'dispatch;
            }
            0x827F2D4C => {
    //   block [0x827F2D4C..0x827F2D7C)
	// 827F2D4C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F2D50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2D54: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F2D58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F2D5C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F2D60: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F2D64: 4082FFE8  bne 0x827f2d4c
	if !ctx.cr[0].eq {
	pc = 0x827F2D4C; continue 'dispatch;
	}
	// 827F2D68: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 827F2D6C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 827F2D70: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 827F2D74: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827F2D78: 409AFF58  bne cr6, 0x827f2cd0
	if !ctx.cr[6].eq {
	pc = 0x827F2CD0; continue 'dispatch;
	}
	pc = 0x827F2D7C; continue 'dispatch;
            }
            0x827F2D7C => {
    //   block [0x827F2D7C..0x827F2E84)
	// 827F2D7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2D80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2D84: 388BA1C0  addi r4, r11, -0x5e40
	ctx.r[4].s64 = ctx.r[11].s64 + -24128;
	// 827F2D88: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2D8C: 4BAAB065  bl 0x8229ddf0
	ctx.lr = 0x827F2D90;
	sub_8229DDF0(ctx, base);
	// 827F2D90: 907F0010  stw r3, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[3].u32 ) };
	// 827F2D94: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F2D98: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F2D9C: 388AA1D0  addi r4, r10, -0x5e30
	ctx.r[4].s64 = ctx.r[10].s64 + -24112;
	// 827F2DA0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2DA4: 4BAAB04D  bl 0x8229ddf0
	ctx.lr = 0x827F2DA8;
	sub_8229DDF0(ctx, base);
	// 827F2DA8: 907F0014  stw r3, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 827F2DAC: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827F2DB0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2DB4: 3889A1E0  addi r4, r9, -0x5e20
	ctx.r[4].s64 = ctx.r[9].s64 + -24096;
	// 827F2DB8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2DBC: 4BAAB035  bl 0x8229ddf0
	ctx.lr = 0x827F2DC0;
	sub_8229DDF0(ctx, base);
	// 827F2DC0: 907F0018  stw r3, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 827F2DC4: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827F2DC8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F2DCC: 3888A1F0  addi r4, r8, -0x5e10
	ctx.r[4].s64 = ctx.r[8].s64 + -24080;
	// 827F2DD0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2DD4: 4BAAB01D  bl 0x8229ddf0
	ctx.lr = 0x827F2DD8;
	sub_8229DDF0(ctx, base);
	// 827F2DD8: 907F001C  stw r3, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 827F2DDC: 81770000  lwz r11, 0(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F2DE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F2DE4: 419A00A8  beq cr6, 0x827f2e8c
	if ctx.cr[6].eq {
	pc = 0x827F2E8C; continue 'dispatch;
	}
	// 827F2DE8: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F2DEC: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2DF0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F2DF4: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 827F2DF8: 4BA36369  bl 0x82229160
	ctx.lr = 0x827F2DFC;
	sub_82229160(ctx, base);
	// 827F2DFC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F2E00: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2E04: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827F2E08: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 827F2E0C: 38A9A1F8  addi r5, r9, -0x5e08
	ctx.r[5].s64 = ctx.r[9].s64 + -24072;
	// 827F2E10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F2E14: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F2E18: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F2E1C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2E20: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 827F2E24: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2E28: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 827F2E2C: 90DE0008  stw r6, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 827F2E30: 4BA35559  bl 0x82228388
	ctx.lr = 0x827F2E34;
	sub_82228388(ctx, base);
	// 827F2E34: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2E38: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 827F2E3C: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 827F2E40: 38859700  addi r4, r5, -0x6900
	ctx.r[4].s64 = ctx.r[5].s64 + -26880;
	// 827F2E44: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827F2E48: 419A003C  beq cr6, 0x827f2e84
	if ctx.cr[6].eq {
	pc = 0x827F2E84; continue 'dispatch;
	}
	// 827F2E4C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F2E50: 2F0A0003  cmpwi cr6, r10, 3
	ctx.cr[6].compare_i32(ctx.r[10].s32, 3, &mut ctx.xer);
	// 827F2E54: 409A0030  bne cr6, 0x827f2e84
	if !ctx.cr[6].eq {
	pc = 0x827F2E84; continue 'dispatch;
	}
	// 827F2E58: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827F2E5C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F2E60: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F2E64: 9BAB0000  stb r29, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u8 ) };
	// 827F2E68: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F2E6C: 4BB3381D  bl 0x82326688
	ctx.lr = 0x827F2E70;
	sub_82326688(ctx, base);
	// 827F2E70: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F2E74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F2E78: 394AFFF0  addi r10, r10, -0x10
	ctx.r[10].s64 = ctx.r[10].s64 + -16;
	// 827F2E7C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F2E80: 48000010  b 0x827f2e90
	pc = 0x827F2E90; continue 'dispatch;
            }
            0x827F2E84 => {
    //   block [0x827F2E84..0x827F2E8C)
	// 827F2E84: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 827F2E88: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x827F2E8C; continue 'dispatch;
            }
            0x827F2E8C => {
    //   block [0x827F2E8C..0x827F2E90)
	// 827F2E8C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827F2E90; continue 'dispatch;
            }
            0x827F2E90 => {
    //   block [0x827F2E90..0x827F2F94)
	// 827F2E90: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 827F2E94: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2E98: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2E9C: 388BA204  addi r4, r11, -0x5dfc
	ctx.r[4].s64 = ctx.r[11].s64 + -24060;
	// 827F2EA0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2EA4: 4B9F1415  bl 0x821e42b8
	ctx.lr = 0x827F2EA8;
	sub_821E42B8(ctx, base);
	// 827F2EA8: 987F0024  stb r3, 0x24(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u8 ) };
	// 827F2EAC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F2EB0: C3D6D81C  lfs f30, -0x27e4(r22)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-10212 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827F2EB4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2EB8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 827F2EBC: 388A0F64  addi r4, r10, 0xf64
	ctx.r[4].s64 = ctx.r[10].s64 + 3940;
	// 827F2EC0: 4B9EC599  bl 0x821df458
	ctx.lr = 0x827F2EC4;
	sub_821DF458(ctx, base);
	// 827F2EC4: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 827F2EC8: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827F2ECC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2ED0: 3889A218  addi r4, r9, -0x5de8
	ctx.r[4].s64 = ctx.r[9].s64 + -24040;
	// 827F2ED4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2ED8: 4BAAAF19  bl 0x8229ddf0
	ctx.lr = 0x827F2EDC;
	sub_8229DDF0(ctx, base);
	// 827F2EDC: 907F002C  stw r3, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 827F2EE0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827F2EE4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827F2EE8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2EEC: 3888A224  addi r4, r8, -0x5ddc
	ctx.r[4].s64 = ctx.r[8].s64 + -24028;
	// 827F2EF0: 4B9EC569  bl 0x821df458
	ctx.lr = 0x827F2EF4;
	sub_821DF458(ctx, base);
	// 827F2EF4: D03F00E8  stfs f1, 0xe8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 827F2EF8: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 827F2EFC: C036D828  lfs f1, -0x27d8(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-10200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F2F00: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2F04: 3887A230  addi r4, r7, -0x5dd0
	ctx.r[4].s64 = ctx.r[7].s64 + -24016;
	// 827F2F08: 4B9EC551  bl 0x821df458
	ctx.lr = 0x827F2F0C;
	sub_821DF458(ctx, base);
	// 827F2F0C: D03F00EC  stfs f1, 0xec(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(236 as u32), tmp.u32 ) };
	// 827F2F10: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 827F2F14: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2F18: 3886A248  addi r4, r6, -0x5db8
	ctx.r[4].s64 = ctx.r[6].s64 + -23992;
	// 827F2F1C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2F20: 4B9F1399  bl 0x821e42b8
	ctx.lr = 0x827F2F24;
	sub_821E42B8(ctx, base);
	// 827F2F24: 987F0030  stb r3, 0x30(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[3].u8 ) };
	// 827F2F28: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 827F2F2C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F2F30: 3884A254  addi r4, r4, -0x5dac
	ctx.r[4].s64 = ctx.r[4].s64 + -23980;
	// 827F2F34: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2F38: 4B9F1381  bl 0x821e42b8
	ctx.lr = 0x827F2F3C;
	sub_821E42B8(ctx, base);
	// 827F2F3C: 987F0031  stb r3, 0x31(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(49 as u32), ctx.r[3].u8 ) };
	// 827F2F40: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 827F2F44: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F2F48: 3883A260  addi r4, r3, -0x5da0
	ctx.r[4].s64 = ctx.r[3].s64 + -23968;
	// 827F2F4C: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2F50: 4B9F1369  bl 0x821e42b8
	ctx.lr = 0x827F2F54;
	sub_821E42B8(ctx, base);
	// 827F2F54: 987F0032  stb r3, 0x32(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(50 as u32), ctx.r[3].u8 ) };
	// 827F2F58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2F5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F2F60: 388BA274  addi r4, r11, -0x5d8c
	ctx.r[4].s64 = ctx.r[11].s64 + -23948;
	// 827F2F64: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 827F2F68: 4B9F1351  bl 0x821e42b8
	ctx.lr = 0x827F2F6C;
	sub_821E42B8(ctx, base);
	// 827F2F6C: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F2F70: 987F0033  stb r3, 0x33(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(51 as u32), ctx.r[3].u8 ) };
	// 827F2F74: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F2F78: 409A001C  bne cr6, 0x827f2f94
	if !ctx.cr[6].eq {
	pc = 0x827F2F94; continue 'dispatch;
	}
	// 827F2F7C: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 827F2F80: 396BFFFE  addi r11, r11, -2
	ctx.r[11].s64 = ctx.r[11].s64 + -2;
	// 827F2F84: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827F2F88: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 827F2F8C: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 827F2F90: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	pc = 0x827F2F94; continue 'dispatch;
            }
            0x827F2F94 => {
    //   block [0x827F2F94..0x827F305C)
	// 827F2F94: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F2F98: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827F2F9C: 38ABA284  addi r5, r11, -0x5d7c
	ctx.r[5].s64 = ctx.r[11].s64 + -23932;
	// 827F2FA0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827F2FA4: 4BBDB16D  bl 0x823ce110
	ctx.lr = 0x827F2FA8;
	sub_823CE110(ctx, base);
	// 827F2FA8: 81410090  lwz r10, 0x90(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 827F2FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F2FB0: 419A00AC  beq cr6, 0x827f305c
	if ctx.cr[6].eq {
	pc = 0x827F305C; continue 'dispatch;
	}
	// 827F2FB4: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 827F2FB8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F2FBC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827F2FC0: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	pc = 0x827F305C; continue 'dispatch;
            }
            0x827F305C => {
    //   block [0x827F305C..0x827F3594)
	// 827F305C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F3060: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827F3064: 38ABA290  addi r5, r11, -0x5d70
	ctx.r[5].s64 = ctx.r[11].s64 + -23920;
	// 827F3068: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827F306C: 4BBDB0A5  bl 0x823ce110
	ctx.lr = 0x827F3070;
	sub_823CE110(ctx, base);
	// 827F3070: 81410088  lwz r10, 0x88(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827F3074: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F3078: 419A00AC  beq cr6, 0x827f3124
	if ctx.cr[6].eq {
	pc = 0x827F3124; continue 'dispatch;
	}
	// 827F307C: 396100D0  addi r11, r1, 0xd0
	ctx.r[11].s64 = ctx.r[1].s64 + 208;
	// 827F3080: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F3084: 38810088  addi r4, r1, 0x88
	ctx.r[4].s64 = ctx.r[1].s64 + 136;
	// 827F3088: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F3598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F3598 size=564
    let mut pc: u32 = 0x827F3598;
    'dispatch: loop {
        match pc {
            0x827F3598 => {
    //   block [0x827F3598..0x827F3608)
	// 827F3598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F359C: 484B5E55  bl 0x82ca93f0
	ctx.lr = 0x827F35A0;
	sub_82CA93D0(ctx, base);
	// 827F35A0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F35A4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F35A8: 3B0BBAFC  addi r24, r11, -0x4504
	ctx.r[24].s64 = ctx.r[11].s64 + -17668;
	// 827F35AC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F35B0: 48005279  bl 0x827f8828
	ctx.lr = 0x827F35B4;
	sub_827F8828(ctx, base);
	// 827F35B4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F35B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F35BC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827F35C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F35C4: 812A0078  lwz r9, 0x78(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 827F35C8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F35CC: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F35D0: 4BBDAFF1  bl 0x823ce5c0
	ctx.lr = 0x827F35D4;
	sub_823CE5C0(ctx, base);
	// 827F35D4: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 827F35D8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827F35DC: 38A7A358  addi r5, r7, -0x5ca8
	ctx.r[5].s64 = ctx.r[7].s64 + -23720;
	// 827F35E0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F35E4: 4BBDAB2D  bl 0x823ce110
	ctx.lr = 0x827F35E8;
	sub_823CE110(ctx, base);
	// 827F35E8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 827F35EC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827F35F0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 827F35F4: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 827F35F8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827F35FC: 3AEBFFDF  addi r23, r11, -0x21
	ctx.r[23].s64 = ctx.r[11].s64 + -33;
	// 827F3600: 3B2A7088  addi r25, r10, 0x7088
	ctx.r[25].s64 = ctx.r[10].s64 + 28808;
	// 827F3604: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	pc = 0x827F3608; continue 'dispatch;
            }
            0x827F3608 => {
    //   block [0x827F3608..0x827F3664)
	// 827F3608: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827F360C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827F3610: 419A0054  beq cr6, 0x827f3664
	if ctx.cr[6].eq {
	pc = 0x827F3664; continue 'dispatch;
	}
	// 827F3614: 83FB0000  lwz r31, 0(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3618: 809B0004  lwz r4, 4(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F361C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F3620: 806B005C  lwz r3, 0x5c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(92 as u32) ) } as u64;
	// 827F3624: 4BA35B3D  bl 0x82229160
	ctx.lr = 0x827F3628;
	sub_82229160(ctx, base);
	// 827F3628: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F362C: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F3630: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 827F3634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F3638: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F363C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F3640: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3644: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 827F3648: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F364C: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 827F3650: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 827F3654: 4BAE4235  bl 0x822d7888
	ctx.lr = 0x827F3658;
	sub_822D7888(ctx, base);
	// 827F3658: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F365C: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 827F3660: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x827F3664; continue 'dispatch;
            }
            0x827F3664 => {
    //   block [0x827F3664..0x827F3674)
	// 827F3664: 7F1A1840  cmplw cr6, r26, r3
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[3].u32, &mut ctx.xer);
	// 827F3668: 4199014C  bgt cr6, 0x827f37b4
	if ctx.cr[6].gt {
	pc = 0x827F37B4; continue 'dispatch;
	}
	// 827F366C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 827F3670: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x827F3674; continue 'dispatch;
            }
            0x827F3674 => {
    //   block [0x827F3674..0x827F36B8)
	// 827F3674: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F3678: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F367C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F3680: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F3684: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F3688: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F368C: 4082FFE8  bne 0x827f3674
	if !ctx.cr[0].eq {
	pc = 0x827F3674; continue 'dispatch;
	}
	// 827F3690: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 827F3694: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827F3698: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 827F369C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F36A0: 4BC70829  bl 0x82463ec8
	ctx.lr = 0x827F36A4;
	sub_82463EC8(ctx, base);
	// 827F36A4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F36A8: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 827F36AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F36B0: 419A0008  beq cr6, 0x827f36b8
	if ctx.cr[6].eq {
	pc = 0x827F36B8; continue 'dispatch;
	}
	// 827F36B4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F36B8; continue 'dispatch;
            }
            0x827F36B8 => {
    //   block [0x827F36B8..0x827F36F0)
	// 827F36B8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827F36BC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F36C0: 4BBDAA51  bl 0x823ce110
	ctx.lr = 0x827F36C4;
	sub_823CE110(ctx, base);
	// 827F36C4: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827F36C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F36CC: 419A00AC  beq cr6, 0x827f3778
	if ctx.cr[6].eq {
	pc = 0x827F3778; continue 'dispatch;
	}
	// 827F36D0: 386000F0  li r3, 0xf0
	ctx.r[3].s64 = 240;
	// 827F36D4: 4BA2BB85  bl 0x8221f258
	ctx.lr = 0x827F36D8;
	sub_8221F258(ctx, base);
	// 827F36D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F36DC: 419A0014  beq cr6, 0x827f36f0
	if ctx.cr[6].eq {
	pc = 0x827F36F0; continue 'dispatch;
	}
	// 827F36E0: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827F36E4: 4BFFF4D5  bl 0x827f2bb8
	ctx.lr = 0x827F36E8;
	sub_827F2BB8(ctx, base);
	// 827F36E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F36EC: 48000008  b 0x827f36f4
	pc = 0x827F36F4; continue 'dispatch;
            }
            0x827F36F0 => {
    //   block [0x827F36F0..0x827F36F4)
	// 827F36F0: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	pc = 0x827F36F4; continue 'dispatch;
            }
            0x827F36F4 => {
    //   block [0x827F36F4..0x827F372C)
	// 827F36F4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 827F36F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F36FC: 419A0030  beq cr6, 0x827f372c
	if ctx.cr[6].eq {
	pc = 0x827F372C; continue 'dispatch;
	}
	// 827F3700: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F3704: 4BA2BB55  bl 0x8221f258
	ctx.lr = 0x827F3708;
	sub_8221F258(ctx, base);
	// 827F3708: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F370C: 419A0020  beq cr6, 0x827f372c
	if ctx.cr[6].eq {
	pc = 0x827F372C; continue 'dispatch;
	}
	// 827F3710: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 827F3714: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827F3718: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F371C: 92C30000  stw r22, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 827F3720: 394B8EE8  addi r10, r11, -0x7118
	ctx.r[10].s64 = ctx.r[11].s64 + -28952;
	// 827F3724: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827F3728: 48000008  b 0x827f3730
	pc = 0x827F3730; continue 'dispatch;
            }
            0x827F372C => {
    //   block [0x827F372C..0x827F3730)
	// 827F372C: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x827F3730; continue 'dispatch;
            }
            0x827F3730 => {
    //   block [0x827F3730..0x827F3770)
	// 827F3730: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F3734: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 827F3738: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F373C: 48004F1D  bl 0x827f8658
	ctx.lr = 0x827F3740;
	sub_827F8658(ctx, base);
	// 827F3740: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F3744: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3748: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F374C: 419A0024  beq cr6, 0x827f3770
	if ctx.cr[6].eq {
	pc = 0x827F3770; continue 'dispatch;
	}
	// 827F3750: 4B9C43C9  bl 0x821b7b18
	ctx.lr = 0x827F3754;
	sub_821B7B18(ctx, base);
	// 827F3754: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827F3758: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F375C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827F3760: 419A0010  beq cr6, 0x827f3770
	if ctx.cr[6].eq {
	pc = 0x827F3770; continue 'dispatch;
	}
	// 827F3764: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3768: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F376C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F3770; continue 'dispatch;
            }
            0x827F3770 => {
    //   block [0x827F3770..0x827F3778)
	// 827F3770: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F3774: 4B9C43A5  bl 0x821b7b18
	ctx.lr = 0x827F3778;
	sub_821B7B18(ctx, base);
	pc = 0x827F3778; continue 'dispatch;
            }
            0x827F3778 => {
    //   block [0x827F3778..0x827F378C)
	// 827F3778: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F377C: 4B9C439D  bl 0x821b7b18
	ctx.lr = 0x827F3780;
	sub_821B7B18(ctx, base);
	// 827F3780: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F3784: 4B9D2FE5  bl 0x821c6768
	ctx.lr = 0x827F3788;
	sub_821C6768(ctx, base);
	// 827F3788: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x827F378C; continue 'dispatch;
            }
            0x827F378C => {
    //   block [0x827F378C..0x827F37B4)
	// 827F378C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F3790: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F3794: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F3798: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F379C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F37A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F37A4: 4082FFE8  bne 0x827f378c
	if !ctx.cr[0].eq {
	pc = 0x827F378C; continue 'dispatch;
	}
	// 827F37A8: 3B5A0001  addi r26, r26, 1
	ctx.r[26].s64 = ctx.r[26].s64 + 1;
	// 827F37AC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F37B0: 4BFFFE58  b 0x827f3608
	pc = 0x827F3608; continue 'dispatch;
            }
            0x827F37B4 => {
    //   block [0x827F37B4..0x827F37CC)
	// 827F37B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F37B8: 4B9C4361  bl 0x821b7b18
	ctx.lr = 0x827F37BC;
	sub_821B7B18(ctx, base);
	// 827F37BC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F37C0: 4B9C4359  bl 0x821b7b18
	ctx.lr = 0x827F37C4;
	sub_821B7B18(ctx, base);
	// 827F37C4: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827F37C8: 484B5C78  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F37D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F37D0 size=96
    let mut pc: u32 = 0x827F37D0;
    'dispatch: loop {
        match pc {
            0x827F37D0 => {
    //   block [0x827F37D0..0x827F3830)
	// 827F37D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F37D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F37D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F37DC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F37E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F37E4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 827F37E8: 4BA485C9  bl 0x8223bdb0
	ctx.lr = 0x827F37EC;
	sub_8223BDB0(ctx, base);
	// 827F37EC: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 827F37F0: 4BA485C1  bl 0x8223bdb0
	ctx.lr = 0x827F37F4;
	sub_8223BDB0(ctx, base);
	// 827F37F4: 387F00B0  addi r3, r31, 0xb0
	ctx.r[3].s64 = ctx.r[31].s64 + 176;
	// 827F37F8: 4BA485B9  bl 0x8223bdb0
	ctx.lr = 0x827F37FC;
	sub_8223BDB0(ctx, base);
	// 827F37FC: 387F00F0  addi r3, r31, 0xf0
	ctx.r[3].s64 = ctx.r[31].s64 + 240;
	// 827F3800: 4BA485B1  bl 0x8223bdb0
	ctx.lr = 0x827F3804;
	sub_8223BDB0(ctx, base);
	// 827F3804: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 827F3808: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F380C: 917F0130  stw r11, 0x130(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), ctx.r[11].u32 ) };
	// 827F3810: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F3814: 917F0134  stw r11, 0x134(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 827F3818: 995F0138  stb r10, 0x138(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), ctx.r[10].u8 ) };
	// 827F381C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F3820: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F3824: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F3828: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F382C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F3830(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F3830 size=1248
    let mut pc: u32 = 0x827F3830;
    'dispatch: loop {
        match pc {
            0x827F3830 => {
    //   block [0x827F3830..0x827F3D10)
	// 827F3830: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F3834: 484B5BD9  bl 0x82ca940c
	ctx.lr = 0x827F3838;
	sub_82CA93D0(ctx, base);
	// 827F3838: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 827F383C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 827F3840: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F3D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F3D10 size=316
    let mut pc: u32 = 0x827F3D10;
    'dispatch: loop {
        match pc {
            0x827F3D10 => {
    //   block [0x827F3D10..0x827F3D74)
	// 827F3D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F3D14: 484B56F1  bl 0x82ca9404
	ctx.lr = 0x827F3D18;
	sub_82CA93D0(ctx, base);
	// 827F3D18: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F3D1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F3D20: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 827F3D24: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F3D28: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827F3D2C: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	// 827F3D30: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F3D34: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 827F3D38: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F3D3C: C0010054  lfs f0, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F3D40: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 827F3D44: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F3D48: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827F3D4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F3D50: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F3D54: ED4C02F2  fmuls f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 827F3D58: ED20537A  fmadds f9, f0, f13, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 827F3D5C: C1AA9A80  lfs f13, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F3D60: ED80482C  fsqrts f12, f9
	ctx.f[12].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 827F3D64: FD006210  fabs f8, f12
	ctx.f[8].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 827F3D68: FF086800  fcmpu cr6, f8, f13
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[13].f64);
	// 827F3D6C: 41980008  blt cr6, 0x827f3d74
	if ctx.cr[6].lt {
	pc = 0x827F3D74; continue 'dispatch;
	}
	// 827F3D70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F3D74; continue 'dispatch;
            }
            0x827F3D74 => {
    //   block [0x827F3D74..0x827F3D94)
	// 827F3D74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F3D78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F3D7C: 419A0018  beq cr6, 0x827f3d94
	if ctx.cr[6].eq {
	pc = 0x827F3D94; continue 'dispatch;
	}
	// 827F3D80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F3D84: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 827F3D88: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F3D8C: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827F3D90: 48000044  b 0x827f3dd4
	pc = 0x827F3DD4; continue 'dispatch;
            }
            0x827F3D94 => {
    //   block [0x827F3D94..0x827F3DD4)
	// 827F3D94: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F3D98: C16100A8  lfs f11, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F3D9C: C14100AC  lfs f10, 0xac(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827F3DA0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F3DA4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 827F3DA8: C121005C  lfs f9, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 827F3DAC: C1010058  lfs f8, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 827F3DB0: ECEB0232  fmuls f7, f11, f8
	ctx.f[7].f64 = (((ctx.f[11].f64 * ctx.f[8].f64) as f32) as f64);
	// 827F3DB4: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F3DB8: D0070000  stfs f0, 0(r7)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827F3DBC: EC0A3A7A  fmadds f0, f10, f9, f7
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[9].f64 + ctx.f[7].f64) as f32) as f64);
	// 827F3DC0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 827F3DC4: 40990010  ble cr6, 0x827f3dd4
	if !ctx.cr[6].gt {
	pc = 0x827F3DD4; continue 'dispatch;
	}
	// 827F3DC8: EDAC0332  fmuls f13, f12, f12
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 827F3DCC: ED806824  fdivs f12, f0, f13
	ctx.f[12].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 827F3DD0: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x827F3DD4; continue 'dispatch;
            }
            0x827F3DD4 => {
    //   block [0x827F3DD4..0x827F3E0C)
	// 827F3DD4: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3DD8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3DDC: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3DE0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F3DE4: 419A0028  beq cr6, 0x827f3e0c
	if ctx.cr[6].eq {
	pc = 0x827F3E0C; continue 'dispatch;
	}
	// 827F3DE8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F3DEC: 4B9C3D2D  bl 0x821b7b18
	ctx.lr = 0x827F3DF0;
	sub_821B7B18(ctx, base);
	// 827F3DF0: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F3DF4: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F3DF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F3DFC: 419A0010  beq cr6, 0x827f3e0c
	if ctx.cr[6].eq {
	pc = 0x827F3E0C; continue 'dispatch;
	}
	// 827F3E00: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3E04: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F3E08: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F3E0C; continue 'dispatch;
            }
            0x827F3E0C => {
    //   block [0x827F3E0C..0x827F3E44)
	// 827F3E0C: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3E10: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3E14: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3E18: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F3E1C: 419A0028  beq cr6, 0x827f3e44
	if ctx.cr[6].eq {
	pc = 0x827F3E44; continue 'dispatch;
	}
	// 827F3E20: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F3E24: 4B9C3CF5  bl 0x821b7b18
	ctx.lr = 0x827F3E28;
	sub_821B7B18(ctx, base);
	// 827F3E28: 93FB0000  stw r31, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827F3E2C: 93DB0004  stw r30, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F3E30: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F3E34: 419A0010  beq cr6, 0x827f3e44
	if ctx.cr[6].eq {
	pc = 0x827F3E44; continue 'dispatch;
	}
	// 827F3E38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3E3C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F3E40: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F3E44; continue 'dispatch;
            }
            0x827F3E44 => {
    //   block [0x827F3E44..0x827F3E4C)
	// 827F3E44: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F3E48: 484B560C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F3E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F3E50 size=688
    let mut pc: u32 = 0x827F3E50;
    'dispatch: loop {
        match pc {
            0x827F3E50 => {
    //   block [0x827F3E50..0x827F3EB8)
	// 827F3E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F3E54: 484B55B1  bl 0x82ca9404
	ctx.lr = 0x827F3E58;
	sub_82CA93D0(ctx, base);
	// 827F3E58: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 827F3E5C: 484B9E75  bl 0x82cadcd0
	ctx.lr = 0x827F3E60;
	sub_82CADCA0(ctx, base);
	// 827F3E60: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F3E64: 81670024  lwz r11, 0x24(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F3E68: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F3E6C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827F3E70: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 827F3E74: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 827F3E78: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 827F3E7C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	// 827F3E80: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827F3E84: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F3E88: 419A00F8  beq cr6, 0x827f3f80
	if ctx.cr[6].eq {
	pc = 0x827F3F80; continue 'dispatch;
	}
	// 827F3E8C: 8167008C  lwz r11, 0x8c(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F3E90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F3E94: 419A0024  beq cr6, 0x827f3eb8
	if ctx.cr[6].eq {
	pc = 0x827F3EB8; continue 'dispatch;
	}
	// 827F3E98: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 827F3E9C: 81670048  lwz r11, 0x48(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F3EA0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F3EA4: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F3EA8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3EAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F3EB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F3EB4: 480000D0  b 0x827f3f84
	pc = 0x827F3F84; continue 'dispatch;
            }
            0x827F3EB8 => {
    //   block [0x827F3EB8..0x827F3ED8)
	// 827F3EB8: 81470048  lwz r10, 0x48(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F3EBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F3EC0: 80A7004C  lwz r5, 0x4c(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F3EC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F3EC8: 7D0A2850  subf r8, r10, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 827F3ECC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F3ED0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F3ED4: 40810054  ble 0x827f3f28
	if !ctx.cr[0].gt {
	pc = 0x827F3F28; continue 'dispatch;
	}
	pc = 0x827F3ED8; continue 'dispatch;
            }
            0x827F3ED8 => {
    //   block [0x827F3ED8..0x827F3EF8)
	// 827F3ED8: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F3EDC: 55071838  slwi r7, r8, 3
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 827F3EE0: 7D475214  add r10, r7, r10
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[10].u64;
	// 827F3EE4: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3EE8: 2F060013  cmpwi cr6, r6, 0x13
	ctx.cr[6].compare_i32(ctx.r[6].s32, 19, &mut ctx.xer);
	// 827F3EEC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 827F3EF0: 41980008  blt cr6, 0x827f3ef8
	if ctx.cr[6].lt {
	pc = 0x827F3EF8; continue 'dispatch;
	}
	// 827F3EF4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x827F3EF8; continue 'dispatch;
            }
            0x827F3EF8 => {
    //   block [0x827F3EF8..0x827F3F14)
	// 827F3EF8: 54C6063E  clrlwi r6, r6, 0x18
	ctx.r[6].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 827F3EFC: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 827F3F00: 419A0014  beq cr6, 0x827f3f14
	if ctx.cr[6].eq {
	pc = 0x827F3F14; continue 'dispatch;
	}
	// 827F3F04: 7D685850  subf r11, r8, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F3F08: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F3F0C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F3F10: 4800000C  b 0x827f3f1c
	pc = 0x827F3F1C; continue 'dispatch;
            }
            0x827F3F14 => {
    //   block [0x827F3F14..0x827F3F1C)
	// 827F3F14: 7D475050  subf r10, r7, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 827F3F18: 7D0B4378  mr r11, r8
	ctx.r[11].u64 = ctx.r[8].u64;
	pc = 0x827F3F1C; continue 'dispatch;
            }
            0x827F3F1C => {
    //   block [0x827F3F1C..0x827F3F28)
	// 827F3F1C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F3F20: 4199FFB8  bgt cr6, 0x827f3ed8
	if ctx.cr[6].gt {
	pc = 0x827F3ED8; continue 'dispatch;
	}
	// 827F3F24: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F3F28; continue 'dispatch;
            }
            0x827F3F28 => {
    //   block [0x827F3F28..0x827F3F44)
	// 827F3F28: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F3F2C: 419A0040  beq cr6, 0x827f3f6c
	if ctx.cr[6].eq {
	pc = 0x827F3F6C; continue 'dispatch;
	}
	// 827F3F30: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3F34: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 827F3F38: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F3F3C: 41990008  bgt cr6, 0x827f3f44
	if ctx.cr[6].gt {
	pc = 0x827F3F44; continue 'dispatch;
	}
	// 827F3F40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F3F44; continue 'dispatch;
            }
            0x827F3F44 => {
    //   block [0x827F3F44..0x827F3F6C)
	// 827F3F44: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F3F48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F3F4C: 409A0020  bne cr6, 0x827f3f6c
	if !ctx.cr[6].eq {
	pc = 0x827F3F6C; continue 'dispatch;
	}
	// 827F3F50: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F3F54: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 827F3F58: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827F3F5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3F60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F3F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F3F68: 4800001C  b 0x827f3f84
	pc = 0x827F3F84; continue 'dispatch;
            }
            0x827F3F6C => {
    //   block [0x827F3F6C..0x827F3F80)
	// 827F3F6C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 827F3F70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F3F74: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F3F78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F3F7C: 48000008  b 0x827f3f84
	pc = 0x827F3F84; continue 'dispatch;
            }
            0x827F3F80 => {
    //   block [0x827F3F80..0x827F3F84)
	// 827F3F80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F3F84; continue 'dispatch;
            }
            0x827F3F84 => {
    //   block [0x827F3F84..0x827F40BC)
	// 827F3F84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F3F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F3F8C: 419A0164  beq cr6, 0x827f40f0
	if ctx.cr[6].eq {
	pc = 0x827F40F0; continue 'dispatch;
	}
	// 827F3F90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F3F94: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 827F3F98: 4B987401  bl 0x8217b398
	ctx.lr = 0x827F3F9C;
	sub_8217B398(ctx, base);
	// 827F3F9C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3FA0: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F3FA4: 4BADF6A5  bl 0x822d3648
	ctx.lr = 0x827F3FA8;
	sub_822D3648(ctx, base);
	// 827F3FA8: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F3FAC: FCE00890  fmr f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[1].f64;
	// 827F3FB0: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F3FB4: 4BADF695  bl 0x822d3648
	ctx.lr = 0x827F3FB8;
	sub_822D3648(ctx, base);
	// 827F3FB8: E97D0008  ld r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 827F3FBC: C00100F4  lfs f0, 0xf4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F3FC0: E93E0008  ld r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 827F3FC4: C1A100F0  lfs f13, 0xf0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F3FC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F3FCC: ECC00032  fmuls f6, f0, f0
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 827F3FD0: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	// 827F3FD4: ECA70824  fdivs f5, f7, f1
	ctx.f[5].f64 = ((ctx.f[7].f64 / ctx.f[1].f64) as f32) as f64;
	// 827F3FD8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 827F3FDC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F3FE0: C0810050  lfs f4, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 827F3FE4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 827F3FE8: C0610058  lfs f3, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 827F3FEC: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 827F3FF0: C0410060  lfs f2, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 827F3FF4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 827F3FF8: C0210068  lfs f1, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F3FFC: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F4000: 38C79490  addi r6, r7, -0x6b70
	ctx.r[6].s64 = ctx.r[7].s64 + -27504;
	// 827F4004: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827F4008: 3CA08210  lis r5, -0x7df0
	ctx.r[5].s64 = -2112880640;
	// 827F400C: C1610064  lfs f11, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F4010: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 827F4014: C141006C  lfs f10, 0x6c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827F4018: ED2D337A  fmadds f9, f13, f13, f6
	ctx.f[9].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[6].f64) as f32) as f64);
	// 827F401C: 38850E68  addi r4, r5, 0xe68
	ctx.r[4].s64 = ctx.r[5].s64 + 3688;
	// 827F4020: C3C79490  lfs f30, -0x6b70(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 827F4024: C3E6FFF4  lfs f31, -0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F4028: EF40482C  fsqrts f26, f9
	ctx.f[26].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 827F402C: ED0400F2  fmuls f8, f4, f3
	ctx.f[8].f64 = (((ctx.f[4].f64 * ctx.f[3].f64) as f32) as f64);
	// 827F4030: ECE20072  fmuls f7, f2, f1
	ctx.f[7].f64 = (((ctx.f[2].f64 * ctx.f[1].f64) as f32) as f64);
	// 827F4034: ECC0433A  fmadds f6, f0, f12, f8
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 827F4038: EC8B3ABA  fmadds f4, f11, f10, f7
	ctx.f[4].f64 = (((ctx.f[11].f64 * ctx.f[10].f64 + ctx.f[7].f64) as f32) as f64);
	// 827F403C: EC60302C  fsqrts f3, f6
	ctx.f[3].f64 = ((ctx.f[6].f64).sqrt() as f32) as f64;
	// 827F4040: EFA30172  fmuls f29, f3, f5
	ctx.f[29].f64 = (((ctx.f[3].f64 * ctx.f[5].f64) as f32) as f64);
	// 827F4044: EF60202C  fsqrts f27, f4
	ctx.f[27].f64 = ((ctx.f[4].f64).sqrt() as f32) as f64;
	// 827F4048: EC5DD028  fsubs f2, f29, f26
	ctx.f[2].f64 = (((ctx.f[29].f64 - ctx.f[26].f64) as f32) as f64);
	// 827F404C: EC3DD828  fsubs f1, f29, f27
	ctx.f[1].f64 = (((ctx.f[29].f64 - ctx.f[27].f64) as f32) as f64);
	// 827F4050: EC020824  fdivs f0, f2, f1
	ctx.f[0].f64 = ((ctx.f[2].f64 / ctx.f[1].f64) as f32) as f64;
	// 827F4054: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 827F4058: 7D600026  mfcr r11
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[11].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[11].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 827F405C: 556ADF7A  rlwinm r10, r11, 0x1b, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 827F4060: 5569F77A  rlwinm r9, r11, 0x1e, 0x1d, 0x1d
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000003u64;
	// 827F4064: 7D484B78  or r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 827F4068: 7DA4442E  lfsx f13, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F406C: FD8DF82E  fsel f12, f13, f0, f31
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[31].f64 };
	// 827F4070: ED6CF028  fsubs f11, f12, f30
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[30].f64) as f32) as f64);
	// 827F4074: FF0BF800  fcmpu cr6, f11, f31
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[31].f64);
	// 827F4078: 7CE00026  mfcr r7
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[7].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[7].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 827F407C: 54E6DF7A  rlwinm r6, r7, 0x1b, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 827F4080: 54E5F77A  rlwinm r5, r7, 0x1e, 0x1d, 0x1d
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0x00000003u64;
	// 827F4084: 7CCB2B78  or r11, r6, r5
	ctx.r[11].u64 = ctx.r[6].u64 | ctx.r[5].u64;
	// 827F4088: 7D445C2E  lfsx f10, r4, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827F408C: FF8A67AE  fsel f28, f10, f30, f12
	ctx.f[28].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[12].f64 };
	// 827F4090: 4BA2B1C9  bl 0x8221f258
	ctx.lr = 0x827F4094;
	sub_8221F258(ctx, base);
	// 827F4094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F4098: 419A0024  beq cr6, 0x827f40bc
	if ctx.cr[6].eq {
	pc = 0x827F40BC; continue 'dispatch;
	}
	// 827F409C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F40A0: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F40A4: 80BE0000  lwz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F40A8: EC5EE028  fsubs f2, f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = (((ctx.f[30].f64 - ctx.f[28].f64) as f32) as f64);
	// 827F40AC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 827F40B0: 4BF6D9F1  bl 0x82761aa0
	ctx.lr = 0x827F40B4;
	sub_82761AA0(ctx, base);
	// 827F40B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F40B8: 48000008  b 0x827f40c0
	pc = 0x827F40C0; continue 'dispatch;
            }
            0x827F40BC => {
    //   block [0x827F40BC..0x827F40C0)
	// 827F40BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x827F40C0; continue 'dispatch;
            }
            0x827F40C0 => {
    //   block [0x827F40C0..0x827F40F0)
	// 827F40C0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F40C4: 4BA7EF95  bl 0x82273058
	ctx.lr = 0x827F40C8;
	sub_82273058(ctx, base);
	// 827F40C8: EC1EE028  fsubs f0, f30, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[28].f64) as f32) as f64);
	// 827F40CC: ED9C06F2  fmuls f12, f28, f27
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[27].f64) as f32) as f64);
	// 827F40D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F40D4: D3FC0000  stfs f31, 0(r28)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827F40D8: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F40DC: EC00677A  fmadds f0, f0, f29, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[12].f64) as f32) as f64);
	// 827F40E0: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 827F40E4: 4099000C  ble cr6, 0x827f40f0
	if !ctx.cr[6].gt {
	pc = 0x827F40F0; continue 'dispatch;
	}
	// 827F40E8: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 827F40EC: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x827F40F0; continue 'dispatch;
            }
            0x827F40F0 => {
    //   block [0x827F40F0..0x827F4100)
	// 827F40F0: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827F40F4: 3981FFD0  addi r12, r1, -0x30
	ctx.r[12].s64 = ctx.r[1].s64 + -48;
	// 827F40F8: 484B9C25  bl 0x82cadd1c
	ctx.lr = 0x827F40FC;
	sub_82CADCEC(ctx, base);
	// 827F40FC: 484B5358  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F4100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F4100 size=288
    let mut pc: u32 = 0x827F4100;
    'dispatch: loop {
        match pc {
            0x827F4100 => {
    //   block [0x827F4100..0x827F41C8)
	// 827F4100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F4104: 484B52F9  bl 0x82ca93fc
	ctx.lr = 0x827F4108;
	sub_82CA93D0(ctx, base);
	// 827F4108: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F410C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F4110: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F4114: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827F4118: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F411C: FBA100C0  std r29, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[29].u64 ) };
	// 827F4120: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F4124: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F4128: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 827F412C: E8BE0008  ld r5, 8(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 827F4130: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 827F4134: 7D1A4378  mr r26, r8
	ctx.r[26].u64 = ctx.r[8].u64;
	// 827F4138: C02A9A80  lfs f1, -0x6580(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F413C: 7D394B78  mr r25, r9
	ctx.r[25].u64 = ctx.r[9].u64;
	// 827F4140: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F4144: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827F4148: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 827F414C: C161005C  lfs f11, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F4150: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F4154: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F4158: ED2D0028  fsubs f9, f13, f0
	ctx.f[9].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 827F415C: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 827F4160: D1210050  stfs f9, 0x50(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 827F4164: D1410054  stfs f10, 0x54(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 827F4168: 4BAB4FD1  bl 0x822a9138
	ctx.lr = 0x827F416C;
	sub_822A9138(ctx, base);
	// 827F416C: E89F0008  ld r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F4170: C10100C0  lfs f8, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 827F4174: C0E100C4  lfs f7, 0xc4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 827F4178: C0C10050  lfs f6, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 827F417C: C0A10054  lfs f5, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 827F4180: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 827F4184: C081005C  lfs f4, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 827F4188: C0610058  lfs f3, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 827F418C: EC481828  fsubs f2, f8, f3
	ctx.f[2].f64 = (((ctx.f[8].f64 - ctx.f[3].f64) as f32) as f64);
	// 827F4190: EC072028  fsubs f0, f7, f4
	ctx.f[0].f64 = (((ctx.f[7].f64 - ctx.f[4].f64) as f32) as f64);
	// 827F4194: EDA201B2  fmuls f13, f2, f6
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[6].f64) as f32) as f64);
	// 827F4198: EC00697A  fmadds f0, f0, f5, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 827F419C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 827F41A0: 40990028  ble cr6, 0x827f41c8
	if !ctx.cr[6].gt {
	pc = 0x827F41C8; continue 'dispatch;
	}
	// 827F41A4: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 827F41A8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827F41AC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827F41B0: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F41B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F41B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F41BC: 4BFFFB55  bl 0x827f3d10
	ctx.lr = 0x827F41C0;
	sub_827F3D10(ctx, base);
	// 827F41C0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F41C4: 484B5288  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F41C8 => {
    //   block [0x827F41C8..0x827F41FC)
	// 827F41C8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F41CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F41D0: C1AB9484  lfs f13, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F41D4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 827F41D8: 40980024  bge cr6, 0x827f41fc
	if !ctx.cr[6].lt {
	pc = 0x827F41FC; continue 'dispatch;
	}
	// 827F41DC: 7F28CB78  mr r8, r25
	ctx.r[8].u64 = ctx.r[25].u64;
	// 827F41E0: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 827F41E4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827F41E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F41EC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F41F0: 4BFFFB21  bl 0x827f3d10
	ctx.lr = 0x827F41F4;
	sub_827F3D10(ctx, base);
	// 827F41F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F41F8: 484B5254  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F41FC => {
    //   block [0x827F41FC..0x827F4220)
	// 827F41FC: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	// 827F4200: 7F48D378  mr r8, r26
	ctx.r[8].u64 = ctx.r[26].u64;
	// 827F4204: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 827F4208: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F420C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F4210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F4214: 4BFFFC3D  bl 0x827f3e50
	ctx.lr = 0x827F4218;
	sub_827F3E50(ctx, base);
	// 827F4218: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F421C: 484B5230  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F4220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F4220 size=2796
    let mut pc: u32 = 0x827F4220;
    'dispatch: loop {
        match pc {
            0x827F4220 => {
    //   block [0x827F4220..0x827F4294)
	// 827F4220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F4224: 484B51B9  bl 0x82ca93dc
	ctx.lr = 0x827F4228;
	sub_82CA93D0(ctx, base);
	// 827F4228: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 827F422C: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 827F4230: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 827F4234: 488127A1  bl 0x830069d4
	ctx.lr = 0x827F4238;
	sub_83006760(ctx, base);
	// 827F4238: 9421FE40  stwu r1, -0x1c0(r1)
	ea = ctx.r[1].u32.wrapping_add(-448 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F423C: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 827F4240: 3AC00000  li r22, 0
	ctx.r[22].s64 = 0;
	// 827F4244: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F4248: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 827F424C: 7CD83378  mr r24, r6
	ctx.r[24].u64 = ctx.r[6].u64;
	// 827F4250: 81790024  lwz r11, 0x24(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F4254: 7CF73B78  mr r23, r7
	ctx.r[23].u64 = ctx.r[7].u64;
	// 827F4258: 7EDAB378  mr r26, r22
	ctx.r[26].u64 = ctx.r[22].u64;
	// 827F425C: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 827F4260: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F4264: 419A00F4  beq cr6, 0x827f4358
	if ctx.cr[6].eq {
	pc = 0x827F4358; continue 'dispatch;
	}
	// 827F4268: 8179008C  lwz r11, 0x8c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F426C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4270: 419A0024  beq cr6, 0x827f4294
	if ctx.cr[6].eq {
	pc = 0x827F4294; continue 'dispatch;
	}
	// 827F4274: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 827F4278: 81790048  lwz r11, 0x48(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F427C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F4280: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F4284: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4288: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 827F428C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4290: 480000CC  b 0x827f435c
	pc = 0x827F435C; continue 'dispatch;
            }
            0x827F4294 => {
    //   block [0x827F4294..0x827F42B0)
	// 827F4294: 81590048  lwz r10, 0x48(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F4298: 80D9004C  lwz r6, 0x4c(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F429C: 92C10080  stw r22, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[22].u32 ) };
	// 827F42A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F42A4: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 827F42A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F42AC: 40810054  ble 0x827f4300
	if !ctx.cr[0].gt {
	pc = 0x827F4300; continue 'dispatch;
	}
	pc = 0x827F42B0; continue 'dispatch;
            }
            0x827F42B0 => {
    //   block [0x827F42B0..0x827F42D0)
	// 827F42B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F42B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F42B8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 827F42BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F42C0: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 827F42C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F42C8: 41980008  blt cr6, 0x827f42d0
	if ctx.cr[6].lt {
	pc = 0x827F42D0; continue 'dispatch;
	}
	// 827F42CC: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	pc = 0x827F42D0; continue 'dispatch;
            }
            0x827F42D0 => {
    //   block [0x827F42D0..0x827F42EC)
	// 827F42D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F42D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F42D8: 419A0014  beq cr6, 0x827f42ec
	if ctx.cr[6].eq {
	pc = 0x827F42EC; continue 'dispatch;
	}
	// 827F42DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F42E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F42E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F42E8: 4800000C  b 0x827f42f4
	pc = 0x827F42F4; continue 'dispatch;
            }
            0x827F42EC => {
    //   block [0x827F42EC..0x827F42F4)
	// 827F42EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F42F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F42F4; continue 'dispatch;
            }
            0x827F42F4 => {
    //   block [0x827F42F4..0x827F4300)
	// 827F42F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F42F8: 4199FFB8  bgt cr6, 0x827f42b0
	if ctx.cr[6].gt {
	pc = 0x827F42B0; continue 'dispatch;
	}
	// 827F42FC: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	pc = 0x827F4300; continue 'dispatch;
            }
            0x827F4300 => {
    //   block [0x827F4300..0x827F431C)
	// 827F4300: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F4304: 419A0040  beq cr6, 0x827f4344
	if ctx.cr[6].eq {
	pc = 0x827F4344; continue 'dispatch;
	}
	// 827F4308: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F430C: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 827F4310: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4314: 41990008  bgt cr6, 0x827f431c
	if ctx.cr[6].gt {
	pc = 0x827F431C; continue 'dispatch;
	}
	// 827F4318: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x827F431C; continue 'dispatch;
            }
            0x827F431C => {
    //   block [0x827F431C..0x827F4344)
	// 827F431C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F4320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4324: 409A0020  bne cr6, 0x827f4344
	if !ctx.cr[6].eq {
	pc = 0x827F4344; continue 'dispatch;
	}
	// 827F4328: E9610080  ld r11, 0x80(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 827F432C: F96100A0  std r11, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[11].u64 ) };
	// 827F4330: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 827F4334: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4338: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 827F433C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4340: 4800001C  b 0x827f435c
	pc = 0x827F435C; continue 'dispatch;
            }
            0x827F4344 => {
    //   block [0x827F4344..0x827F4358)
	// 827F4344: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F4348: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F434C: 7D7A5B78  mr r26, r11
	ctx.r[26].u64 = ctx.r[11].u64;
	// 827F4350: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4354: 48000008  b 0x827f435c
	pc = 0x827F435C; continue 'dispatch;
            }
            0x827F4358 => {
    //   block [0x827F4358..0x827F435C)
	// 827F4358: 7ECBB378  mr r11, r22
	ctx.r[11].u64 = ctx.r[22].u64;
	pc = 0x827F435C; continue 'dispatch;
            }
            0x827F435C => {
    //   block [0x827F435C..0x827F437C)
	// 827F435C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F4360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4364: 419A0990  beq cr6, 0x827f4cf4
	if ctx.cr[6].eq {
	pc = 0x827F4CF4; continue 'dispatch;
	}
	// 827F4368: 80BB0008  lwz r5, 8(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F436C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4370: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F4374: 40990008  ble cr6, 0x827f437c
	if !ctx.cr[6].gt {
	pc = 0x827F437C; continue 'dispatch;
	}
	// 827F4378: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F437C; continue 'dispatch;
            }
            0x827F437C => {
    //   block [0x827F437C..0x827F439C)
	// 827F437C: 93610060  stw r27, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[27].u32 ) };
	// 827F4380: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F4384: 90A10064  stw r5, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[5].u32 ) };
	// 827F4388: 92C10070  stw r22, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[22].u32 ) };
	// 827F438C: 92C10074  stw r22, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[22].u32 ) };
	// 827F4390: 4099000C  ble cr6, 0x827f439c
	if !ctx.cr[6].gt {
	pc = 0x827F439C; continue 'dispatch;
	}
	// 827F4394: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 827F4398: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F439C; continue 'dispatch;
            }
            0x827F439C => {
    //   block [0x827F439C..0x827F43B4)
	// 827F439C: 93610080  stw r27, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[27].u32 ) };
	// 827F43A0: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F43A4: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 827F43A8: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 827F43AC: F9410080  std r10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 827F43B0: 419A001C  beq cr6, 0x827f43cc
	if ctx.cr[6].eq {
	pc = 0x827F43CC; continue 'dispatch;
	}
	pc = 0x827F43B4; continue 'dispatch;
            }
            0x827F43B4 => {
    //   block [0x827F43B4..0x827F43CC)
	// 827F43B4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F43B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F43BC: 419A0010  beq cr6, 0x827f43cc
	if ctx.cr[6].eq {
	pc = 0x827F43CC; continue 'dispatch;
	}
	// 827F43C0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 827F43C4: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F43C8: 409AFFEC  bne cr6, 0x827f43b4
	if !ctx.cr[6].eq {
	pc = 0x827F43B4; continue 'dispatch;
	}
	pc = 0x827F43CC; continue 'dispatch;
            }
            0x827F43CC => {
    //   block [0x827F43CC..0x827F43E4)
	// 827F43CC: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 827F43D0: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 827F43D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F43D8: 419A000C  beq cr6, 0x827f43e4
	if ctx.cr[6].eq {
	pc = 0x827F43E4; continue 'dispatch;
	}
	// 827F43DC: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827F43E0: 419A0008  beq cr6, 0x827f43e8
	if ctx.cr[6].eq {
	pc = 0x827F43E8; continue 'dispatch;
	}
	pc = 0x827F43E4; continue 'dispatch;
            }
            0x827F43E4 => {
    //   block [0x827F43E4..0x827F43E8)
	// 827F43E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F43E8; continue 'dispatch;
            }
            0x827F43E8 => {
    //   block [0x827F43E8..0x827F43FC)
	// 827F43E8: 7F0B2840  cmplw cr6, r11, r5
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827F43EC: 409A0010  bne cr6, 0x827f43fc
	if !ctx.cr[6].eq {
	pc = 0x827F43FC; continue 'dispatch;
	}
	// 827F43F0: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 827F43F4: F9410080  std r10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 827F43F8: 4800003C  b 0x827f4434
	pc = 0x827F4434; continue 'dispatch;
            }
            0x827F43FC => {
    //   block [0x827F43FC..0x827F4408)
	// 827F43FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F4400: 409A0008  bne cr6, 0x827f4408
	if !ctx.cr[6].eq {
	pc = 0x827F4408; continue 'dispatch;
	}
	// 827F4404: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4408; continue 'dispatch;
            }
            0x827F4408 => {
    //   block [0x827F4408..0x827F4418)
	// 827F4408: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F440C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F4410: 41980008  blt cr6, 0x827f4418
	if ctx.cr[6].lt {
	pc = 0x827F4418; continue 'dispatch;
	}
	// 827F4414: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4418; continue 'dispatch;
            }
            0x827F4418 => {
    //   block [0x827F4418..0x827F4434)
	// 827F4418: E9410080  ld r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 827F441C: 388B0008  addi r4, r11, 8
	ctx.r[4].s64 = ctx.r[11].s64 + 8;
	// 827F4420: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 827F4424: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 827F4428: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827F442C: F94100A0  std r10, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[10].u64 ) };
	// 827F4430: 480060D1  bl 0x827fa500
	ctx.lr = 0x827F4434;
	sub_827FA500(ctx, base);
	pc = 0x827F4434; continue 'dispatch;
            }
            0x827F4434 => {
    //   block [0x827F4434..0x827F4488)
	// 827F4434: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 827F4438: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827F443C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F4440: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827F4444: E8AB0000  ld r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827F4448: 48004441  bl 0x827f8888
	ctx.lr = 0x827F444C;
	sub_827F8888(ctx, base);
	// 827F444C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F4450: 4B9C36C9  bl 0x821b7b18
	ctx.lr = 0x827F4454;
	sub_821B7B18(ctx, base);
	// 827F4454: 80DB0004  lwz r6, 4(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4458: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 827F445C: 419A0898  beq cr6, 0x827f4cf4
	if ctx.cr[6].eq {
	pc = 0x827F4CF4; continue 'dispatch;
	}
	// 827F4460: 809B0008  lwz r4, 8(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4464: 7D662050  subf r11, r6, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 827F4468: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 827F446C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F4470: 419A0884  beq cr6, 0x827f4cf4
	if ctx.cr[6].eq {
	pc = 0x827F4CF4; continue 'dispatch;
	}
	// 827F4474: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827F4478: 409A0030  bne cr6, 0x827f44a8
	if !ctx.cr[6].eq {
	pc = 0x827F44A8; continue 'dispatch;
	}
	// 827F447C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F4480: 409A0008  bne cr6, 0x827f4488
	if !ctx.cr[6].eq {
	pc = 0x827F4488; continue 'dispatch;
	}
	// 827F4484: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4488; continue 'dispatch;
            }
            0x827F4488 => {
    //   block [0x827F4488..0x827F44A8)
	// 827F4488: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F448C: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	// 827F4490: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 827F4494: E89B0018  ld r4, 0x18(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	// 827F4498: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 827F449C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 827F44A0: 4BFFF871  bl 0x827f3d10
	ctx.lr = 0x827F44A4;
	sub_827F3D10(ctx, base);
	// 827F44A4: 48000850  b 0x827f4cf4
	pc = 0x827F4CF4; continue 'dispatch;
            }
            0x827F44A8 => {
    //   block [0x827F44A8..0x827F44BC)
	// 827F44A8: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 827F44AC: 409A0028  bne cr6, 0x827f44d4
	if !ctx.cr[6].eq {
	pc = 0x827F44D4; continue 'dispatch;
	}
	// 827F44B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F44B4: 409A0008  bne cr6, 0x827f44bc
	if !ctx.cr[6].eq {
	pc = 0x827F44BC; continue 'dispatch;
	}
	// 827F44B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F44BC; continue 'dispatch;
            }
            0x827F44BC => {
    //   block [0x827F44BC..0x827F44CC)
	// 827F44BC: 80660000  lwz r3, 0(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F44C0: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827F44C4: 41990008  bgt cr6, 0x827f44cc
	if ctx.cr[6].gt {
	pc = 0x827F44CC; continue 'dispatch;
	}
	// 827F44C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F44CC; continue 'dispatch;
            }
            0x827F44CC => {
    //   block [0x827F44CC..0x827F44D4)
	// 827F44CC: 80860008  lwz r4, 8(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F44D0: 4800080C  b 0x827f4cdc
	pc = 0x827F4CDC; continue 'dispatch;
            }
            0x827F44D4 => {
    //   block [0x827F44D4..0x827F44F4)
	// 827F44D4: 2B0A0003  cmplwi cr6, r10, 3
	ctx.cr[6].compare_u32(ctx.r[10].u32, 3 as u32, &mut ctx.xer);
	// 827F44D8: 419A00FC  beq cr6, 0x827f45d4
	if ctx.cr[6].eq {
	pc = 0x827F45D4; continue 'dispatch;
	}
	// 827F44DC: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 827F44E0: 409A0814  bne cr6, 0x827f4cf4
	if !ctx.cr[6].eq {
	pc = 0x827F4CF4; continue 'dispatch;
	}
	// 827F44E4: 7EC8B378  mr r8, r22
	ctx.r[8].u64 = ctx.r[22].u64;
	// 827F44E8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F44EC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F44F0: 39600008  li r11, 8
	ctx.r[11].s64 = 8;
	pc = 0x827F44F4; continue 'dispatch;
            }
            0x827F44F4 => {
    //   block [0x827F44F4..0x827F4500)
	// 827F44F4: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F44F8: 41980008  blt cr6, 0x827f4500
	if ctx.cr[6].lt {
	pc = 0x827F4500; continue 'dispatch;
	}
	// 827F44FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4500; continue 'dispatch;
            }
            0x827F4500 => {
    //   block [0x827F4500..0x827F4510)
	// 827F4500: 7D2B302E  lwzx r9, r11, r6
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 827F4504: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F4508: 41980008  blt cr6, 0x827f4510
	if ctx.cr[6].lt {
	pc = 0x827F4510; continue 'dispatch;
	}
	// 827F450C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4510; continue 'dispatch;
            }
            0x827F4510 => {
    //   block [0x827F4510..0x827F452C)
	// 827F4510: 7C65302E  lwzx r3, r5, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 827F4514: C0090010  lfs f0, 0x10(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F4518: C1A30010  lfs f13, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F451C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 827F4520: 4098000C  bge cr6, 0x827f452c
	if !ctx.cr[6].lt {
	pc = 0x827F452C; continue 'dispatch;
	}
	// 827F4524: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 827F4528: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	pc = 0x827F452C; continue 'dispatch;
            }
            0x827F452C => {
    //   block [0x827F452C..0x827F454C)
	// 827F452C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 827F4530: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 827F4534: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 827F4538: 409AFFBC  bne cr6, 0x827f44f4
	if !ctx.cr[6].eq {
	pc = 0x827F44F4; continue 'dispatch;
	}
	// 827F453C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F4540: 409A000C  bne cr6, 0x827f454c
	if !ctx.cr[6].eq {
	pc = 0x827F454C; continue 'dispatch;
	}
	// 827F4544: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 827F4548: 48000024  b 0x827f456c
	pc = 0x827F456C; continue 'dispatch;
            }
            0x827F454C => {
    //   block [0x827F454C..0x827F455C)
	// 827F454C: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 827F4550: 409A000C  bne cr6, 0x827f455c
	if !ctx.cr[6].eq {
	pc = 0x827F455C; continue 'dispatch;
	}
	// 827F4554: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 827F4558: 48000014  b 0x827f456c
	pc = 0x827F456C; continue 'dispatch;
            }
            0x827F455C => {
    //   block [0x827F455C..0x827F456C)
	// 827F455C: 3968FFFD  addi r11, r8, -3
	ctx.r[11].s64 = ctx.r[8].s64 + -3;
	// 827F4560: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827F4564: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 827F4568: 692B0001  xori r11, r9, 1
	ctx.r[11].u64 = ctx.r[9].u64 ^ 1;
	pc = 0x827F456C; continue 'dispatch;
            }
            0x827F456C => {
    //   block [0x827F456C..0x827F4578)
	// 827F456C: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827F4570: 40990008  ble cr6, 0x827f4578
	if !ctx.cr[6].gt {
	pc = 0x827F4578; continue 'dispatch;
	}
	// 827F4574: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4578; continue 'dispatch;
            }
            0x827F4578 => {
    //   block [0x827F4578..0x827F4598)
	// 827F4578: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F457C: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4580: 7CAB3214  add r5, r11, r6
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[6].u64;
	// 827F4584: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F4588: 41990010  bgt cr6, 0x827f4598
	if ctx.cr[6].gt {
	pc = 0x827F4598; continue 'dispatch;
	}
	// 827F458C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4590: 7F055840  cmplw cr6, r5, r11
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F4594: 40980008  bge cr6, 0x827f459c
	if !ctx.cr[6].lt {
	pc = 0x827F459C; continue 'dispatch;
	}
	pc = 0x827F4598; continue 'dispatch;
            }
            0x827F4598 => {
    //   block [0x827F4598..0x827F459C)
	// 827F4598: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F459C; continue 'dispatch;
            }
            0x827F459C => {
    //   block [0x827F459C..0x827F45B4)
	// 827F459C: 38650008  addi r3, r5, 8
	ctx.r[3].s64 = ctx.r[5].s64 + 8;
	// 827F45A0: 483764D9  bl 0x82b6aa78
	ctx.lr = 0x827F45A4;
	sub_82B6AA78(ctx, base);
	// 827F45A4: 83DB0008  lwz r30, 8(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F45A8: 3BFEFFF8  addi r31, r30, -8
	ctx.r[31].s64 = ctx.r[30].s64 + -8;
	// 827F45AC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F45B0: 419A0018  beq cr6, 0x827f45c8
	if ctx.cr[6].eq {
	pc = 0x827F45C8; continue 'dispatch;
	}
	pc = 0x827F45B4; continue 'dispatch;
            }
            0x827F45B4 => {
    //   block [0x827F45B4..0x827F45C8)
	// 827F45B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F45B8: 4B9C3561  bl 0x821b7b18
	ctx.lr = 0x827F45BC;
	sub_821B7B18(ctx, base);
	// 827F45BC: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 827F45C0: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F45C4: 409AFFF0  bne cr6, 0x827f45b4
	if !ctx.cr[6].eq {
	pc = 0x827F45B4; continue 'dispatch;
	}
	pc = 0x827F45C8; continue 'dispatch;
            }
            0x827F45C8 => {
    //   block [0x827F45C8..0x827F45D4)
	// 827F45C8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F45CC: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 827F45D0: 917B0008  stw r11, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x827F45D4; continue 'dispatch;
            }
            0x827F45D4 => {
    //   block [0x827F45D4..0x827F45F0)
	// 827F45D4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F45D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F45DC: 419A0014  beq cr6, 0x827f45f0
	if ctx.cr[6].eq {
	pc = 0x827F45F0; continue 'dispatch;
	}
	// 827F45E0: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F45E4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F45E8: 7D2A1E71  srawi. r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F45EC: 40820008  bne 0x827f45f4
	if !ctx.cr[0].eq {
	pc = 0x827F45F4; continue 'dispatch;
	}
	pc = 0x827F45F0; continue 'dispatch;
            }
            0x827F45F0 => {
    //   block [0x827F45F0..0x827F45F4)
	// 827F45F0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F45F4; continue 'dispatch;
            }
            0x827F45F4 => {
    //   block [0x827F45F4..0x827F4614)
	// 827F45F4: 838B0000  lwz r28, 0(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F45F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F45FC: 419A0018  beq cr6, 0x827f4614
	if ctx.cr[6].eq {
	pc = 0x827F4614; continue 'dispatch;
	}
	// 827F4600: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4604: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F4608: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F460C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 827F4610: 41990008  bgt cr6, 0x827f4618
	if ctx.cr[6].gt {
	pc = 0x827F4618; continue 'dispatch;
	}
	pc = 0x827F4614; continue 'dispatch;
            }
            0x827F4614 => {
    //   block [0x827F4614..0x827F4618)
	// 827F4614: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4618; continue 'dispatch;
            }
            0x827F4618 => {
    //   block [0x827F4618..0x827F4638)
	// 827F4618: 83AB0008  lwz r29, 8(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F461C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4620: 419A0018  beq cr6, 0x827f4638
	if ctx.cr[6].eq {
	pc = 0x827F4638; continue 'dispatch;
	}
	// 827F4624: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4628: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F462C: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F4630: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 827F4634: 41990008  bgt cr6, 0x827f463c
	if ctx.cr[6].gt {
	pc = 0x827F463C; continue 'dispatch;
	}
	pc = 0x827F4638; continue 'dispatch;
            }
            0x827F4638 => {
    //   block [0x827F4638..0x827F463C)
	// 827F4638: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F463C; continue 'dispatch;
            }
            0x827F463C => {
    //   block [0x827F463C..0x827F4CDC)
	// 827F463C: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4640: 83EB0010  lwz r31, 0x10(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F4644: C0230028  lfs f1, 0x28(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F4648: 4BADF001  bl 0x822d3648
	ctx.lr = 0x827F464C;
	sub_822D3648(ctx, base);
	// 827F464C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4650: FCE00890  fmr f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[1].f64;
	// 827F4654: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F4658: 4BADEFF1  bl 0x822d3648
	ctx.lr = 0x827F465C;
	sub_822D3648(ctx, base);
	// 827F465C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4660: ECC70824  fdivs f6, f7, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[6].f64 = ((ctx.f[7].f64 / ctx.f[1].f64) as f32) as f64;
	// 827F4664: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F4668: 4BADEFE1  bl 0x822d3648
	ctx.lr = 0x827F466C;
	sub_822D3648(ctx, base);
	// 827F466C: 807C0000  lwz r3, 0(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4670: FCA00890  fmr f5, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[5].f64 = ctx.f[1].f64;
	// 827F4674: C0230028  lfs f1, 0x28(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F4678: 4BADEFD1  bl 0x822d3648
	ctx.lr = 0x827F467C;
	sub_822D3648(ctx, base);
	// 827F467C: E8FF0008  ld r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F4680: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F4684: E95C0008  ld r10, 8(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	// 827F4688: EC850824  fdivs f4, f5, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[4].f64 = ((ctx.f[5].f64 / ctx.f[1].f64) as f32) as f64;
	// 827F468C: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 827F4690: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F4694: F9410080  std r10, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 827F4698: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 827F469C: E93D0008  ld r9, 8(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 827F46A0: 3A810070  addi r20, r1, 0x70
	ctx.r[20].s64 = ctx.r[1].s64 + 112;
	// 827F46A4: C00B9484  lfs f0, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F46A8: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 827F46AC: 3A610060  addi r19, r1, 0x60
	ctx.r[19].s64 = ctx.r[1].s64 + 96;
	// 827F46B0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 827F46B4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827F46B8: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x827F4CDC; continue 'dispatch;
            }
            0x827F4CDC => {
    //   block [0x827F4CDC..0x827F4CF4)
	// 827F4CDC: 7EE9BB78  mr r9, r23
	ctx.r[9].u64 = ctx.r[23].u64;
	// 827F4CE0: E8BB0018  ld r5, 0x18(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) };
	// 827F4CE4: 7F08C378  mr r8, r24
	ctx.r[8].u64 = ctx.r[24].u64;
	// 827F4CE8: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 827F4CEC: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 827F4CF0: 4BFFF411  bl 0x827f4100
	ctx.lr = 0x827F4CF4;
	sub_827F4100(ctx, base);
	pc = 0x827F4CF4; continue 'dispatch;
            }
            0x827F4CF4 => {
    //   block [0x827F4CF4..0x827F4D0C)
	// 827F4CF4: 382101C0  addi r1, r1, 0x1c0
	ctx.r[1].s64 = ctx.r[1].s64 + 448;
	// 827F4CF8: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 827F4CFC: 48811F71  bl 0x83006c6c
	ctx.lr = 0x827F4D00;
	sub_830069F8(ctx, base);
	// 827F4D00: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 827F4D04: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 827F4D08: 484B4724  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F4D10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F4D10 size=1108
    let mut pc: u32 = 0x827F4D10;
    'dispatch: loop {
        match pc {
            0x827F4D10 => {
    //   block [0x827F4D10..0x827F4D74)
	// 827F4D10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F4D14: 484B46E9  bl 0x82ca93fc
	ctx.lr = 0x827F4D18;
	sub_82CA93D0(ctx, base);
	// 827F4D18: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 827F4D1C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F4D20: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827F4D24: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F4D28: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 827F4D2C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827F4D30: 815A001C  lwz r10, 0x1c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F4D34: C3EB9484  lfs f31, -0x6b7c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F4D38: 9B3A0029  stb r25, 0x29(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(41 as u32), ctx.r[25].u8 ) };
	// 827F4D3C: D3FA002C  stfs f31, 0x2c(r26)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 827F4D40: 892A0030  lbz r9, 0x30(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F4D44: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F4D48: 419A00A4  beq cr6, 0x827f4dec
	if ctx.cr[6].eq {
	pc = 0x827F4DEC; continue 'dispatch;
	}
	// 827F4D4C: 387A0004  addi r3, r26, 4
	ctx.r[3].s64 = ctx.r[26].s64 + 4;
	// 827F4D50: 4BD8A889  bl 0x8257f5d8
	ctx.lr = 0x827F4D54;
	sub_8257F5D8(ctx, base);
	// 827F4D54: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F4D58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4D5C: 419A0090  beq cr6, 0x827f4dec
	if ctx.cr[6].eq {
	pc = 0x827F4DEC; continue 'dispatch;
	}
	// 827F4D60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4D64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F4D68: 409A000C  bne cr6, 0x827f4d74
	if !ctx.cr[6].eq {
	pc = 0x827F4D74; continue 'dispatch;
	}
	// 827F4D6C: 7F3DCB78  mr r29, r25
	ctx.r[29].u64 = ctx.r[25].u64;
	// 827F4D70: 48000010  b 0x827f4d80
	pc = 0x827F4D80; continue 'dispatch;
            }
            0x827F4D74 => {
    //   block [0x827F4D74..0x827F4D80)
	// 827F4D74: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4D78: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F4D7C: 7D5D1670  srawi r29, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> 2) as i64;
	pc = 0x827F4D80; continue 'dispatch;
            }
            0x827F4D80 => {
    //   block [0x827F4D80..0x827F4D90)
	// 827F4D80: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 827F4D84: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F4D88: 419A0064  beq cr6, 0x827f4dec
	if ctx.cr[6].eq {
	pc = 0x827F4DEC; continue 'dispatch;
	}
	// 827F4D8C: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	pc = 0x827F4D90; continue 'dispatch;
            }
            0x827F4D90 => {
    //   block [0x827F4D90..0x827F4DB4)
	// 827F4D90: 815A001C  lwz r10, 0x1c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F4D94: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4D9C: 419A0018  beq cr6, 0x827f4db4
	if ctx.cr[6].eq {
	pc = 0x827F4DB4; continue 'dispatch;
	}
	// 827F4DA0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4DA4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F4DA8: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 827F4DAC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F4DB0: 41980008  blt cr6, 0x827f4db8
	if ctx.cr[6].lt {
	pc = 0x827F4DB8; continue 'dispatch;
	}
	pc = 0x827F4DB4; continue 'dispatch;
            }
            0x827F4DB4 => {
    //   block [0x827F4DB4..0x827F4DB8)
	// 827F4DB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4DB8; continue 'dispatch;
            }
            0x827F4DB8 => {
    //   block [0x827F4DB8..0x827F4DEC)
	// 827F4DB8: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 827F4DBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F4DC0: 4B9FB481  bl 0x821f0240
	ctx.lr = 0x827F4DC4;
	sub_821F0240(ctx, base);
	// 827F4DC4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827F4DC8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F4DCC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F4DD0: 480020E1  bl 0x827f6eb0
	ctx.lr = 0x827F4DD4;
	sub_827F6EB0(ctx, base);
	// 827F4DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F4DD8: 4BA20001  bl 0x82214dd8
	ctx.lr = 0x827F4DDC;
	sub_82214DD8(ctx, base);
	// 827F4DDC: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F4DE0: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827F4DE4: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F4DE8: 409AFFA8  bne cr6, 0x827f4d90
	if !ctx.cr[6].eq {
	pc = 0x827F4D90; continue 'dispatch;
	}
	pc = 0x827F4DEC; continue 'dispatch;
            }
            0x827F4DEC => {
    //   block [0x827F4DEC..0x827F4E58)
	// 827F4DEC: 817A001C  lwz r11, 0x1c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F4DF0: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F4DF4: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 827F4DF8: 409A0360  bne cr6, 0x827f5158
	if !ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F4DFC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4E04: 419A0354  beq cr6, 0x827f5158
	if ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F4E08: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F4E0C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F4E10: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F4E14: 41820344  beq 0x827f5158
	if ctx.cr[0].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F4E18: 817C0024  lwz r11, 0x24(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F4E1C: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 827F4E20: 5569D7FE  rlwinm r9, r11, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000003Fu64;
	// 827F4E24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F4E28: 419A00F4  beq cr6, 0x827f4f1c
	if ctx.cr[6].eq {
	pc = 0x827F4F1C; continue 'dispatch;
	}
	// 827F4E2C: 817C008C  lwz r11, 0x8c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F4E30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4E34: 419A0024  beq cr6, 0x827f4e58
	if ctx.cr[6].eq {
	pc = 0x827F4E58; continue 'dispatch;
	}
	// 827F4E38: 894B0006  lbz r10, 6(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 827F4E3C: 817C0048  lwz r11, 0x48(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F4E40: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F4E44: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F4E48: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4E4C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F4E50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4E54: 480000CC  b 0x827f4f20
	pc = 0x827F4F20; continue 'dispatch;
            }
            0x827F4E58 => {
    //   block [0x827F4E58..0x827F4E74)
	// 827F4E58: 815C0048  lwz r10, 0x48(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F4E5C: 80DC004C  lwz r6, 0x4c(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F4E60: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 827F4E64: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F4E68: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F4E6C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F4E70: 40810054  ble 0x827f4ec4
	if !ctx.cr[0].gt {
	pc = 0x827F4EC4; continue 'dispatch;
	}
	pc = 0x827F4E74; continue 'dispatch;
            }
            0x827F4E74 => {
    //   block [0x827F4E74..0x827F4E94)
	// 827F4E74: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F4E78: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F4E7C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F4E80: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4E84: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 827F4E88: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F4E8C: 41980008  blt cr6, 0x827f4e94
	if ctx.cr[6].lt {
	pc = 0x827F4E94; continue 'dispatch;
	}
	// 827F4E90: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x827F4E94; continue 'dispatch;
            }
            0x827F4E94 => {
    //   block [0x827F4E94..0x827F4EB0)
	// 827F4E94: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F4E98: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F4E9C: 419A0014  beq cr6, 0x827f4eb0
	if ctx.cr[6].eq {
	pc = 0x827F4EB0; continue 'dispatch;
	}
	// 827F4EA0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F4EA4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F4EA8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F4EAC: 4800000C  b 0x827f4eb8
	pc = 0x827F4EB8; continue 'dispatch;
            }
            0x827F4EB0 => {
    //   block [0x827F4EB0..0x827F4EB8)
	// 827F4EB0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F4EB4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F4EB8; continue 'dispatch;
            }
            0x827F4EB8 => {
    //   block [0x827F4EB8..0x827F4EC4)
	// 827F4EB8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F4EBC: 4199FFB8  bgt cr6, 0x827f4e74
	if ctx.cr[6].gt {
	pc = 0x827F4E74; continue 'dispatch;
	}
	// 827F4EC0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x827F4EC4; continue 'dispatch;
            }
            0x827F4EC4 => {
    //   block [0x827F4EC4..0x827F4EE0)
	// 827F4EC4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F4EC8: 419A0040  beq cr6, 0x827f4f08
	if ctx.cr[6].eq {
	pc = 0x827F4F08; continue 'dispatch;
	}
	// 827F4ECC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4ED0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 827F4ED4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4ED8: 41990008  bgt cr6, 0x827f4ee0
	if ctx.cr[6].gt {
	pc = 0x827F4EE0; continue 'dispatch;
	}
	// 827F4EDC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x827F4EE0; continue 'dispatch;
            }
            0x827F4EE0 => {
    //   block [0x827F4EE0..0x827F4F08)
	// 827F4EE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F4EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4EE8: 409A0020  bne cr6, 0x827f4f08
	if !ctx.cr[6].eq {
	pc = 0x827F4F08; continue 'dispatch;
	}
	// 827F4EEC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F4EF0: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 827F4EF4: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 827F4EF8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4EFC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F4F00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4F04: 4800001C  b 0x827f4f20
	pc = 0x827F4F20; continue 'dispatch;
            }
            0x827F4F08 => {
    //   block [0x827F4F08..0x827F4F1C)
	// 827F4F08: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F4F0C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F4F10: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F4F14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F4F18: 48000008  b 0x827f4f20
	pc = 0x827F4F20; continue 'dispatch;
            }
            0x827F4F1C => {
    //   block [0x827F4F1C..0x827F4F20)
	// 827F4F1C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x827F4F20; continue 'dispatch;
            }
            0x827F4F20 => {
    //   block [0x827F4F20..0x827F4F4C)
	// 827F4F20: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F4F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4F28: 419A0230  beq cr6, 0x827f5158
	if ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F4F2C: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F4F30: 83EA0094  lwz r31, 0x94(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 827F4F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4F38: 419A0014  beq cr6, 0x827f4f4c
	if ctx.cr[6].eq {
	pc = 0x827F4F4C; continue 'dispatch;
	}
	// 827F4F3C: 815A000C  lwz r10, 0xc(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F4F40: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F4F44: 7D2A1E71  srawi. r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F4F48: 40820008  bne 0x827f4f50
	if !ctx.cr[0].eq {
	pc = 0x827F4F50; continue 'dispatch;
	}
	pc = 0x827F4F4C; continue 'dispatch;
            }
            0x827F4F4C => {
    //   block [0x827F4F4C..0x827F4F50)
	// 827F4F4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F4F50; continue 'dispatch;
            }
            0x827F4F50 => {
    //   block [0x827F4F50..0x827F50BC)
	// 827F4F50: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4F54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F4F58: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F4F5C: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 827F4F60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F4F64: 4E800421  bctrl
	ctx.lr = 0x827F4F68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F4F68: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827F4F6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4F70: 419A01E8  beq cr6, 0x827f5158
	if ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F4F74: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827F4F78: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F4F7C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 827F4F80: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F4F84: 4BA0B35D  bl 0x822002e0
	ctx.lr = 0x827F4F88;
	sub_822002E0(ctx, base);
	// 827F4F88: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F4F8C: 83610050  lwz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F4F90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F4F94: 419A017C  beq cr6, 0x827f5110
	if ctx.cr[6].eq {
	pc = 0x827F5110; continue 'dispatch;
	}
	// 827F4F98: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 827F4F9C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F4FA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F4FA4: 4BA00C75  bl 0x821f5c18
	ctx.lr = 0x827F4FA8;
	sub_821F5C18(ctx, base);
	// 827F4FA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F4FAC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827F4FB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827F4FB4: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 827F4FB8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F4FBC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F4FC0: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F4FC4: 809E0010  lwz r4, 0x10(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F4FC8: 4BA401E9  bl 0x822351b0
	ctx.lr = 0x827F4FCC;
	sub_822351B0(ctx, base);
	// 827F4FCC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827F4FD0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F4FD4: 388B13A0  addi r4, r11, 0x13a0
	ctx.r[4].s64 = ctx.r[11].s64 + 5024;
	// 827F4FD8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F4FDC: 4BA37EF5  bl 0x8222ced0
	ctx.lr = 0x827F4FE0;
	sub_8222CED0(ctx, base);
	// 827F4FE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827F4FE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F4FE8: 4B9C0521  bl 0x821b5508
	ctx.lr = 0x827F4FEC;
	sub_821B5508(ctx, base);
	// 827F4FEC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F4FF0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F4FF4: 4BA1FDE5  bl 0x82214dd8
	ctx.lr = 0x827F4FF8;
	sub_82214DD8(ctx, base);
	// 827F4FF8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F4FFC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F5000: 388A13B0  addi r4, r10, 0x13b0
	ctx.r[4].s64 = ctx.r[10].s64 + 5040;
	// 827F5004: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F5008: 4BA37EC9  bl 0x8222ced0
	ctx.lr = 0x827F500C;
	sub_8222CED0(ctx, base);
	// 827F500C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827F5010: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F5014: 4B9C04F5  bl 0x821b5508
	ctx.lr = 0x827F5018;
	sub_821B5508(ctx, base);
	// 827F5018: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827F501C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F5020: 4BA1FDB9  bl 0x82214dd8
	ctx.lr = 0x827F5024;
	sub_82214DD8(ctx, base);
	// 827F5024: 2F1DFFFF  cmpwi cr6, r29, -1
	ctx.cr[6].compare_i32(ctx.r[29].s32, -1, &mut ctx.xer);
	// 827F5028: 419A00E0  beq cr6, 0x827f5108
	if ctx.cr[6].eq {
	pc = 0x827F5108; continue 'dispatch;
	}
	// 827F502C: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 827F5030: 419A00D8  beq cr6, 0x827f5108
	if ctx.cr[6].eq {
	pc = 0x827F5108; continue 'dispatch;
	}
	// 827F5034: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827F5038: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F503C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F5040: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F5044: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F5048: 4BA00A69  bl 0x821f5ab0
	ctx.lr = 0x827F504C;
	sub_821F5AB0(ctx, base);
	// 827F504C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827F5050: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F5054: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F5058: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F505C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 827F5060: 4BA00A51  bl 0x821f5ab0
	ctx.lr = 0x827F5064;
	sub_821F5AB0(ctx, base);
	// 827F5064: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 827F5068: 4BA2A1F1  bl 0x8221f258
	ctx.lr = 0x827F506C;
	sub_8221F258(ctx, base);
	// 827F506C: 3BFA0044  addi r31, r26, 0x44
	ctx.r[31].s64 = ctx.r[26].s64 + 68;
	// 827F5070: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F5074: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F5078: 4B9C2AA1  bl 0x821b7b18
	ctx.lr = 0x827F507C;
	sub_821B7B18(ctx, base);
	// 827F507C: 93DA0044  stw r30, 0x44(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(68 as u32), ctx.r[30].u32 ) };
	// 827F5080: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F5084: 419A0040  beq cr6, 0x827f50c4
	if ctx.cr[6].eq {
	pc = 0x827F50C4; continue 'dispatch;
	}
	// 827F5088: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F508C: 4BA2A1CD  bl 0x8221f258
	ctx.lr = 0x827F5090;
	sub_8221F258(ctx, base);
	// 827F5090: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F5094: 419A0028  beq cr6, 0x827f50bc
	if ctx.cr[6].eq {
	pc = 0x827F50BC; continue 'dispatch;
	}
	// 827F5098: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F509C: 3D208284  lis r9, -0x7d7c
	ctx.r[9].s64 = -2105278464;
	// 827F50A0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827F50A4: 38E957B0  addi r7, r9, 0x57b0
	ctx.r[7].s64 = ctx.r[9].s64 + 22448;
	// 827F50A8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F50AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F50B0: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 827F50B4: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F50B8: 48000008  b 0x827f50c0
	pc = 0x827F50C0; continue 'dispatch;
            }
            0x827F50BC => {
    //   block [0x827F50BC..0x827F50C0)
	// 827F50BC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x827F50C0; continue 'dispatch;
            }
            0x827F50C0 => {
    //   block [0x827F50C0..0x827F50C4)
	// 827F50C0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x827F50C4; continue 'dispatch;
            }
            0x827F50C4 => {
    //   block [0x827F50C4..0x827F5108)
	// 827F50C4: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 827F50C8: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F50CC: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 827F50D0: E8A10078  ld r5, 0x78(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 827F50D4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F5108; continue 'dispatch;
            }
            0x827F5108 => {
    //   block [0x827F5108..0x827F5110)
	// 827F5108: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F510C: 4BA3CBAD  bl 0x82231cb8
	ctx.lr = 0x827F5110;
	sub_82231CB8(ctx, base);
	pc = 0x827F5110; continue 'dispatch;
            }
            0x827F5110 => {
    //   block [0x827F5110..0x827F5158)
	// 827F5110: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827F5114: 419A0044  beq cr6, 0x827f5158
	if ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F5118: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 827F511C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F5120: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5124: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F5128: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827F512C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F5130: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5134: 4082FFE8  bne 0x827f511c
	if !ctx.cr[0].eq {
	pc = 0x827F511C; continue 'dispatch;
	}
	// 827F5138: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827F513C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F5140: 409A0018  bne cr6, 0x827f5158
	if !ctx.cr[6].eq {
	pc = 0x827F5158; continue 'dispatch;
	}
	// 827F5144: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5148: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F514C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5150: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F5154: 4E800421  bctrl
	ctx.lr = 0x827F5158;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F5158 => {
    //   block [0x827F5158..0x827F5164)
	// 827F5158: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827F515C: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 827F5160: 484B42EC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F5168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F5168 size=144
    let mut pc: u32 = 0x827F5168;
    'dispatch: loop {
        match pc {
            0x827F5168 => {
    //   block [0x827F5168..0x827F51F8)
	// 827F5168: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F516C: 11A1184A  vsubfp v13, v1, v3
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[13].f32[i] = ctx.v[1].f32[i] - ctx.v[3].f32[i];
	}
	// 827F5170: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 827F5174: 392A90F0  addi r9, r10, -0x6f10
	ctx.r[9].s64 = ctx.r[10].s64 + -28432;
	// 827F5178: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 827F517C: 896BEB8C  lbz r11, -0x1474(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5236 as u32) ) } as u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F51F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F51F8 size=164
    let mut pc: u32 = 0x827F51F8;
    'dispatch: loop {
        match pc {
            0x827F51F8 => {
    //   block [0x827F51F8..0x827F529C)
	// 827F51F8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F52A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F52A0 size=1116
    let mut pc: u32 = 0x827F52A0;
    'dispatch: loop {
        match pc {
            0x827F52A0 => {
    //   block [0x827F52A0..0x827F56FC)
	// 827F52A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F52A4: 484B414D  bl 0x82ca93f0
	ctx.lr = 0x827F52A8;
	sub_82CA93D0(ctx, base);
	// 827F52A8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 827F52AC: 484B8A29  bl 0x82cadcd4
	ctx.lr = 0x827F52B0;
	sub_82CADCA0(ctx, base);
	// 827F52B0: 3980FF50  li r12, -0xb0
	ctx.r[12].s64 = -176;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F5700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F5700 size=340
    let mut pc: u32 = 0x827F5700;
    'dispatch: loop {
        match pc {
            0x827F5700 => {
    //   block [0x827F5700..0x827F5764)
	// 827F5700: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F5704: 484B3CF9  bl 0x82ca93fc
	ctx.lr = 0x827F5708;
	sub_82CA93D0(ctx, base);
	// 827F5708: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F570C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F5710: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F5714: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 827F5718: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F571C: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 827F5720: E97F0008  ld r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	// 827F5724: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 827F5728: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827F572C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 827F5730: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F5734: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 827F5738: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F573C: C1810058  lfs f12, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827F5740: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5744: C1610050  lfs f11, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 827F5748: ED4C02F2  fmuls f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 827F574C: ED20537A  fmadds f9, f0, f13, f10
	ctx.f[9].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 827F5750: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F5754: ED00482C  fsqrts f8, f9
	ctx.f[8].f64 = ((ctx.f[9].f64).sqrt() as f32) as f64;
	// 827F5758: FF080000  fcmpu cr6, f8, f0
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[0].f64);
	// 827F575C: 41990008  bgt cr6, 0x827f5764
	if ctx.cr[6].gt {
	pc = 0x827F5764; continue 'dispatch;
	}
	// 827F5760: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F5764; continue 'dispatch;
            }
            0x827F5764 => {
    //   block [0x827F5764..0x827F5774)
	// 827F5764: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F5768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F576C: 409A0008  bne cr6, 0x827f5774
	if !ctx.cr[6].eq {
	pc = 0x827F5774; continue 'dispatch;
	}
	// 827F5770: E89F0000  ld r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	pc = 0x827F5774; continue 'dispatch;
            }
            0x827F5774 => {
    //   block [0x827F5774..0x827F584C)
	// 827F5774: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F5778: 4BFFD1D9  bl 0x827f2950
	ctx.lr = 0x827F577C;
	sub_827F2950(ctx, base);
	// 827F577C: 815F0134  lwz r10, 0x134(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(308 as u32) ) } as u64;
	// 827F5780: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 827F5784: 419A00C8  beq cr6, 0x827f584c
	if ctx.cr[6].eq {
	pc = 0x827F584C; continue 'dispatch;
	}
	// 827F5788: 817F0130  lwz r11, 0x130(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(304 as u32) ) } as u64;
	// 827F578C: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 827F5790: 419A00BC  beq cr6, 0x827f584c
	if ctx.cr[6].eq {
	pc = 0x827F584C; continue 'dispatch;
	}
	// 827F5794: 392000A0  li r9, 0xa0
	ctx.r[9].s64 = 160;
	// 827F5798: C03F0018  lfs f1, 0x18(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F579C: 39000120  li r8, 0x120
	ctx.r[8].s64 = 288;
	// 827F57A0: 38E00060  li r7, 0x60
	ctx.r[7].s64 = 96;
	// 827F57A4: 38C000E0  li r6, 0xe0
	ctx.r[6].s64 = 224;
	// 827F57A8: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	pc = 0x827F584C; continue 'dispatch;
            }
            0x827F584C => {
    //   block [0x827F584C..0x827F5854)
	// 827F584C: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 827F5850: 484B3BFC  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F5858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F5858 size=3104
    let mut pc: u32 = 0x827F5858;
    'dispatch: loop {
        match pc {
            0x827F5858 => {
    //   block [0x827F5858..0x827F58A4)
	// 827F5858: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F585C: 484B3B85  bl 0x82ca93e0
	ctx.lr = 0x827F5860;
	sub_82CA93D0(ctx, base);
	// 827F5860: DBE1FF80  stfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[31].u64 ) };
	// 827F5864: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F5868: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 827F586C: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 827F5870: 38750004  addi r3, r21, 4
	ctx.r[3].s64 = ctx.r[21].s64 + 4;
	// 827F5874: 7CB62B78  mr r22, r5
	ctx.r[22].u64 = ctx.r[5].u64;
	// 827F5878: 7CD33378  mr r19, r6
	ctx.r[19].u64 = ctx.r[6].u64;
	// 827F587C: 4BD89D5D  bl 0x8257f5d8
	ctx.lr = 0x827F5880;
	sub_8257F5D8(ctx, base);
	// 827F5880: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5884: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 827F5888: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F588C: 419A00BC  beq cr6, 0x827f5948
	if ctx.cr[6].eq {
	pc = 0x827F5948; continue 'dispatch;
	}
	// 827F5890: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5894: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5898: 409A000C  bne cr6, 0x827f58a4
	if !ctx.cr[6].eq {
	pc = 0x827F58A4; continue 'dispatch;
	}
	// 827F589C: 7E5D9378  mr r29, r18
	ctx.r[29].u64 = ctx.r[18].u64;
	// 827F58A0: 48000010  b 0x827f58b0
	pc = 0x827F58B0; continue 'dispatch;
            }
            0x827F58A4 => {
    //   block [0x827F58A4..0x827F58B0)
	// 827F58A4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F58A8: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827F58AC: 7D5D1670  srawi r29, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[10].s32 >> 2) as i64;
	pc = 0x827F58B0; continue 'dispatch;
            }
            0x827F58B0 => {
    //   block [0x827F58B0..0x827F58C8)
	// 827F58B0: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 827F58B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F58B8: 419A0090  beq cr6, 0x827f5948
	if ctx.cr[6].eq {
	pc = 0x827F5948; continue 'dispatch;
	}
	// 827F58BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F58C0: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 827F58C4: 3B8B7088  addi r28, r11, 0x7088
	ctx.r[28].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827F58C8; continue 'dispatch;
            }
            0x827F58C8 => {
    //   block [0x827F58C8..0x827F58EC)
	// 827F58C8: 8155001C  lwz r10, 0x1c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F58CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F58D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F58D4: 419A0018  beq cr6, 0x827f58ec
	if ctx.cr[6].eq {
	pc = 0x827F58EC; continue 'dispatch;
	}
	// 827F58D8: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F58DC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F58E0: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 827F58E4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F58E8: 41980008  blt cr6, 0x827f58f0
	if ctx.cr[6].lt {
	pc = 0x827F58F0; continue 'dispatch;
	}
	pc = 0x827F58EC; continue 'dispatch;
            }
            0x827F58EC => {
    //   block [0x827F58EC..0x827F58F0)
	// 827F58EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F58F0; continue 'dispatch;
            }
            0x827F58F0 => {
    //   block [0x827F58F0..0x827F5918)
	// 827F58F0: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827F58F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F58F8: 4B9FA949  bl 0x821f0240
	ctx.lr = 0x827F58FC;
	sub_821F0240(ctx, base);
	// 827F58FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827F5900: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827F5904: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5908: 480015A9  bl 0x827f6eb0
	ctx.lr = 0x827F590C;
	sub_827F6EB0(ctx, base);
	// 827F590C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F5910: 4B9D0E59  bl 0x821c6768
	ctx.lr = 0x827F5914;
	sub_821C6768(ctx, base);
	// 827F5914: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x827F5918; continue 'dispatch;
            }
            0x827F5918 => {
    //   block [0x827F5918..0x827F5948)
	// 827F5918: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F591C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5920: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F5924: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F5928: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F592C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5930: 4082FFE8  bne 0x827f5918
	if !ctx.cr[0].eq {
	pc = 0x827F5918; continue 'dispatch;
	}
	// 827F5934: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F5938: 92410050  stw r18, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[18].u32 ) };
	// 827F593C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827F5940: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F5944: 409AFF84  bne cr6, 0x827f58c8
	if !ctx.cr[6].eq {
	pc = 0x827F58C8; continue 'dispatch;
	}
	pc = 0x827F5948; continue 'dispatch;
            }
            0x827F5948 => {
    //   block [0x827F5948..0x827F59AC)
	// 827F5948: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827F594C: 48214C65  bl 0x82a0a5b0
	ctx.lr = 0x827F5950;
	sub_82A0A5B0(ctx, base);
	// 827F5950: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5954: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827F5958: 386B00D0  addi r3, r11, 0xd0
	ctx.r[3].s64 = ctx.r[11].s64 + 208;
	// 827F595C: 4BF75FAD  bl 0x8276b908
	ctx.lr = 0x827F5960;
	sub_8276B908(ctx, base);
	// 827F5960: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 827F5964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5968: 419A01B8  beq cr6, 0x827f5b20
	if ctx.cr[6].eq {
	pc = 0x827F5B20; continue 'dispatch;
	}
	// 827F596C: 81760030  lwz r11, 0x30(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F5970: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 827F5974: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 827F5978: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F597C: 419A00F4  beq cr6, 0x827f5a70
	if ctx.cr[6].eq {
	pc = 0x827F5A70; continue 'dispatch;
	}
	// 827F5980: 8176008C  lwz r11, 0x8c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F5984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5988: 419A0024  beq cr6, 0x827f59ac
	if ctx.cr[6].eq {
	pc = 0x827F59AC; continue 'dispatch;
	}
	// 827F598C: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 827F5990: 81760048  lwz r11, 0x48(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F5994: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F5998: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F599C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F59A0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F59A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F59A8: 480000CC  b 0x827f5a74
	pc = 0x827F5A74; continue 'dispatch;
            }
            0x827F59AC => {
    //   block [0x827F59AC..0x827F59C8)
	// 827F59AC: 81560048  lwz r10, 0x48(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F59B0: 80D6004C  lwz r6, 0x4c(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F59B4: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 827F59B8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F59BC: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F59C0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F59C4: 40810054  ble 0x827f5a18
	if !ctx.cr[0].gt {
	pc = 0x827F5A18; continue 'dispatch;
	}
	pc = 0x827F59C8; continue 'dispatch;
            }
            0x827F59C8 => {
    //   block [0x827F59C8..0x827F59E8)
	// 827F59C8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F59CC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F59D0: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 827F59D4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F59D8: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 827F59DC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F59E0: 41980008  blt cr6, 0x827f59e8
	if ctx.cr[6].lt {
	pc = 0x827F59E8; continue 'dispatch;
	}
	// 827F59E4: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	pc = 0x827F59E8; continue 'dispatch;
            }
            0x827F59E8 => {
    //   block [0x827F59E8..0x827F5A04)
	// 827F59E8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F59EC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F59F0: 419A0014  beq cr6, 0x827f5a04
	if ctx.cr[6].eq {
	pc = 0x827F5A04; continue 'dispatch;
	}
	// 827F59F4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F59F8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F59FC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F5A00: 4800000C  b 0x827f5a0c
	pc = 0x827F5A0C; continue 'dispatch;
            }
            0x827F5A04 => {
    //   block [0x827F5A04..0x827F5A0C)
	// 827F5A04: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F5A08: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F5A0C; continue 'dispatch;
            }
            0x827F5A0C => {
    //   block [0x827F5A0C..0x827F5A18)
	// 827F5A0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F5A10: 4199FFB8  bgt cr6, 0x827f59c8
	if ctx.cr[6].gt {
	pc = 0x827F59C8; continue 'dispatch;
	}
	// 827F5A14: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	pc = 0x827F5A18; continue 'dispatch;
            }
            0x827F5A18 => {
    //   block [0x827F5A18..0x827F5A34)
	// 827F5A18: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F5A1C: 419A0040  beq cr6, 0x827f5a5c
	if ctx.cr[6].eq {
	pc = 0x827F5A5C; continue 'dispatch;
	}
	// 827F5A20: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5A24: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 827F5A28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5A2C: 41990008  bgt cr6, 0x827f5a34
	if ctx.cr[6].gt {
	pc = 0x827F5A34; continue 'dispatch;
	}
	// 827F5A30: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x827F5A34; continue 'dispatch;
            }
            0x827F5A34 => {
    //   block [0x827F5A34..0x827F5A5C)
	// 827F5A34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F5A38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5A3C: 409A0020  bne cr6, 0x827f5a5c
	if !ctx.cr[6].eq {
	pc = 0x827F5A5C; continue 'dispatch;
	}
	// 827F5A40: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F5A44: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 827F5A48: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827F5A4C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5A50: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F5A54: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5A58: 4800001C  b 0x827f5a74
	pc = 0x827F5A74; continue 'dispatch;
            }
            0x827F5A5C => {
    //   block [0x827F5A5C..0x827F5A70)
	// 827F5A5C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F5A60: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5A64: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F5A68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5A6C: 48000008  b 0x827f5a74
	pc = 0x827F5A74; continue 'dispatch;
            }
            0x827F5A70 => {
    //   block [0x827F5A70..0x827F5A74)
	// 827F5A70: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x827F5A74; continue 'dispatch;
            }
            0x827F5A74 => {
    //   block [0x827F5A74..0x827F5A9C)
	// 827F5A74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F5A78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5A7C: 419A00A4  beq cr6, 0x827f5b20
	if ctx.cr[6].eq {
	pc = 0x827F5B20; continue 'dispatch;
	}
	// 827F5A80: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827F5A84: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 827F5A88: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 827F5A8C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5A90: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 827F5A94: E9010070  ld r8, 0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F5A98: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	pc = 0x827F5A9C; continue 'dispatch;
            }
            0x827F5A9C => {
    //   block [0x827F5A9C..0x827F5AB4)
	// 827F5A9C: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F5AA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5AA4: 419A0010  beq cr6, 0x827f5ab4
	if ctx.cr[6].eq {
	pc = 0x827F5AB4; continue 'dispatch;
	}
	// 827F5AA8: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 827F5AAC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F5AB0: 419A0008  beq cr6, 0x827f5ab8
	if ctx.cr[6].eq {
	pc = 0x827F5AB8; continue 'dispatch;
	}
	pc = 0x827F5AB4; continue 'dispatch;
            }
            0x827F5AB4 => {
    //   block [0x827F5AB4..0x827F5AB8)
	// 827F5AB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5AB8; continue 'dispatch;
            }
            0x827F5AB8 => {
    //   block [0x827F5AB8..0x827F5AD4)
	// 827F5AB8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F5ABC: 81210094  lwz r9, 0x94(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827F5AC0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F5AC4: 419A005C  beq cr6, 0x827f5b20
	if ctx.cr[6].eq {
	pc = 0x827F5B20; continue 'dispatch;
	}
	// 827F5AC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5ACC: 409A0008  bne cr6, 0x827f5ad4
	if !ctx.cr[6].eq {
	pc = 0x827F5AD4; continue 'dispatch;
	}
	// 827F5AD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5AD4; continue 'dispatch;
            }
            0x827F5AD4 => {
    //   block [0x827F5AD4..0x827F5AE4)
	// 827F5AD4: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5AD8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F5ADC: 409A0008  bne cr6, 0x827f5ae4
	if !ctx.cr[6].eq {
	pc = 0x827F5AE4; continue 'dispatch;
	}
	// 827F5AE0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5AE4; continue 'dispatch;
            }
            0x827F5AE4 => {
    //   block [0x827F5AE4..0x827F5AF4)
	// 827F5AE4: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 827F5AE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F5AEC: 409A0008  bne cr6, 0x827f5af4
	if !ctx.cr[6].eq {
	pc = 0x827F5AF4; continue 'dispatch;
	}
	// 827F5AF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5AF4; continue 'dispatch;
            }
            0x827F5AF4 => {
    //   block [0x827F5AF4..0x827F5B20)
	// 827F5AF4: C3E30004  lfs f31, 4(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F5AF8: 4BBBAF41  bl 0x823b0a38
	ctx.lr = 0x827F5AFC;
	sub_823B0A38(ctx, base);
	// 827F5AFC: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827F5B00: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827F5B04: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 827F5B08: 4BBD02F9  bl 0x823c5e00
	ctx.lr = 0x827F5B0C;
	sub_823C5E00(ctx, base);
	// 827F5B0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F5B10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F5B14: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 827F5B18: 4BD60D41  bl 0x82556858
	ctx.lr = 0x827F5B1C;
	sub_82556858(ctx, base);
	// 827F5B1C: 4BFFFF80  b 0x827f5a9c
	pc = 0x827F5A9C; continue 'dispatch;
            }
            0x827F5B20 => {
    //   block [0x827F5B20..0x827F5B38)
	// 827F5B20: 8155001C  lwz r10, 0x1c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5B24: 816A00C4  lwz r11, 0xc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 827F5B28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5B2C: 409A000C  bne cr6, 0x827f5b38
	if !ctx.cr[6].eq {
	pc = 0x827F5B38; continue 'dispatch;
	}
	// 827F5B30: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	// 827F5B34: 48000010  b 0x827f5b44
	pc = 0x827F5B44; continue 'dispatch;
            }
            0x827F5B38 => {
    //   block [0x827F5B38..0x827F5B44)
	// 827F5B38: 814A00C8  lwz r10, 0xc8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(200 as u32) ) } as u64;
	// 827F5B3C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F5B40: 7D371670  srawi r23, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[23].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x827F5B44; continue 'dispatch;
            }
            0x827F5B44 => {
    //   block [0x827F5B44..0x827F5B7C)
	// 827F5B44: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 827F5B48: 3B550034  addi r26, r21, 0x34
	ctx.r[26].s64 = ctx.r[21].s64 + 52;
	// 827F5B4C: 92410074  stw r18, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[18].u32 ) };
	// 827F5B50: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 827F5B54: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827F5B58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F5B5C: 48003515  bl 0x827f9070
	ctx.lr = 0x827F5B60;
	sub_827F9070(ctx, base);
	// 827F5B60: 7E5C9378  mr r28, r18
	ctx.r[28].u64 = ctx.r[18].u64;
	// 827F5B64: 7E589378  mr r24, r18
	ctx.r[24].u64 = ctx.r[18].u64;
	// 827F5B68: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 827F5B6C: 419A01A8  beq cr6, 0x827f5d14
	if ctx.cr[6].eq {
	pc = 0x827F5D14; continue 'dispatch;
	}
	// 827F5B70: 92810070  stw r20, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[20].u32 ) };
	// 827F5B74: 7E599378  mr r25, r18
	ctx.r[25].u64 = ctx.r[18].u64;
	// 827F5B78: 7E5B9378  mr r27, r18
	ctx.r[27].u64 = ctx.r[18].u64;
	pc = 0x827F5B7C; continue 'dispatch;
            }
            0x827F5B7C => {
    //   block [0x827F5B7C..0x827F5BA0)
	// 827F5B7C: 8155001C  lwz r10, 0x1c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5B80: 816A00C4  lwz r11, 0xc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 827F5B84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5B88: 419A0018  beq cr6, 0x827f5ba0
	if ctx.cr[6].eq {
	pc = 0x827F5BA0; continue 'dispatch;
	}
	// 827F5B8C: 814A00C8  lwz r10, 0xc8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(200 as u32) ) } as u64;
	// 827F5B90: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F5B94: 7D2A1670  srawi r10, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 827F5B98: 7F185040  cmplw cr6, r24, r10
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F5B9C: 41980008  blt cr6, 0x827f5ba4
	if ctx.cr[6].lt {
	pc = 0x827F5BA4; continue 'dispatch;
	}
	pc = 0x827F5BA0; continue 'dispatch;
            }
            0x827F5BA0 => {
    //   block [0x827F5BA0..0x827F5BA4)
	// 827F5BA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5BA4; continue 'dispatch;
            }
            0x827F5BA4 => {
    //   block [0x827F5BA4..0x827F5BC0)
	// 827F5BA4: 81340004  lwz r9, 4(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5BA8: 7D0BD82E  lwzx r8, r11, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 827F5BAC: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 827F5BB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5BB4: 88EB0019  lbz r7, 0x19(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F5BB8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F5BBC: 409A002C  bne cr6, 0x827f5be8
	if !ctx.cr[6].eq {
	pc = 0x827F5BE8; continue 'dispatch;
	}
	pc = 0x827F5BC0; continue 'dispatch;
            }
            0x827F5BC0 => {
    //   block [0x827F5BC0..0x827F5BD4)
	// 827F5BC0: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F5BC4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827F5BC8: 4098000C  bge cr6, 0x827f5bd4
	if !ctx.cr[6].lt {
	pc = 0x827F5BD4; continue 'dispatch;
	}
	// 827F5BCC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F5BD0: 4800000C  b 0x827f5bdc
	pc = 0x827F5BDC; continue 'dispatch;
            }
            0x827F5BD4 => {
    //   block [0x827F5BD4..0x827F5BDC)
	// 827F5BD4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F5BD8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F5BDC; continue 'dispatch;
            }
            0x827F5BDC => {
    //   block [0x827F5BDC..0x827F5BE8)
	// 827F5BDC: 88EB0019  lbz r7, 0x19(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F5BE0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F5BE4: 419AFFDC  beq cr6, 0x827f5bc0
	if ctx.cr[6].eq {
	pc = 0x827F5BC0; continue 'dispatch;
	}
	pc = 0x827F5BE8; continue 'dispatch;
            }
            0x827F5BE8 => {
    //   block [0x827F5BE8..0x827F5C08)
	// 827F5BE8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F5BEC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F5BF0: 419A0018  beq cr6, 0x827f5c08
	if ctx.cr[6].eq {
	pc = 0x827F5C08; continue 'dispatch;
	}
	// 827F5BF4: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F5BF8: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F5BFC: 4198000C  blt cr6, 0x827f5c08
	if ctx.cr[6].lt {
	pc = 0x827F5C08; continue 'dispatch;
	}
	// 827F5C00: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 827F5C04: 48000010  b 0x827f5c14
	pc = 0x827F5C14; continue 'dispatch;
            }
            0x827F5C08 => {
    //   block [0x827F5C08..0x827F5C14)
	// 827F5C08: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 827F5C0C: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 827F5C10: 92810068  stw r20, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u32 ) };
	pc = 0x827F5C14; continue 'dispatch;
            }
            0x827F5C14 => {
    //   block [0x827F5C14..0x827F5C30)
	// 827F5C14: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827F5C18: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827F5C1C: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827F5C20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5C24: 419A000C  beq cr6, 0x827f5c30
	if ctx.cr[6].eq {
	pc = 0x827F5C30; continue 'dispatch;
	}
	// 827F5C28: 7F0AA040  cmplw cr6, r10, r20
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[20].u32, &mut ctx.xer);
	// 827F5C2C: 419A0008  beq cr6, 0x827f5c34
	if ctx.cr[6].eq {
	pc = 0x827F5C34; continue 'dispatch;
	}
	pc = 0x827F5C30; continue 'dispatch;
            }
            0x827F5C30 => {
    //   block [0x827F5C30..0x827F5C34)
	// 827F5C30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5C34; continue 'dispatch;
            }
            0x827F5C34 => {
    //   block [0x827F5C34..0x827F5C4C)
	// 827F5C34: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827F5C38: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F5C3C: 419A00C8  beq cr6, 0x827f5d04
	if ctx.cr[6].eq {
	pc = 0x827F5D04; continue 'dispatch;
	}
	// 827F5C40: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5C44: 409A0008  bne cr6, 0x827f5c4c
	if !ctx.cr[6].eq {
	pc = 0x827F5C4C; continue 'dispatch;
	}
	// 827F5C48: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5C4C; continue 'dispatch;
            }
            0x827F5C4C => {
    //   block [0x827F5C4C..0x827F5C5C)
	// 827F5C4C: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5C50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F5C54: 409A0008  bne cr6, 0x827f5c5c
	if !ctx.cr[6].eq {
	pc = 0x827F5C5C; continue 'dispatch;
	}
	// 827F5C58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5C5C; continue 'dispatch;
            }
            0x827F5C5C => {
    //   block [0x827F5C5C..0x827F5C74)
	// 827F5C5C: 83CB0014  lwz r30, 0x14(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F5C60: 83AB0010  lwz r29, 0x10(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F5C64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F5C68: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827F5C6C: 93A10080  stw r29, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[29].u32 ) };
	// 827F5C70: 419A0020  beq cr6, 0x827f5c90
	if ctx.cr[6].eq {
	pc = 0x827F5C90; continue 'dispatch;
	}
	pc = 0x827F5C74; continue 'dispatch;
            }
            0x827F5C74 => {
    //   block [0x827F5C74..0x827F5C90)
	// 827F5C74: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F5C78: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5C7C: 7D60F028  lwarx r11, 0, r30
	// lwarx
	let ea = ctx.r[30].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F5C80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F5C84: 7D60F12D  stwcx. r11, 0, r30
	// stwcx.
	let addr = ctx.r[30].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F5C88: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F5C8C: 4082FFE8  bne 0x827f5c74
	if !ctx.cr[0].eq {
	pc = 0x827F5C74; continue 'dispatch;
	}
	pc = 0x827F5C90; continue 'dispatch;
            }
            0x827F5C90 => {
    //   block [0x827F5C90..0x827F5CBC)
	// 827F5C90: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827F5C94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F5C98: 4BFFF079  bl 0x827f4d10
	ctx.lr = 0x827F5C9C;
	sub_827F4D10(ctx, base);
	// 827F5C9C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5CA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5CA4: 419A0018  beq cr6, 0x827f5cbc
	if ctx.cr[6].eq {
	pc = 0x827F5CBC; continue 'dispatch;
	}
	// 827F5CA8: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F5CAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F5CB0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F5CB4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F5CB8: 41980008  blt cr6, 0x827f5cc0
	if ctx.cr[6].lt {
	pc = 0x827F5CC0; continue 'dispatch;
	}
	pc = 0x827F5CBC; continue 'dispatch;
            }
            0x827F5CBC => {
    //   block [0x827F5CBC..0x827F5CC0)
	// 827F5CBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F5CC0; continue 'dispatch;
            }
            0x827F5CC0 => {
    //   block [0x827F5CC0..0x827F5CFC)
	// 827F5CC0: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 827F5CC4: 3B9C0001  addi r28, r28, 1
	ctx.r[28].s64 = ctx.r[28].s64 + 1;
	// 827F5CC8: 3B390008  addi r25, r25, 8
	ctx.r[25].s64 = ctx.r[25].s64 + 8;
	// 827F5CCC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5CD0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F5CD4: 419A0028  beq cr6, 0x827f5cfc
	if ctx.cr[6].eq {
	pc = 0x827F5CFC; continue 'dispatch;
	}
	// 827F5CD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F5CDC: 4B9C1E3D  bl 0x821b7b18
	ctx.lr = 0x827F5CE0;
	sub_821B7B18(ctx, base);
	// 827F5CE0: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827F5CE4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F5CE8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F5CEC: 419A0010  beq cr6, 0x827f5cfc
	if ctx.cr[6].eq {
	pc = 0x827F5CFC; continue 'dispatch;
	}
	// 827F5CF0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5CF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F5CF8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F5CFC; continue 'dispatch;
            }
            0x827F5CFC => {
    //   block [0x827F5CFC..0x827F5D04)
	// 827F5CFC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827F5D00: 4B9C1E19  bl 0x821b7b18
	ctx.lr = 0x827F5D04;
	sub_821B7B18(ctx, base);
	pc = 0x827F5D04; continue 'dispatch;
            }
            0x827F5D04 => {
    //   block [0x827F5D04..0x827F5D14)
	// 827F5D04: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 827F5D08: 3B7B0004  addi r27, r27, 4
	ctx.r[27].s64 = ctx.r[27].s64 + 4;
	// 827F5D0C: 7F18B840  cmplw cr6, r24, r23
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827F5D10: 409AFE6C  bne cr6, 0x827f5b7c
	if !ctx.cr[6].eq {
	pc = 0x827F5B7C; continue 'dispatch;
	}
	pc = 0x827F5D14; continue 'dispatch;
            }
            0x827F5D14 => {
    //   block [0x827F5D14..0x827F5D80)
	// 827F5D14: 92410080  stw r18, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[18].u32 ) };
	// 827F5D18: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 827F5D1C: 92410084  stw r18, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[18].u32 ) };
	// 827F5D20: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F5D24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F5D28: 48003349  bl 0x827f9070
	ctx.lr = 0x827F5D2C;
	sub_827F9070(ctx, base);
	// 827F5D2C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F5D30: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827F5D34: 394B9490  addi r10, r11, -0x6b70
	ctx.r[10].s64 = ctx.r[11].s64 + -27504;
	// 827F5D38: C00AFFF4  lfs f0, -0xc(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F5D3C: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5D40: C3F30018  lfs f31, 0x18(r19)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 827F5D44: D0150030  stfs f0, 0x30(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 827F5D48: 99350028  stb r9, 0x28(r21)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[21].u32.wrapping_add(40 as u32), ctx.r[9].u8 ) };
	// 827F5D4C: D015002C  stfs f0, 0x2c(r21)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 827F5D50: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F5D54: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827F5D58: 419A036C  beq cr6, 0x827f60c4
	if ctx.cr[6].eq {
	pc = 0x827F60C4; continue 'dispatch;
	}
	// 827F5D5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F5D60: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 827F5D64: 409A001C  bne cr6, 0x827f5d80
	if !ctx.cr[6].eq {
	pc = 0x827F5D80; continue 'dispatch;
	}
	// 827F5D68: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F5D6C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F5D70: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F5D74: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5D78: 48000A41  bl 0x827f67b8
	ctx.lr = 0x827F5D7C;
	sub_827F67B8(ctx, base);
	// 827F5D7C: 480000E0  b 0x827f5e5c
	pc = 0x827F5E5C; continue 'dispatch;
            }
            0x827F5D80 => {
    //   block [0x827F5D80..0x827F5DA0)
	// 827F5D80: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 827F5D84: 409A001C  bne cr6, 0x827f5da0
	if !ctx.cr[6].eq {
	pc = 0x827F5DA0; continue 'dispatch;
	}
	// 827F5D88: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F5D8C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F5D90: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F5D94: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5D98: 48000F11  bl 0x827f6ca8
	ctx.lr = 0x827F5D9C;
	sub_827F6CA8(ctx, base);
	// 827F5D9C: 480000C0  b 0x827f5e5c
	pc = 0x827F5E5C; continue 'dispatch;
            }
            0x827F5DA0 => {
    //   block [0x827F5DA0..0x827F5E0C)
	// 827F5DA0: 2F090003  cmpwi cr6, r9, 3
	ctx.cr[6].compare_i32(ctx.r[9].s32, 3, &mut ctx.xer);
	// 827F5DA4: 409A0068  bne cr6, 0x827f5e0c
	if !ctx.cr[6].eq {
	pc = 0x827F5E0C; continue 'dispatch;
	}
	// 827F5DA8: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F5DAC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F5DB0: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F5DB4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5DB8: 48000FD1  bl 0x827f6d88
	ctx.lr = 0x827F5DBC;
	sub_827F6D88(ctx, base);
	// 827F5DBC: 8096007C  lwz r4, 0x7c(r22)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(124 as u32) ) } as u64;
	// 827F5DC0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827F5DC4: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5DC8: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F5DCC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F5DD0: 4E800421  bctrl
	ctx.lr = 0x827F5DD4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F5DD4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 827F5DD8: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 827F5DDC: 38E990F0  addi r7, r9, -0x6f10
	ctx.r[7].s64 = ctx.r[9].s64 + -28432;
	// 827F5DE0: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
            }
            0x827F5E0C => {
    //   block [0x827F5E0C..0x827F5E5C)
	// 827F5E0C: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 827F5E10: 409A0030  bne cr6, 0x827f5e40
	if !ctx.cr[6].eq {
	pc = 0x827F5E40; continue 'dispatch;
	}
	// 827F5E14: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F5E18: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F5E1C: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F5E20: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5E24: 48000F65  bl 0x827f6d88
	ctx.lr = 0x827F5E28;
	sub_827F6D88(ctx, base);
	// 827F5E28: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5E2C: C0130014  lfs f0, 0x14(r19)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F5E30: C1AB004C  lfs f13, 0x4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F5E34: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 827F5E38: D1950030  stfs f12, 0x30(r21)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 827F5E3C: 48000020  b 0x827f5e5c
	pc = 0x827F5E5C; continue 'dispatch;
	// 827F5E40: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 827F5E44: 409A0018  bne cr6, 0x827f5e5c
	if !ctx.cr[6].eq {
	pc = 0x827F5E5C; continue 'dispatch;
	}
	// 827F5E48: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F5E4C: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F5E50: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F5E54: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F5E58: 48000FB9  bl 0x827f6e10
	ctx.lr = 0x827F5E5C;
	sub_827F6E10(ctx, base);
            }
            0x827F5E5C => {
    //   block [0x827F5E5C..0x827F60C4)
	// 827F5E5C: 81750014  lwz r11, 0x14(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F5E60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5E64: 419A05CC  beq cr6, 0x827f6430
	if ctx.cr[6].eq {
	pc = 0x827F6430; continue 'dispatch;
	}
	// 827F5E68: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F5E6C: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 827F5E70: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 827F5E74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5E78: 419A00F4  beq cr6, 0x827f5f6c
	if ctx.cr[6].eq {
	pc = 0x827F5F6C; continue 'dispatch;
	}
	// 827F5E7C: 8176008C  lwz r11, 0x8c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F5E80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5E84: 419A0024  beq cr6, 0x827f5ea8
	if ctx.cr[6].eq {
	pc = 0x827F5EA8; continue 'dispatch;
	}
	// 827F5E88: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 827F5E8C: 81760048  lwz r11, 0x48(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F5E90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F5E94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F5E98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5E9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F5EA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5EA4: 480000CC  b 0x827f5f70
	pc = 0x827F5F70; continue 'dispatch;
	// 827F5EA8: 81560048  lwz r10, 0x48(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F5EAC: 80D6004C  lwz r6, 0x4c(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F5EB0: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 827F5EB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F5EB8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F5EBC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F5EC0: 40810054  ble 0x827f5f14
	if !ctx.cr[0].gt {
	pc = 0x827F5F14; continue 'dispatch;
	}
	// 827F5EC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F5EC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F5ECC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F5ED0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5ED4: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 827F5ED8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F5EDC: 41980008  blt cr6, 0x827f5ee4
	if ctx.cr[6].lt {
	pc = 0x827F5EE4; continue 'dispatch;
	}
	// 827F5EE0: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F5EE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F5EE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F5EEC: 419A0014  beq cr6, 0x827f5f00
	if ctx.cr[6].eq {
	pc = 0x827F5F00; continue 'dispatch;
	}
	// 827F5EF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F5EF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F5EF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F5EFC: 4800000C  b 0x827f5f08
	pc = 0x827F5F08; continue 'dispatch;
	// 827F5F00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F5F04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 827F5F08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F5F0C: 4199FFB8  bgt cr6, 0x827f5ec4
	if ctx.cr[6].gt {
	pc = 0x827F5EC4; continue 'dispatch;
	}
	// 827F5F10: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F5F14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F5F18: 419A0040  beq cr6, 0x827f5f58
	if ctx.cr[6].eq {
	pc = 0x827F5F58; continue 'dispatch;
	}
	// 827F5F1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5F20: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 827F5F24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5F28: 41990008  bgt cr6, 0x827f5f30
	if ctx.cr[6].gt {
	pc = 0x827F5F30; continue 'dispatch;
	}
	// 827F5F2C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 827F5F30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F5F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5F38: 409A0020  bne cr6, 0x827f5f58
	if !ctx.cr[6].eq {
	pc = 0x827F5F58; continue 'dispatch;
	}
	// 827F5F3C: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F5F40: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 827F5F44: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827F5F48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5F4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F5F50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5F54: 4800001C  b 0x827f5f70
	pc = 0x827F5F70; continue 'dispatch;
	// 827F5F58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F5F5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F5F60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F5F64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F5F68: 48000008  b 0x827f5f70
	pc = 0x827F5F70; continue 'dispatch;
	// 827F5F6C: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 827F5F70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F5F74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F5F78: 419A04B8  beq cr6, 0x827f6430
	if ctx.cr[6].eq {
	pc = 0x827F6430; continue 'dispatch;
	}
	// 827F5F7C: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5F80: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F5F84: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F5F88: C1AB0028  lfs f13, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F5F8C: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F5F90: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 827F5F94: 4099003C  ble cr6, 0x827f5fd0
	if !ctx.cr[6].gt {
	pc = 0x827F5FD0; continue 'dispatch;
	}
	// 827F5F98: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F5F9C: 894B6D44  lbz r10, 0x6d44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27972 as u32) ) } as u64;
	// 827F5FA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F5FA4: 409A002C  bne cr6, 0x827f5fd0
	if !ctx.cr[6].eq {
	pc = 0x827F5FD0; continue 'dispatch;
	}
	// 827F5FA8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 827F5FAC: 4BA292AD  bl 0x8221f258
	ctx.lr = 0x827F5FB0;
	sub_8221F258(ctx, base);
	// 827F5FB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F5FB4: 419A0018  beq cr6, 0x827f5fcc
	if ctx.cr[6].eq {
	pc = 0x827F5FCC; continue 'dispatch;
	}
	// 827F5FB8: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F5FBC: C02B0028  lfs f1, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F5FC0: 4BA95B81  bl 0x8228bb40
	ctx.lr = 0x827F5FC4;
	sub_8228BB40(ctx, base);
	// 827F5FC4: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827F5FC8: 48000008  b 0x827f5fd0
	pc = 0x827F5FD0; continue 'dispatch;
	// 827F5FCC: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F5FD0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827F5FD4: 80B50014  lwz r5, 0x14(r21)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F5FD8: 38C00008  li r6, 8
	ctx.r[6].s64 = 8;
	// 827F5FDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F5FE0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F5FE4: 4B9D815D  bl 0x821ce140
	ctx.lr = 0x827F5FE8;
	sub_821CE140(ctx, base);
	// 827F5FE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F5FEC: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5FF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F5FF4: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 827F5FF8: 419A0078  beq cr6, 0x827f6070
	if ctx.cr[6].eq {
	pc = 0x827F6070; continue 'dispatch;
	}
	// 827F5FFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F6000: 419A0040  beq cr6, 0x827f6040
	if ctx.cr[6].eq {
	pc = 0x827F6040; continue 'dispatch;
	}
	// 827F6004: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 827F6008: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F600C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6010: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F6014: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6018: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F601C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6020: 4082FFE8  bne 0x827f6008
	if !ctx.cr[0].eq {
	pc = 0x827F6008; continue 'dispatch;
	}
	// 827F6024: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6028: 409A0014  bne cr6, 0x827f603c
	if !ctx.cr[6].eq {
	pc = 0x827F603C; continue 'dispatch;
	}
	// 827F602C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6030: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6034: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F6038: 4E800421  bctrl
	ctx.lr = 0x827F603C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F603C: 92550000  stw r18, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 827F6040: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6048: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F604C: 419A0024  beq cr6, 0x827f6070
	if ctx.cr[6].eq {
	pc = 0x827F6070; continue 'dispatch;
	}
	// 827F6050: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827F6054: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F6058: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F605C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F6060: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F6064: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F6068: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F606C: 4082FFE8  bne 0x827f6054
	if !ctx.cr[0].eq {
	pc = 0x827F6054; continue 'dispatch;
	}
	// 827F6070: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F6074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6078: 419A03B8  beq cr6, 0x827f6430
	if ctx.cr[6].eq {
	pc = 0x827F6430; continue 'dispatch;
	}
	// 827F607C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F6080: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 827F6084: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F6088: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F608C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F6090: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827F6094: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F6098: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F609C: 4082FFE8  bne 0x827f6084
	if !ctx.cr[0].eq {
	pc = 0x827F6084; continue 'dispatch;
	}
	// 827F60A0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827F60A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F60A8: 409A0014  bne cr6, 0x827f60bc
	if !ctx.cr[6].eq {
	pc = 0x827F60BC; continue 'dispatch;
	}
	// 827F60AC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F60B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F60B4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F60B8: 4E800421  bctrl
	ctx.lr = 0x827F60BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F60BC: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 827F60C0: 48000370  b 0x827f6430
	pc = 0x827F6430; continue 'dispatch;
            }
            0x827F60C4 => {
    //   block [0x827F60C4..0x827F6478)
	// 827F60C4: 892B0030  lbz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F60C8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F60CC: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 827F60D0: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 827F60D4: 9241006C  stw r18, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[18].u32 ) };
	// 827F60D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F60DC: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 827F60E0: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 827F60E4: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F60E8: 419A003C  beq cr6, 0x827f6124
	if ctx.cr[6].eq {
	pc = 0x827F6124; continue 'dispatch;
	}
	// 827F60EC: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F60F0: 48000D21  bl 0x827f6e10
	ctx.lr = 0x827F60F4;
	sub_827F6E10(ctx, base);
	// 827F60F4: 83D50018  lwz r30, 0x18(r21)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F60F8: 83F50014  lwz r31, 0x14(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F60FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F6100: 419A0328  beq cr6, 0x827f6428
	if ctx.cr[6].eq {
	pc = 0x827F6428; continue 'dispatch;
	}
	// 827F6104: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F6108: 4B9C1A11  bl 0x821b7b18
	ctx.lr = 0x827F610C;
	sub_821B7B18(ctx, base);
	// 827F610C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6110: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 827F6114: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F6118: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827F611C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F6120: 480000BC  b 0x827f61dc
	pc = 0x827F61DC; continue 'dispatch;
	// 827F6124: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F6128: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 827F612C: 409A003C  bne cr6, 0x827f6168
	if !ctx.cr[6].eq {
	pc = 0x827F6168; continue 'dispatch;
	}
	// 827F6130: 38950014  addi r4, r21, 0x14
	ctx.r[4].s64 = ctx.r[21].s64 + 20;
	// 827F6134: 48000685  bl 0x827f67b8
	ctx.lr = 0x827F6138;
	sub_827F67B8(ctx, base);
	// 827F6138: 83D50018  lwz r30, 0x18(r21)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F613C: 83F50014  lwz r31, 0x14(r21)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F6140: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F6144: 419A02E4  beq cr6, 0x827f6428
	if ctx.cr[6].eq {
	pc = 0x827F6428; continue 'dispatch;
	}
	// 827F6148: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F614C: 4B9C19CD  bl 0x821b7b18
	ctx.lr = 0x827F6150;
	sub_821B7B18(ctx, base);
	// 827F6150: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6154: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 827F6158: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F615C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827F6160: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F6164: 48000078  b 0x827f61dc
	pc = 0x827F61DC; continue 'dispatch;
	// 827F6168: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 827F616C: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	// 827F6170: 92410074  stw r18, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[18].u32 ) };
	// 827F6174: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 827F6178: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 827F617C: 48001685  bl 0x827f7800
	ctx.lr = 0x827F6180;
	sub_827F7800(ctx, base);
	// 827F6180: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 827F6184: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 827F6188: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827F618C: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 827F6190: 4BFFF571  bl 0x827f5700
	ctx.lr = 0x827F6194;
	sub_827F5700(ctx, base);
	// 827F6194: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F6198: 81750018  lwz r11, 0x18(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F619C: 3BF50014  addi r31, r21, 0x14
	ctx.r[31].s64 = ctx.r[21].s64 + 20;
	// 827F61A0: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F61A4: 419A002C  beq cr6, 0x827f61d0
	if ctx.cr[6].eq {
	pc = 0x827F61D0; continue 'dispatch;
	}
	// 827F61A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F61AC: 4B9C196D  bl 0x821b7b18
	ctx.lr = 0x827F61B0;
	sub_821B7B18(ctx, base);
	// 827F61B0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827F61B4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F61B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F61BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F61C0: 419A0010  beq cr6, 0x827f61d0
	if ctx.cr[6].eq {
	pc = 0x827F61D0; continue 'dispatch;
	}
	// 827F61C4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F61C8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F61CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F61D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F61D4: 4B9C1945  bl 0x821b7b18
	ctx.lr = 0x827F61D8;
	sub_821B7B18(ctx, base);
	// 827F61D8: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827F61DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827F61E0: 419A0248  beq cr6, 0x827f6428
	if ctx.cr[6].eq {
	pc = 0x827F6428; continue 'dispatch;
	}
	// 827F61E4: 81760024  lwz r11, 0x24(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F61E8: 7E5E9378  mr r30, r18
	ctx.r[30].u64 = ctx.r[18].u64;
	// 827F61EC: 556A6FFE  rlwinm r10, r11, 0xd, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0007FFFFu64;
	// 827F61F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F61F4: 419A00D8  beq cr6, 0x827f62cc
	if ctx.cr[6].eq {
	pc = 0x827F62CC; continue 'dispatch;
	}
	// 827F61F8: 8176008C  lwz r11, 0x8c(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F61FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6200: 419A001C  beq cr6, 0x827f621c
	if ctx.cr[6].eq {
	pc = 0x827F621C; continue 'dispatch;
	}
	// 827F6204: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 827F6208: 81760048  lwz r11, 0x48(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F620C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F6210: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F6214: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6218: 480000B0  b 0x827f62c8
	pc = 0x827F62C8; continue 'dispatch;
	// 827F621C: 81560048  lwz r10, 0x48(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F6220: 80D6004C  lwz r6, 0x4c(r22)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F6224: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 827F6228: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F622C: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F6230: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6234: 40810054  ble 0x827f6288
	if !ctx.cr[0].gt {
	pc = 0x827F6288; continue 'dispatch;
	}
	// 827F6238: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F623C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F6240: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F6244: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6248: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 827F624C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F6250: 41980008  blt cr6, 0x827f6258
	if ctx.cr[6].lt {
	pc = 0x827F6258; continue 'dispatch;
	}
	// 827F6254: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F6258: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F625C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F6260: 419A0014  beq cr6, 0x827f6274
	if ctx.cr[6].eq {
	pc = 0x827F6274; continue 'dispatch;
	}
	// 827F6264: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F6268: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F626C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6270: 4800000C  b 0x827f627c
	pc = 0x827F627C; continue 'dispatch;
	// 827F6274: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F6278: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 827F627C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6280: 4199FFB8  bgt cr6, 0x827f6238
	if ctx.cr[6].gt {
	pc = 0x827F6238; continue 'dispatch;
	}
	// 827F6284: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827F6288: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F628C: 419A0034  beq cr6, 0x827f62c0
	if ctx.cr[6].eq {
	pc = 0x827F62C0; continue 'dispatch;
	}
	// 827F6290: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6294: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 827F6298: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F629C: 41990008  bgt cr6, 0x827f62a4
	if ctx.cr[6].gt {
	pc = 0x827F62A4; continue 'dispatch;
	}
	// 827F62A0: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 827F62A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F62A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F62AC: 409A0014  bne cr6, 0x827f62c0
	if !ctx.cr[6].eq {
	pc = 0x827F62C0; continue 'dispatch;
	}
	// 827F62B0: E9610070  ld r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F62B4: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 827F62B8: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827F62BC: 48000008  b 0x827f62c4
	pc = 0x827F62C4; continue 'dispatch;
	// 827F62C0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F62C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F62C8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827F62CC: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F62D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F62D4: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F62D8: C1AB0028  lfs f13, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F62DC: C00A9A80  lfs f0, -0x6580(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F62E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 827F62E4: 4099003C  ble cr6, 0x827f6320
	if !ctx.cr[6].gt {
	pc = 0x827F6320; continue 'dispatch;
	}
	// 827F62E8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F62EC: 894B6D44  lbz r10, 0x6d44(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27972 as u32) ) } as u64;
	// 827F62F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F62F4: 409A002C  bne cr6, 0x827f6320
	if !ctx.cr[6].eq {
	pc = 0x827F6320; continue 'dispatch;
	}
	// 827F62F8: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 827F62FC: 4BA28F5D  bl 0x8221f258
	ctx.lr = 0x827F6300;
	sub_8221F258(ctx, base);
	// 827F6300: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F6304: 419A0018  beq cr6, 0x827f631c
	if ctx.cr[6].eq {
	pc = 0x827F631C; continue 'dispatch;
	}
	// 827F6308: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F630C: C02B0028  lfs f1, 0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F6310: 4BA95831  bl 0x8228bb40
	ctx.lr = 0x827F6314;
	sub_8228BB40(ctx, base);
	// 827F6314: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 827F6318: 48000008  b 0x827f6320
	pc = 0x827F6320; continue 'dispatch;
	// 827F631C: 7E479378  mr r7, r18
	ctx.r[7].u64 = ctx.r[18].u64;
	// 827F6320: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6324: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 827F6328: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827F632C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F6330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F6334: 892B0030  lbz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F6338: 20C90000  subfic r6, r9, 0
	ctx.xer.ca = ctx.r[9].u32 <= 0 as u32;
	ctx.r[6].s64 = (0 as i64) - ctx.r[9].s64;
	// 827F633C: 7D663110  subfe r11, r6, r6
	let x = (!ctx.r[6].u32);
	let y = ctx.r[6].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 827F6340: 556B003C  rlwinm r11, r11, 0, 0, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F6344: 556B07B8  rlwinm r11, r11, 0, 0x1e, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827F6348: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 827F634C: 4B9D7DF5  bl 0x821ce140
	ctx.lr = 0x827F6350;
	sub_821CE140(ctx, base);
	// 827F6350: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F6354: 80750000  lwz r3, 0(r21)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6358: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F635C: 7F035000  cmpw cr6, r3, r10
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[10].s32, &mut ctx.xer);
	// 827F6360: 419A0078  beq cr6, 0x827f63d8
	if ctx.cr[6].eq {
	pc = 0x827F63D8; continue 'dispatch;
	}
	// 827F6364: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F6368: 419A0040  beq cr6, 0x827f63a8
	if ctx.cr[6].eq {
	pc = 0x827F63A8; continue 'dispatch;
	}
	// 827F636C: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	// 827F6370: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F6374: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6378: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F637C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6380: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F6384: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6388: 4082FFE8  bne 0x827f6370
	if !ctx.cr[0].eq {
	pc = 0x827F6370; continue 'dispatch;
	}
	// 827F638C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6390: 409A0014  bne cr6, 0x827f63a4
	if !ctx.cr[6].eq {
	pc = 0x827F63A4; continue 'dispatch;
	}
	// 827F6394: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6398: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F639C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F63A0: 4E800421  bctrl
	ctx.lr = 0x827F63A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F63A4: 92550000  stw r18, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[18].u32 ) };
	// 827F63A8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F63AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F63B0: 91750000  stw r11, 0(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F63B4: 419A0024  beq cr6, 0x827f63d8
	if ctx.cr[6].eq {
	pc = 0x827F63D8; continue 'dispatch;
	}
	// 827F63B8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 827F63BC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F63C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F63C4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F63C8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F63CC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F63D0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F63D4: 4082FFE8  bne 0x827f63bc
	if !ctx.cr[0].eq {
	pc = 0x827F63BC; continue 'dispatch;
	}
	// 827F63D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F63DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F63E0: 419A0048  beq cr6, 0x827f6428
	if ctx.cr[6].eq {
	pc = 0x827F6428; continue 'dispatch;
	}
	// 827F63E4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F63E8: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 827F63EC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F63F0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F63F4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F63F8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827F63FC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F6400: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6404: 4082FFE8  bne 0x827f63ec
	if !ctx.cr[0].eq {
	pc = 0x827F63EC; continue 'dispatch;
	}
	// 827F6408: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827F640C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6410: 409A0014  bne cr6, 0x827f6424
	if !ctx.cr[6].eq {
	pc = 0x827F6424; continue 'dispatch;
	}
	// 827F6414: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6418: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F641C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F6420: 4E800421  bctrl
	ctx.lr = 0x827F6424;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F6424: 92410058  stw r18, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[18].u32 ) };
	// 827F6428: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F642C: 4B9C16ED  bl 0x821b7b18
	ctx.lr = 0x827F6430;
	sub_821B7B18(ctx, base);
	// 827F6430: 81610094  lwz r11, 0x94(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827F6434: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 827F6438: 39410090  addi r10, r1, 0x90
	ctx.r[10].s64 = ctx.r[1].s64 + 144;
	// 827F643C: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 827F6440: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 827F6444: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F6448: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 827F644C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6450: 91610084  stw r11, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 827F6454: E8C10080  ld r6, 0x80(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 827F6458: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 827F645C: E8A10070  ld r5, 0x70(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827F6460: 482BDA29  bl 0x82ab3e88
	ctx.lr = 0x827F6464;
	sub_82AB3E88(ctx, base);
	// 827F6464: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827F6468: 4BA258D1  bl 0x8221bd38
	ctx.lr = 0x827F646C;
	sub_8221BD38(ctx, base);
	// 827F646C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 827F6470: CBE1FF80  lfd f31, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 827F6474: 484B2FBC  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F6478(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F6478 size=828
    let mut pc: u32 = 0x827F6478;
    'dispatch: loop {
        match pc {
            0x827F6478 => {
    //   block [0x827F6478..0x827F64D0)
	// 827F6478: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F647C: 484B2F8D  bl 0x82ca9408
	ctx.lr = 0x827F6480;
	sub_82CA93D0(ctx, base);
	// 827F6480: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F6484: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F6488: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F648C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827F6490: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 827F6494: 9B9D0028  stb r28, 0x28(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[28].u8 ) };
	// 827F6498: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F649C: 556A97FE  rlwinm r10, r11, 0x12, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00003FFFu64;
	// 827F64A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F64A4: 419A00E8  beq cr6, 0x827f658c
	if ctx.cr[6].eq {
	pc = 0x827F658C; continue 'dispatch;
	}
	// 827F64A8: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F64AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F64B0: 419A0020  beq cr6, 0x827f64d0
	if ctx.cr[6].eq {
	pc = 0x827F64D0; continue 'dispatch;
	}
	// 827F64B4: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 827F64B8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F64BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F64C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F64C4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F64C8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F64CC: 480000C4  b 0x827f6590
	pc = 0x827F6590; continue 'dispatch;
            }
            0x827F64D0 => {
    //   block [0x827F64D0..0x827F64EC)
	// 827F64D0: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F64D4: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F64D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F64DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F64E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F64E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F64E8: 40810054  ble 0x827f653c
	if !ctx.cr[0].gt {
	pc = 0x827F653C; continue 'dispatch;
	}
	pc = 0x827F64EC; continue 'dispatch;
            }
            0x827F64EC => {
    //   block [0x827F64EC..0x827F650C)
	// 827F64EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F64F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F64F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F64F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F64FC: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 827F6500: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F6504: 41980008  blt cr6, 0x827f650c
	if ctx.cr[6].lt {
	pc = 0x827F650C; continue 'dispatch;
	}
	// 827F6508: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x827F650C; continue 'dispatch;
            }
            0x827F650C => {
    //   block [0x827F650C..0x827F6528)
	// 827F650C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F6510: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F6514: 419A0014  beq cr6, 0x827f6528
	if ctx.cr[6].eq {
	pc = 0x827F6528; continue 'dispatch;
	}
	// 827F6518: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F651C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F6520: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6524: 4800000C  b 0x827f6530
	pc = 0x827F6530; continue 'dispatch;
            }
            0x827F6528 => {
    //   block [0x827F6528..0x827F6530)
	// 827F6528: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F652C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F6530; continue 'dispatch;
            }
            0x827F6530 => {
    //   block [0x827F6530..0x827F653C)
	// 827F6530: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6534: 4199FFB8  bgt cr6, 0x827f64ec
	if ctx.cr[6].gt {
	pc = 0x827F64EC; continue 'dispatch;
	}
	// 827F6538: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F653C; continue 'dispatch;
            }
            0x827F653C => {
    //   block [0x827F653C..0x827F6558)
	// 827F653C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F6540: 419A003C  beq cr6, 0x827f657c
	if ctx.cr[6].eq {
	pc = 0x827F657C; continue 'dispatch;
	}
	// 827F6544: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6548: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 827F654C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6550: 41990008  bgt cr6, 0x827f6558
	if ctx.cr[6].gt {
	pc = 0x827F6558; continue 'dispatch;
	}
	// 827F6554: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x827F6558; continue 'dispatch;
            }
            0x827F6558 => {
    //   block [0x827F6558..0x827F657C)
	// 827F6558: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F655C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6560: 409A001C  bne cr6, 0x827f657c
	if !ctx.cr[6].eq {
	pc = 0x827F657C; continue 'dispatch;
	}
	// 827F6564: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F6568: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F656C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F6570: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6574: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6578: 48000018  b 0x827f6590
	pc = 0x827F6590; continue 'dispatch;
            }
            0x827F657C => {
    //   block [0x827F657C..0x827F658C)
	// 827F657C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F6580: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6584: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6588: 48000008  b 0x827f6590
	pc = 0x827F6590; continue 'dispatch;
            }
            0x827F658C => {
    //   block [0x827F658C..0x827F6590)
	// 827F658C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x827F6590; continue 'dispatch;
            }
            0x827F6590 => {
    //   block [0x827F6590..0x827F65C8)
	// 827F6590: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F6594: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6598: 419A0030  beq cr6, 0x827f65c8
	if ctx.cr[6].eq {
	pc = 0x827F65C8; continue 'dispatch;
	}
	// 827F659C: 817F0074  lwz r11, 0x74(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F65A0: 387F0070  addi r3, r31, 0x70
	ctx.r[3].s64 = ctx.r[31].s64 + 112;
	// 827F65A4: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F65A8: 4835E619  bl 0x82b54bc0
	ctx.lr = 0x827F65AC;
	sub_82B54BC0(ctx, base);
	// 827F65AC: 815F0074  lwz r10, 0x74(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F65B0: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827F65B4: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 827F65B8: 813F0074  lwz r9, 0x74(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F65BC: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F65C0: 811F0074  lwz r8, 0x74(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) } as u64;
	// 827F65C4: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x827F65C8; continue 'dispatch;
            }
            0x827F65C8 => {
    //   block [0x827F65C8..0x827F6610)
	// 827F65C8: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F65CC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F65D0: 419A0164  beq cr6, 0x827f6734
	if ctx.cr[6].eq {
	pc = 0x827F6734; continue 'dispatch;
	}
	// 827F65D4: 815E0024  lwz r10, 0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F65D8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 827F65DC: 55496FFE  rlwinm r9, r10, 0xd, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0007FFFFu64;
	// 827F65E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F65E4: 419A00E8  beq cr6, 0x827f66cc
	if ctx.cr[6].eq {
	pc = 0x827F66CC; continue 'dispatch;
	}
	// 827F65E8: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F65EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F65F0: 419A0020  beq cr6, 0x827f6610
	if ctx.cr[6].eq {
	pc = 0x827F6610; continue 'dispatch;
	}
	// 827F65F4: 894B0013  lbz r10, 0x13(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 827F65F8: 817E0048  lwz r11, 0x48(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F65FC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F6600: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F6604: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F6608: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F660C: 480000C4  b 0x827f66d0
	pc = 0x827F66D0; continue 'dispatch;
            }
            0x827F6610 => {
    //   block [0x827F6610..0x827F662C)
	// 827F6610: 815E0048  lwz r10, 0x48(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F6614: 80DE004C  lwz r6, 0x4c(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F6618: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F661C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F6620: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F6624: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6628: 40810054  ble 0x827f667c
	if !ctx.cr[0].gt {
	pc = 0x827F667C; continue 'dispatch;
	}
	pc = 0x827F662C; continue 'dispatch;
            }
            0x827F662C => {
    //   block [0x827F662C..0x827F664C)
	// 827F662C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F6630: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F6634: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F6638: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F663C: 2F070013  cmpwi cr6, r7, 0x13
	ctx.cr[6].compare_i32(ctx.r[7].s32, 19, &mut ctx.xer);
	// 827F6640: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F6644: 41980008  blt cr6, 0x827f664c
	if ctx.cr[6].lt {
	pc = 0x827F664C; continue 'dispatch;
	}
	// 827F6648: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x827F664C; continue 'dispatch;
            }
            0x827F664C => {
    //   block [0x827F664C..0x827F6668)
	// 827F664C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F6650: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F6654: 419A0014  beq cr6, 0x827f6668
	if ctx.cr[6].eq {
	pc = 0x827F6668; continue 'dispatch;
	}
	// 827F6658: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F665C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F6660: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6664: 4800000C  b 0x827f6670
	pc = 0x827F6670; continue 'dispatch;
            }
            0x827F6668 => {
    //   block [0x827F6668..0x827F6670)
	// 827F6668: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F666C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F6670; continue 'dispatch;
            }
            0x827F6670 => {
    //   block [0x827F6670..0x827F667C)
	// 827F6670: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6674: 4199FFB8  bgt cr6, 0x827f662c
	if ctx.cr[6].gt {
	pc = 0x827F662C; continue 'dispatch;
	}
	// 827F6678: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F667C; continue 'dispatch;
            }
            0x827F667C => {
    //   block [0x827F667C..0x827F6698)
	// 827F667C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F6680: 419A003C  beq cr6, 0x827f66bc
	if ctx.cr[6].eq {
	pc = 0x827F66BC; continue 'dispatch;
	}
	// 827F6684: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6688: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 827F668C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6690: 41990008  bgt cr6, 0x827f6698
	if ctx.cr[6].gt {
	pc = 0x827F6698; continue 'dispatch;
	}
	// 827F6694: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x827F6698; continue 'dispatch;
            }
            0x827F6698 => {
    //   block [0x827F6698..0x827F66BC)
	// 827F6698: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F669C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F66A0: 409A001C  bne cr6, 0x827f66bc
	if !ctx.cr[6].eq {
	pc = 0x827F66BC; continue 'dispatch;
	}
	// 827F66A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F66A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F66AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F66B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F66B4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F66B8: 48000018  b 0x827f66d0
	pc = 0x827F66D0; continue 'dispatch;
            }
            0x827F66BC => {
    //   block [0x827F66BC..0x827F66CC)
	// 827F66BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F66C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F66C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F66C8: 48000008  b 0x827f66d0
	pc = 0x827F66D0; continue 'dispatch;
            }
            0x827F66CC => {
    //   block [0x827F66CC..0x827F66D0)
	// 827F66CC: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	pc = 0x827F66D0; continue 'dispatch;
            }
            0x827F66D0 => {
    //   block [0x827F66D0..0x827F66F8)
	// 827F66D0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F66D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F66D8: 419A005C  beq cr6, 0x827f6734
	if ctx.cr[6].eq {
	pc = 0x827F6734; continue 'dispatch;
	}
	// 827F66DC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F66E0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827F66E4: 4BAB793D  bl 0x822ae020
	ctx.lr = 0x827F66E8;
	sub_822AE020(ctx, base);
	// 827F66E8: 807D0000  lwz r3, 0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F66EC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F66F0: 419A0040  beq cr6, 0x827f6730
	if ctx.cr[6].eq {
	pc = 0x827F6730; continue 'dispatch;
	}
	// 827F66F4: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x827F66F8; continue 'dispatch;
            }
            0x827F66F8 => {
    //   block [0x827F66F8..0x827F672C)
	// 827F66F8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F66FC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6700: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F6704: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6708: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F670C: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F6710: 4082FFE8  bne 0x827f66f8
	if !ctx.cr[0].eq {
	pc = 0x827F66F8; continue 'dispatch;
	}
	// 827F6714: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6718: 409A0014  bne cr6, 0x827f672c
	if !ctx.cr[6].eq {
	pc = 0x827F672C; continue 'dispatch;
	}
	// 827F671C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6720: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6724: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F6728: 4E800421  bctrl
	ctx.lr = 0x827F672C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F672C => {
    //   block [0x827F672C..0x827F6730)
	// 827F672C: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x827F6730; continue 'dispatch;
            }
            0x827F6730 => {
    //   block [0x827F6730..0x827F6734)
	// 827F6730: 939D0000  stw r28, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	pc = 0x827F6734; continue 'dispatch;
            }
            0x827F6734 => {
    //   block [0x827F6734..0x827F673C)
	// 827F6734: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 827F6738: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x827F673C; continue 'dispatch;
            }
            0x827F673C => {
    //   block [0x827F673C..0x827F6750)
	// 827F673C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6740: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6744: 409A000C  bne cr6, 0x827f6750
	if !ctx.cr[6].eq {
	pc = 0x827F6750; continue 'dispatch;
	}
	// 827F6748: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 827F674C: 48000010  b 0x827f675c
	pc = 0x827F675C; continue 'dispatch;
            }
            0x827F6750 => {
    //   block [0x827F6750..0x827F675C)
	// 827F6750: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6754: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F6758: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F675C; continue 'dispatch;
            }
            0x827F675C => {
    //   block [0x827F675C..0x827F6784)
	// 827F675C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F6760: 419A004C  beq cr6, 0x827f67ac
	if ctx.cr[6].eq {
	pc = 0x827F67AC; continue 'dispatch;
	}
	// 827F6764: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F676C: 419A0018  beq cr6, 0x827f6784
	if ctx.cr[6].eq {
	pc = 0x827F6784; continue 'dispatch;
	}
	// 827F6770: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6774: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F6778: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F677C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F6780: 41980008  blt cr6, 0x827f6788
	if ctx.cr[6].lt {
	pc = 0x827F6788; continue 'dispatch;
	}
	pc = 0x827F6784; continue 'dispatch;
            }
            0x827F6784 => {
    //   block [0x827F6784..0x827F6788)
	// 827F6784: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F6788; continue 'dispatch;
            }
            0x827F6788 => {
    //   block [0x827F6788..0x827F67AC)
	// 827F6788: 7C7E582E  lwzx r3, r30, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827F678C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6790: C0230020  lfs f1, 0x20(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F6794: 814B001C  lwz r10, 0x1c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6798: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F679C: 4E800421  bctrl
	ctx.lr = 0x827F67A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F67A0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F67A4: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 827F67A8: 4BFFFF94  b 0x827f673c
	pc = 0x827F673C; continue 'dispatch;
            }
            0x827F67AC => {
    //   block [0x827F67AC..0x827F67B4)
	// 827F67AC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F67B0: 484B2CA8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F67B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F67B8 size=1264
    let mut pc: u32 = 0x827F67B8;
    'dispatch: loop {
        match pc {
            0x827F67B8 => {
    //   block [0x827F67B8..0x827F6CA8)
	// 827F67B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F67BC: 484B2C31  bl 0x82ca93ec
	ctx.lr = 0x827F67C0;
	sub_82CA93D0(ctx, base);
	// 827F67C0: DBC1FF90  stfd f30, -0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[30].u64 ) };
	// 827F67C4: DBE1FF98  stfd f31, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.f[31].u64 ) };
	// 827F67C8: 3980FF60  li r12, -0xa0
	ctx.r[12].s64 = -160;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F6CA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F6CA8 size=224
    let mut pc: u32 = 0x827F6CA8;
    'dispatch: loop {
        match pc {
            0x827F6CA8 => {
    //   block [0x827F6CA8..0x827F6D00)
	// 827F6CA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F6CAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F6CB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F6CB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F6CB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F6CBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F6CC0: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 827F6CC4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F6CC8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F6CCC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F6CD0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 827F6CD4: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827F6CD8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827F6CDC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827F6CE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F6CE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F6CE8: 480006E1  bl 0x827f73c8
	ctx.lr = 0x827F6CEC;
	sub_827F73C8(ctx, base);
	// 827F6CEC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F6CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6CF4: 419A000C  beq cr6, 0x827f6d00
	if ctx.cr[6].eq {
	pc = 0x827F6D00; continue 'dispatch;
	}
	// 827F6CF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F6CFC: 48000040  b 0x827f6d3c
	pc = 0x827F6D3C; continue 'dispatch;
            }
            0x827F6D00 => {
    //   block [0x827F6D00..0x827F6D38)
	// 827F6D00: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6D04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6D08: 419A0058  beq cr6, 0x827f6d60
	if ctx.cr[6].eq {
	pc = 0x827F6D60; continue 'dispatch;
	}
	// 827F6D0C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6D10: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F6D14: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6D18: 41820048  beq 0x827f6d60
	if ctx.cr[0].eq {
	pc = 0x827F6D60; continue 'dispatch;
	}
	// 827F6D1C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6D20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F6D24: 419A0014  beq cr6, 0x827f6d38
	if ctx.cr[6].eq {
	pc = 0x827F6D38; continue 'dispatch;
	}
	// 827F6D28: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F6D2C: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 827F6D30: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6D34: 40820008  bne 0x827f6d3c
	if !ctx.cr[0].eq {
	pc = 0x827F6D3C; continue 'dispatch;
	}
	pc = 0x827F6D38; continue 'dispatch;
            }
            0x827F6D38 => {
    //   block [0x827F6D38..0x827F6D3C)
	// 827F6D38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F6D3C; continue 'dispatch;
            }
            0x827F6D3C => {
    //   block [0x827F6D3C..0x827F6D60)
	// 827F6D3C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F6D40: 4B984659  bl 0x8217b398
	ctx.lr = 0x827F6D44;
	sub_8217B398(ctx, base);
	// 827F6D44: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6D48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F6D4C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6D50: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F6D54: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6D58: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827F6D5C: 4E800421  bctrl
	ctx.lr = 0x827F6D60;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F6D60 => {
    //   block [0x827F6D60..0x827F6D88)
	// 827F6D60: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F6D64: 4B9C0DB5  bl 0x821b7b18
	ctx.lr = 0x827F6D68;
	sub_821B7B18(ctx, base);
	// 827F6D68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F6D6C: 4B9C0DAD  bl 0x821b7b18
	ctx.lr = 0x827F6D70;
	sub_821B7B18(ctx, base);
	// 827F6D70: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F6D74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F6D78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F6D7C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F6D80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F6D84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F6D88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F6D88 size=136
    let mut pc: u32 = 0x827F6D88;
    'dispatch: loop {
        match pc {
            0x827F6D88 => {
    //   block [0x827F6D88..0x827F6DD4)
	// 827F6D88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F6D8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F6D90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F6D94: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F6D98: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6D9C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F6DA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6DA4: 419A0058  beq cr6, 0x827f6dfc
	if ctx.cr[6].eq {
	pc = 0x827F6DFC; continue 'dispatch;
	}
	// 827F6DA8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6DAC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F6DB0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6DB4: 41820048  beq 0x827f6dfc
	if ctx.cr[0].eq {
	pc = 0x827F6DFC; continue 'dispatch;
	}
	// 827F6DB8: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6DBC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F6DC0: 419A0014  beq cr6, 0x827f6dd4
	if ctx.cr[6].eq {
	pc = 0x827F6DD4; continue 'dispatch;
	}
	// 827F6DC4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F6DC8: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 827F6DCC: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6DD0: 40820008  bne 0x827f6dd8
	if !ctx.cr[0].eq {
	pc = 0x827F6DD8; continue 'dispatch;
	}
	pc = 0x827F6DD4; continue 'dispatch;
            }
            0x827F6DD4 => {
    //   block [0x827F6DD4..0x827F6DD8)
	// 827F6DD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F6DD8; continue 'dispatch;
            }
            0x827F6DD8 => {
    //   block [0x827F6DD8..0x827F6DFC)
	// 827F6DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F6DDC: 4B9845BD  bl 0x8217b398
	ctx.lr = 0x827F6DE0;
	sub_8217B398(ctx, base);
	// 827F6DE0: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6DE4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F6DE8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6DEC: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F6DF0: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6DF4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827F6DF8: 4E800421  bctrl
	ctx.lr = 0x827F6DFC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F6DFC => {
    //   block [0x827F6DFC..0x827F6E10)
	// 827F6DFC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F6E00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F6E04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F6E08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F6E0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F6E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F6E10 size=160
    let mut pc: u32 = 0x827F6E10;
    'dispatch: loop {
        match pc {
            0x827F6E10 => {
    //   block [0x827F6E10..0x827F6E58)
	// 827F6E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F6E14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F6E18: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F6E1C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F6E20: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6E24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F6E28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6E2C: 419A0070  beq cr6, 0x827f6e9c
	if ctx.cr[6].eq {
	pc = 0x827F6E9C; continue 'dispatch;
	}
	// 827F6E30: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6E34: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F6E38: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6E3C: 41820060  beq 0x827f6e9c
	if ctx.cr[0].eq {
	pc = 0x827F6E9C; continue 'dispatch;
	}
	// 827F6E40: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6E44: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F6E48: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 827F6E4C: 409A000C  bne cr6, 0x827f6e58
	if !ctx.cr[6].eq {
	pc = 0x827F6E58; continue 'dispatch;
	}
	// 827F6E50: 4BFFF969  bl 0x827f67b8
	ctx.lr = 0x827F6E54;
	sub_827F67B8(ctx, base);
	// 827F6E54: 4800002C  b 0x827f6e80
	pc = 0x827F6E80; continue 'dispatch;
            }
            0x827F6E58 => {
    //   block [0x827F6E58..0x827F6E74)
	// 827F6E58: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F6E5C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827F6E60: 419A0014  beq cr6, 0x827f6e74
	if ctx.cr[6].eq {
	pc = 0x827F6E74; continue 'dispatch;
	}
	// 827F6E64: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F6E68: 7D445850  subf r10, r4, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[4].s64;
	// 827F6E6C: 7D4B1E71  srawi. r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6E70: 40820008  bne 0x827f6e78
	if !ctx.cr[0].eq {
	pc = 0x827F6E78; continue 'dispatch;
	}
	pc = 0x827F6E74; continue 'dispatch;
            }
            0x827F6E74 => {
    //   block [0x827F6E74..0x827F6E78)
	// 827F6E74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F6E78; continue 'dispatch;
            }
            0x827F6E78 => {
    //   block [0x827F6E78..0x827F6E80)
	// 827F6E78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F6E7C: 4B98451D  bl 0x8217b398
	ctx.lr = 0x827F6E80;
	sub_8217B398(ctx, base);
	pc = 0x827F6E80; continue 'dispatch;
            }
            0x827F6E80 => {
    //   block [0x827F6E80..0x827F6E9C)
	// 827F6E80: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6E84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F6E88: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6E8C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F6E90: 812A001C  lwz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F6E94: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827F6E98: 4E800421  bctrl
	ctx.lr = 0x827F6E9C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F6E9C => {
    //   block [0x827F6E9C..0x827F6EB0)
	// 827F6E9C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F6EA0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F6EA4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F6EA8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F6EAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F6EB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F6EB0 size=1304
    let mut pc: u32 = 0x827F6EB0;
    'dispatch: loop {
        match pc {
            0x827F6EB0 => {
    //   block [0x827F6EB0..0x827F6F08)
	// 827F6EB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F6EB4: 484B253D  bl 0x82ca93f0
	ctx.lr = 0x827F6EB8;
	sub_82CA93D0(ctx, base);
	// 827F6EB8: DBE1FFA0  stfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[31].u64 ) };
	// 827F6EBC: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F6EC0: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 827F6EC4: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 827F6EC8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 827F6ECC: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 827F6ED0: 7CB92B78  mr r25, r5
	ctx.r[25].u64 = ctx.r[5].u64;
	// 827F6ED4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F6ED8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F6EDC: 419A00E8  beq cr6, 0x827f6fc4
	if ctx.cr[6].eq {
	pc = 0x827F6FC4; continue 'dispatch;
	}
	// 827F6EE0: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F6EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6EE8: 419A0020  beq cr6, 0x827f6f08
	if ctx.cr[6].eq {
	pc = 0x827F6F08; continue 'dispatch;
	}
	// 827F6EEC: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 827F6EF0: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F6EF4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F6EF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F6EFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6F00: 80690004  lwz r3, 4(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6F04: 480000C4  b 0x827f6fc8
	pc = 0x827F6FC8; continue 'dispatch;
            }
            0x827F6F08 => {
    //   block [0x827F6F08..0x827F6F24)
	// 827F6F08: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F6F0C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F6F10: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 827F6F14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F6F18: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 827F6F1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6F20: 40810054  ble 0x827f6f74
	if !ctx.cr[0].gt {
	pc = 0x827F6F74; continue 'dispatch;
	}
	pc = 0x827F6F24; continue 'dispatch;
            }
            0x827F6F24 => {
    //   block [0x827F6F24..0x827F6F44)
	// 827F6F24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F6F28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F6F2C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F6F30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6F34: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 827F6F38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F6F3C: 41980008  blt cr6, 0x827f6f44
	if ctx.cr[6].lt {
	pc = 0x827F6F44; continue 'dispatch;
	}
	// 827F6F40: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	pc = 0x827F6F44; continue 'dispatch;
            }
            0x827F6F44 => {
    //   block [0x827F6F44..0x827F6F60)
	// 827F6F44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F6F48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F6F4C: 419A0014  beq cr6, 0x827f6f60
	if ctx.cr[6].eq {
	pc = 0x827F6F60; continue 'dispatch;
	}
	// 827F6F50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F6F54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F6F58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F6F5C: 4800000C  b 0x827f6f68
	pc = 0x827F6F68; continue 'dispatch;
            }
            0x827F6F60 => {
    //   block [0x827F6F60..0x827F6F68)
	// 827F6F60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F6F64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F6F68; continue 'dispatch;
            }
            0x827F6F68 => {
    //   block [0x827F6F68..0x827F6F74)
	// 827F6F68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F6F6C: 4199FFB8  bgt cr6, 0x827f6f24
	if ctx.cr[6].gt {
	pc = 0x827F6F24; continue 'dispatch;
	}
	// 827F6F70: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x827F6F74; continue 'dispatch;
            }
            0x827F6F74 => {
    //   block [0x827F6F74..0x827F6F90)
	// 827F6F74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F6F78: 419A003C  beq cr6, 0x827f6fb4
	if ctx.cr[6].eq {
	pc = 0x827F6FB4; continue 'dispatch;
	}
	// 827F6F7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F6F80: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 827F6F84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6F88: 41990008  bgt cr6, 0x827f6f90
	if ctx.cr[6].gt {
	pc = 0x827F6F90; continue 'dispatch;
	}
	// 827F6F8C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x827F6F90; continue 'dispatch;
            }
            0x827F6F90 => {
    //   block [0x827F6F90..0x827F6FB4)
	// 827F6F90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F6F94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6F98: 409A001C  bne cr6, 0x827f6fb4
	if !ctx.cr[6].eq {
	pc = 0x827F6FB4; continue 'dispatch;
	}
	// 827F6F9C: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827F6FA0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827F6FA4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827F6FA8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6FAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6FB0: 48000018  b 0x827f6fc8
	pc = 0x827F6FC8; continue 'dispatch;
            }
            0x827F6FB4 => {
    //   block [0x827F6FB4..0x827F6FC4)
	// 827F6FB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F6FB8: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F6FBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F6FC0: 48000008  b 0x827f6fc8
	pc = 0x827F6FC8; continue 'dispatch;
            }
            0x827F6FC4 => {
    //   block [0x827F6FC4..0x827F6FC8)
	// 827F6FC4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x827F6FC8; continue 'dispatch;
            }
            0x827F6FC8 => {
    //   block [0x827F6FC8..0x827F70A4)
	// 827F6FC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F6FCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F6FD0: 419A03EC  beq cr6, 0x827f73bc
	if ctx.cr[6].eq {
	pc = 0x827F73BC; continue 'dispatch;
	}
	// 827F6FD4: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 827F6FD8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 827F6FDC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 827F6FE0: 93010060  stw r24, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u32 ) };
	// 827F6FE4: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 827F6FE8: 93010064  stw r24, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u32 ) };
	// 827F6FEC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F6FF0: 4BA8CD41  bl 0x82283d30
	ctx.lr = 0x827F6FF4;
	sub_82283D30(ctx, base);
	// 827F6FF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F6FF8: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F6FFC: 4BA7C05D  bl 0x82273058
	ctx.lr = 0x827F7000;
	sub_82273058(ctx, base);
	// 827F7000: 83410060  lwz r26, 0x60(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827F7004: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827F7008: 419A03AC  beq cr6, 0x827f73b4
	if ctx.cr[6].eq {
	pc = 0x827F73B4; continue 'dispatch;
	}
	// 827F700C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F7010: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F7014: 388BA374  addi r4, r11, -0x5c8c
	ctx.r[4].s64 = ctx.r[11].s64 + -23692;
	// 827F7018: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F701C: 4BA35EB5  bl 0x8222ced0
	ctx.lr = 0x827F7020;
	sub_8222CED0(ctx, base);
	// 827F7020: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F7024: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F7028: 4BA76599  bl 0x8226d5c0
	ctx.lr = 0x827F702C;
	sub_8226D5C0(ctx, base);
	// 827F702C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F7030: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 827F7034: 4BA1DDA5  bl 0x82214dd8
	ctx.lr = 0x827F7038;
	sub_82214DD8(ctx, base);
	// 827F7038: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F703C: C00A0A64  lfs f0, 0xa64(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(2660 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F7040: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827F7044: 40990060  ble cr6, 0x827f70a4
	if !ctx.cr[6].gt {
	pc = 0x827F70A4; continue 'dispatch;
	}
	// 827F7048: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F704C: C03A0028  lfs f1, 0x28(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 827F7050: 4BADC5F9  bl 0x822d3648
	ctx.lr = 0x827F7054;
	sub_822D3648(ctx, base);
	// 827F7054: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F7058: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 827F705C: 392A0E68  addi r9, r10, 0xe68
	ctx.r[9].s64 = ctx.r[10].s64 + 3688;
	// 827F7060: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F7064: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 827F7068: 7D000026  mfcr r8
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[8].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[8].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 827F706C: 5507DF7A  rlwinm r7, r8, 0x1b, 0x1d, 0x1d
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	// 827F7070: 5506F77A  rlwinm r6, r8, 0x1e, 0x1d, 0x1d
	ctx.r[6].u64 = ctx.r[8].u32 as u64 & 0x00000003u64;
	// 827F7074: 7CE53378  or r5, r7, r6
	ctx.r[5].u64 = ctx.r[7].u64 | ctx.r[6].u64;
	// 827F7078: 7DA92C2E  lfsx f13, r9, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827F707C: FD8D07EE  fsel f12, f13, f31, f0
	ctx.f[12].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 827F7080: ED6C0828  fsubs f11, f12, f1
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[1].f64) as f32) as f64);
	// 827F7084: FF0B0000  fcmpu cr6, f11, f0
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[0].f64);
	// 827F7088: 7C800026  mfcr r4
	// MFCR packs CR[0..7] (lt,gt,eq,so per field) into GPR
	ctx.r[4].u64 = if ctx.cr[0].lt { 0x80000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].gt { 0x40000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].eq { 0x20000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[0].so { 0x10000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].lt { 0x8000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].gt { 0x4000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].eq { 0x2000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[1].so { 0x1000000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].lt { 0x800000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].gt { 0x400000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].eq { 0x200000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[2].so { 0x100000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].lt { 0x80000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].gt { 0x40000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].eq { 0x20000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[3].so { 0x10000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].lt { 0x8000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].gt { 0x4000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].eq { 0x2000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[4].so { 0x1000 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].lt { 0x800 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].gt { 0x400 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].eq { 0x200 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[5].so { 0x100 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].lt { 0x80 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].gt { 0x40 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].eq { 0x20 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[6].so { 0x10 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].lt { 0x8 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].gt { 0x4 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].eq { 0x2 } else { 0 };
	ctx.r[4].u64 |= if ctx.cr[7].so { 0x1 } else { 0 };
	// 827F708C: 5483DF7A  rlwinm r3, r4, 0x1b, 0x1d, 0x1d
	ctx.r[3].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 827F7090: 548BF77A  rlwinm r11, r4, 0x1e, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000003u64;
	// 827F7094: 7C6A5B78  or r10, r3, r11
	ctx.r[10].u64 = ctx.r[3].u64 | ctx.r[11].u64;
	// 827F7098: 7D49542E  lfsx f10, r9, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 827F709C: FD2A606E  fsel f9, f10, f1, f12
	ctx.f[9].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[1].f64 } else { ctx.f[12].f64 };
	// 827F70A0: D13A0028  stfs f9, 0x28(r26)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x827F70A4; continue 'dispatch;
            }
            0x827F70A4 => {
    //   block [0x827F70A4..0x827F70D8)
	// 827F70A4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F70A8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F70AC: 388BA380  addi r4, r11, -0x5c80
	ctx.r[4].s64 = ctx.r[11].s64 + -23680;
	// 827F70B0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F70B4: 4BA35E1D  bl 0x8222ced0
	ctx.lr = 0x827F70B8;
	sub_8222CED0(ctx, base);
	// 827F70B8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827F70BC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 827F70C0: 3BCBFFDF  addi r30, r11, -0x21
	ctx.r[30].s64 = ctx.r[11].s64 + -33;
	// 827F70C4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827F70C8: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F70CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F70D0: 419A0008  beq cr6, 0x827f70d8
	if ctx.cr[6].eq {
	pc = 0x827F70D8; continue 'dispatch;
	}
	// 827F70D4: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F70D8; continue 'dispatch;
            }
            0x827F70D8 => {
    //   block [0x827F70D8..0x827F70EC)
	// 827F70D8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F70DC: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 827F70E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F70E4: 419A0008  beq cr6, 0x827f70ec
	if ctx.cr[6].eq {
	pc = 0x827F70EC; continue 'dispatch;
	}
	// 827F70E8: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F70EC; continue 'dispatch;
            }
            0x827F70EC => {
    //   block [0x827F70EC..0x827F70F0)
	// 827F70EC: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827F70F0; continue 'dispatch;
            }
            0x827F70F0 => {
    //   block [0x827F70F0..0x827F7114)
	// 827F70F0: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F70F4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F70F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F70FC: 409AFFF4  bne cr6, 0x827f70f0
	if !ctx.cr[6].eq {
	pc = 0x827F70F0; continue 'dispatch;
	}
	// 827F7100: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F7104: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F7108: 557C003E  slwi r28, r11, 0
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 827F710C: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827F7110: 409A000C  bne cr6, 0x827f711c
	if !ctx.cr[6].eq {
	pc = 0x827F711C; continue 'dispatch;
	}
	pc = 0x827F7114; continue 'dispatch;
            }
            0x827F7114 => {
    //   block [0x827F7114..0x827F711C)
	// 827F7114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F7118: 48000060  b 0x827f7178
	pc = 0x827F7178; continue 'dispatch;
            }
            0x827F711C => {
    //   block [0x827F711C..0x827F7128)
	// 827F711C: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7120: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7124: 419A0050  beq cr6, 0x827f7174
	if ctx.cr[6].eq {
	pc = 0x827F7174; continue 'dispatch;
	}
	pc = 0x827F7128; continue 'dispatch;
            }
            0x827F7128 => {
    //   block [0x827F7128..0x827F7164)
	// 827F7128: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F712C: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 827F7130: 4B9F7B19  bl 0x821eec48
	ctx.lr = 0x827F7134;
	sub_821EEC48(ctx, base);
	// 827F7134: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7138: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827F713C: 7D430774  extsb r3, r10
	ctx.r[3].s64 = ctx.r[10].s8 as i64;
	// 827F7140: 4B9F7B09  bl 0x821eec48
	ctx.lr = 0x827F7144;
	sub_821EEC48(ctx, base);
	// 827F7144: 7F161800  cmpw cr6, r22, r3
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[3].s32, &mut ctx.xer);
	// 827F7148: 409A001C  bne cr6, 0x827f7164
	if !ctx.cr[6].eq {
	pc = 0x827F7164; continue 'dispatch;
	}
	// 827F714C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F7150: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F7154: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7158: 484BAB31  bl 0x82cb1c88
	ctx.lr = 0x827F715C;
	sub_82CB1C88(ctx, base);
	// 827F715C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 827F7160: 419AFFB4  beq cr6, 0x827f7114
	if ctx.cr[6].eq {
	pc = 0x827F7114; continue 'dispatch;
	}
	pc = 0x827F7164; continue 'dispatch;
            }
            0x827F7164 => {
    //   block [0x827F7164..0x827F7174)
	// 827F7164: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F7168: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F716C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7170: 409AFFB8  bne cr6, 0x827f7128
	if !ctx.cr[6].eq {
	pc = 0x827F7128; continue 'dispatch;
	}
	pc = 0x827F7174; continue 'dispatch;
            }
            0x827F7174 => {
    //   block [0x827F7174..0x827F7178)
	// 827F7174: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x827F7178; continue 'dispatch;
            }
            0x827F7178 => {
    //   block [0x827F7178..0x827F71B0)
	// 827F7178: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F717C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7180: 409A01B4  bne cr6, 0x827f7334
	if !ctx.cr[6].eq {
	pc = 0x827F7334; continue 'dispatch;
	}
	// 827F7184: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F7188: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F718C: 388BA388  addi r4, r11, -0x5c78
	ctx.r[4].s64 = ctx.r[11].s64 + -23672;
	// 827F7190: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F7194: 4BA35D3D  bl 0x8222ced0
	ctx.lr = 0x827F7198;
	sub_8222CED0(ctx, base);
	// 827F7198: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F719C: 3B600003  li r27, 3
	ctx.r[27].s64 = 3;
	// 827F71A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F71A4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827F71A8: 419A0008  beq cr6, 0x827f71b0
	if ctx.cr[6].eq {
	pc = 0x827F71B0; continue 'dispatch;
	}
	// 827F71AC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F71B0; continue 'dispatch;
            }
            0x827F71B0 => {
    //   block [0x827F71B0..0x827F71C4)
	// 827F71B0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F71B4: 7FDDF378  mr r29, r30
	ctx.r[29].u64 = ctx.r[30].u64;
	// 827F71B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F71BC: 419A0008  beq cr6, 0x827f71c4
	if ctx.cr[6].eq {
	pc = 0x827F71C4; continue 'dispatch;
	}
	// 827F71C0: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F71C4; continue 'dispatch;
            }
            0x827F71C4 => {
    //   block [0x827F71C4..0x827F71C8)
	// 827F71C4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827F71C8; continue 'dispatch;
            }
            0x827F71C8 => {
    //   block [0x827F71C8..0x827F71EC)
	// 827F71C8: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F71CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F71D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F71D4: 409AFFF4  bne cr6, 0x827f71c8
	if !ctx.cr[6].eq {
	pc = 0x827F71C8; continue 'dispatch;
	}
	// 827F71D8: 7D7D5850  subf r11, r29, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 827F71DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F71E0: 557C003E  slwi r28, r11, 0
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 827F71E4: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827F71E8: 409A000C  bne cr6, 0x827f71f4
	if !ctx.cr[6].eq {
	pc = 0x827F71F4; continue 'dispatch;
	}
	pc = 0x827F71EC; continue 'dispatch;
            }
            0x827F71EC => {
    //   block [0x827F71EC..0x827F71F4)
	// 827F71EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F71F0: 48000060  b 0x827f7250
	pc = 0x827F7250; continue 'dispatch;
            }
            0x827F71F4 => {
    //   block [0x827F71F4..0x827F7200)
	// 827F71F4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F71F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F71FC: 419A0050  beq cr6, 0x827f724c
	if ctx.cr[6].eq {
	pc = 0x827F724C; continue 'dispatch;
	}
	pc = 0x827F7200; continue 'dispatch;
            }
            0x827F7200 => {
    //   block [0x827F7200..0x827F723C)
	// 827F7200: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7204: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 827F7208: 4B9F7A41  bl 0x821eec48
	ctx.lr = 0x827F720C;
	sub_821EEC48(ctx, base);
	// 827F720C: 895D0000  lbz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7210: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827F7214: 7D430774  extsb r3, r10
	ctx.r[3].s64 = ctx.r[10].s8 as i64;
	// 827F7218: 4B9F7A31  bl 0x821eec48
	ctx.lr = 0x827F721C;
	sub_821EEC48(ctx, base);
	// 827F721C: 7F161800  cmpw cr6, r22, r3
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[3].s32, &mut ctx.xer);
	// 827F7220: 409A001C  bne cr6, 0x827f723c
	if !ctx.cr[6].eq {
	pc = 0x827F723C; continue 'dispatch;
	}
	// 827F7224: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 827F7228: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F722C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7230: 484BAA59  bl 0x82cb1c88
	ctx.lr = 0x827F7234;
	sub_82CB1C88(ctx, base);
	// 827F7234: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 827F7238: 419AFFB4  beq cr6, 0x827f71ec
	if ctx.cr[6].eq {
	pc = 0x827F71EC; continue 'dispatch;
	}
	pc = 0x827F723C; continue 'dispatch;
            }
            0x827F723C => {
    //   block [0x827F723C..0x827F724C)
	// 827F723C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F7240: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7244: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7248: 409AFFB8  bne cr6, 0x827f7200
	if !ctx.cr[6].eq {
	pc = 0x827F7200; continue 'dispatch;
	}
	pc = 0x827F724C; continue 'dispatch;
            }
            0x827F724C => {
    //   block [0x827F724C..0x827F7250)
	// 827F724C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x827F7250; continue 'dispatch;
            }
            0x827F7250 => {
    //   block [0x827F7250..0x827F7288)
	// 827F7250: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F7254: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7258: 409A00DC  bne cr6, 0x827f7334
	if !ctx.cr[6].eq {
	pc = 0x827F7334; continue 'dispatch;
	}
	// 827F725C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F7260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F7264: 388BA390  addi r4, r11, -0x5c70
	ctx.r[4].s64 = ctx.r[11].s64 + -23664;
	// 827F7268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F726C: 4BA35C65  bl 0x8222ced0
	ctx.lr = 0x827F7270;
	sub_8222CED0(ctx, base);
	// 827F7270: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7274: 3B600007  li r27, 7
	ctx.r[27].s64 = 7;
	// 827F7278: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F727C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827F7280: 419A0008  beq cr6, 0x827f7288
	if ctx.cr[6].eq {
	pc = 0x827F7288; continue 'dispatch;
	}
	// 827F7284: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F7288; continue 'dispatch;
            }
            0x827F7288 => {
    //   block [0x827F7288..0x827F7298)
	// 827F7288: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F728C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7290: 419A0008  beq cr6, 0x827f7298
	if ctx.cr[6].eq {
	pc = 0x827F7298; continue 'dispatch;
	}
	// 827F7294: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F7298; continue 'dispatch;
            }
            0x827F7298 => {
    //   block [0x827F7298..0x827F729C)
	// 827F7298: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x827F729C; continue 'dispatch;
            }
            0x827F729C => {
    //   block [0x827F729C..0x827F72C0)
	// 827F729C: 894B0000  lbz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F72A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F72A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F72A8: 409AFFF4  bne cr6, 0x827f729c
	if !ctx.cr[6].eq {
	pc = 0x827F729C; continue 'dispatch;
	}
	// 827F72AC: 7D7E5850  subf r11, r30, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 827F72B0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F72B4: 557D003E  slwi r29, r11, 0
	ctx.r[29].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 827F72B8: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 827F72BC: 409A000C  bne cr6, 0x827f72c8
	if !ctx.cr[6].eq {
	pc = 0x827F72C8; continue 'dispatch;
	}
	pc = 0x827F72C0; continue 'dispatch;
            }
            0x827F72C0 => {
    //   block [0x827F72C0..0x827F72C8)
	// 827F72C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F72C4: 48000060  b 0x827f7324
	pc = 0x827F7324; continue 'dispatch;
            }
            0x827F72C8 => {
    //   block [0x827F72C8..0x827F72D4)
	// 827F72C8: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F72CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F72D0: 419A0050  beq cr6, 0x827f7320
	if ctx.cr[6].eq {
	pc = 0x827F7320; continue 'dispatch;
	}
	pc = 0x827F72D4; continue 'dispatch;
            }
            0x827F72D4 => {
    //   block [0x827F72D4..0x827F7310)
	// 827F72D4: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F72D8: 7D630774  extsb r3, r11
	ctx.r[3].s64 = ctx.r[11].s8 as i64;
	// 827F72DC: 4B9F796D  bl 0x821eec48
	ctx.lr = 0x827F72E0;
	sub_821EEC48(ctx, base);
	// 827F72E0: 895E0000  lbz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F72E4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827F72E8: 7D430774  extsb r3, r10
	ctx.r[3].s64 = ctx.r[10].s8 as i64;
	// 827F72EC: 4B9F795D  bl 0x821eec48
	ctx.lr = 0x827F72F0;
	sub_821EEC48(ctx, base);
	// 827F72F0: 7F1C1800  cmpw cr6, r28, r3
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[3].s32, &mut ctx.xer);
	// 827F72F4: 409A001C  bne cr6, 0x827f7310
	if !ctx.cr[6].eq {
	pc = 0x827F7310; continue 'dispatch;
	}
	// 827F72F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F72FC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F7300: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7304: 484BA985  bl 0x82cb1c88
	ctx.lr = 0x827F7308;
	sub_82CB1C88(ctx, base);
	// 827F7308: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 827F730C: 419AFFB4  beq cr6, 0x827f72c0
	if ctx.cr[6].eq {
	pc = 0x827F72C0; continue 'dispatch;
	}
	pc = 0x827F7310; continue 'dispatch;
            }
            0x827F7310 => {
    //   block [0x827F7310..0x827F7320)
	// 827F7310: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827F7314: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F731C: 409AFFB8  bne cr6, 0x827f72d4
	if !ctx.cr[6].eq {
	pc = 0x827F72D4; continue 'dispatch;
	}
	pc = 0x827F7320; continue 'dispatch;
            }
            0x827F7320 => {
    //   block [0x827F7320..0x827F7324)
	// 827F7320: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x827F7324; continue 'dispatch;
            }
            0x827F7324 => {
    //   block [0x827F7324..0x827F7334)
	// 827F7324: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F7328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F732C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 827F7330: 419A0008  beq cr6, 0x827f7338
	if ctx.cr[6].eq {
	pc = 0x827F7338; continue 'dispatch;
	}
	pc = 0x827F7334; continue 'dispatch;
            }
            0x827F7334 => {
    //   block [0x827F7334..0x827F7338)
	// 827F7334: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x827F7338; continue 'dispatch;
            }
            0x827F7338 => {
    //   block [0x827F7338..0x827F7354)
	// 827F7338: 576A077A  rlwinm r10, r27, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 827F733C: 557F063E  clrlwi r31, r11, 0x18
	ctx.r[31].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F7340: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F7344: 419A0010  beq cr6, 0x827f7354
	if ctx.cr[6].eq {
	pc = 0x827F7354; continue 'dispatch;
	}
	// 827F7348: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F734C: 577B07B8  rlwinm r27, r27, 0, 0x1e, 0x1c
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 827F7350: 4BA1DA89  bl 0x82214dd8
	ctx.lr = 0x827F7354;
	sub_82214DD8(ctx, base);
	pc = 0x827F7354; continue 'dispatch;
            }
            0x827F7354 => {
    //   block [0x827F7354..0x827F736C)
	// 827F7354: 576B07BC  rlwinm r11, r27, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 827F7358: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F735C: 419A0010  beq cr6, 0x827f736c
	if ctx.cr[6].eq {
	pc = 0x827F736C; continue 'dispatch;
	}
	// 827F7360: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827F7364: 577B07FA  rlwinm r27, r27, 0, 0x1f, 0x1d
	ctx.r[27].u64 = ctx.r[27].u32 as u64 & 0xFFFFFFFFu64;
	// 827F7368: 4BA1DA71  bl 0x82214dd8
	ctx.lr = 0x827F736C;
	sub_82214DD8(ctx, base);
	pc = 0x827F736C; continue 'dispatch;
            }
            0x827F736C => {
    //   block [0x827F736C..0x827F7380)
	// 827F736C: 576B07FE  clrlwi r11, r27, 0x1f
	ctx.r[11].u64 = ctx.r[27].u32 as u64 & 0x00000001u64;
	// 827F7370: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F7374: 419A000C  beq cr6, 0x827f7380
	if ctx.cr[6].eq {
	pc = 0x827F7380; continue 'dispatch;
	}
	// 827F7378: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F737C: 4BA1DA5D  bl 0x82214dd8
	ctx.lr = 0x827F7380;
	sub_82214DD8(ctx, base);
	pc = 0x827F7380; continue 'dispatch;
            }
            0x827F7380 => {
    //   block [0x827F7380..0x827F73A0)
	// 827F7380: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 827F7384: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F7388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F738C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7390: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827F7394: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F7398: 409A0008  bne cr6, 0x827f73a0
	if !ctx.cr[6].eq {
	pc = 0x827F73A0; continue 'dispatch;
	}
	// 827F739C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	pc = 0x827F73A0; continue 'dispatch;
            }
            0x827F73A0 => {
    //   block [0x827F73A0..0x827F73B4)
	// 827F73A0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F73A4: 4E800421  bctrl
	ctx.lr = 0x827F73A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827F73A8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827F73AC: 38770004  addi r3, r23, 4
	ctx.r[3].s64 = ctx.r[23].s64 + 4;
	// 827F73B0: 4BAFE599  bl 0x822f5948
	ctx.lr = 0x827F73B4;
	sub_822F5948(ctx, base);
            }
            0x827F73B4 => {
    //   block [0x827F73B4..0x827F73BC)
	// 827F73B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F73B8: 4B9C0761  bl 0x821b7b18
	ctx.lr = 0x827F73BC;
	sub_821B7B18(ctx, base);
	pc = 0x827F73BC; continue 'dispatch;
            }
            0x827F73BC => {
    //   block [0x827F73BC..0x827F73C8)
	// 827F73BC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827F73C0: CBE1FFA0  lfd f31, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 827F73C4: 484B207C  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F73C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827F73C8 size=1080
    let mut pc: u32 = 0x827F73C8;
    'dispatch: loop {
        match pc {
            0x827F73C8 => {
    //   block [0x827F73C8..0x827F7800)
	// 827F73C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F73CC: 484B201D  bl 0x82ca93e8
	ctx.lr = 0x827F73D0;
	sub_82CA93D0(ctx, base);
	// 827F73D0: 3981FF98  addi r12, r1, -0x68
	ctx.r[12].s64 = ctx.r[1].s64 + -104;
	// 827F73D4: 484B68F1  bl 0x82cadcc4
	ctx.lr = 0x827F73D8;
	sub_82CADCA0(ctx, base);
	// 827F73D8: 3980FF40  li r12, -0xc0
	ctx.r[12].s64 = -192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F7800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F7800 size=332
    let mut pc: u32 = 0x827F7800;
    'dispatch: loop {
        match pc {
            0x827F7800 => {
    //   block [0x827F7800..0x827F7878)
	// 827F7800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F7804: 484B1BF1  bl 0x82ca93f4
	ctx.lr = 0x827F7808;
	sub_82CA93D0(ctx, base);
	// 827F7808: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 827F780C: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F7810: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827F7814: 7CD73378  mr r23, r6
	ctx.r[23].u64 = ctx.r[6].u64;
	// 827F7818: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 827F781C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F7820: 93810068  stw r28, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[28].u32 ) };
	// 827F7824: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827F7828: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 827F782C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F7830: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827F7834: E9770008  ld r11, 8(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[23].u32.wrapping_add(8 as u32) ) };
	// 827F7838: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 827F783C: 7D184378  mr r24, r8
	ctx.r[24].u64 = ctx.r[8].u64;
	// 827F7840: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827F7844: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 827F7848: 4BFFB109  bl 0x827f2950
	ctx.lr = 0x827F784C;
	sub_827F2950(ctx, base);
	// 827F784C: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 827F7850: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F7854: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827F7858: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 827F785C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 827F7860: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F7864: F9410078  std r10, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 827F7868: 48001701  bl 0x827f8f68
	ctx.lr = 0x827F786C;
	sub_827F8F68(ctx, base);
	// 827F786C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 827F7870: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 827F7874: C3F70018  lfs f31, 0x18(r23)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(24 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x827F7878; continue 'dispatch;
            }
            0x827F7878 => {
    //   block [0x827F7878..0x827F788C)
	// 827F7878: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F787C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7880: 409A000C  bne cr6, 0x827f788c
	if !ctx.cr[6].eq {
	pc = 0x827F788C; continue 'dispatch;
	}
	// 827F7884: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 827F7888: 48000010  b 0x827f7898
	pc = 0x827F7898; continue 'dispatch;
            }
            0x827F788C => {
    //   block [0x827F788C..0x827F7898)
	// 827F788C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F7890: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F7894: 7D2B1E70  srawi r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F7898; continue 'dispatch;
            }
            0x827F7898 => {
    //   block [0x827F7898..0x827F78C0)
	// 827F7898: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F789C: 419A0084  beq cr6, 0x827f7920
	if ctx.cr[6].eq {
	pc = 0x827F7920; continue 'dispatch;
	}
	// 827F78A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F78A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F78A8: 419A0018  beq cr6, 0x827f78c0
	if ctx.cr[6].eq {
	pc = 0x827F78C0; continue 'dispatch;
	}
	// 827F78AC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F78B0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F78B4: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F78B8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F78BC: 41980008  blt cr6, 0x827f78c4
	if ctx.cr[6].lt {
	pc = 0x827F78C4; continue 'dispatch;
	}
	pc = 0x827F78C0; continue 'dispatch;
            }
            0x827F78C0 => {
    //   block [0x827F78C0..0x827F78C4)
	// 827F78C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F78C4; continue 'dispatch;
            }
            0x827F78C4 => {
    //   block [0x827F78C4..0x827F78E0)
	// 827F78C4: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 827F78C8: 7D3D582E  lwzx r9, r29, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 827F78CC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F78D0: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827F78D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F78D8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F78DC: 419A0020  beq cr6, 0x827f78fc
	if ctx.cr[6].eq {
	pc = 0x827F78FC; continue 'dispatch;
	}
	pc = 0x827F78E0; continue 'dispatch;
            }
            0x827F78E0 => {
    //   block [0x827F78E0..0x827F78FC)
	// 827F78E0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F78E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F78E8: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F78EC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F78F0: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F78F4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F78F8: 4082FFE8  bne 0x827f78e0
	if !ctx.cr[0].eq {
	pc = 0x827F78E0; continue 'dispatch;
	}
	pc = 0x827F78FC; continue 'dispatch;
            }
            0x827F78FC => {
    //   block [0x827F78FC..0x827F7920)
	// 827F78FC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F7900: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 827F7904: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F7908: 4BFFBF29  bl 0x827f3830
	ctx.lr = 0x827F790C;
	sub_827F3830(ctx, base);
	// 827F790C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F7910: 4B9C0209  bl 0x821b7b18
	ctx.lr = 0x827F7914;
	sub_821B7B18(ctx, base);
	// 827F7914: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 827F7918: 3BBD0008  addi r29, r29, 8
	ctx.r[29].s64 = ctx.r[29].s64 + 8;
	// 827F791C: 4BFFFF5C  b 0x827f7878
	pc = 0x827F7878; continue 'dispatch;
            }
            0x827F7920 => {
    //   block [0x827F7920..0x827F794C)
	// 827F7920: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 827F7924: 7F26CB78  mr r6, r25
	ctx.r[6].u64 = ctx.r[25].u64;
	// 827F7928: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 827F792C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F7930: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F7934: 4BFFC8ED  bl 0x827f4220
	ctx.lr = 0x827F7938;
	sub_827F4220(ctx, base);
	// 827F7938: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F793C: 4BBE4EED  bl 0x823dc828
	ctx.lr = 0x827F7940;
	sub_823DC828(ctx, base);
	// 827F7940: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827F7944: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 827F7948: 484B1AFC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F7950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F7950 size=296
    let mut pc: u32 = 0x827F7950;
    'dispatch: loop {
        match pc {
            0x827F7950 => {
    //   block [0x827F7950..0x827F7988)
	// 827F7950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F7954: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F7958: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F795C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F7960: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F7964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F7968: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827F796C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827F7970: 390BF058  addi r8, r11, -0xfa8
	ctx.r[8].s64 = ctx.r[11].s64 + -4008;
	// 827F7974: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 827F7978: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 827F797C: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F7980: 38C77088  addi r6, r7, 0x7088
	ctx.r[6].s64 = ctx.r[7].s64 + 28808;
	// 827F7984: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x827F7988; continue 'dispatch;
            }
            0x827F7988 => {
    //   block [0x827F7988..0x827F79EC)
	// 827F7988: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F798C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F7990: 7D403028  lwarx r10, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F7994: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F7998: 7D40312D  stwcx. r10, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F799C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F79A0: 4082FFE8  bne 0x827f7988
	if !ctx.cr[0].eq {
	pc = 0x827F7988; continue 'dispatch;
	}
	// 827F79A4: 3CA0820E  lis r5, -0x7df2
	ctx.r[5].s64 = -2113011712;
	// 827F79A8: 9BDF000D  stb r30, 0xd(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(13 as u32), ctx.r[30].u8 ) };
	// 827F79AC: 3C80820E  lis r4, -0x7df2
	ctx.r[4].s64 = -2113011712;
	// 827F79B0: 3865A408  addi r3, r5, -0x5bf8
	ctx.r[3].s64 = ctx.r[5].s64 + -23544;
	// 827F79B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827F79B8: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 827F79BC: 3884A398  addi r4, r4, -0x5c68
	ctx.r[4].s64 = ctx.r[4].s64 + -23656;
	// 827F79C0: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 827F79C4: 4BA3550D  bl 0x8222ced0
	ctx.lr = 0x827F79C8;
	sub_8222CED0(ctx, base);
	// 827F79C8: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 827F79CC: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 827F79D0: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 827F79D4: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 827F79D8: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 827F79DC: 4BA2787D  bl 0x8221f258
	ctx.lr = 0x827F79E0;
	sub_8221F258(ctx, base);
	// 827F79E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F79E4: 419A0008  beq cr6, 0x827f79ec
	if ctx.cr[6].eq {
	pc = 0x827F79EC; continue 'dispatch;
	}
	// 827F79E8: 93C30000  stw r30, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x827F79EC; continue 'dispatch;
            }
            0x827F79EC => {
    //   block [0x827F79EC..0x827F79F8)
	// 827F79EC: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F79F0: 41820008  beq 0x827f79f8
	if ctx.cr[0].eq {
	pc = 0x827F79F8; continue 'dispatch;
	}
	// 827F79F4: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x827F79F8; continue 'dispatch;
            }
            0x827F79F8 => {
    //   block [0x827F79F8..0x827F7A04)
	// 827F79F8: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F79FC: 41820008  beq 0x827f7a04
	if ctx.cr[0].eq {
	pc = 0x827F7A04; continue 'dispatch;
	}
	// 827F7A00: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x827F7A04; continue 'dispatch;
            }
            0x827F7A04 => {
    //   block [0x827F7A04..0x827F7A78)
	// 827F7A04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F7A08: 9BC30019  stb r30, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[30].u8 ) };
	// 827F7A0C: 3D408210  lis r10, -0x7df0
	ctx.r[10].s64 = -2112880640;
	// 827F7A10: 99630018  stb r11, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u8 ) };
	// 827F7A14: 907F0028  stw r3, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[3].u32 ) };
	// 827F7A18: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 827F7A1C: 387F0040  addi r3, r31, 0x40
	ctx.r[3].s64 = ctx.r[31].s64 + 64;
	// 827F7A20: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 827F7A24: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F7A28: C00A15C0  lfs f0, 0x15c0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(5568 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827F7A2C: 811F0028  lwz r8, 0x28(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 827F7A30: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F7A34: 80FF0028  lwz r7, 0x28(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 827F7A38: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 827F7A3C: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 827F7A40: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 827F7A44: 4BA4436D  bl 0x8223bdb0
	ctx.lr = 0x827F7A48;
	sub_8223BDB0(ctx, base);
	// 827F7A48: 387F0080  addi r3, r31, 0x80
	ctx.r[3].s64 = ctx.r[31].s64 + 128;
	// 827F7A4C: 4BA44365  bl 0x8223bdb0
	ctx.lr = 0x827F7A50;
	sub_8223BDB0(ctx, base);
	// 827F7A50: 93DF00C4  stw r30, 0xc4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), ctx.r[30].u32 ) };
	// 827F7A54: 93DF00C8  stw r30, 0xc8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 827F7A58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7A5C: 93DF00CC  stw r30, 0xcc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), ctx.r[30].u32 ) };
	// 827F7A60: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F7A64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F7A68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F7A6C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F7A70: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F7A74: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F7A78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F7A78 size=804
    let mut pc: u32 = 0x827F7A78;
    'dispatch: loop {
        match pc {
            0x827F7A78 => {
    //   block [0x827F7A78..0x827F7D9C)
	// 827F7A78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F7A7C: 484B1975  bl 0x82ca93f0
	ctx.lr = 0x827F7A80;
	sub_82CA93D0(ctx, base);
	// 827F7A80: 9421FDF0  stwu r1, -0x210(r1)
	ea = ctx.r[1].u32.wrapping_add(-528 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F7A84: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 827F7A88: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 827F7A8C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827F7A90: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827F7A94: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 827F7A98: 387600C0  addi r3, r22, 0xc0
	ctx.r[3].s64 = ctx.r[22].s64 + 192;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F7DA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F7DA0 size=532
    let mut pc: u32 = 0x827F7DA0;
    'dispatch: loop {
        match pc {
            0x827F7DA0 => {
    //   block [0x827F7DA0..0x827F7DF0)
	// 827F7DA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F7DA4: 484B1669  bl 0x82ca940c
	ctx.lr = 0x827F7DA8;
	sub_82CA93D0(ctx, base);
	// 827F7DA8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F7DAC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F7DB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F7DB4: 3BEBBB08  addi r31, r11, -0x44f8
	ctx.r[31].s64 = ctx.r[11].s64 + -17656;
	// 827F7DB8: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 827F7DBC: 816BBB08  lwz r11, -0x44f8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17656 as u32) ) } as u64;
	// 827F7DC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7DC4: 419A002C  beq cr6, 0x827f7df0
	if ctx.cr[6].eq {
	pc = 0x827F7DF0; continue 'dispatch;
	}
	// 827F7DC8: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827F7DCC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F7DD0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F7DD4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F7DD8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7DDC: 4BB58AE5  bl 0x823508c0
	ctx.lr = 0x827F7DE0;
	sub_823508C0(ctx, base);
	// 827F7DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7DE4: 4B9BFD35  bl 0x821b7b18
	ctx.lr = 0x827F7DE8;
	sub_821B7B18(ctx, base);
	// 827F7DE8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7DEC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F7DF0; continue 'dispatch;
            }
            0x827F7DF0 => {
    //   block [0x827F7DF0..0x827F7E2C)
	// 827F7DF0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F7DF4: 3BEBBB10  addi r31, r11, -0x44f0
	ctx.r[31].s64 = ctx.r[11].s64 + -17648;
	// 827F7DF8: 816BBB10  lwz r11, -0x44f0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17648 as u32) ) } as u64;
	// 827F7DFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7E00: 419A002C  beq cr6, 0x827f7e2c
	if ctx.cr[6].eq {
	pc = 0x827F7E2C; continue 'dispatch;
	}
	// 827F7E04: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827F7E08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F7E0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F7E10: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F7E14: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7E18: 4BB58AA9  bl 0x823508c0
	ctx.lr = 0x827F7E1C;
	sub_823508C0(ctx, base);
	// 827F7E1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7E20: 4B9BFCF9  bl 0x821b7b18
	ctx.lr = 0x827F7E24;
	sub_821B7B18(ctx, base);
	// 827F7E24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7E28: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F7E2C; continue 'dispatch;
            }
            0x827F7E2C => {
    //   block [0x827F7E2C..0x827F7E68)
	// 827F7E2C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F7E30: 3BEBBB18  addi r31, r11, -0x44e8
	ctx.r[31].s64 = ctx.r[11].s64 + -17640;
	// 827F7E34: 816BBB18  lwz r11, -0x44e8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17640 as u32) ) } as u64;
	// 827F7E38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7E3C: 419A002C  beq cr6, 0x827f7e68
	if ctx.cr[6].eq {
	pc = 0x827F7E68; continue 'dispatch;
	}
	// 827F7E40: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827F7E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F7E48: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F7E4C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F7E50: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7E54: 4BB58A6D  bl 0x823508c0
	ctx.lr = 0x827F7E58;
	sub_823508C0(ctx, base);
	// 827F7E58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7E5C: 4B9BFCBD  bl 0x821b7b18
	ctx.lr = 0x827F7E60;
	sub_821B7B18(ctx, base);
	// 827F7E60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7E64: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F7E68; continue 'dispatch;
            }
            0x827F7E68 => {
    //   block [0x827F7E68..0x827F7EA4)
	// 827F7E68: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F7E6C: 3BEBBB20  addi r31, r11, -0x44e0
	ctx.r[31].s64 = ctx.r[11].s64 + -17632;
	// 827F7E70: 816BBB20  lwz r11, -0x44e0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17632 as u32) ) } as u64;
	// 827F7E74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7E78: 419A002C  beq cr6, 0x827f7ea4
	if ctx.cr[6].eq {
	pc = 0x827F7EA4; continue 'dispatch;
	}
	// 827F7E7C: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827F7E80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F7E84: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F7E88: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827F7E8C: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7E90: 4BB58A31  bl 0x823508c0
	ctx.lr = 0x827F7E94;
	sub_823508C0(ctx, base);
	// 827F7E94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7E98: 4B9BFC81  bl 0x821b7b18
	ctx.lr = 0x827F7E9C;
	sub_821B7B18(ctx, base);
	// 827F7E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7EA0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F7EA4; continue 'dispatch;
            }
            0x827F7EA4 => {
    //   block [0x827F7EA4..0x827F7ED0)
	// 827F7EA4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 827F7EA8: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	// 827F7EAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7EB0: 419A003C  beq cr6, 0x827f7eec
	if ctx.cr[6].eq {
	pc = 0x827F7EEC; continue 'dispatch;
	}
	// 827F7EB4: 816B001C  lwz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 827F7EB8: 814B0010  lwz r10, 0x10(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F7EBC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F7EC0: 409A0010  bne cr6, 0x827f7ed0
	if !ctx.cr[6].eq {
	pc = 0x827F7ED0; continue 'dispatch;
	}
	// 827F7EC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F7EC8: 387D001C  addi r3, r29, 0x1c
	ctx.r[3].s64 = ctx.r[29].s64 + 28;
	// 827F7ECC: 4B9834CD  bl 0x8217b398
	ctx.lr = 0x827F7ED0;
	sub_8217B398(ctx, base);
	pc = 0x827F7ED0; continue 'dispatch;
            }
            0x827F7ED0 => {
    //   block [0x827F7ED0..0x827F7EEC)
	// 827F7ED0: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7ED4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7ED8: 4BFFE5A1  bl 0x827f6478
	ctx.lr = 0x827F7EDC;
	sub_827F6478(ctx, base);
	// 827F7EDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F7EE0: 4B9BFC39  bl 0x821b7b18
	ctx.lr = 0x827F7EE4;
	sub_821B7B18(ctx, base);
	// 827F7EE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7EE8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F7EEC; continue 'dispatch;
            }
            0x827F7EEC => {
    //   block [0x827F7EEC..0x827F7F04)
	// 827F7EEC: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 827F7EF0: 3BDD0024  addi r30, r29, 0x24
	ctx.r[30].s64 = ctx.r[29].s64 + 36;
	// 827F7EF4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 827F7EF8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F7EFC: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F7F00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F7F04; continue 'dispatch;
            }
            0x827F7F04 => {
    //   block [0x827F7F04..0x827F7F18)
	// 827F7F04: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7F08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7F0C: 419A000C  beq cr6, 0x827f7f18
	if ctx.cr[6].eq {
	pc = 0x827F7F18; continue 'dispatch;
	}
	// 827F7F10: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F7F14: 419A0008  beq cr6, 0x827f7f1c
	if ctx.cr[6].eq {
	pc = 0x827F7F1C; continue 'dispatch;
	}
	pc = 0x827F7F18; continue 'dispatch;
            }
            0x827F7F18 => {
    //   block [0x827F7F18..0x827F7F1C)
	// 827F7F18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F7F1C; continue 'dispatch;
            }
            0x827F7F1C => {
    //   block [0x827F7F1C..0x827F7F30)
	// 827F7F1C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F7F20: 419A0084  beq cr6, 0x827f7fa4
	if ctx.cr[6].eq {
	pc = 0x827F7FA4; continue 'dispatch;
	}
	// 827F7F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F7F28: 409A0008  bne cr6, 0x827f7f30
	if !ctx.cr[6].eq {
	pc = 0x827F7F30; continue 'dispatch;
	}
	// 827F7F2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F7F30; continue 'dispatch;
            }
            0x827F7F30 => {
    //   block [0x827F7F30..0x827F7F40)
	// 827F7F30: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F7F34: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F7F38: 409A0008  bne cr6, 0x827f7f40
	if !ctx.cr[6].eq {
	pc = 0x827F7F40; continue 'dispatch;
	}
	// 827F7F3C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F7F40; continue 'dispatch;
            }
            0x827F7F40 => {
    //   block [0x827F7F40..0x827F7F5C)
	// 827F7F40: 83EA0010  lwz r31, 0x10(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 827F7F44: 389F0034  addi r4, r31, 0x34
	ctx.r[4].s64 = ctx.r[31].s64 + 52;
	// 827F7F48: 815F003C  lwz r10, 0x3c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) } as u64;
	// 827F7F4C: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 827F7F50: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F7F54: 40990008  ble cr6, 0x827f7f5c
	if !ctx.cr[6].gt {
	pc = 0x827F7F5C; continue 'dispatch;
	}
	// 827F7F58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F7F5C; continue 'dispatch;
            }
            0x827F7F5C => {
    //   block [0x827F7F5C..0x827F7F70)
	// 827F7F5C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 827F7F60: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F7F64: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F7F68: 40990008  ble cr6, 0x827f7f70
	if !ctx.cr[6].gt {
	pc = 0x827F7F70; continue 'dispatch;
	}
	// 827F7F6C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F7F70; continue 'dispatch;
            }
            0x827F7F70 => {
    //   block [0x827F7F70..0x827F7FA4)
	// 827F7F70: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F7F74: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827F7F78: 90810060  stw r4, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 827F7F7C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F7F80: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827F7F84: 480D3375  bl 0x828cb2f8
	ctx.lr = 0x827F7F88;
	sub_828CB2F8(ctx, base);
	// 827F7F88: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827F7F8C: 4BD8764D  bl 0x8257f5d8
	ctx.lr = 0x827F7F90;
	sub_8257F5D8(ctx, base);
	// 827F7F90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F7F94: 4BC44E5D  bl 0x8243cdf0
	ctx.lr = 0x827F7F98;
	sub_8243CDF0(ctx, base);
	// 827F7F98: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F7F9C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F7FA0: 4BFFFF64  b 0x827f7f04
	pc = 0x827F7F04; continue 'dispatch;
            }
            0x827F7FA4 => {
    //   block [0x827F7FA4..0x827F7FB4)
	// 827F7FA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F7FA8: 4BB1B9F1  bl 0x82313998
	ctx.lr = 0x827F7FAC;
	sub_82313998(ctx, base);
	// 827F7FAC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F7FB0: 484B14AC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F7FB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F7FB8 size=352
    let mut pc: u32 = 0x827F7FB8;
    'dispatch: loop {
        match pc {
            0x827F7FB8 => {
    //   block [0x827F7FB8..0x827F8020)
	// 827F7FB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F7FBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F7FC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F7FC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F7FC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F7FCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F7FD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F7FD4: 4BFFF97D  bl 0x827f7950
	ctx.lr = 0x827F7FD8;
	sub_827F7950(ctx, base);
	// 827F7FD8: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827F7FDC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F7FE0: 392A6070  addi r9, r10, 0x6070
	ctx.r[9].s64 = ctx.r[10].s64 + 24688;
	// 827F7FE4: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F7FE8: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F7FEC: 550797FE  rlwinm r7, r8, 0x12, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00003FFFu64;
	// 827F7FF0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F7FF4: 419A00EC  beq cr6, 0x827f80e0
	if ctx.cr[6].eq {
	pc = 0x827F80E0; continue 'dispatch;
	}
	// 827F7FF8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F7FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8000: 419A0020  beq cr6, 0x827f8020
	if ctx.cr[6].eq {
	pc = 0x827F8020; continue 'dispatch;
	}
	// 827F8004: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 827F8008: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F800C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F8010: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F8014: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8018: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F801C: 480000C8  b 0x827f80e4
	pc = 0x827F80E4; continue 'dispatch;
            }
            0x827F8020 => {
    //   block [0x827F8020..0x827F8040)
	// 827F8020: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F8024: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8028: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F802C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F8030: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F8034: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F8038: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F803C: 40810054  ble 0x827f8090
	if !ctx.cr[0].gt {
	pc = 0x827F8090; continue 'dispatch;
	}
	pc = 0x827F8040; continue 'dispatch;
            }
            0x827F8040 => {
    //   block [0x827F8040..0x827F8060)
	// 827F8040: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F8044: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F8048: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F804C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8050: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 827F8054: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F8058: 41980008  blt cr6, 0x827f8060
	if ctx.cr[6].lt {
	pc = 0x827F8060; continue 'dispatch;
	}
	// 827F805C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F8060; continue 'dispatch;
            }
            0x827F8060 => {
    //   block [0x827F8060..0x827F807C)
	// 827F8060: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F8064: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F8068: 419A0014  beq cr6, 0x827f807c
	if ctx.cr[6].eq {
	pc = 0x827F807C; continue 'dispatch;
	}
	// 827F806C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F8070: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F8074: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F8078: 4800000C  b 0x827f8084
	pc = 0x827F8084; continue 'dispatch;
            }
            0x827F807C => {
    //   block [0x827F807C..0x827F8084)
	// 827F807C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F8080: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F8084; continue 'dispatch;
            }
            0x827F8084 => {
    //   block [0x827F8084..0x827F8090)
	// 827F8084: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F8088: 4199FFB8  bgt cr6, 0x827f8040
	if ctx.cr[6].gt {
	pc = 0x827F8040; continue 'dispatch;
	}
	// 827F808C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F8090; continue 'dispatch;
            }
            0x827F8090 => {
    //   block [0x827F8090..0x827F80AC)
	// 827F8090: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F8094: 419A003C  beq cr6, 0x827f80d0
	if ctx.cr[6].eq {
	pc = 0x827F80D0; continue 'dispatch;
	}
	// 827F8098: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F809C: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 827F80A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F80A4: 41990008  bgt cr6, 0x827f80ac
	if ctx.cr[6].gt {
	pc = 0x827F80AC; continue 'dispatch;
	}
	// 827F80A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F80AC; continue 'dispatch;
            }
            0x827F80AC => {
    //   block [0x827F80AC..0x827F80D0)
	// 827F80AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F80B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F80B4: 409A001C  bne cr6, 0x827f80d0
	if !ctx.cr[6].eq {
	pc = 0x827F80D0; continue 'dispatch;
	}
	// 827F80B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F80BC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F80C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F80C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F80C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F80CC: 48000018  b 0x827f80e4
	pc = 0x827F80E4; continue 'dispatch;
            }
            0x827F80D0 => {
    //   block [0x827F80D0..0x827F80E0)
	// 827F80D0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F80D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F80D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F80DC: 48000008  b 0x827f80e4
	pc = 0x827F80E4; continue 'dispatch;
            }
            0x827F80E0 => {
    //   block [0x827F80E0..0x827F80E4)
	// 827F80E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F80E4; continue 'dispatch;
            }
            0x827F80E4 => {
    //   block [0x827F80E4..0x827F80FC)
	// 827F80E4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F80E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F80EC: 419A0010  beq cr6, 0x827f80fc
	if ctx.cr[6].eq {
	pc = 0x827F80FC; continue 'dispatch;
	}
	// 827F80F0: 388B0090  addi r4, r11, 0x90
	ctx.r[4].s64 = ctx.r[11].s64 + 144;
	// 827F80F4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 827F80F8: 4BA6D0A9  bl 0x822651a0
	ctx.lr = 0x827F80FC;
	sub_822651A0(ctx, base);
	pc = 0x827F80FC; continue 'dispatch;
            }
            0x827F80FC => {
    //   block [0x827F80FC..0x827F8118)
	// 827F80FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F810C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F8110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8118 size=352
    let mut pc: u32 = 0x827F8118;
    'dispatch: loop {
        match pc {
            0x827F8118 => {
    //   block [0x827F8118..0x827F8180)
	// 827F8118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F811C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F8124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8128: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F812C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F8130: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F8134: 4BFFF81D  bl 0x827f7950
	ctx.lr = 0x827F8138;
	sub_827F7950(ctx, base);
	// 827F8138: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F813C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8140: 392AA468  addi r9, r10, -0x5b98
	ctx.r[9].s64 = ctx.r[10].s64 + -23448;
	// 827F8144: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F8148: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F814C: 550797FE  rlwinm r7, r8, 0x12, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00003FFFu64;
	// 827F8150: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F8154: 419A00EC  beq cr6, 0x827f8240
	if ctx.cr[6].eq {
	pc = 0x827F8240; continue 'dispatch;
	}
	// 827F8158: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F815C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8160: 419A0020  beq cr6, 0x827f8180
	if ctx.cr[6].eq {
	pc = 0x827F8180; continue 'dispatch;
	}
	// 827F8164: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 827F8168: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F816C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F8170: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F8174: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8178: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F817C: 480000C8  b 0x827f8244
	pc = 0x827F8244; continue 'dispatch;
            }
            0x827F8180 => {
    //   block [0x827F8180..0x827F81A0)
	// 827F8180: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F8184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8188: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F818C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F8190: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F8194: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F8198: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F819C: 40810054  ble 0x827f81f0
	if !ctx.cr[0].gt {
	pc = 0x827F81F0; continue 'dispatch;
	}
	pc = 0x827F81A0; continue 'dispatch;
            }
            0x827F81A0 => {
    //   block [0x827F81A0..0x827F81C0)
	// 827F81A0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F81A4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F81A8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F81AC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F81B0: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 827F81B4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F81B8: 41980008  blt cr6, 0x827f81c0
	if ctx.cr[6].lt {
	pc = 0x827F81C0; continue 'dispatch;
	}
	// 827F81BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F81C0; continue 'dispatch;
            }
            0x827F81C0 => {
    //   block [0x827F81C0..0x827F81DC)
	// 827F81C0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F81C4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F81C8: 419A0014  beq cr6, 0x827f81dc
	if ctx.cr[6].eq {
	pc = 0x827F81DC; continue 'dispatch;
	}
	// 827F81CC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F81D0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F81D4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F81D8: 4800000C  b 0x827f81e4
	pc = 0x827F81E4; continue 'dispatch;
            }
            0x827F81DC => {
    //   block [0x827F81DC..0x827F81E4)
	// 827F81DC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F81E0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F81E4; continue 'dispatch;
            }
            0x827F81E4 => {
    //   block [0x827F81E4..0x827F81F0)
	// 827F81E4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F81E8: 4199FFB8  bgt cr6, 0x827f81a0
	if ctx.cr[6].gt {
	pc = 0x827F81A0; continue 'dispatch;
	}
	// 827F81EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F81F0; continue 'dispatch;
            }
            0x827F81F0 => {
    //   block [0x827F81F0..0x827F820C)
	// 827F81F0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F81F4: 419A003C  beq cr6, 0x827f8230
	if ctx.cr[6].eq {
	pc = 0x827F8230; continue 'dispatch;
	}
	// 827F81F8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F81FC: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 827F8200: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F8204: 41990008  bgt cr6, 0x827f820c
	if ctx.cr[6].gt {
	pc = 0x827F820C; continue 'dispatch;
	}
	// 827F8208: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F820C; continue 'dispatch;
            }
            0x827F820C => {
    //   block [0x827F820C..0x827F8230)
	// 827F820C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F8210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8214: 409A001C  bne cr6, 0x827f8230
	if !ctx.cr[6].eq {
	pc = 0x827F8230; continue 'dispatch;
	}
	// 827F8218: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F821C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8220: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F8224: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8228: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F822C: 48000018  b 0x827f8244
	pc = 0x827F8244; continue 'dispatch;
            }
            0x827F8230 => {
    //   block [0x827F8230..0x827F8240)
	// 827F8230: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F8234: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8238: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F823C: 48000008  b 0x827f8244
	pc = 0x827F8244; continue 'dispatch;
            }
            0x827F8240 => {
    //   block [0x827F8240..0x827F8244)
	// 827F8240: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F8244; continue 'dispatch;
            }
            0x827F8244 => {
    //   block [0x827F8244..0x827F825C)
	// 827F8244: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F8248: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F824C: 419A0010  beq cr6, 0x827f825c
	if ctx.cr[6].eq {
	pc = 0x827F825C; continue 'dispatch;
	}
	// 827F8250: 388B0094  addi r4, r11, 0x94
	ctx.r[4].s64 = ctx.r[11].s64 + 148;
	// 827F8254: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 827F8258: 4BA6CF49  bl 0x822651a0
	ctx.lr = 0x827F825C;
	sub_822651A0(ctx, base);
	pc = 0x827F825C; continue 'dispatch;
            }
            0x827F825C => {
    //   block [0x827F825C..0x827F8278)
	// 827F825C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8260: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8264: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8268: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F826C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F8270: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8274: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8278(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8278 size=352
    let mut pc: u32 = 0x827F8278;
    'dispatch: loop {
        match pc {
            0x827F8278 => {
    //   block [0x827F8278..0x827F82E0)
	// 827F8278: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F827C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8280: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F8284: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8288: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F828C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F8290: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F8294: 4BFFF6BD  bl 0x827f7950
	ctx.lr = 0x827F8298;
	sub_827F7950(ctx, base);
	// 827F8298: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827F829C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F82A0: 392AA4C8  addi r9, r10, -0x5b38
	ctx.r[9].s64 = ctx.r[10].s64 + -23352;
	// 827F82A4: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827F82A8: 811F0030  lwz r8, 0x30(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 827F82AC: 550797FE  rlwinm r7, r8, 0x12, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00003FFFu64;
	// 827F82B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F82B4: 419A00EC  beq cr6, 0x827f83a0
	if ctx.cr[6].eq {
	pc = 0x827F83A0; continue 'dispatch;
	}
	// 827F82B8: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 827F82BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F82C0: 419A0020  beq cr6, 0x827f82e0
	if ctx.cr[6].eq {
	pc = 0x827F82E0; continue 'dispatch;
	}
	// 827F82C4: 894B006E  lbz r10, 0x6e(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(110 as u32) ) } as u64;
	// 827F82C8: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F82CC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827F82D0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F82D4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F82D8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F82DC: 480000C8  b 0x827f83a4
	pc = 0x827F83A4; continue 'dispatch;
            }
            0x827F82E0 => {
    //   block [0x827F82E0..0x827F8300)
	// 827F82E0: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 827F82E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F82E8: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 827F82EC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F82F0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827F82F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F82F8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F82FC: 40810054  ble 0x827f8350
	if !ctx.cr[0].gt {
	pc = 0x827F8350; continue 'dispatch;
	}
	pc = 0x827F8300; continue 'dispatch;
            }
            0x827F8300 => {
    //   block [0x827F8300..0x827F8320)
	// 827F8300: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827F8304: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F8308: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827F830C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8310: 2F07006E  cmpwi cr6, r7, 0x6e
	ctx.cr[6].compare_i32(ctx.r[7].s32, 110, &mut ctx.xer);
	// 827F8314: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827F8318: 41980008  blt cr6, 0x827f8320
	if ctx.cr[6].lt {
	pc = 0x827F8320; continue 'dispatch;
	}
	// 827F831C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x827F8320; continue 'dispatch;
            }
            0x827F8320 => {
    //   block [0x827F8320..0x827F833C)
	// 827F8320: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827F8324: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F8328: 419A0014  beq cr6, 0x827f833c
	if ctx.cr[6].eq {
	pc = 0x827F833C; continue 'dispatch;
	}
	// 827F832C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F8330: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827F8334: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F8338: 4800000C  b 0x827f8344
	pc = 0x827F8344; continue 'dispatch;
            }
            0x827F833C => {
    //   block [0x827F833C..0x827F8344)
	// 827F833C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827F8340: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827F8344; continue 'dispatch;
            }
            0x827F8344 => {
    //   block [0x827F8344..0x827F8350)
	// 827F8344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F8348: 4199FFB8  bgt cr6, 0x827f8300
	if ctx.cr[6].gt {
	pc = 0x827F8300; continue 'dispatch;
	}
	// 827F834C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827F8350; continue 'dispatch;
            }
            0x827F8350 => {
    //   block [0x827F8350..0x827F836C)
	// 827F8350: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827F8354: 419A003C  beq cr6, 0x827f8390
	if ctx.cr[6].eq {
	pc = 0x827F8390; continue 'dispatch;
	}
	// 827F8358: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F835C: 2F0B006E  cmpwi cr6, r11, 0x6e
	ctx.cr[6].compare_i32(ctx.r[11].s32, 110, &mut ctx.xer);
	// 827F8360: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F8364: 41990008  bgt cr6, 0x827f836c
	if ctx.cr[6].gt {
	pc = 0x827F836C; continue 'dispatch;
	}
	// 827F8368: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F836C; continue 'dispatch;
            }
            0x827F836C => {
    //   block [0x827F836C..0x827F8390)
	// 827F836C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F8370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8374: 409A001C  bne cr6, 0x827f8390
	if !ctx.cr[6].eq {
	pc = 0x827F8390; continue 'dispatch;
	}
	// 827F8378: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F837C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8380: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 827F8384: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8388: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F838C: 48000018  b 0x827f83a4
	pc = 0x827F83A4; continue 'dispatch;
            }
            0x827F8390 => {
    //   block [0x827F8390..0x827F83A0)
	// 827F8390: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827F8394: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827F8398: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F839C: 48000008  b 0x827f83a4
	pc = 0x827F83A4; continue 'dispatch;
            }
            0x827F83A0 => {
    //   block [0x827F83A0..0x827F83A4)
	// 827F83A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x827F83A4; continue 'dispatch;
            }
            0x827F83A4 => {
    //   block [0x827F83A4..0x827F83BC)
	// 827F83A4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827F83A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F83AC: 419A0010  beq cr6, 0x827f83bc
	if ctx.cr[6].eq {
	pc = 0x827F83BC; continue 'dispatch;
	}
	// 827F83B0: 388B0098  addi r4, r11, 0x98
	ctx.r[4].s64 = ctx.r[11].s64 + 152;
	// 827F83B4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 827F83B8: 4BA6CDE9  bl 0x822651a0
	ctx.lr = 0x827F83BC;
	sub_822651A0(ctx, base);
	pc = 0x827F83BC; continue 'dispatch;
            }
            0x827F83BC => {
    //   block [0x827F83BC..0x827F83D8)
	// 827F83BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F83C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F83C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F83C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F83CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F83D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F83D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F83D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F83D8 size=80
    let mut pc: u32 = 0x827F83D8;
    'dispatch: loop {
        match pc {
            0x827F83D8 => {
    //   block [0x827F83D8..0x827F8410)
	// 827F83D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F83DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F83E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F83E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F83E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F83EC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F83F0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F83F4: 4BFFA2DD  bl 0x827f26d0
	ctx.lr = 0x827F83F8;
	sub_827F26D0(ctx, base);
	// 827F83F8: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 827F83FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8400: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8404: 419A000C  beq cr6, 0x827f8410
	if ctx.cr[6].eq {
	pc = 0x827F8410; continue 'dispatch;
	}
	// 827F8408: 4BA23931  bl 0x8221bd38
	ctx.lr = 0x827F840C;
	sub_8221BD38(ctx, base);
	// 827F840C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x827F8410; continue 'dispatch;
            }
            0x827F8410 => {
    //   block [0x827F8410..0x827F8428)
	// 827F8410: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8414: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8418: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F841C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F8420: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8424: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8428(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8428 size=128
    let mut pc: u32 = 0x827F8428;
    'dispatch: loop {
        match pc {
            0x827F8428 => {
    //   block [0x827F8428..0x827F8488)
	// 827F8428: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F842C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8430: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F8434: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8438: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F843C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F8440: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F8444: 4B9BF6D5  bl 0x821b7b18
	ctx.lr = 0x827F8448;
	sub_821B7B18(ctx, base);
	// 827F8448: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827F844C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F8450: 419A0040  beq cr6, 0x827f8490
	if ctx.cr[6].eq {
	pc = 0x827F8490; continue 'dispatch;
	}
	// 827F8454: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F8458: 4BA26E01  bl 0x8221f258
	ctx.lr = 0x827F845C;
	sub_8221F258(ctx, base);
	// 827F845C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F8460: 419A0028  beq cr6, 0x827f8488
	if ctx.cr[6].eq {
	pc = 0x827F8488; continue 'dispatch;
	}
	// 827F8464: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8468: 3D208280  lis r9, -0x7d80
	ctx.r[9].s64 = -2105540608;
	// 827F846C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827F8470: 38E99198  addi r7, r9, -0x6e68
	ctx.r[7].s64 = ctx.r[9].s64 + -28264;
	// 827F8474: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F8478: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F847C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 827F8480: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F8484: 48000008  b 0x827f848c
	pc = 0x827F848C; continue 'dispatch;
            }
            0x827F8488 => {
    //   block [0x827F8488..0x827F848C)
	// 827F8488: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F848C; continue 'dispatch;
            }
            0x827F848C => {
    //   block [0x827F848C..0x827F8490)
	// 827F848C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x827F8490; continue 'dispatch;
            }
            0x827F8490 => {
    //   block [0x827F8490..0x827F84A8)
	// 827F8490: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8494: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8498: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F849C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F84A0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F84A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F84A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F84A8 size=252
    let mut pc: u32 = 0x827F84A8;
    'dispatch: loop {
        match pc {
            0x827F84A8 => {
    //   block [0x827F84A8..0x827F84D0)
	// 827F84A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F84AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F84B0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F84B4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 827F84B8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F84BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F84C0: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F84C4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F84C8: 409A0030  bne cr6, 0x827f84f8
	if !ctx.cr[6].eq {
	pc = 0x827F84F8; continue 'dispatch;
	}
	// 827F84CC: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F84D0; continue 'dispatch;
            }
            0x827F84D0 => {
    //   block [0x827F84D0..0x827F84E4)
	// 827F84D0: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F84D4: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827F84D8: 4098000C  bge cr6, 0x827f84e4
	if !ctx.cr[6].lt {
	pc = 0x827F84E4; continue 'dispatch;
	}
	// 827F84DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F84E0: 4800000C  b 0x827f84ec
	pc = 0x827F84EC; continue 'dispatch;
            }
            0x827F84E4 => {
    //   block [0x827F84E4..0x827F84EC)
	// 827F84E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F84E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F84EC; continue 'dispatch;
            }
            0x827F84EC => {
    //   block [0x827F84EC..0x827F84F8)
	// 827F84EC: 88EB0019  lbz r7, 0x19(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F84F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827F84F4: 419AFFDC  beq cr6, 0x827f84d0
	if ctx.cr[6].eq {
	pc = 0x827F84D0; continue 'dispatch;
	}
	pc = 0x827F84F8; continue 'dispatch;
            }
            0x827F84F8 => {
    //   block [0x827F84F8..0x827F8520)
	// 827F84F8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F84FC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827F8500: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827F8504: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F8508: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827F850C: 419A0014  beq cr6, 0x827f8520
	if ctx.cr[6].eq {
	pc = 0x827F8520; continue 'dispatch;
	}
	// 827F8510: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8514: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8518: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827F851C: 40980058  bge cr6, 0x827f8574
	if !ctx.cr[6].lt {
	pc = 0x827F8574; continue 'dispatch;
	}
	pc = 0x827F8520; continue 'dispatch;
            }
            0x827F8520 => {
    //   block [0x827F8520..0x827F8574)
	// 827F8520: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8524: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8528: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 827F852C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F8530: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827F8534: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 827F8538: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827F853C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F8540: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827F8544: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827F8548: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 827F854C: 4800044D  bl 0x827f8998
	ctx.lr = 0x827F8550;
	sub_827F8998(ctx, base);
	// 827F8550: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 827F8554: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 827F8558: E9090000  ld r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 827F855C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 827F8560: 4B9BF5B9  bl 0x821b7b18
	ctx.lr = 0x827F8564;
	sub_821B7B18(ctx, base);
	// 827F8564: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F8568: 4B9BF5B1  bl 0x821b7b18
	ctx.lr = 0x827F856C;
	sub_821B7B18(ctx, base);
	// 827F856C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8570: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x827F8574; continue 'dispatch;
            }
            0x827F8574 => {
    //   block [0x827F8574..0x827F8580)
	// 827F8574: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F8578: 409A0008  bne cr6, 0x827f8580
	if !ctx.cr[6].eq {
	pc = 0x827F8580; continue 'dispatch;
	}
	// 827F857C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8580; continue 'dispatch;
            }
            0x827F8580 => {
    //   block [0x827F8580..0x827F8590)
	// 827F8580: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8584: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8588: 409A0008  bne cr6, 0x827f8590
	if !ctx.cr[6].eq {
	pc = 0x827F8590; continue 'dispatch;
	}
	// 827F858C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8590; continue 'dispatch;
            }
            0x827F8590 => {
    //   block [0x827F8590..0x827F85A4)
	// 827F8590: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 827F8594: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F8598: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F859C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F85A0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F85A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F85A8 size=172
    let mut pc: u32 = 0x827F85A8;
    'dispatch: loop {
        match pc {
            0x827F85A8 => {
    //   block [0x827F85A8..0x827F85F8)
	// 827F85A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F85AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F85B0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F85B4: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F85B8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 827F85BC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F85C0: 7D495850  subf r10, r9, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827F85C4: 7D4A2670  srawi r10, r10, 4
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 4) as i64;
	// 827F85C8: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F85CC: 4099002C  ble cr6, 0x827f85f8
	if !ctx.cr[6].gt {
	pc = 0x827F85F8; continue 'dispatch;
	}
	// 827F85D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F85D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F85D8: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 827F85DC: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827F85E0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F85E4: 4829EF35  bl 0x82a97518
	ctx.lr = 0x827F85E8;
	sub_82A97518(ctx, base);
	// 827F85E8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F85EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F85F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F85F4: 4E800020  blr
	return;
            }
            0x827F85F8 => {
    //   block [0x827F85F8..0x827F8640)
	// 827F85F8: 4098004C  bge cr6, 0x827f8644
	if !ctx.cr[6].lt {
	pc = 0x827F8644; continue 'dispatch;
	}
	// 827F85FC: 548A2036  slwi r10, r4, 4
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F8600: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 827F8604: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F8608: 419A003C  beq cr6, 0x827f8644
	if ctx.cr[6].eq {
	pc = 0x827F8644; continue 'dispatch;
	}
	// 827F860C: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 827F8610: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827F8614: 7D072670  srawi r7, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 827F8618: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F861C: 54E82036  slwi r8, r7, 4
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827F8620: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 827F8624: 419A001C  beq cr6, 0x827f8640
	if ctx.cr[6].eq {
	pc = 0x827F8640; continue 'dispatch;
	}
	// 827F8628: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x827F8640; continue 'dispatch;
            }
            0x827F8640 => {
    //   block [0x827F8640..0x827F8644)
	// 827F8640: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x827F8644; continue 'dispatch;
            }
            0x827F8644 => {
    //   block [0x827F8644..0x827F8654)
	// 827F8644: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F8648: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F864C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F8650: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8658 size=352
    let mut pc: u32 = 0x827F8658;
    'dispatch: loop {
        match pc {
            0x827F8658 => {
    //   block [0x827F8658..0x827F8690)
	// 827F8658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F865C: 484B0DA1  bl 0x82ca93fc
	ctx.lr = 0x827F8660;
	sub_82CA93D0(ctx, base);
	// 827F8660: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8664: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F8668: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 827F866C: 3BCBBAFC  addi r30, r11, -0x4504
	ctx.r[30].s64 = ctx.r[11].s64 + -17668;
	// 827F8670: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827F8674: 837E0004  lwz r27, 4(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8678: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 827F867C: 83FB0004  lwz r31, 4(r27)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8680: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8684: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8688: 409A007C  bne cr6, 0x827f8704
	if !ctx.cr[6].eq {
	pc = 0x827F8704; continue 'dispatch;
	}
	// 827F868C: 83B90000  lwz r29, 0(r25)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F8690; continue 'dispatch;
            }
            0x827F8690 => {
    //   block [0x827F8690..0x827F86A4)
	// 827F8690: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8694: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F8698: 409A000C  bne cr6, 0x827f86a4
	if !ctx.cr[6].eq {
	pc = 0x827F86A4; continue 'dispatch;
	}
	// 827F869C: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 827F86A0: 4800003C  b 0x827f86dc
	pc = 0x827F86DC; continue 'dispatch;
            }
            0x827F86A4 => {
    //   block [0x827F86A4..0x827F86B4)
	// 827F86A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F86A8: 409A000C  bne cr6, 0x827f86b4
	if !ctx.cr[6].eq {
	pc = 0x827F86B4; continue 'dispatch;
	}
	// 827F86AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827F86B0: 4800002C  b 0x827f86dc
	pc = 0x827F86DC; continue 'dispatch;
            }
            0x827F86B4 => {
    //   block [0x827F86B4..0x827F86C4)
	// 827F86B4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F86B8: 409A000C  bne cr6, 0x827f86c4
	if !ctx.cr[6].eq {
	pc = 0x827F86C4; continue 'dispatch;
	}
	// 827F86BC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 827F86C0: 4800001C  b 0x827f86dc
	pc = 0x827F86DC; continue 'dispatch;
            }
            0x827F86C4 => {
    //   block [0x827F86C4..0x827F86DC)
	// 827F86C4: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F86C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F86CC: 4BA7512D  bl 0x8226d7f8
	ctx.lr = 0x827F86D0;
	sub_8226D7F8(ctx, base);
	// 827F86D0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 827F86D4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827F86D8: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x827F86DC; continue 'dispatch;
            }
            0x827F86DC => {
    //   block [0x827F86DC..0x827F86F0)
	// 827F86DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F86E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F86E4: 419A000C  beq cr6, 0x827f86f0
	if ctx.cr[6].eq {
	pc = 0x827F86F0; continue 'dispatch;
	}
	// 827F86E8: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F86EC: 4800000C  b 0x827f86f8
	pc = 0x827F86F8; continue 'dispatch;
            }
            0x827F86F0 => {
    //   block [0x827F86F0..0x827F86F8)
	// 827F86F0: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827F86F4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F86F8; continue 'dispatch;
            }
            0x827F86F8 => {
    //   block [0x827F86F8..0x827F8704)
	// 827F86F8: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F86FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8700: 419AFF90  beq cr6, 0x827f8690
	if ctx.cr[6].eq {
	pc = 0x827F8690; continue 'dispatch;
	}
	pc = 0x827F8704; continue 'dispatch;
            }
            0x827F8704 => {
    //   block [0x827F8704..0x827F8734)
	// 827F8704: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 827F8708: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827F870C: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827F8710: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827F8714: 419A0020  beq cr6, 0x827f8734
	if ctx.cr[6].eq {
	pc = 0x827F8734; continue 'dispatch;
	}
	// 827F8718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F871C: 38BC000C  addi r5, r28, 0xc
	ctx.r[5].s64 = ctx.r[28].s64 + 12;
	// 827F8720: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827F8724: 4BFDA8B5  bl 0x827d2fd8
	ctx.lr = 0x827F8728;
	sub_827D2FD8(ctx, base);
	// 827F8728: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F872C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8730: 419A006C  beq cr6, 0x827f879c
	if ctx.cr[6].eq {
	pc = 0x827F879C; continue 'dispatch;
	}
	pc = 0x827F8734; continue 'dispatch;
            }
            0x827F8734 => {
    //   block [0x827F8734..0x827F8798)
	// 827F8734: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827F8738: 93410058  stw r26, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 827F873C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F8740: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 827F8744: 4B9F7AFD  bl 0x821f0240
	ctx.lr = 0x827F8748;
	sub_821F0240(ctx, base);
	// 827F8748: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 827F874C: 93410070  stw r26, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[26].u32 ) };
	// 827F8750: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F8754: 38C10068  addi r6, r1, 0x68
	ctx.r[6].s64 = ctx.r[1].s64 + 104;
	// 827F8758: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F875C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F8760: 48000459  bl 0x827f8bb8
	ctx.lr = 0x827F8764;
	sub_827F8BB8(ctx, base);
	// 827F8764: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F8768: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 827F876C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 827F8770: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 827F8774: 4B9BF3A5  bl 0x821b7b18
	ctx.lr = 0x827F8778;
	sub_821B7B18(ctx, base);
	// 827F8778: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827F877C: 4BA1C65D  bl 0x82214dd8
	ctx.lr = 0x827F8780;
	sub_82214DD8(ctx, base);
	// 827F8780: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F8784: 4B9BF395  bl 0x821b7b18
	ctx.lr = 0x827F8788;
	sub_821B7B18(ctx, base);
	// 827F8788: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F878C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F8790: 409A0008  bne cr6, 0x827f8798
	if !ctx.cr[6].eq {
	pc = 0x827F8798; continue 'dispatch;
	}
	// 827F8794: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8798; continue 'dispatch;
            }
            0x827F8798 => {
    //   block [0x827F8798..0x827F879C)
	// 827F8798: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x827F879C; continue 'dispatch;
            }
            0x827F879C => {
    //   block [0x827F879C..0x827F87AC)
	// 827F879C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F87A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F87A4: 409A0008  bne cr6, 0x827f87ac
	if !ctx.cr[6].eq {
	pc = 0x827F87AC; continue 'dispatch;
	}
	// 827F87A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F87AC; continue 'dispatch;
            }
            0x827F87AC => {
    //   block [0x827F87AC..0x827F87B8)
	// 827F87AC: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 827F87B0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827F87B4: 484B0C98  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F87B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F87B8 size=112
    let mut pc: u32 = 0x827F87B8;
    'dispatch: loop {
        match pc {
            0x827F87B8 => {
    //   block [0x827F87B8..0x827F8828)
	// 827F87B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F87BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F87C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F87C4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F87C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F87CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F87D0: 3BEBBAFC  addi r31, r11, -0x4504
	ctx.r[31].s64 = ctx.r[11].s64 + -17668;
	// 827F87D4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827F87D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F87DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827F87E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F87E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F87E8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F87EC: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F87F0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F87F4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F87F8: 48000FC1  bl 0x827f97b8
	ctx.lr = 0x827F87FC;
	sub_827F97B8(ctx, base);
	// 827F87FC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8800: 4BA23539  bl 0x8221bd38
	ctx.lr = 0x827F8804;
	sub_8221BD38(ctx, base);
	// 827F8804: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8808: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F880C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F8810: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F8814: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8818: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F881C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F8820: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8824: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8828(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8828 size=92
    let mut pc: u32 = 0x827F8828;
    'dispatch: loop {
        match pc {
            0x827F8828 => {
    //   block [0x827F8828..0x827F8884)
	// 827F8828: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F882C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8830: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8834: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8838: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F883C: 3BEBBAFC  addi r31, r11, -0x4504
	ctx.r[31].s64 = ctx.r[11].s64 + -17668;
	// 827F8840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8844: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8848: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F884C: 48000605  bl 0x827f8e50
	ctx.lr = 0x827F8850;
	sub_827F8E50(ctx, base);
	// 827F8850: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8854: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F8858: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F885C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F8860: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8864: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827F8868: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F886C: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F8870: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F8874: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8878: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F887C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8880: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8888 size=144
    let mut pc: u32 = 0x827F8888;
    'dispatch: loop {
        match pc {
            0x827F8888 => {
    //   block [0x827F8888..0x827F88C0)
	// 827F8888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F888C: 484B0B75  bl 0x82ca9400
	ctx.lr = 0x827F8890;
	sub_82CA93D0(ctx, base);
	// 827F8890: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8894: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827F8898: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F889C: FB4100B0  std r26, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[26].u64 ) };
	// 827F88A0: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827F88A4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 827F88A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F88AC: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 827F88B0: 419A0010  beq cr6, 0x827f88c0
	if ctx.cr[6].eq {
	pc = 0x827F88C0; continue 'dispatch;
	}
	// 827F88B4: 814100B8  lwz r10, 0xb8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827F88B8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F88BC: 419A0008  beq cr6, 0x827f88c4
	if ctx.cr[6].eq {
	pc = 0x827F88C4; continue 'dispatch;
	}
	pc = 0x827F88C0; continue 'dispatch;
            }
            0x827F88C0 => {
    //   block [0x827F88C0..0x827F88C4)
	// 827F88C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F88C4; continue 'dispatch;
            }
            0x827F88C4 => {
    //   block [0x827F88C4..0x827F88F0)
	// 827F88C4: 80A100B4  lwz r5, 0xb4(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 827F88C8: 806100BC  lwz r3, 0xbc(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 827F88CC: 7F051840  cmplw cr6, r5, r3
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[3].u32, &mut ctx.xer);
	// 827F88D0: 419A0038  beq cr6, 0x827f8908
	if ctx.cr[6].eq {
	pc = 0x827F8908; continue 'dispatch;
	}
	// 827F88D4: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F88D8: 483721A1  bl 0x82b6aa78
	ctx.lr = 0x827F88DC;
	sub_82B6AA78(ctx, base);
	// 827F88DC: 83BC0008  lwz r29, 8(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F88E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F88E4: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827F88E8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F88EC: 419A0018  beq cr6, 0x827f8904
	if ctx.cr[6].eq {
	pc = 0x827F8904; continue 'dispatch;
	}
	pc = 0x827F88F0; continue 'dispatch;
            }
            0x827F88F0 => {
    //   block [0x827F88F0..0x827F8904)
	// 827F88F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F88F4: 4B9BF225  bl 0x821b7b18
	ctx.lr = 0x827F88F8;
	sub_821B7B18(ctx, base);
	// 827F88F8: 3BFF0008  addi r31, r31, 8
	ctx.r[31].s64 = ctx.r[31].s64 + 8;
	// 827F88FC: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F8900: 409AFFF0  bne cr6, 0x827f88f0
	if !ctx.cr[6].eq {
	pc = 0x827F88F0; continue 'dispatch;
	}
	pc = 0x827F8904; continue 'dispatch;
            }
            0x827F8904 => {
    //   block [0x827F8904..0x827F8908)
	// 827F8904: 93DC0008  stw r30, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x827F8908; continue 'dispatch;
            }
            0x827F8908 => {
    //   block [0x827F8908..0x827F8918)
	// 827F8908: FB5B0000  std r26, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 827F890C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F8910: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F8914: 484B0B3C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8918 size=128
    let mut pc: u32 = 0x827F8918;
    'dispatch: loop {
        match pc {
            0x827F8918 => {
    //   block [0x827F8918..0x827F8978)
	// 827F8918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F891C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F8924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F892C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F8930: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F8934: 4B9BF1E5  bl 0x821b7b18
	ctx.lr = 0x827F8938;
	sub_821B7B18(ctx, base);
	// 827F8938: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827F893C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F8940: 419A0040  beq cr6, 0x827f8980
	if ctx.cr[6].eq {
	pc = 0x827F8980; continue 'dispatch;
	}
	// 827F8944: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827F8948: 4BA26911  bl 0x8221f258
	ctx.lr = 0x827F894C;
	sub_8221F258(ctx, base);
	// 827F894C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F8950: 419A0028  beq cr6, 0x827f8978
	if ctx.cr[6].eq {
	pc = 0x827F8978; continue 'dispatch;
	}
	// 827F8954: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8958: 3D208235  lis r9, -0x7dcb
	ctx.r[9].s64 = -2110455808;
	// 827F895C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 827F8960: 38E918D8  addi r7, r9, 0x18d8
	ctx.r[7].s64 = ctx.r[9].s64 + 6360;
	// 827F8964: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827F8968: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F896C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 827F8970: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F8974: 48000008  b 0x827f897c
	pc = 0x827F897C; continue 'dispatch;
            }
            0x827F8978 => {
    //   block [0x827F8978..0x827F897C)
	// 827F8978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x827F897C; continue 'dispatch;
            }
            0x827F897C => {
    //   block [0x827F897C..0x827F8980)
	// 827F897C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x827F8980; continue 'dispatch;
            }
            0x827F8980 => {
    //   block [0x827F8980..0x827F8998)
	// 827F8980: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8984: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8988: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F898C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F8990: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8994: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8998 size=540
    let mut pc: u32 = 0x827F8998;
    'dispatch: loop {
        match pc {
            0x827F8998 => {
    //   block [0x827F8998..0x827F89EC)
	// 827F8998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F899C: 484B0A69  bl 0x82ca9404
	ctx.lr = 0x827F89A0;
	sub_82CA93D0(ctx, base);
	// 827F89A0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F89A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F89A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F89AC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 827F89B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F89B4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827F89B8: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 827F89BC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827F89C0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F89C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F89C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F89CC: 409A0020  bne cr6, 0x827f89ec
	if !ctx.cr[6].eq {
	pc = 0x827F89EC; continue 'dispatch;
	}
	// 827F89D0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827F89D4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F89D8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F89DC: 480009B5  bl 0x827f9390
	ctx.lr = 0x827F89E0;
	sub_827F9390(ctx, base);
	// 827F89E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F89E4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F89E8: 484B0A6C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F89EC => {
    //   block [0x827F89EC..0x827F8A08)
	// 827F89EC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F89F0: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 827F89F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F89F8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F89FC: 419A000C  beq cr6, 0x827f8a08
	if ctx.cr[6].eq {
	pc = 0x827F8A08; continue 'dispatch;
	}
	// 827F8A00: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8A04: 419A0008  beq cr6, 0x827f8a0c
	if ctx.cr[6].eq {
	pc = 0x827F8A0C; continue 'dispatch;
	}
	pc = 0x827F8A08; continue 'dispatch;
            }
            0x827F8A08 => {
    //   block [0x827F8A08..0x827F8A0C)
	// 827F8A08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8A0C; continue 'dispatch;
            }
            0x827F8A0C => {
    //   block [0x827F8A0C..0x827F8A4C)
	// 827F8A0C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 827F8A10: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F8A14: 409A0038  bne cr6, 0x827f8a4c
	if !ctx.cr[6].eq {
	pc = 0x827F8A4C; continue 'dispatch;
	}
	// 827F8A18: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8A1C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8A20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8A24: 40980160  bge cr6, 0x827f8b84
	if !ctx.cr[6].lt {
	pc = 0x827F8B84; continue 'dispatch;
	}
	// 827F8A28: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827F8A2C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827F8A30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8A34: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8A3C: 48000955  bl 0x827f9390
	ctx.lr = 0x827F8A40;
	sub_827F9390(ctx, base);
	// 827F8A40: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8A44: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F8A48: 484B0A0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8A4C => {
    //   block [0x827F8A4C..0x827F8A5C)
	// 827F8A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8A50: 419A000C  beq cr6, 0x827f8a5c
	if ctx.cr[6].eq {
	pc = 0x827F8A5C; continue 'dispatch;
	}
	// 827F8A54: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8A58: 419A0008  beq cr6, 0x827f8a60
	if ctx.cr[6].eq {
	pc = 0x827F8A60; continue 'dispatch;
	}
	pc = 0x827F8A5C; continue 'dispatch;
            }
            0x827F8A5C => {
    //   block [0x827F8A5C..0x827F8A60)
	// 827F8A5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8A60; continue 'dispatch;
            }
            0x827F8A60 => {
    //   block [0x827F8A60..0x827F8A9C)
	// 827F8A60: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8A64: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8A68: 409A0034  bne cr6, 0x827f8a9c
	if !ctx.cr[6].eq {
	pc = 0x827F8A9C; continue 'dispatch;
	}
	// 827F8A6C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8A70: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8A74: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F8A78: 4098010C  bge cr6, 0x827f8b84
	if !ctx.cr[6].lt {
	pc = 0x827F8B84; continue 'dispatch;
	}
	// 827F8A7C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827F8A80: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F8A84: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8A88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8A8C: 48000905  bl 0x827f9390
	ctx.lr = 0x827F8A90;
	sub_827F9390(ctx, base);
	// 827F8A90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8A94: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F8A98: 484B09BC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8A9C => {
    //   block [0x827F8A9C..0x827F8AE8)
	// 827F8A9C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8AA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8AA4: 40980058  bge cr6, 0x827f8afc
	if !ctx.cr[6].lt {
	pc = 0x827F8AFC; continue 'dispatch;
	}
	// 827F8AA8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F8AAC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 827F8AB0: 4BE67A99  bl 0x82660548
	ctx.lr = 0x827F8AB4;
	sub_82660548(ctx, base);
	// 827F8AB4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8AB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8ABC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8AC0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F8AC4: 40980038  bge cr6, 0x827f8afc
	if !ctx.cr[6].lt {
	pc = 0x827F8AFC; continue 'dispatch;
	}
	// 827F8AC8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8ACC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827F8AD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8AD4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8AD8: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8ADC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F8AE0: 409A0090  bne cr6, 0x827f8b70
	if !ctx.cr[6].eq {
	pc = 0x827F8B70; continue 'dispatch;
	}
	// 827F8AE4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x827F8AE8; continue 'dispatch;
            }
            0x827F8AE8 => {
    //   block [0x827F8AE8..0x827F8AFC)
	// 827F8AE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8AEC: 480008A5  bl 0x827f9390
	ctx.lr = 0x827F8AF0;
	sub_827F9390(ctx, base);
	// 827F8AF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8AF4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F8AF8: 484B095C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8AFC => {
    //   block [0x827F8AFC..0x827F8B2C)
	// 827F8AFC: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8B00: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F8B04: 40980080  bge cr6, 0x827f8b84
	if !ctx.cr[6].lt {
	pc = 0x827F8B84; continue 'dispatch;
	}
	// 827F8B08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F8B0C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 827F8B10: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8B14: 4BC442DD  bl 0x8243cdf0
	ctx.lr = 0x827F8B18;
	sub_8243CDF0(ctx, base);
	// 827F8B18: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8B20: 419A000C  beq cr6, 0x827f8b2c
	if ctx.cr[6].eq {
	pc = 0x827F8B2C; continue 'dispatch;
	}
	// 827F8B24: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8B28: 419A0008  beq cr6, 0x827f8b30
	if ctx.cr[6].eq {
	pc = 0x827F8B30; continue 'dispatch;
	}
	pc = 0x827F8B2C; continue 'dispatch;
            }
            0x827F8B2C => {
    //   block [0x827F8B2C..0x827F8B30)
	// 827F8B2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8B30; continue 'dispatch;
            }
            0x827F8B30 => {
    //   block [0x827F8B30..0x827F8B50)
	// 827F8B30: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8B34: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8B38: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827F8B3C: 419A0014  beq cr6, 0x827f8b50
	if ctx.cr[6].eq {
	pc = 0x827F8B50; continue 'dispatch;
	}
	// 827F8B40: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8B44: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F8B48: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8B4C: 40980038  bge cr6, 0x827f8b84
	if !ctx.cr[6].lt {
	pc = 0x827F8B84; continue 'dispatch;
	}
	pc = 0x827F8B50; continue 'dispatch;
            }
            0x827F8B50 => {
    //   block [0x827F8B50..0x827F8B70)
	// 827F8B50: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8B54: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827F8B58: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8B5C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8B60: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8B64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F8B68: 419AFF80  beq cr6, 0x827f8ae8
	if ctx.cr[6].eq {
	pc = 0x827F8AE8; continue 'dispatch;
	}
	// 827F8B6C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x827F8B70; continue 'dispatch;
            }
            0x827F8B70 => {
    //   block [0x827F8B70..0x827F8B84)
	// 827F8B70: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F8B74: 4800081D  bl 0x827f9390
	ctx.lr = 0x827F8B78;
	sub_827F9390(ctx, base);
	// 827F8B78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8B7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F8B80: 484B08D4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8B84 => {
    //   block [0x827F8B84..0x827F8BB4)
	// 827F8B84: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F8B88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8B8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827F8B90: 480006C1  bl 0x827f9250
	ctx.lr = 0x827F8B94;
	sub_827F9250(ctx, base);
	// 827F8B94: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F8B98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8B9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8BA0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F8BA4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8BA8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F8BAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F8BB0: 484B08A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8BB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8BB8 size=664
    let mut pc: u32 = 0x827F8BB8;
    'dispatch: loop {
        match pc {
            0x827F8BB8 => {
    //   block [0x827F8BB8..0x827F8C08)
	// 827F8BB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F8BBC: 484B083D  bl 0x82ca93f8
	ctx.lr = 0x827F8BC0;
	sub_82CA93D0(ctx, base);
	// 827F8BC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8BC4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F8BC8: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827F8BCC: 3BEBBAFC  addi r31, r11, -0x4504
	ctx.r[31].s64 = ctx.r[11].s64 + -17668;
	// 827F8BD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F8BD4: FB0100D0  std r24, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[24].u64 ) };
	// 827F8BD8: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F8BDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8BE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8BE4: 409A0024  bne cr6, 0x827f8c08
	if !ctx.cr[6].eq {
	pc = 0x827F8C08; continue 'dispatch;
	}
	// 827F8BE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8BEC: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8BF0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827F8BF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8BF8: 48000CB1  bl 0x827f98a8
	ctx.lr = 0x827F8BFC;
	sub_827F98A8(ctx, base);
	// 827F8BFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8C00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8C04: 484B0844  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8C08 => {
    //   block [0x827F8C08..0x827F8C24)
	// 827F8C08: 833F0004  lwz r25, 4(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8C0C: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 827F8C10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8C14: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8C18: 419A000C  beq cr6, 0x827f8c24
	if ctx.cr[6].eq {
	pc = 0x827F8C24; continue 'dispatch;
	}
	// 827F8C1C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8C20: 419A0008  beq cr6, 0x827f8c28
	if ctx.cr[6].eq {
	pc = 0x827F8C28; continue 'dispatch;
	}
	pc = 0x827F8C24; continue 'dispatch;
            }
            0x827F8C24 => {
    //   block [0x827F8C24..0x827F8C28)
	// 827F8C24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8C28; continue 'dispatch;
            }
            0x827F8C28 => {
    //   block [0x827F8C28..0x827F8C74)
	// 827F8C28: 834100D4  lwz r26, 0xd4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 827F8C2C: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8C30: 409A0044  bne cr6, 0x827f8c74
	if !ctx.cr[6].eq {
	pc = 0x827F8C74; continue 'dispatch;
	}
	// 827F8C34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8C38: 38BA000C  addi r5, r26, 0xc
	ctx.r[5].s64 = ctx.r[26].s64 + 12;
	// 827F8C3C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F8C40: 4BFDA399  bl 0x827d2fd8
	ctx.lr = 0x827F8C44;
	sub_827D2FD8(ctx, base);
	// 827F8C44: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8C48: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8C4C: 419A01D4  beq cr6, 0x827f8e20
	if ctx.cr[6].eq {
	pc = 0x827F8E20; continue 'dispatch;
	}
	// 827F8C50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8C54: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827F8C58: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827F8C5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8C60: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8C64: 48000C45  bl 0x827f98a8
	ctx.lr = 0x827F8C68;
	sub_827F98A8(ctx, base);
	// 827F8C68: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8C6C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8C70: 484B07D8  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8C74 => {
    //   block [0x827F8C74..0x827F8C84)
	// 827F8C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8C78: 419A000C  beq cr6, 0x827f8c84
	if ctx.cr[6].eq {
	pc = 0x827F8C84; continue 'dispatch;
	}
	// 827F8C7C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8C80: 419A0008  beq cr6, 0x827f8c88
	if ctx.cr[6].eq {
	pc = 0x827F8C88; continue 'dispatch;
	}
	pc = 0x827F8C84; continue 'dispatch;
            }
            0x827F8C84 => {
    //   block [0x827F8C84..0x827F8C88)
	// 827F8C84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8C88; continue 'dispatch;
            }
            0x827F8C88 => {
    //   block [0x827F8C88..0x827F8CD4)
	// 827F8C88: 7F1AC840  cmplw cr6, r26, r25
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[25].u32, &mut ctx.xer);
	// 827F8C8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8C90: 409A0044  bne cr6, 0x827f8cd4
	if !ctx.cr[6].eq {
	pc = 0x827F8CD4; continue 'dispatch;
	}
	// 827F8C94: 83990008  lwz r28, 8(r25)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8C98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F8C9C: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 827F8CA0: 4BFDA339  bl 0x827d2fd8
	ctx.lr = 0x827F8CA4;
	sub_827D2FD8(ctx, base);
	// 827F8CA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8CA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8CAC: 419A0174  beq cr6, 0x827f8e20
	if ctx.cr[6].eq {
	pc = 0x827F8E20; continue 'dispatch;
	}
	// 827F8CB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8CB4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827F8CB8: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F8CBC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F8CC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8CC4: 48000BE5  bl 0x827f98a8
	ctx.lr = 0x827F8CC8;
	sub_827F98A8(ctx, base);
	// 827F8CC8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8CCC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8CD0: 484B0778  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8CD4 => {
    //   block [0x827F8CD4..0x827F8D50)
	// 827F8CD4: 3B7A000C  addi r27, r26, 0xc
	ctx.r[27].s64 = ctx.r[26].s64 + 12;
	// 827F8CD8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F8CDC: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 827F8CE0: 4BFDA2F9  bl 0x827d2fd8
	ctx.lr = 0x827F8CE4;
	sub_827D2FD8(ctx, base);
	// 827F8CE4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8CE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8CEC: 419A0080  beq cr6, 0x827f8d6c
	if ctx.cr[6].eq {
	pc = 0x827F8D6C; continue 'dispatch;
	}
	// 827F8CF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F8CF4: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 827F8CF8: 4BE67851  bl 0x82660548
	ctx.lr = 0x827F8CFC;
	sub_82660548(ctx, base);
	// 827F8CFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8D00: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F8D04: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8D08: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	// 827F8D0C: 4BFDA2CD  bl 0x827d2fd8
	ctx.lr = 0x827F8D10;
	sub_827D2FD8(ctx, base);
	// 827F8D10: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8D18: 419A0050  beq cr6, 0x827f8d68
	if ctx.cr[6].eq {
	pc = 0x827F8D68; continue 'dispatch;
	}
	// 827F8D1C: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8D20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8D24: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827F8D28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8D2C: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8D30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F8D34: 419A001C  beq cr6, 0x827f8d50
	if ctx.cr[6].eq {
	pc = 0x827F8D50; continue 'dispatch;
	}
	// 827F8D38: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F8D3C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F8D40: 48000B69  bl 0x827f98a8
	ctx.lr = 0x827F8D44;
	sub_827F98A8(ctx, base);
	// 827F8D44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8D48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8D4C: 484B06FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8D50 => {
    //   block [0x827F8D50..0x827F8D68)
	// 827F8D50: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827F8D54: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8D58: 48000B51  bl 0x827f98a8
	ctx.lr = 0x827F8D5C;
	sub_827F98A8(ctx, base);
	// 827F8D5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8D60: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8D64: 484B06E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8D68 => {
    //   block [0x827F8D68..0x827F8D6C)
	// 827F8D68: 833F0004  lwz r25, 4(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x827F8D6C; continue 'dispatch;
            }
            0x827F8D6C => {
    //   block [0x827F8D6C..0x827F8DA8)
	// 827F8D6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8D70: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F8D74: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F8D78: 4BFDA261  bl 0x827d2fd8
	ctx.lr = 0x827F8D7C;
	sub_827D2FD8(ctx, base);
	// 827F8D7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8D84: 419A009C  beq cr6, 0x827f8e20
	if ctx.cr[6].eq {
	pc = 0x827F8E20; continue 'dispatch;
	}
	// 827F8D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F8D8C: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 827F8D90: 4BC44061  bl 0x8243cdf0
	ctx.lr = 0x827F8D94;
	sub_8243CDF0(ctx, base);
	// 827F8D94: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827F8D98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8D9C: 419A000C  beq cr6, 0x827f8da8
	if ctx.cr[6].eq {
	pc = 0x827F8DA8; continue 'dispatch;
	}
	// 827F8DA0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F8DA4: 419A0008  beq cr6, 0x827f8dac
	if ctx.cr[6].eq {
	pc = 0x827F8DAC; continue 'dispatch;
	}
	pc = 0x827F8DA8; continue 'dispatch;
            }
            0x827F8DA8 => {
    //   block [0x827F8DA8..0x827F8DAC)
	// 827F8DA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8DAC; continue 'dispatch;
            }
            0x827F8DAC => {
    //   block [0x827F8DAC..0x827F8DD4)
	// 827F8DAC: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F8DB0: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 827F8DB4: 419A0020  beq cr6, 0x827f8dd4
	if ctx.cr[6].eq {
	pc = 0x827F8DD4; continue 'dispatch;
	}
	// 827F8DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8DBC: 38BC000C  addi r5, r28, 0xc
	ctx.r[5].s64 = ctx.r[28].s64 + 12;
	// 827F8DC0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F8DC4: 4BFDA215  bl 0x827d2fd8
	ctx.lr = 0x827F8DC8;
	sub_827D2FD8(ctx, base);
	// 827F8DC8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F8DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8DD0: 419A0050  beq cr6, 0x827f8e20
	if ctx.cr[6].eq {
	pc = 0x827F8E20; continue 'dispatch;
	}
	pc = 0x827F8DD4; continue 'dispatch;
            }
            0x827F8DD4 => {
    //   block [0x827F8DD4..0x827F8E08)
	// 827F8DD4: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8DD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8DDC: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 827F8DE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8DE4: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8DE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F8DEC: 419A001C  beq cr6, 0x827f8e08
	if ctx.cr[6].eq {
	pc = 0x827F8E08; continue 'dispatch;
	}
	// 827F8DF0: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 827F8DF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827F8DF8: 48000AB1  bl 0x827f98a8
	ctx.lr = 0x827F8DFC;
	sub_827F98A8(ctx, base);
	// 827F8DFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8E00: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8E04: 484B0644  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8E08 => {
    //   block [0x827F8E08..0x827F8E20)
	// 827F8E08: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F8E0C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F8E10: 48000A99  bl 0x827f98a8
	ctx.lr = 0x827F8E14;
	sub_827F98A8(ctx, base);
	// 827F8E14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8E18: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8E1C: 484B062C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F8E20 => {
    //   block [0x827F8E20..0x827F8E50)
	// 827F8E20: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F8E24: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F8E28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F8E2C: 48000805  bl 0x827f9630
	ctx.lr = 0x827F8E30;
	sub_827F9630(ctx, base);
	// 827F8E30: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F8E34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8E38: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8E3C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F8E40: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8E44: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F8E48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F8E4C: 484B05FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8E50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8E50 size=152
    let mut pc: u32 = 0x827F8E50;
    'dispatch: loop {
        match pc {
            0x827F8E50 => {
    //   block [0x827F8E50..0x827F8E80)
	// 827F8E50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F8E54: 484B05AD  bl 0x82ca9400
	ctx.lr = 0x827F8E58;
	sub_82CA93D0(ctx, base);
	// 827F8E58: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8E5C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827F8E60: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F8E64: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827F8E68: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8E6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8E70: 409A0070  bne cr6, 0x827f8ee0
	if !ctx.cr[6].eq {
	pc = 0x827F8EE0; continue 'dispatch;
	}
	// 827F8E74: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827F8E78: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827F8E7C: 3B8B7088  addi r28, r11, 0x7088
	ctx.r[28].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827F8E80; continue 'dispatch;
            }
            0x827F8E80 => {
    //   block [0x827F8E80..0x827F8EA8)
	// 827F8E80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F8E84: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8E88: 4BFFFFC9  bl 0x827f8e50
	ctx.lr = 0x827F8E8C;
	sub_827F8E50(ctx, base);
	// 827F8E8C: 3BBE000C  addi r29, r30, 0xc
	ctx.r[29].s64 = ctx.r[30].s64 + 12;
	// 827F8E90: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 827F8E94: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F8E98: 4B9BEC81  bl 0x821b7b18
	ctx.lr = 0x827F8E9C;
	sub_821B7B18(ctx, base);
	// 827F8E9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F8EA0: 4B9CD8C9  bl 0x821c6768
	ctx.lr = 0x827F8EA4;
	sub_821C6768(ctx, base);
	// 827F8EA4: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x827F8EA8; continue 'dispatch;
            }
            0x827F8EA8 => {
    //   block [0x827F8EA8..0x827F8EE0)
	// 827F8EA8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F8EAC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F8EB0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F8EB4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F8EB8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F8EBC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F8EC0: 4082FFE8  bne 0x827f8ea8
	if !ctx.cr[0].eq {
	pc = 0x827F8EA8; continue 'dispatch;
	}
	// 827F8EC4: 935E000C  stw r26, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 827F8EC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8ECC: 4BA22E6D  bl 0x8221bd38
	ctx.lr = 0x827F8ED0;
	sub_8221BD38(ctx, base);
	// 827F8ED0: 891F0019  lbz r8, 0x19(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F8ED4: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 827F8ED8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F8EDC: 419AFFA4  beq cr6, 0x827f8e80
	if ctx.cr[6].eq {
	pc = 0x827F8E80; continue 'dispatch;
	}
	pc = 0x827F8EE0; continue 'dispatch;
            }
            0x827F8EE0 => {
    //   block [0x827F8EE0..0x827F8EE8)
	// 827F8EE0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F8EE4: 484B056C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8EE8 size=128
    let mut pc: u32 = 0x827F8EE8;
    'dispatch: loop {
        match pc {
            0x827F8EE8 => {
    //   block [0x827F8EE8..0x827F8F30)
	// 827F8EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F8EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8EF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827F8EF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8EF8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8EFC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F8F00: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F8F04: 419A004C  beq cr6, 0x827f8f50
	if ctx.cr[6].eq {
	pc = 0x827F8F50; continue 'dispatch;
	}
	// 827F8F08: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 827F8F0C: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827F8F10: 4BB287D1  bl 0x823216e0
	ctx.lr = 0x827F8F14;
	sub_823216E0(ctx, base);
	// 827F8F14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F8F18: 4BBB3D29  bl 0x823acc40
	ctx.lr = 0x827F8F1C;
	sub_823ACC40(ctx, base);
	// 827F8F1C: 807E00C4  lwz r3, 0xc4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) } as u64;
	// 827F8F20: 3BFE00C0  addi r31, r30, 0xc0
	ctx.r[31].s64 = ctx.r[30].s64 + 192;
	// 827F8F24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F8F28: 419A0008  beq cr6, 0x827f8f30
	if ctx.cr[6].eq {
	pc = 0x827F8F30; continue 'dispatch;
	}
	// 827F8F2C: 4BA22E0D  bl 0x8221bd38
	ctx.lr = 0x827F8F30;
	sub_8221BD38(ctx, base);
	pc = 0x827F8F30; continue 'dispatch;
            }
            0x827F8F30 => {
    //   block [0x827F8F30..0x827F8F50)
	// 827F8F30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F8F34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8F38: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F8F3C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F8F40: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827F8F44: 4BB21C15  bl 0x8231ab58
	ctx.lr = 0x827F8F48;
	sub_8231AB58(ctx, base);
	// 827F8F48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F8F4C: 4BA22DED  bl 0x8221bd38
	ctx.lr = 0x827F8F50;
	sub_8221BD38(ctx, base);
	pc = 0x827F8F50; continue 'dispatch;
            }
            0x827F8F50 => {
    //   block [0x827F8F50..0x827F8F68)
	// 827F8F50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827F8F54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F8F58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F8F5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827F8F60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F8F64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F8F68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F8F68 size=260
    let mut pc: u32 = 0x827F8F68;
    'dispatch: loop {
        match pc {
            0x827F8F68 => {
    //   block [0x827F8F68..0x827F8FA4)
	// 827F8F68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F8F6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F8F70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F8F74: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F8F78: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F8F7C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F8F80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8F84: 419A0020  beq cr6, 0x827f8fa4
	if ctx.cr[6].eq {
	pc = 0x827F8FA4; continue 'dispatch;
	}
	// 827F8F88: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8F8C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F8F90: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F8F94: 2B090004  cmplwi cr6, r9, 4
	ctx.cr[6].compare_u32(ctx.r[9].u32, 4 as u32, &mut ctx.xer);
	// 827F8F98: 4098004C  bge cr6, 0x827f8fe4
	if !ctx.cr[6].lt {
	pc = 0x827F8FE4; continue 'dispatch;
	}
	// 827F8F9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F8FA0: 409A000C  bne cr6, 0x827f8fac
	if !ctx.cr[6].eq {
	pc = 0x827F8FAC; continue 'dispatch;
	}
	pc = 0x827F8FA4; continue 'dispatch;
            }
            0x827F8FA4 => {
    //   block [0x827F8FA4..0x827F8FAC)
	// 827F8FA4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F8FA8: 48000010  b 0x827f8fb8
	pc = 0x827F8FB8; continue 'dispatch;
            }
            0x827F8FAC => {
    //   block [0x827F8FAC..0x827F8FB8)
	// 827F8FAC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8FB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F8FB4: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F8FB8; continue 'dispatch;
            }
            0x827F8FB8 => {
    //   block [0x827F8FB8..0x827F8FC8)
	// 827F8FB8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F8FBC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8FC0: 40990008  ble cr6, 0x827f8fc8
	if !ctx.cr[6].gt {
	pc = 0x827F8FC8; continue 'dispatch;
	}
	// 827F8FC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8FC8; continue 'dispatch;
            }
            0x827F8FC8 => {
    //   block [0x827F8FC8..0x827F8FE4)
	// 827F8FC8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F8FCC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827F8FD0: 20A90004  subfic r5, r9, 4
	ctx.xer.ca = ctx.r[9].u32 <= 4 as u32;
	ctx.r[5].s64 = (4 as i64) - ctx.r[9].s64;
	// 827F8FD4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F8FD8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F8FDC: 48000B75  bl 0x827f9b50
	ctx.lr = 0x827F8FE0;
	sub_827F9B50(ctx, base);
	// 827F8FE0: 48000070  b 0x827f9050
	pc = 0x827F9050; continue 'dispatch;
            }
            0x827F8FE4 => {
    //   block [0x827F8FE4..0x827F8FF4)
	// 827F8FE4: 4099006C  ble cr6, 0x827f9050
	if !ctx.cr[6].gt {
	pc = 0x827F9050; continue 'dispatch;
	}
	// 827F8FE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8FEC: 40990008  ble cr6, 0x827f8ff4
	if !ctx.cr[6].gt {
	pc = 0x827F8FF4; continue 'dispatch;
	}
	// 827F8FF0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F8FF4; continue 'dispatch;
            }
            0x827F8FF4 => {
    //   block [0x827F8FF4..0x827F9008)
	// 827F8FF4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 827F8FF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F8FFC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F9000: 40990008  ble cr6, 0x827f9008
	if !ctx.cr[6].gt {
	pc = 0x827F9008; continue 'dispatch;
	}
	// 827F9004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9008; continue 'dispatch;
            }
            0x827F9008 => {
    //   block [0x827F9008..0x827F9034)
	// 827F9008: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F900C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 827F9010: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9014: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827F9018: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F901C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9020: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 827F9024: 41990010  bgt cr6, 0x827f9034
	if ctx.cr[6].gt {
	pc = 0x827F9034; continue 'dispatch;
	}
	// 827F9028: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F902C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9030: 40980008  bge cr6, 0x827f9038
	if !ctx.cr[6].lt {
	pc = 0x827F9038; continue 'dispatch;
	}
	pc = 0x827F9034; continue 'dispatch;
            }
            0x827F9034 => {
    //   block [0x827F9034..0x827F9038)
	// 827F9034: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9038; continue 'dispatch;
            }
            0x827F9038 => {
    //   block [0x827F9038..0x827F9050)
	// 827F9038: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F903C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F9040: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F9044: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F9048: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F904C: 4BFFF83D  bl 0x827f8888
	ctx.lr = 0x827F9050;
	sub_827F8888(ctx, base);
	pc = 0x827F9050; continue 'dispatch;
            }
            0x827F9050 => {
    //   block [0x827F9050..0x827F906C)
	// 827F9050: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9054: 4B9BEAC5  bl 0x821b7b18
	ctx.lr = 0x827F9058;
	sub_821B7B18(ctx, base);
	// 827F9058: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F905C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F9060: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F9064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F9068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9070 size=296
    let mut pc: u32 = 0x827F9070;
    'dispatch: loop {
        match pc {
            0x827F9070 => {
    //   block [0x827F9070..0x827F9098)
	// 827F9070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F9078: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F907C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F9080: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9084: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 827F9088: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F908C: 409A000C  bne cr6, 0x827f9098
	if !ctx.cr[6].eq {
	pc = 0x827F9098; continue 'dispatch;
	}
	// 827F9090: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F9094: 48000010  b 0x827f90a4
	pc = 0x827F90A4; continue 'dispatch;
            }
            0x827F9098 => {
    //   block [0x827F9098..0x827F90A4)
	// 827F9098: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F909C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F90A0: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F90A4; continue 'dispatch;
            }
            0x827F90A4 => {
    //   block [0x827F90A4..0x827F90BC)
	// 827F90A4: 7F0A2040  cmplw cr6, r10, r4
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827F90A8: 4098004C  bge cr6, 0x827f90f4
	if !ctx.cr[6].lt {
	pc = 0x827F90F4; continue 'dispatch;
	}
	// 827F90AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F90B0: 409A000C  bne cr6, 0x827f90bc
	if !ctx.cr[6].eq {
	pc = 0x827F90BC; continue 'dispatch;
	}
	// 827F90B4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F90B8: 48000010  b 0x827f90c8
	pc = 0x827F90C8; continue 'dispatch;
            }
            0x827F90BC => {
    //   block [0x827F90BC..0x827F90C8)
	// 827F90BC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F90C0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F90C4: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F90C8; continue 'dispatch;
            }
            0x827F90C8 => {
    //   block [0x827F90C8..0x827F90D8)
	// 827F90C8: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F90CC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F90D0: 40990008  ble cr6, 0x827f90d8
	if !ctx.cr[6].gt {
	pc = 0x827F90D8; continue 'dispatch;
	}
	// 827F90D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F90D8; continue 'dispatch;
            }
            0x827F90D8 => {
    //   block [0x827F90D8..0x827F90F4)
	// 827F90D8: 7CA92050  subf r5, r9, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 827F90DC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827F90E0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F90E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F90E8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F90EC: 48000A65  bl 0x827f9b50
	ctx.lr = 0x827F90F0;
	sub_827F9B50(ctx, base);
	// 827F90F0: 4800008C  b 0x827f917c
	pc = 0x827F917C; continue 'dispatch;
            }
            0x827F90F4 => {
    //   block [0x827F90F4..0x827F911C)
	// 827F90F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F90F8: 419A0084  beq cr6, 0x827f917c
	if ctx.cr[6].eq {
	pc = 0x827F917C; continue 'dispatch;
	}
	// 827F90FC: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9100: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F9104: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 827F9108: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F910C: 40980070  bge cr6, 0x827f917c
	if !ctx.cr[6].lt {
	pc = 0x827F917C; continue 'dispatch;
	}
	// 827F9110: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9114: 40990008  ble cr6, 0x827f911c
	if !ctx.cr[6].gt {
	pc = 0x827F911C; continue 'dispatch;
	}
	// 827F9118: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F911C; continue 'dispatch;
            }
            0x827F911C => {
    //   block [0x827F911C..0x827F9130)
	// 827F911C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 827F9120: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9124: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827F9128: 40990008  ble cr6, 0x827f9130
	if !ctx.cr[6].gt {
	pc = 0x827F9130; continue 'dispatch;
	}
	// 827F912C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9130; continue 'dispatch;
            }
            0x827F9130 => {
    //   block [0x827F9130..0x827F9160)
	// 827F9130: 548A1838  slwi r10, r4, 3
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F9134: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9138: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827F913C: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827F9140: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827F9144: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F9148: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F914C: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 827F9150: 41990010  bgt cr6, 0x827f9160
	if ctx.cr[6].gt {
	pc = 0x827F9160; continue 'dispatch;
	}
	// 827F9154: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9158: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F915C: 40980008  bge cr6, 0x827f9164
	if !ctx.cr[6].lt {
	pc = 0x827F9164; continue 'dispatch;
	}
	pc = 0x827F9160; continue 'dispatch;
            }
            0x827F9160 => {
    //   block [0x827F9160..0x827F9164)
	// 827F9160: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9164; continue 'dispatch;
            }
            0x827F9164 => {
    //   block [0x827F9164..0x827F917C)
	// 827F9164: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827F9168: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827F916C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827F9170: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827F9174: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F9178: 480D2181  bl 0x828cb2f8
	ctx.lr = 0x827F917C;
	sub_828CB2F8(ctx, base);
	pc = 0x827F917C; continue 'dispatch;
            }
            0x827F917C => {
    //   block [0x827F917C..0x827F9198)
	// 827F917C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9180: 4B9BE999  bl 0x821b7b18
	ctx.lr = 0x827F9184;
	sub_821B7B18(ctx, base);
	// 827F9184: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827F9188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F918C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F9190: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F9194: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9198 size=180
    let mut pc: u32 = 0x827F9198;
    'dispatch: loop {
        match pc {
            0x827F9198 => {
    //   block [0x827F9198..0x827F91F4)
	// 827F9198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F919C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827F91A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827F91A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F91A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F91AC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827F91B0: 419A0088  beq cr6, 0x827f9238
	if ctx.cr[6].eq {
	pc = 0x827F9238; continue 'dispatch;
	}
	// 827F91B4: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 827F91B8: 4B9BE961  bl 0x821b7b18
	ctx.lr = 0x827F91BC;
	sub_821B7B18(ctx, base);
	// 827F91BC: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 827F91C0: 4BBE3669  bl 0x823dc828
	ctx.lr = 0x827F91C4;
	sub_823DC828(ctx, base);
	// 827F91C4: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 827F91C8: 4BA1BC11  bl 0x82214dd8
	ctx.lr = 0x827F91CC;
	sub_82214DD8(ctx, base);
	// 827F91CC: 387F001C  addi r3, r31, 0x1c
	ctx.r[3].s64 = ctx.r[31].s64 + 28;
	// 827F91D0: 4B9BE949  bl 0x821b7b18
	ctx.lr = 0x827F91D4;
	sub_821B7B18(ctx, base);
	// 827F91D4: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 827F91D8: 4B9BE941  bl 0x821b7b18
	ctx.lr = 0x827F91DC;
	sub_821B7B18(ctx, base);
	// 827F91DC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827F91E0: 4BBE3649  bl 0x823dc828
	ctx.lr = 0x827F91E4;
	sub_823DC828(ctx, base);
	// 827F91E4: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F91E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827F91EC: 419A0044  beq cr6, 0x827f9230
	if ctx.cr[6].eq {
	pc = 0x827F9230; continue 'dispatch;
	}
	// 827F91F0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x827F91F4; continue 'dispatch;
            }
            0x827F91F4 => {
    //   block [0x827F91F4..0x827F9228)
	// 827F91F4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F91F8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F91FC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F9200: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827F9204: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9208: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F920C: 4082FFE8  bne 0x827f91f4
	if !ctx.cr[0].eq {
	pc = 0x827F91F4; continue 'dispatch;
	}
	// 827F9210: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827F9214: 409A0014  bne cr6, 0x827f9228
	if !ctx.cr[6].eq {
	pc = 0x827F9228; continue 'dispatch;
	}
	// 827F9218: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F921C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9220: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827F9224: 4E800421  bctrl
	ctx.lr = 0x827F9228;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827F9228 => {
    //   block [0x827F9228..0x827F9230)
	// 827F9228: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F922C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F9230; continue 'dispatch;
            }
            0x827F9230 => {
    //   block [0x827F9230..0x827F9238)
	// 827F9230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9234: 4BA22B05  bl 0x8221bd38
	ctx.lr = 0x827F9238;
	sub_8221BD38(ctx, base);
	pc = 0x827F9238; continue 'dispatch;
            }
            0x827F9238 => {
    //   block [0x827F9238..0x827F924C)
	// 827F9238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827F923C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827F9240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827F9244: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827F9248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9250(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827F9250 size=316
    let mut pc: u32 = 0x827F9250;
    'dispatch: loop {
        match pc {
            0x827F9250 => {
    //   block [0x827F9250..0x827F9288)
	// 827F9250: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9254: 484B01AD  bl 0x82ca9400
	ctx.lr = 0x827F9258;
	sub_82CA93D0(ctx, base);
	// 827F9258: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F925C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827F9260: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 827F9264: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827F9268: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827F926C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 827F9270: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9274: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9278: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F927C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F9280: 409A003C  bne cr6, 0x827f92bc
	if !ctx.cr[6].eq {
	pc = 0x827F92BC; continue 'dispatch;
	}
	// 827F9284: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F9288; continue 'dispatch;
            }
            0x827F9288 => {
    //   block [0x827F9288..0x827F92AC)
	// 827F9288: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F928C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827F9290: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 827F9294: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 827F9298: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 827F929C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F92A0: 419A000C  beq cr6, 0x827f92ac
	if ctx.cr[6].eq {
	pc = 0x827F92AC; continue 'dispatch;
	}
	// 827F92A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F92A8: 48000008  b 0x827f92b0
	pc = 0x827F92B0; continue 'dispatch;
            }
            0x827F92AC => {
    //   block [0x827F92AC..0x827F92B0)
	// 827F92AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x827F92B0; continue 'dispatch;
            }
            0x827F92B0 => {
    //   block [0x827F92B0..0x827F92BC)
	// 827F92B0: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F92B4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F92B8: 419AFFD0  beq cr6, 0x827f9288
	if ctx.cr[6].eq {
	pc = 0x827F9288; continue 'dispatch;
	}
	pc = 0x827F92BC; continue 'dispatch;
            }
            0x827F92BC => {
    //   block [0x827F92BC..0x827F931C)
	// 827F92BC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 827F92C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827F92C4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 827F92C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F92CC: 419A0054  beq cr6, 0x827f9320
	if ctx.cr[6].eq {
	pc = 0x827F9320; continue 'dispatch;
	}
	// 827F92D0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F92D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F92D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F92DC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F92E0: 409A003C  bne cr6, 0x827f931c
	if !ctx.cr[6].eq {
	pc = 0x827F931C; continue 'dispatch;
	}
	// 827F92E4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 827F92E8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F92EC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F92F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F92F4: 4800009D  bl 0x827f9390
	ctx.lr = 0x827F92F8;
	sub_827F9390(ctx, base);
	// 827F92F8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F92FC: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 827F9300: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9304: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9308: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F930C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F9310: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F9314: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F9318: 484B0138  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F931C => {
    //   block [0x827F931C..0x827F9320)
	// 827F931C: 4BE6722D  bl 0x82660548
	ctx.lr = 0x827F9320;
	sub_82660548(ctx, base);
	pc = 0x827F9320; continue 'dispatch;
            }
            0x827F9320 => {
    //   block [0x827F9320..0x827F9370)
	// 827F9320: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F9324: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9328: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F932C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9330: 40980040  bge cr6, 0x827f9370
	if !ctx.cr[6].lt {
	pc = 0x827F9370; continue 'dispatch;
	}
	// 827F9334: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 827F9338: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 827F933C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827F9340: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827F9344: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9348: 48000049  bl 0x827f9390
	ctx.lr = 0x827F934C;
	sub_827F9390(ctx, base);
	// 827F934C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F9350: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 827F9354: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9358: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F935C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9360: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F9364: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F9368: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F936C: 484B00E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F9370 => {
    //   block [0x827F9370..0x827F938C)
	// 827F9370: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F9374: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F9378: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F937C: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 827F9380: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 827F9384: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F9388: 484B00C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9390 size=672
    let mut pc: u32 = 0x827F9390;
    'dispatch: loop {
        match pc {
            0x827F9390 => {
    //   block [0x827F9390..0x827F9408)
	// 827F9390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9394: 484B0065  bl 0x82ca93f8
	ctx.lr = 0x827F9398;
	sub_82CA93D0(ctx, base);
	// 827F9398: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F939C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 827F93A0: 3D601555  lis r11, 0x1555
	ctx.r[11].s64 = 357892096;
	// 827F93A4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827F93A8: 61695554  ori r9, r11, 0x5554
	ctx.r[9].u64 = ctx.r[11].u64 | 21844;
	// 827F93AC: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827F93B0: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F93B4: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 827F93B8: 7CFF3B78  mr r31, r7
	ctx.r[31].u64 = ctx.r[7].u64;
	// 827F93BC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F93C0: 41980048  blt cr6, 0x827f9408
	if ctx.cr[6].lt {
	pc = 0x827F9408; continue 'dispatch;
	}
	// 827F93C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F93C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F93CC: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 827F93D0: 4BAF8B71  bl 0x822f1f40
	ctx.lr = 0x827F93D4;
	sub_822F1F40(ctx, base);
	// 827F93D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F93D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F93DC: 4BAF89D5  bl 0x822f1db0
	ctx.lr = 0x827F93E0;
	sub_822F1DB0(ctx, base);
	// 827F93E0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F93E4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F93E8: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 827F93EC: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 827F93F0: 4BAF8A31  bl 0x822f1e20
	ctx.lr = 0x827F93F4;
	sub_822F1E20(ctx, base);
	// 827F93F4: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 827F93F8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F93FC: 4BE823E5  bl 0x8267b7e0
	ctx.lr = 0x827F9400;
	sub_8267B7E0(ctx, base);
	// 827F9400: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9404: 4B97840D  bl 0x82171810
	ctx.lr = 0x827F9408;
	sub_82171810(ctx, base);
	pc = 0x827F9408; continue 'dispatch;
            }
            0x827F9408 => {
    //   block [0x827F9408..0x827F9454)
	// 827F9408: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 827F940C: 83BB0004  lwz r29, 4(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9410: 4BA25E49  bl 0x8221f258
	ctx.lr = 0x827F9414;
	sub_8221F258(ctx, base);
	// 827F9414: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827F9418: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 827F941C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827F9420: 419A0058  beq cr6, 0x827f9478
	if ctx.cr[6].eq {
	pc = 0x827F9478; continue 'dispatch;
	}
	// 827F9424: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827F9428: 397C000C  addi r11, r28, 0xc
	ctx.r[11].s64 = ctx.r[28].s64 + 12;
	// 827F942C: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827F9430: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 827F9434: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9438: 917C000C  stw r11, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 827F943C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9440: 915C0010  stw r10, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 827F9444: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F944C: 917C0014  stw r11, 0x14(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 827F9450: 419A0020  beq cr6, 0x827f9470
	if ctx.cr[6].eq {
	pc = 0x827F9470; continue 'dispatch;
	}
	pc = 0x827F9454; continue 'dispatch;
            }
            0x827F9454 => {
    //   block [0x827F9454..0x827F9470)
	// 827F9454: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F9458: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F945C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F9460: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F9464: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9468: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F946C: 4082FFE8  bne 0x827f9454
	if !ctx.cr[0].eq {
	pc = 0x827F9454; continue 'dispatch;
	}
	pc = 0x827F9470; continue 'dispatch;
            }
            0x827F9470 => {
    //   block [0x827F9470..0x827F9478)
	// 827F9470: 9B3C0018  stb r25, 0x18(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9474: 9B3C0019  stb r25, 0x19(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(25 as u32), ctx.r[25].u8 ) };
	pc = 0x827F9478; continue 'dispatch;
            }
            0x827F9478 => {
    //   block [0x827F9478..0x827F94A8)
	// 827F9478: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F947C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9480: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F9484: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9488: 915B0008  stw r10, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F948C: 409A001C  bne cr6, 0x827f94a8
	if !ctx.cr[6].eq {
	pc = 0x827F94A8; continue 'dispatch;
	}
	// 827F9490: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 827F9494: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9498: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F949C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F94A0: 938A0008  stw r28, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827F94A4: 48000044  b 0x827f94e8
	pc = 0x827F94E8; continue 'dispatch;
            }
            0x827F94A8 => {
    //   block [0x827F94A8..0x827F94D0)
	// 827F94A8: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 827F94AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F94B0: 419A0020  beq cr6, 0x827f94d0
	if ctx.cr[6].eq {
	pc = 0x827F94D0; continue 'dispatch;
	}
	// 827F94B4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F94B8: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F94BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F94C0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F94C4: 409A0024  bne cr6, 0x827f94e8
	if !ctx.cr[6].eq {
	pc = 0x827F94E8; continue 'dispatch;
	}
	// 827F94C8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F94CC: 4800001C  b 0x827f94e8
	pc = 0x827F94E8; continue 'dispatch;
            }
            0x827F94D0 => {
    //   block [0x827F94D0..0x827F94E8)
	// 827F94D0: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827F94D4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F94D8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F94DC: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F94E0: 409A0008  bne cr6, 0x827f94e8
	if !ctx.cr[6].eq {
	pc = 0x827F94E8; continue 'dispatch;
	}
	// 827F94E4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x827F94E8; continue 'dispatch;
            }
            0x827F94E8 => {
    //   block [0x827F94E8..0x827F9504)
	// 827F94E8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F94EC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 827F94F0: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 827F94F4: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 827F94F8: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F94FC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9500: 409A0110  bne cr6, 0x827f9610
	if !ctx.cr[6].eq {
	pc = 0x827F9610; continue 'dispatch;
	}
	pc = 0x827F9504; continue 'dispatch;
            }
            0x827F9504 => {
    //   block [0x827F9504..0x827F954C)
	// 827F9504: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9508: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F950C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9510: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F9514: 409A0078  bne cr6, 0x827f958c
	if !ctx.cr[6].eq {
	pc = 0x827F958C; continue 'dispatch;
	}
	// 827F9518: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F951C: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9520: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9524: 409A0028  bne cr6, 0x827f954c
	if !ctx.cr[6].eq {
	pc = 0x827F954C; continue 'dispatch;
	}
	// 827F9528: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 827F952C: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F9530: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F9534: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9538: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F953C: 9B270018  stb r25, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9540: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9544: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9548: 480000B4  b 0x827f95fc
	pc = 0x827F95FC; continue 'dispatch;
            }
            0x827F954C => {
    //   block [0x827F954C..0x827F9564)
	// 827F954C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9550: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9554: 409A0010  bne cr6, 0x827f9564
	if !ctx.cr[6].eq {
	pc = 0x827F9564; continue 'dispatch;
	}
	// 827F9558: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F955C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F9560: 48410F89  bl 0x82c0a4e8
	ctx.lr = 0x827F9564;
	sub_82C0A4E8(ctx, base);
	pc = 0x827F9564; continue 'dispatch;
            }
            0x827F9564 => {
    //   block [0x827F9564..0x827F958C)
	// 827F9564: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9568: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F956C: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F9570: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9574: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9578: 9B290018  stb r25, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F957C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9580: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9584: 48410FDD  bl 0x82c0a560
	ctx.lr = 0x827F9588;
	sub_82C0A560(ctx, base);
	// 827F9588: 48000074  b 0x827f95fc
	pc = 0x827F95FC; continue 'dispatch;
            }
            0x827F958C => {
    //   block [0x827F958C..0x827F95C0)
	// 827F958C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9590: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9594: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9598: 409A0028  bne cr6, 0x827f95c0
	if !ctx.cr[6].eq {
	pc = 0x827F95C0; continue 'dispatch;
	}
	// 827F959C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F95A0: 9BC90018  stb r30, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F95A4: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F95A8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F95AC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95B0: 9B270018  stb r25, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F95B4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F95B8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95BC: 48000040  b 0x827f95fc
	pc = 0x827F95FC; continue 'dispatch;
            }
            0x827F95C0 => {
    //   block [0x827F95C0..0x827F95D8)
	// 827F95C0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F95C4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F95C8: 409A0010  bne cr6, 0x827f95d8
	if !ctx.cr[6].eq {
	pc = 0x827F95D8; continue 'dispatch;
	}
	// 827F95CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F95D0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F95D4: 48410F8D  bl 0x82c0a560
	ctx.lr = 0x827F95D8;
	sub_82C0A560(ctx, base);
	pc = 0x827F95D8; continue 'dispatch;
            }
            0x827F95D8 => {
    //   block [0x827F95D8..0x827F95FC)
	// 827F95D8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F95E0: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F95E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95E8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95EC: 9B290018  stb r25, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F95F0: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95F4: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F95F8: 48410EF1  bl 0x82c0a4e8
	ctx.lr = 0x827F95FC;
	sub_82C0A4E8(ctx, base);
	pc = 0x827F95FC; continue 'dispatch;
            }
            0x827F95FC => {
    //   block [0x827F95FC..0x827F9610)
	// 827F95FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9600: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827F9604: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9608: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F960C: 419AFEF8  beq cr6, 0x827f9504
	if ctx.cr[6].eq {
	pc = 0x827F9504; continue 'dispatch;
	}
	pc = 0x827F9610; continue 'dispatch;
            }
            0x827F9610 => {
    //   block [0x827F9610..0x827F9630)
	// 827F9610: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9614: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F9618: 93980004  stw r28, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 827F961C: 93780000  stw r27, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827F9620: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9624: 9BCA0018  stb r30, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827F9628: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827F962C: 484AFE1C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9630 size=392
    let mut pc: u32 = 0x827F9630;
    'dispatch: loop {
        match pc {
            0x827F9630 => {
    //   block [0x827F9630..0x827F9670)
	// 827F9630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9634: 484AFDC1  bl 0x82ca93f4
	ctx.lr = 0x827F9638;
	sub_82CA93D0(ctx, base);
	// 827F9638: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F963C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F9640: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 827F9644: 3B4BBAFC  addi r26, r11, -0x4504
	ctx.r[26].s64 = ctx.r[11].s64 + -17668;
	// 827F9648: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F964C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 827F9650: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 827F9654: 833A0004  lwz r25, 4(r26)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9658: 7F3CCB78  mr r28, r25
	ctx.r[28].u64 = ctx.r[25].u64;
	// 827F965C: 83F90004  lwz r31, 4(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9660: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9668: 409A0078  bne cr6, 0x827f96e0
	if !ctx.cr[6].eq {
	pc = 0x827F96E0; continue 'dispatch;
	}
	// 827F966C: 83780000  lwz r27, 0(r24)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827F9670; continue 'dispatch;
            }
            0x827F9670 => {
    //   block [0x827F9670..0x827F9688)
	// 827F9670: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F9674: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 827F9678: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827F967C: 409A000C  bne cr6, 0x827f9688
	if !ctx.cr[6].eq {
	pc = 0x827F9688; continue 'dispatch;
	}
	// 827F9680: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F9684: 48000034  b 0x827f96b8
	pc = 0x827F96B8; continue 'dispatch;
            }
            0x827F9688 => {
    //   block [0x827F9688..0x827F9698)
	// 827F9688: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827F968C: 409A000C  bne cr6, 0x827f9698
	if !ctx.cr[6].eq {
	pc = 0x827F9698; continue 'dispatch;
	}
	// 827F9690: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 827F9694: 48000024  b 0x827f96b8
	pc = 0x827F96B8; continue 'dispatch;
            }
            0x827F9698 => {
    //   block [0x827F9698..0x827F96B8)
	// 827F9698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F969C: 419A001C  beq cr6, 0x827f96b8
	if ctx.cr[6].eq {
	pc = 0x827F96B8; continue 'dispatch;
	}
	// 827F96A0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F96A4: 807B0000  lwz r3, 0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F96A8: 4BA74151  bl 0x8226d7f8
	ctx.lr = 0x827F96AC;
	sub_8226D7F8(ctx, base);
	// 827F96AC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 827F96B0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 827F96B4: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x827F96B8; continue 'dispatch;
            }
            0x827F96B8 => {
    //   block [0x827F96B8..0x827F96D0)
	// 827F96B8: 556A063E  clrlwi r10, r11, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827F96BC: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827F96C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F96C4: 419A000C  beq cr6, 0x827f96d0
	if ctx.cr[6].eq {
	pc = 0x827F96D0; continue 'dispatch;
	}
	// 827F96C8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F96CC: 48000008  b 0x827f96d4
	pc = 0x827F96D4; continue 'dispatch;
            }
            0x827F96D0 => {
    //   block [0x827F96D0..0x827F96D4)
	// 827F96D0: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x827F96D4; continue 'dispatch;
            }
            0x827F96D4 => {
    //   block [0x827F96D4..0x827F96E0)
	// 827F96D4: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F96D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F96DC: 419AFF94  beq cr6, 0x827f9670
	if ctx.cr[6].eq {
	pc = 0x827F9670; continue 'dispatch;
	}
	pc = 0x827F96E0; continue 'dispatch;
            }
            0x827F96E0 => {
    //   block [0x827F96E0..0x827F973C)
	// 827F96E0: 57CB063E  clrlwi r11, r30, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x000000FFu64;
	// 827F96E4: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 827F96E8: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 827F96EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F96F0: 419A0050  beq cr6, 0x827f9740
	if ctx.cr[6].eq {
	pc = 0x827F9740; continue 'dispatch;
	}
	// 827F96F4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F96F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F96FC: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9700: 409A003C  bne cr6, 0x827f973c
	if !ctx.cr[6].eq {
	pc = 0x827F973C; continue 'dispatch;
	}
	// 827F9704: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827F9708: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 827F970C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F9710: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827F9714: 48000195  bl 0x827f98a8
	ctx.lr = 0x827F9718;
	sub_827F98A8(ctx, base);
	// 827F9718: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F971C: 9AFD0008  stb r23, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[23].u8 ) };
	// 827F9720: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F9724: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9728: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F972C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F9730: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F9734: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F9738: 484AFD0C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F973C => {
    //   block [0x827F973C..0x827F9740)
	// 827F973C: 4BE66E0D  bl 0x82660548
	ctx.lr = 0x827F9740;
	sub_82660548(ctx, base);
	pc = 0x827F9740; continue 'dispatch;
            }
            0x827F9740 => {
    //   block [0x827F9740..0x827F979C)
	// 827F9740: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827F9744: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827F9748: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 827F974C: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 827F9750: 4BFD9889  bl 0x827d2fd8
	ctx.lr = 0x827F9754;
	sub_827D2FD8(ctx, base);
	// 827F9754: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827F9758: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827F975C: 419A0040  beq cr6, 0x827f979c
	if ctx.cr[6].eq {
	pc = 0x827F979C; continue 'dispatch;
	}
	// 827F9760: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827F9764: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 827F9768: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827F976C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F9770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9774: 48000135  bl 0x827f98a8
	ctx.lr = 0x827F9778;
	sub_827F98A8(ctx, base);
	// 827F9778: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F977C: 9AFD0008  stb r23, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[23].u8 ) };
	// 827F9780: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F9784: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9788: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F978C: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827F9790: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827F9794: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F9798: 484AFCAC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F979C => {
    //   block [0x827F979C..0x827F97B8)
	// 827F979C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827F97A0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F97A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F97A8: 995D0008  stb r10, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 827F97AC: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 827F97B0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 827F97B4: 484AFC90  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F97B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F97B8 size=236
    let mut pc: u32 = 0x827F97B8;
    'dispatch: loop {
        match pc {
            0x827F97B8 => {
    //   block [0x827F97B8..0x827F97F4)
	// 827F97B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F97BC: 484AFC49  bl 0x82ca9404
	ctx.lr = 0x827F97C0;
	sub_82CA93D0(ctx, base);
	// 827F97C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F97C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F97C8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 827F97CC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 827F97D0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827F97D4: 3BEBBAFC  addi r31, r11, -0x4504
	ctx.r[31].s64 = ctx.r[11].s64 + -17668;
	// 827F97D8: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 827F97DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F97E0: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F97E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F97E8: 419A000C  beq cr6, 0x827f97f4
	if ctx.cr[6].eq {
	pc = 0x827F97F4; continue 'dispatch;
	}
	// 827F97EC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F97F0: 419A0008  beq cr6, 0x827f97f8
	if ctx.cr[6].eq {
	pc = 0x827F97F8; continue 'dispatch;
	}
	pc = 0x827F97F4; continue 'dispatch;
            }
            0x827F97F4 => {
    //   block [0x827F97F4..0x827F97F8)
	// 827F97F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F97F8; continue 'dispatch;
            }
            0x827F97F8 => {
    //   block [0x827F97F8..0x827F981C)
	// 827F97F8: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 827F97FC: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 827F9800: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 827F9804: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9808: 409A0044  bne cr6, 0x827f984c
	if !ctx.cr[6].eq {
	pc = 0x827F984C; continue 'dispatch;
	}
	// 827F980C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827F9810: 419A000C  beq cr6, 0x827f981c
	if ctx.cr[6].eq {
	pc = 0x827F981C; continue 'dispatch;
	}
	// 827F9814: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F9818: 419A0008  beq cr6, 0x827f9820
	if ctx.cr[6].eq {
	pc = 0x827F9820; continue 'dispatch;
	}
	pc = 0x827F981C; continue 'dispatch;
            }
            0x827F981C => {
    //   block [0x827F981C..0x827F9820)
	// 827F981C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9820; continue 'dispatch;
            }
            0x827F9820 => {
    //   block [0x827F9820..0x827F984C)
	// 827F9820: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F9824: 409A0028  bne cr6, 0x827f984c
	if !ctx.cr[6].eq {
	pc = 0x827F984C; continue 'dispatch;
	}
	// 827F9828: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F982C: 4BFFEFFD  bl 0x827f8828
	ctx.lr = 0x827F9830;
	sub_827F8828(ctx, base);
	// 827F9830: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9834: 93FD0000  stw r31, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 827F9838: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F983C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9840: 917D0004  stw r11, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827F9844: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F9848: 484AFC0C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F984C => {
    //   block [0x827F984C..0x827F985C)
	// 827F984C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9850: 419A000C  beq cr6, 0x827f985c
	if ctx.cr[6].eq {
	pc = 0x827F985C; continue 'dispatch;
	}
	// 827F9854: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827F9858: 419A0008  beq cr6, 0x827f9860
	if ctx.cr[6].eq {
	pc = 0x827F9860; continue 'dispatch;
	}
	pc = 0x827F985C; continue 'dispatch;
            }
            0x827F985C => {
    //   block [0x827F985C..0x827F9860)
	// 827F985C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827F9860; continue 'dispatch;
            }
            0x827F9860 => {
    //   block [0x827F9860..0x827F9894)
	// 827F9860: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 827F9864: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827F9868: 419A002C  beq cr6, 0x827f9894
	if ctx.cr[6].eq {
	pc = 0x827F9894; continue 'dispatch;
	}
	// 827F986C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 827F9870: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827F9874: 4BC4357D  bl 0x8243cdf0
	ctx.lr = 0x827F9878;
	sub_8243CDF0(ctx, base);
	// 827F9878: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827F987C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 827F9880: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9884: 48000645  bl 0x827f9ec8
	ctx.lr = 0x827F9888;
	sub_827F9EC8(ctx, base);
	// 827F9888: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 827F988C: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 827F9890: 4BFFFFBC  b 0x827f984c
	pc = 0x827F984C; continue 'dispatch;
            }
            0x827F9894 => {
    //   block [0x827F9894..0x827F98A4)
	// 827F9894: F8BD0000  std r5, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 827F9898: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827F989C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827F98A0: 484AFBB4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F98A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F98A8 size=676
    let mut pc: u32 = 0x827F98A8;
    'dispatch: loop {
        match pc {
            0x827F98A8 => {
    //   block [0x827F98A8..0x827F9924)
	// 827F98A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F98AC: 484AFB4D  bl 0x82ca93f8
	ctx.lr = 0x827F98B0;
	sub_82CA93D0(ctx, base);
	// 827F98B0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F98B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F98B8: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 827F98BC: 3BCBBAFC  addi r30, r11, -0x4504
	ctx.r[30].s64 = ctx.r[11].s64 + -17668;
	// 827F98C0: 61495554  ori r9, r10, 0x5554
	ctx.r[9].u64 = ctx.r[10].u64 | 21844;
	// 827F98C4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827F98C8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827F98CC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 827F98D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F98D4: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 827F98D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F98DC: 41980048  blt cr6, 0x827f9924
	if ctx.cr[6].lt {
	pc = 0x827F9924; continue 'dispatch;
	}
	// 827F98E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F98E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F98E8: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 827F98EC: 4BAF8655  bl 0x822f1f40
	ctx.lr = 0x827F98F0;
	sub_822F1F40(ctx, base);
	// 827F98F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F98F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F98F8: 4BAF84B9  bl 0x822f1db0
	ctx.lr = 0x827F98FC;
	sub_822F1DB0(ctx, base);
	// 827F98FC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F9900: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F9904: 3B8A1720  addi r28, r10, 0x1720
	ctx.r[28].s64 = ctx.r[10].s64 + 5920;
	// 827F9908: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 827F990C: 4BAF8515  bl 0x822f1e20
	ctx.lr = 0x827F9910;
	sub_822F1E20(ctx, base);
	// 827F9910: 93810070  stw r28, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u32 ) };
	// 827F9914: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F9918: 4BE81EC9  bl 0x8267b7e0
	ctx.lr = 0x827F991C;
	sub_8267B7E0(ctx, base);
	// 827F991C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9920: 4B977EF1  bl 0x82171810
	ctx.lr = 0x827F9924;
	sub_82171810(ctx, base);
	pc = 0x827F9924; continue 'dispatch;
            }
            0x827F9924 => {
    //   block [0x827F9924..0x827F9970)
	// 827F9924: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 827F9928: 839E0004  lwz r28, 4(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F992C: 4BA2592D  bl 0x8221f258
	ctx.lr = 0x827F9930;
	sub_8221F258(ctx, base);
	// 827F9930: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F9934: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 827F9938: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827F993C: 419A0058  beq cr6, 0x827f9994
	if ctx.cr[6].eq {
	pc = 0x827F9994; continue 'dispatch;
	}
	// 827F9940: 939B0000  stw r28, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F9944: 387B000C  addi r3, r27, 0xc
	ctx.r[3].s64 = ctx.r[27].s64 + 12;
	// 827F9948: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F994C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F9950: 939B0008  stw r28, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 827F9954: 4B9F68ED  bl 0x821f0240
	ctx.lr = 0x827F9958;
	sub_821F0240(ctx, base);
	// 827F9958: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F995C: 917B0010  stw r11, 0x10(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 827F9960: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9968: 917B0014  stw r11, 0x14(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 827F996C: 419A0020  beq cr6, 0x827f998c
	if ctx.cr[6].eq {
	pc = 0x827F998C; continue 'dispatch;
	}
	pc = 0x827F9970; continue 'dispatch;
            }
            0x827F9970 => {
    //   block [0x827F9970..0x827F998C)
	// 827F9970: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F9974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9978: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F997C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F9980: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9984: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9988: 4082FFE8  bne 0x827f9970
	if !ctx.cr[0].eq {
	pc = 0x827F9970; continue 'dispatch;
	}
	pc = 0x827F998C; continue 'dispatch;
            }
            0x827F998C => {
    //   block [0x827F998C..0x827F9994)
	// 827F998C: 9B3B0018  stb r25, 0x18(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9990: 9B3B0019  stb r25, 0x19(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(25 as u32), ctx.r[25].u8 ) };
	pc = 0x827F9994; continue 'dispatch;
            }
            0x827F9994 => {
    //   block [0x827F9994..0x827F99C0)
	// 827F9994: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9998: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F999C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F99A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F99A4: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827F99A8: 409A0018  bne cr6, 0x827f99c0
	if !ctx.cr[6].eq {
	pc = 0x827F99C0; continue 'dispatch;
	}
	// 827F99AC: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 827F99B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F99B4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827F99B8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F99BC: 48000044  b 0x827f9a00
	pc = 0x827F9A00; continue 'dispatch;
            }
            0x827F99C0 => {
    //   block [0x827F99C0..0x827F99EC)
	// 827F99C0: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 827F99C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F99C8: 419A0024  beq cr6, 0x827f99ec
	if ctx.cr[6].eq {
	pc = 0x827F99EC; continue 'dispatch;
	}
	// 827F99CC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827F99D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F99D4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F99D8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F99DC: 409A0028  bne cr6, 0x827f9a04
	if !ctx.cr[6].eq {
	pc = 0x827F9A04; continue 'dispatch;
	}
	// 827F99E0: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F99E4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827F99E8: 4800001C  b 0x827f9a04
	pc = 0x827F9A04; continue 'dispatch;
            }
            0x827F99EC => {
    //   block [0x827F99EC..0x827F9A00)
	// 827F99EC: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 827F99F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F99F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F99F8: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827F99FC: 409A0008  bne cr6, 0x827f9a04
	if !ctx.cr[6].eq {
	pc = 0x827F9A04; continue 'dispatch;
	}
	pc = 0x827F9A00; continue 'dispatch;
            }
            0x827F9A00 => {
    //   block [0x827F9A00..0x827F9A04)
	// 827F9A00: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x827F9A04; continue 'dispatch;
            }
            0x827F9A04 => {
    //   block [0x827F9A04..0x827F9A20)
	// 827F9A04: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A08: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 827F9A0C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 827F9A10: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 827F9A14: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9A18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9A1C: 409A0110  bne cr6, 0x827f9b2c
	if !ctx.cr[6].eq {
	pc = 0x827F9B2C; continue 'dispatch;
	}
	pc = 0x827F9A20; continue 'dispatch;
            }
            0x827F9A20 => {
    //   block [0x827F9A20..0x827F9A68)
	// 827F9A20: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9A24: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A28: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9A2C: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F9A30: 409A0078  bne cr6, 0x827f9aa8
	if !ctx.cr[6].eq {
	pc = 0x827F9AA8; continue 'dispatch;
	}
	// 827F9A34: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9A38: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9A3C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9A40: 409A0028  bne cr6, 0x827f9a68
	if !ctx.cr[6].eq {
	pc = 0x827F9A68; continue 'dispatch;
	}
	// 827F9A44: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 827F9A48: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9A4C: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9A50: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9A54: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A58: 9B270018  stb r25, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9A5C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9A60: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A64: 480000B4  b 0x827f9b18
	pc = 0x827F9B18; continue 'dispatch;
            }
            0x827F9A68 => {
    //   block [0x827F9A68..0x827F9A80)
	// 827F9A68: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9A6C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9A70: 409A0010  bne cr6, 0x827f9a80
	if !ctx.cr[6].eq {
	pc = 0x827F9A80; continue 'dispatch;
	}
	// 827F9A74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9A78: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F9A7C: 480008B5  bl 0x827fa330
	ctx.lr = 0x827F9A80;
	sub_827FA330(ctx, base);
	pc = 0x827F9A80; continue 'dispatch;
            }
            0x827F9A80 => {
    //   block [0x827F9A80..0x827F9AA8)
	// 827F9A80: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9A88: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9A8C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A90: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A94: 9B290018  stb r25, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9A98: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9A9C: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9AA0: 48000911  bl 0x827fa3b0
	ctx.lr = 0x827F9AA4;
	sub_827FA3B0(ctx, base);
	// 827F9AA4: 48000074  b 0x827f9b18
	pc = 0x827F9B18; continue 'dispatch;
            }
            0x827F9AA8 => {
    //   block [0x827F9AA8..0x827F9ADC)
	// 827F9AA8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9AAC: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9AB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9AB4: 409A0028  bne cr6, 0x827f9adc
	if !ctx.cr[6].eq {
	pc = 0x827F9ADC; continue 'dispatch;
	}
	// 827F9AB8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9ABC: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9AC0: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9AC4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9AC8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9ACC: 9B270018  stb r25, 0x18(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9AD0: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9AD4: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9AD8: 48000040  b 0x827f9b18
	pc = 0x827F9B18; continue 'dispatch;
            }
            0x827F9ADC => {
    //   block [0x827F9ADC..0x827F9AF4)
	// 827F9ADC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9AE0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9AE4: 409A0010  bne cr6, 0x827f9af4
	if !ctx.cr[6].eq {
	pc = 0x827F9AF4; continue 'dispatch;
	}
	// 827F9AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9AEC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827F9AF0: 480008C1  bl 0x827fa3b0
	ctx.lr = 0x827F9AF4;
	sub_827FA3B0(ctx, base);
	pc = 0x827F9AF4; continue 'dispatch;
            }
            0x827F9AF4 => {
    //   block [0x827F9AF4..0x827F9B18)
	// 827F9AF4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9AF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9AFC: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9B00: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B04: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B08: 9B290018  stb r25, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[25].u8 ) };
	// 827F9B0C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B10: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B14: 4800081D  bl 0x827fa330
	ctx.lr = 0x827F9B18;
	sub_827FA330(ctx, base);
	pc = 0x827F9B18; continue 'dispatch;
            }
            0x827F9B18 => {
    //   block [0x827F9B18..0x827F9B2C)
	// 827F9B18: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B1C: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 827F9B20: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827F9B24: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9B28: 419AFEF8  beq cr6, 0x827f9a20
	if ctx.cr[6].eq {
	pc = 0x827F9A20; continue 'dispatch;
	}
	pc = 0x827F9B2C; continue 'dispatch;
            }
            0x827F9B2C => {
    //   block [0x827F9B2C..0x827F9B4C)
	// 827F9B2C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B30: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827F9B34: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 827F9B38: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 827F9B3C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B40: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827F9B44: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827F9B48: 484AF900  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9B50 size=884
    let mut pc: u32 = 0x827F9B50;
    'dispatch: loop {
        match pc {
            0x827F9B50 => {
    //   block [0x827F9B50..0x827F9B80)
	// 827F9B50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9B54: 484AF8A5  bl 0x82ca93f8
	ctx.lr = 0x827F9B58;
	sub_82CA93D0(ctx, base);
	// 827F9B58: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F9B5C: 83260004  lwz r25, 4(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9B60: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827F9B64: 83060000  lwz r24, 0(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9B68: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827F9B6C: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 827F9B70: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827F9B74: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 827F9B78: 93010050  stw r24, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u32 ) };
	// 827F9B7C: 419A0020  beq cr6, 0x827f9b9c
	if ctx.cr[6].eq {
	pc = 0x827F9B9C; continue 'dispatch;
	}
	pc = 0x827F9B80; continue 'dispatch;
            }
            0x827F9B80 => {
    //   block [0x827F9B80..0x827F9B9C)
	// 827F9B80: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827F9B84: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9B88: 7D60C828  lwarx r11, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827F9B8C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F9B90: 7D60C92D  stwcx. r11, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9B94: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9B98: 4082FFE8  bne 0x827f9b80
	if !ctx.cr[0].eq {
	pc = 0x827F9B80; continue 'dispatch;
	}
	pc = 0x827F9B9C; continue 'dispatch;
            }
            0x827F9B9C => {
    //   block [0x827F9B9C..0x827F9BB0)
	// 827F9B9C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9BA0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F9BA4: 409A000C  bne cr6, 0x827f9bb0
	if !ctx.cr[6].eq {
	pc = 0x827F9BB0; continue 'dispatch;
	}
	// 827F9BA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 827F9BAC: 48000010  b 0x827f9bbc
	pc = 0x827F9BBC; continue 'dispatch;
            }
            0x827F9BB0 => {
    //   block [0x827F9BB0..0x827F9BBC)
	// 827F9BB0: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 827F9BB4: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F9BB8: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x827F9BBC; continue 'dispatch;
            }
            0x827F9BBC => {
    //   block [0x827F9BBC..0x827F9BD4)
	// 827F9BBC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F9BC0: 419A02F4  beq cr6, 0x827f9eb4
	if ctx.cr[6].eq {
	pc = 0x827F9EB4; continue 'dispatch;
	}
	// 827F9BC4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F9BC8: 409A000C  bne cr6, 0x827f9bd4
	if !ctx.cr[6].eq {
	pc = 0x827F9BD4; continue 'dispatch;
	}
	// 827F9BCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F9BD0: 48000010  b 0x827f9be0
	pc = 0x827F9BE0; continue 'dispatch;
            }
            0x827F9BD4 => {
    //   block [0x827F9BD4..0x827F9BE0)
	// 827F9BD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9BD8: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F9BDC: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x827F9BE0; continue 'dispatch;
            }
            0x827F9BE0 => {
    //   block [0x827F9BE0..0x827F9C08)
	// 827F9BE0: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 827F9BE4: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 827F9BE8: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F9BEC: 7F07E840  cmplw cr6, r7, r29
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F9BF0: 40980018  bge cr6, 0x827f9c08
	if !ctx.cr[6].lt {
	pc = 0x827F9C08; continue 'dispatch;
	}
	// 827F9BF4: 4BCFAEDD  bl 0x824f4ad0
	ctx.lr = 0x827F9BF8;
	sub_824F4AD0(ctx, base);
	// 827F9BF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9BFC: 4B9BDF1D  bl 0x821b7b18
	ctx.lr = 0x827F9C00;
	sub_821B7B18(ctx, base);
	// 827F9C00: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F9C04: 484AF844  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F9C08 => {
    //   block [0x827F9C08..0x827F9C18)
	// 827F9C08: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F9C0C: 409A000C  bne cr6, 0x827f9c18
	if !ctx.cr[6].eq {
	pc = 0x827F9C18; continue 'dispatch;
	}
	// 827F9C10: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F9C14: 48000010  b 0x827f9c24
	pc = 0x827F9C24; continue 'dispatch;
            }
            0x827F9C18 => {
    //   block [0x827F9C18..0x827F9C24)
	// 827F9C18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9C1C: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F9C20: 7CEB1E70  srawi r11, r7, 3
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 3) as i64;
	pc = 0x827F9C24; continue 'dispatch;
            }
            0x827F9C24 => {
    //   block [0x827F9C24..0x827F9C48)
	// 827F9C24: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 827F9C28: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9C2C: 40980174  bge cr6, 0x827f9da0
	if !ctx.cr[6].lt {
	pc = 0x827F9DA0; continue 'dispatch;
	}
	// 827F9C30: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F9C34: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 827F9C38: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F9C3C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827F9C40: 41980008  blt cr6, 0x827f9c48
	if ctx.cr[6].lt {
	pc = 0x827F9C48; continue 'dispatch;
	}
	// 827F9C44: 7F4B4A14  add r26, r11, r9
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x827F9C48; continue 'dispatch;
            }
            0x827F9C48 => {
    //   block [0x827F9C48..0x827F9C58)
	// 827F9C48: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F9C4C: 409A000C  bne cr6, 0x827f9c58
	if !ctx.cr[6].eq {
	pc = 0x827F9C58; continue 'dispatch;
	}
	// 827F9C50: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F9C54: 48000010  b 0x827f9c64
	pc = 0x827F9C64; continue 'dispatch;
            }
            0x827F9C58 => {
    //   block [0x827F9C58..0x827F9C64)
	// 827F9C58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9C5C: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F9C60: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x827F9C64; continue 'dispatch;
            }
            0x827F9C64 => {
    //   block [0x827F9C64..0x827F9C80)
	// 827F9C64: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 827F9C68: 7F1A5840  cmplw cr6, r26, r11
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827F9C6C: 40980024  bge cr6, 0x827f9c90
	if !ctx.cr[6].lt {
	pc = 0x827F9C90; continue 'dispatch;
	}
	// 827F9C70: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827F9C74: 409A000C  bne cr6, 0x827f9c80
	if !ctx.cr[6].eq {
	pc = 0x827F9C80; continue 'dispatch;
	}
	// 827F9C78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827F9C7C: 48000010  b 0x827f9c8c
	pc = 0x827F9C8C; continue 'dispatch;
            }
            0x827F9C80 => {
    //   block [0x827F9C80..0x827F9C8C)
	// 827F9C80: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9C84: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 827F9C88: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	pc = 0x827F9C8C; continue 'dispatch;
            }
            0x827F9C8C => {
    //   block [0x827F9C8C..0x827F9C90)
	// 827F9C8C: 7F4BEA14  add r26, r11, r29
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x827F9C90; continue 'dispatch;
            }
            0x827F9C90 => {
    //   block [0x827F9C90..0x827F9CC8)
	// 827F9C90: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827F9C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9C98: 482B6CC1  bl 0x82ab0958
	ctx.lr = 0x827F9C9C;
	sub_82AB0958(ctx, base);
	// 827F9C9C: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 827F9CA0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 827F9CA4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9CA8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F9CAC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827F9CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9CB4: 4BC86F8D  bl 0x82480c40
	ctx.lr = 0x827F9CB8;
	sub_82480C40(ctx, base);
	// 827F9CB8: 7FA903A6  mtctr r29
	ctx.ctr.u64 = ctx.r[29].u64;
	// 827F9CBC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827F9CC0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827F9CC4: 419A0040  beq cr6, 0x827f9d04
	if ctx.cr[6].eq {
	pc = 0x827F9D04; continue 'dispatch;
	}
	pc = 0x827F9CC8; continue 'dispatch;
            }
            0x827F9CC8 => {
    //   block [0x827F9CC8..0x827F9CE0)
	// 827F9CC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9CCC: 419A0030  beq cr6, 0x827f9cfc
	if ctx.cr[6].eq {
	pc = 0x827F9CFC; continue 'dispatch;
	}
	// 827F9CD0: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 827F9CD4: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827F9CD8: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 827F9CDC: 419A0020  beq cr6, 0x827f9cfc
	if ctx.cr[6].eq {
	pc = 0x827F9CFC; continue 'dispatch;
	}
	pc = 0x827F9CE0; continue 'dispatch;
            }
            0x827F9CE0 => {
    //   block [0x827F9CE0..0x827F9CFC)
	// 827F9CE0: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827F9CE4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9CE8: 7D40C828  lwarx r10, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827F9CEC: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 827F9CF0: 7D40C92D  stwcx. r10, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9CF4: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9CF8: 4082FFE8  bne 0x827f9ce0
	if !ctx.cr[0].eq {
	pc = 0x827F9CE0; continue 'dispatch;
	}
	pc = 0x827F9CFC; continue 'dispatch;
            }
            0x827F9CFC => {
    //   block [0x827F9CFC..0x827F9D04)
	// 827F9CFC: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 827F9D00: 4200FFC8  bdnz 0x827f9cc8
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x827F9CC8; continue 'dispatch;
	}
	pc = 0x827F9D04; continue 'dispatch;
            }
            0x827F9D04 => {
    //   block [0x827F9D04..0x827F9D30)
	// 827F9D04: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F9D08: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9D0C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827F9D10: 7CCB1A14  add r6, r11, r3
	ctx.r[6].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 827F9D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9D18: 4BC86F29  bl 0x82480c40
	ctx.lr = 0x827F9D1C;
	sub_82480C40(ctx, base);
	// 827F9D1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9D20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9D24: 409A000C  bne cr6, 0x827f9d30
	if !ctx.cr[6].eq {
	pc = 0x827F9D30; continue 'dispatch;
	}
	// 827F9D28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827F9D2C: 48000010  b 0x827f9d3c
	pc = 0x827F9D3C; continue 'dispatch;
            }
            0x827F9D30 => {
    //   block [0x827F9D30..0x827F9D3C)
	// 827F9D30: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9D34: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 827F9D38: 7D2A1E70  srawi r10, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x827F9D3C; continue 'dispatch;
            }
            0x827F9D3C => {
    //   block [0x827F9D3C..0x827F9D58)
	// 827F9D3C: 7F8AEA14  add r28, r10, r29
	ctx.r[28].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 827F9D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9D44: 419A0030  beq cr6, 0x827f9d74
	if ctx.cr[6].eq {
	pc = 0x827F9D74; continue 'dispatch;
	}
	// 827F9D48: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9D4C: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 827F9D50: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F9D54: 419A0018  beq cr6, 0x827f9d6c
	if ctx.cr[6].eq {
	pc = 0x827F9D6C; continue 'dispatch;
	}
	pc = 0x827F9D58; continue 'dispatch;
            }
            0x827F9D58 => {
    //   block [0x827F9D58..0x827F9D6C)
	// 827F9D58: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9D5C: 4B9BDDBD  bl 0x821b7b18
	ctx.lr = 0x827F9D60;
	sub_821B7B18(ctx, base);
	// 827F9D60: 3BDE0008  addi r30, r30, 8
	ctx.r[30].s64 = ctx.r[30].s64 + 8;
	// 827F9D64: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F9D68: 409AFFF0  bne cr6, 0x827f9d58
	if !ctx.cr[6].eq {
	pc = 0x827F9D58; continue 'dispatch;
	}
	pc = 0x827F9D6C; continue 'dispatch;
            }
            0x827F9D6C => {
    //   block [0x827F9D6C..0x827F9D74)
	// 827F9D6C: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9D70: 4BA21FC9  bl 0x8221bd38
	ctx.lr = 0x827F9D74;
	sub_8221BD38(ctx, base);
	pc = 0x827F9D74; continue 'dispatch;
            }
            0x827F9D74 => {
    //   block [0x827F9D74..0x827F9DA0)
	// 827F9D74: 578B1838  slwi r11, r28, 3
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827F9D78: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 827F9D7C: 574A1838  slwi r10, r26, 3
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827F9D80: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 827F9D84: 7D4ADA14  add r10, r10, r27
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 827F9D88: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 827F9D8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9D90: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 827F9D94: 4B9BDD85  bl 0x821b7b18
	ctx.lr = 0x827F9D98;
	sub_821B7B18(ctx, base);
	// 827F9D98: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F9D9C: 484AF6AC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x827F9DA0 => {
    //   block [0x827F9DA0..0x827F9DE4)
	// 827F9DA0: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 827F9DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827F9DA8: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9DAC: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 827F9DB0: 7D6A1E70  srawi r10, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 827F9DB4: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F9DB8: 40980080  bge cr6, 0x827f9e38
	if !ctx.cr[6].lt {
	pc = 0x827F9E38; continue 'dispatch;
	}
	// 827F9DBC: 57BC1838  slwi r28, r29, 3
	ctx.r[28].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 827F9DC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F9DC4: 7CDCDA14  add r6, r28, r27
	ctx.r[6].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 827F9DC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827F9DCC: 4BC86E75  bl 0x82480c40
	ctx.lr = 0x827F9DD0;
	sub_82480C40(ctx, base);
	// 827F9DD0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9DD4: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 827F9DD8: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 827F9DDC: 7D49E851  subf. r10, r9, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F9DE0: 41820044  beq 0x827f9e24
	if ctx.cr[0].eq {
	pc = 0x827F9E24; continue 'dispatch;
	}
	pc = 0x827F9DE4; continue 'dispatch;
            }
            0x827F9DE4 => {
    //   block [0x827F9DE4..0x827F9DFC)
	// 827F9DE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9DE8: 419A0030  beq cr6, 0x827f9e18
	if ctx.cr[6].eq {
	pc = 0x827F9E18; continue 'dispatch;
	}
	// 827F9DEC: 930B0000  stw r24, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[24].u32 ) };
	// 827F9DF0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 827F9DF4: 932B0004  stw r25, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 827F9DF8: 419A0020  beq cr6, 0x827f9e18
	if ctx.cr[6].eq {
	pc = 0x827F9E18; continue 'dispatch;
	}
	pc = 0x827F9DFC; continue 'dispatch;
            }
            0x827F9DFC => {
    //   block [0x827F9DFC..0x827F9E18)
	// 827F9DFC: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827F9E00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9E04: 7D20C828  lwarx r9, 0, r25
	// lwarx
	let ea = ctx.r[25].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827F9E08: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 827F9E0C: 7D20C92D  stwcx. r9, 0, r25
	// stwcx.
	let addr = ctx.r[25].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827F9E10: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827F9E14: 4082FFE8  bne 0x827f9dfc
	if !ctx.cr[0].eq {
	pc = 0x827F9DFC; continue 'dispatch;
	}
	pc = 0x827F9E18; continue 'dispatch;
            }
            0x827F9E18 => {
    //   block [0x827F9E18..0x827F9E24)
	// 827F9E18: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 827F9E1C: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 827F9E20: 4082FFC4  bne 0x827f9de4
	if !ctx.cr[0].eq {
	pc = 0x827F9DE4; continue 'dispatch;
	}
	pc = 0x827F9E24; continue 'dispatch;
            }
            0x827F9E24 => {
    //   block [0x827F9E24..0x827F9E38)
	// 827F9E24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9E28: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 827F9E2C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827F9E30: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 827F9E34: 48000074  b 0x827f9ea8
	pc = 0x827F9EA8; continue 'dispatch;
            }
            0x827F9E38 => {
    //   block [0x827F9E38..0x827F9E5C)
	// 827F9E38: 57BA1838  slwi r26, r29, 3
	ctx.r[26].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[26].u64 = ctx.r[26].u32 as u64;
	// 827F9E3C: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 827F9E40: 7FBAF050  subf r29, r26, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[26].s64;
	// 827F9E44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827F9E48: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827F9E4C: 4BC86DF5  bl 0x82480c40
	ctx.lr = 0x827F9E50;
	sub_82480C40(ctx, base);
	// 827F9E50: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 827F9E54: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827F9E58: 419A004C  beq cr6, 0x827f9ea4
	if ctx.cr[6].eq {
	pc = 0x827F9EA4; continue 'dispatch;
	}
	pc = 0x827F9E5C; continue 'dispatch;
            }
            0x827F9E5C => {
    //   block [0x827F9E5C..0x827F9E9C)
	// 827F9E5C: 3BBDFFF8  addi r29, r29, -8
	ctx.r[29].s64 = ctx.r[29].s64 + -8;
	// 827F9E60: 3BDEFFF8  addi r30, r30, -8
	ctx.r[30].s64 = ctx.r[30].s64 + -8;
	// 827F9E64: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9E68: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9E6C: 839D0000  lwz r28, 0(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9E70: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827F9E74: 419A0028  beq cr6, 0x827f9e9c
	if ctx.cr[6].eq {
	pc = 0x827F9E9C; continue 'dispatch;
	}
	// 827F9E78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827F9E7C: 4B9BDC9D  bl 0x821b7b18
	ctx.lr = 0x827F9E80;
	sub_821B7B18(ctx, base);
	// 827F9E80: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 827F9E84: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827F9E88: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827F9E8C: 419A0010  beq cr6, 0x827f9e9c
	if ctx.cr[6].eq {
	pc = 0x827F9E9C; continue 'dispatch;
	}
	// 827F9E90: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9E94: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827F9E98: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827F9E9C; continue 'dispatch;
            }
            0x827F9E9C => {
    //   block [0x827F9E9C..0x827F9EA4)
	// 827F9E9C: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827F9EA0: 409AFFBC  bne cr6, 0x827f9e5c
	if !ctx.cr[6].eq {
	pc = 0x827F9E5C; continue 'dispatch;
	}
	pc = 0x827F9EA4; continue 'dispatch;
            }
            0x827F9EA4 => {
    //   block [0x827F9EA4..0x827F9EA8)
	// 827F9EA4: 7C9ADA14  add r4, r26, r27
	ctx.r[4].u64 = ctx.r[26].u64 + ctx.r[27].u64;
	pc = 0x827F9EA8; continue 'dispatch;
            }
            0x827F9EA8 => {
    //   block [0x827F9EA8..0x827F9EB4)
	// 827F9EA8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827F9EAC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827F9EB0: 4BEF6671  bl 0x826f0520
	ctx.lr = 0x827F9EB4;
	sub_826F0520(ctx, base);
	pc = 0x827F9EB4; continue 'dispatch;
            }
            0x827F9EB4 => {
    //   block [0x827F9EB4..0x827F9EC4)
	// 827F9EB4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9EB8: 4B9BDC61  bl 0x821b7b18
	ctx.lr = 0x827F9EBC;
	sub_821B7B18(ctx, base);
	// 827F9EBC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827F9EC0: 484AF588  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827F9EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827F9EC8 size=1124
    let mut pc: u32 = 0x827F9EC8;
    'dispatch: loop {
        match pc {
            0x827F9EC8 => {
    //   block [0x827F9EC8..0x827F9F30)
	// 827F9EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827F9ECC: 484AF531  bl 0x82ca93fc
	ctx.lr = 0x827F9ED0;
	sub_82CA93D0(ctx, base);
	// 827F9ED0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827F9ED4: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 827F9ED8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827F9EDC: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 827F9EE0: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9EE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9EE8: 419A0048  beq cr6, 0x827f9f30
	if ctx.cr[6].eq {
	pc = 0x827F9F30; continue 'dispatch;
	}
	// 827F9EEC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827F9EF0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9EF4: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 827F9EF8: 4BAF8049  bl 0x822f1f40
	ctx.lr = 0x827F9EFC;
	sub_822F1F40(ctx, base);
	// 827F9EFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827F9F00: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F9F04: 4BAF7EAD  bl 0x822f1db0
	ctx.lr = 0x827F9F08;
	sub_822F1DB0(ctx, base);
	// 827F9F08: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 827F9F0C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F9F10: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 827F9F14: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 827F9F18: 4BAF7F09  bl 0x822f1e20
	ctx.lr = 0x827F9F1C;
	sub_822F1E20(ctx, base);
	// 827F9F1C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 827F9F20: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827F9F24: 4BE818BD  bl 0x8267b7e0
	ctx.lr = 0x827F9F28;
	sub_8267B7E0(ctx, base);
	// 827F9F28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827F9F2C: 4B9778E5  bl 0x82171810
	ctx.lr = 0x827F9F30;
	sub_82171810(ctx, base);
	pc = 0x827F9F30; continue 'dispatch;
            }
            0x827F9F30 => {
    //   block [0x827F9F30..0x827F9F54)
	// 827F9F30: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 827F9F34: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 827F9F38: 4BC42EB9  bl 0x8243cdf0
	ctx.lr = 0x827F9F3C;
	sub_8243CDF0(ctx, base);
	// 827F9F3C: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9F40: 896A0019  lbz r11, 0x19(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9F44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9F48: 419A000C  beq cr6, 0x827f9f54
	if ctx.cr[6].eq {
	pc = 0x827F9F54; continue 'dispatch;
	}
	// 827F9F4C: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9F50: 4800002C  b 0x827f9f7c
	pc = 0x827F9F7C; continue 'dispatch;
            }
            0x827F9F54 => {
    //   block [0x827F9F54..0x827F9F6C)
	// 827F9F54: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9F58: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9F5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9F60: 419A000C  beq cr6, 0x827f9f6c
	if ctx.cr[6].eq {
	pc = 0x827F9F6C; continue 'dispatch;
	}
	// 827F9F64: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 827F9F68: 48000014  b 0x827f9f7c
	pc = 0x827F9F7C; continue 'dispatch;
            }
            0x827F9F6C => {
    //   block [0x827F9F6C..0x827F9F7C)
	// 827F9F6C: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 827F9F70: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F9F74: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827F9F78: 409A00FC  bne cr6, 0x827fa074
	if !ctx.cr[6].eq {
	pc = 0x827FA074; continue 'dispatch;
	}
	pc = 0x827F9F7C; continue 'dispatch;
            }
            0x827F9F7C => {
    //   block [0x827F9F7C..0x827F9F90)
	// 827F9F7C: 897B0019  lbz r11, 0x19(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9F80: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9F84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9F88: 409A0008  bne cr6, 0x827f9f90
	if !ctx.cr[6].eq {
	pc = 0x827F9F90; continue 'dispatch;
	}
	// 827F9F8C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x827F9F90; continue 'dispatch;
            }
            0x827F9F90 => {
    //   block [0x827F9F90..0x827F9FB0)
	// 827F9F90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827F9F94: 3B8BBAFC  addi r28, r11, -0x4504
	ctx.r[28].s64 = ctx.r[11].s64 + -17668;
	// 827F9F98: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9F9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9FA0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F9FA4: 409A000C  bne cr6, 0x827f9fb0
	if !ctx.cr[6].eq {
	pc = 0x827F9FB0; continue 'dispatch;
	}
	// 827F9FA8: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 827F9FAC: 4800001C  b 0x827f9fc8
	pc = 0x827F9FC8; continue 'dispatch;
            }
            0x827F9FB0 => {
    //   block [0x827F9FB0..0x827F9FC4)
	// 827F9FB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9FB4: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F9FB8: 409A000C  bne cr6, 0x827f9fc4
	if !ctx.cr[6].eq {
	pc = 0x827F9FC4; continue 'dispatch;
	}
	// 827F9FBC: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827F9FC0: 48000008  b 0x827f9fc8
	pc = 0x827F9FC8; continue 'dispatch;
            }
            0x827F9FC4 => {
    //   block [0x827F9FC4..0x827F9FC8)
	// 827F9FC4: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x827F9FC8; continue 'dispatch;
            }
            0x827F9FC8 => {
    //   block [0x827F9FC8..0x827F9FEC)
	// 827F9FC8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827F9FCC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9FD0: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827F9FD4: 409A0048  bne cr6, 0x827fa01c
	if !ctx.cr[6].eq {
	pc = 0x827FA01C; continue 'dispatch;
	}
	// 827F9FD8: 897B0019  lbz r11, 0x19(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9FDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827F9FE0: 419A000C  beq cr6, 0x827f9fec
	if ctx.cr[6].eq {
	pc = 0x827F9FEC; continue 'dispatch;
	}
	// 827F9FE4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 827F9FE8: 4800002C  b 0x827fa014
	pc = 0x827FA014; continue 'dispatch;
            }
            0x827F9FEC => {
    //   block [0x827F9FEC..0x827FA000)
	// 827F9FEC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827F9FF0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 827F9FF4: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827F9FF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827F9FFC: 409A0018  bne cr6, 0x827fa014
	if !ctx.cr[6].eq {
	pc = 0x827FA014; continue 'dispatch;
	}
	pc = 0x827FA000; continue 'dispatch;
            }
            0x827FA000 => {
    //   block [0x827FA000..0x827FA014)
	// 827FA000: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FA004: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA008: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA00C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FA010: 419AFFF0  beq cr6, 0x827fa000
	if ctx.cr[6].eq {
	pc = 0x827FA000; continue 'dispatch;
	}
	pc = 0x827FA014; continue 'dispatch;
            }
            0x827FA014 => {
    //   block [0x827FA014..0x827FA01C)
	// 827FA014: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA018: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827FA01C; continue 'dispatch;
            }
            0x827FA01C => {
    //   block [0x827FA01C..0x827FA044)
	// 827FA01C: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA020: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA024: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FA028: 409A00E8  bne cr6, 0x827fa110
	if !ctx.cr[6].eq {
	pc = 0x827FA110; continue 'dispatch;
	}
	// 827FA02C: 897B0019  lbz r11, 0x19(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA034: 419A0010  beq cr6, 0x827fa044
	if ctx.cr[6].eq {
	pc = 0x827FA044; continue 'dispatch;
	}
	// 827FA038: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 827FA03C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FA040: 480000D0  b 0x827fa110
	pc = 0x827FA110; continue 'dispatch;
            }
            0x827FA044 => {
    //   block [0x827FA044..0x827FA058)
	// 827FA044: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA048: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 827FA04C: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA050: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FA054: 409A0018  bne cr6, 0x827fa06c
	if !ctx.cr[6].eq {
	pc = 0x827FA06C; continue 'dispatch;
	}
	pc = 0x827FA058; continue 'dispatch;
            }
            0x827FA058 => {
    //   block [0x827FA058..0x827FA06C)
	// 827FA058: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FA05C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA060: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA064: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FA068: 419AFFF0  beq cr6, 0x827fa058
	if ctx.cr[6].eq {
	pc = 0x827FA058; continue 'dispatch;
	}
	pc = 0x827FA06C; continue 'dispatch;
            }
            0x827FA06C => {
    //   block [0x827FA06C..0x827FA074)
	// 827FA06C: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FA070: 480000A0  b 0x827fa110
	pc = 0x827FA110; continue 'dispatch;
            }
            0x827FA074 => {
    //   block [0x827FA074..0x827FA094)
	// 827FA074: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA078: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA07C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827FA080: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA084: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FA088: 409A000C  bne cr6, 0x827fa094
	if !ctx.cr[6].eq {
	pc = 0x827FA094; continue 'dispatch;
	}
	// 827FA08C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827FA090: 4800002C  b 0x827fa0bc
	pc = 0x827FA0BC; continue 'dispatch;
            }
            0x827FA094 => {
    //   block [0x827FA094..0x827FA0A8)
	// 827FA094: 895B0019  lbz r10, 0x19(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA098: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA09C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA0A0: 409A0008  bne cr6, 0x827fa0a8
	if !ctx.cr[6].eq {
	pc = 0x827FA0A8; continue 'dispatch;
	}
	// 827FA0A4: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x827FA0A8; continue 'dispatch;
            }
            0x827FA0A8 => {
    //   block [0x827FA0A8..0x827FA0BC)
	// 827FA0A8: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 827FA0AC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA0B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FA0B4: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA0B8: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x827FA0BC; continue 'dispatch;
            }
            0x827FA0BC => {
    //   block [0x827FA0BC..0x827FA0DC)
	// 827FA0BC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 827FA0C0: 3B8ABAFC  addi r28, r10, -0x4504
	ctx.r[28].s64 = ctx.r[10].s64 + -17668;
	// 827FA0C4: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA0C8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA0CC: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FA0D0: 409A000C  bne cr6, 0x827fa0dc
	if !ctx.cr[6].eq {
	pc = 0x827FA0DC; continue 'dispatch;
	}
	// 827FA0D4: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA0D8: 48000020  b 0x827fa0f8
	pc = 0x827FA0F8; continue 'dispatch;
            }
            0x827FA0DC => {
    //   block [0x827FA0DC..0x827FA0F4)
	// 827FA0DC: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA0E0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA0E4: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FA0E8: 409A000C  bne cr6, 0x827fa0f4
	if !ctx.cr[6].eq {
	pc = 0x827FA0F4; continue 'dispatch;
	}
	// 827FA0EC: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827FA0F0: 48000008  b 0x827fa0f8
	pc = 0x827FA0F8; continue 'dispatch;
            }
            0x827FA0F4 => {
    //   block [0x827FA0F4..0x827FA0F8)
	// 827FA0F4: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x827FA0F8; continue 'dispatch;
            }
            0x827FA0F8 => {
    //   block [0x827FA0F8..0x827FA110)
	// 827FA0F8: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA0FC: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827FA100: 893A0018  lbz r9, 0x18(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA104: 890B0018  lbz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA108: 992B0018  stb r9, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u8 ) };
	// 827FA10C: 991A0018  stb r8, 0x18(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	pc = 0x827FA110; continue 'dispatch;
            }
            0x827FA110 => {
    //   block [0x827FA110..0x827FA134)
	// 827FA110: 897A0018  lbz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA114: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827FA118: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827FA11C: 409A0194  bne cr6, 0x827fa2b0
	if !ctx.cr[6].eq {
	pc = 0x827FA2B0; continue 'dispatch;
	}
	// 827FA120: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA124: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 827FA128: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA12C: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FA130: 419A017C  beq cr6, 0x827fa2ac
	if ctx.cr[6].eq {
	pc = 0x827FA2AC; continue 'dispatch;
	}
	pc = 0x827FA134; continue 'dispatch;
            }
            0x827FA134 => {
    //   block [0x827FA134..0x827FA174)
	// 827FA134: 897B0018  lbz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA138: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 827FA13C: 409A0170  bne cr6, 0x827fa2ac
	if !ctx.cr[6].eq {
	pc = 0x827FA2AC; continue 'dispatch;
	}
	// 827FA140: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA144: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FA148: 409A00A8  bne cr6, 0x827fa1f0
	if !ctx.cr[6].eq {
	pc = 0x827FA1F0; continue 'dispatch;
	}
	// 827FA14C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA150: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA154: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA158: 409A001C  bne cr6, 0x827fa174
	if !ctx.cr[6].eq {
	pc = 0x827FA174; continue 'dispatch;
	}
	// 827FA15C: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA160: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA164: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827FA168: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA16C: 480001C5  bl 0x827fa330
	ctx.lr = 0x827FA170;
	sub_827FA330(ctx, base);
	// 827FA170: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x827FA174; continue 'dispatch;
            }
            0x827FA174 => {
    //   block [0x827FA174..0x827FA1A0)
	// 827FA174: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA178: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA17C: 409A00C8  bne cr6, 0x827fa244
	if !ctx.cr[6].eq {
	pc = 0x827FA244; continue 'dispatch;
	}
	// 827FA180: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA184: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA188: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA18C: 409A0014  bne cr6, 0x827fa1a0
	if !ctx.cr[6].eq {
	pc = 0x827FA1A0; continue 'dispatch;
	}
	// 827FA190: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA194: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA198: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA19C: 419A00A4  beq cr6, 0x827fa240
	if ctx.cr[6].eq {
	pc = 0x827FA240; continue 'dispatch;
	}
	pc = 0x827FA1A0; continue 'dispatch;
            }
            0x827FA1A0 => {
    //   block [0x827FA1A0..0x827FA1CC)
	// 827FA1A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA1A4: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA1A8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA1AC: 409A0020  bne cr6, 0x827fa1cc
	if !ctx.cr[6].eq {
	pc = 0x827FA1CC; continue 'dispatch;
	}
	// 827FA1B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA1B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA1B8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827FA1BC: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA1C0: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827FA1C4: 480001ED  bl 0x827fa3b0
	ctx.lr = 0x827FA1C8;
	sub_827FA3B0(ctx, base);
	// 827FA1C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x827FA1CC; continue 'dispatch;
            }
            0x827FA1CC => {
    //   block [0x827FA1CC..0x827FA1F0)
	// 827FA1CC: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA1D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA1D4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA1D8: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 827FA1DC: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA1E0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA1E4: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA1E8: 48000149  bl 0x827fa330
	ctx.lr = 0x827FA1EC;
	sub_827FA330(ctx, base);
	// 827FA1EC: 480000C0  b 0x827fa2ac
	pc = 0x827FA2AC; continue 'dispatch;
            }
            0x827FA1F0 => {
    //   block [0x827FA1F0..0x827FA214)
	// 827FA1F0: 894B0018  lbz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA1F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA1F8: 409A001C  bne cr6, 0x827fa214
	if !ctx.cr[6].eq {
	pc = 0x827FA214; continue 'dispatch;
	}
	// 827FA1FC: 9BAB0018  stb r29, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA200: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA204: 9BDF0018  stb r30, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827FA208: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA20C: 480001A5  bl 0x827fa3b0
	ctx.lr = 0x827FA210;
	sub_827FA3B0(ctx, base);
	// 827FA210: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FA214; continue 'dispatch;
            }
            0x827FA214 => {
    //   block [0x827FA214..0x827FA240)
	// 827FA214: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA218: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA21C: 409A0028  bne cr6, 0x827fa244
	if !ctx.cr[6].eq {
	pc = 0x827FA244; continue 'dispatch;
	}
	// 827FA220: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA224: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA228: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA22C: 409A0034  bne cr6, 0x827fa260
	if !ctx.cr[6].eq {
	pc = 0x827FA260; continue 'dispatch;
	}
	// 827FA230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA234: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA238: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA23C: 409A0024  bne cr6, 0x827fa260
	if !ctx.cr[6].eq {
	pc = 0x827FA260; continue 'dispatch;
	}
	pc = 0x827FA240; continue 'dispatch;
            }
            0x827FA240 => {
    //   block [0x827FA240..0x827FA244)
	// 827FA240: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	pc = 0x827FA244; continue 'dispatch;
            }
            0x827FA244 => {
    //   block [0x827FA244..0x827FA260)
	// 827FA244: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA248: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 827FA24C: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA250: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA254: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FA258: 409AFEDC  bne cr6, 0x827fa134
	if !ctx.cr[6].eq {
	pc = 0x827FA134; continue 'dispatch;
	}
	// 827FA25C: 48000050  b 0x827fa2ac
	pc = 0x827FA2AC; continue 'dispatch;
            }
            0x827FA260 => {
    //   block [0x827FA260..0x827FA28C)
	// 827FA260: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA264: 892A0018  lbz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA268: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 827FA26C: 409A0020  bne cr6, 0x827fa28c
	if !ctx.cr[6].eq {
	pc = 0x827FA28C; continue 'dispatch;
	}
	// 827FA270: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA274: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA278: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827FA27C: 9BAA0018  stb r29, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA280: 9BCB0018  stb r30, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[30].u8 ) };
	// 827FA284: 480000AD  bl 0x827fa330
	ctx.lr = 0x827FA288;
	sub_827FA330(ctx, base);
	// 827FA288: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FA28C; continue 'dispatch;
            }
            0x827FA28C => {
    //   block [0x827FA28C..0x827FA2AC)
	// 827FA28C: 895F0018  lbz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FA290: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FA294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA298: 994B0018  stb r10, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[10].u8 ) };
	// 827FA29C: 9BBF0018  stb r29, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA2A0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA2A4: 9BA90018  stb r29, 0x18(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	// 827FA2A8: 48000109  bl 0x827fa3b0
	ctx.lr = 0x827FA2AC;
	sub_827FA3B0(ctx, base);
	pc = 0x827FA2AC; continue 'dispatch;
            }
            0x827FA2AC => {
    //   block [0x827FA2AC..0x827FA2B0)
	// 827FA2AC: 9BBB0018  stb r29, 0x18(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(24 as u32), ctx.r[29].u8 ) };
	pc = 0x827FA2B0; continue 'dispatch;
            }
            0x827FA2B0 => {
    //   block [0x827FA2B0..0x827FA2CC)
	// 827FA2B0: 3BFA000C  addi r31, r26, 0xc
	ctx.r[31].s64 = ctx.r[26].s64 + 12;
	// 827FA2B4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 827FA2B8: 4B9BD861  bl 0x821b7b18
	ctx.lr = 0x827FA2BC;
	sub_821B7B18(ctx, base);
	// 827FA2BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA2C0: 4B9CC4A9  bl 0x821c6768
	ctx.lr = 0x827FA2C4;
	sub_821C6768(ctx, base);
	// 827FA2C4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FA2C8: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827FA2CC; continue 'dispatch;
            }
            0x827FA2CC => {
    //   block [0x827FA2CC..0x827FA31C)
	// 827FA2CC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827FA2D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FA2D4: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827FA2D8: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827FA2DC: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FA2E0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FA2E4: 4082FFE8  bne 0x827fa2cc
	if !ctx.cr[0].eq {
	pc = 0x827FA2CC; continue 'dispatch;
	}
	// 827FA2E8: 93DA000C  stw r30, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 827FA2EC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FA2F0: 4BA21A49  bl 0x8221bd38
	ctx.lr = 0x827FA2F4;
	sub_8221BD38(ctx, base);
	// 827FA2F4: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA2F8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FA2FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA300: 419A001C  beq cr6, 0x827fa31c
	if ctx.cr[6].eq {
	pc = 0x827FA31C; continue 'dispatch;
	}
	// 827FA304: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 827FA308: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FA30C: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827FA310: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 827FA314: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827FA318: 484AF134  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FA31C => {
    //   block [0x827FA31C..0x827FA32C)
	// 827FA31C: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 827FA320: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 827FA324: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827FA328: 484AF124  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827FA330 size=80
    let mut pc: u32 = 0x827FA330;
    'dispatch: loop {
        match pc {
            0x827FA330 => {
    //   block [0x827FA330..0x827FA350)
	// 827FA330: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA334: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA338: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FA33C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA340: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA344: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FA348: 409A0008  bne cr6, 0x827fa350
	if !ctx.cr[6].eq {
	pc = 0x827FA350; continue 'dispatch;
	}
	// 827FA34C: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x827FA350; continue 'dispatch;
            }
            0x827FA350 => {
    //   block [0x827FA350..0x827FA380)
	// 827FA350: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 827FA354: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA358: 390ABAFC  addi r8, r10, -0x4504
	ctx.r[8].s64 = ctx.r[10].s64 + -17668;
	// 827FA35C: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FA360: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA364: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA368: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827FA36C: 409A0014  bne cr6, 0x827fa380
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x827FA380);
		return;
	}
	// 827FA370: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA374: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 827FA378: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA37C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA3B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827FA3B0 size=80
    let mut pc: u32 = 0x827FA3B0;
    'dispatch: loop {
        match pc {
            0x827FA3B0 => {
    //   block [0x827FA3B0..0x827FA3D0)
	// 827FA3B0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA3B4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA3B8: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827FA3BC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA3C0: 892A0019  lbz r9, 0x19(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FA3C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FA3C8: 409A0008  bne cr6, 0x827fa3d0
	if !ctx.cr[6].eq {
	pc = 0x827FA3D0; continue 'dispatch;
	}
	// 827FA3CC: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x827FA3D0; continue 'dispatch;
            }
            0x827FA3D0 => {
    //   block [0x827FA3D0..0x827FA400)
	// 827FA3D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 827FA3D4: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA3D8: 390ABAFC  addi r8, r10, -0x4504
	ctx.r[8].s64 = ctx.r[10].s64 + -17668;
	// 827FA3DC: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FA3E0: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA3E4: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA3E8: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827FA3EC: 409A0014  bne cr6, 0x827fa400
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x827FA400);
		return;
	}
	// 827FA3F0: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA3F4: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 827FA3F8: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FA3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA430(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827FA430 size=208
    let mut pc: u32 = 0x827FA430;
    'dispatch: loop {
        match pc {
            0x827FA430 => {
    //   block [0x827FA430..0x827FA500)
	// 827FA430: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA434: 484AEFD9  bl 0x82ca940c
	ctx.lr = 0x827FA438;
	sub_82CA93D0(ctx, base);
	// 827FA438: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA500(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA500 size=240
    let mut pc: u32 = 0x827FA500;
    'dispatch: loop {
        match pc {
            0x827FA500 => {
    //   block [0x827FA500..0x827FA528)
	// 827FA500: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA504: 484AEEF5  bl 0x82ca93f8
	ctx.lr = 0x827FA508;
	sub_82CA93D0(ctx, base);
	// 827FA508: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA50C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 827FA510: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 827FA514: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827FA518: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 827FA51C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 827FA520: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FA524: 419A00B0  beq cr6, 0x827fa5d4
	if ctx.cr[6].eq {
	pc = 0x827FA5D4; continue 'dispatch;
	}
	pc = 0x827FA528; continue 'dispatch;
            }
            0x827FA528 => {
    //   block [0x827FA528..0x827FA550)
	// 827FA528: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA52C: 81590000  lwz r10, 0(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA530: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 827FA534: 419A0094  beq cr6, 0x827fa5c8
	if ctx.cr[6].eq {
	pc = 0x827FA5C8; continue 'dispatch;
	}
	// 827FA538: E95B0000  ld r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	// 827FA53C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA544: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 827FA548: 409A0008  bne cr6, 0x827fa550
	if !ctx.cr[6].eq {
	pc = 0x827FA550; continue 'dispatch;
	}
	// 827FA54C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA550; continue 'dispatch;
            }
            0x827FA550 => {
    //   block [0x827FA550..0x827FA564)
	// 827FA550: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA554: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA558: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FA55C: 41980008  blt cr6, 0x827fa564
	if ctx.cr[6].lt {
	pc = 0x827FA564; continue 'dispatch;
	}
	// 827FA560: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA564; continue 'dispatch;
            }
            0x827FA564 => {
    //   block [0x827FA564..0x827FA57C)
	// 827FA564: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 827FA568: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FA56C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA570: 915B0004  stw r10, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827FA574: 409A0008  bne cr6, 0x827fa57c
	if !ctx.cr[6].eq {
	pc = 0x827FA57C; continue 'dispatch;
	}
	// 827FA578: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA57C; continue 'dispatch;
            }
            0x827FA57C => {
    //   block [0x827FA57C..0x827FA590)
	// 827FA57C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA580: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FA584: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FA588: 41980008  blt cr6, 0x827fa590
	if ctx.cr[6].lt {
	pc = 0x827FA590; continue 'dispatch;
	}
	// 827FA58C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA590; continue 'dispatch;
            }
            0x827FA590 => {
    //   block [0x827FA590..0x827FA5C8)
	// 827FA590: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA594: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA598: 83BC0000  lwz r29, 0(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA59C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FA5A0: 419A0028  beq cr6, 0x827fa5c8
	if ctx.cr[6].eq {
	pc = 0x827FA5C8; continue 'dispatch;
	}
	// 827FA5A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FA5A8: 4B9BD571  bl 0x821b7b18
	ctx.lr = 0x827FA5AC;
	sub_821B7B18(ctx, base);
	// 827FA5AC: 93BE0000  stw r29, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827FA5B0: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 827FA5B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827FA5B8: 419A0010  beq cr6, 0x827fa5c8
	if ctx.cr[6].eq {
	pc = 0x827FA5C8; continue 'dispatch;
	}
	// 827FA5BC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA5C0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827FA5C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x827FA5C8; continue 'dispatch;
            }
            0x827FA5C8 => {
    //   block [0x827FA5C8..0x827FA5D4)
	// 827FA5C8: 3B9C0008  addi r28, r28, 8
	ctx.r[28].s64 = ctx.r[28].s64 + 8;
	// 827FA5CC: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FA5D0: 409AFF58  bne cr6, 0x827fa528
	if !ctx.cr[6].eq {
	pc = 0x827FA528; continue 'dispatch;
	}
	pc = 0x827FA5D4; continue 'dispatch;
            }
            0x827FA5D4 => {
    //   block [0x827FA5D4..0x827FA5F0)
	// 827FA5D4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA5D8: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827FA5DC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA5E0: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827FA5E4: 91580004  stw r10, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 827FA5E8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FA5EC: 484AEE5C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827FA5F0 size=16
    let mut pc: u32 = 0x827FA5F0;
    'dispatch: loop {
        match pc {
            0x827FA5F0 => {
    //   block [0x827FA5F0..0x827FA600)
	// 827FA5F0: 80830008  lwz r4, 8(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA5F4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 827FA5F8: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA5FC: 4BC2C6AC  b 0x82426ca8
	sub_82426CA8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA600 size=92
    let mut pc: u32 = 0x827FA600;
    'dispatch: loop {
        match pc {
            0x827FA600 => {
    //   block [0x827FA600..0x827FA630)
	// 827FA600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA604: 484AEE09  bl 0x82ca940c
	ctx.lr = 0x827FA608;
	sub_82CA93D0(ctx, base);
	// 827FA608: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA60C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 827FA610: 4BAAF651  bl 0x822a9c60
	ctx.lr = 0x827FA614;
	sub_822A9C60(ctx, base);
	// 827FA614: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FA618: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827FA61C: 419A0038  beq cr6, 0x827fa654
	if ctx.cr[6].eq {
	pc = 0x827FA654; continue 'dispatch;
	}
	// 827FA620: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA624: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA628: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FA62C: 419A0028  beq cr6, 0x827fa654
	if ctx.cr[6].eq {
	pc = 0x827FA654; continue 'dispatch;
	}
	pc = 0x827FA630; continue 'dispatch;
            }
            0x827FA630 => {
    //   block [0x827FA630..0x827FA654)
	// 827FA630: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA634: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827FA638: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA63C: 806B0004  lwz r3, 4(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA640: 4BC2C669  bl 0x82426ca8
	ctx.lr = 0x827FA644;
	sub_82426CA8(ctx, base);
	// 827FA644: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA648: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827FA64C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FA650: 409AFFE0  bne cr6, 0x827fa630
	if !ctx.cr[6].eq {
	pc = 0x827FA630; continue 'dispatch;
	}
	pc = 0x827FA654; continue 'dispatch;
            }
            0x827FA654 => {
    //   block [0x827FA654..0x827FA65C)
	// 827FA654: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FA658: 484AEE04  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA660 size=60
    let mut pc: u32 = 0x827FA660;
    'dispatch: loop {
        match pc {
            0x827FA660 => {
    //   block [0x827FA660..0x827FA69C)
	// 827FA660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FA668: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FA66C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 827FA674: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FA678: 388B9F7C  addi r4, r11, -0x6084
	ctx.r[4].s64 = ctx.r[11].s64 + -24708;
	// 827FA67C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FA680: 4BA32851  bl 0x8222ced0
	ctx.lr = 0x827FA684;
	sub_8222CED0(ctx, base);
	// 827FA684: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA688: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827FA68C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FA690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FA694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FA698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA6C0 size=164
    let mut pc: u32 = 0x827FA6C0;
    'dispatch: loop {
        match pc {
            0x827FA6C0 => {
    //   block [0x827FA6C0..0x827FA704)
	// 827FA6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FA6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FA6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FA6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA6D4: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 827FA6D8: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 827FA6DC: 38A1008C  addi r5, r1, 0x8c
	ctx.r[5].s64 = ctx.r[1].s64 + 140;
	// 827FA6E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FA6E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA6E8: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA6EC: 4BD8451D  bl 0x8257ec08
	ctx.lr = 0x827FA6F0;
	sub_8257EC08(ctx, base);
	// 827FA6F0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA6F8: 419A000C  beq cr6, 0x827fa704
	if ctx.cr[6].eq {
	pc = 0x827FA704; continue 'dispatch;
	}
	// 827FA6FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FA700: 419A0008  beq cr6, 0x827fa708
	if ctx.cr[6].eq {
	pc = 0x827FA708; continue 'dispatch;
	}
	pc = 0x827FA704; continue 'dispatch;
            }
            0x827FA704 => {
    //   block [0x827FA704..0x827FA708)
	// 827FA704: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA708; continue 'dispatch;
            }
            0x827FA708 => {
    //   block [0x827FA708..0x827FA730)
	// 827FA708: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA70C: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 827FA710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA714: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FA718: 419A0018  beq cr6, 0x827fa730
	if ctx.cr[6].eq {
	pc = 0x827FA730; continue 'dispatch;
	}
	// 827FA71C: 48004E35  bl 0x827ff550
	ctx.lr = 0x827FA720;
	sub_827FF550(ctx, base);
	// 827FA720: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA724: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 827FA728: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827FA72C: 48000020  b 0x827fa74c
	pc = 0x827FA74C; continue 'dispatch;
            }
            0x827FA730 => {
    //   block [0x827FA730..0x827FA74C)
	// 827FA730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FA734: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827FA738: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FA73C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FA740: 48004E11  bl 0x827ff550
	ctx.lr = 0x827FA744;
	sub_827FF550(ctx, base);
	// 827FA744: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FA748: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	pc = 0x827FA74C; continue 'dispatch;
            }
            0x827FA74C => {
    //   block [0x827FA74C..0x827FA764)
	// 827FA74C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FA750: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FA754: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FA758: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FA75C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FA760: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA768 size=160
    let mut pc: u32 = 0x827FA768;
    'dispatch: loop {
        match pc {
            0x827FA768 => {
    //   block [0x827FA768..0x827FA7A8)
	// 827FA768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA76C: 484AECA1  bl 0x82ca940c
	ctx.lr = 0x827FA770;
	sub_82CA93D0(ctx, base);
	// 827FA770: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA774: 9081009C  stw r4, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[4].u32 ) };
	// 827FA778: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 827FA77C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827FA780: 38A1009C  addi r5, r1, 0x9c
	ctx.r[5].s64 = ctx.r[1].s64 + 156;
	// 827FA784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FA788: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FA78C: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA790: 4BD84479  bl 0x8257ec08
	ctx.lr = 0x827FA794;
	sub_8257EC08(ctx, base);
	// 827FA794: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA798: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA79C: 419A000C  beq cr6, 0x827fa7a8
	if ctx.cr[6].eq {
	pc = 0x827FA7A8; continue 'dispatch;
	}
	// 827FA7A0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FA7A4: 419A0008  beq cr6, 0x827fa7ac
	if ctx.cr[6].eq {
	pc = 0x827FA7AC; continue 'dispatch;
	}
	pc = 0x827FA7A8; continue 'dispatch;
            }
            0x827FA7A8 => {
    //   block [0x827FA7A8..0x827FA7AC)
	// 827FA7A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA7AC; continue 'dispatch;
            }
            0x827FA7AC => {
    //   block [0x827FA7AC..0x827FA7E8)
	// 827FA7AC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA7B0: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 827FA7B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA7B8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FA7BC: 419A002C  beq cr6, 0x827fa7e8
	if ctx.cr[6].eq {
	pc = 0x827FA7E8; continue 'dispatch;
	}
	// 827FA7C0: 48004D91  bl 0x827ff550
	ctx.lr = 0x827FA7C4;
	sub_827FF550(ctx, base);
	// 827FA7C4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA7C8: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 827FA7CC: 40990034  ble cr6, 0x827fa800
	if !ctx.cr[6].gt {
	pc = 0x827FA800; continue 'dispatch;
	}
	// 827FA7D0: 3881009C  addi r4, r1, 0x9c
	ctx.r[4].s64 = ctx.r[1].s64 + 156;
	// 827FA7D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA7D8: 48004D79  bl 0x827ff550
	ctx.lr = 0x827FA7DC;
	sub_827FF550(ctx, base);
	// 827FA7DC: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 827FA7E0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827FA7E4: 484AEC78  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FA7E8 => {
    //   block [0x827FA7E8..0x827FA800)
	// 827FA7E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FA7EC: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FA7F0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FA7F4: 48004D5D  bl 0x827ff550
	ctx.lr = 0x827FA7F8;
	sub_827FF550(ctx, base);
	// 827FA7F8: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FA7FC: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	pc = 0x827FA800; continue 'dispatch;
            }
            0x827FA800 => {
    //   block [0x827FA800..0x827FA808)
	// 827FA800: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827FA804: 484AEC58  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA808 size=164
    let mut pc: u32 = 0x827FA808;
    'dispatch: loop {
        match pc {
            0x827FA808 => {
    //   block [0x827FA808..0x827FA838)
	// 827FA808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FA810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FA814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FA818: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA81C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA820: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 827FA824: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827FA828: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 827FA82C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FA830: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA834: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827FA838; continue 'dispatch;
            }
            0x827FA838 => {
    //   block [0x827FA838..0x827FA84C)
	// 827FA838: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA83C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA840: 419A000C  beq cr6, 0x827fa84c
	if ctx.cr[6].eq {
	pc = 0x827FA84C; continue 'dispatch;
	}
	// 827FA844: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FA848: 419A0008  beq cr6, 0x827fa850
	if ctx.cr[6].eq {
	pc = 0x827FA850; continue 'dispatch;
	}
	pc = 0x827FA84C; continue 'dispatch;
            }
            0x827FA84C => {
    //   block [0x827FA84C..0x827FA850)
	// 827FA84C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA850; continue 'dispatch;
            }
            0x827FA850 => {
    //   block [0x827FA850..0x827FA864)
	// 827FA850: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FA854: 419A003C  beq cr6, 0x827fa890
	if ctx.cr[6].eq {
	pc = 0x827FA890; continue 'dispatch;
	}
	// 827FA858: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA85C: 409A0008  bne cr6, 0x827fa864
	if !ctx.cr[6].eq {
	pc = 0x827FA864; continue 'dispatch;
	}
	// 827FA860: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA864; continue 'dispatch;
            }
            0x827FA864 => {
    //   block [0x827FA864..0x827FA874)
	// 827FA864: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA868: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FA86C: 409A0008  bne cr6, 0x827fa874
	if !ctx.cr[6].eq {
	pc = 0x827FA874; continue 'dispatch;
	}
	// 827FA870: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA874; continue 'dispatch;
            }
            0x827FA874 => {
    //   block [0x827FA874..0x827FA890)
	// 827FA874: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FA878: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FA87C: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827FA880: 4BC42571  bl 0x8243cdf0
	ctx.lr = 0x827FA884;
	sub_8243CDF0(ctx, base);
	// 827FA884: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FA888: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FA88C: 4BFFFFAC  b 0x827fa838
	pc = 0x827FA838; continue 'dispatch;
            }
            0x827FA890 => {
    //   block [0x827FA890..0x827FA8AC)
	// 827FA890: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FA894: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FA898: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FA89C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FA8A0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FA8A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FA8A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA8B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA8B0 size=164
    let mut pc: u32 = 0x827FA8B0;
    'dispatch: loop {
        match pc {
            0x827FA8B0 => {
    //   block [0x827FA8B0..0x827FA8E0)
	// 827FA8B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA8B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FA8B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FA8BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FA8C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA8C4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FA8C8: 3BE30004  addi r31, r3, 4
	ctx.r[31].s64 = ctx.r[3].s64 + 4;
	// 827FA8CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827FA8D0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 827FA8D4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FA8D8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FA8DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x827FA8E0; continue 'dispatch;
            }
            0x827FA8E0 => {
    //   block [0x827FA8E0..0x827FA8F4)
	// 827FA8E0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA8E8: 419A000C  beq cr6, 0x827fa8f4
	if ctx.cr[6].eq {
	pc = 0x827FA8F4; continue 'dispatch;
	}
	// 827FA8EC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FA8F0: 419A0008  beq cr6, 0x827fa8f8
	if ctx.cr[6].eq {
	pc = 0x827FA8F8; continue 'dispatch;
	}
	pc = 0x827FA8F4; continue 'dispatch;
            }
            0x827FA8F4 => {
    //   block [0x827FA8F4..0x827FA8F8)
	// 827FA8F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA8F8; continue 'dispatch;
            }
            0x827FA8F8 => {
    //   block [0x827FA8F8..0x827FA90C)
	// 827FA8F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FA8FC: 419A003C  beq cr6, 0x827fa938
	if ctx.cr[6].eq {
	pc = 0x827FA938; continue 'dispatch;
	}
	// 827FA900: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FA904: 409A0008  bne cr6, 0x827fa90c
	if !ctx.cr[6].eq {
	pc = 0x827FA90C; continue 'dispatch;
	}
	// 827FA908: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA90C; continue 'dispatch;
            }
            0x827FA90C => {
    //   block [0x827FA90C..0x827FA91C)
	// 827FA90C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FA910: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FA914: 409A0008  bne cr6, 0x827fa91c
	if !ctx.cr[6].eq {
	pc = 0x827FA91C; continue 'dispatch;
	}
	// 827FA918: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FA91C; continue 'dispatch;
            }
            0x827FA91C => {
    //   block [0x827FA91C..0x827FA938)
	// 827FA91C: 816A0014  lwz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FA920: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FA924: 7FCBF214  add r30, r11, r30
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 827FA928: 4BC424C9  bl 0x8243cdf0
	ctx.lr = 0x827FA92C;
	sub_8243CDF0(ctx, base);
	// 827FA92C: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FA930: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FA934: 4BFFFFAC  b 0x827fa8e0
	pc = 0x827FA8E0; continue 'dispatch;
            }
            0x827FA938 => {
    //   block [0x827FA938..0x827FA954)
	// 827FA938: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FA93C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FA940: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FA944: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FA948: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FA94C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FA950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FA958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FA958 size=184
    let mut pc: u32 = 0x827FA958;
    'dispatch: loop {
        match pc {
            0x827FA958 => {
    //   block [0x827FA958..0x827FA9F8)
	// 827FA958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FA95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FA960: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FA964: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FA968: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FA96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FA970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FA974: 387F0094  addi r3, r31, 0x94
	ctx.r[3].s64 = ctx.r[31].s64 + 148;
	// 827FA978: 4BB57CF9  bl 0x82352670
	ctx.lr = 0x827FA97C;
	sub_82352670(ctx, base);
	// 827FA97C: 387F0088  addi r3, r31, 0x88
	ctx.r[3].s64 = ctx.r[31].s64 + 136;
	// 827FA980: 48005109  bl 0x827ffa88
	ctx.lr = 0x827FA984;
	sub_827FFA88(ctx, base);
	// 827FA984: 387F007C  addi r3, r31, 0x7c
	ctx.r[3].s64 = ctx.r[31].s64 + 124;
	// 827FA988: 48005101  bl 0x827ffa88
	ctx.lr = 0x827FA98C;
	sub_827FFA88(ctx, base);
	// 827FA98C: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 827FA990: 480050F9  bl 0x827ffa88
	ctx.lr = 0x827FA994;
	sub_827FFA88(ctx, base);
	// 827FA994: 387F0060  addi r3, r31, 0x60
	ctx.r[3].s64 = ctx.r[31].s64 + 96;
	// 827FA998: 480050F1  bl 0x827ffa88
	ctx.lr = 0x827FA99C;
	sub_827FFA88(ctx, base);
	// 827FA99C: 387F0054  addi r3, r31, 0x54
	ctx.r[3].s64 = ctx.r[31].s64 + 84;
	// 827FA9A0: 480050E9  bl 0x827ffa88
	ctx.lr = 0x827FA9A4;
	sub_827FFA88(ctx, base);
	// 827FA9A4: 387F0048  addi r3, r31, 0x48
	ctx.r[3].s64 = ctx.r[31].s64 + 72;
	// 827FA9A8: 480050E1  bl 0x827ffa88
	ctx.lr = 0x827FA9AC;
	sub_827FFA88(ctx, base);
	// 827FA9AC: 387F003C  addi r3, r31, 0x3c
	ctx.r[3].s64 = ctx.r[31].s64 + 60;
	// 827FA9B0: 480050D9  bl 0x827ffa88
	ctx.lr = 0x827FA9B4;
	sub_827FFA88(ctx, base);
	// 827FA9B4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 827FA9B8: 48004E41  bl 0x827ff7f8
	ctx.lr = 0x827FA9BC;
	sub_827FF7F8(ctx, base);
	// 827FA9BC: 387F0024  addi r3, r31, 0x24
	ctx.r[3].s64 = ctx.r[31].s64 + 36;
	// 827FA9C0: 48004E39  bl 0x827ff7f8
	ctx.lr = 0x827FA9C4;
	sub_827FF7F8(ctx, base);
	// 827FA9C4: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 827FA9C8: 48004E31  bl 0x827ff7f8
	ctx.lr = 0x827FA9CC;
	sub_827FF7F8(ctx, base);
	// 827FA9CC: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 827FA9D0: 4BB700C1  bl 0x8236aa90
	ctx.lr = 0x827FA9D4;
	sub_8236AA90(ctx, base);
	// 827FA9D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827FA9D8: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 827FA9DC: 392B2850  addi r9, r11, 0x2850
	ctx.r[9].s64 = ctx.r[11].s64 + 10320;
	// 827FA9E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FA9E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827FA9E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FA9EC: 419A000C  beq cr6, 0x827fa9f8
	if ctx.cr[6].eq {
	pc = 0x827FA9F8; continue 'dispatch;
	}
	// 827FA9F0: 4BA21349  bl 0x8221bd38
	ctx.lr = 0x827FA9F4;
	sub_8221BD38(ctx, base);
	// 827FA9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x827FA9F8; continue 'dispatch;
            }
            0x827FA9F8 => {
    //   block [0x827FA9F8..0x827FAA10)
	// 827FA9F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FA9FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FAA00: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FAA04: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FAA08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FAA0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FAA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FAA10 size=472
    let mut pc: u32 = 0x827FAA10;
    'dispatch: loop {
        match pc {
            0x827FAA10 => {
    //   block [0x827FAA10..0x827FABE8)
	// 827FAA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FAA14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FAA18: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FAA1C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FAA20: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FAA24: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FAA28: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FAA2C: 3BCBA524  addi r30, r11, -0x5adc
	ctx.r[30].s64 = ctx.r[11].s64 + -23260;
	// 827FAA30: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAA34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAA38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAA3C: 4BA32495  bl 0x8222ced0
	ctx.lr = 0x827FAA40;
	sub_8222CED0(ctx, base);
	// 827FAA40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAA44: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FAA48: 48006969  bl 0x828013b0
	ctx.lr = 0x827FAA4C;
	sub_828013B0(ctx, base);
	// 827FAA4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAA50: 4BA1A389  bl 0x82214dd8
	ctx.lr = 0x827FAA54;
	sub_82214DD8(ctx, base);
	// 827FAA54: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FAA58: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAA5C: 388AA534  addi r4, r10, -0x5acc
	ctx.r[4].s64 = ctx.r[10].s64 + -23244;
	// 827FAA60: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAA64: 4BA3246D  bl 0x8222ced0
	ctx.lr = 0x827FAA68;
	sub_8222CED0(ctx, base);
	// 827FAA68: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAA6C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAA70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAA74: 4BA3245D  bl 0x8222ced0
	ctx.lr = 0x827FAA78;
	sub_8222CED0(ctx, base);
	// 827FAA78: 3D208280  lis r9, -0x7d80
	ctx.r[9].s64 = -2105540608;
	// 827FAA7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAA80: 38C9A6A0  addi r6, r9, -0x5960
	ctx.r[6].s64 = ctx.r[9].s64 + -22880;
	// 827FAA84: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FAA88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FAA8C: 48006B6D  bl 0x828015f8
	ctx.lr = 0x827FAA90;
	sub_828015F8(ctx, base);
	// 827FAA90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAA94: 4BA1A345  bl 0x82214dd8
	ctx.lr = 0x827FAA98;
	sub_82214DD8(ctx, base);
	// 827FAA98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAA9C: 4BA1A33D  bl 0x82214dd8
	ctx.lr = 0x827FAAA0;
	sub_82214DD8(ctx, base);
	// 827FAAA0: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827FAAA4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAAA8: 3888A544  addi r4, r8, -0x5abc
	ctx.r[4].s64 = ctx.r[8].s64 + -23228;
	// 827FAAAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAAB0: 4BA32421  bl 0x8222ced0
	ctx.lr = 0x827FAAB4;
	sub_8222CED0(ctx, base);
	// 827FAAB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAAB8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAABC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAAC0: 4BA32411  bl 0x8222ced0
	ctx.lr = 0x827FAAC4;
	sub_8222CED0(ctx, base);
	// 827FAAC4: 3CE08280  lis r7, -0x7d80
	ctx.r[7].s64 = -2105540608;
	// 827FAAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAACC: 38C7A6B0  addi r6, r7, -0x5950
	ctx.r[6].s64 = ctx.r[7].s64 + -22864;
	// 827FAAD0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FAAD4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FAAD8: 48006B21  bl 0x828015f8
	ctx.lr = 0x827FAADC;
	sub_828015F8(ctx, base);
	// 827FAADC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAAE0: 4BA1A2F9  bl 0x82214dd8
	ctx.lr = 0x827FAAE4;
	sub_82214DD8(ctx, base);
	// 827FAAE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAAE8: 4BA1A2F1  bl 0x82214dd8
	ctx.lr = 0x827FAAEC;
	sub_82214DD8(ctx, base);
	// 827FAAEC: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 827FAAF0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAAF4: 3886A558  addi r4, r6, -0x5aa8
	ctx.r[4].s64 = ctx.r[6].s64 + -23208;
	// 827FAAF8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAAFC: 4BA323D5  bl 0x8222ced0
	ctx.lr = 0x827FAB00;
	sub_8222CED0(ctx, base);
	// 827FAB00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAB04: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAB08: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAB0C: 4BA323C5  bl 0x8222ced0
	ctx.lr = 0x827FAB10;
	sub_8222CED0(ctx, base);
	// 827FAB10: 3C808280  lis r4, -0x7d80
	ctx.r[4].s64 = -2105540608;
	// 827FAB14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAB18: 38C4B4A8  addi r6, r4, -0x4b58
	ctx.r[6].s64 = ctx.r[4].s64 + -19288;
	// 827FAB1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FAB20: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FAB24: 48006AD5  bl 0x828015f8
	ctx.lr = 0x827FAB28;
	sub_828015F8(ctx, base);
	// 827FAB28: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAB2C: 4BA1A2AD  bl 0x82214dd8
	ctx.lr = 0x827FAB30;
	sub_82214DD8(ctx, base);
	// 827FAB30: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAB34: 4BA1A2A5  bl 0x82214dd8
	ctx.lr = 0x827FAB38;
	sub_82214DD8(ctx, base);
	// 827FAB38: 3C60820E  lis r3, -0x7df2
	ctx.r[3].s64 = -2113011712;
	// 827FAB3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAB40: 3883A574  addi r4, r3, -0x5a8c
	ctx.r[4].s64 = ctx.r[3].s64 + -23180;
	// 827FAB44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAB48: 4BA32389  bl 0x8222ced0
	ctx.lr = 0x827FAB4C;
	sub_8222CED0(ctx, base);
	// 827FAB4C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAB50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAB54: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAB58: 4BA32379  bl 0x8222ced0
	ctx.lr = 0x827FAB5C;
	sub_8222CED0(ctx, base);
	// 827FAB5C: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 827FAB60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAB64: 38CBB268  addi r6, r11, -0x4d98
	ctx.r[6].s64 = ctx.r[11].s64 + -19864;
	// 827FAB68: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FAB6C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FAB70: 48006C89  bl 0x828017f8
	ctx.lr = 0x827FAB74;
	sub_828017F8(ctx, base);
	// 827FAB74: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FAB78: 4BA1A261  bl 0x82214dd8
	ctx.lr = 0x827FAB7C;
	sub_82214DD8(ctx, base);
	// 827FAB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAB80: 4BA1A259  bl 0x82214dd8
	ctx.lr = 0x827FAB84;
	sub_82214DD8(ctx, base);
	// 827FAB84: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FAB88: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FAB8C: 388AA590  addi r4, r10, -0x5a70
	ctx.r[4].s64 = ctx.r[10].s64 + -23152;
	// 827FAB90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAB94: 4BA3233D  bl 0x8222ced0
	ctx.lr = 0x827FAB98;
	sub_8222CED0(ctx, base);
	// 827FAB98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAB9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FABA0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FABA4: 4BA3232D  bl 0x8222ced0
	ctx.lr = 0x827FABA8;
	sub_8222CED0(ctx, base);
	// 827FABA8: 3D208280  lis r9, -0x7d80
	ctx.r[9].s64 = -2105540608;
	// 827FABAC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FABB0: 38C9B3D0  addi r6, r9, -0x4c30
	ctx.r[6].s64 = ctx.r[9].s64 + -19504;
	// 827FABB4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FABB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FABBC: 48006C3D  bl 0x828017f8
	ctx.lr = 0x827FABC0;
	sub_828017F8(ctx, base);
	// 827FABC0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FABC4: 4BA1A215  bl 0x82214dd8
	ctx.lr = 0x827FABC8;
	sub_82214DD8(ctx, base);
	// 827FABC8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FABCC: 4BA1A20D  bl 0x82214dd8
	ctx.lr = 0x827FABD0;
	sub_82214DD8(ctx, base);
	// 827FABD0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FABD4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FABD8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FABDC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FABE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FABE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FABE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x827FABE8 size=700
    let mut pc: u32 = 0x827FABE8;
    'dispatch: loop {
        match pc {
            0x827FABE8 => {
    //   block [0x827FABE8..0x827FAC44)
	// 827FABE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FABEC: 484AE821  bl 0x82ca940c
	ctx.lr = 0x827FABF0;
	sub_82CA93D0(ctx, base);
	// 827FABF0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FABF4: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 827FABF8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FABFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAC00: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FAC04: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FAC08: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FAC0C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAC10: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FAC14: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAC18: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FAC1C: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAC20: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FAC24: 4B9F561D  bl 0x821f0240
	ctx.lr = 0x827FAC28;
	sub_821F0240(ctx, base);
	// 827FAC28: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FAC2C: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FAC30: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827FAC34: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827FAC38: 409A000C  bne cr6, 0x827fac44
	if !ctx.cr[6].eq {
	pc = 0x827FAC44; continue 'dispatch;
	}
	// 827FAC3C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 827FAC40: 48000020  b 0x827fac60
	pc = 0x827FAC60; continue 'dispatch;
            }
            0x827FAC44 => {
    //   block [0x827FAC44..0x827FAC5C)
	// 827FAC44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827FAC48: 419A0014  beq cr6, 0x827fac5c
	if ctx.cr[6].eq {
	pc = 0x827FAC5C; continue 'dispatch;
	}
	// 827FAC4C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FAC50: 419A000C  beq cr6, 0x827fac5c
	if ctx.cr[6].eq {
	pc = 0x827FAC5C; continue 'dispatch;
	}
	// 827FAC54: 4BA72B3D  bl 0x8226d790
	ctx.lr = 0x827FAC58;
	sub_8226D790(ctx, base);
	// 827FAC58: 48000008  b 0x827fac60
	pc = 0x827FAC60; continue 'dispatch;
            }
            0x827FAC5C => {
    //   block [0x827FAC5C..0x827FAC60)
	// 827FAC5C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x827FAC60; continue 'dispatch;
            }
            0x827FAC60 => {
    //   block [0x827FAC60..0x827FACCC)
	// 827FAC60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FAC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FAC68: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FAC6C: 419A0208  beq cr6, 0x827fae74
	if ctx.cr[6].eq {
	pc = 0x827FAE74; continue 'dispatch;
	}
	// 827FAC70: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 827FAC74: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 827FAC78: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 827FAC7C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FAC80: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 827FAC84: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 827FAC88: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827FAC8C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FAC90: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FAC94: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FAC98: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAC9C: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FACA0: 48006D59  bl 0x828019f8
	ctx.lr = 0x827FACA4;
	sub_828019F8(ctx, base);
	// 827FACA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827FACA8: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FACAC: 80810068  lwz r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FACB0: 3BEBBC68  addi r31, r11, -0x4398
	ctx.r[31].s64 = ctx.r[11].s64 + -17304;
	// 827FACB4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 827FACB8: 7CC32050  subf r6, r3, r4
	ctx.r[6].s64 = ctx.r[4].s64 - ctx.r[3].s64;
	// 827FACBC: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827FACC0: 7CDE1670  srawi r30, r6, 2
	ctx.xer.ca = (ctx.r[6].s32 < 0) && ((ctx.r[6].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[6].s32 >> 2) as i64;
	// 827FACC4: C01FD81C  lfs f0, -0x27e4(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-10212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 827FACC8: 419A0130  beq cr6, 0x827fadf8
	if ctx.cr[6].eq {
	pc = 0x827FADF8; continue 'dispatch;
	}
	pc = 0x827FACCC; continue 'dispatch;
            }
            0x827FACCC => {
    //   block [0x827FACCC..0x827FAD10)
	// 827FACCC: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FACD0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FACD4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FACD8: 5528FFFE  rlwinm r8, r9, 0x1f, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 827FACDC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FACE0: 419A00F4  beq cr6, 0x827fadd4
	if ctx.cr[6].eq {
	pc = 0x827FADD4; continue 'dispatch;
	}
	// 827FACE4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FACE8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FACEC: 419A0024  beq cr6, 0x827fad10
	if ctx.cr[6].eq {
	pc = 0x827FAD10; continue 'dispatch;
	}
	// 827FACF0: 894A0041  lbz r10, 0x41(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(65 as u32) ) } as u64;
	// 827FACF4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FACF8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827FACFC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827FAD00: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAD04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FAD08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FAD0C: 480000CC  b 0x827fadd8
	pc = 0x827FADD8; continue 'dispatch;
            }
            0x827FAD10 => {
    //   block [0x827FAD10..0x827FAD2C)
	// 827FAD10: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FAD14: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FAD18: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 827FAD1C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FAD20: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FAD24: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FAD28: 40810054  ble 0x827fad7c
	if !ctx.cr[0].gt {
	pc = 0x827FAD7C; continue 'dispatch;
	}
	pc = 0x827FAD2C; continue 'dispatch;
            }
            0x827FAD2C => {
    //   block [0x827FAD2C..0x827FAD4C)
	// 827FAD2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FAD30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FAD34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FAD38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FAD3C: 2F070041  cmpwi cr6, r7, 0x41
	ctx.cr[6].compare_i32(ctx.r[7].s32, 65, &mut ctx.xer);
	// 827FAD40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FAD44: 41980008  blt cr6, 0x827fad4c
	if ctx.cr[6].lt {
	pc = 0x827FAD4C; continue 'dispatch;
	}
	// 827FAD48: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x827FAD4C; continue 'dispatch;
            }
            0x827FAD4C => {
    //   block [0x827FAD4C..0x827FAD68)
	// 827FAD4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FAD50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FAD54: 419A0014  beq cr6, 0x827fad68
	if ctx.cr[6].eq {
	pc = 0x827FAD68; continue 'dispatch;
	}
	// 827FAD58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FAD5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FAD60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FAD64: 4800000C  b 0x827fad70
	pc = 0x827FAD70; continue 'dispatch;
            }
            0x827FAD68 => {
    //   block [0x827FAD68..0x827FAD70)
	// 827FAD68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FAD6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FAD70; continue 'dispatch;
            }
            0x827FAD70 => {
    //   block [0x827FAD70..0x827FAD7C)
	// 827FAD70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FAD74: 4199FFB8  bgt cr6, 0x827fad2c
	if ctx.cr[6].gt {
	pc = 0x827FAD2C; continue 'dispatch;
	}
	// 827FAD78: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x827FAD7C; continue 'dispatch;
            }
            0x827FAD7C => {
    //   block [0x827FAD7C..0x827FAD98)
	// 827FAD7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FAD80: 419A0040  beq cr6, 0x827fadc0
	if ctx.cr[6].eq {
	pc = 0x827FADC0; continue 'dispatch;
	}
	// 827FAD84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FAD88: 2F0B0041  cmpwi cr6, r11, 0x41
	ctx.cr[6].compare_i32(ctx.r[11].s32, 65, &mut ctx.xer);
	// 827FAD8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FAD90: 41990008  bgt cr6, 0x827fad98
	if ctx.cr[6].gt {
	pc = 0x827FAD98; continue 'dispatch;
	}
	// 827FAD94: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FAD98; continue 'dispatch;
            }
            0x827FAD98 => {
    //   block [0x827FAD98..0x827FADC0)
	// 827FAD98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FAD9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FADA0: 409A0020  bne cr6, 0x827fadc0
	if !ctx.cr[6].eq {
	pc = 0x827FADC0; continue 'dispatch;
	}
	// 827FADA4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FADA8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827FADAC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FADB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FADB4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FADB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FADBC: 4800001C  b 0x827fadd8
	pc = 0x827FADD8; continue 'dispatch;
            }
            0x827FADC0 => {
    //   block [0x827FADC0..0x827FADD4)
	// 827FADC0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FADC4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FADC8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FADCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FADD0: 48000008  b 0x827fadd8
	pc = 0x827FADD8; continue 'dispatch;
            }
            0x827FADD4 => {
    //   block [0x827FADD4..0x827FADD8)
	// 827FADD4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FADD8; continue 'dispatch;
            }
            0x827FADD8 => {
    //   block [0x827FADD8..0x827FADEC)
	// 827FADD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FADDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FADE0: 419A000C  beq cr6, 0x827fadec
	if ctx.cr[6].eq {
	pc = 0x827FADEC; continue 'dispatch;
	}
	// 827FADE4: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827FADE8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x827FADEC; continue 'dispatch;
            }
            0x827FADEC => {
    //   block [0x827FADEC..0x827FADF8)
	// 827FADEC: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 827FADF0: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 827FADF4: 409AFED8  bne cr6, 0x827faccc
	if !ctx.cr[6].eq {
	pc = 0x827FACCC; continue 'dispatch;
	}
	pc = 0x827FADF8; continue 'dispatch;
            }
            0x827FADF8 => {
    //   block [0x827FADF8..0x827FAE3C)
	// 827FADF8: 7FCB07B4  extsw r11, r30
	ctx.r[11].s64 = ctx.r[30].s32 as i64;
	// 827FADFC: C1BF0000  lfs f13, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 827FAE00: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 827FAE04: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827FAE08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827FAE0C: C9810060  lfd f12, 0x60(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827FAE10: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 827FAE14: C18A10CC  lfs f12, 0x10cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4300 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 827FAE18: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 827FAE1C: ED205024  fdivs f9, f0, f10
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 827FAE20: ED09682A  fadds f8, f9, f13
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64;
	// 827FAE24: ECE80332  fmuls f7, f8, f12
	ctx.f[7].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 827FAE28: FCC0381E  fctiwz f6, f7
	ctx.f[6].s64 = if ctx.f[7].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[7].f64.trunc() as i32 as i64 };
	// 827FAE2C: D8C10060  stfd f6, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.f[6].u64 ) };
	// 827FAE30: 83E10064  lwz r31, 0x64(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FAE34: 419A0008  beq cr6, 0x827fae3c
	if ctx.cr[6].eq {
	pc = 0x827FAE3C; continue 'dispatch;
	}
	// 827FAE38: 4BA20F01  bl 0x8221bd38
	ctx.lr = 0x827FAE3C;
	sub_8221BD38(ctx, base);
	pc = 0x827FAE3C; continue 'dispatch;
            }
            0x827FAE3C => {
    //   block [0x827FAE3C..0x827FAE4C)
	// 827FAE3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAE40: 4B9CB929  bl 0x821c6768
	ctx.lr = 0x827FAE44;
	sub_821C6768(ctx, base);
	// 827FAE44: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FAE48: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827FAE4C; continue 'dispatch;
            }
            0x827FAE4C => {
    //   block [0x827FAE4C..0x827FAE74)
	// 827FAE4C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827FAE50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FAE54: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827FAE58: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827FAE5C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FAE60: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FAE64: 4082FFE8  bne 0x827fae4c
	if !ctx.cr[0].eq {
	pc = 0x827FAE4C; continue 'dispatch;
	}
	// 827FAE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAE6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FAE70: 484AE5EC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FAE74 => {
    //   block [0x827FAE74..0x827FAEA4)
	// 827FAE74: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FAE78: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAE7C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FAE80: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAE84: 80690024  lwz r3, 0x24(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FAE88: 4BE5B889  bl 0x82656710
	ctx.lr = 0x827FAE8C;
	sub_82656710(ctx, base);
	// 827FAE8C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FAE90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAE94: 4BA19F45  bl 0x82214dd8
	ctx.lr = 0x827FAE98;
	sub_82214DD8(ctx, base);
	// 827FAE98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAE9C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FAEA0: 484AE5BC  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FAEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FAEA8 size=752
    let mut pc: u32 = 0x827FAEA8;
    'dispatch: loop {
        match pc {
            0x827FAEA8 => {
    //   block [0x827FAEA8..0x827FAF0C)
	// 827FAEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FAEAC: 484AE549  bl 0x82ca93f4
	ctx.lr = 0x827FAEB0;
	sub_82CA93D0(ctx, base);
	// 827FAEB0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FAEB4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827FAEB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827FAEBC: 3B0B0AF8  addi r24, r11, 0xaf8
	ctx.r[24].s64 = ctx.r[11].s64 + 2808;
	// 827FAEC0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827FAEC4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FAEC8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 827FAECC: 4BADB53D  bl 0x822d6408
	ctx.lr = 0x827FAED0;
	sub_822D6408(ctx, base);
	// 827FAED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAED4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FAED8: 48004529  bl 0x827ff400
	ctx.lr = 0x827FAEDC;
	sub_827FF400(ctx, base);
	// 827FAEDC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827FAEE0: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 827FAEE4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FAEE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FAEEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FAEF0: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAEF4: 480049C5  bl 0x827ff8b8
	ctx.lr = 0x827FAEF8;
	sub_827FF8B8(ctx, base);
	// 827FAEF8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FAEFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FAF00: 419A000C  beq cr6, 0x827faf0c
	if ctx.cr[6].eq {
	pc = 0x827FAF0C; continue 'dispatch;
	}
	// 827FAF04: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FAF08: 419A0008  beq cr6, 0x827faf10
	if ctx.cr[6].eq {
	pc = 0x827FAF10; continue 'dispatch;
	}
	pc = 0x827FAF0C; continue 'dispatch;
            }
            0x827FAF0C => {
    //   block [0x827FAF0C..0x827FAF10)
	// 827FAF0C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FAF10; continue 'dispatch;
            }
            0x827FAF10 => {
    //   block [0x827FAF10..0x827FAF58)
	// 827FAF10: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAF14: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FAF18: 419A0274  beq cr6, 0x827fb18c
	if ctx.cr[6].eq {
	pc = 0x827FB18C; continue 'dispatch;
	}
	// 827FAF1C: 3F808349  lis r28, -0x7cb7
	ctx.r[28].s64 = -2092367872;
	// 827FAF20: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FAF24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FAF28: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FAF2C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FAF30: 83AB0054  lwz r29, 0x54(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FAF34: 48004795  bl 0x827ff6c8
	ctx.lr = 0x827FAF38;
	sub_827FF6C8(ctx, base);
	// 827FAF38: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FAF3C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FAF40: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 827FAF44: 3B2B708C  addi r25, r11, 0x708c
	ctx.r[25].s64 = ctx.r[11].s64 + 28812;
	// 827FAF48: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAF4C: 83EA0000  lwz r31, 0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FAF50: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 827FAF54: 3AEA8D18  addi r23, r10, -0x72e8
	ctx.r[23].s64 = ctx.r[10].s64 + -29416;
	pc = 0x827FAF58; continue 'dispatch;
            }
            0x827FAF58 => {
    //   block [0x827FAF58..0x827FAF74)
	// 827FAF58: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAF5C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FAF60: 419A00B0  beq cr6, 0x827fb010
	if ctx.cr[6].eq {
	pc = 0x827FB010; continue 'dispatch;
	}
	// 827FAF64: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FAF68: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FAF6C: 409A0008  bne cr6, 0x827faf74
	if !ctx.cr[6].eq {
	pc = 0x827FAF74; continue 'dispatch;
	}
	// 827FAF70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FAF74; continue 'dispatch;
            }
            0x827FAF74 => {
    //   block [0x827FAF74..0x827FAFC0)
	// 827FAF74: 38BF0008  addi r5, r31, 8
	ctx.r[5].s64 = ctx.r[31].s64 + 8;
	// 827FAF78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FAF7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAF80: 4BB7FB19  bl 0x8237aa98
	ctx.lr = 0x827FAF84;
	sub_8237AA98(ctx, base);
	// 827FAF84: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FAF88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAF8C: 48343E1D  bl 0x82b3eda8
	ctx.lr = 0x827FAF90;
	sub_82B3EDA8(ctx, base);
	// 827FAF90: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FAF94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FAF98: 419A0034  beq cr6, 0x827fafcc
	if ctx.cr[6].eq {
	pc = 0x827FAFCC; continue 'dispatch;
	}
	// 827FAF9C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FAFA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FAFA4: 48343E05  bl 0x82b3eda8
	ctx.lr = 0x827FAFA8;
	sub_82B3EDA8(ctx, base);
	// 827FAFA8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FAFAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FAFB0: 419A0010  beq cr6, 0x827fafc0
	if ctx.cr[6].eq {
	pc = 0x827FAFC0; continue 'dispatch;
	}
	// 827FAFB4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FAFB8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FAFBC: 48343F65  bl 0x82b3ef20
	ctx.lr = 0x827FAFC0;
	sub_82B3EF20(ctx, base);
	pc = 0x827FAFC0; continue 'dispatch;
            }
            0x827FAFC0 => {
    //   block [0x827FAFC0..0x827FAFCC)
	// 827FAFC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FAFC4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FAFC8: 48343E89  bl 0x82b3ee50
	ctx.lr = 0x827FAFCC;
	sub_82B3EE50(ctx, base);
	pc = 0x827FAFCC; continue 'dispatch;
            }
            0x827FAFCC => {
    //   block [0x827FAFCC..0x827FAFD8)
	// 827FAFCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FAFD0: 4B9CB799  bl 0x821c6768
	ctx.lr = 0x827FAFD4;
	sub_821C6768(ctx, base);
	// 827FAFD4: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x827FAFD8; continue 'dispatch;
            }
            0x827FAFD8 => {
    //   block [0x827FAFD8..0x827FB008)
	// 827FAFD8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827FAFDC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FAFE0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827FAFE4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FAFE8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FAFEC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FAFF0: 4082FFE8  bne 0x827fafd8
	if !ctx.cr[0].eq {
	pc = 0x827FAFD8; continue 'dispatch;
	}
	// 827FAFF4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FAFF8: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 827FAFFC: 7F1F4040  cmplw cr6, r31, r8
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FB000: 409A0008  bne cr6, 0x827fb008
	if !ctx.cr[6].eq {
	pc = 0x827FB008; continue 'dispatch;
	}
	// 827FB004: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB008; continue 'dispatch;
            }
            0x827FB008 => {
    //   block [0x827FB008..0x827FB010)
	// 827FB008: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB00C: 4BFFFF4C  b 0x827faf58
	pc = 0x827FAF58; continue 'dispatch;
            }
            0x827FB010 => {
    //   block [0x827FB010..0x827FB05C)
	// 827FB010: 817C6AB8  lwz r11, 0x6ab8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FB014: 3940007C  li r10, 0x7c
	ctx.r[10].s64 = 124;
	// 827FB018: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 827FB01C: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FB020: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 827FB024: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 827FB028: 9361006C  stw r27, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[27].u32 ) };
	// 827FB02C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB030: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827FB034: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB038: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FB03C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB040: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB044: 480069B5  bl 0x828019f8
	ctx.lr = 0x827FB048;
	sub_828019F8(ctx, base);
	// 827FB048: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FB04C: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FB050: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827FB054: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FB058: 419A0124  beq cr6, 0x827fb17c
	if ctx.cr[6].eq {
	pc = 0x827FB17C; continue 'dispatch;
	}
	pc = 0x827FB05C; continue 'dispatch;
            }
            0x827FB05C => {
    //   block [0x827FB05C..0x827FB090)
	// 827FB05C: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB060: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FB064: 556A67FE  rlwinm r10, r11, 0xc, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x000FFFFFu64;
	// 827FB068: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FB06C: 419A0078  beq cr6, 0x827fb0e4
	if ctx.cr[6].eq {
	pc = 0x827FB0E4; continue 'dispatch;
	}
	// 827FB070: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FB074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB078: 409A0064  bne cr6, 0x827fb0dc
	if !ctx.cr[6].eq {
	pc = 0x827FB0DC; continue 'dispatch;
	}
	// 827FB07C: 8164004C  lwz r11, 0x4c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FB080: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FB084: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 827FB088: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FB08C: 40810050  ble 0x827fb0dc
	if !ctx.cr[0].gt {
	pc = 0x827FB0DC; continue 'dispatch;
	}
	pc = 0x827FB090; continue 'dispatch;
            }
            0x827FB090 => {
    //   block [0x827FB090..0x827FB0B0)
	// 827FB090: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FB094: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FB098: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FB09C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB0A0: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 827FB0A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FB0A8: 41980008  blt cr6, 0x827fb0b0
	if ctx.cr[6].lt {
	pc = 0x827FB0B0; continue 'dispatch;
	}
	// 827FB0AC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x827FB0B0; continue 'dispatch;
            }
            0x827FB0B0 => {
    //   block [0x827FB0B0..0x827FB0CC)
	// 827FB0B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FB0B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FB0B8: 419A0014  beq cr6, 0x827fb0cc
	if ctx.cr[6].eq {
	pc = 0x827FB0CC; continue 'dispatch;
	}
	// 827FB0BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FB0C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FB0C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FB0C8: 4800000C  b 0x827fb0d4
	pc = 0x827FB0D4; continue 'dispatch;
            }
            0x827FB0CC => {
    //   block [0x827FB0CC..0x827FB0D4)
	// 827FB0CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FB0D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FB0D4; continue 'dispatch;
            }
            0x827FB0D4 => {
    //   block [0x827FB0D4..0x827FB0DC)
	// 827FB0D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FB0D8: 4199FFB8  bgt cr6, 0x827fb090
	if ctx.cr[6].gt {
	pc = 0x827FB090; continue 'dispatch;
	}
	pc = 0x827FB0DC; continue 'dispatch;
            }
            0x827FB0DC => {
    //   block [0x827FB0DC..0x827FB0E4)
	// 827FB0DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FB0E0: 48000008  b 0x827fb0e8
	pc = 0x827FB0E8; continue 'dispatch;
            }
            0x827FB0E4 => {
    //   block [0x827FB0E4..0x827FB0E8)
	// 827FB0E4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x827FB0E8; continue 'dispatch;
            }
            0x827FB0E8 => {
    //   block [0x827FB0E8..0x827FB138)
	// 827FB0E8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FB0EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB0F0: 419A0080  beq cr6, 0x827fb170
	if ctx.cr[6].eq {
	pc = 0x827FB170; continue 'dispatch;
	}
	// 827FB0F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FB0F8: 4BBCD419  bl 0x823c8510
	ctx.lr = 0x827FB0FC;
	sub_823C8510(ctx, base);
	// 827FB0FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FB100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB104: 419A0040  beq cr6, 0x827fb144
	if ctx.cr[6].eq {
	pc = 0x827FB144; continue 'dispatch;
	}
	// 827FB108: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB10C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FB110: 419A0034  beq cr6, 0x827fb144
	if ctx.cr[6].eq {
	pc = 0x827FB144; continue 'dispatch;
	}
	// 827FB114: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FB118: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FB11C: 48343C8D  bl 0x82b3eda8
	ctx.lr = 0x827FB120;
	sub_82B3EDA8(ctx, base);
	// 827FB120: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FB124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB128: 419A0010  beq cr6, 0x827fb138
	if ctx.cr[6].eq {
	pc = 0x827FB138; continue 'dispatch;
	}
	// 827FB12C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FB130: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FB134: 48343DED  bl 0x82b3ef20
	ctx.lr = 0x827FB138;
	sub_82B3EF20(ctx, base);
	pc = 0x827FB138; continue 'dispatch;
            }
            0x827FB138 => {
    //   block [0x827FB138..0x827FB144)
	// 827FB138: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB13C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FB140: 48343D11  bl 0x82b3ee50
	ctx.lr = 0x827FB144;
	sub_82B3EE50(ctx, base);
	pc = 0x827FB144; continue 'dispatch;
            }
            0x827FB144 => {
    //   block [0x827FB144..0x827FB150)
	// 827FB144: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FB148: 4B9CB621  bl 0x821c6768
	ctx.lr = 0x827FB14C;
	sub_821C6768(ctx, base);
	// 827FB14C: 7F29CB78  mr r9, r25
	ctx.r[9].u64 = ctx.r[25].u64;
	pc = 0x827FB150; continue 'dispatch;
            }
            0x827FB150 => {
    //   block [0x827FB150..0x827FB170)
	// 827FB150: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827FB154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FB158: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827FB15C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FB160: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FB164: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FB168: 4082FFE8  bne 0x827fb150
	if !ctx.cr[0].eq {
	pc = 0x827FB150; continue 'dispatch;
	}
	// 827FB16C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	pc = 0x827FB170; continue 'dispatch;
            }
            0x827FB170 => {
    //   block [0x827FB170..0x827FB17C)
	// 827FB170: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 827FB174: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FB178: 409AFEE4  bne cr6, 0x827fb05c
	if !ctx.cr[6].eq {
	pc = 0x827FB05C; continue 'dispatch;
	}
	pc = 0x827FB17C; continue 'dispatch;
            }
            0x827FB17C => {
    //   block [0x827FB17C..0x827FB18C)
	// 827FB17C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827FB180: 419A000C  beq cr6, 0x827fb18c
	if ctx.cr[6].eq {
	pc = 0x827FB18C; continue 'dispatch;
	}
	// 827FB184: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FB188: 4BA20BB1  bl 0x8221bd38
	ctx.lr = 0x827FB18C;
	sub_8221BD38(ctx, base);
	pc = 0x827FB18C; continue 'dispatch;
            }
            0x827FB18C => {
    //   block [0x827FB18C..0x827FB198)
	// 827FB18C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FB190: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827FB194: 484AE2B0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB198(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB198 size=208
    let mut pc: u32 = 0x827FB198;
    'dispatch: loop {
        match pc {
            0x827FB198 => {
    //   block [0x827FB198..0x827FB1E0)
	// 827FB198: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB19C: 484AE26D  bl 0x82ca9408
	ctx.lr = 0x827FB1A0;
	sub_82CA93D0(ctx, base);
	// 827FB1A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB1A4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FB1A8: 48004259  bl 0x827ff400
	ctx.lr = 0x827FB1AC;
	sub_827FF400(ctx, base);
	// 827FB1AC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827FB1B0: 3BFE003C  addi r31, r30, 0x3c
	ctx.r[31].s64 = ctx.r[30].s64 + 60;
	// 827FB1B4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FB1B8: 83BE0040  lwz r29, 0x40(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 827FB1BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FB1C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FB1C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827FB1C8: 4BB7A031  bl 0x823751f8
	ctx.lr = 0x827FB1CC;
	sub_823751F8(ctx, base);
	// 827FB1CC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB1D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB1D4: 419A000C  beq cr6, 0x827fb1e0
	if ctx.cr[6].eq {
	pc = 0x827FB1E0; continue 'dispatch;
	}
	// 827FB1D8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FB1DC: 419A0008  beq cr6, 0x827fb1e4
	if ctx.cr[6].eq {
	pc = 0x827FB1E4; continue 'dispatch;
	}
	pc = 0x827FB1E0; continue 'dispatch;
            }
            0x827FB1E0 => {
    //   block [0x827FB1E0..0x827FB1E4)
	// 827FB1E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB1E4; continue 'dispatch;
            }
            0x827FB1E4 => {
    //   block [0x827FB1E4..0x827FB204)
	// 827FB1E4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB1E8: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FB1EC: 419A0018  beq cr6, 0x827fb204
	if ctx.cr[6].eq {
	pc = 0x827FB204; continue 'dispatch;
	}
	// 827FB1F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB1F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB1F8: 48004761  bl 0x827ff958
	ctx.lr = 0x827FB1FC;
	sub_827FF958(ctx, base);
	// 827FB1FC: 4BFFF60D  bl 0x827fa808
	ctx.lr = 0x827FB200;
	sub_827FA808(ctx, base);
	// 827FB200: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	pc = 0x827FB204; continue 'dispatch;
            }
            0x827FB204 => {
    //   block [0x827FB204..0x827FB230)
	// 827FB204: 3BFE0048  addi r31, r30, 0x48
	ctx.r[31].s64 = ctx.r[30].s64 + 72;
	// 827FB208: 83DE004C  lwz r30, 0x4c(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FB20C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FB210: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FB214: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FB218: 4BB79FE1  bl 0x823751f8
	ctx.lr = 0x827FB21C;
	sub_823751F8(ctx, base);
	// 827FB21C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB224: 419A000C  beq cr6, 0x827fb230
	if ctx.cr[6].eq {
	pc = 0x827FB230; continue 'dispatch;
	}
	// 827FB228: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FB22C: 419A0008  beq cr6, 0x827fb234
	if ctx.cr[6].eq {
	pc = 0x827FB234; continue 'dispatch;
	}
	pc = 0x827FB230; continue 'dispatch;
            }
            0x827FB230 => {
    //   block [0x827FB230..0x827FB234)
	// 827FB230: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB234; continue 'dispatch;
            }
            0x827FB234 => {
    //   block [0x827FB234..0x827FB25C)
	// 827FB234: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB238: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FB23C: 419A0020  beq cr6, 0x827fb25c
	if ctx.cr[6].eq {
	pc = 0x827FB25C; continue 'dispatch;
	}
	// 827FB240: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB248: 48004711  bl 0x827ff958
	ctx.lr = 0x827FB24C;
	sub_827FF958(ctx, base);
	// 827FB24C: 4BFFF5BD  bl 0x827fa808
	ctx.lr = 0x827FB250;
	sub_827FA808(ctx, base);
	// 827FB250: 7C63E214  add r3, r3, r28
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[28].u64;
	// 827FB254: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FB258: 484AE200  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FB25C => {
    //   block [0x827FB25C..0x827FB268)
	// 827FB25C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FB260: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FB264: 484AE1F4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB268 size=248
    let mut pc: u32 = 0x827FB268;
    'dispatch: loop {
        match pc {
            0x827FB268 => {
    //   block [0x827FB268..0x827FB2CC)
	// 827FB268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB26C: 484AE19D  bl 0x82ca9408
	ctx.lr = 0x827FB270;
	sub_82CA93D0(ctx, base);
	// 827FB270: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FB278: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FB27C: 48004185  bl 0x827ff400
	ctx.lr = 0x827FB280;
	sub_827FF400(ctx, base);
	// 827FB280: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FB284: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB288: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB28C: 48004085  bl 0x827ff310
	ctx.lr = 0x827FB290;
	sub_827FF310(ctx, base);
	// 827FB290: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FB294: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827FB298: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB29C: 419A00BC  beq cr6, 0x827fb358
	if ctx.cr[6].eq {
	pc = 0x827FB358; continue 'dispatch;
	}
	// 827FB2A0: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 827FB2A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FB2A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FB2AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FB2B0: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB2B4: 4BB79F45  bl 0x823751f8
	ctx.lr = 0x827FB2B8;
	sub_823751F8(ctx, base);
	// 827FB2B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB2BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB2C0: 419A000C  beq cr6, 0x827fb2cc
	if ctx.cr[6].eq {
	pc = 0x827FB2CC; continue 'dispatch;
	}
	// 827FB2C4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FB2C8: 419A0008  beq cr6, 0x827fb2d0
	if ctx.cr[6].eq {
	pc = 0x827FB2D0; continue 'dispatch;
	}
	pc = 0x827FB2CC; continue 'dispatch;
            }
            0x827FB2CC => {
    //   block [0x827FB2CC..0x827FB2D0)
	// 827FB2CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB2D0; continue 'dispatch;
            }
            0x827FB2D0 => {
    //   block [0x827FB2D0..0x827FB314)
	// 827FB2D0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB2D4: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FB2D8: 419A003C  beq cr6, 0x827fb314
	if ctx.cr[6].eq {
	pc = 0x827FB314; continue 'dispatch;
	}
	// 827FB2DC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB2E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB2E4: 48004675  bl 0x827ff958
	ctx.lr = 0x827FB2E8;
	sub_827FF958(ctx, base);
	// 827FB2E8: 4BFFF5C9  bl 0x827fa8b0
	ctx.lr = 0x827FB2EC;
	sub_827FA8B0(ctx, base);
	// 827FB2EC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827FB2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB2F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB2F8: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 827FB2FC: 4800465D  bl 0x827ff958
	ctx.lr = 0x827FB300;
	sub_827FF958(ctx, base);
	// 827FB300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 827FB304: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FB308: 4BFFF461  bl 0x827fa768
	ctx.lr = 0x827FB30C;
	sub_827FA768(ctx, base);
	// 827FB30C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FB310: 484AE148  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FB314 => {
    //   block [0x827FB314..0x827FB358)
	// 827FB314: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827FB318: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FB31C: 4821CC05  bl 0x82a17f20
	ctx.lr = 0x827FB320;
	sub_82A17F20(ctx, base);
	// 827FB320: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB328: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 827FB32C: 4800462D  bl 0x827ff958
	ctx.lr = 0x827FB330;
	sub_827FF958(ctx, base);
	// 827FB330: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB334: 4800002D  bl 0x827fb360
	ctx.lr = 0x827FB338;
	sub_827FB360(ctx, base);
	// 827FB338: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FB33C: 4BEDE71D  bl 0x826d9a58
	ctx.lr = 0x827FB340;
	sub_826D9A58(ctx, base);
	// 827FB340: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB348: 48004611  bl 0x827ff958
	ctx.lr = 0x827FB34C;
	sub_827FF958(ctx, base);
	// 827FB34C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FB350: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FB354: 4BFFF415  bl 0x827fa768
	ctx.lr = 0x827FB358;
	sub_827FA768(ctx, base);
	pc = 0x827FB358; continue 'dispatch;
            }
            0x827FB358 => {
    //   block [0x827FB358..0x827FB360)
	// 827FB358: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FB35C: 484AE0FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB360 size=108
    let mut pc: u32 = 0x827FB360;
    'dispatch: loop {
        match pc {
            0x827FB360 => {
    //   block [0x827FB360..0x827FB3C0)
	// 827FB360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB364: 484AE0A9  bl 0x82ca940c
	ctx.lr = 0x827FB368;
	sub_82CA93D0(ctx, base);
	// 827FB368: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB36C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB370: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FB374: 3BA40004  addi r29, r4, 4
	ctx.r[29].s64 = ctx.r[4].s64 + 4;
	// 827FB378: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 827FB37C: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FB380: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827FB384: 419A003C  beq cr6, 0x827fb3c0
	if ctx.cr[6].eq {
	pc = 0x827FB3C0; continue 'dispatch;
	}
	// 827FB388: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB38C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FB390: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827FB394: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FB398: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827FB39C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB3A0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FB3A4: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FB3A8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FB3AC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FB3B0: 4BAF5459  bl 0x822f0808
	ctx.lr = 0x827FB3B4;
	sub_822F0808(ctx, base);
	// 827FB3B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FB3B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB3BC: 4800499D  bl 0x827ffd58
	ctx.lr = 0x827FB3C0;
	sub_827FFD58(ctx, base);
	pc = 0x827FB3C0; continue 'dispatch;
            }
            0x827FB3C0 => {
    //   block [0x827FB3C0..0x827FB3CC)
	// 827FB3C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FB3C4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827FB3C8: 484AE094  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB3D0 size=212
    let mut pc: u32 = 0x827FB3D0;
    'dispatch: loop {
        match pc {
            0x827FB3D0 => {
    //   block [0x827FB3D0..0x827FB434)
	// 827FB3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB3D4: 484AE035  bl 0x82ca9408
	ctx.lr = 0x827FB3D8;
	sub_82CA93D0(ctx, base);
	// 827FB3D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB3DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FB3E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FB3E4: 4800401D  bl 0x827ff400
	ctx.lr = 0x827FB3E8;
	sub_827FF400(ctx, base);
	// 827FB3E8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FB3EC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB3F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB3F4: 48003F1D  bl 0x827ff310
	ctx.lr = 0x827FB3F8;
	sub_827FF310(ctx, base);
	// 827FB3F8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FB3FC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 827FB400: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB404: 419A0098  beq cr6, 0x827fb49c
	if ctx.cr[6].eq {
	pc = 0x827FB49C; continue 'dispatch;
	}
	// 827FB408: 3BFF0048  addi r31, r31, 0x48
	ctx.r[31].s64 = ctx.r[31].s64 + 72;
	// 827FB40C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FB410: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FB414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FB418: 83DF0004  lwz r30, 4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB41C: 4BB79DDD  bl 0x823751f8
	ctx.lr = 0x827FB420;
	sub_823751F8(ctx, base);
	// 827FB420: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB424: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB428: 419A000C  beq cr6, 0x827fb434
	if ctx.cr[6].eq {
	pc = 0x827FB434; continue 'dispatch;
	}
	// 827FB42C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FB430: 419A0008  beq cr6, 0x827fb438
	if ctx.cr[6].eq {
	pc = 0x827FB438; continue 'dispatch;
	}
	pc = 0x827FB434; continue 'dispatch;
            }
            0x827FB434 => {
    //   block [0x827FB434..0x827FB438)
	// 827FB434: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB438; continue 'dispatch;
            }
            0x827FB438 => {
    //   block [0x827FB438..0x827FB488)
	// 827FB438: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB43C: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FB440: 409A0048  bne cr6, 0x827fb488
	if !ctx.cr[6].eq {
	pc = 0x827FB488; continue 'dispatch;
	}
	// 827FB444: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827FB448: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FB44C: 4821CAD5  bl 0x82a17f20
	ctx.lr = 0x827FB450;
	sub_82A17F20(ctx, base);
	// 827FB450: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB454: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB458: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 827FB45C: 480044FD  bl 0x827ff958
	ctx.lr = 0x827FB460;
	sub_827FF958(ctx, base);
	// 827FB460: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB464: 4BFFFEFD  bl 0x827fb360
	ctx.lr = 0x827FB468;
	sub_827FB360(ctx, base);
	// 827FB468: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FB46C: 4BEDE5ED  bl 0x826d9a58
	ctx.lr = 0x827FB470;
	sub_826D9A58(ctx, base);
	// 827FB470: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB478: 480044E1  bl 0x827ff958
	ctx.lr = 0x827FB47C;
	sub_827FF958(ctx, base);
	// 827FB47C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FB480: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FB484: 4BFFF2E5  bl 0x827fa768
	ctx.lr = 0x827FB488;
	sub_827FA768(ctx, base);
	pc = 0x827FB488; continue 'dispatch;
            }
            0x827FB488 => {
    //   block [0x827FB488..0x827FB49C)
	// 827FB488: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB48C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB490: 480044C9  bl 0x827ff958
	ctx.lr = 0x827FB494;
	sub_827FF958(ctx, base);
	// 827FB494: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FB498: 4BFFF229  bl 0x827fa6c0
	ctx.lr = 0x827FB49C;
	sub_827FA6C0(ctx, base);
	pc = 0x827FB49C; continue 'dispatch;
            }
            0x827FB49C => {
    //   block [0x827FB49C..0x827FB4A4)
	// 827FB49C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FB4A0: 484ADFB8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB4A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB4A8 size=144
    let mut pc: u32 = 0x827FB4A8;
    'dispatch: loop {
        match pc {
            0x827FB4A8 => {
    //   block [0x827FB4A8..0x827FB520)
	// 827FB4A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB4AC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FB4B0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FB4B4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FB4B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB4BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FB4C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FB4C4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FB4C8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB4CC: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FB4D0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB4D4: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FB4D8: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB4DC: 80A60024  lwz r5, 0x24(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FB4E0: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB4E4: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FB4E8: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FB4EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB4F0: 419A0030  beq cr6, 0x827fb520
	if ctx.cr[6].eq {
	pc = 0x827FB520; continue 'dispatch;
	}
	// 827FB4F4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB4F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FB4FC: 419A0024  beq cr6, 0x827fb520
	if ctx.cr[6].eq {
	pc = 0x827FB520; continue 'dispatch;
	}
	// 827FB500: 48003E11  bl 0x827ff310
	ctx.lr = 0x827FB504;
	sub_827FF310(ctx, base);
	// 827FB504: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FB508: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FB50C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FB510: 387F006C  addi r3, r31, 0x6c
	ctx.r[3].s64 = ctx.r[31].s64 + 108;
	// 827FB514: 48004445  bl 0x827ff958
	ctx.lr = 0x827FB518;
	sub_827FF958(ctx, base);
	// 827FB518: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB51C: 4BFFF1A5  bl 0x827fa6c0
	ctx.lr = 0x827FB520;
	sub_827FA6C0(ctx, base);
	pc = 0x827FB520; continue 'dispatch;
            }
            0x827FB520 => {
    //   block [0x827FB520..0x827FB538)
	// 827FB520: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FB524: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FB528: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FB52C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FB530: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FB534: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FB538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FB538 size=8720
    let mut pc: u32 = 0x827FB538;
    'dispatch: loop {
        match pc {
            0x827FB538 => {
    //   block [0x827FB538..0x827FB588)
	// 827FB538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FB53C: 484ADEB1  bl 0x82ca93ec
	ctx.lr = 0x827FB540;
	sub_82CA93D0(ctx, base);
	// 827FB540: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FB544: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 827FB548: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827FB54C: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 827FB550: 409A21A0  bne cr6, 0x827fd6f0
	if !ctx.cr[6].eq {
	pc = 0x827FD6F0; continue 'dispatch;
	}
	// 827FB554: 54CB063E  clrlwi r11, r6, 0x18
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 827FB558: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB55C: 419A1154  beq cr6, 0x827fc6b0
	if ctx.cr[6].eq {
	pc = 0x827FC6B0; continue 'dispatch;
	}
	// 827FB560: 81550010  lwz r10, 0x10(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FB564: 3BB5000C  addi r29, r21, 0xc
	ctx.r[29].s64 = ctx.r[21].s64 + 12;
	// 827FB568: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 827FB56C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827FB570: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827FB574: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827FB578: 3AC94AC8  addi r22, r9, 0x4ac8
	ctx.r[22].s64 = ctx.r[9].s64 + 19144;
	// 827FB57C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB580: 3BC8A5AC  addi r30, r8, -0x5a54
	ctx.r[30].s64 = ctx.r[8].s64 + -23124;
	// 827FB584: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x827FB588; continue 'dispatch;
            }
            0x827FB588 => {
    //   block [0x827FB588..0x827FB59C)
	// 827FB588: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB58C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB590: 419A000C  beq cr6, 0x827fb59c
	if ctx.cr[6].eq {
	pc = 0x827FB59C; continue 'dispatch;
	}
	// 827FB594: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FB598: 419A0008  beq cr6, 0x827fb5a0
	if ctx.cr[6].eq {
	pc = 0x827FB5A0; continue 'dispatch;
	}
	pc = 0x827FB59C; continue 'dispatch;
            }
            0x827FB59C => {
    //   block [0x827FB59C..0x827FB5A0)
	// 827FB59C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB5A0; continue 'dispatch;
            }
            0x827FB5A0 => {
    //   block [0x827FB5A0..0x827FB5B4)
	// 827FB5A0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB5A4: 419A00A0  beq cr6, 0x827fb644
	if ctx.cr[6].eq {
	pc = 0x827FB644; continue 'dispatch;
	}
	// 827FB5A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB5AC: 409A0008  bne cr6, 0x827fb5b4
	if !ctx.cr[6].eq {
	pc = 0x827FB5B4; continue 'dispatch;
	}
	// 827FB5B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB5B4; continue 'dispatch;
            }
            0x827FB5B4 => {
    //   block [0x827FB5B4..0x827FB5C4)
	// 827FB5B4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB5B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB5BC: 409A0008  bne cr6, 0x827fb5c4
	if !ctx.cr[6].eq {
	pc = 0x827FB5C4; continue 'dispatch;
	}
	// 827FB5C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB5C4; continue 'dispatch;
            }
            0x827FB5C4 => {
    //   block [0x827FB5C4..0x827FB5DC)
	// 827FB5C4: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB5C8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 827FB5CC: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB5D0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FB5D4: 409A0008  bne cr6, 0x827fb5dc
	if !ctx.cr[6].eq {
	pc = 0x827FB5DC; continue 'dispatch;
	}
	// 827FB5D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB5DC; continue 'dispatch;
            }
            0x827FB5DC => {
    //   block [0x827FB5DC..0x827FB644)
	// 827FB5DC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB5E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB5E4: 814A0010  lwz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FB5E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB5EC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB5F0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827FB5F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FB5F8: 4E800421  bctrl
	ctx.lr = 0x827FB5FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB5FC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FB600: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FB604: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB608: 4BB94A81  bl 0x82390088
	ctx.lr = 0x827FB60C;
	sub_82390088(ctx, base);
	// 827FB60C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FB610: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FB614: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB618: 4BC851B1  bl 0x824807c8
	ctx.lr = 0x827FB61C;
	sub_824807C8(ctx, base);
	// 827FB61C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB620: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB624: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB628: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FB62C: 4E800421  bctrl
	ctx.lr = 0x827FB630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB630: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FB634: 4BD5B225  bl 0x82556858
	ctx.lr = 0x827FB638;
	sub_82556858(ctx, base);
	// 827FB638: 81410064  lwz r10, 0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FB63C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FB640: 4BFFFF48  b 0x827fb588
	pc = 0x827FB588; continue 'dispatch;
            }
            0x827FB644 => {
    //   block [0x827FB644..0x827FB674)
	// 827FB644: 8175001C  lwz r11, 0x1c(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(28 as u32) ) } as u64;
	// 827FB648: 3B550018  addi r26, r21, 0x18
	ctx.r[26].s64 = ctx.r[21].s64 + 24;
	// 827FB64C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FB650: 7F5CD378  mr r28, r26
	ctx.r[28].u64 = ctx.r[26].u64;
	// 827FB654: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827FB658: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827FB65C: 3B6AA5CC  addi r27, r10, -0x5a34
	ctx.r[27].s64 = ctx.r[10].s64 + -23092;
	// 827FB660: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB664: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827FB668: 3B29A5B8  addi r25, r9, -0x5a48
	ctx.r[25].s64 = ctx.r[9].s64 + -23112;
	// 827FB66C: 3B0B9A68  addi r24, r11, -0x6598
	ctx.r[24].s64 = ctx.r[11].s64 + -26008;
	// 827FB670: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	pc = 0x827FB674; continue 'dispatch;
            }
            0x827FB674 => {
    //   block [0x827FB674..0x827FB688)
	// 827FB674: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB678: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB67C: 419A000C  beq cr6, 0x827fb688
	if ctx.cr[6].eq {
	pc = 0x827FB688; continue 'dispatch;
	}
	// 827FB680: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FB684: 419A0008  beq cr6, 0x827fb68c
	if ctx.cr[6].eq {
	pc = 0x827FB68C; continue 'dispatch;
	}
	pc = 0x827FB688; continue 'dispatch;
            }
            0x827FB688 => {
    //   block [0x827FB688..0x827FB68C)
	// 827FB688: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB68C; continue 'dispatch;
            }
            0x827FB68C => {
    //   block [0x827FB68C..0x827FB6A0)
	// 827FB68C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB690: 419A010C  beq cr6, 0x827fb79c
	if ctx.cr[6].eq {
	pc = 0x827FB79C; continue 'dispatch;
	}
	// 827FB694: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB698: 409A0008  bne cr6, 0x827fb6a0
	if !ctx.cr[6].eq {
	pc = 0x827FB6A0; continue 'dispatch;
	}
	// 827FB69C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB6A0; continue 'dispatch;
            }
            0x827FB6A0 => {
    //   block [0x827FB6A0..0x827FB6B0)
	// 827FB6A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB6A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB6A8: 409A0008  bne cr6, 0x827fb6b0
	if !ctx.cr[6].eq {
	pc = 0x827FB6B0; continue 'dispatch;
	}
	// 827FB6AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB6B0; continue 'dispatch;
            }
            0x827FB6B0 => {
    //   block [0x827FB6B0..0x827FB6E8)
	// 827FB6B0: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FB6B4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FB6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB6BC: 419A00CC  beq cr6, 0x827fb788
	if ctx.cr[6].eq {
	pc = 0x827FB788; continue 'dispatch;
	}
	// 827FB6C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB6C4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FB6C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB6CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB6D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB6D4: 4E800421  bctrl
	ctx.lr = 0x827FB6D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB6D8: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB6DC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB6E0: 409A0008  bne cr6, 0x827fb6e8
	if !ctx.cr[6].eq {
	pc = 0x827FB6E8; continue 'dispatch;
	}
	// 827FB6E4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB6E8 => {
    //   block [0x827FB6E8..0x827FB708)
	// 827FB6E8: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB6EC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FB6F0: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FB6F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB6F8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FB6FC: 4BB9498D  bl 0x82390088
	ctx.lr = 0x827FB700;
	sub_82390088(ctx, base);
	// 827FB700: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB704: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FB708; continue 'dispatch;
            }
            0x827FB708 => {
    //   block [0x827FB708..0x827FB738)
	// 827FB708: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB70C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB710: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB714: 419A0068  beq cr6, 0x827fb77c
	if ctx.cr[6].eq {
	pc = 0x827FB77C; continue 'dispatch;
	}
	// 827FB718: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB71C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FB720: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB724: 4E800421  bctrl
	ctx.lr = 0x827FB728;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB728: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB72C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB730: 409A0008  bne cr6, 0x827fb738
	if !ctx.cr[6].eq {
	pc = 0x827FB738; continue 'dispatch;
	}
	// 827FB734: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB738 => {
    //   block [0x827FB738..0x827FB774)
	// 827FB738: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FB73C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FB740: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FB744: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB748: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827FB74C: 4BB9493D  bl 0x82390088
	ctx.lr = 0x827FB750;
	sub_82390088(ctx, base);
	// 827FB750: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB754: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB758: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB75C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FB760: 4E800421  bctrl
	ctx.lr = 0x827FB764;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB764: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB768: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB76C: 409A0008  bne cr6, 0x827fb774
	if !ctx.cr[6].eq {
	pc = 0x827FB774; continue 'dispatch;
	}
	// 827FB770: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB774 => {
    //   block [0x827FB774..0x827FB77C)
	// 827FB774: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB778: 4BFFFF90  b 0x827fb708
	pc = 0x827FB708; continue 'dispatch;
            }
            0x827FB77C => {
    //   block [0x827FB77C..0x827FB788)
	// 827FB77C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB780: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB784: 4E800421  bctrl
	ctx.lr = 0x827FB788;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FB788 => {
    //   block [0x827FB788..0x827FB79C)
	// 827FB788: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FB78C: 482A0D8D  bl 0x82a9c518
	ctx.lr = 0x827FB790;
	sub_82A9C518(ctx, base);
	// 827FB790: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FB794: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FB798: 4BFFFEDC  b 0x827fb674
	pc = 0x827FB674; continue 'dispatch;
            }
            0x827FB79C => {
    //   block [0x827FB79C..0x827FB7C4)
	// 827FB79C: 81750034  lwz r11, 0x34(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(52 as u32) ) } as u64;
	// 827FB7A0: 3B750030  addi r27, r21, 0x30
	ctx.r[27].s64 = ctx.r[21].s64 + 48;
	// 827FB7A4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FB7A8: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 827FB7AC: 3B4AA5DC  addi r26, r10, -0x5a24
	ctx.r[26].s64 = ctx.r[10].s64 + -23076;
	// 827FB7B0: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827FB7B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB7B8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FB7BC: 3B2BA5F0  addi r25, r11, -0x5a10
	ctx.r[25].s64 = ctx.r[11].s64 + -23056;
	// 827FB7C0: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	pc = 0x827FB7C4; continue 'dispatch;
            }
            0x827FB7C4 => {
    //   block [0x827FB7C4..0x827FB7D8)
	// 827FB7C4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB7C8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB7CC: 419A000C  beq cr6, 0x827fb7d8
	if ctx.cr[6].eq {
	pc = 0x827FB7D8; continue 'dispatch;
	}
	// 827FB7D0: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FB7D4: 419A0008  beq cr6, 0x827fb7dc
	if ctx.cr[6].eq {
	pc = 0x827FB7DC; continue 'dispatch;
	}
	pc = 0x827FB7D8; continue 'dispatch;
            }
            0x827FB7D8 => {
    //   block [0x827FB7D8..0x827FB7DC)
	// 827FB7D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB7DC; continue 'dispatch;
            }
            0x827FB7DC => {
    //   block [0x827FB7DC..0x827FB7F0)
	// 827FB7DC: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB7E0: 419A010C  beq cr6, 0x827fb8ec
	if ctx.cr[6].eq {
	pc = 0x827FB8EC; continue 'dispatch;
	}
	// 827FB7E4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB7E8: 409A0008  bne cr6, 0x827fb7f0
	if !ctx.cr[6].eq {
	pc = 0x827FB7F0; continue 'dispatch;
	}
	// 827FB7EC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB7F0; continue 'dispatch;
            }
            0x827FB7F0 => {
    //   block [0x827FB7F0..0x827FB800)
	// 827FB7F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB7F4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB7F8: 409A0008  bne cr6, 0x827fb800
	if !ctx.cr[6].eq {
	pc = 0x827FB800; continue 'dispatch;
	}
	// 827FB7FC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB800; continue 'dispatch;
            }
            0x827FB800 => {
    //   block [0x827FB800..0x827FB838)
	// 827FB800: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FB804: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FB808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB80C: 419A00CC  beq cr6, 0x827fb8d8
	if ctx.cr[6].eq {
	pc = 0x827FB8D8; continue 'dispatch;
	}
	// 827FB810: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB814: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FB818: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB81C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB820: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB824: 4E800421  bctrl
	ctx.lr = 0x827FB828;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB828: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB82C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB830: 409A0008  bne cr6, 0x827fb838
	if !ctx.cr[6].eq {
	pc = 0x827FB838; continue 'dispatch;
	}
	// 827FB834: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB838 => {
    //   block [0x827FB838..0x827FB858)
	// 827FB838: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB83C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FB840: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FB844: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB848: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FB84C: 4BB9483D  bl 0x82390088
	ctx.lr = 0x827FB850;
	sub_82390088(ctx, base);
	// 827FB850: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB854: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FB858; continue 'dispatch;
            }
            0x827FB858 => {
    //   block [0x827FB858..0x827FB888)
	// 827FB858: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB85C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB860: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB864: 419A0068  beq cr6, 0x827fb8cc
	if ctx.cr[6].eq {
	pc = 0x827FB8CC; continue 'dispatch;
	}
	// 827FB868: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB86C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FB870: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB874: 4E800421  bctrl
	ctx.lr = 0x827FB878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB878: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB87C: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB880: 409A0008  bne cr6, 0x827fb888
	if !ctx.cr[6].eq {
	pc = 0x827FB888; continue 'dispatch;
	}
	// 827FB884: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB888 => {
    //   block [0x827FB888..0x827FB8C4)
	// 827FB888: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FB88C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FB890: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FB894: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB898: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827FB89C: 4BB947ED  bl 0x82390088
	ctx.lr = 0x827FB8A0;
	sub_82390088(ctx, base);
	// 827FB8A0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB8A8: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB8AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FB8B0: 4E800421  bctrl
	ctx.lr = 0x827FB8B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB8B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB8B8: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB8BC: 409A0008  bne cr6, 0x827fb8c4
	if !ctx.cr[6].eq {
	pc = 0x827FB8C4; continue 'dispatch;
	}
	// 827FB8C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB8C4 => {
    //   block [0x827FB8C4..0x827FB8CC)
	// 827FB8C4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB8C8: 4BFFFF90  b 0x827fb858
	pc = 0x827FB858; continue 'dispatch;
            }
            0x827FB8CC => {
    //   block [0x827FB8CC..0x827FB8D8)
	// 827FB8CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB8D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB8D4: 4E800421  bctrl
	ctx.lr = 0x827FB8D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FB8D8 => {
    //   block [0x827FB8D8..0x827FB8EC)
	// 827FB8D8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FB8DC: 482A0C3D  bl 0x82a9c518
	ctx.lr = 0x827FB8E0;
	sub_82A9C518(ctx, base);
	// 827FB8E0: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FB8E4: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FB8E8: 4BFFFEDC  b 0x827fb7c4
	pc = 0x827FB7C4; continue 'dispatch;
            }
            0x827FB8EC => {
    //   block [0x827FB8EC..0x827FB90C)
	// 827FB8EC: 81750028  lwz r11, 0x28(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(40 as u32) ) } as u64;
	// 827FB8F0: 3B750024  addi r27, r21, 0x24
	ctx.r[27].s64 = ctx.r[21].s64 + 36;
	// 827FB8F4: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 827FB8F8: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 827FB8FC: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB900: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FB904: 3B4BA5F8  addi r26, r11, -0x5a08
	ctx.r[26].s64 = ctx.r[11].s64 + -23048;
	// 827FB908: 93C10064  stw r30, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[30].u32 ) };
	pc = 0x827FB90C; continue 'dispatch;
            }
            0x827FB90C => {
    //   block [0x827FB90C..0x827FB920)
	// 827FB90C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB910: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB914: 419A000C  beq cr6, 0x827fb920
	if ctx.cr[6].eq {
	pc = 0x827FB920; continue 'dispatch;
	}
	// 827FB918: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FB91C: 419A0008  beq cr6, 0x827fb924
	if ctx.cr[6].eq {
	pc = 0x827FB924; continue 'dispatch;
	}
	pc = 0x827FB920; continue 'dispatch;
            }
            0x827FB920 => {
    //   block [0x827FB920..0x827FB924)
	// 827FB920: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB924; continue 'dispatch;
            }
            0x827FB924 => {
    //   block [0x827FB924..0x827FB938)
	// 827FB924: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB928: 419A010C  beq cr6, 0x827fba34
	if ctx.cr[6].eq {
	pc = 0x827FBA34; continue 'dispatch;
	}
	// 827FB92C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FB930: 409A0008  bne cr6, 0x827fb938
	if !ctx.cr[6].eq {
	pc = 0x827FB938; continue 'dispatch;
	}
	// 827FB934: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB938; continue 'dispatch;
            }
            0x827FB938 => {
    //   block [0x827FB938..0x827FB948)
	// 827FB938: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB93C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB940: 409A0008  bne cr6, 0x827fb948
	if !ctx.cr[6].eq {
	pc = 0x827FB948; continue 'dispatch;
	}
	// 827FB944: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FB948; continue 'dispatch;
            }
            0x827FB948 => {
    //   block [0x827FB948..0x827FB980)
	// 827FB948: 817E0018  lwz r11, 0x18(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FB94C: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FB950: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FB954: 419A00CC  beq cr6, 0x827fba20
	if ctx.cr[6].eq {
	pc = 0x827FBA20; continue 'dispatch;
	}
	// 827FB958: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB95C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FB960: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB964: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB968: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB96C: 4E800421  bctrl
	ctx.lr = 0x827FB970;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB970: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB974: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB978: 409A0008  bne cr6, 0x827fb980
	if !ctx.cr[6].eq {
	pc = 0x827FB980; continue 'dispatch;
	}
	// 827FB97C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB980 => {
    //   block [0x827FB980..0x827FB9A0)
	// 827FB980: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB984: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FB988: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FB98C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB990: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FB994: 4BB946F5  bl 0x82390088
	ctx.lr = 0x827FB998;
	sub_82390088(ctx, base);
	// 827FB998: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB99C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FB9A0; continue 'dispatch;
            }
            0x827FB9A0 => {
    //   block [0x827FB9A0..0x827FB9D0)
	// 827FB9A0: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FB9A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB9AC: 419A0068  beq cr6, 0x827fba14
	if ctx.cr[6].eq {
	pc = 0x827FBA14; continue 'dispatch;
	}
	// 827FB9B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB9B4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FB9B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FB9BC: 4E800421  bctrl
	ctx.lr = 0x827FB9C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB9C0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FB9C4: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FB9C8: 409A0008  bne cr6, 0x827fb9d0
	if !ctx.cr[6].eq {
	pc = 0x827FB9D0; continue 'dispatch;
	}
	// 827FB9CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FB9D0 => {
    //   block [0x827FB9D0..0x827FBA0C)
	// 827FB9D0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FB9D4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FB9D8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FB9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB9E0: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 827FB9E4: 4BB946A5  bl 0x82390088
	ctx.lr = 0x827FB9E8;
	sub_82390088(ctx, base);
	// 827FB9E8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FB9EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FB9F0: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FB9F4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FB9F8: 4E800421  bctrl
	ctx.lr = 0x827FB9FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FB9FC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBA00: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FBA04: 409A0008  bne cr6, 0x827fba0c
	if !ctx.cr[6].eq {
	pc = 0x827FBA0C; continue 'dispatch;
	}
	// 827FBA08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
            }
            0x827FBA0C => {
    //   block [0x827FBA0C..0x827FBA14)
	// 827FBA0C: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBA10: 4BFFFF90  b 0x827fb9a0
	pc = 0x827FB9A0; continue 'dispatch;
            }
            0x827FBA14 => {
    //   block [0x827FBA14..0x827FBA20)
	// 827FBA14: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBA18: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBA1C: 4E800421  bctrl
	ctx.lr = 0x827FBA20;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FBA20 => {
    //   block [0x827FBA20..0x827FBA34)
	// 827FBA20: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FBA24: 482A0AF5  bl 0x82a9c518
	ctx.lr = 0x827FBA28;
	sub_82A9C518(ctx, base);
	// 827FBA28: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FBA2C: 83810060  lwz r28, 0x60(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FBA30: 4BFFFEDC  b 0x827fb90c
	pc = 0x827FB90C; continue 'dispatch;
            }
            0x827FBA34 => {
    //   block [0x827FBA34..0x827FBA74)
	// 827FBA34: 81750040  lwz r11, 0x40(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(64 as u32) ) } as u64;
	// 827FBA38: 3B75003C  addi r27, r21, 0x3c
	ctx.r[27].s64 = ctx.r[21].s64 + 60;
	// 827FBA3C: 3CE0820E  lis r7, -0x7df2
	ctx.r[7].s64 = -2113011712;
	// 827FBA40: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827FBA44: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827FBA48: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827FBA4C: 90C10068  stw r6, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u32 ) };
	// 827FBA50: 83AB0000  lwz r29, 0(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBA54: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FBA58: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FBA5C: 3B47A64C  addi r26, r7, -0x59b4
	ctx.r[26].s64 = ctx.r[7].s64 + -22964;
	// 827FBA60: 3B28A644  addi r25, r8, -0x59bc
	ctx.r[25].s64 = ctx.r[8].s64 + -22972;
	// 827FBA64: 3B09A634  addi r24, r9, -0x59cc
	ctx.r[24].s64 = ctx.r[9].s64 + -22988;
	// 827FBA68: 93A1006C  stw r29, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[29].u32 ) };
	// 827FBA6C: 3AEAA624  addi r23, r10, -0x59dc
	ctx.r[23].s64 = ctx.r[10].s64 + -23004;
	// 827FBA70: 3B8BA610  addi r28, r11, -0x59f0
	ctx.r[28].s64 = ctx.r[11].s64 + -23024;
	pc = 0x827FBA74; continue 'dispatch;
            }
            0x827FBA74 => {
    //   block [0x827FBA74..0x827FBA88)
	// 827FBA74: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBA78: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 827FBA7C: 419A000C  beq cr6, 0x827fba88
	if ctx.cr[6].eq {
	pc = 0x827FBA88; continue 'dispatch;
	}
	// 827FBA80: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FBA84: 419A0008  beq cr6, 0x827fba8c
	if ctx.cr[6].eq {
	pc = 0x827FBA8C; continue 'dispatch;
	}
	pc = 0x827FBA88; continue 'dispatch;
            }
            0x827FBA88 => {
    //   block [0x827FBA88..0x827FBA8C)
	// 827FBA88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBA8C; continue 'dispatch;
            }
            0x827FBA8C => {
    //   block [0x827FBA8C..0x827FBAA0)
	// 827FBA8C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FBA90: 419A0188  beq cr6, 0x827fbc18
	if ctx.cr[6].eq {
	pc = 0x827FBC18; continue 'dispatch;
	}
	// 827FBA94: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 827FBA98: 409A0008  bne cr6, 0x827fbaa0
	if !ctx.cr[6].eq {
	pc = 0x827FBAA0; continue 'dispatch;
	}
	// 827FBA9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBAA0; continue 'dispatch;
            }
            0x827FBAA0 => {
    //   block [0x827FBAA0..0x827FBAB0)
	// 827FBAA0: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBAA4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FBAA8: 409A0008  bne cr6, 0x827fbab0
	if !ctx.cr[6].eq {
	pc = 0x827FBAB0; continue 'dispatch;
	}
	// 827FBAAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBAB0; continue 'dispatch;
            }
            0x827FBAB0 => {
    //   block [0x827FBAB0..0x827FBAC8)
	// 827FBAB0: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBAB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FBAB8: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBABC: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBAC0: 409A0008  bne cr6, 0x827fbac8
	if !ctx.cr[6].eq {
	pc = 0x827FBAC8; continue 'dispatch;
	}
	// 827FBAC4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBAC8; continue 'dispatch;
            }
            0x827FBAC8 => {
    //   block [0x827FBAC8..0x827FBB0C)
	// 827FBAC8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBACC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FBAD0: 3BDD0010  addi r30, r29, 0x10
	ctx.r[30].s64 = ctx.r[29].s64 + 16;
	// 827FBAD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBAD8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBAE0: 4E800421  bctrl
	ctx.lr = 0x827FBAE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBAE4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FBAE8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FBAEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBAF0: 4BB94599  bl 0x82390088
	ctx.lr = 0x827FBAF4;
	sub_82390088(ctx, base);
	// 827FBAF4: 813D0018  lwz r9, 0x18(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FBAF8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827FBAFC: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 827FBB00: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBB04: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 827FBB08: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
            }
            0x827FBB0C => {
    //   block [0x827FBB0C..0x827FBB20)
	// 827FBB0C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBB10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBB14: 419A000C  beq cr6, 0x827fbb20
	if ctx.cr[6].eq {
	pc = 0x827FBB20; continue 'dispatch;
	}
	// 827FBB18: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FBB1C: 419A0008  beq cr6, 0x827fbb24
	if ctx.cr[6].eq {
	pc = 0x827FBB24; continue 'dispatch;
	}
	pc = 0x827FBB20; continue 'dispatch;
            }
            0x827FBB20 => {
    //   block [0x827FBB20..0x827FBB24)
	// 827FBB20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBB24; continue 'dispatch;
            }
            0x827FBB24 => {
    //   block [0x827FBB24..0x827FBB38)
	// 827FBB24: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBB28: 419A00C8  beq cr6, 0x827fbbf0
	if ctx.cr[6].eq {
	pc = 0x827FBBF0; continue 'dispatch;
	}
	// 827FBB2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBB30: 409A0008  bne cr6, 0x827fbb38
	if !ctx.cr[6].eq {
	pc = 0x827FBB38; continue 'dispatch;
	}
	// 827FBB34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBB38; continue 'dispatch;
            }
            0x827FBB38 => {
    //   block [0x827FBB38..0x827FBB48)
	// 827FBB38: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBB3C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBB40: 409A0008  bne cr6, 0x827fbb48
	if !ctx.cr[6].eq {
	pc = 0x827FBB48; continue 'dispatch;
	}
	// 827FBB44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBB48; continue 'dispatch;
            }
            0x827FBB48 => {
    //   block [0x827FBB48..0x827FBB60)
	// 827FBB48: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBB4C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FBB50: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBB54: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBB58: 409A0008  bne cr6, 0x827fbb60
	if !ctx.cr[6].eq {
	pc = 0x827FBB60; continue 'dispatch;
	}
	// 827FBB5C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBB60; continue 'dispatch;
            }
            0x827FBB60 => {
    //   block [0x827FBB60..0x827FBB78)
	// 827FBB60: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FBB64: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FBB68: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBB6C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBB70: 409A0008  bne cr6, 0x827fbb78
	if !ctx.cr[6].eq {
	pc = 0x827FBB78; continue 'dispatch;
	}
	// 827FBB74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBB78; continue 'dispatch;
            }
            0x827FBB78 => {
    //   block [0x827FBB78..0x827FBBF0)
	// 827FBB78: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBB7C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FBB80: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FBB84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBB88: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBB8C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FBB90: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FBB94: 4E800421  bctrl
	ctx.lr = 0x827FBB98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBB98: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FBB9C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FBBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBBA4: 4BB944E5  bl 0x82390088
	ctx.lr = 0x827FBBA8;
	sub_82390088(ctx, base);
	// 827FBBA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FBBAC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FBBB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBBB4: 4BC84C15  bl 0x824807c8
	ctx.lr = 0x827FBBB8;
	sub_824807C8(ctx, base);
	// 827FBBB8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FBBBC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FBBC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBBC4: 4BC84C05  bl 0x824807c8
	ctx.lr = 0x827FBBC8;
	sub_824807C8(ctx, base);
	// 827FBBC8: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBBCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBBD0: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBBD4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FBBD8: 4E800421  bctrl
	ctx.lr = 0x827FBBDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBBDC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FBBE0: 4BC41211  bl 0x8243cdf0
	ctx.lr = 0x827FBBE4;
	sub_8243CDF0(ctx, base);
	// 827FBBE4: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FBBE8: 81410070  lwz r10, 0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FBBEC: 4BFFFF20  b 0x827fbb0c
	pc = 0x827FBB0C; continue 'dispatch;
            }
            0x827FBBF0 => {
    //   block [0x827FBBF0..0x827FBC18)
	// 827FBBF0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBBF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBBF8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBBFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBC00: 4E800421  bctrl
	ctx.lr = 0x827FBC04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBC04: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FBC08: 4BB18F21  bl 0x82314b28
	ctx.lr = 0x827FBC0C;
	sub_82314B28(ctx, base);
	// 827FBC0C: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FBC10: 83A1006C  lwz r29, 0x6c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FBC14: 4BFFFE60  b 0x827fba74
	pc = 0x827FBA74; continue 'dispatch;
            }
            0x827FBC18 => {
    //   block [0x827FBC18..0x827FBC38)
	// 827FBC18: 8155004C  lwz r10, 0x4c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FBC1C: 3B750048  addi r27, r21, 0x48
	ctx.r[27].s64 = ctx.r[21].s64 + 72;
	// 827FBC20: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FBC24: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FBC28: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBC2C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FBC30: 3B8AA654  addi r28, r10, -0x59ac
	ctx.r[28].s64 = ctx.r[10].s64 + -22956;
	// 827FBC34: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FBC38; continue 'dispatch;
            }
            0x827FBC38 => {
    //   block [0x827FBC38..0x827FBC4C)
	// 827FBC38: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBC40: 419A000C  beq cr6, 0x827fbc4c
	if ctx.cr[6].eq {
	pc = 0x827FBC4C; continue 'dispatch;
	}
	// 827FBC44: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FBC48: 419A0008  beq cr6, 0x827fbc50
	if ctx.cr[6].eq {
	pc = 0x827FBC50; continue 'dispatch;
	}
	pc = 0x827FBC4C; continue 'dispatch;
            }
            0x827FBC4C => {
    //   block [0x827FBC4C..0x827FBC50)
	// 827FBC4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBC50; continue 'dispatch;
            }
            0x827FBC50 => {
    //   block [0x827FBC50..0x827FBC64)
	// 827FBC50: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBC54: 419A0188  beq cr6, 0x827fbddc
	if ctx.cr[6].eq {
	pc = 0x827FBDDC; continue 'dispatch;
	}
	// 827FBC58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBC5C: 409A0008  bne cr6, 0x827fbc64
	if !ctx.cr[6].eq {
	pc = 0x827FBC64; continue 'dispatch;
	}
	// 827FBC60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBC64; continue 'dispatch;
            }
            0x827FBC64 => {
    //   block [0x827FBC64..0x827FBC74)
	// 827FBC64: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBC68: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBC6C: 409A0008  bne cr6, 0x827fbc74
	if !ctx.cr[6].eq {
	pc = 0x827FBC74; continue 'dispatch;
	}
	// 827FBC70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBC74; continue 'dispatch;
            }
            0x827FBC74 => {
    //   block [0x827FBC74..0x827FBC8C)
	// 827FBC74: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBC78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FBC7C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBC80: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBC84: 409A0008  bne cr6, 0x827fbc8c
	if !ctx.cr[6].eq {
	pc = 0x827FBC8C; continue 'dispatch;
	}
	// 827FBC88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBC8C; continue 'dispatch;
            }
            0x827FBC8C => {
    //   block [0x827FBC8C..0x827FBCD0)
	// 827FBC8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBC90: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FBC94: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FBC98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBC9C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBCA0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBCA4: 4E800421  bctrl
	ctx.lr = 0x827FBCA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBCA8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FBCAC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FBCB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBCB4: 4BB943D5  bl 0x82390088
	ctx.lr = 0x827FBCB8;
	sub_82390088(ctx, base);
	// 827FBCB8: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FBCBC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FBCC0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FBCC4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBCC8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FBCCC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FBCD0 => {
    //   block [0x827FBCD0..0x827FBCE4)
	// 827FBCD0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBCD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBCD8: 419A000C  beq cr6, 0x827fbce4
	if ctx.cr[6].eq {
	pc = 0x827FBCE4; continue 'dispatch;
	}
	// 827FBCDC: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FBCE0: 419A0008  beq cr6, 0x827fbce8
	if ctx.cr[6].eq {
	pc = 0x827FBCE8; continue 'dispatch;
	}
	pc = 0x827FBCE4; continue 'dispatch;
            }
            0x827FBCE4 => {
    //   block [0x827FBCE4..0x827FBCE8)
	// 827FBCE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBCE8; continue 'dispatch;
            }
            0x827FBCE8 => {
    //   block [0x827FBCE8..0x827FBCFC)
	// 827FBCE8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBCEC: 419A00C8  beq cr6, 0x827fbdb4
	if ctx.cr[6].eq {
	pc = 0x827FBDB4; continue 'dispatch;
	}
	// 827FBCF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBCF4: 409A0008  bne cr6, 0x827fbcfc
	if !ctx.cr[6].eq {
	pc = 0x827FBCFC; continue 'dispatch;
	}
	// 827FBCF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBCFC; continue 'dispatch;
            }
            0x827FBCFC => {
    //   block [0x827FBCFC..0x827FBD0C)
	// 827FBCFC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBD00: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBD04: 409A0008  bne cr6, 0x827fbd0c
	if !ctx.cr[6].eq {
	pc = 0x827FBD0C; continue 'dispatch;
	}
	// 827FBD08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBD0C; continue 'dispatch;
            }
            0x827FBD0C => {
    //   block [0x827FBD0C..0x827FBD24)
	// 827FBD0C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBD10: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FBD14: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBD18: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBD1C: 409A0008  bne cr6, 0x827fbd24
	if !ctx.cr[6].eq {
	pc = 0x827FBD24; continue 'dispatch;
	}
	// 827FBD20: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBD24; continue 'dispatch;
            }
            0x827FBD24 => {
    //   block [0x827FBD24..0x827FBD3C)
	// 827FBD24: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FBD28: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FBD2C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBD30: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBD34: 409A0008  bne cr6, 0x827fbd3c
	if !ctx.cr[6].eq {
	pc = 0x827FBD3C; continue 'dispatch;
	}
	// 827FBD38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBD3C; continue 'dispatch;
            }
            0x827FBD3C => {
    //   block [0x827FBD3C..0x827FBDB4)
	// 827FBD3C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBD40: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FBD44: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FBD48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBD4C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBD50: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FBD54: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FBD58: 4E800421  bctrl
	ctx.lr = 0x827FBD5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBD5C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FBD60: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FBD64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBD68: 4BB94321  bl 0x82390088
	ctx.lr = 0x827FBD6C;
	sub_82390088(ctx, base);
	// 827FBD6C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FBD70: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FBD74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBD78: 4BC84A51  bl 0x824807c8
	ctx.lr = 0x827FBD7C;
	sub_824807C8(ctx, base);
	// 827FBD7C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FBD80: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FBD84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBD88: 4BC84A41  bl 0x824807c8
	ctx.lr = 0x827FBD8C;
	sub_824807C8(ctx, base);
	// 827FBD8C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBD90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBD94: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBD98: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FBD9C: 4E800421  bctrl
	ctx.lr = 0x827FBDA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBDA0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FBDA4: 4BC4104D  bl 0x8243cdf0
	ctx.lr = 0x827FBDA8;
	sub_8243CDF0(ctx, base);
	// 827FBDA8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FBDAC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FBDB0: 4BFFFF20  b 0x827fbcd0
	pc = 0x827FBCD0; continue 'dispatch;
            }
            0x827FBDB4 => {
    //   block [0x827FBDB4..0x827FBDDC)
	// 827FBDB4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBDBC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBDC0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBDC4: 4E800421  bctrl
	ctx.lr = 0x827FBDC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBDC8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FBDCC: 4BB18D5D  bl 0x82314b28
	ctx.lr = 0x827FBDD0;
	sub_82314B28(ctx, base);
	// 827FBDD0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FBDD4: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FBDD8: 4BFFFE60  b 0x827fbc38
	pc = 0x827FBC38; continue 'dispatch;
            }
            0x827FBDDC => {
    //   block [0x827FBDDC..0x827FBDFC)
	// 827FBDDC: 81550058  lwz r10, 0x58(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FBDE0: 3B750054  addi r27, r21, 0x54
	ctx.r[27].s64 = ctx.r[21].s64 + 84;
	// 827FBDE4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FBDE8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FBDEC: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBDF0: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FBDF4: 3B8AA674  addi r28, r10, -0x598c
	ctx.r[28].s64 = ctx.r[10].s64 + -22924;
	// 827FBDF8: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FBDFC; continue 'dispatch;
            }
            0x827FBDFC => {
    //   block [0x827FBDFC..0x827FBE10)
	// 827FBDFC: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBE00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBE04: 419A000C  beq cr6, 0x827fbe10
	if ctx.cr[6].eq {
	pc = 0x827FBE10; continue 'dispatch;
	}
	// 827FBE08: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FBE0C: 419A0008  beq cr6, 0x827fbe14
	if ctx.cr[6].eq {
	pc = 0x827FBE14; continue 'dispatch;
	}
	pc = 0x827FBE10; continue 'dispatch;
            }
            0x827FBE10 => {
    //   block [0x827FBE10..0x827FBE14)
	// 827FBE10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBE14; continue 'dispatch;
            }
            0x827FBE14 => {
    //   block [0x827FBE14..0x827FBE28)
	// 827FBE14: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBE18: 419A0188  beq cr6, 0x827fbfa0
	if ctx.cr[6].eq {
	pc = 0x827FBFA0; continue 'dispatch;
	}
	// 827FBE1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBE20: 409A0008  bne cr6, 0x827fbe28
	if !ctx.cr[6].eq {
	pc = 0x827FBE28; continue 'dispatch;
	}
	// 827FBE24: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBE28; continue 'dispatch;
            }
            0x827FBE28 => {
    //   block [0x827FBE28..0x827FBE38)
	// 827FBE28: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBE2C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBE30: 409A0008  bne cr6, 0x827fbe38
	if !ctx.cr[6].eq {
	pc = 0x827FBE38; continue 'dispatch;
	}
	// 827FBE34: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBE38; continue 'dispatch;
            }
            0x827FBE38 => {
    //   block [0x827FBE38..0x827FBE50)
	// 827FBE38: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBE3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FBE40: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBE44: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBE48: 409A0008  bne cr6, 0x827fbe50
	if !ctx.cr[6].eq {
	pc = 0x827FBE50; continue 'dispatch;
	}
	// 827FBE4C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBE50; continue 'dispatch;
            }
            0x827FBE50 => {
    //   block [0x827FBE50..0x827FBE94)
	// 827FBE50: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBE54: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FBE58: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FBE5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBE60: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBE64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBE68: 4E800421  bctrl
	ctx.lr = 0x827FBE6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBE6C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FBE70: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FBE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBE78: 4BB94211  bl 0x82390088
	ctx.lr = 0x827FBE7C;
	sub_82390088(ctx, base);
	// 827FBE7C: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FBE80: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FBE84: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FBE88: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBE8C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FBE90: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FBE94 => {
    //   block [0x827FBE94..0x827FBEA8)
	// 827FBE94: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBE98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBE9C: 419A000C  beq cr6, 0x827fbea8
	if ctx.cr[6].eq {
	pc = 0x827FBEA8; continue 'dispatch;
	}
	// 827FBEA0: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FBEA4: 419A0008  beq cr6, 0x827fbeac
	if ctx.cr[6].eq {
	pc = 0x827FBEAC; continue 'dispatch;
	}
	pc = 0x827FBEA8; continue 'dispatch;
            }
            0x827FBEA8 => {
    //   block [0x827FBEA8..0x827FBEAC)
	// 827FBEA8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBEAC; continue 'dispatch;
            }
            0x827FBEAC => {
    //   block [0x827FBEAC..0x827FBEC0)
	// 827FBEAC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBEB0: 419A00C8  beq cr6, 0x827fbf78
	if ctx.cr[6].eq {
	pc = 0x827FBF78; continue 'dispatch;
	}
	// 827FBEB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FBEB8: 409A0008  bne cr6, 0x827fbec0
	if !ctx.cr[6].eq {
	pc = 0x827FBEC0; continue 'dispatch;
	}
	// 827FBEBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBEC0; continue 'dispatch;
            }
            0x827FBEC0 => {
    //   block [0x827FBEC0..0x827FBED0)
	// 827FBEC0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBEC4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FBEC8: 409A0008  bne cr6, 0x827fbed0
	if !ctx.cr[6].eq {
	pc = 0x827FBED0; continue 'dispatch;
	}
	// 827FBECC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBED0; continue 'dispatch;
            }
            0x827FBED0 => {
    //   block [0x827FBED0..0x827FBEE8)
	// 827FBED0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBED4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FBED8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBEDC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBEE0: 409A0008  bne cr6, 0x827fbee8
	if !ctx.cr[6].eq {
	pc = 0x827FBEE8; continue 'dispatch;
	}
	// 827FBEE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBEE8; continue 'dispatch;
            }
            0x827FBEE8 => {
    //   block [0x827FBEE8..0x827FBF00)
	// 827FBEE8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FBEEC: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FBEF0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBEF4: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FBEF8: 409A0008  bne cr6, 0x827fbf00
	if !ctx.cr[6].eq {
	pc = 0x827FBF00; continue 'dispatch;
	}
	// 827FBEFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBF00; continue 'dispatch;
            }
            0x827FBF00 => {
    //   block [0x827FBF00..0x827FBF78)
	// 827FBF00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBF04: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FBF08: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FBF0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF10: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBF14: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FBF18: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FBF1C: 4E800421  bctrl
	ctx.lr = 0x827FBF20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBF20: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FBF24: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FBF28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF2C: 4BB9415D  bl 0x82390088
	ctx.lr = 0x827FBF30;
	sub_82390088(ctx, base);
	// 827FBF30: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FBF34: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FBF38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF3C: 4BC8488D  bl 0x824807c8
	ctx.lr = 0x827FBF40;
	sub_824807C8(ctx, base);
	// 827FBF40: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FBF44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FBF48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF4C: 4BC8487D  bl 0x824807c8
	ctx.lr = 0x827FBF50;
	sub_824807C8(ctx, base);
	// 827FBF50: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF58: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBF5C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FBF60: 4E800421  bctrl
	ctx.lr = 0x827FBF64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBF64: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FBF68: 4BC40E89  bl 0x8243cdf0
	ctx.lr = 0x827FBF6C;
	sub_8243CDF0(ctx, base);
	// 827FBF6C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FBF70: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FBF74: 4BFFFF20  b 0x827fbe94
	pc = 0x827FBE94; continue 'dispatch;
            }
            0x827FBF78 => {
    //   block [0x827FBF78..0x827FBFA0)
	// 827FBF78: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBF7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FBF80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FBF84: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FBF88: 4E800421  bctrl
	ctx.lr = 0x827FBF8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FBF8C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FBF90: 4BB18B99  bl 0x82314b28
	ctx.lr = 0x827FBF94;
	sub_82314B28(ctx, base);
	// 827FBF94: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FBF98: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FBF9C: 4BFFFE60  b 0x827fbdfc
	pc = 0x827FBDFC; continue 'dispatch;
            }
            0x827FBFA0 => {
    //   block [0x827FBFA0..0x827FBFC0)
	// 827FBFA0: 81550064  lwz r10, 0x64(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FBFA4: 3B750060  addi r27, r21, 0x60
	ctx.r[27].s64 = ctx.r[21].s64 + 96;
	// 827FBFA8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FBFAC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FBFB0: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FBFB4: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FBFB8: 3B8AA688  addi r28, r10, -0x5978
	ctx.r[28].s64 = ctx.r[10].s64 + -22904;
	// 827FBFBC: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FBFC0; continue 'dispatch;
            }
            0x827FBFC0 => {
    //   block [0x827FBFC0..0x827FBFD4)
	// 827FBFC0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBFC8: 419A000C  beq cr6, 0x827fbfd4
	if ctx.cr[6].eq {
	pc = 0x827FBFD4; continue 'dispatch;
	}
	// 827FBFCC: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FBFD0: 419A0008  beq cr6, 0x827fbfd8
	if ctx.cr[6].eq {
	pc = 0x827FBFD8; continue 'dispatch;
	}
	pc = 0x827FBFD4; continue 'dispatch;
            }
            0x827FBFD4 => {
    //   block [0x827FBFD4..0x827FBFD8)
	// 827FBFD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBFD8; continue 'dispatch;
            }
            0x827FBFD8 => {
    //   block [0x827FBFD8..0x827FBFEC)
	// 827FBFD8: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBFDC: 419A0188  beq cr6, 0x827fc164
	if ctx.cr[6].eq {
	pc = 0x827FC164; continue 'dispatch;
	}
	// 827FBFE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FBFE4: 409A0008  bne cr6, 0x827fbfec
	if !ctx.cr[6].eq {
	pc = 0x827FBFEC; continue 'dispatch;
	}
	// 827FBFE8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBFEC; continue 'dispatch;
            }
            0x827FBFEC => {
    //   block [0x827FBFEC..0x827FBFFC)
	// 827FBFEC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FBFF0: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FBFF4: 409A0008  bne cr6, 0x827fbffc
	if !ctx.cr[6].eq {
	pc = 0x827FBFFC; continue 'dispatch;
	}
	// 827FBFF8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FBFFC; continue 'dispatch;
            }
            0x827FBFFC => {
    //   block [0x827FBFFC..0x827FC014)
	// 827FBFFC: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC000: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FC004: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC008: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC00C: 409A0008  bne cr6, 0x827fc014
	if !ctx.cr[6].eq {
	pc = 0x827FC014; continue 'dispatch;
	}
	// 827FC010: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC014; continue 'dispatch;
            }
            0x827FC014 => {
    //   block [0x827FC014..0x827FC058)
	// 827FC014: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC018: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC01C: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FC020: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC024: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC028: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC02C: 4E800421  bctrl
	ctx.lr = 0x827FC030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC030: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FC034: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FC038: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC03C: 4BB9404D  bl 0x82390088
	ctx.lr = 0x827FC040;
	sub_82390088(ctx, base);
	// 827FC040: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FC044: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FC048: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FC04C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC050: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FC054: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FC058 => {
    //   block [0x827FC058..0x827FC06C)
	// 827FC058: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC05C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC060: 419A000C  beq cr6, 0x827fc06c
	if ctx.cr[6].eq {
	pc = 0x827FC06C; continue 'dispatch;
	}
	// 827FC064: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FC068: 419A0008  beq cr6, 0x827fc070
	if ctx.cr[6].eq {
	pc = 0x827FC070; continue 'dispatch;
	}
	pc = 0x827FC06C; continue 'dispatch;
            }
            0x827FC06C => {
    //   block [0x827FC06C..0x827FC070)
	// 827FC06C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC070; continue 'dispatch;
            }
            0x827FC070 => {
    //   block [0x827FC070..0x827FC084)
	// 827FC070: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC074: 419A00C8  beq cr6, 0x827fc13c
	if ctx.cr[6].eq {
	pc = 0x827FC13C; continue 'dispatch;
	}
	// 827FC078: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC07C: 409A0008  bne cr6, 0x827fc084
	if !ctx.cr[6].eq {
	pc = 0x827FC084; continue 'dispatch;
	}
	// 827FC080: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC084; continue 'dispatch;
            }
            0x827FC084 => {
    //   block [0x827FC084..0x827FC094)
	// 827FC084: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC088: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC08C: 409A0008  bne cr6, 0x827fc094
	if !ctx.cr[6].eq {
	pc = 0x827FC094; continue 'dispatch;
	}
	// 827FC090: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC094; continue 'dispatch;
            }
            0x827FC094 => {
    //   block [0x827FC094..0x827FC0AC)
	// 827FC094: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC098: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FC09C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC0A0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC0A4: 409A0008  bne cr6, 0x827fc0ac
	if !ctx.cr[6].eq {
	pc = 0x827FC0AC; continue 'dispatch;
	}
	// 827FC0A8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC0AC; continue 'dispatch;
            }
            0x827FC0AC => {
    //   block [0x827FC0AC..0x827FC0C4)
	// 827FC0AC: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FC0B0: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FC0B4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC0B8: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC0BC: 409A0008  bne cr6, 0x827fc0c4
	if !ctx.cr[6].eq {
	pc = 0x827FC0C4; continue 'dispatch;
	}
	// 827FC0C0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC0C4; continue 'dispatch;
            }
            0x827FC0C4 => {
    //   block [0x827FC0C4..0x827FC13C)
	// 827FC0C4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC0C8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC0CC: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FC0D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC0D4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC0D8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FC0DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC0E0: 4E800421  bctrl
	ctx.lr = 0x827FC0E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC0E4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FC0E8: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FC0EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC0F0: 4BB93F99  bl 0x82390088
	ctx.lr = 0x827FC0F4;
	sub_82390088(ctx, base);
	// 827FC0F4: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC0F8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC0FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC100: 4BC846C9  bl 0x824807c8
	ctx.lr = 0x827FC104;
	sub_824807C8(ctx, base);
	// 827FC104: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC108: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC10C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC110: 4BC846B9  bl 0x824807c8
	ctx.lr = 0x827FC114;
	sub_824807C8(ctx, base);
	// 827FC114: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC11C: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC120: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC124: 4E800421  bctrl
	ctx.lr = 0x827FC128;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC128: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FC12C: 4BC40CC5  bl 0x8243cdf0
	ctx.lr = 0x827FC130;
	sub_8243CDF0(ctx, base);
	// 827FC130: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FC134: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FC138: 4BFFFF20  b 0x827fc058
	pc = 0x827FC058; continue 'dispatch;
            }
            0x827FC13C => {
    //   block [0x827FC13C..0x827FC164)
	// 827FC13C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC140: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC144: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC148: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC14C: 4E800421  bctrl
	ctx.lr = 0x827FC150;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC150: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FC154: 4BB189D5  bl 0x82314b28
	ctx.lr = 0x827FC158;
	sub_82314B28(ctx, base);
	// 827FC158: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FC15C: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FC160: 4BFFFE60  b 0x827fbfc0
	pc = 0x827FBFC0; continue 'dispatch;
            }
            0x827FC164 => {
    //   block [0x827FC164..0x827FC184)
	// 827FC164: 81550070  lwz r10, 0x70(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FC168: 3B75006C  addi r27, r21, 0x6c
	ctx.r[27].s64 = ctx.r[21].s64 + 108;
	// 827FC16C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FC170: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FC174: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC178: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FC17C: 3B8AA6A8  addi r28, r10, -0x5958
	ctx.r[28].s64 = ctx.r[10].s64 + -22872;
	// 827FC180: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FC184; continue 'dispatch;
            }
            0x827FC184 => {
    //   block [0x827FC184..0x827FC198)
	// 827FC184: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC18C: 419A000C  beq cr6, 0x827fc198
	if ctx.cr[6].eq {
	pc = 0x827FC198; continue 'dispatch;
	}
	// 827FC190: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FC194: 419A0008  beq cr6, 0x827fc19c
	if ctx.cr[6].eq {
	pc = 0x827FC19C; continue 'dispatch;
	}
	pc = 0x827FC198; continue 'dispatch;
            }
            0x827FC198 => {
    //   block [0x827FC198..0x827FC19C)
	// 827FC198: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC19C; continue 'dispatch;
            }
            0x827FC19C => {
    //   block [0x827FC19C..0x827FC1B0)
	// 827FC19C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC1A0: 419A0188  beq cr6, 0x827fc328
	if ctx.cr[6].eq {
	pc = 0x827FC328; continue 'dispatch;
	}
	// 827FC1A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC1A8: 409A0008  bne cr6, 0x827fc1b0
	if !ctx.cr[6].eq {
	pc = 0x827FC1B0; continue 'dispatch;
	}
	// 827FC1AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC1B0; continue 'dispatch;
            }
            0x827FC1B0 => {
    //   block [0x827FC1B0..0x827FC1C0)
	// 827FC1B0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC1B4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC1B8: 409A0008  bne cr6, 0x827fc1c0
	if !ctx.cr[6].eq {
	pc = 0x827FC1C0; continue 'dispatch;
	}
	// 827FC1BC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC1C0; continue 'dispatch;
            }
            0x827FC1C0 => {
    //   block [0x827FC1C0..0x827FC1D8)
	// 827FC1C0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC1C4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FC1C8: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC1CC: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC1D0: 409A0008  bne cr6, 0x827fc1d8
	if !ctx.cr[6].eq {
	pc = 0x827FC1D8; continue 'dispatch;
	}
	// 827FC1D4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC1D8; continue 'dispatch;
            }
            0x827FC1D8 => {
    //   block [0x827FC1D8..0x827FC21C)
	// 827FC1D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC1DC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC1E0: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FC1E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC1E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC1EC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC1F0: 4E800421  bctrl
	ctx.lr = 0x827FC1F4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC1F4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FC1F8: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FC1FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC200: 4BB93E89  bl 0x82390088
	ctx.lr = 0x827FC204;
	sub_82390088(ctx, base);
	// 827FC204: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FC208: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FC20C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FC210: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC214: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FC218: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FC21C => {
    //   block [0x827FC21C..0x827FC230)
	// 827FC21C: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC220: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC224: 419A000C  beq cr6, 0x827fc230
	if ctx.cr[6].eq {
	pc = 0x827FC230; continue 'dispatch;
	}
	// 827FC228: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FC22C: 419A0008  beq cr6, 0x827fc234
	if ctx.cr[6].eq {
	pc = 0x827FC234; continue 'dispatch;
	}
	pc = 0x827FC230; continue 'dispatch;
            }
            0x827FC230 => {
    //   block [0x827FC230..0x827FC234)
	// 827FC230: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC234; continue 'dispatch;
            }
            0x827FC234 => {
    //   block [0x827FC234..0x827FC248)
	// 827FC234: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC238: 419A00C8  beq cr6, 0x827fc300
	if ctx.cr[6].eq {
	pc = 0x827FC300; continue 'dispatch;
	}
	// 827FC23C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC240: 409A0008  bne cr6, 0x827fc248
	if !ctx.cr[6].eq {
	pc = 0x827FC248; continue 'dispatch;
	}
	// 827FC244: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC248; continue 'dispatch;
            }
            0x827FC248 => {
    //   block [0x827FC248..0x827FC258)
	// 827FC248: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC24C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC250: 409A0008  bne cr6, 0x827fc258
	if !ctx.cr[6].eq {
	pc = 0x827FC258; continue 'dispatch;
	}
	// 827FC254: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC258; continue 'dispatch;
            }
            0x827FC258 => {
    //   block [0x827FC258..0x827FC270)
	// 827FC258: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC25C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FC260: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC264: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC268: 409A0008  bne cr6, 0x827fc270
	if !ctx.cr[6].eq {
	pc = 0x827FC270; continue 'dispatch;
	}
	// 827FC26C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC270; continue 'dispatch;
            }
            0x827FC270 => {
    //   block [0x827FC270..0x827FC288)
	// 827FC270: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FC274: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FC278: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC27C: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC280: 409A0008  bne cr6, 0x827fc288
	if !ctx.cr[6].eq {
	pc = 0x827FC288; continue 'dispatch;
	}
	// 827FC284: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC288; continue 'dispatch;
            }
            0x827FC288 => {
    //   block [0x827FC288..0x827FC300)
	// 827FC288: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC28C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC290: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FC294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC298: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC29C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FC2A0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC2A4: 4E800421  bctrl
	ctx.lr = 0x827FC2A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC2A8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FC2AC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FC2B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC2B4: 4BB93DD5  bl 0x82390088
	ctx.lr = 0x827FC2B8;
	sub_82390088(ctx, base);
	// 827FC2B8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC2BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC2C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC2C4: 4BC84505  bl 0x824807c8
	ctx.lr = 0x827FC2C8;
	sub_824807C8(ctx, base);
	// 827FC2C8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC2CC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC2D4: 4BC844F5  bl 0x824807c8
	ctx.lr = 0x827FC2D8;
	sub_824807C8(ctx, base);
	// 827FC2D8: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC2DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC2E0: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC2E4: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC2E8: 4E800421  bctrl
	ctx.lr = 0x827FC2EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC2EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FC2F0: 4BC40B01  bl 0x8243cdf0
	ctx.lr = 0x827FC2F4;
	sub_8243CDF0(ctx, base);
	// 827FC2F4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FC2F8: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FC2FC: 4BFFFF20  b 0x827fc21c
	pc = 0x827FC21C; continue 'dispatch;
            }
            0x827FC300 => {
    //   block [0x827FC300..0x827FC328)
	// 827FC300: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC304: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC308: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC30C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC310: 4E800421  bctrl
	ctx.lr = 0x827FC314;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC314: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FC318: 4BB18811  bl 0x82314b28
	ctx.lr = 0x827FC31C;
	sub_82314B28(ctx, base);
	// 827FC31C: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FC320: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FC324: 4BFFFE60  b 0x827fc184
	pc = 0x827FC184; continue 'dispatch;
            }
            0x827FC328 => {
    //   block [0x827FC328..0x827FC348)
	// 827FC328: 81550080  lwz r10, 0x80(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(128 as u32) ) } as u64;
	// 827FC32C: 3B75007C  addi r27, r21, 0x7c
	ctx.r[27].s64 = ctx.r[21].s64 + 124;
	// 827FC330: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FC334: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FC338: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC33C: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FC340: 3B8AA6C0  addi r28, r10, -0x5940
	ctx.r[28].s64 = ctx.r[10].s64 + -22848;
	// 827FC344: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FC348; continue 'dispatch;
            }
            0x827FC348 => {
    //   block [0x827FC348..0x827FC35C)
	// 827FC348: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC34C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC350: 419A000C  beq cr6, 0x827fc35c
	if ctx.cr[6].eq {
	pc = 0x827FC35C; continue 'dispatch;
	}
	// 827FC354: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FC358: 419A0008  beq cr6, 0x827fc360
	if ctx.cr[6].eq {
	pc = 0x827FC360; continue 'dispatch;
	}
	pc = 0x827FC35C; continue 'dispatch;
            }
            0x827FC35C => {
    //   block [0x827FC35C..0x827FC360)
	// 827FC35C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC360; continue 'dispatch;
            }
            0x827FC360 => {
    //   block [0x827FC360..0x827FC374)
	// 827FC360: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC364: 419A0188  beq cr6, 0x827fc4ec
	if ctx.cr[6].eq {
	pc = 0x827FC4EC; continue 'dispatch;
	}
	// 827FC368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC36C: 409A0008  bne cr6, 0x827fc374
	if !ctx.cr[6].eq {
	pc = 0x827FC374; continue 'dispatch;
	}
	// 827FC370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC374; continue 'dispatch;
            }
            0x827FC374 => {
    //   block [0x827FC374..0x827FC384)
	// 827FC374: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC378: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC37C: 409A0008  bne cr6, 0x827fc384
	if !ctx.cr[6].eq {
	pc = 0x827FC384; continue 'dispatch;
	}
	// 827FC380: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC384; continue 'dispatch;
            }
            0x827FC384 => {
    //   block [0x827FC384..0x827FC39C)
	// 827FC384: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC388: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FC38C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC390: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC394: 409A0008  bne cr6, 0x827fc39c
	if !ctx.cr[6].eq {
	pc = 0x827FC39C; continue 'dispatch;
	}
	// 827FC398: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC39C; continue 'dispatch;
            }
            0x827FC39C => {
    //   block [0x827FC39C..0x827FC3E0)
	// 827FC39C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC3A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC3A4: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FC3A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC3AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC3B0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC3B4: 4E800421  bctrl
	ctx.lr = 0x827FC3B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC3B8: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FC3BC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FC3C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC3C4: 4BB93CC5  bl 0x82390088
	ctx.lr = 0x827FC3C8;
	sub_82390088(ctx, base);
	// 827FC3C8: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FC3CC: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FC3D0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FC3D4: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC3D8: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FC3DC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FC3E0 => {
    //   block [0x827FC3E0..0x827FC3F4)
	// 827FC3E0: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC3E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC3E8: 419A000C  beq cr6, 0x827fc3f4
	if ctx.cr[6].eq {
	pc = 0x827FC3F4; continue 'dispatch;
	}
	// 827FC3EC: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FC3F0: 419A0008  beq cr6, 0x827fc3f8
	if ctx.cr[6].eq {
	pc = 0x827FC3F8; continue 'dispatch;
	}
	pc = 0x827FC3F4; continue 'dispatch;
            }
            0x827FC3F4 => {
    //   block [0x827FC3F4..0x827FC3F8)
	// 827FC3F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC3F8; continue 'dispatch;
            }
            0x827FC3F8 => {
    //   block [0x827FC3F8..0x827FC40C)
	// 827FC3F8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC3FC: 419A00C8  beq cr6, 0x827fc4c4
	if ctx.cr[6].eq {
	pc = 0x827FC4C4; continue 'dispatch;
	}
	// 827FC400: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC404: 409A0008  bne cr6, 0x827fc40c
	if !ctx.cr[6].eq {
	pc = 0x827FC40C; continue 'dispatch;
	}
	// 827FC408: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC40C; continue 'dispatch;
            }
            0x827FC40C => {
    //   block [0x827FC40C..0x827FC41C)
	// 827FC40C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC410: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC414: 409A0008  bne cr6, 0x827fc41c
	if !ctx.cr[6].eq {
	pc = 0x827FC41C; continue 'dispatch;
	}
	// 827FC418: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC41C; continue 'dispatch;
            }
            0x827FC41C => {
    //   block [0x827FC41C..0x827FC434)
	// 827FC41C: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC420: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FC424: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC428: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC42C: 409A0008  bne cr6, 0x827fc434
	if !ctx.cr[6].eq {
	pc = 0x827FC434; continue 'dispatch;
	}
	// 827FC430: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC434; continue 'dispatch;
            }
            0x827FC434 => {
    //   block [0x827FC434..0x827FC44C)
	// 827FC434: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FC438: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FC43C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC440: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC444: 409A0008  bne cr6, 0x827fc44c
	if !ctx.cr[6].eq {
	pc = 0x827FC44C; continue 'dispatch;
	}
	// 827FC448: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC44C; continue 'dispatch;
            }
            0x827FC44C => {
    //   block [0x827FC44C..0x827FC4C4)
	// 827FC44C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC450: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC454: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FC458: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC45C: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC460: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FC464: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC468: 4E800421  bctrl
	ctx.lr = 0x827FC46C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC46C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FC470: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FC474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC478: 4BB93C11  bl 0x82390088
	ctx.lr = 0x827FC47C;
	sub_82390088(ctx, base);
	// 827FC47C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC480: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC484: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC488: 4BC84341  bl 0x824807c8
	ctx.lr = 0x827FC48C;
	sub_824807C8(ctx, base);
	// 827FC48C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC490: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC494: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC498: 4BC84331  bl 0x824807c8
	ctx.lr = 0x827FC49C;
	sub_824807C8(ctx, base);
	// 827FC49C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC4A4: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC4A8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC4AC: 4E800421  bctrl
	ctx.lr = 0x827FC4B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC4B0: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FC4B4: 4BC4093D  bl 0x8243cdf0
	ctx.lr = 0x827FC4B8;
	sub_8243CDF0(ctx, base);
	// 827FC4B8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FC4BC: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FC4C0: 4BFFFF20  b 0x827fc3e0
	pc = 0x827FC3E0; continue 'dispatch;
            }
            0x827FC4C4 => {
    //   block [0x827FC4C4..0x827FC4EC)
	// 827FC4C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC4C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC4CC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC4D0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC4D4: 4E800421  bctrl
	ctx.lr = 0x827FC4D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC4D8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FC4DC: 4BB1864D  bl 0x82314b28
	ctx.lr = 0x827FC4E0;
	sub_82314B28(ctx, base);
	// 827FC4E0: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FC4E4: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FC4E8: 4BFFFE60  b 0x827fc348
	pc = 0x827FC348; continue 'dispatch;
            }
            0x827FC4EC => {
    //   block [0x827FC4EC..0x827FC50C)
	// 827FC4EC: 8155008C  lwz r10, 0x8c(r21)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FC4F0: 3B750088  addi r27, r21, 0x88
	ctx.r[27].s64 = ctx.r[21].s64 + 136;
	// 827FC4F4: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 827FC4F8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FC4FC: 83CA0000  lwz r30, 0(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC500: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FC504: 3B8AA6D8  addi r28, r10, -0x5928
	ctx.r[28].s64 = ctx.r[10].s64 + -22824;
	// 827FC508: 93C10074  stw r30, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	pc = 0x827FC50C; continue 'dispatch;
            }
            0x827FC50C => {
    //   block [0x827FC50C..0x827FC520)
	// 827FC50C: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC510: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC514: 419A000C  beq cr6, 0x827fc520
	if ctx.cr[6].eq {
	pc = 0x827FC520; continue 'dispatch;
	}
	// 827FC518: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FC51C: 419A0008  beq cr6, 0x827fc524
	if ctx.cr[6].eq {
	pc = 0x827FC524; continue 'dispatch;
	}
	pc = 0x827FC520; continue 'dispatch;
            }
            0x827FC520 => {
    //   block [0x827FC520..0x827FC524)
	// 827FC520: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC524; continue 'dispatch;
            }
            0x827FC524 => {
    //   block [0x827FC524..0x827FC538)
	// 827FC524: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC528: 419A11C8  beq cr6, 0x827fd6f0
	if ctx.cr[6].eq {
	pc = 0x827FD6F0; continue 'dispatch;
	}
	// 827FC52C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC530: 409A0008  bne cr6, 0x827fc538
	if !ctx.cr[6].eq {
	pc = 0x827FC538; continue 'dispatch;
	}
	// 827FC534: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC538; continue 'dispatch;
            }
            0x827FC538 => {
    //   block [0x827FC538..0x827FC548)
	// 827FC538: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC53C: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FC540: 409A0008  bne cr6, 0x827fc548
	if !ctx.cr[6].eq {
	pc = 0x827FC548; continue 'dispatch;
	}
	// 827FC544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC548; continue 'dispatch;
            }
            0x827FC548 => {
    //   block [0x827FC548..0x827FC560)
	// 827FC548: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC54C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FC550: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC554: 7F1E4840  cmplw cr6, r30, r9
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC558: 409A0008  bne cr6, 0x827fc560
	if !ctx.cr[6].eq {
	pc = 0x827FC560; continue 'dispatch;
	}
	// 827FC55C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC560; continue 'dispatch;
            }
            0x827FC560 => {
    //   block [0x827FC560..0x827FC5A4)
	// 827FC560: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC564: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC568: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 827FC56C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC570: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC574: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC578: 4E800421  bctrl
	ctx.lr = 0x827FC57C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC57C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FC580: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FC584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC588: 4BB93B01  bl 0x82390088
	ctx.lr = 0x827FC58C;
	sub_82390088(ctx, base);
	// 827FC58C: 813E0018  lwz r9, 0x18(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FC590: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FC594: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FC598: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC59C: 91410068  stw r10, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u32 ) };
	// 827FC5A0: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
            }
            0x827FC5A4 => {
    //   block [0x827FC5A4..0x827FC5B8)
	// 827FC5A4: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC5A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC5AC: 419A000C  beq cr6, 0x827fc5b8
	if ctx.cr[6].eq {
	pc = 0x827FC5B8; continue 'dispatch;
	}
	// 827FC5B0: 7F0AE840  cmplw cr6, r10, r29
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[29].u32, &mut ctx.xer);
	// 827FC5B4: 419A0008  beq cr6, 0x827fc5bc
	if ctx.cr[6].eq {
	pc = 0x827FC5BC; continue 'dispatch;
	}
	pc = 0x827FC5B8; continue 'dispatch;
            }
            0x827FC5B8 => {
    //   block [0x827FC5B8..0x827FC5BC)
	// 827FC5B8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC5BC; continue 'dispatch;
            }
            0x827FC5BC => {
    //   block [0x827FC5BC..0x827FC5D0)
	// 827FC5BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC5C0: 419A00C8  beq cr6, 0x827fc688
	if ctx.cr[6].eq {
	pc = 0x827FC688; continue 'dispatch;
	}
	// 827FC5C4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FC5C8: 409A0008  bne cr6, 0x827fc5d0
	if !ctx.cr[6].eq {
	pc = 0x827FC5D0; continue 'dispatch;
	}
	// 827FC5CC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC5D0; continue 'dispatch;
            }
            0x827FC5D0 => {
    //   block [0x827FC5D0..0x827FC5E0)
	// 827FC5D0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC5D4: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FC5D8: 409A0008  bne cr6, 0x827fc5e0
	if !ctx.cr[6].eq {
	pc = 0x827FC5E0; continue 'dispatch;
	}
	// 827FC5DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC5E0; continue 'dispatch;
            }
            0x827FC5E0 => {
    //   block [0x827FC5E0..0x827FC5F8)
	// 827FC5E0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC5E4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FC5E8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC5EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC5F0: 409A0008  bne cr6, 0x827fc5f8
	if !ctx.cr[6].eq {
	pc = 0x827FC5F8; continue 'dispatch;
	}
	// 827FC5F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC5F8; continue 'dispatch;
            }
            0x827FC5F8 => {
    //   block [0x827FC5F8..0x827FC610)
	// 827FC5F8: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 827FC5FC: 91210060  stw r9, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 827FC600: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC604: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FC608: 409A0008  bne cr6, 0x827fc610
	if !ctx.cr[6].eq {
	pc = 0x827FC610; continue 'dispatch;
	}
	// 827FC60C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FC610; continue 'dispatch;
            }
            0x827FC610 => {
    //   block [0x827FC610..0x827FC688)
	// 827FC610: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC614: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC618: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FC61C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC620: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FC624: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FC628: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC62C: 4E800421  bctrl
	ctx.lr = 0x827FC630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC630: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FC634: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FC638: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC63C: 4BB93A4D  bl 0x82390088
	ctx.lr = 0x827FC640;
	sub_82390088(ctx, base);
	// 827FC640: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC644: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC64C: 4BC8417D  bl 0x824807c8
	ctx.lr = 0x827FC650;
	sub_824807C8(ctx, base);
	// 827FC650: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC654: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC658: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC65C: 4BC8416D  bl 0x824807c8
	ctx.lr = 0x827FC660;
	sub_824807C8(ctx, base);
	// 827FC660: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC668: 80C7000C  lwz r6, 0xc(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC66C: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC670: 4E800421  bctrl
	ctx.lr = 0x827FC674;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC674: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FC678: 4BC40779  bl 0x8243cdf0
	ctx.lr = 0x827FC67C;
	sub_8243CDF0(ctx, base);
	// 827FC67C: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FC680: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FC684: 4BFFFF20  b 0x827fc5a4
	pc = 0x827FC5A4; continue 'dispatch;
            }
            0x827FC688 => {
    //   block [0x827FC688..0x827FC6B0)
	// 827FC688: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC68C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC690: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC694: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC698: 4E800421  bctrl
	ctx.lr = 0x827FC69C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC69C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 827FC6A0: 4BB18489  bl 0x82314b28
	ctx.lr = 0x827FC6A4;
	sub_82314B28(ctx, base);
	// 827FC6A4: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FC6A8: 83C10074  lwz r30, 0x74(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FC6AC: 4BFFFE60  b 0x827fc50c
	pc = 0x827FC50C; continue 'dispatch;
            }
            0x827FC6B0 => {
    //   block [0x827FC6B0..0x827FC6F4)
	// 827FC6B0: 3B95000C  addi r28, r21, 0xc
	ctx.r[28].s64 = ctx.r[21].s64 + 12;
	// 827FC6B4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FC6B8: 4BAFBF89  bl 0x822f8640
	ctx.lr = 0x827FC6BC;
	sub_822F8640(ctx, base);
	// 827FC6BC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FC6C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC6C4: 3BABA5AC  addi r29, r11, -0x5a54
	ctx.r[29].s64 = ctx.r[11].s64 + -23124;
	// 827FC6C8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FC6CC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC6D0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC6D4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC6D8: 4E800421  bctrl
	ctx.lr = 0x827FC6DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC6DC: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC6E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 827FC6E4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827FC6E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FC6EC: 3AEB4AC8  addi r23, r11, 0x4ac8
	ctx.r[23].s64 = ctx.r[11].s64 + 19144;
	// 827FC6F0: 419A007C  beq cr6, 0x827fc76c
	if ctx.cr[6].eq {
	pc = 0x827FC76C; continue 'dispatch;
	}
            }
            0x827FC6F4 => {
    //   block [0x827FC6F4..0x827FC76C)
	// 827FC6F4: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FC6F8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC6FC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FC700: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC708: 4BB93981  bl 0x82390088
	ctx.lr = 0x827FC70C;
	sub_82390088(ctx, base);
	// 827FC70C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FC710: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC718: 4BC840B1  bl 0x824807c8
	ctx.lr = 0x827FC71C;
	sub_824807C8(ctx, base);
	// 827FC71C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FC720: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FC724: 4BB6E28D  bl 0x8236a9b0
	ctx.lr = 0x827FC728;
	sub_8236A9B0(ctx, base);
	// 827FC728: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FC72C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827FC730: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC734: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 827FC738: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC73C: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC740: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC744: 4E800421  bctrl
	ctx.lr = 0x827FC748;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC748: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC74C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FC750: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC754: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC758: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC75C: 4E800421  bctrl
	ctx.lr = 0x827FC760;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC760: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC764: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827FC768: 409AFF8C  bne cr6, 0x827fc6f4
	if !ctx.cr[6].eq {
	pc = 0x827FC6F4; continue 'dispatch;
	}
            }
            0x827FC76C => {
    //   block [0x827FC76C..0x827FC7B8)
	// 827FC76C: 3B750018  addi r27, r21, 0x18
	ctx.r[27].s64 = ctx.r[21].s64 + 24;
	// 827FC770: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FC774: 480030ED  bl 0x827ff860
	ctx.lr = 0x827FC778;
	sub_827FF860(ctx, base);
	// 827FC778: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FC77C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC780: 3B4BA5B8  addi r26, r11, -0x5a48
	ctx.r[26].s64 = ctx.r[11].s64 + -23112;
	// 827FC784: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC788: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC78C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC790: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC794: 4E800421  bctrl
	ctx.lr = 0x827FC798;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC798: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC79C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 827FC7A0: 3F008349  lis r24, -0x7cb7
	ctx.r[24].s64 = -2092367872;
	// 827FC7A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FC7A8: 3B2B9A68  addi r25, r11, -0x6598
	ctx.r[25].s64 = ctx.r[11].s64 + -26008;
	// 827FC7AC: 419A016C  beq cr6, 0x827fc918
	if ctx.cr[6].eq {
	pc = 0x827FC918; continue 'dispatch;
	}
	// 827FC7B0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FC7B4: 3B8BA5CC  addi r28, r11, -0x5a34
	ctx.r[28].s64 = ctx.r[11].s64 + -23092;
            }
            0x827FC7B8 => {
    //   block [0x827FC7B8..0x827FC7FC)
	// 827FC7B8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FC7BC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC7C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC7C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC7C8: 4BB938C1  bl 0x82390088
	ctx.lr = 0x827FC7CC;
	sub_82390088(ctx, base);
	// 827FC7CC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827FC7D0: 4BA22AF1  bl 0x8221f2c0
	ctx.lr = 0x827FC7D4;
	sub_8221F2C0(ctx, base);
	// 827FC7D4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FC7D8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827FC7DC: 409A0028  bne cr6, 0x827fc804
	if !ctx.cr[6].eq {
	pc = 0x827FC804; continue 'dispatch;
	}
	// 827FC7E0: 81786F6C  lwz r11, 0x6f6c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28524 as u32) ) } as u64;
	// 827FC7E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC7E8: 419A0014  beq cr6, 0x827fc7fc
	if ctx.cr[6].eq {
	pc = 0x827FC7FC; continue 'dispatch;
	}
	// 827FC7EC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FC7F0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827FC7F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827FC7F8: 4E800421  bctrl
	ctx.lr = 0x827FC7FC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FC7FC => {
    //   block [0x827FC7FC..0x827FC804)
	// 827FC7FC: 484C5BAD  bl 0x82cc23a8
	ctx.lr = 0x827FC800;
	sub_82CC23A8(ctx, base);
	// 827FC800: 48000008  b 0x827fc808
	pc = 0x827FC808; continue 'dispatch;
            }
            0x827FC804 => {
    //   block [0x827FC804..0x827FC808)
	// 827FC804: 93BD0000  stw r29, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FC808; continue 'dispatch;
            }
            0x827FC808 => {
    //   block [0x827FC808..0x827FC814)
	// 827FC808: 357D0004  addic. r11, r29, 4
	ctx.xer.ca = (ctx.r[29].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FC80C: 41820008  beq 0x827fc814
	if ctx.cr[0].eq {
	pc = 0x827FC814; continue 'dispatch;
	}
	// 827FC810: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FC814; continue 'dispatch;
            }
            0x827FC814 => {
    //   block [0x827FC814..0x827FC848)
	// 827FC814: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC818: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC81C: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 827FC820: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC824: 93C10090  stw r30, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u32 ) };
	// 827FC828: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC82C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC830: 4E800421  bctrl
	ctx.lr = 0x827FC834;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC834: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC838: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FC83C: 419A0078  beq cr6, 0x827fc8b4
	if ctx.cr[6].eq {
	pc = 0x827FC8B4; continue 'dispatch;
	}
	// 827FC840: 39610088  addi r11, r1, 0x88
	ctx.r[11].s64 = ctx.r[1].s64 + 136;
	// 827FC844: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
            }
            0x827FC848 => {
    //   block [0x827FC848..0x827FC8B4)
	// 827FC848: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FC84C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC850: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC858: 4BB93831  bl 0x82390088
	ctx.lr = 0x827FC85C;
	sub_82390088(ctx, base);
	// 827FC85C: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FC860: 8141008C  lwz r10, 0x8c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FC864: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FC868: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827FC86C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FC870: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FC874: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FC878: 4829AAF1  bl 0x82a97368
	ctx.lr = 0x827FC87C;
	sub_82A97368(ctx, base);
	// 827FC87C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC880: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC888: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC88C: 4E800421  bctrl
	ctx.lr = 0x827FC890;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC890: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC894: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC89C: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC8A0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FC8A4: 4E800421  bctrl
	ctx.lr = 0x827FC8A8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC8A8: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC8AC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827FC8B0: 409AFF98  bne cr6, 0x827fc848
	if !ctx.cr[6].eq {
	pc = 0x827FC848; continue 'dispatch;
	}
            }
            0x827FC8B4 => {
    //   block [0x827FC8B4..0x827FC918)
	// 827FC8B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC8B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC8BC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FC8C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC8C4: 4E800421  bctrl
	ctx.lr = 0x827FC8C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC8C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FC8CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FC8D0: 3BA10088  addi r29, r1, 0x88
	ctx.r[29].s64 = ctx.r[1].s64 + 136;
	// 827FC8D4: 48002DF5  bl 0x827ff6c8
	ctx.lr = 0x827FC8D8;
	sub_827FF6C8(ctx, base);
	// 827FC8D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FC8DC: 4BC5459D  bl 0x82450e78
	ctx.lr = 0x827FC8E0;
	sub_82450E78(ctx, base);
	// 827FC8E0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 827FC8E4: 482184AD  bl 0x82a14d90
	ctx.lr = 0x827FC8E8;
	sub_82A14D90(ctx, base);
	// 827FC8E8: 8061008C  lwz r3, 0x8c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FC8EC: 4BA1F44D  bl 0x8221bd38
	ctx.lr = 0x827FC8F0;
	sub_8221BD38(ctx, base);
	// 827FC8F0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC8F4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC8F8: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 827FC8FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC900: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC904: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FC908: 4E800421  bctrl
	ctx.lr = 0x827FC90C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC90C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC910: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FC914: 409AFEA4  bne cr6, 0x827fc7b8
	if !ctx.cr[6].eq {
	pc = 0x827FC7B8; continue 'dispatch;
	}
            }
            0x827FC918 => {
    //   block [0x827FC918..0x827FC958)
	// 827FC918: 3B750030  addi r27, r21, 0x30
	ctx.r[27].s64 = ctx.r[21].s64 + 48;
	// 827FC91C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FC920: 48002F41  bl 0x827ff860
	ctx.lr = 0x827FC924;
	sub_827FF860(ctx, base);
	// 827FC924: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FC928: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC92C: 3B4BA5DC  addi r26, r11, -0x5a24
	ctx.r[26].s64 = ctx.r[11].s64 + -23076;
	// 827FC930: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FC934: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC938: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC93C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC940: 4E800421  bctrl
	ctx.lr = 0x827FC944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC944: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC948: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FC94C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FC950: 3B8BA5F0  addi r28, r11, -0x5a10
	ctx.r[28].s64 = ctx.r[11].s64 + -23056;
	// 827FC954: 419A0164  beq cr6, 0x827fcab8
	if ctx.cr[6].eq {
	pc = 0x827FCAB8; continue 'dispatch;
	}
            }
            0x827FC958 => {
    //   block [0x827FC958..0x827FC99C)
	// 827FC958: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FC95C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FC960: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FC964: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC968: 4BB93721  bl 0x82390088
	ctx.lr = 0x827FC96C;
	sub_82390088(ctx, base);
	// 827FC96C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827FC970: 4BA22951  bl 0x8221f2c0
	ctx.lr = 0x827FC974;
	sub_8221F2C0(ctx, base);
	// 827FC974: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FC978: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827FC97C: 409A0028  bne cr6, 0x827fc9a4
	if !ctx.cr[6].eq {
	pc = 0x827FC9A4; continue 'dispatch;
	}
	// 827FC980: 81786F6C  lwz r11, 0x6f6c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28524 as u32) ) } as u64;
	// 827FC984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FC988: 419A0014  beq cr6, 0x827fc99c
	if ctx.cr[6].eq {
	pc = 0x827FC99C; continue 'dispatch;
	}
	// 827FC98C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FC990: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827FC994: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827FC998: 4E800421  bctrl
	ctx.lr = 0x827FC99C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FC99C => {
    //   block [0x827FC99C..0x827FC9A4)
	// 827FC99C: 484C5A0D  bl 0x82cc23a8
	ctx.lr = 0x827FC9A0;
	sub_82CC23A8(ctx, base);
	// 827FC9A0: 48000008  b 0x827fc9a8
	pc = 0x827FC9A8; continue 'dispatch;
            }
            0x827FC9A4 => {
    //   block [0x827FC9A4..0x827FC9A8)
	// 827FC9A4: 93BD0000  stw r29, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FC9A8; continue 'dispatch;
            }
            0x827FC9A8 => {
    //   block [0x827FC9A8..0x827FC9B4)
	// 827FC9A8: 357D0004  addic. r11, r29, 4
	ctx.xer.ca = (ctx.r[29].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FC9AC: 41820008  beq 0x827fc9b4
	if ctx.cr[0].eq {
	pc = 0x827FC9B4; continue 'dispatch;
	}
	// 827FC9B0: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FC9B4; continue 'dispatch;
            }
            0x827FC9B4 => {
    //   block [0x827FC9B4..0x827FC9E8)
	// 827FC9B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FC9B8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FC9BC: 93A1007C  stw r29, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u32 ) };
	// 827FC9C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC9C4: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 827FC9C8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FC9CC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FC9D0: 4E800421  bctrl
	ctx.lr = 0x827FC9D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FC9D4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FC9D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FC9DC: 419A0078  beq cr6, 0x827fca54
	if ctx.cr[6].eq {
	pc = 0x827FCA54; continue 'dispatch;
	}
	// 827FC9E0: 39610078  addi r11, r1, 0x78
	ctx.r[11].s64 = ctx.r[1].s64 + 120;
	// 827FC9E4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
            }
            0x827FC9E8 => {
    //   block [0x827FC9E8..0x827FCA54)
	// 827FC9E8: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FC9EC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FC9F0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FC9F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FC9F8: 4BB93691  bl 0x82390088
	ctx.lr = 0x827FC9FC;
	sub_82390088(ctx, base);
	// 827FC9FC: 81610060  lwz r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FCA00: 8141007C  lwz r10, 0x7c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FCA04: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FCA08: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FCA0C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FCA10: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FCA14: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FCA18: 4829A951  bl 0x82a97368
	ctx.lr = 0x827FCA1C;
	sub_82A97368(ctx, base);
	// 827FCA1C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCA20: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCA24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCA28: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCA2C: 4E800421  bctrl
	ctx.lr = 0x827FCA30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCA30: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCA34: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FCA38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCA3C: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCA40: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FCA44: 4E800421  bctrl
	ctx.lr = 0x827FCA48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCA48: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCA4C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827FCA50: 409AFF98  bne cr6, 0x827fc9e8
	if !ctx.cr[6].eq {
	pc = 0x827FC9E8; continue 'dispatch;
	}
            }
            0x827FCA54 => {
    //   block [0x827FCA54..0x827FCAB8)
	// 827FCA54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCA5C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCA64: 4E800421  bctrl
	ctx.lr = 0x827FCA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCA68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCA6C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FCA70: 3BA10078  addi r29, r1, 0x78
	ctx.r[29].s64 = ctx.r[1].s64 + 120;
	// 827FCA74: 48002C55  bl 0x827ff6c8
	ctx.lr = 0x827FCA78;
	sub_827FF6C8(ctx, base);
	// 827FCA78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCA7C: 4BC543FD  bl 0x82450e78
	ctx.lr = 0x827FCA80;
	sub_82450E78(ctx, base);
	// 827FCA80: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FCA84: 4821830D  bl 0x82a14d90
	ctx.lr = 0x827FCA88;
	sub_82A14D90(ctx, base);
	// 827FCA88: 8061007C  lwz r3, 0x7c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FCA8C: 4BA1F2AD  bl 0x8221bd38
	ctx.lr = 0x827FCA90;
	sub_8221BD38(ctx, base);
	// 827FCA90: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCA94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FCA98: 93C1007C  stw r30, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[30].u32 ) };
	// 827FCA9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCAA0: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCAA4: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCAA8: 4E800421  bctrl
	ctx.lr = 0x827FCAAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCAAC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCAB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FCAB4: 409AFEA4  bne cr6, 0x827fc958
	if !ctx.cr[6].eq {
	pc = 0x827FC958; continue 'dispatch;
	}
            }
            0x827FCAB8 => {
    //   block [0x827FCAB8..0x827FCAF0)
	// 827FCAB8: 3B750024  addi r27, r21, 0x24
	ctx.r[27].s64 = ctx.r[21].s64 + 36;
	// 827FCABC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FCAC0: 48002DA1  bl 0x827ff860
	ctx.lr = 0x827FCAC4;
	sub_827FF860(ctx, base);
	// 827FCAC4: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FCAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCACC: 3B4BA5F8  addi r26, r11, -0x5a08
	ctx.r[26].s64 = ctx.r[11].s64 + -23048;
	// 827FCAD0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FCAD4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCAD8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCAE0: 4E800421  bctrl
	ctx.lr = 0x827FCAE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCAE4: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCAE8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FCAEC: 419A0164  beq cr6, 0x827fcc50
	if ctx.cr[6].eq {
	pc = 0x827FCC50; continue 'dispatch;
	}
            }
            0x827FCAF0 => {
    //   block [0x827FCAF0..0x827FCB34)
	// 827FCAF0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FCAF4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FCAF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FCAFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCB00: 4BB93589  bl 0x82390088
	ctx.lr = 0x827FCB04;
	sub_82390088(ctx, base);
	// 827FCB04: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 827FCB08: 4BA227B9  bl 0x8221f2c0
	ctx.lr = 0x827FCB0C;
	sub_8221F2C0(ctx, base);
	// 827FCB0C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FCB10: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 827FCB14: 409A0028  bne cr6, 0x827fcb3c
	if !ctx.cr[6].eq {
	pc = 0x827FCB3C; continue 'dispatch;
	}
	// 827FCB18: 81786F6C  lwz r11, 0x6f6c(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(28524 as u32) ) } as u64;
	// 827FCB1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FCB20: 419A0014  beq cr6, 0x827fcb34
	if ctx.cr[6].eq {
	pc = 0x827FCB34; continue 'dispatch;
	}
	// 827FCB24: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FCB28: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 827FCB2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 827FCB30: 4E800421  bctrl
	ctx.lr = 0x827FCB34;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x827FCB34 => {
    //   block [0x827FCB34..0x827FCB3C)
	// 827FCB34: 484C5875  bl 0x82cc23a8
	ctx.lr = 0x827FCB38;
	sub_82CC23A8(ctx, base);
	// 827FCB38: 48000008  b 0x827fcb40
	pc = 0x827FCB40; continue 'dispatch;
            }
            0x827FCB3C => {
    //   block [0x827FCB3C..0x827FCB40)
	// 827FCB3C: 93BD0000  stw r29, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FCB40; continue 'dispatch;
            }
            0x827FCB40 => {
    //   block [0x827FCB40..0x827FCB4C)
	// 827FCB40: 357D0004  addic. r11, r29, 4
	ctx.xer.ca = (ctx.r[29].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FCB44: 41820008  beq 0x827fcb4c
	if ctx.cr[0].eq {
	pc = 0x827FCB4C; continue 'dispatch;
	}
	// 827FCB48: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x827FCB4C; continue 'dispatch;
            }
            0x827FCB4C => {
    //   block [0x827FCB4C..0x827FCB80)
	// 827FCB4C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCB50: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FCB54: 93A1009C  stw r29, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u32 ) };
	// 827FCB58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCB5C: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 827FCB60: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCB64: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCB68: 4E800421  bctrl
	ctx.lr = 0x827FCB6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCB6C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCB70: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FCB74: 419A0078  beq cr6, 0x827fcbec
	if ctx.cr[6].eq {
	pc = 0x827FCBEC; continue 'dispatch;
	}
	// 827FCB78: 39610098  addi r11, r1, 0x98
	ctx.r[11].s64 = ctx.r[1].s64 + 152;
	// 827FCB7C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
            }
            0x827FCB80 => {
    //   block [0x827FCB80..0x827FCBEC)
	// 827FCB80: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FCB84: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 827FCB88: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FCB8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCB90: 4BB934F9  bl 0x82390088
	ctx.lr = 0x827FCB94;
	sub_82390088(ctx, base);
	// 827FCB94: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FCB98: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 827FCB9C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FCBA0: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 827FCBA4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 827FCBA8: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827FCBAC: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FCBB0: 4829A7B9  bl 0x82a97368
	ctx.lr = 0x827FCBB4;
	sub_82A97368(ctx, base);
	// 827FCBB4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCBB8: 8109000C  lwz r8, 0xc(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCBBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCBC0: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCBC4: 4E800421  bctrl
	ctx.lr = 0x827FCBC8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCBC8: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCBCC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FCBD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCBD4: 80C70008  lwz r6, 8(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCBD8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 827FCBDC: 4E800421  bctrl
	ctx.lr = 0x827FCBE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCBE0: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCBE4: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 827FCBE8: 409AFF98  bne cr6, 0x827fcb80
	if !ctx.cr[6].eq {
	pc = 0x827FCB80; continue 'dispatch;
	}
            }
            0x827FCBEC => {
    //   block [0x827FCBEC..0x827FCC50)
	// 827FCBEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCBF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCBF4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCBF8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCBFC: 4E800421  bctrl
	ctx.lr = 0x827FCC00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCC00: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCC04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FCC08: 3BA10098  addi r29, r1, 0x98
	ctx.r[29].s64 = ctx.r[1].s64 + 152;
	// 827FCC0C: 48002ABD  bl 0x827ff6c8
	ctx.lr = 0x827FCC10;
	sub_827FF6C8(ctx, base);
	// 827FCC10: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCC14: 4BC54265  bl 0x82450e78
	ctx.lr = 0x827FCC18;
	sub_82450E78(ctx, base);
	// 827FCC18: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 827FCC1C: 48218175  bl 0x82a14d90
	ctx.lr = 0x827FCC20;
	sub_82A14D90(ctx, base);
	// 827FCC20: 8061009C  lwz r3, 0x9c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 827FCC24: 4BA1F115  bl 0x8221bd38
	ctx.lr = 0x827FCC28;
	sub_8221BD38(ctx, base);
	// 827FCC28: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCC2C: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FCC30: 93C1009C  stw r30, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 827FCC34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCC38: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCC3C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCC40: 4E800421  bctrl
	ctx.lr = 0x827FCC44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCC44: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCC48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FCC4C: 409AFEA4  bne cr6, 0x827fcaf0
	if !ctx.cr[6].eq {
	pc = 0x827FCAF0; continue 'dispatch;
	}
            }
            0x827FCC50 => {
    //   block [0x827FCC50..0x827FCCA8)
	// 827FCC50: 3B35003C  addi r25, r21, 0x3c
	ctx.r[25].s64 = ctx.r[21].s64 + 60;
	// 827FCC54: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCC58: 48002E99  bl 0x827ffaf0
	ctx.lr = 0x827FCC5C;
	sub_827FFAF0(ctx, base);
	// 827FCC5C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FCC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCC64: 3B0BA610  addi r24, r11, -0x59f0
	ctx.r[24].s64 = ctx.r[11].s64 + -23024;
	// 827FCC68: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FCC6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCC70: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCC74: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCC78: 4E800421  bctrl
	ctx.lr = 0x827FCC7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCC7C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCC80: 3D00820E  lis r8, -0x7df2
	ctx.r[8].s64 = -2113011712;
	// 827FCC84: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827FCC88: 3D40820E  lis r10, -0x7df2
	ctx.r[10].s64 = -2113011712;
	// 827FCC8C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FCC90: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FCC94: 3B88A64C  addi r28, r8, -0x59b4
	ctx.r[28].s64 = ctx.r[8].s64 + -22964;
	// 827FCC98: 3B69A644  addi r27, r9, -0x59bc
	ctx.r[27].s64 = ctx.r[9].s64 + -22972;
	// 827FCC9C: 3B4AA634  addi r26, r10, -0x59cc
	ctx.r[26].s64 = ctx.r[10].s64 + -22988;
	// 827FCCA0: 3BABA624  addi r29, r11, -0x59dc
	ctx.r[29].s64 = ctx.r[11].s64 + -23004;
	// 827FCCA4: 419A014C  beq cr6, 0x827fcdf0
	if ctx.cr[6].eq {
	pc = 0x827FCDF0; continue 'dispatch;
	}
            }
            0x827FCCA8 => {
    //   block [0x827FCCA8..0x827FCD10)
	// 827FCCA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FCCAC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FCCB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FCCB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCCB8: 4BB933D1  bl 0x82390088
	ctx.lr = 0x827FCCBC;
	sub_82390088(ctx, base);
	// 827FCCBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FCCC0: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 827FCCC4: 916100E0  stw r11, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[11].u32 ) };
	// 827FCCC8: 4821B259  bl 0x82a17f20
	ctx.lr = 0x827FCCCC;
	sub_82A17F20(ctx, base);
	// 827FCCCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCCD0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCCD4: 3AC100E0  addi r22, r1, 0xe0
	ctx.r[22].s64 = ctx.r[1].s64 + 224;
	// 827FCCD8: 48002C81  bl 0x827ff958
	ctx.lr = 0x827FCCDC;
	sub_827FF958(ctx, base);
	// 827FCCDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FCCE0: 4BFFE681  bl 0x827fb360
	ctx.lr = 0x827FCCE4;
	sub_827FB360(ctx, base);
	// 827FCCE4: 386100E4  addi r3, r1, 0xe4
	ctx.r[3].s64 = ctx.r[1].s64 + 228;
	// 827FCCE8: 4BEDCD71  bl 0x826d9a58
	ctx.lr = 0x827FCCEC;
	sub_826D9A58(ctx, base);
	// 827FCCEC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCCF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCCF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCCF8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCCFC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FCD00: 4E800421  bctrl
	ctx.lr = 0x827FCD04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCD04: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCD08: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FCD0C: 419A00AC  beq cr6, 0x827fcdb8
	if ctx.cr[6].eq {
	pc = 0x827FCDB8; continue 'dispatch;
	}
            }
            0x827FCD10 => {
    //   block [0x827FCD10..0x827FCDB8)
	// 827FCD10: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FCD14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FCD18: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FCD1C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FCD20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FCD24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCD28: 4BB93361  bl 0x82390088
	ctx.lr = 0x827FCD2C;
	sub_82390088(ctx, base);
	// 827FCD2C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FCD30: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FCD34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCD38: 4BC83A91  bl 0x824807c8
	ctx.lr = 0x827FCD3C;
	sub_824807C8(ctx, base);
	// 827FCD3C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FCD40: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FCD44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCD48: 4BC83A81  bl 0x824807c8
	ctx.lr = 0x827FCD4C;
	sub_824807C8(ctx, base);
	// 827FCD4C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FCD50: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FCD54: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCD58: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCD5C: 3AC10060  addi r22, r1, 0x60
	ctx.r[22].s64 = ctx.r[1].s64 + 96;
	// 827FCD60: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FCD64: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FCD68: 48002BF1  bl 0x827ff958
	ctx.lr = 0x827FCD6C;
	sub_827FF958(ctx, base);
	// 827FCD6C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FCD70: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FCD74: 480027DD  bl 0x827ff550
	ctx.lr = 0x827FCD78;
	sub_827FF550(ctx, base);
	// 827FCD78: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FCD7C: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FCD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCD84: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCD88: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCD8C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FCD90: 4E800421  bctrl
	ctx.lr = 0x827FCD94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCD94: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCD98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCD9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCDA0: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCDA4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FCDA8: 4E800421  bctrl
	ctx.lr = 0x827FCDAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCDAC: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCDB0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FCDB4: 409AFF5C  bne cr6, 0x827fcd10
	if !ctx.cr[6].eq {
	pc = 0x827FCD10; continue 'dispatch;
	}
            }
            0x827FCDB8 => {
    //   block [0x827FCDB8..0x827FCDF0)
	// 827FCDB8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCDBC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCDC0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCDC4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCDC8: 4E800421  bctrl
	ctx.lr = 0x827FCDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCDCC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCDD0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FCDD4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCDD8: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCDDC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCDE0: 4E800421  bctrl
	ctx.lr = 0x827FCDE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCDE4: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCDE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FCDEC: 409AFEBC  bne cr6, 0x827fcca8
	if !ctx.cr[6].eq {
	pc = 0x827FCCA8; continue 'dispatch;
	}
            }
            0x827FCDF0 => {
    //   block [0x827FCDF0..0x827FCE28)
	// 827FCDF0: 3B350048  addi r25, r21, 0x48
	ctx.r[25].s64 = ctx.r[21].s64 + 72;
	// 827FCDF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCDF8: 48002CF9  bl 0x827ffaf0
	ctx.lr = 0x827FCDFC;
	sub_827FFAF0(ctx, base);
	// 827FCDFC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FCE00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCE04: 3B0BA654  addi r24, r11, -0x59ac
	ctx.r[24].s64 = ctx.r[11].s64 + -22956;
	// 827FCE08: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FCE0C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCE10: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCE14: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCE18: 4E800421  bctrl
	ctx.lr = 0x827FCE1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCE1C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCE20: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FCE24: 419A014C  beq cr6, 0x827fcf70
	if ctx.cr[6].eq {
	pc = 0x827FCF70; continue 'dispatch;
	}
            }
            0x827FCE28 => {
    //   block [0x827FCE28..0x827FCE90)
	// 827FCE28: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FCE2C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FCE30: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FCE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCE38: 4BB93251  bl 0x82390088
	ctx.lr = 0x827FCE3C;
	sub_82390088(ctx, base);
	// 827FCE3C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FCE40: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 827FCE44: 91610100  stw r11, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[11].u32 ) };
	// 827FCE48: 4821B0D9  bl 0x82a17f20
	ctx.lr = 0x827FCE4C;
	sub_82A17F20(ctx, base);
	// 827FCE4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCE50: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCE54: 3AC10100  addi r22, r1, 0x100
	ctx.r[22].s64 = ctx.r[1].s64 + 256;
	// 827FCE58: 48002B01  bl 0x827ff958
	ctx.lr = 0x827FCE5C;
	sub_827FF958(ctx, base);
	// 827FCE5C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FCE60: 4BFFE501  bl 0x827fb360
	ctx.lr = 0x827FCE64;
	sub_827FB360(ctx, base);
	// 827FCE64: 38610104  addi r3, r1, 0x104
	ctx.r[3].s64 = ctx.r[1].s64 + 260;
	// 827FCE68: 4BEDCBF1  bl 0x826d9a58
	ctx.lr = 0x827FCE6C;
	sub_826D9A58(ctx, base);
	// 827FCE6C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCE70: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCE74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCE78: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCE7C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FCE80: 4E800421  bctrl
	ctx.lr = 0x827FCE84;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCE84: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCE88: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FCE8C: 419A00AC  beq cr6, 0x827fcf38
	if ctx.cr[6].eq {
	pc = 0x827FCF38; continue 'dispatch;
	}
            }
            0x827FCE90 => {
    //   block [0x827FCE90..0x827FCF38)
	// 827FCE90: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FCE94: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FCE98: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FCE9C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FCEA0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FCEA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCEA8: 4BB931E1  bl 0x82390088
	ctx.lr = 0x827FCEAC;
	sub_82390088(ctx, base);
	// 827FCEAC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FCEB0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FCEB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCEB8: 4BC83911  bl 0x824807c8
	ctx.lr = 0x827FCEBC;
	sub_824807C8(ctx, base);
	// 827FCEBC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FCEC0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FCEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCEC8: 4BC83901  bl 0x824807c8
	ctx.lr = 0x827FCECC;
	sub_824807C8(ctx, base);
	// 827FCECC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FCED0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FCED4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCED8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCEDC: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FCEE0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FCEE4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FCEE8: 48002A71  bl 0x827ff958
	ctx.lr = 0x827FCEEC;
	sub_827FF958(ctx, base);
	// 827FCEEC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FCEF0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FCEF4: 4800265D  bl 0x827ff550
	ctx.lr = 0x827FCEF8;
	sub_827FF550(ctx, base);
	// 827FCEF8: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FCEFC: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FCF00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCF04: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCF08: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCF0C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FCF10: 4E800421  bctrl
	ctx.lr = 0x827FCF14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCF14: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCF18: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCF1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCF20: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCF24: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FCF28: 4E800421  bctrl
	ctx.lr = 0x827FCF2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCF2C: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCF30: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FCF34: 409AFF5C  bne cr6, 0x827fce90
	if !ctx.cr[6].eq {
	pc = 0x827FCE90; continue 'dispatch;
	}
            }
            0x827FCF38 => {
    //   block [0x827FCF38..0x827FCF70)
	// 827FCF38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCF3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCF40: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FCF44: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCF48: 4E800421  bctrl
	ctx.lr = 0x827FCF4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCF4C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCF50: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FCF54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCF58: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCF5C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FCF60: 4E800421  bctrl
	ctx.lr = 0x827FCF64;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCF64: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCF68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FCF6C: 409AFEBC  bne cr6, 0x827fce28
	if !ctx.cr[6].eq {
	pc = 0x827FCE28; continue 'dispatch;
	}
            }
            0x827FCF70 => {
    //   block [0x827FCF70..0x827FCFA8)
	// 827FCF70: 3B350054  addi r25, r21, 0x54
	ctx.r[25].s64 = ctx.r[21].s64 + 84;
	// 827FCF74: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCF78: 48002B79  bl 0x827ffaf0
	ctx.lr = 0x827FCF7C;
	sub_827FFAF0(ctx, base);
	// 827FCF7C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FCF80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCF84: 3B0BA674  addi r24, r11, -0x598c
	ctx.r[24].s64 = ctx.r[11].s64 + -22924;
	// 827FCF88: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FCF8C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCF90: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCF94: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FCF98: 4E800421  bctrl
	ctx.lr = 0x827FCF9C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FCF9C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FCFA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FCFA4: 419A014C  beq cr6, 0x827fd0f0
	if ctx.cr[6].eq {
	pc = 0x827FD0F0; continue 'dispatch;
	}
            }
            0x827FCFA8 => {
    //   block [0x827FCFA8..0x827FD010)
	// 827FCFA8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FCFAC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FCFB0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FCFB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCFB8: 4BB930D1  bl 0x82390088
	ctx.lr = 0x827FCFBC;
	sub_82390088(ctx, base);
	// 827FCFBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FCFC0: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 827FCFC4: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 827FCFC8: 4821AF59  bl 0x82a17f20
	ctx.lr = 0x827FCFCC;
	sub_82A17F20(ctx, base);
	// 827FCFCC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FCFD0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FCFD4: 3AC100B0  addi r22, r1, 0xb0
	ctx.r[22].s64 = ctx.r[1].s64 + 176;
	// 827FCFD8: 48002981  bl 0x827ff958
	ctx.lr = 0x827FCFDC;
	sub_827FF958(ctx, base);
	// 827FCFDC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FCFE0: 4BFFE381  bl 0x827fb360
	ctx.lr = 0x827FCFE4;
	sub_827FB360(ctx, base);
	// 827FCFE4: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 827FCFE8: 4BEDCA71  bl 0x826d9a58
	ctx.lr = 0x827FCFEC;
	sub_826D9A58(ctx, base);
	// 827FCFEC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FCFF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FCFF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FCFF8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FCFFC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FD000: 4E800421  bctrl
	ctx.lr = 0x827FD004;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD004: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD008: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FD00C: 419A00AC  beq cr6, 0x827fd0b8
	if ctx.cr[6].eq {
	pc = 0x827FD0B8; continue 'dispatch;
	}
            }
            0x827FD010 => {
    //   block [0x827FD010..0x827FD0B8)
	// 827FD010: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FD014: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FD018: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FD01C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FD020: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FD024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD028: 4BB93061  bl 0x82390088
	ctx.lr = 0x827FD02C;
	sub_82390088(ctx, base);
	// 827FD02C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FD030: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD034: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD038: 4BC83791  bl 0x824807c8
	ctx.lr = 0x827FD03C;
	sub_824807C8(ctx, base);
	// 827FD03C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FD040: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FD044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD048: 4BC83781  bl 0x824807c8
	ctx.lr = 0x827FD04C;
	sub_824807C8(ctx, base);
	// 827FD04C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FD050: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FD054: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD058: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD05C: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FD060: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FD064: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FD068: 480028F1  bl 0x827ff958
	ctx.lr = 0x827FD06C;
	sub_827FF958(ctx, base);
	// 827FD06C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FD070: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD074: 480024DD  bl 0x827ff550
	ctx.lr = 0x827FD078;
	sub_827FF550(ctx, base);
	// 827FD078: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FD07C: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FD080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD084: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD088: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD08C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FD090: 4E800421  bctrl
	ctx.lr = 0x827FD094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD094: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD098: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD09C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD0A0: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD0A4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FD0A8: 4E800421  bctrl
	ctx.lr = 0x827FD0AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD0AC: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD0B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD0B4: 409AFF5C  bne cr6, 0x827fd010
	if !ctx.cr[6].eq {
	pc = 0x827FD010; continue 'dispatch;
	}
            }
            0x827FD0B8 => {
    //   block [0x827FD0B8..0x827FD0F0)
	// 827FD0B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD0C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD0C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD0C8: 4E800421  bctrl
	ctx.lr = 0x827FD0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD0CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD0D0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD0D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD0D8: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD0DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FD0E0: 4E800421  bctrl
	ctx.lr = 0x827FD0E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD0E4: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD0E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FD0EC: 409AFEBC  bne cr6, 0x827fcfa8
	if !ctx.cr[6].eq {
	pc = 0x827FCFA8; continue 'dispatch;
	}
            }
            0x827FD0F0 => {
    //   block [0x827FD0F0..0x827FD128)
	// 827FD0F0: 3B350060  addi r25, r21, 0x60
	ctx.r[25].s64 = ctx.r[21].s64 + 96;
	// 827FD0F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD0F8: 480029F9  bl 0x827ffaf0
	ctx.lr = 0x827FD0FC;
	sub_827FFAF0(ctx, base);
	// 827FD0FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD100: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD104: 3B0BA688  addi r24, r11, -0x5978
	ctx.r[24].s64 = ctx.r[11].s64 + -22904;
	// 827FD108: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD10C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD110: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD114: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD118: 4E800421  bctrl
	ctx.lr = 0x827FD11C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD11C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD120: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FD124: 419A014C  beq cr6, 0x827fd270
	if ctx.cr[6].eq {
	pc = 0x827FD270; continue 'dispatch;
	}
            }
            0x827FD128 => {
    //   block [0x827FD128..0x827FD190)
	// 827FD128: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FD12C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FD130: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FD134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD138: 4BB92F51  bl 0x82390088
	ctx.lr = 0x827FD13C;
	sub_82390088(ctx, base);
	// 827FD13C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FD140: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 827FD144: 916100C0  stw r11, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 827FD148: 4821ADD9  bl 0x82a17f20
	ctx.lr = 0x827FD14C;
	sub_82A17F20(ctx, base);
	// 827FD14C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD150: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD154: 3AC100C0  addi r22, r1, 0xc0
	ctx.r[22].s64 = ctx.r[1].s64 + 192;
	// 827FD158: 48002801  bl 0x827ff958
	ctx.lr = 0x827FD15C;
	sub_827FF958(ctx, base);
	// 827FD15C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD160: 4BFFE201  bl 0x827fb360
	ctx.lr = 0x827FD164;
	sub_827FB360(ctx, base);
	// 827FD164: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 827FD168: 4BEDC8F1  bl 0x826d9a58
	ctx.lr = 0x827FD16C;
	sub_826D9A58(ctx, base);
	// 827FD16C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD170: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD174: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD178: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD17C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FD180: 4E800421  bctrl
	ctx.lr = 0x827FD184;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD184: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD188: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FD18C: 419A00AC  beq cr6, 0x827fd238
	if ctx.cr[6].eq {
	pc = 0x827FD238; continue 'dispatch;
	}
            }
            0x827FD190 => {
    //   block [0x827FD190..0x827FD238)
	// 827FD190: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FD194: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FD198: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FD19C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FD1A0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FD1A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD1A8: 4BB92EE1  bl 0x82390088
	ctx.lr = 0x827FD1AC;
	sub_82390088(ctx, base);
	// 827FD1AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FD1B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD1B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD1B8: 4BC83611  bl 0x824807c8
	ctx.lr = 0x827FD1BC;
	sub_824807C8(ctx, base);
	// 827FD1BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FD1C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FD1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD1C8: 4BC83601  bl 0x824807c8
	ctx.lr = 0x827FD1CC;
	sub_824807C8(ctx, base);
	// 827FD1CC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FD1D0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FD1D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD1D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD1DC: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FD1E0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FD1E4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FD1E8: 48002771  bl 0x827ff958
	ctx.lr = 0x827FD1EC;
	sub_827FF958(ctx, base);
	// 827FD1EC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FD1F0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD1F4: 4800235D  bl 0x827ff550
	ctx.lr = 0x827FD1F8;
	sub_827FF550(ctx, base);
	// 827FD1F8: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FD1FC: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FD200: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD204: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD208: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD20C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FD210: 4E800421  bctrl
	ctx.lr = 0x827FD214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD214: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD218: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD21C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD220: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD224: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FD228: 4E800421  bctrl
	ctx.lr = 0x827FD22C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD22C: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD230: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD234: 409AFF5C  bne cr6, 0x827fd190
	if !ctx.cr[6].eq {
	pc = 0x827FD190; continue 'dispatch;
	}
            }
            0x827FD238 => {
    //   block [0x827FD238..0x827FD270)
	// 827FD238: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD240: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD244: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD248: 4E800421  bctrl
	ctx.lr = 0x827FD24C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD24C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD250: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD258: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD25C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FD260: 4E800421  bctrl
	ctx.lr = 0x827FD264;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD264: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD268: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FD26C: 409AFEBC  bne cr6, 0x827fd128
	if !ctx.cr[6].eq {
	pc = 0x827FD128; continue 'dispatch;
	}
            }
            0x827FD270 => {
    //   block [0x827FD270..0x827FD2A8)
	// 827FD270: 3B35006C  addi r25, r21, 0x6c
	ctx.r[25].s64 = ctx.r[21].s64 + 108;
	// 827FD274: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD278: 48002879  bl 0x827ffaf0
	ctx.lr = 0x827FD27C;
	sub_827FFAF0(ctx, base);
	// 827FD27C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD280: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD284: 3B0BA6A8  addi r24, r11, -0x5958
	ctx.r[24].s64 = ctx.r[11].s64 + -22872;
	// 827FD288: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD28C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD290: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD294: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD298: 4E800421  bctrl
	ctx.lr = 0x827FD29C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD29C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD2A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FD2A4: 419A014C  beq cr6, 0x827fd3f0
	if ctx.cr[6].eq {
	pc = 0x827FD3F0; continue 'dispatch;
	}
            }
            0x827FD2A8 => {
    //   block [0x827FD2A8..0x827FD310)
	// 827FD2A8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FD2AC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FD2B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FD2B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD2B8: 4BB92DD1  bl 0x82390088
	ctx.lr = 0x827FD2BC;
	sub_82390088(ctx, base);
	// 827FD2BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FD2C0: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 827FD2C4: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 827FD2C8: 4821AC59  bl 0x82a17f20
	ctx.lr = 0x827FD2CC;
	sub_82A17F20(ctx, base);
	// 827FD2CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD2D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD2D4: 3AC100D0  addi r22, r1, 0xd0
	ctx.r[22].s64 = ctx.r[1].s64 + 208;
	// 827FD2D8: 48002681  bl 0x827ff958
	ctx.lr = 0x827FD2DC;
	sub_827FF958(ctx, base);
	// 827FD2DC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD2E0: 4BFFE081  bl 0x827fb360
	ctx.lr = 0x827FD2E4;
	sub_827FB360(ctx, base);
	// 827FD2E4: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 827FD2E8: 4BEDC771  bl 0x826d9a58
	ctx.lr = 0x827FD2EC;
	sub_826D9A58(ctx, base);
	// 827FD2EC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD2F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD2F8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD2FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FD300: 4E800421  bctrl
	ctx.lr = 0x827FD304;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD304: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD308: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FD30C: 419A00AC  beq cr6, 0x827fd3b8
	if ctx.cr[6].eq {
	pc = 0x827FD3B8; continue 'dispatch;
	}
            }
            0x827FD310 => {
    //   block [0x827FD310..0x827FD3B8)
	// 827FD310: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FD314: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FD318: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FD31C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FD320: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FD324: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD328: 4BB92D61  bl 0x82390088
	ctx.lr = 0x827FD32C;
	sub_82390088(ctx, base);
	// 827FD32C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FD330: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD334: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD338: 4BC83491  bl 0x824807c8
	ctx.lr = 0x827FD33C;
	sub_824807C8(ctx, base);
	// 827FD33C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FD340: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FD344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD348: 4BC83481  bl 0x824807c8
	ctx.lr = 0x827FD34C;
	sub_824807C8(ctx, base);
	// 827FD34C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FD350: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FD354: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD358: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD35C: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FD360: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FD364: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FD368: 480025F1  bl 0x827ff958
	ctx.lr = 0x827FD36C;
	sub_827FF958(ctx, base);
	// 827FD36C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FD370: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD374: 480021DD  bl 0x827ff550
	ctx.lr = 0x827FD378;
	sub_827FF550(ctx, base);
	// 827FD378: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FD37C: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FD380: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD384: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD388: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD38C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FD390: 4E800421  bctrl
	ctx.lr = 0x827FD394;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD394: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD398: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD39C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD3A0: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD3A4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FD3A8: 4E800421  bctrl
	ctx.lr = 0x827FD3AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD3AC: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD3B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD3B4: 409AFF5C  bne cr6, 0x827fd310
	if !ctx.cr[6].eq {
	pc = 0x827FD310; continue 'dispatch;
	}
            }
            0x827FD3B8 => {
    //   block [0x827FD3B8..0x827FD3F0)
	// 827FD3B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD3BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD3C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD3C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD3C8: 4E800421  bctrl
	ctx.lr = 0x827FD3CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD3CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD3D0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD3D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD3D8: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD3DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FD3E0: 4E800421  bctrl
	ctx.lr = 0x827FD3E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD3E4: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD3E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FD3EC: 409AFEBC  bne cr6, 0x827fd2a8
	if !ctx.cr[6].eq {
	pc = 0x827FD2A8; continue 'dispatch;
	}
            }
            0x827FD3F0 => {
    //   block [0x827FD3F0..0x827FD428)
	// 827FD3F0: 3B35007C  addi r25, r21, 0x7c
	ctx.r[25].s64 = ctx.r[21].s64 + 124;
	// 827FD3F4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD3F8: 480026F9  bl 0x827ffaf0
	ctx.lr = 0x827FD3FC;
	sub_827FFAF0(ctx, base);
	// 827FD3FC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD400: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD404: 3B0BA6C0  addi r24, r11, -0x5940
	ctx.r[24].s64 = ctx.r[11].s64 + -22848;
	// 827FD408: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD40C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD410: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD414: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD418: 4E800421  bctrl
	ctx.lr = 0x827FD41C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD41C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD420: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FD424: 419A014C  beq cr6, 0x827fd570
	if ctx.cr[6].eq {
	pc = 0x827FD570; continue 'dispatch;
	}
            }
            0x827FD428 => {
    //   block [0x827FD428..0x827FD490)
	// 827FD428: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FD42C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FD430: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FD434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD438: 4BB92C51  bl 0x82390088
	ctx.lr = 0x827FD43C;
	sub_82390088(ctx, base);
	// 827FD43C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FD440: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 827FD444: 916100F0  stw r11, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[11].u32 ) };
	// 827FD448: 4821AAD9  bl 0x82a17f20
	ctx.lr = 0x827FD44C;
	sub_82A17F20(ctx, base);
	// 827FD44C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD450: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD454: 3AC100F0  addi r22, r1, 0xf0
	ctx.r[22].s64 = ctx.r[1].s64 + 240;
	// 827FD458: 48002501  bl 0x827ff958
	ctx.lr = 0x827FD45C;
	sub_827FF958(ctx, base);
	// 827FD45C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD460: 4BFFDF01  bl 0x827fb360
	ctx.lr = 0x827FD464;
	sub_827FB360(ctx, base);
	// 827FD464: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 827FD468: 4BEDC5F1  bl 0x826d9a58
	ctx.lr = 0x827FD46C;
	sub_826D9A58(ctx, base);
	// 827FD46C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD470: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD474: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD478: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD47C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FD480: 4E800421  bctrl
	ctx.lr = 0x827FD484;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD484: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD488: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FD48C: 419A00AC  beq cr6, 0x827fd538
	if ctx.cr[6].eq {
	pc = 0x827FD538; continue 'dispatch;
	}
            }
            0x827FD490 => {
    //   block [0x827FD490..0x827FD538)
	// 827FD490: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FD494: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FD498: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FD49C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FD4A0: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FD4A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD4A8: 4BB92BE1  bl 0x82390088
	ctx.lr = 0x827FD4AC;
	sub_82390088(ctx, base);
	// 827FD4AC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FD4B0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD4B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD4B8: 4BC83311  bl 0x824807c8
	ctx.lr = 0x827FD4BC;
	sub_824807C8(ctx, base);
	// 827FD4BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FD4C0: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FD4C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD4C8: 4BC83301  bl 0x824807c8
	ctx.lr = 0x827FD4CC;
	sub_824807C8(ctx, base);
	// 827FD4CC: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FD4D0: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FD4D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD4D8: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD4DC: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FD4E0: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FD4E4: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FD4E8: 48002471  bl 0x827ff958
	ctx.lr = 0x827FD4EC;
	sub_827FF958(ctx, base);
	// 827FD4EC: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FD4F0: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD4F4: 4800205D  bl 0x827ff550
	ctx.lr = 0x827FD4F8;
	sub_827FF550(ctx, base);
	// 827FD4F8: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FD4FC: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FD500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD504: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD508: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD50C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FD510: 4E800421  bctrl
	ctx.lr = 0x827FD514;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD514: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD518: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD51C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD520: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD524: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FD528: 4E800421  bctrl
	ctx.lr = 0x827FD52C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD52C: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD530: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD534: 409AFF5C  bne cr6, 0x827fd490
	if !ctx.cr[6].eq {
	pc = 0x827FD490; continue 'dispatch;
	}
            }
            0x827FD538 => {
    //   block [0x827FD538..0x827FD570)
	// 827FD538: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD540: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD544: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD548: 4E800421  bctrl
	ctx.lr = 0x827FD54C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD54C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD550: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD554: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD558: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD55C: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FD560: 4E800421  bctrl
	ctx.lr = 0x827FD564;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD564: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD568: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FD56C: 409AFEBC  bne cr6, 0x827fd428
	if !ctx.cr[6].eq {
	pc = 0x827FD428; continue 'dispatch;
	}
            }
            0x827FD570 => {
    //   block [0x827FD570..0x827FD5A8)
	// 827FD570: 3B350088  addi r25, r21, 0x88
	ctx.r[25].s64 = ctx.r[21].s64 + 136;
	// 827FD574: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD578: 48002579  bl 0x827ffaf0
	ctx.lr = 0x827FD57C;
	sub_827FFAF0(ctx, base);
	// 827FD57C: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD584: 3B0BA6D8  addi r24, r11, -0x5928
	ctx.r[24].s64 = ctx.r[11].s64 + -22824;
	// 827FD588: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD58C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD590: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD594: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD598: 4E800421  bctrl
	ctx.lr = 0x827FD59C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD59C: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD5A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FD5A4: 419A014C  beq cr6, 0x827fd6f0
	if ctx.cr[6].eq {
	pc = 0x827FD6F0; continue 'dispatch;
	}
            }
            0x827FD5A8 => {
    //   block [0x827FD5A8..0x827FD610)
	// 827FD5A8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 827FD5AC: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FD5B0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FD5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD5B8: 4BB92AD1  bl 0x82390088
	ctx.lr = 0x827FD5BC;
	sub_82390088(ctx, base);
	// 827FD5BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FD5C0: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 827FD5C4: 91610110  stw r11, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 827FD5C8: 4821A959  bl 0x82a17f20
	ctx.lr = 0x827FD5CC;
	sub_82A17F20(ctx, base);
	// 827FD5CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD5D0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD5D4: 3AC10110  addi r22, r1, 0x110
	ctx.r[22].s64 = ctx.r[1].s64 + 272;
	// 827FD5D8: 48002381  bl 0x827ff958
	ctx.lr = 0x827FD5DC;
	sub_827FF958(ctx, base);
	// 827FD5DC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD5E0: 4BFFDD81  bl 0x827fb360
	ctx.lr = 0x827FD5E4;
	sub_827FB360(ctx, base);
	// 827FD5E4: 38610114  addi r3, r1, 0x114
	ctx.r[3].s64 = ctx.r[1].s64 + 276;
	// 827FD5E8: 4BEDC471  bl 0x826d9a58
	ctx.lr = 0x827FD5EC;
	sub_826D9A58(ctx, base);
	// 827FD5EC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD5F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD5F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD5F8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD5FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 827FD600: 4E800421  bctrl
	ctx.lr = 0x827FD604;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD604: 5468063E  clrlwi r8, r3, 0x18
	ctx.r[8].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD608: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FD60C: 419A00AC  beq cr6, 0x827fd6b8
	if ctx.cr[6].eq {
	pc = 0x827FD6B8; continue 'dispatch;
	}
            }
            0x827FD610 => {
    //   block [0x827FD610..0x827FD6B8)
	// 827FD610: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 827FD614: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FD618: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 827FD61C: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FD620: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FD624: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD628: 4BB92A61  bl 0x82390088
	ctx.lr = 0x827FD62C;
	sub_82390088(ctx, base);
	// 827FD62C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FD630: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD634: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD638: 4BC83191  bl 0x824807c8
	ctx.lr = 0x827FD63C;
	sub_824807C8(ctx, base);
	// 827FD63C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FD640: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FD644: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD648: 4BC83181  bl 0x824807c8
	ctx.lr = 0x827FD64C;
	sub_824807C8(ctx, base);
	// 827FD64C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FD650: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FD654: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD658: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 827FD65C: 3AC10054  addi r22, r1, 0x54
	ctx.r[22].s64 = ctx.r[1].s64 + 84;
	// 827FD660: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FD664: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FD668: 480022F1  bl 0x827ff958
	ctx.lr = 0x827FD66C;
	sub_827FF958(ctx, base);
	// 827FD66C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 827FD670: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FD674: 48001EDD  bl 0x827ff550
	ctx.lr = 0x827FD678;
	sub_827FF550(ctx, base);
	// 827FD678: E9210068  ld r9, 0x68(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FD67C: F9230000  std r9, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 827FD680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD684: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD688: 80E8000C  lwz r7, 0xc(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD68C: 7CE903A6  mtctr r7
	ctx.ctr.u64 = ctx.r[7].u64;
	// 827FD690: 4E800421  bctrl
	ctx.lr = 0x827FD694;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD694: 80DF0000  lwz r6, 0(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD698: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FD69C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD6A0: 80A60008  lwz r5, 8(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD6A4: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 827FD6A8: 4E800421  bctrl
	ctx.lr = 0x827FD6AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD6AC: 5464063E  clrlwi r4, r3, 0x18
	ctx.r[4].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD6B0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD6B4: 409AFF5C  bne cr6, 0x827fd610
	if !ctx.cr[6].eq {
	pc = 0x827FD610; continue 'dispatch;
	}
            }
            0x827FD6B8 => {
    //   block [0x827FD6B8..0x827FD6F0)
	// 827FD6B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD6BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD6C0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD6C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 827FD6C8: 4E800421  bctrl
	ctx.lr = 0x827FD6CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD6CC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD6D0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 827FD6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD6D8: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD6DC: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 827FD6E0: 4E800421  bctrl
	ctx.lr = 0x827FD6E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 827FD6E4: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FD6E8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FD6EC: 409AFEBC  bne cr6, 0x827fd5a8
	if !ctx.cr[6].eq {
	pc = 0x827FD5A8; continue 'dispatch;
	}
            }
            0x827FD6F0 => {
    //   block [0x827FD6F0..0x827FD724)
	// 827FD6F0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD6F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FD6F8: 388BA6F0  addi r4, r11, -0x5910
	ctx.r[4].s64 = ctx.r[11].s64 + -22800;
	// 827FD6FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FD700: 4BA2F7D1  bl 0x8222ced0
	ctx.lr = 0x827FD704;
	sub_8222CED0(ctx, base);
	// 827FD704: 38B50078  addi r5, r21, 0x78
	ctx.r[5].s64 = ctx.r[21].s64 + 120;
	// 827FD708: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FD70C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FD710: 4821F739  bl 0x82a1ce48
	ctx.lr = 0x827FD714;
	sub_82A1CE48(ctx, base);
	// 827FD714: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FD718: 4B9C9051  bl 0x821c6768
	ctx.lr = 0x827FD71C;
	sub_821C6768(ctx, base);
	// 827FD71C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 827FD720: 38EA7088  addi r7, r10, 0x7088
	ctx.r[7].s64 = ctx.r[10].s64 + 28808;
	pc = 0x827FD724; continue 'dispatch;
            }
            0x827FD724 => {
    //   block [0x827FD724..0x827FD748)
	// 827FD724: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 827FD728: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD72C: 7D203828  lwarx r9, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 827FD730: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 827FD734: 7D20392D  stwcx. r9, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FD738: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD73C: 4082FFE8  bne 0x827fd724
	if !ctx.cr[0].eq {
	pc = 0x827FD724; continue 'dispatch;
	}
	// 827FD740: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 827FD744: 484ABCF8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FD750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FD750 size=648
    let mut pc: u32 = 0x827FD750;
    'dispatch: loop {
        match pc {
            0x827FD750 => {
    //   block [0x827FD750..0x827FD7E4)
	// 827FD750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FD754: 484ABC8D  bl 0x82ca93e0
	ctx.lr = 0x827FD758;
	sub_82CA93D0(ctx, base);
	// 827FD758: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FD75C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827FD760: 817A009C  lwz r11, 0x9c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(156 as u32) ) } as u64;
	// 827FD764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FD768: 409A0268  bne cr6, 0x827fd9d0
	if !ctx.cr[6].eq {
	pc = 0x827FD9D0; continue 'dispatch;
	}
	// 827FD76C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 827FD770: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FD774: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 827FD778: 386BA700  addi r3, r11, -0x5900
	ctx.r[3].s64 = ctx.r[11].s64 + -22784;
	// 827FD77C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 827FD780: 83F96DA0  lwz r31, 0x6da0(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FD784: 4B9F65D5  bl 0x821f3d58
	ctx.lr = 0x827FD788;
	sub_821F3D58(ctx, base);
	// 827FD788: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FD78C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD790: 482026C9  bl 0x829ffe58
	ctx.lr = 0x827FD794;
	sub_829FFE58(ctx, base);
	// 827FD794: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FD798: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD79C: 419A0234  beq cr6, 0x827fd9d0
	if ctx.cr[6].eq {
	pc = 0x827FD9D0; continue 'dispatch;
	}
	// 827FD7A0: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FD7A4: 482031ED  bl 0x82a00990
	ctx.lr = 0x827FD7A8;
	sub_82A00990(ctx, base);
	// 827FD7A8: 83010080  lwz r24, 0x80(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 827FD7AC: 8241007C  lwz r18, 0x7c(r1)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FD7B0: 82C10078  lwz r22, 0x78(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827FD7B4: 7F189040  cmplw cr6, r24, r18
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[18].u32, &mut ctx.xer);
	// 827FD7B8: 419A0210  beq cr6, 0x827fd9c8
	if ctx.cr[6].eq {
	pc = 0x827FD9C8; continue 'dispatch;
	}
	// 827FD7BC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FD7C0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 827FD7C4: 3D20820E  lis r9, -0x7df2
	ctx.r[9].s64 = -2113011712;
	// 827FD7C8: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 827FD7CC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 827FD7D0: 3E60834A  lis r19, -0x7cb6
	ctx.r[19].s64 = -2092302336;
	// 827FD7D4: 3B6B7088  addi r27, r11, 0x7088
	ctx.r[27].s64 = ctx.r[11].s64 + 28808;
	// 827FD7D8: 3A8AE460  addi r20, r10, -0x1ba0
	ctx.r[20].s64 = ctx.r[10].s64 + -7072;
	// 827FD7DC: 3AE9A710  addi r23, r9, -0x58f0
	ctx.r[23].s64 = ctx.r[9].s64 + -22768;
	// 827FD7E0: 3AA8FB7C  addi r21, r8, -0x484
	ctx.r[21].s64 = ctx.r[8].s64 + -1156;
	pc = 0x827FD7E4; continue 'dispatch;
            }
            0x827FD7E4 => {
    //   block [0x827FD7E4..0x827FD820)
	// 827FD7E4: 570B083C  slwi r11, r24, 1
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FD7E8: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 827FD7EC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FD7F0: 7D6BB214  add r11, r11, r22
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 827FD7F4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD7F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD7FC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 827FD800: 419A0020  beq cr6, 0x827fd820
	if ctx.cr[6].eq {
	pc = 0x827FD820; continue 'dispatch;
	}
	// 827FD804: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 827FD808: 409A0018  bne cr6, 0x827fd820
	if !ctx.cr[6].eq {
	pc = 0x827FD820; continue 'dispatch;
	}
	// 827FD80C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD810: 8133E454  lwz r9, -0x1bac(r19)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 827FD814: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FD818: 409A0008  bne cr6, 0x827fd820
	if !ctx.cr[6].eq {
	pc = 0x827FD820; continue 'dispatch;
	}
	// 827FD81C: 7E8AA378  mr r10, r20
	ctx.r[10].u64 = ctx.r[20].u64;
	pc = 0x827FD820; continue 'dispatch;
            }
            0x827FD820 => {
    //   block [0x827FD820..0x827FD8BC)
	// 827FD820: 80796DA0  lwz r3, 0x6da0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FD824: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD828: 4B9E6A29  bl 0x821e4250
	ctx.lr = 0x827FD82C;
	sub_821E4250(ctx, base);
	// 827FD82C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FD830: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 827FD834: 419A0188  beq cr6, 0x827fd9bc
	if ctx.cr[6].eq {
	pc = 0x827FD9BC; continue 'dispatch;
	}
	// 827FD838: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 827FD83C: 4BB25D05  bl 0x82323540
	ctx.lr = 0x827FD840;
	sub_82323540(ctx, base);
	// 827FD840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FD844: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FD848: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FD84C: 4BA2F685  bl 0x8222ced0
	ctx.lr = 0x827FD850;
	sub_8222CED0(ctx, base);
	// 827FD850: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FD854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FD858: 419A0138  beq cr6, 0x827fd990
	if ctx.cr[6].eq {
	pc = 0x827FD990; continue 'dispatch;
	}
	// 827FD85C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FD860: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FD864: 419A012C  beq cr6, 0x827fd990
	if ctx.cr[6].eq {
	pc = 0x827FD990; continue 'dispatch;
	}
	// 827FD868: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FD86C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FD870: 48001B91  bl 0x827ff400
	ctx.lr = 0x827FD874;
	sub_827FF400(ctx, base);
	// 827FD874: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 827FD878: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FD87C: 4BB2330D  bl 0x82320b88
	ctx.lr = 0x827FD880;
	sub_82320B88(ctx, base);
	// 827FD880: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 827FD884: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD888: 4BAAC161  bl 0x822a99e8
	ctx.lr = 0x827FD88C;
	sub_822A99E8(ctx, base);
	// 827FD88C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FD890: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FD894: 419A00D0  beq cr6, 0x827fd964
	if ctx.cr[6].eq {
	pc = 0x827FD964; continue 'dispatch;
	}
	// 827FD898: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FD89C: 482030F5  bl 0x82a00990
	ctx.lr = 0x827FD8A0;
	sub_82A00990(ctx, base);
	// 827FD8A0: 83E10080  lwz r31, 0x80(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 827FD8A4: 83C1007C  lwz r30, 0x7c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FD8A8: 83A10078  lwz r29, 0x78(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827FD8AC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FD8B0: 419A00A8  beq cr6, 0x827fd958
	if ctx.cr[6].eq {
	pc = 0x827FD958; continue 'dispatch;
	}
	// 827FD8B4: 39610068  addi r11, r1, 0x68
	ctx.r[11].s64 = ctx.r[1].s64 + 104;
	// 827FD8B8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x827FD8BC; continue 'dispatch;
            }
            0x827FD8BC => {
    //   block [0x827FD8BC..0x827FD92C)
	// 827FD8BC: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827FD8C0: 81796DA0  lwz r11, 0x6da0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FD8C4: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 827FD8C8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 827FD8CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD8D0: 7D6AEA14  add r11, r10, r29
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 827FD8D4: 8069000C  lwz r3, 0xc(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FD8D8: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FD8DC: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FD8E0: 48203831  bl 0x82a01110
	ctx.lr = 0x827FD8E4;
	sub_82A01110(ctx, base);
	// 827FD8E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FD8E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FD8EC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FD8F0: 4BA2F5E1  bl 0x8222ced0
	ctx.lr = 0x827FD8F4;
	sub_8222CED0(ctx, base);
	// 827FD8F4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FD8F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FD8FC: 48001B05  bl 0x827ff400
	ctx.lr = 0x827FD900;
	sub_827FF400(ctx, base);
	// 827FD900: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 827FD904: 80E1006C  lwz r7, 0x6c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FD908: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FD90C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FD910: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 827FD914: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827FD918: 4834C469  bl 0x82b49d80
	ctx.lr = 0x827FD91C;
	sub_82B49D80(ctx, base);
	// 827FD91C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FD920: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827FD924: 4B9C8E45  bl 0x821c6768
	ctx.lr = 0x827FD928;
	sub_821C6768(ctx, base);
	// 827FD928: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x827FD92C; continue 'dispatch;
            }
            0x827FD92C => {
    //   block [0x827FD92C..0x827FD958)
	// 827FD92C: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 827FD930: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD934: 7CC02028  lwarx r6, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 827FD938: 38C6FFFF  addi r6, r6, -1
	ctx.r[6].s64 = ctx.r[6].s64 + -1;
	// 827FD93C: 7CC0212D  stwcx. r6, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FD940: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD944: 4082FFE8  bne 0x827fd92c
	if !ctx.cr[0].eq {
	pc = 0x827FD92C; continue 'dispatch;
	}
	// 827FD948: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	// 827FD94C: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FD950: 409AFF6C  bne cr6, 0x827fd8bc
	if !ctx.cr[6].eq {
	pc = 0x827FD8BC; continue 'dispatch;
	}
	// 827FD954: 93E10080  stw r31, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	pc = 0x827FD958; continue 'dispatch;
            }
            0x827FD958 => {
    //   block [0x827FD958..0x827FD964)
	// 827FD958: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827FD95C: 4BA1E3DD  bl 0x8221bd38
	ctx.lr = 0x827FD960;
	sub_8221BD38(ctx, base);
	// 827FD960: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	pc = 0x827FD964; continue 'dispatch;
            }
            0x827FD964 => {
    //   block [0x827FD964..0x827FD990)
	// 827FD964: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827FD968: 387A0094  addi r3, r26, 0x94
	ctx.r[3].s64 = ctx.r[26].s64 + 148;
	// 827FD96C: 3BE10068  addi r31, r1, 0x68
	ctx.r[31].s64 = ctx.r[1].s64 + 104;
	// 827FD970: 4BE59229  bl 0x82656b98
	ctx.lr = 0x827FD974;
	sub_82656B98(ctx, base);
	// 827FD974: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FD978: 4BB23309  bl 0x82320c80
	ctx.lr = 0x827FD97C;
	sub_82320C80(ctx, base);
	// 827FD97C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 827FD980: 48217411  bl 0x82a14d90
	ctx.lr = 0x827FD984;
	sub_82A14D90(ctx, base);
	// 827FD984: 8061006C  lwz r3, 0x6c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 827FD988: 4BA1E3B1  bl 0x8221bd38
	ctx.lr = 0x827FD98C;
	sub_8221BD38(ctx, base);
	// 827FD98C: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	pc = 0x827FD990; continue 'dispatch;
            }
            0x827FD990 => {
    //   block [0x827FD990..0x827FD99C)
	// 827FD990: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FD994: 4B9C8DD5  bl 0x821c6768
	ctx.lr = 0x827FD998;
	sub_821C6768(ctx, base);
	// 827FD998: 7F69DB78  mr r9, r27
	ctx.r[9].u64 = ctx.r[27].u64;
	pc = 0x827FD99C; continue 'dispatch;
            }
            0x827FD99C => {
    //   block [0x827FD99C..0x827FD9BC)
	// 827FD99C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 827FD9A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD9A4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 827FD9A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FD9AC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FD9B0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FD9B4: 4082FFE8  bne 0x827fd99c
	if !ctx.cr[0].eq {
	pc = 0x827FD99C; continue 'dispatch;
	}
	// 827FD9B8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x827FD9BC; continue 'dispatch;
            }
            0x827FD9BC => {
    //   block [0x827FD9BC..0x827FD9C8)
	// 827FD9BC: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 827FD9C0: 7F189040  cmplw cr6, r24, r18
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[18].u32, &mut ctx.xer);
	// 827FD9C4: 409AFE20  bne cr6, 0x827fd7e4
	if !ctx.cr[6].eq {
	pc = 0x827FD7E4; continue 'dispatch;
	}
	pc = 0x827FD9C8; continue 'dispatch;
            }
            0x827FD9C8 => {
    //   block [0x827FD9C8..0x827FD9D0)
	// 827FD9C8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 827FD9CC: 4BA1E36D  bl 0x8221bd38
	ctx.lr = 0x827FD9D0;
	sub_8221BD38(ctx, base);
	pc = 0x827FD9D0; continue 'dispatch;
            }
            0x827FD9D0 => {
    //   block [0x827FD9D0..0x827FD9D8)
	// 827FD9D0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 827FD9D4: 484ABA5C  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FD9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FD9D8 size=116
    let mut pc: u32 = 0x827FD9D8;
    'dispatch: loop {
        match pc {
            0x827FD9D8 => {
    //   block [0x827FD9D8..0x827FDA4C)
	// 827FD9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FD9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FD9E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FD9E4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FD9E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FD9EC: 48000445  bl 0x827fde30
	ctx.lr = 0x827FD9F0;
	sub_827FDE30(ctx, base);
	// 827FD9F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD9F4: 4800005D  bl 0x827fda50
	ctx.lr = 0x827FD9F8;
	sub_827FDA50(ctx, base);
	// 827FD9F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FD9FC: 48000A45  bl 0x827fe440
	ctx.lr = 0x827FDA00;
	sub_827FE440(ctx, base);
	// 827FDA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA04: 4800066D  bl 0x827fe070
	ctx.lr = 0x827FDA08;
	sub_827FE070(ctx, base);
	// 827FDA08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA0C: 48000DE5  bl 0x827fe7f0
	ctx.lr = 0x827FDA10;
	sub_827FE7F0(ctx, base);
	// 827FDA10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA14: 48000F35  bl 0x827fe948
	ctx.lr = 0x827FDA18;
	sub_827FE948(ctx, base);
	// 827FDA18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA1C: 48001085  bl 0x827feaa0
	ctx.lr = 0x827FDA20;
	sub_827FEAA0(ctx, base);
	// 827FDA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA24: 48001345  bl 0x827fed68
	ctx.lr = 0x827FDA28;
	sub_827FED68(ctx, base);
	// 827FDA28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA2C: 4800156D  bl 0x827fef98
	ctx.lr = 0x827FDA30;
	sub_827FEF98(ctx, base);
	// 827FDA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDA34: 480016BD  bl 0x827ff0f0
	ctx.lr = 0x827FDA38;
	sub_827FF0F0(ctx, base);
	// 827FDA38: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827FDA3C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FDA40: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FDA44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FDA48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FDA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FDA50 size=992
    let mut pc: u32 = 0x827FDA50;
    'dispatch: loop {
        match pc {
            0x827FDA50 => {
    //   block [0x827FDA50..0x827FDB10)
	// 827FDA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FDA54: 484AB9AD  bl 0x82ca9400
	ctx.lr = 0x827FDA58;
	sub_82CA93D0(ctx, base);
	// 827FDA58: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FDA5C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 827FDA60: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827FDA64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FDA68: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FDA6C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDA70: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FDA74: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDA78: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FDA7C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDA80: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FDA84: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDA88: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FDA8C: 4B9F27B5  bl 0x821f0240
	ctx.lr = 0x827FDA90;
	sub_821F0240(ctx, base);
	// 827FDA90: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FDA94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDA98: 419A0364  beq cr6, 0x827fddfc
	if ctx.cr[6].eq {
	pc = 0x827FDDFC; continue 'dispatch;
	}
	// 827FDA9C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDAA0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDAA4: 419A0358  beq cr6, 0x827fddfc
	if ctx.cr[6].eq {
	pc = 0x827FDDFC; continue 'dispatch;
	}
	// 827FDAA8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FDAAC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FDAB0: 48001951  bl 0x827ff400
	ctx.lr = 0x827FDAB4;
	sub_827FF400(ctx, base);
	// 827FDAB4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 827FDAB8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827FDABC: 4BB230CD  bl 0x82320b88
	ctx.lr = 0x827FDAC0;
	sub_82320B88(ctx, base);
	// 827FDAC0: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FDAC4: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 827FDAC8: 3940007C  li r10, 0x7c
	ctx.r[10].s64 = 124;
	// 827FDACC: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 827FDAD0: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 827FDAD4: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 827FDAD8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FDADC: 93C1008C  stw r30, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[30].u32 ) };
	// 827FDAE0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FDAE4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827FDAE8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDAEC: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FDAF0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDAF4: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDAF8: 48003F01  bl 0x828019f8
	ctx.lr = 0x827FDAFC;
	sub_828019F8(ctx, base);
	// 827FDAFC: 83810084  lwz r28, 0x84(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FDB00: 83610088  lwz r27, 0x88(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 827FDB04: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 827FDB08: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FDB0C: 419A02A0  beq cr6, 0x827fddac
	if ctx.cr[6].eq {
	pc = 0x827FDDAC; continue 'dispatch;
	}
	pc = 0x827FDB10; continue 'dispatch;
            }
            0x827FDB10 => {
    //   block [0x827FDB10..0x827FDB54)
	// 827FDB10: 80DD0000  lwz r6, 0(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDB14: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 827FDB18: 8166002C  lwz r11, 0x2c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FDB1C: 556AEFFE  rlwinm r10, r11, 0x1d, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000007u64;
	// 827FDB20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FDB24: 419A00F4  beq cr6, 0x827fdc18
	if ctx.cr[6].eq {
	pc = 0x827FDC18; continue 'dispatch;
	}
	// 827FDB28: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FDB2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDB30: 419A0024  beq cr6, 0x827fdb54
	if ctx.cr[6].eq {
	pc = 0x827FDB54; continue 'dispatch;
	}
	// 827FDB34: 894B0043  lbz r10, 0x43(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 827FDB38: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FDB3C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827FDB40: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827FDB44: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDB48: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827FDB4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDB50: 480000CC  b 0x827fdc1c
	pc = 0x827FDC1C; continue 'dispatch;
            }
            0x827FDB54 => {
    //   block [0x827FDB54..0x827FDB70)
	// 827FDB54: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FDB58: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FDB5C: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 827FDB60: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 827FDB64: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 827FDB68: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDB6C: 40810054  ble 0x827fdbc0
	if !ctx.cr[0].gt {
	pc = 0x827FDBC0; continue 'dispatch;
	}
	pc = 0x827FDB70; continue 'dispatch;
            }
            0x827FDB70 => {
    //   block [0x827FDB70..0x827FDB90)
	// 827FDB70: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FDB74: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FDB78: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FDB7C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDB80: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 827FDB84: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FDB88: 41980008  blt cr6, 0x827fdb90
	if ctx.cr[6].lt {
	pc = 0x827FDB90; continue 'dispatch;
	}
	// 827FDB8C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x827FDB90; continue 'dispatch;
            }
            0x827FDB90 => {
    //   block [0x827FDB90..0x827FDBAC)
	// 827FDB90: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FDB94: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FDB98: 419A0014  beq cr6, 0x827fdbac
	if ctx.cr[6].eq {
	pc = 0x827FDBAC; continue 'dispatch;
	}
	// 827FDB9C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FDBA0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FDBA4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FDBA8: 4800000C  b 0x827fdbb4
	pc = 0x827FDBB4; continue 'dispatch;
            }
            0x827FDBAC => {
    //   block [0x827FDBAC..0x827FDBB4)
	// 827FDBAC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FDBB0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FDBB4; continue 'dispatch;
            }
            0x827FDBB4 => {
    //   block [0x827FDBB4..0x827FDBC0)
	// 827FDBB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDBB8: 4199FFB8  bgt cr6, 0x827fdb70
	if ctx.cr[6].gt {
	pc = 0x827FDB70; continue 'dispatch;
	}
	// 827FDBBC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x827FDBC0; continue 'dispatch;
            }
            0x827FDBC0 => {
    //   block [0x827FDBC0..0x827FDBDC)
	// 827FDBC0: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 827FDBC4: 419A0040  beq cr6, 0x827fdc04
	if ctx.cr[6].eq {
	pc = 0x827FDC04; continue 'dispatch;
	}
	// 827FDBC8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDBCC: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 827FDBD0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDBD4: 41990008  bgt cr6, 0x827fdbdc
	if ctx.cr[6].gt {
	pc = 0x827FDBDC; continue 'dispatch;
	}
	// 827FDBD8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x827FDBDC; continue 'dispatch;
            }
            0x827FDBDC => {
    //   block [0x827FDBDC..0x827FDC04)
	// 827FDBDC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDBE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDBE4: 409A0020  bne cr6, 0x827fdc04
	if !ctx.cr[6].eq {
	pc = 0x827FDC04; continue 'dispatch;
	}
	// 827FDBE8: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827FDBEC: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 827FDBF0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FDBF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDBF8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827FDBFC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDC00: 4800001C  b 0x827fdc1c
	pc = 0x827FDC1C; continue 'dispatch;
            }
            0x827FDC04 => {
    //   block [0x827FDC04..0x827FDC18)
	// 827FDC04: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 827FDC08: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDC0C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 827FDC10: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDC14: 48000008  b 0x827fdc1c
	pc = 0x827FDC1C; continue 'dispatch;
            }
            0x827FDC18 => {
    //   block [0x827FDC18..0x827FDC1C)
	// 827FDC18: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x827FDC1C; continue 'dispatch;
            }
            0x827FDC1C => {
    //   block [0x827FDC1C..0x827FDC64)
	// 827FDC1C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDC20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDC24: 419A017C  beq cr6, 0x827fdda0
	if ctx.cr[6].eq {
	pc = 0x827FDDA0; continue 'dispatch;
	}
	// 827FDC28: 8146002C  lwz r10, 0x2c(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FDC2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 827FDC30: 5549F7FE  rlwinm r9, r10, 0x1e, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000003u64;
	// 827FDC34: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FDC38: 419A00E4  beq cr6, 0x827fdd1c
	if ctx.cr[6].eq {
	pc = 0x827FDD1C; continue 'dispatch;
	}
	// 827FDC3C: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FDC40: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FDC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDC48: 419A001C  beq cr6, 0x827fdc64
	if ctx.cr[6].eq {
	pc = 0x827FDC64; continue 'dispatch;
	}
	// 827FDC4C: 896B0042  lbz r11, 0x42(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(66 as u32) ) } as u64;
	// 827FDC50: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827FDC54: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827FDC58: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDC5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FDC60: 480000C0  b 0x827fdd20
	pc = 0x827FDD20; continue 'dispatch;
            }
            0x827FDC64 => {
    //   block [0x827FDC64..0x827FDC7C)
	// 827FDC64: 80C6004C  lwz r6, 0x4c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FDC68: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 827FDC6C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FDC70: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FDC74: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDC78: 40810054  ble 0x827fdccc
	if !ctx.cr[0].gt {
	pc = 0x827FDCCC; continue 'dispatch;
	}
	pc = 0x827FDC7C; continue 'dispatch;
            }
            0x827FDC7C => {
    //   block [0x827FDC7C..0x827FDC9C)
	// 827FDC7C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FDC80: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FDC84: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FDC88: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDC8C: 2F070042  cmpwi cr6, r7, 0x42
	ctx.cr[6].compare_i32(ctx.r[7].s32, 66, &mut ctx.xer);
	// 827FDC90: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FDC94: 41980008  blt cr6, 0x827fdc9c
	if ctx.cr[6].lt {
	pc = 0x827FDC9C; continue 'dispatch;
	}
	// 827FDC98: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x827FDC9C; continue 'dispatch;
            }
            0x827FDC9C => {
    //   block [0x827FDC9C..0x827FDCB8)
	// 827FDC9C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FDCA0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FDCA4: 419A0014  beq cr6, 0x827fdcb8
	if ctx.cr[6].eq {
	pc = 0x827FDCB8; continue 'dispatch;
	}
	// 827FDCA8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FDCAC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FDCB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FDCB4: 4800000C  b 0x827fdcc0
	pc = 0x827FDCC0; continue 'dispatch;
            }
            0x827FDCB8 => {
    //   block [0x827FDCB8..0x827FDCC0)
	// 827FDCB8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FDCBC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FDCC0; continue 'dispatch;
            }
            0x827FDCC0 => {
    //   block [0x827FDCC0..0x827FDCCC)
	// 827FDCC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDCC4: 4199FFB8  bgt cr6, 0x827fdc7c
	if ctx.cr[6].gt {
	pc = 0x827FDC7C; continue 'dispatch;
	}
	// 827FDCC8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x827FDCCC; continue 'dispatch;
            }
            0x827FDCCC => {
    //   block [0x827FDCCC..0x827FDCE8)
	// 827FDCCC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FDCD0: 419A003C  beq cr6, 0x827fdd0c
	if ctx.cr[6].eq {
	pc = 0x827FDD0C; continue 'dispatch;
	}
	// 827FDCD4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDCD8: 2F0B0042  cmpwi cr6, r11, 0x42
	ctx.cr[6].compare_i32(ctx.r[11].s32, 66, &mut ctx.xer);
	// 827FDCDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDCE0: 41990008  bgt cr6, 0x827fdce8
	if ctx.cr[6].gt {
	pc = 0x827FDCE8; continue 'dispatch;
	}
	// 827FDCE4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x827FDCE8; continue 'dispatch;
            }
            0x827FDCE8 => {
    //   block [0x827FDCE8..0x827FDD0C)
	// 827FDCE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDCEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDCF0: 409A001C  bne cr6, 0x827fdd0c
	if !ctx.cr[6].eq {
	pc = 0x827FDD0C; continue 'dispatch;
	}
	// 827FDCF4: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FDCF8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FDCFC: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 827FDD00: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FDD04: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDD08: 48000018  b 0x827fdd20
	pc = 0x827FDD20; continue 'dispatch;
            }
            0x827FDD0C => {
    //   block [0x827FDD0C..0x827FDD1C)
	// 827FDD0C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FDD10: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FDD14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDD18: 48000008  b 0x827fdd20
	pc = 0x827FDD20; continue 'dispatch;
            }
            0x827FDD1C => {
    //   block [0x827FDD1C..0x827FDD20)
	// 827FDD1C: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x827FDD20; continue 'dispatch;
            }
            0x827FDD20 => {
    //   block [0x827FDD20..0x827FDD50)
	// 827FDD20: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827FDD24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FDD28: 419A0078  beq cr6, 0x827fdda0
	if ctx.cr[6].eq {
	pc = 0x827FDDA0; continue 'dispatch;
	}
	// 827FDD2C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FDD30: 4BAA1149  bl 0x8229ee78
	ctx.lr = 0x827FDD34;
	sub_8229EE78(ctx, base);
	// 827FDD34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827FDD38: 419A0018  beq cr6, 0x827fdd50
	if ctx.cr[6].eq {
	pc = 0x827FDD50; continue 'dispatch;
	}
	// 827FDD3C: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 827FDD40: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827FDD44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDD48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FDD4C: 409A0008  bne cr6, 0x827fdd54
	if !ctx.cr[6].eq {
	pc = 0x827FDD54; continue 'dispatch;
	}
	pc = 0x827FDD50; continue 'dispatch;
            }
            0x827FDD50 => {
    //   block [0x827FDD50..0x827FDD54)
	// 827FDD50: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x827FDD54; continue 'dispatch;
            }
            0x827FDD54 => {
    //   block [0x827FDD54..0x827FDDA0)
	// 827FDD54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDD58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDD5C: 419A0044  beq cr6, 0x827fdda0
	if ctx.cr[6].eq {
	pc = 0x827FDDA0; continue 'dispatch;
	}
	// 827FDD60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FDD64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FDD68: 4802D0F1  bl 0x8282ae58
	ctx.lr = 0x827FDD6C;
	sub_8282AE58(ctx, base);
	// 827FDD6C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FDD70: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 827FDD74: 4B9C404D  bl 0x821c1dc0
	ctx.lr = 0x827FDD78;
	sub_821C1DC0(ctx, base);
	// 827FDD78: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FDD7C: 4BA1705D  bl 0x82214dd8
	ctx.lr = 0x827FDD80;
	sub_82214DD8(ctx, base);
	// 827FDD80: 81410094  lwz r10, 0x94(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827FDD84: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 827FDD88: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 827FDD8C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827FDD90: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FDD94: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827FDD98: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827FDD9C: 482995CD  bl 0x82a97368
	ctx.lr = 0x827FDDA0;
	sub_82A97368(ctx, base);
	pc = 0x827FDDA0; continue 'dispatch;
            }
            0x827FDDA0 => {
    //   block [0x827FDDA0..0x827FDDAC)
	// 827FDDA0: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 827FDDA4: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FDDA8: 409AFD68  bne cr6, 0x827fdb10
	if !ctx.cr[6].eq {
	pc = 0x827FDB10; continue 'dispatch;
	}
	pc = 0x827FDDAC; continue 'dispatch;
            }
            0x827FDDAC => {
    //   block [0x827FDDAC..0x827FDDE8)
	// 827FDDAC: 3BFA0018  addi r31, r26, 0x18
	ctx.r[31].s64 = ctx.r[26].s64 + 24;
	// 827FDDB0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FDDB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDDB8: 48001911  bl 0x827ff6c8
	ctx.lr = 0x827FDDBC;
	sub_827FF6C8(ctx, base);
	// 827FDDBC: 48216FD5  bl 0x82a14d90
	ctx.lr = 0x827FDDC0;
	sub_82A14D90(ctx, base);
	// 827FDDC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDDC4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FDDC8: 3BE10090  addi r31, r1, 0x90
	ctx.r[31].s64 = ctx.r[1].s64 + 144;
	// 827FDDCC: 480018FD  bl 0x827ff6c8
	ctx.lr = 0x827FDDD0;
	sub_827FF6C8(ctx, base);
	// 827FDDD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FDDD4: 4BC530A5  bl 0x82450e78
	ctx.lr = 0x827FDDD8;
	sub_82450E78(ctx, base);
	// 827FDDD8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 827FDDDC: 419A000C  beq cr6, 0x827fdde8
	if ctx.cr[6].eq {
	pc = 0x827FDDE8; continue 'dispatch;
	}
	// 827FDDE0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FDDE4: 4BA1DF55  bl 0x8221bd38
	ctx.lr = 0x827FDDE8;
	sub_8221BD38(ctx, base);
	pc = 0x827FDDE8; continue 'dispatch;
            }
            0x827FDDE8 => {
    //   block [0x827FDDE8..0x827FDDFC)
	// 827FDDE8: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 827FDDEC: 48216FA5  bl 0x82a14d90
	ctx.lr = 0x827FDDF0;
	sub_82A14D90(ctx, base);
	// 827FDDF0: 80610094  lwz r3, 0x94(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 827FDDF4: 4BA1DF45  bl 0x8221bd38
	ctx.lr = 0x827FDDF8;
	sub_8221BD38(ctx, base);
	// 827FDDF8: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	pc = 0x827FDDFC; continue 'dispatch;
            }
            0x827FDDFC => {
    //   block [0x827FDDFC..0x827FDE0C)
	// 827FDDFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FDE00: 4B9C8969  bl 0x821c6768
	ctx.lr = 0x827FDE04;
	sub_821C6768(ctx, base);
	// 827FDE04: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FDE08: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827FDE0C; continue 'dispatch;
            }
            0x827FDE0C => {
    //   block [0x827FDE0C..0x827FDE30)
	// 827FDE0C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827FDE10: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FDE14: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827FDE18: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827FDE1C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FDE20: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FDE24: 4082FFE8  bne 0x827fde0c
	if !ctx.cr[0].eq {
	pc = 0x827FDE0C; continue 'dispatch;
	}
	// 827FDE28: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 827FDE2C: 484AB624  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FDE30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FDE30 size=576
    let mut pc: u32 = 0x827FDE30;
    'dispatch: loop {
        match pc {
            0x827FDE30 => {
    //   block [0x827FDE30..0x827FDEEC)
	// 827FDE30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FDE34: 484AB5CD  bl 0x82ca9400
	ctx.lr = 0x827FDE38;
	sub_82CA93D0(ctx, base);
	// 827FDE38: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FDE3C: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 827FDE40: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FDE44: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FDE48: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FDE4C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDE50: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FDE54: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDE58: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FDE5C: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDE60: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FDE64: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDE68: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FDE6C: 4B9F23D5  bl 0x821f0240
	ctx.lr = 0x827FDE70;
	sub_821F0240(ctx, base);
	// 827FDE70: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FDE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDE78: 419A01C4  beq cr6, 0x827fe03c
	if ctx.cr[6].eq {
	pc = 0x827FE03C; continue 'dispatch;
	}
	// 827FDE7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDE80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDE84: 419A01B8  beq cr6, 0x827fe03c
	if ctx.cr[6].eq {
	pc = 0x827FE03C; continue 'dispatch;
	}
	// 827FDE88: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FDE8C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FDE90: 48001571  bl 0x827ff400
	ctx.lr = 0x827FDE94;
	sub_827FF400(ctx, base);
	// 827FDE94: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FDE98: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827FDE9C: 90610060  stw r3, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u32 ) };
	// 827FDEA0: 39400041  li r10, 0x41
	ctx.r[10].s64 = 65;
	// 827FDEA4: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 827FDEA8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 827FDEAC: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 827FDEB0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 827FDEB4: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 827FDEB8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FDEBC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827FDEC0: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 827FDEC4: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDEC8: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FDECC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDED0: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FDED4: 48003B25  bl 0x828019f8
	ctx.lr = 0x827FDED8;
	sub_828019F8(ctx, base);
	// 827FDED8: 83610074  lwz r27, 0x74(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FDEDC: 83410078  lwz r26, 0x78(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827FDEE0: 7F7EDB78  mr r30, r27
	ctx.r[30].u64 = ctx.r[27].u64;
	// 827FDEE4: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FDEE8: 419A0134  beq cr6, 0x827fe01c
	if ctx.cr[6].eq {
	pc = 0x827FE01C; continue 'dispatch;
	}
	pc = 0x827FDEEC; continue 'dispatch;
            }
            0x827FDEEC => {
    //   block [0x827FDEEC..0x827FDF30)
	// 827FDEEC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDEF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FDEF4: 814B0038  lwz r10, 0x38(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 827FDEF8: 5549B7FE  rlwinm r9, r10, 0x16, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000003FFu64;
	// 827FDEFC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FDF00: 419A00F4  beq cr6, 0x827fdff4
	if ctx.cr[6].eq {
	pc = 0x827FDFF4; continue 'dispatch;
	}
	// 827FDF04: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FDF08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FDF0C: 419A0024  beq cr6, 0x827fdf30
	if ctx.cr[6].eq {
	pc = 0x827FDF30; continue 'dispatch;
	}
	// 827FDF10: 894A00AA  lbz r10, 0xaa(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(170 as u32) ) } as u64;
	// 827FDF14: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FDF18: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827FDF1C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827FDF20: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDF24: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FDF28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDF2C: 480000CC  b 0x827fdff8
	pc = 0x827FDFF8; continue 'dispatch;
            }
            0x827FDF30 => {
    //   block [0x827FDF30..0x827FDF4C)
	// 827FDF30: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FDF34: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FDF38: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827FDF3C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FDF40: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FDF44: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDF48: 40810054  ble 0x827fdf9c
	if !ctx.cr[0].gt {
	pc = 0x827FDF9C; continue 'dispatch;
	}
	pc = 0x827FDF4C; continue 'dispatch;
            }
            0x827FDF4C => {
    //   block [0x827FDF4C..0x827FDF6C)
	// 827FDF4C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FDF50: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FDF54: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FDF58: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDF5C: 2F0700AA  cmpwi cr6, r7, 0xaa
	ctx.cr[6].compare_i32(ctx.r[7].s32, 170, &mut ctx.xer);
	// 827FDF60: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FDF64: 41980008  blt cr6, 0x827fdf6c
	if ctx.cr[6].lt {
	pc = 0x827FDF6C; continue 'dispatch;
	}
	// 827FDF68: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x827FDF6C; continue 'dispatch;
            }
            0x827FDF6C => {
    //   block [0x827FDF6C..0x827FDF88)
	// 827FDF6C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FDF70: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FDF74: 419A0014  beq cr6, 0x827fdf88
	if ctx.cr[6].eq {
	pc = 0x827FDF88; continue 'dispatch;
	}
	// 827FDF78: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FDF7C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FDF80: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FDF84: 4800000C  b 0x827fdf90
	pc = 0x827FDF90; continue 'dispatch;
            }
            0x827FDF88 => {
    //   block [0x827FDF88..0x827FDF90)
	// 827FDF88: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FDF8C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FDF90; continue 'dispatch;
            }
            0x827FDF90 => {
    //   block [0x827FDF90..0x827FDF9C)
	// 827FDF90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FDF94: 4199FFB8  bgt cr6, 0x827fdf4c
	if ctx.cr[6].gt {
	pc = 0x827FDF4C; continue 'dispatch;
	}
	// 827FDF98: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x827FDF9C; continue 'dispatch;
            }
            0x827FDF9C => {
    //   block [0x827FDF9C..0x827FDFB8)
	// 827FDF9C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FDFA0: 419A0040  beq cr6, 0x827fdfe0
	if ctx.cr[6].eq {
	pc = 0x827FDFE0; continue 'dispatch;
	}
	// 827FDFA4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FDFA8: 2F0B00AA  cmpwi cr6, r11, 0xaa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 170, &mut ctx.xer);
	// 827FDFAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDFB0: 41990008  bgt cr6, 0x827fdfb8
	if ctx.cr[6].gt {
	pc = 0x827FDFB8; continue 'dispatch;
	}
	// 827FDFB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827FDFB8; continue 'dispatch;
            }
            0x827FDFB8 => {
    //   block [0x827FDFB8..0x827FDFE0)
	// 827FDFB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDFBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FDFC0: 409A0020  bne cr6, 0x827fdfe0
	if !ctx.cr[6].eq {
	pc = 0x827FDFE0; continue 'dispatch;
	}
	// 827FDFC4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FDFC8: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 827FDFCC: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FDFD0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDFD4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FDFD8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDFDC: 4800001C  b 0x827fdff8
	pc = 0x827FDFF8; continue 'dispatch;
            }
            0x827FDFE0 => {
    //   block [0x827FDFE0..0x827FDFF4)
	// 827FDFE0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FDFE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FDFE8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FDFEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FDFF0: 48000008  b 0x827fdff8
	pc = 0x827FDFF8; continue 'dispatch;
            }
            0x827FDFF4 => {
    //   block [0x827FDFF4..0x827FDFF8)
	// 827FDFF4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827FDFF8; continue 'dispatch;
            }
            0x827FDFF8 => {
    //   block [0x827FDFF8..0x827FE010)
	// 827FDFF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FDFFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE000: 419A0010  beq cr6, 0x827fe010
	if ctx.cr[6].eq {
	pc = 0x827FE010; continue 'dispatch;
	}
	// 827FE004: 809C0004  lwz r4, 4(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE008: 4BFCF179  bl 0x827cd180
	ctx.lr = 0x827FE00C;
	sub_827CD180(ctx, base);
	// 827FE00C: 7FA3EA14  add r29, r3, r29
	ctx.r[29].u64 = ctx.r[3].u64 + ctx.r[29].u64;
	pc = 0x827FE010; continue 'dispatch;
            }
            0x827FE010 => {
    //   block [0x827FE010..0x827FE01C)
	// 827FE010: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827FE014: 7F1ED040  cmplw cr6, r30, r26
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[26].u32, &mut ctx.xer);
	// 827FE018: 409AFED4  bne cr6, 0x827fdeec
	if !ctx.cr[6].eq {
	pc = 0x827FDEEC; continue 'dispatch;
	}
	pc = 0x827FE01C; continue 'dispatch;
            }
            0x827FE01C => {
    //   block [0x827FE01C..0x827FE03C)
	// 827FE01C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 827FE020: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 827FE024: 4BB6C98D  bl 0x8236a9b0
	ctx.lr = 0x827FE028;
	sub_8236A9B0(ctx, base);
	// 827FE028: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 827FE02C: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 827FE030: 419A000C  beq cr6, 0x827fe03c
	if ctx.cr[6].eq {
	pc = 0x827FE03C; continue 'dispatch;
	}
	// 827FE034: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 827FE038: 4BA1DD01  bl 0x8221bd38
	ctx.lr = 0x827FE03C;
	sub_8221BD38(ctx, base);
	pc = 0x827FE03C; continue 'dispatch;
            }
            0x827FE03C => {
    //   block [0x827FE03C..0x827FE04C)
	// 827FE03C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FE040: 4B9C8729  bl 0x821c6768
	ctx.lr = 0x827FE044;
	sub_821C6768(ctx, base);
	// 827FE044: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FE048: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	pc = 0x827FE04C; continue 'dispatch;
            }
            0x827FE04C => {
    //   block [0x827FE04C..0x827FE070)
	// 827FE04C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 827FE050: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FE054: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 827FE058: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 827FE05C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 827FE060: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 827FE064: 4082FFE8  bne 0x827fe04c
	if !ctx.cr[0].eq {
	pc = 0x827FE04C; continue 'dispatch;
	}
	// 827FE068: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827FE06C: 484AB3E4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FE070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FE070 size=976
    let mut pc: u32 = 0x827FE070;
    'dispatch: loop {
        match pc {
            0x827FE070 => {
    //   block [0x827FE070..0x827FE12C)
	// 827FE070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FE074: 484AB38D  bl 0x82ca9400
	ctx.lr = 0x827FE078;
	sub_82CA93D0(ctx, base);
	// 827FE078: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FE07C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 827FE080: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FE084: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE088: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE08C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE090: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE094: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE098: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE09C: 81670024  lwz r11, 0x24(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FE0A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE0A4: 419A0394  beq cr6, 0x827fe438
	if ctx.cr[6].eq {
	pc = 0x827FE438; continue 'dispatch;
	}
	// 827FE0A8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE0AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FE0B0: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FE0B4: 836B00B4  lwz r27, 0xb4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 827FE0B8: 4B9F2189  bl 0x821f0240
	ctx.lr = 0x827FE0BC;
	sub_821F0240(ctx, base);
	// 827FE0BC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FE0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE0C4: 4800133D  bl 0x827ff400
	ctx.lr = 0x827FE0C8;
	sub_827FF400(ctx, base);
	// 827FE0C8: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827FE0CC: 3B9F0024  addi r28, r31, 0x24
	ctx.r[28].s64 = ctx.r[31].s64 + 36;
	// 827FE0D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE0D4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE0D8: 480015F1  bl 0x827ff6c8
	ctx.lr = 0x827FE0DC;
	sub_827FF6C8(ctx, base);
	// 827FE0DC: 48216CB5  bl 0x82a14d90
	ctx.lr = 0x827FE0E0;
	sub_82A14D90(ctx, base);
	// 827FE0E0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE0E4: 4BB22AA5  bl 0x82320b88
	ctx.lr = 0x827FE0E8;
	sub_82320B88(ctx, base);
	// 827FE0E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE0EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827FE0F0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FE0F4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FE0F8: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 827FE0FC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FE100: 419A00E8  beq cr6, 0x827fe1e8
	if ctx.cr[6].eq {
	pc = 0x827FE1E8; continue 'dispatch;
	}
	// 827FE104: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FE108: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE10C: 419A0020  beq cr6, 0x827fe12c
	if ctx.cr[6].eq {
	pc = 0x827FE12C; continue 'dispatch;
	}
	// 827FE110: 894A0045  lbz r10, 0x45(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(69 as u32) ) } as u64;
	// 827FE114: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE118: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827FE11C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827FE120: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE124: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE128: 480000C4  b 0x827fe1ec
	pc = 0x827FE1EC; continue 'dispatch;
            }
            0x827FE12C => {
    //   block [0x827FE12C..0x827FE148)
	// 827FE12C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE130: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FE134: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 827FE138: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FE13C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 827FE140: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE144: 40810054  ble 0x827fe198
	if !ctx.cr[0].gt {
	pc = 0x827FE198; continue 'dispatch;
	}
	pc = 0x827FE148; continue 'dispatch;
            }
            0x827FE148 => {
    //   block [0x827FE148..0x827FE168)
	// 827FE148: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FE14C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FE150: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FE154: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE158: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 827FE15C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FE160: 41980008  blt cr6, 0x827fe168
	if ctx.cr[6].lt {
	pc = 0x827FE168; continue 'dispatch;
	}
	// 827FE164: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x827FE168; continue 'dispatch;
            }
            0x827FE168 => {
    //   block [0x827FE168..0x827FE184)
	// 827FE168: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FE16C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FE170: 419A0014  beq cr6, 0x827fe184
	if ctx.cr[6].eq {
	pc = 0x827FE184; continue 'dispatch;
	}
	// 827FE174: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FE178: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FE17C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FE180: 4800000C  b 0x827fe18c
	pc = 0x827FE18C; continue 'dispatch;
            }
            0x827FE184 => {
    //   block [0x827FE184..0x827FE18C)
	// 827FE184: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FE188: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FE18C; continue 'dispatch;
            }
            0x827FE18C => {
    //   block [0x827FE18C..0x827FE198)
	// 827FE18C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE190: 4199FFB8  bgt cr6, 0x827fe148
	if ctx.cr[6].gt {
	pc = 0x827FE148; continue 'dispatch;
	}
	// 827FE194: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x827FE198; continue 'dispatch;
            }
            0x827FE198 => {
    //   block [0x827FE198..0x827FE1B4)
	// 827FE198: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FE19C: 419A003C  beq cr6, 0x827fe1d8
	if ctx.cr[6].eq {
	pc = 0x827FE1D8; continue 'dispatch;
	}
	// 827FE1A0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE1A4: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 827FE1A8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE1AC: 41990008  bgt cr6, 0x827fe1b4
	if ctx.cr[6].gt {
	pc = 0x827FE1B4; continue 'dispatch;
	}
	// 827FE1B0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE1B4; continue 'dispatch;
            }
            0x827FE1B4 => {
    //   block [0x827FE1B4..0x827FE1D8)
	// 827FE1B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE1B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE1BC: 409A001C  bne cr6, 0x827fe1d8
	if !ctx.cr[6].eq {
	pc = 0x827FE1D8; continue 'dispatch;
	}
	// 827FE1C0: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827FE1C4: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 827FE1C8: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FE1CC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE1D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE1D4: 48000018  b 0x827fe1ec
	pc = 0x827FE1EC; continue 'dispatch;
            }
            0x827FE1D8 => {
    //   block [0x827FE1D8..0x827FE1E8)
	// 827FE1D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FE1DC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE1E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE1E4: 48000008  b 0x827fe1ec
	pc = 0x827FE1EC; continue 'dispatch;
            }
            0x827FE1E8 => {
    //   block [0x827FE1E8..0x827FE1EC)
	// 827FE1E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE1EC; continue 'dispatch;
            }
            0x827FE1EC => {
    //   block [0x827FE1EC..0x827FE204)
	// 827FE1EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE1F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE1F4: 419A0200  beq cr6, 0x827fe3f4
	if ctx.cr[6].eq {
	pc = 0x827FE3F4; continue 'dispatch;
	}
	// 827FE1F8: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 827FE1FC: 3BCA0018  addi r30, r10, 0x18
	ctx.r[30].s64 = ctx.r[10].s64 + 24;
	// 827FE200: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FE204; continue 'dispatch;
            }
            0x827FE204 => {
    //   block [0x827FE204..0x827FE220)
	// 827FE204: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE208: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE20C: 419A01E8  beq cr6, 0x827fe3f4
	if ctx.cr[6].eq {
	pc = 0x827FE3F4; continue 'dispatch;
	}
	// 827FE210: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FE214: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE218: 409A0008  bne cr6, 0x827fe220
	if !ctx.cr[6].eq {
	pc = 0x827FE220; continue 'dispatch;
	}
	// 827FE21C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE220; continue 'dispatch;
            }
            0x827FE220 => {
    //   block [0x827FE220..0x827FE23C)
	// 827FE220: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE224: 8944000C  lbz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE228: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE22C: 419A01B0  beq cr6, 0x827fe3dc
	if ctx.cr[6].eq {
	pc = 0x827FE3DC; continue 'dispatch;
	}
	// 827FE230: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE234: 409A0008  bne cr6, 0x827fe23c
	if !ctx.cr[6].eq {
	pc = 0x827FE23C; continue 'dispatch;
	}
	// 827FE238: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE23C; continue 'dispatch;
            }
            0x827FE23C => {
    //   block [0x827FE23C..0x827FE254)
	// 827FE23C: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FE240: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FE244: 409A0198  bne cr6, 0x827fe3dc
	if !ctx.cr[6].eq {
	pc = 0x827FE3DC; continue 'dispatch;
	}
	// 827FE248: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE24C: 409A0008  bne cr6, 0x827fe254
	if !ctx.cr[6].eq {
	pc = 0x827FE254; continue 'dispatch;
	}
	// 827FE250: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE254; continue 'dispatch;
            }
            0x827FE254 => {
    //   block [0x827FE254..0x827FE288)
	// 827FE254: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE258: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE25C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE260: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE264: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE268: 4BA66221  bl 0x82264488
	ctx.lr = 0x827FE26C;
	sub_82264488(ctx, base);
	// 827FE26C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827FE270: 419A0018  beq cr6, 0x827fe288
	if ctx.cr[6].eq {
	pc = 0x827FE288; continue 'dispatch;
	}
	// 827FE274: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 827FE278: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827FE27C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE280: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE284: 409A0008  bne cr6, 0x827fe28c
	if !ctx.cr[6].eq {
	pc = 0x827FE28C; continue 'dispatch;
	}
	pc = 0x827FE288; continue 'dispatch;
            }
            0x827FE288 => {
    //   block [0x827FE288..0x827FE28C)
	// 827FE288: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE28C; continue 'dispatch;
            }
            0x827FE28C => {
    //   block [0x827FE28C..0x827FE2D4)
	// 827FE28C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE290: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE294: 419A0148  beq cr6, 0x827fe3dc
	if ctx.cr[6].eq {
	pc = 0x827FE3DC; continue 'dispatch;
	}
	// 827FE298: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FE29C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827FE2A0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 827FE2A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FE2A8: 419A00E4  beq cr6, 0x827fe38c
	if ctx.cr[6].eq {
	pc = 0x827FE38C; continue 'dispatch;
	}
	// 827FE2AC: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FE2B0: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE2B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE2B8: 419A001C  beq cr6, 0x827fe2d4
	if ctx.cr[6].eq {
	pc = 0x827FE2D4; continue 'dispatch;
	}
	// 827FE2BC: 896B0043  lbz r11, 0x43(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 827FE2C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827FE2C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827FE2C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE2CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE2D0: 480000C0  b 0x827fe390
	pc = 0x827FE390; continue 'dispatch;
            }
            0x827FE2D4 => {
    //   block [0x827FE2D4..0x827FE2EC)
	// 827FE2D4: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FE2D8: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 827FE2DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FE2E0: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FE2E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE2E8: 40810054  ble 0x827fe33c
	if !ctx.cr[0].gt {
	pc = 0x827FE33C; continue 'dispatch;
	}
	pc = 0x827FE2EC; continue 'dispatch;
            }
            0x827FE2EC => {
    //   block [0x827FE2EC..0x827FE30C)
	// 827FE2EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FE2F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FE2F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FE2F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE2FC: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 827FE300: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FE304: 41980008  blt cr6, 0x827fe30c
	if ctx.cr[6].lt {
	pc = 0x827FE30C; continue 'dispatch;
	}
	// 827FE308: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x827FE30C; continue 'dispatch;
            }
            0x827FE30C => {
    //   block [0x827FE30C..0x827FE328)
	// 827FE30C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FE310: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FE314: 419A0014  beq cr6, 0x827fe328
	if ctx.cr[6].eq {
	pc = 0x827FE328; continue 'dispatch;
	}
	// 827FE318: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FE31C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FE320: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FE324: 4800000C  b 0x827fe330
	pc = 0x827FE330; continue 'dispatch;
            }
            0x827FE328 => {
    //   block [0x827FE328..0x827FE330)
	// 827FE328: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FE32C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FE330; continue 'dispatch;
            }
            0x827FE330 => {
    //   block [0x827FE330..0x827FE33C)
	// 827FE330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE334: 4199FFB8  bgt cr6, 0x827fe2ec
	if ctx.cr[6].gt {
	pc = 0x827FE2EC; continue 'dispatch;
	}
	// 827FE338: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x827FE33C; continue 'dispatch;
            }
            0x827FE33C => {
    //   block [0x827FE33C..0x827FE358)
	// 827FE33C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FE340: 419A003C  beq cr6, 0x827fe37c
	if ctx.cr[6].eq {
	pc = 0x827FE37C; continue 'dispatch;
	}
	// 827FE344: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE348: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 827FE34C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE350: 41990008  bgt cr6, 0x827fe358
	if ctx.cr[6].gt {
	pc = 0x827FE358; continue 'dispatch;
	}
	// 827FE354: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE358; continue 'dispatch;
            }
            0x827FE358 => {
    //   block [0x827FE358..0x827FE37C)
	// 827FE358: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE35C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE360: 409A001C  bne cr6, 0x827fe37c
	if !ctx.cr[6].eq {
	pc = 0x827FE37C; continue 'dispatch;
	}
	// 827FE364: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FE368: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE36C: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 827FE370: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FE374: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE378: 48000018  b 0x827fe390
	pc = 0x827FE390; continue 'dispatch;
            }
            0x827FE37C => {
    //   block [0x827FE37C..0x827FE38C)
	// 827FE37C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FE380: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE384: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE388: 48000008  b 0x827fe390
	pc = 0x827FE390; continue 'dispatch;
            }
            0x827FE38C => {
    //   block [0x827FE38C..0x827FE390)
	// 827FE38C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x827FE390; continue 'dispatch;
            }
            0x827FE390 => {
    //   block [0x827FE390..0x827FE3DC)
	// 827FE390: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827FE394: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE398: 419A0044  beq cr6, 0x827fe3dc
	if ctx.cr[6].eq {
	pc = 0x827FE3DC; continue 'dispatch;
	}
	// 827FE39C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827FE3A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FE3A4: 4802CAB5  bl 0x8282ae58
	ctx.lr = 0x827FE3A8;
	sub_8282AE58(ctx, base);
	// 827FE3A8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FE3AC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FE3B0: 4B9C3A11  bl 0x821c1dc0
	ctx.lr = 0x827FE3B4;
	sub_821C1DC0(ctx, base);
	// 827FE3B4: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FE3B8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 827FE3BC: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FE3C0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE3C4: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FE3C8: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827FE3CC: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827FE3D0: 48298F99  bl 0x82a97368
	ctx.lr = 0x827FE3D4;
	sub_82A97368(ctx, base);
	// 827FE3D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FE3D8: 4BA16A01  bl 0x82214dd8
	ctx.lr = 0x827FE3DC;
	sub_82214DD8(ctx, base);
	pc = 0x827FE3DC; continue 'dispatch;
            }
            0x827FE3DC => {
    //   block [0x827FE3DC..0x827FE3EC)
	// 827FE3DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE3E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE3E4: 409A0008  bne cr6, 0x827fe3ec
	if !ctx.cr[6].eq {
	pc = 0x827FE3EC; continue 'dispatch;
	}
	// 827FE3E8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE3EC; continue 'dispatch;
            }
            0x827FE3EC => {
    //   block [0x827FE3EC..0x827FE3F4)
	// 827FE3EC: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE3F0: 4BFFFE14  b 0x827fe204
	pc = 0x827FE204; continue 'dispatch;
            }
            0x827FE3F4 => {
    //   block [0x827FE3F4..0x827FE438)
	// 827FE3F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE3F8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE3FC: 480012CD  bl 0x827ff6c8
	ctx.lr = 0x827FE400;
	sub_827FF6C8(ctx, base);
	// 827FE400: 48216991  bl 0x82a14d90
	ctx.lr = 0x827FE404;
	sub_82A14D90(ctx, base);
	// 827FE404: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE408: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE40C: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 827FE410: 480012B9  bl 0x827ff6c8
	ctx.lr = 0x827FE414;
	sub_827FF6C8(ctx, base);
	// 827FE414: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FE418: 4BC52A61  bl 0x82450e78
	ctx.lr = 0x827FE41C;
	sub_82450E78(ctx, base);
	// 827FE41C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE420: 48216971  bl 0x82a14d90
	ctx.lr = 0x827FE424;
	sub_82A14D90(ctx, base);
	// 827FE424: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FE428: 4BA1D911  bl 0x8221bd38
	ctx.lr = 0x827FE42C;
	sub_8221BD38(ctx, base);
	// 827FE42C: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 827FE430: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FE434: 4BA169A5  bl 0x82214dd8
	ctx.lr = 0x827FE438;
	sub_82214DD8(ctx, base);
	pc = 0x827FE438; continue 'dispatch;
            }
            0x827FE438 => {
    //   block [0x827FE438..0x827FE440)
	// 827FE438: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827FE43C: 484AB014  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FE440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FE440 size=944
    let mut pc: u32 = 0x827FE440;
    'dispatch: loop {
        match pc {
            0x827FE440 => {
    //   block [0x827FE440..0x827FE4FC)
	// 827FE440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FE444: 484AAFBD  bl 0x82ca9400
	ctx.lr = 0x827FE448;
	sub_82CA93D0(ctx, base);
	// 827FE448: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FE44C: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 827FE450: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FE454: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE458: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE45C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE460: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE464: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE468: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE46C: 81670024  lwz r11, 0x24(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FE470: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE474: 419A0374  beq cr6, 0x827fe7e8
	if ctx.cr[6].eq {
	pc = 0x827FE7E8; continue 'dispatch;
	}
	// 827FE478: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE47C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FE480: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FE484: 836B00B4  lwz r27, 0xb4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(180 as u32) ) } as u64;
	// 827FE488: 4B9F1DB9  bl 0x821f0240
	ctx.lr = 0x827FE48C;
	sub_821F0240(ctx, base);
	// 827FE48C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FE490: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE494: 48000F6D  bl 0x827ff400
	ctx.lr = 0x827FE498;
	sub_827FF400(ctx, base);
	// 827FE498: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 827FE49C: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 827FE4A0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE4A4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE4A8: 48001221  bl 0x827ff6c8
	ctx.lr = 0x827FE4AC;
	sub_827FF6C8(ctx, base);
	// 827FE4AC: 482168E5  bl 0x82a14d90
	ctx.lr = 0x827FE4B0;
	sub_82A14D90(ctx, base);
	// 827FE4B0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE4B4: 4BB226D5  bl 0x82320b88
	ctx.lr = 0x827FE4B8;
	sub_82320B88(ctx, base);
	// 827FE4B8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE4BC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 827FE4C0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 827FE4C4: 812B002C  lwz r9, 0x2c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FE4C8: 5528DFFE  rlwinm r8, r9, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 827FE4CC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FE4D0: 419A00E8  beq cr6, 0x827fe5b8
	if ctx.cr[6].eq {
	pc = 0x827FE5B8; continue 'dispatch;
	}
	// 827FE4D4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FE4D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE4DC: 419A0020  beq cr6, 0x827fe4fc
	if ctx.cr[6].eq {
	pc = 0x827FE4FC; continue 'dispatch;
	}
	// 827FE4E0: 894A0045  lbz r10, 0x45(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(69 as u32) ) } as u64;
	// 827FE4E4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE4E8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 827FE4EC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 827FE4F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE4F4: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE4F8: 480000C4  b 0x827fe5bc
	pc = 0x827FE5BC; continue 'dispatch;
            }
            0x827FE4FC => {
    //   block [0x827FE4FC..0x827FE518)
	// 827FE4FC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE500: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FE504: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 827FE508: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FE50C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 827FE510: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE514: 40810054  ble 0x827fe568
	if !ctx.cr[0].gt {
	pc = 0x827FE568; continue 'dispatch;
	}
	pc = 0x827FE518; continue 'dispatch;
            }
            0x827FE518 => {
    //   block [0x827FE518..0x827FE538)
	// 827FE518: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FE51C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FE520: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FE524: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE528: 2F070045  cmpwi cr6, r7, 0x45
	ctx.cr[6].compare_i32(ctx.r[7].s32, 69, &mut ctx.xer);
	// 827FE52C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FE530: 41980008  blt cr6, 0x827fe538
	if ctx.cr[6].lt {
	pc = 0x827FE538; continue 'dispatch;
	}
	// 827FE534: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x827FE538; continue 'dispatch;
            }
            0x827FE538 => {
    //   block [0x827FE538..0x827FE554)
	// 827FE538: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FE53C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FE540: 419A0014  beq cr6, 0x827fe554
	if ctx.cr[6].eq {
	pc = 0x827FE554; continue 'dispatch;
	}
	// 827FE544: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FE548: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FE54C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FE550: 4800000C  b 0x827fe55c
	pc = 0x827FE55C; continue 'dispatch;
            }
            0x827FE554 => {
    //   block [0x827FE554..0x827FE55C)
	// 827FE554: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FE558: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FE55C; continue 'dispatch;
            }
            0x827FE55C => {
    //   block [0x827FE55C..0x827FE568)
	// 827FE55C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE560: 4199FFB8  bgt cr6, 0x827fe518
	if ctx.cr[6].gt {
	pc = 0x827FE518; continue 'dispatch;
	}
	// 827FE564: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	pc = 0x827FE568; continue 'dispatch;
            }
            0x827FE568 => {
    //   block [0x827FE568..0x827FE584)
	// 827FE568: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FE56C: 419A003C  beq cr6, 0x827fe5a8
	if ctx.cr[6].eq {
	pc = 0x827FE5A8; continue 'dispatch;
	}
	// 827FE570: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE574: 2F0B0045  cmpwi cr6, r11, 0x45
	ctx.cr[6].compare_i32(ctx.r[11].s32, 69, &mut ctx.xer);
	// 827FE578: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE57C: 41990008  bgt cr6, 0x827fe584
	if ctx.cr[6].gt {
	pc = 0x827FE584; continue 'dispatch;
	}
	// 827FE580: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE584; continue 'dispatch;
            }
            0x827FE584 => {
    //   block [0x827FE584..0x827FE5A8)
	// 827FE584: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE58C: 409A001C  bne cr6, 0x827fe5a8
	if !ctx.cr[6].eq {
	pc = 0x827FE5A8; continue 'dispatch;
	}
	// 827FE590: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 827FE594: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 827FE598: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 827FE59C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE5A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE5A4: 48000018  b 0x827fe5bc
	pc = 0x827FE5BC; continue 'dispatch;
            }
            0x827FE5A8 => {
    //   block [0x827FE5A8..0x827FE5B8)
	// 827FE5A8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FE5AC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE5B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE5B4: 48000008  b 0x827fe5bc
	pc = 0x827FE5BC; continue 'dispatch;
            }
            0x827FE5B8 => {
    //   block [0x827FE5B8..0x827FE5BC)
	// 827FE5B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE5BC; continue 'dispatch;
            }
            0x827FE5BC => {
    //   block [0x827FE5BC..0x827FE5E0)
	// 827FE5BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE5C4: 419A01E0  beq cr6, 0x827fe7a4
	if ctx.cr[6].eq {
	pc = 0x827FE7A4; continue 'dispatch;
	}
	// 827FE5C8: 816A0020  lwz r11, 0x20(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 827FE5CC: 3BCA0018  addi r30, r10, 0x18
	ctx.r[30].s64 = ctx.r[10].s64 + 24;
	// 827FE5D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE5D4: 419A01D0  beq cr6, 0x827fe7a4
	if ctx.cr[6].eq {
	pc = 0x827FE7A4; continue 'dispatch;
	}
	// 827FE5D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE5DC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FE5E0; continue 'dispatch;
            }
            0x827FE5E0 => {
    //   block [0x827FE5E0..0x827FE604)
	// 827FE5E0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE5E4: 419A01C0  beq cr6, 0x827fe7a4
	if ctx.cr[6].eq {
	pc = 0x827FE7A4; continue 'dispatch;
	}
	// 827FE5E8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE5EC: 81440014  lwz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FE5F0: 7F0AD840  cmplw cr6, r10, r27
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FE5F4: 409A0198  bne cr6, 0x827fe78c
	if !ctx.cr[6].eq {
	pc = 0x827FE78C; continue 'dispatch;
	}
	// 827FE5F8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE5FC: 409A0008  bne cr6, 0x827fe604
	if !ctx.cr[6].eq {
	pc = 0x827FE604; continue 'dispatch;
	}
	// 827FE600: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE604; continue 'dispatch;
            }
            0x827FE604 => {
    //   block [0x827FE604..0x827FE638)
	// 827FE604: 817A6AB8  lwz r11, 0x6ab8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE608: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE60C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE610: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE614: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE618: 4BA65E71  bl 0x82264488
	ctx.lr = 0x827FE61C;
	sub_82264488(ctx, base);
	// 827FE61C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 827FE620: 419A0018  beq cr6, 0x827fe638
	if ctx.cr[6].eq {
	pc = 0x827FE638; continue 'dispatch;
	}
	// 827FE624: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 827FE628: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 827FE62C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE630: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE634: 409A0008  bne cr6, 0x827fe63c
	if !ctx.cr[6].eq {
	pc = 0x827FE63C; continue 'dispatch;
	}
	pc = 0x827FE638; continue 'dispatch;
            }
            0x827FE638 => {
    //   block [0x827FE638..0x827FE63C)
	// 827FE638: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE63C; continue 'dispatch;
            }
            0x827FE63C => {
    //   block [0x827FE63C..0x827FE684)
	// 827FE63C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE640: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE644: 419A0148  beq cr6, 0x827fe78c
	if ctx.cr[6].eq {
	pc = 0x827FE78C; continue 'dispatch;
	}
	// 827FE648: 8143002C  lwz r10, 0x2c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 827FE64C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 827FE650: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 827FE654: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FE658: 419A00E4  beq cr6, 0x827fe73c
	if ctx.cr[6].eq {
	pc = 0x827FE73C; continue 'dispatch;
	}
	// 827FE65C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FE660: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FE664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE668: 419A001C  beq cr6, 0x827fe684
	if ctx.cr[6].eq {
	pc = 0x827FE684; continue 'dispatch;
	}
	// 827FE66C: 896B0043  lbz r11, 0x43(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(67 as u32) ) } as u64;
	// 827FE670: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 827FE674: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827FE678: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE67C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE680: 480000C0  b 0x827fe740
	pc = 0x827FE740; continue 'dispatch;
            }
            0x827FE684 => {
    //   block [0x827FE684..0x827FE69C)
	// 827FE684: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FE688: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 827FE68C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FE690: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 827FE694: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE698: 40810054  ble 0x827fe6ec
	if !ctx.cr[0].gt {
	pc = 0x827FE6EC; continue 'dispatch;
	}
	pc = 0x827FE69C; continue 'dispatch;
            }
            0x827FE69C => {
    //   block [0x827FE69C..0x827FE6BC)
	// 827FE69C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FE6A0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FE6A4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FE6A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE6AC: 2F070043  cmpwi cr6, r7, 0x43
	ctx.cr[6].compare_i32(ctx.r[7].s32, 67, &mut ctx.xer);
	// 827FE6B0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FE6B4: 41980008  blt cr6, 0x827fe6bc
	if ctx.cr[6].lt {
	pc = 0x827FE6BC; continue 'dispatch;
	}
	// 827FE6B8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x827FE6BC; continue 'dispatch;
            }
            0x827FE6BC => {
    //   block [0x827FE6BC..0x827FE6D8)
	// 827FE6BC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FE6C0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FE6C4: 419A0014  beq cr6, 0x827fe6d8
	if ctx.cr[6].eq {
	pc = 0x827FE6D8; continue 'dispatch;
	}
	// 827FE6C8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FE6CC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FE6D0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FE6D4: 4800000C  b 0x827fe6e0
	pc = 0x827FE6E0; continue 'dispatch;
            }
            0x827FE6D8 => {
    //   block [0x827FE6D8..0x827FE6E0)
	// 827FE6D8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FE6DC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FE6E0; continue 'dispatch;
            }
            0x827FE6E0 => {
    //   block [0x827FE6E0..0x827FE6EC)
	// 827FE6E0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE6E4: 4199FFB8  bgt cr6, 0x827fe69c
	if ctx.cr[6].gt {
	pc = 0x827FE69C; continue 'dispatch;
	}
	// 827FE6E8: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	pc = 0x827FE6EC; continue 'dispatch;
            }
            0x827FE6EC => {
    //   block [0x827FE6EC..0x827FE708)
	// 827FE6EC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FE6F0: 419A003C  beq cr6, 0x827fe72c
	if ctx.cr[6].eq {
	pc = 0x827FE72C; continue 'dispatch;
	}
	// 827FE6F4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE6F8: 2F0B0043  cmpwi cr6, r11, 0x43
	ctx.cr[6].compare_i32(ctx.r[11].s32, 67, &mut ctx.xer);
	// 827FE6FC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FE700: 41990008  bgt cr6, 0x827fe708
	if ctx.cr[6].gt {
	pc = 0x827FE708; continue 'dispatch;
	}
	// 827FE704: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x827FE708; continue 'dispatch;
            }
            0x827FE708 => {
    //   block [0x827FE708..0x827FE72C)
	// 827FE708: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FE70C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE710: 409A001C  bne cr6, 0x827fe72c
	if !ctx.cr[6].eq {
	pc = 0x827FE72C; continue 'dispatch;
	}
	// 827FE714: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 827FE718: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE71C: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 827FE720: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 827FE724: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE728: 48000018  b 0x827fe740
	pc = 0x827FE740; continue 'dispatch;
            }
            0x827FE72C => {
    //   block [0x827FE72C..0x827FE73C)
	// 827FE72C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FE730: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FE734: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE738: 48000008  b 0x827fe740
	pc = 0x827FE740; continue 'dispatch;
            }
            0x827FE73C => {
    //   block [0x827FE73C..0x827FE740)
	// 827FE73C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x827FE740; continue 'dispatch;
            }
            0x827FE740 => {
    //   block [0x827FE740..0x827FE78C)
	// 827FE740: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827FE744: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FE748: 419A0044  beq cr6, 0x827fe78c
	if ctx.cr[6].eq {
	pc = 0x827FE78C; continue 'dispatch;
	}
	// 827FE74C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 827FE750: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FE754: 4802C705  bl 0x8282ae58
	ctx.lr = 0x827FE758;
	sub_8282AE58(ctx, base);
	// 827FE758: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FE75C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FE760: 4B9C3661  bl 0x821c1dc0
	ctx.lr = 0x827FE764;
	sub_821C1DC0(ctx, base);
	// 827FE764: 81410084  lwz r10, 0x84(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FE768: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 827FE76C: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 827FE770: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE774: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FE778: 91410074  stw r10, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 827FE77C: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 827FE780: 48298BE9  bl 0x82a97368
	ctx.lr = 0x827FE784;
	sub_82A97368(ctx, base);
	// 827FE784: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FE788: 4BA16651  bl 0x82214dd8
	ctx.lr = 0x827FE78C;
	sub_82214DD8(ctx, base);
	pc = 0x827FE78C; continue 'dispatch;
            }
            0x827FE78C => {
    //   block [0x827FE78C..0x827FE79C)
	// 827FE78C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE790: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FE794: 409A0008  bne cr6, 0x827fe79c
	if !ctx.cr[6].eq {
	pc = 0x827FE79C; continue 'dispatch;
	}
	// 827FE798: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE79C; continue 'dispatch;
            }
            0x827FE79C => {
    //   block [0x827FE79C..0x827FE7A4)
	// 827FE79C: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE7A0: 4BFFFE40  b 0x827fe5e0
	pc = 0x827FE5E0; continue 'dispatch;
            }
            0x827FE7A4 => {
    //   block [0x827FE7A4..0x827FE7E8)
	// 827FE7A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE7A8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE7AC: 48000F1D  bl 0x827ff6c8
	ctx.lr = 0x827FE7B0;
	sub_827FF6C8(ctx, base);
	// 827FE7B0: 482165E1  bl 0x82a14d90
	ctx.lr = 0x827FE7B4;
	sub_82A14D90(ctx, base);
	// 827FE7B4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE7B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FE7BC: 3BE10080  addi r31, r1, 0x80
	ctx.r[31].s64 = ctx.r[1].s64 + 128;
	// 827FE7C0: 48000F09  bl 0x827ff6c8
	ctx.lr = 0x827FE7C4;
	sub_827FF6C8(ctx, base);
	// 827FE7C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FE7C8: 4BC526B1  bl 0x82450e78
	ctx.lr = 0x827FE7CC;
	sub_82450E78(ctx, base);
	// 827FE7CC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 827FE7D0: 482165C1  bl 0x82a14d90
	ctx.lr = 0x827FE7D4;
	sub_82A14D90(ctx, base);
	// 827FE7D4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 827FE7D8: 4BA1D561  bl 0x8221bd38
	ctx.lr = 0x827FE7DC;
	sub_8221BD38(ctx, base);
	// 827FE7DC: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 827FE7E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FE7E4: 4BA165F5  bl 0x82214dd8
	ctx.lr = 0x827FE7E8;
	sub_82214DD8(ctx, base);
	pc = 0x827FE7E8; continue 'dispatch;
            }
            0x827FE7E8 => {
    //   block [0x827FE7E8..0x827FE7F0)
	// 827FE7E8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827FE7EC: 484AAC64  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FE7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FE7F0 size=340
    let mut pc: u32 = 0x827FE7F0;
    'dispatch: loop {
        match pc {
            0x827FE7F0 => {
    //   block [0x827FE7F0..0x827FE8D8)
	// 827FE7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FE7F4: 484AAC0D  bl 0x82ca9400
	ctx.lr = 0x827FE7F8;
	sub_82CA93D0(ctx, base);
	// 827FE7F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FE7FC: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 827FE800: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FE804: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE808: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE80C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE810: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE814: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE818: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE81C: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FE820: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE824: 3BCB00AC  addi r30, r11, 0xac
	ctx.r[30].s64 = ctx.r[11].s64 + 172;
	// 827FE828: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FE82C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE830: 419A010C  beq cr6, 0x827fe93c
	if ctx.cr[6].eq {
	pc = 0x827FE93C; continue 'dispatch;
	}
	// 827FE834: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE838: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE83C: 419A0100  beq cr6, 0x827fe93c
	if ctx.cr[6].eq {
	pc = 0x827FE93C; continue 'dispatch;
	}
	// 827FE840: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FE844: 48000BBD  bl 0x827ff400
	ctx.lr = 0x827FE848;
	sub_827FF400(ctx, base);
	// 827FE848: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FE84C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FE850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE854: 48000ABD  bl 0x827ff310
	ctx.lr = 0x827FE858;
	sub_827FF310(ctx, base);
	// 827FE858: 815D6AB8  lwz r10, 0x6ab8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE85C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FE860: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 827FE864: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827FE868: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FE86C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FE870: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FE874: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827FE878: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 827FE87C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FE880: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FE884: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE888: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827FE88C: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE890: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE894: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE898: 48003161  bl 0x828019f8
	ctx.lr = 0x827FE89C;
	sub_828019F8(ctx, base);
	// 827FE89C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FE8A0: 3BFF003C  addi r31, r31, 0x3c
	ctx.r[31].s64 = ctx.r[31].s64 + 60;
	// 827FE8A4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FE8A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FE8AC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FE8B0: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FE8B4: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE8B8: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 827FE8BC: 7D5E1670  srawi r30, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 827FE8C0: 4BB76939  bl 0x823751f8
	ctx.lr = 0x827FE8C4;
	sub_823751F8(ctx, base);
	// 827FE8C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FE8C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE8CC: 419A000C  beq cr6, 0x827fe8d8
	if ctx.cr[6].eq {
	pc = 0x827FE8D8; continue 'dispatch;
	}
	// 827FE8D0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FE8D4: 419A0008  beq cr6, 0x827fe8dc
	if ctx.cr[6].eq {
	pc = 0x827FE8DC; continue 'dispatch;
	}
	pc = 0x827FE8D8; continue 'dispatch;
            }
            0x827FE8D8 => {
    //   block [0x827FE8D8..0x827FE8DC)
	// 827FE8D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FE8DC; continue 'dispatch;
            }
            0x827FE8DC => {
    //   block [0x827FE8DC..0x827FE914)
	// 827FE8DC: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE8E0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FE8E4: 409A0030  bne cr6, 0x827fe914
	if !ctx.cr[6].eq {
	pc = 0x827FE914; continue 'dispatch;
	}
	// 827FE8E8: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 827FE8EC: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FE8F0: 48219631  bl 0x82a17f20
	ctx.lr = 0x827FE8F4;
	sub_82A17F20(ctx, base);
	// 827FE8F4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE8F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE8FC: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 827FE900: 48001059  bl 0x827ff958
	ctx.lr = 0x827FE904;
	sub_827FF958(ctx, base);
	// 827FE904: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FE908: 4BFFCA59  bl 0x827fb360
	ctx.lr = 0x827FE90C;
	sub_827FB360(ctx, base);
	// 827FE90C: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FE910: 4BEDB149  bl 0x826d9a58
	ctx.lr = 0x827FE914;
	sub_826D9A58(ctx, base);
	pc = 0x827FE914; continue 'dispatch;
            }
            0x827FE914 => {
    //   block [0x827FE914..0x827FE93C)
	// 827FE914: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FE918: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE91C: 4800103D  bl 0x827ff958
	ctx.lr = 0x827FE920;
	sub_827FF958(ctx, base);
	// 827FE920: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827FE924: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FE928: 4BFFBE41  bl 0x827fa768
	ctx.lr = 0x827FE92C;
	sub_827FA768(ctx, base);
	// 827FE92C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827FE930: 419A000C  beq cr6, 0x827fe93c
	if ctx.cr[6].eq {
	pc = 0x827FE93C; continue 'dispatch;
	}
	// 827FE934: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FE938: 4BA1D401  bl 0x8221bd38
	ctx.lr = 0x827FE93C;
	sub_8221BD38(ctx, base);
	pc = 0x827FE93C; continue 'dispatch;
            }
            0x827FE93C => {
    //   block [0x827FE93C..0x827FE944)
	// 827FE93C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827FE940: 484AAB10  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FE948(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FE948 size=340
    let mut pc: u32 = 0x827FE948;
    'dispatch: loop {
        match pc {
            0x827FE948 => {
    //   block [0x827FE948..0x827FEA30)
	// 827FE948: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FE94C: 484AAAB5  bl 0x82ca9400
	ctx.lr = 0x827FE950;
	sub_82CA93D0(ctx, base);
	// 827FE950: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FE954: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 827FE958: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FE95C: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE960: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE964: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE968: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE96C: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FE970: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE974: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FE978: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE97C: 3BCB00AC  addi r30, r11, 0xac
	ctx.r[30].s64 = ctx.r[11].s64 + 172;
	// 827FE980: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FE984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FE988: 419A010C  beq cr6, 0x827fea94
	if ctx.cr[6].eq {
	pc = 0x827FEA94; continue 'dispatch;
	}
	// 827FE98C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE990: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FE994: 419A0100  beq cr6, 0x827fea94
	if ctx.cr[6].eq {
	pc = 0x827FEA94; continue 'dispatch;
	}
	// 827FE998: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FE99C: 48000A65  bl 0x827ff400
	ctx.lr = 0x827FE9A0;
	sub_827FF400(ctx, base);
	// 827FE9A0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FE9A4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FE9A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FE9AC: 48000965  bl 0x827ff310
	ctx.lr = 0x827FE9B0;
	sub_827FF310(ctx, base);
	// 827FE9B0: 815D6AB8  lwz r10, 0x6ab8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FE9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FE9B8: 3920005F  li r9, 0x5f
	ctx.r[9].s64 = 95;
	// 827FE9BC: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827FE9C0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FE9C4: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FE9C8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FE9CC: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827FE9D0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 827FE9D4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FE9D8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FE9DC: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE9E0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827FE9E4: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FE9E8: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FE9EC: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FE9F0: 48003009  bl 0x828019f8
	ctx.lr = 0x827FE9F4;
	sub_828019F8(ctx, base);
	// 827FE9F4: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FE9F8: 3BFF0054  addi r31, r31, 0x54
	ctx.r[31].s64 = ctx.r[31].s64 + 84;
	// 827FE9FC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FEA00: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FEA04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEA08: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FEA0C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEA10: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 827FEA14: 7D5E1670  srawi r30, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 827FEA18: 4BB767E1  bl 0x823751f8
	ctx.lr = 0x827FEA1C;
	sub_823751F8(ctx, base);
	// 827FEA1C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEA20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEA24: 419A000C  beq cr6, 0x827fea30
	if ctx.cr[6].eq {
	pc = 0x827FEA30; continue 'dispatch;
	}
	// 827FEA28: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FEA2C: 419A0008  beq cr6, 0x827fea34
	if ctx.cr[6].eq {
	pc = 0x827FEA34; continue 'dispatch;
	}
	pc = 0x827FEA30; continue 'dispatch;
            }
            0x827FEA30 => {
    //   block [0x827FEA30..0x827FEA34)
	// 827FEA30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FEA34; continue 'dispatch;
            }
            0x827FEA34 => {
    //   block [0x827FEA34..0x827FEA6C)
	// 827FEA34: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEA38: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FEA3C: 409A0030  bne cr6, 0x827fea6c
	if !ctx.cr[6].eq {
	pc = 0x827FEA6C; continue 'dispatch;
	}
	// 827FEA40: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 827FEA44: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FEA48: 482194D9  bl 0x82a17f20
	ctx.lr = 0x827FEA4C;
	sub_82A17F20(ctx, base);
	// 827FEA4C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FEA50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEA54: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 827FEA58: 48000F01  bl 0x827ff958
	ctx.lr = 0x827FEA5C;
	sub_827FF958(ctx, base);
	// 827FEA5C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FEA60: 4BFFC901  bl 0x827fb360
	ctx.lr = 0x827FEA64;
	sub_827FB360(ctx, base);
	// 827FEA64: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FEA68: 4BEDAFF1  bl 0x826d9a58
	ctx.lr = 0x827FEA6C;
	sub_826D9A58(ctx, base);
	pc = 0x827FEA6C; continue 'dispatch;
            }
            0x827FEA6C => {
    //   block [0x827FEA6C..0x827FEA94)
	// 827FEA6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FEA70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEA74: 48000EE5  bl 0x827ff958
	ctx.lr = 0x827FEA78;
	sub_827FF958(ctx, base);
	// 827FEA78: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827FEA7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FEA80: 4BFFBCE9  bl 0x827fa768
	ctx.lr = 0x827FEA84;
	sub_827FA768(ctx, base);
	// 827FEA84: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827FEA88: 419A000C  beq cr6, 0x827fea94
	if ctx.cr[6].eq {
	pc = 0x827FEA94; continue 'dispatch;
	}
	// 827FEA8C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FEA90: 4BA1D2A9  bl 0x8221bd38
	ctx.lr = 0x827FEA94;
	sub_8221BD38(ctx, base);
	pc = 0x827FEA94; continue 'dispatch;
            }
            0x827FEA94 => {
    //   block [0x827FEA94..0x827FEA9C)
	// 827FEA94: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827FEA98: 484AA9B8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FEAA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FEAA0 size=712
    let mut pc: u32 = 0x827FEAA0;
    'dispatch: loop {
        match pc {
            0x827FEAA0 => {
    //   block [0x827FEAA0..0x827FEB6C)
	// 827FEAA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FEAA4: 484AA955  bl 0x82ca93f8
	ctx.lr = 0x827FEAA8;
	sub_82CA93D0(ctx, base);
	// 827FEAA8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FEAAC: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 827FEAB0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FEAB4: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FEAB8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FEABC: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FEAC0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEAC4: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FEAC8: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEACC: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FEAD0: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEAD4: 3BEB00AC  addi r31, r11, 0xac
	ctx.r[31].s64 = ctx.r[11].s64 + 172;
	// 827FEAD8: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FEADC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEAE0: 419A0280  beq cr6, 0x827fed60
	if ctx.cr[6].eq {
	pc = 0x827FED60; continue 'dispatch;
	}
	// 827FEAE4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEAE8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEAEC: 419A0274  beq cr6, 0x827fed60
	if ctx.cr[6].eq {
	pc = 0x827FED60; continue 'dispatch;
	}
	// 827FEAF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEAF4: 4800090D  bl 0x827ff400
	ctx.lr = 0x827FEAF8;
	sub_827FF400(ctx, base);
	// 827FEAF8: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 827FEAFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEB00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827FEB04: 4800080D  bl 0x827ff310
	ctx.lr = 0x827FEB08;
	sub_827FF310(ctx, base);
	// 827FEB08: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FEB0C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827FEB10: 394000C0  li r10, 0xc0
	ctx.r[10].s64 = 192;
	// 827FEB14: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 827FEB18: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 827FEB1C: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 827FEB20: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FEB24: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 827FEB28: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 827FEB2C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 827FEB30: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FEB34: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FEB38: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 827FEB3C: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FEB40: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEB44: 8067000C  lwz r3, 0xc(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FEB48: 48002EB1  bl 0x828019f8
	ctx.lr = 0x827FEB4C;
	sub_828019F8(ctx, base);
	// 827FEB4C: 80C10068  lwz r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FEB50: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 827FEB54: 83010064  lwz r24, 0x64(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FEB58: 7CB83050  subf r5, r24, r6
	ctx.r[5].s64 = ctx.r[6].s64 - ctx.r[24].s64;
	// 827FEB5C: 7CAB1671  srawi. r11, r5, 2
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[5].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEB60: 41820170  beq 0x827fecd0
	if ctx.cr[0].eq {
	pc = 0x827FECD0; continue 'dispatch;
	}
	// 827FEB64: 7F1EC378  mr r30, r24
	ctx.r[30].u64 = ctx.r[24].u64;
	// 827FEB68: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	pc = 0x827FEB6C; continue 'dispatch;
            }
            0x827FEB6C => {
    //   block [0x827FEB6C..0x827FEB8C)
	// 827FEB6C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEB70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEB74: 419A0018  beq cr6, 0x827feb8c
	if ctx.cr[6].eq {
	pc = 0x827FEB8C; continue 'dispatch;
	}
	// 827FEB78: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 827FEB7C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 827FEB80: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 827FEB84: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FEB88: 409A0008  bne cr6, 0x827feb90
	if !ctx.cr[6].eq {
	pc = 0x827FEB90; continue 'dispatch;
	}
	pc = 0x827FEB8C; continue 'dispatch;
            }
            0x827FEB8C => {
    //   block [0x827FEB8C..0x827FEB90)
	// 827FEB8C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x827FEB90; continue 'dispatch;
            }
            0x827FEB90 => {
    //   block [0x827FEB90..0x827FEBDC)
	// 827FEB90: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 827FEB94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FEB98: 419A012C  beq cr6, 0x827fecc4
	if ctx.cr[6].eq {
	pc = 0x827FECC4; continue 'dispatch;
	}
	// 827FEB9C: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 827FEBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEBA4: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 827FEBA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FEBAC: 419A00F4  beq cr6, 0x827feca0
	if ctx.cr[6].eq {
	pc = 0x827FECA0; continue 'dispatch;
	}
	// 827FEBB0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FEBB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FEBB8: 419A0024  beq cr6, 0x827febdc
	if ctx.cr[6].eq {
	pc = 0x827FEBDC; continue 'dispatch;
	}
	// 827FEBBC: 892A00C0  lbz r9, 0xc0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) } as u64;
	// 827FEBC0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FEBC4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 827FEBC8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 827FEBCC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEBD0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FEBD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FEBD8: 480000CC  b 0x827feca4
	pc = 0x827FECA4; continue 'dispatch;
            }
            0x827FEBDC => {
    //   block [0x827FEBDC..0x827FEBF8)
	// 827FEBDC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 827FEBE0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 827FEBE4: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827FEBE8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 827FEBEC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FEBF0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEBF4: 40810054  ble 0x827fec48
	if !ctx.cr[0].gt {
	pc = 0x827FEC48; continue 'dispatch;
	}
	pc = 0x827FEBF8; continue 'dispatch;
            }
            0x827FEBF8 => {
    //   block [0x827FEBF8..0x827FEC18)
	// 827FEBF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 827FEBFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 827FEC00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 827FEC04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEC08: 2F0700C0  cmpwi cr6, r7, 0xc0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 192, &mut ctx.xer);
	// 827FEC0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 827FEC10: 41980008  blt cr6, 0x827fec18
	if ctx.cr[6].lt {
	pc = 0x827FEC18; continue 'dispatch;
	}
	// 827FEC14: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x827FEC18; continue 'dispatch;
            }
            0x827FEC18 => {
    //   block [0x827FEC18..0x827FEC34)
	// 827FEC18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 827FEC1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FEC20: 419A0014  beq cr6, 0x827fec34
	if ctx.cr[6].eq {
	pc = 0x827FEC34; continue 'dispatch;
	}
	// 827FEC24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 827FEC28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 827FEC2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 827FEC30: 4800000C  b 0x827fec3c
	pc = 0x827FEC3C; continue 'dispatch;
            }
            0x827FEC34 => {
    //   block [0x827FEC34..0x827FEC3C)
	// 827FEC34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 827FEC38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x827FEC3C; continue 'dispatch;
            }
            0x827FEC3C => {
    //   block [0x827FEC3C..0x827FEC48)
	// 827FEC3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEC40: 4199FFB8  bgt cr6, 0x827febf8
	if ctx.cr[6].gt {
	pc = 0x827FEBF8; continue 'dispatch;
	}
	// 827FEC44: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x827FEC48; continue 'dispatch;
            }
            0x827FEC48 => {
    //   block [0x827FEC48..0x827FEC64)
	// 827FEC48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 827FEC4C: 419A0040  beq cr6, 0x827fec8c
	if ctx.cr[6].eq {
	pc = 0x827FEC8C; continue 'dispatch;
	}
	// 827FEC50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEC54: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 827FEC58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FEC5C: 41990008  bgt cr6, 0x827fec64
	if ctx.cr[6].gt {
	pc = 0x827FEC64; continue 'dispatch;
	}
	// 827FEC60: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827FEC64; continue 'dispatch;
            }
            0x827FEC64 => {
    //   block [0x827FEC64..0x827FEC8C)
	// 827FEC64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FEC68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEC6C: 409A0020  bne cr6, 0x827fec8c
	if !ctx.cr[6].eq {
	pc = 0x827FEC8C; continue 'dispatch;
	}
	// 827FEC70: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FEC74: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 827FEC78: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FEC7C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEC80: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FEC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FEC88: 4800001C  b 0x827feca4
	pc = 0x827FECA4; continue 'dispatch;
            }
            0x827FEC8C => {
    //   block [0x827FEC8C..0x827FECA0)
	// 827FEC8C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 827FEC90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEC94: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 827FEC98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 827FEC9C: 48000008  b 0x827feca4
	pc = 0x827FECA4; continue 'dispatch;
            }
            0x827FECA0 => {
    //   block [0x827FECA0..0x827FECA4)
	// 827FECA0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x827FECA4; continue 'dispatch;
            }
            0x827FECA4 => {
    //   block [0x827FECA4..0x827FECC4)
	// 827FECA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 827FECA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FECAC: 419A0018  beq cr6, 0x827fecc4
	if ctx.cr[6].eq {
	pc = 0x827FECC4; continue 'dispatch;
	}
	// 827FECB0: 4BF33E09  bl 0x82732ab8
	ctx.lr = 0x827FECB4;
	sub_82732AB8(ctx, base);
	// 827FECB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 827FECB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FECBC: 419A0008  beq cr6, 0x827fecc4
	if ctx.cr[6].eq {
	pc = 0x827FECC4; continue 'dispatch;
	}
	// 827FECC0: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	pc = 0x827FECC4; continue 'dispatch;
            }
            0x827FECC4 => {
    //   block [0x827FECC4..0x827FECD0)
	// 827FECC4: 379CFFFF  addic. r28, r28, -1
	ctx.xer.ca = (ctx.r[28].u32 > (!(-1 as u32)));
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 827FECC8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 827FECCC: 4082FEA0  bne 0x827feb6c
	if !ctx.cr[0].eq {
	pc = 0x827FEB6C; continue 'dispatch;
	}
	pc = 0x827FECD0; continue 'dispatch;
            }
            0x827FECD0 => {
    //   block [0x827FECD0..0x827FECFC)
	// 827FECD0: 3BFD0060  addi r31, r29, 0x60
	ctx.r[31].s64 = ctx.r[29].s64 + 96;
	// 827FECD4: 83DD0064  lwz r30, 0x64(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FECD8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FECDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FECE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FECE4: 4BB76515  bl 0x823751f8
	ctx.lr = 0x827FECE8;
	sub_823751F8(ctx, base);
	// 827FECE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FECEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FECF0: 419A000C  beq cr6, 0x827fecfc
	if ctx.cr[6].eq {
	pc = 0x827FECFC; continue 'dispatch;
	}
	// 827FECF4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FECF8: 419A0008  beq cr6, 0x827fed00
	if ctx.cr[6].eq {
	pc = 0x827FED00; continue 'dispatch;
	}
	pc = 0x827FECFC; continue 'dispatch;
            }
            0x827FECFC => {
    //   block [0x827FECFC..0x827FED00)
	// 827FECFC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FED00; continue 'dispatch;
            }
            0x827FED00 => {
    //   block [0x827FED00..0x827FED38)
	// 827FED00: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FED04: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FED08: 409A0030  bne cr6, 0x827fed38
	if !ctx.cr[6].eq {
	pc = 0x827FED38; continue 'dispatch;
	}
	// 827FED0C: 93210070  stw r25, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u32 ) };
	// 827FED10: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FED14: 4821920D  bl 0x82a17f20
	ctx.lr = 0x827FED18;
	sub_82A17F20(ctx, base);
	// 827FED18: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FED20: 3BC10070  addi r30, r1, 0x70
	ctx.r[30].s64 = ctx.r[1].s64 + 112;
	// 827FED24: 48000C35  bl 0x827ff958
	ctx.lr = 0x827FED28;
	sub_827FF958(ctx, base);
	// 827FED28: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FED2C: 4BFFC635  bl 0x827fb360
	ctx.lr = 0x827FED30;
	sub_827FB360(ctx, base);
	// 827FED30: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FED34: 4BEDAD25  bl 0x826d9a58
	ctx.lr = 0x827FED38;
	sub_826D9A58(ctx, base);
	pc = 0x827FED38; continue 'dispatch;
            }
            0x827FED38 => {
    //   block [0x827FED38..0x827FED60)
	// 827FED38: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FED3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FED40: 48000C19  bl 0x827ff958
	ctx.lr = 0x827FED44;
	sub_827FF958(ctx, base);
	// 827FED44: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 827FED48: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 827FED4C: 4BFFBA1D  bl 0x827fa768
	ctx.lr = 0x827FED50;
	sub_827FA768(ctx, base);
	// 827FED50: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 827FED54: 419A000C  beq cr6, 0x827fed60
	if ctx.cr[6].eq {
	pc = 0x827FED60; continue 'dispatch;
	}
	// 827FED58: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827FED5C: 4BA1CFDD  bl 0x8221bd38
	ctx.lr = 0x827FED60;
	sub_8221BD38(ctx, base);
	pc = 0x827FED60; continue 'dispatch;
            }
            0x827FED60 => {
    //   block [0x827FED60..0x827FED68)
	// 827FED60: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827FED64: 484AA6E4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FED68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FED68 size=556
    let mut pc: u32 = 0x827FED68;
    'dispatch: loop {
        match pc {
            0x827FED68 => {
    //   block [0x827FED68..0x827FEE38)
	// 827FED68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FED6C: 484AA681  bl 0x82ca93ec
	ctx.lr = 0x827FED70;
	sub_82CA93D0(ctx, base);
	// 827FED70: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FED74: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FED78: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FED7C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FED80: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FED84: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FED88: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FED8C: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FED90: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FED94: 80A60024  lwz r5, 0x24(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FED98: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FED9C: 3BEB00AC  addi r31, r11, 0xac
	ctx.r[31].s64 = ctx.r[11].s64 + 172;
	// 827FEDA0: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FEDA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEDA8: 419A01E4  beq cr6, 0x827fef8c
	if ctx.cr[6].eq {
	pc = 0x827FEF8C; continue 'dispatch;
	}
	// 827FEDAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEDB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEDB4: 419A01D8  beq cr6, 0x827fef8c
	if ctx.cr[6].eq {
	pc = 0x827FEF8C; continue 'dispatch;
	}
	// 827FEDB8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEDBC: 48000645  bl 0x827ff400
	ctx.lr = 0x827FEDC0;
	sub_827FF400(ctx, base);
	// 827FEDC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEDC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FEDC8: 48000549  bl 0x827ff310
	ctx.lr = 0x827FEDCC;
	sub_827FF310(ctx, base);
	// 827FEDCC: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FEDD0: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 827FEDD4: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827FEDD8: 386BA700  addi r3, r11, -0x5900
	ctx.r[3].s64 = ctx.r[11].s64 + -22784;
	// 827FEDDC: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 827FEDE0: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 827FEDE4: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 827FEDE8: 4B9F4F71  bl 0x821f3d58
	ctx.lr = 0x827FEDEC;
	sub_821F3D58(ctx, base);
	// 827FEDEC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 827FEDF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FEDF4: 807A6DA0  lwz r3, 0x6da0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FEDF8: 48201061  bl 0x829ffe58
	ctx.lr = 0x827FEDFC;
	sub_829FFE58(ctx, base);
	// 827FEDFC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FEE00: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FEE04: 419A0108  beq cr6, 0x827fef0c
	if ctx.cr[6].eq {
	pc = 0x827FEF0C; continue 'dispatch;
	}
	// 827FEE08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FEE0C: 48201B85  bl 0x82a00990
	ctx.lr = 0x827FEE10;
	sub_82A00990(ctx, base);
	// 827FEE10: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FEE14: 82E10054  lwz r23, 0x54(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FEE18: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FEE1C: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827FEE20: 419A00E4  beq cr6, 0x827fef04
	if ctx.cr[6].eq {
	pc = 0x827FEF04; continue 'dispatch;
	}
	// 827FEE24: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827FEE28: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 827FEE2C: 3F00834A  lis r24, -0x7cb6
	ctx.r[24].s64 = -2092302336;
	// 827FEE30: 3B2BE460  addi r25, r11, -0x1ba0
	ctx.r[25].s64 = ctx.r[11].s64 + -7072;
	// 827FEE34: 3B6AFB7C  addi r27, r10, -0x484
	ctx.r[27].s64 = ctx.r[10].s64 + -1156;
	pc = 0x827FEE38; continue 'dispatch;
            }
            0x827FEE38 => {
    //   block [0x827FEE38..0x827FEE74)
	// 827FEE38: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FEE3C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 827FEE40: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FEE44: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 827FEE48: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FEE4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEE50: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 827FEE54: 419A0020  beq cr6, 0x827fee74
	if ctx.cr[6].eq {
	pc = 0x827FEE74; continue 'dispatch;
	}
	// 827FEE58: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 827FEE5C: 409A0018  bne cr6, 0x827fee74
	if !ctx.cr[6].eq {
	pc = 0x827FEE74; continue 'dispatch;
	}
	// 827FEE60: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEE64: 8138E454  lwz r9, -0x1bac(r24)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 827FEE68: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FEE6C: 409A0008  bne cr6, 0x827fee74
	if !ctx.cr[6].eq {
	pc = 0x827FEE74; continue 'dispatch;
	}
	// 827FEE70: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x827FEE74; continue 'dispatch;
            }
            0x827FEE74 => {
    //   block [0x827FEE74..0x827FEED0)
	// 827FEE74: 807A6DA0  lwz r3, 0x6da0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FEE78: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEE7C: 4B9E53D5  bl 0x821e4250
	ctx.lr = 0x827FEE80;
	sub_821E4250(ctx, base);
	// 827FEE80: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FEE84: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827FEE88: 419A0050  beq cr6, 0x827feed8
	if ctx.cr[6].eq {
	pc = 0x827FEED8; continue 'dispatch;
	}
	// 827FEE8C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 827FEE90: 4BB246B1  bl 0x82323540
	ctx.lr = 0x827FEE94;
	sub_82323540(ctx, base);
	// 827FEE94: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FEE98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FEE9C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FEEA0: 4BA2E031  bl 0x8222ced0
	ctx.lr = 0x827FEEA4;
	sub_8222CED0(ctx, base);
	// 827FEEA4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FEEA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEEAC: 419A0024  beq cr6, 0x827feed0
	if ctx.cr[6].eq {
	pc = 0x827FEED0; continue 'dispatch;
	}
	// 827FEEB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEEB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEEB8: 419A0018  beq cr6, 0x827feed0
	if ctx.cr[6].eq {
	pc = 0x827FEED0; continue 'dispatch;
	}
	// 827FEEBC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FEEC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 827FEEC4: 4800053D  bl 0x827ff400
	ctx.lr = 0x827FEEC8;
	sub_827FF400(ctx, base);
	// 827FEEC8: 7F03B040  cmplw cr6, r3, r22
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[22].u32, &mut ctx.xer);
	// 827FEECC: 419A001C  beq cr6, 0x827feee8
	if ctx.cr[6].eq {
	pc = 0x827FEEE8; continue 'dispatch;
	}
	pc = 0x827FEED0; continue 'dispatch;
            }
            0x827FEED0 => {
    //   block [0x827FEED0..0x827FEED8)
	// 827FEED0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FEED4: 4BA15F05  bl 0x82214dd8
	ctx.lr = 0x827FEED8;
	sub_82214DD8(ctx, base);
	pc = 0x827FEED8; continue 'dispatch;
            }
            0x827FEED8 => {
    //   block [0x827FEED8..0x827FEEE8)
	// 827FEED8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827FEEDC: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827FEEE0: 409AFF58  bne cr6, 0x827fee38
	if !ctx.cr[6].eq {
	pc = 0x827FEE38; continue 'dispatch;
	}
	// 827FEEE4: 48000020  b 0x827fef04
	pc = 0x827FEF04; continue 'dispatch;
            }
            0x827FEEE8 => {
    //   block [0x827FEEE8..0x827FEF04)
	// 827FEEE8: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FEEEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FEEF0: 388BA71C  addi r4, r11, -0x58e4
	ctx.r[4].s64 = ctx.r[11].s64 + -22756;
	// 827FEEF4: 4BBC092D  bl 0x823bf820
	ctx.lr = 0x827FEEF8;
	sub_823BF820(ctx, base);
	// 827FEEF8: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 827FEEFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FEF00: 4BA15ED9  bl 0x82214dd8
	ctx.lr = 0x827FEF04;
	sub_82214DD8(ctx, base);
	pc = 0x827FEF04; continue 'dispatch;
            }
            0x827FEF04 => {
    //   block [0x827FEF04..0x827FEF0C)
	// 827FEF04: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827FEF08: 4BA1CE31  bl 0x8221bd38
	ctx.lr = 0x827FEF0C;
	sub_8221BD38(ctx, base);
	pc = 0x827FEF0C; continue 'dispatch;
            }
            0x827FEF0C => {
    //   block [0x827FEF0C..0x827FEF38)
	// 827FEF0C: 3BFC006C  addi r31, r28, 0x6c
	ctx.r[31].s64 = ctx.r[28].s64 + 108;
	// 827FEF10: 83DC0070  lwz r30, 0x70(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 827FEF14: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 827FEF18: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FEF1C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FEF20: 4BB762D9  bl 0x823751f8
	ctx.lr = 0x827FEF24;
	sub_823751F8(ctx, base);
	// 827FEF24: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FEF28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEF2C: 419A000C  beq cr6, 0x827fef38
	if ctx.cr[6].eq {
	pc = 0x827FEF38; continue 'dispatch;
	}
	// 827FEF30: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FEF34: 419A0008  beq cr6, 0x827fef3c
	if ctx.cr[6].eq {
	pc = 0x827FEF3C; continue 'dispatch;
	}
	pc = 0x827FEF38; continue 'dispatch;
            }
            0x827FEF38 => {
    //   block [0x827FEF38..0x827FEF3C)
	// 827FEF38: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FEF3C; continue 'dispatch;
            }
            0x827FEF3C => {
    //   block [0x827FEF3C..0x827FEF74)
	// 827FEF3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEF40: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FEF44: 409A0030  bne cr6, 0x827fef74
	if !ctx.cr[6].eq {
	pc = 0x827FEF74; continue 'dispatch;
	}
	// 827FEF48: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 827FEF4C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FEF50: 48218FD1  bl 0x82a17f20
	ctx.lr = 0x827FEF54;
	sub_82A17F20(ctx, base);
	// 827FEF54: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827FEF58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEF5C: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 827FEF60: 480009F9  bl 0x827ff958
	ctx.lr = 0x827FEF64;
	sub_827FF958(ctx, base);
	// 827FEF64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FEF68: 4BFFC3F9  bl 0x827fb360
	ctx.lr = 0x827FEF6C;
	sub_827FB360(ctx, base);
	// 827FEF6C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FEF70: 4BEDAAE9  bl 0x826d9a58
	ctx.lr = 0x827FEF74;
	sub_826D9A58(ctx, base);
	pc = 0x827FEF74; continue 'dispatch;
            }
            0x827FEF74 => {
    //   block [0x827FEF74..0x827FEF8C)
	// 827FEF74: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827FEF78: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEF7C: 480009DD  bl 0x827ff958
	ctx.lr = 0x827FEF80;
	sub_827FF958(ctx, base);
	// 827FEF80: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 827FEF84: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FEF88: 4BFFB7E1  bl 0x827fa768
	ctx.lr = 0x827FEF8C;
	sub_827FA768(ctx, base);
	pc = 0x827FEF8C; continue 'dispatch;
            }
            0x827FEF8C => {
    //   block [0x827FEF8C..0x827FEF94)
	// 827FEF8C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827FEF90: 484AA4AC  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FEF98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FEF98 size=340
    let mut pc: u32 = 0x827FEF98;
    'dispatch: loop {
        match pc {
            0x827FEF98 => {
    //   block [0x827FEF98..0x827FF080)
	// 827FEF98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FEF9C: 484AA465  bl 0x82ca9400
	ctx.lr = 0x827FEFA0;
	sub_82CA93D0(ctx, base);
	// 827FEFA0: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FEFA4: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 827FEFA8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FEFAC: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FEFB0: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FEFB4: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FEFB8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEFBC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FEFC0: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEFC4: 80C70024  lwz r6, 0x24(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FEFC8: 81660004  lwz r11, 4(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEFCC: 3BCB00AC  addi r30, r11, 0xac
	ctx.r[30].s64 = ctx.r[11].s64 + 172;
	// 827FEFD0: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FEFD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FEFD8: 419A010C  beq cr6, 0x827ff0e4
	if ctx.cr[6].eq {
	pc = 0x827FF0E4; continue 'dispatch;
	}
	// 827FEFDC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FEFE0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FEFE4: 419A0100  beq cr6, 0x827ff0e4
	if ctx.cr[6].eq {
	pc = 0x827FF0E4; continue 'dispatch;
	}
	// 827FEFE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FEFEC: 48000415  bl 0x827ff400
	ctx.lr = 0x827FEFF0;
	sub_827FF400(ctx, base);
	// 827FEFF0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 827FEFF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FEFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FEFFC: 48000315  bl 0x827ff310
	ctx.lr = 0x827FF000;
	sub_827FF310(ctx, base);
	// 827FF000: 815D6AB8  lwz r10, 0x6ab8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FF004: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FF008: 39200060  li r9, 0x60
	ctx.r[9].s64 = 96;
	// 827FF00C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 827FF010: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 827FF014: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 827FF018: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FF01C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 827FF020: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 827FF024: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 827FF028: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FF02C: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF030: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 827FF034: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FF038: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF03C: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF040: 480029B9  bl 0x828019f8
	ctx.lr = 0x827FF044;
	sub_828019F8(ctx, base);
	// 827FF044: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 827FF048: 3BFF007C  addi r31, r31, 0x7c
	ctx.r[31].s64 = ctx.r[31].s64 + 124;
	// 827FF04C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 827FF050: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF054: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF058: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FF05C: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF060: 7D5A5850  subf r10, r26, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[26].s64;
	// 827FF064: 7D5E1670  srawi r30, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[30].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 827FF068: 4BB76191  bl 0x823751f8
	ctx.lr = 0x827FF06C;
	sub_823751F8(ctx, base);
	// 827FF06C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF074: 419A000C  beq cr6, 0x827ff080
	if ctx.cr[6].eq {
	pc = 0x827FF080; continue 'dispatch;
	}
	// 827FF078: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FF07C: 419A0008  beq cr6, 0x827ff084
	if ctx.cr[6].eq {
	pc = 0x827FF084; continue 'dispatch;
	}
	pc = 0x827FF080; continue 'dispatch;
            }
            0x827FF080 => {
    //   block [0x827FF080..0x827FF084)
	// 827FF080: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF084; continue 'dispatch;
            }
            0x827FF084 => {
    //   block [0x827FF084..0x827FF0BC)
	// 827FF084: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF088: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FF08C: 409A0030  bne cr6, 0x827ff0bc
	if !ctx.cr[6].eq {
	pc = 0x827FF0BC; continue 'dispatch;
	}
	// 827FF090: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 827FF094: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FF098: 48218E89  bl 0x82a17f20
	ctx.lr = 0x827FF09C;
	sub_82A17F20(ctx, base);
	// 827FF09C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FF0A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF0A4: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 827FF0A8: 480008B1  bl 0x827ff958
	ctx.lr = 0x827FF0AC;
	sub_827FF958(ctx, base);
	// 827FF0AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 827FF0B0: 4BFFC2B1  bl 0x827fb360
	ctx.lr = 0x827FF0B4;
	sub_827FB360(ctx, base);
	// 827FF0B4: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FF0B8: 4BEDA9A1  bl 0x826d9a58
	ctx.lr = 0x827FF0BC;
	sub_826D9A58(ctx, base);
	pc = 0x827FF0BC; continue 'dispatch;
            }
            0x827FF0BC => {
    //   block [0x827FF0BC..0x827FF0E4)
	// 827FF0BC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FF0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF0C4: 48000895  bl 0x827ff958
	ctx.lr = 0x827FF0C8;
	sub_827FF958(ctx, base);
	// 827FF0C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 827FF0CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FF0D0: 4BFFB699  bl 0x827fa768
	ctx.lr = 0x827FF0D4;
	sub_827FA768(ctx, base);
	// 827FF0D4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 827FF0D8: 419A000C  beq cr6, 0x827ff0e4
	if ctx.cr[6].eq {
	pc = 0x827FF0E4; continue 'dispatch;
	}
	// 827FF0DC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 827FF0E0: 4BA1CC59  bl 0x8221bd38
	ctx.lr = 0x827FF0E4;
	sub_8221BD38(ctx, base);
	pc = 0x827FF0E4; continue 'dispatch;
            }
            0x827FF0E4 => {
    //   block [0x827FF0E4..0x827FF0EC)
	// 827FF0E4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 827FF0E8: 484AA368  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF0F0 size=540
    let mut pc: u32 = 0x827FF0F0;
    'dispatch: loop {
        match pc {
            0x827FF0F0 => {
    //   block [0x827FF0F0..0x827FF1B0)
	// 827FF0F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF0F4: 484AA2F9  bl 0x82ca93ec
	ctx.lr = 0x827FF0F8;
	sub_82CA93D0(ctx, base);
	// 827FF0F8: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF0FC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 827FF100: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 827FF104: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 827FF108: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF10C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FF110: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF114: 80E80008  lwz r7, 8(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF118: 80C70004  lwz r6, 4(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF11C: 80A60024  lwz r5, 0x24(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 827FF120: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF124: 388B00AC  addi r4, r11, 0xac
	ctx.r[4].s64 = ctx.r[11].s64 + 172;
	// 827FF128: 816B00AC  lwz r11, 0xac(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(172 as u32) ) } as u64;
	// 827FF12C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF130: 419A01D4  beq cr6, 0x827ff304
	if ctx.cr[6].eq {
	pc = 0x827FF304; continue 'dispatch;
	}
	// 827FF134: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF138: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FF13C: 419A01C8  beq cr6, 0x827ff304
	if ctx.cr[6].eq {
	pc = 0x827FF304; continue 'dispatch;
	}
	// 827FF140: 480001D1  bl 0x827ff310
	ctx.lr = 0x827FF144;
	sub_827FF310(ctx, base);
	// 827FF144: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FF148: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 827FF14C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 827FF150: 386BA700  addi r3, r11, -0x5900
	ctx.r[3].s64 = ctx.r[11].s64 + -22784;
	// 827FF154: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 827FF158: 92C1005C  stw r22, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 827FF15C: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 827FF160: 4B9F4BF9  bl 0x821f3d58
	ctx.lr = 0x827FF164;
	sub_821F3D58(ctx, base);
	// 827FF164: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 827FF168: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FF16C: 807B6DA0  lwz r3, 0x6da0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FF170: 48200CE9  bl 0x829ffe58
	ctx.lr = 0x827FF174;
	sub_829FFE58(ctx, base);
	// 827FF174: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FF178: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 827FF17C: 419A0108  beq cr6, 0x827ff284
	if ctx.cr[6].eq {
	pc = 0x827FF284; continue 'dispatch;
	}
	// 827FF180: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF184: 4820180D  bl 0x82a00990
	ctx.lr = 0x827FF188;
	sub_82A00990(ctx, base);
	// 827FF188: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 827FF18C: 82E10054  lwz r23, 0x54(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FF190: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FF194: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827FF198: 419A00E4  beq cr6, 0x827ff27c
	if ctx.cr[6].eq {
	pc = 0x827FF27C; continue 'dispatch;
	}
	// 827FF19C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 827FF1A0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 827FF1A4: 3F20834A  lis r25, -0x7cb6
	ctx.r[25].s64 = -2092302336;
	// 827FF1A8: 3B4BE460  addi r26, r11, -0x1ba0
	ctx.r[26].s64 = ctx.r[11].s64 + -7072;
	// 827FF1AC: 3B8AFB7C  addi r28, r10, -0x484
	ctx.r[28].s64 = ctx.r[10].s64 + -1156;
	pc = 0x827FF1B0; continue 'dispatch;
            }
            0x827FF1B0 => {
    //   block [0x827FF1B0..0x827FF1EC)
	// 827FF1B0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FF1B4: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 827FF1B8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 827FF1BC: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 827FF1C0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF1C4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF1C8: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 827FF1CC: 419A0020  beq cr6, 0x827ff1ec
	if ctx.cr[6].eq {
	pc = 0x827FF1EC; continue 'dispatch;
	}
	// 827FF1D0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 827FF1D4: 409A0018  bne cr6, 0x827ff1ec
	if !ctx.cr[6].eq {
	pc = 0x827FF1EC; continue 'dispatch;
	}
	// 827FF1D8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF1DC: 8139E454  lwz r9, -0x1bac(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 827FF1E0: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FF1E4: 409A0008  bne cr6, 0x827ff1ec
	if !ctx.cr[6].eq {
	pc = 0x827FF1EC; continue 'dispatch;
	}
	// 827FF1E8: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x827FF1EC; continue 'dispatch;
            }
            0x827FF1EC => {
    //   block [0x827FF1EC..0x827FF248)
	// 827FF1EC: 807B6DA0  lwz r3, 0x6da0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28064 as u32) ) } as u64;
	// 827FF1F0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF1F4: 4B9E505D  bl 0x821e4250
	ctx.lr = 0x827FF1F8;
	sub_821E4250(ctx, base);
	// 827FF1F8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FF1FC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 827FF200: 419A0050  beq cr6, 0x827ff250
	if ctx.cr[6].eq {
	pc = 0x827FF250; continue 'dispatch;
	}
	// 827FF204: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 827FF208: 4BB24339  bl 0x82323540
	ctx.lr = 0x827FF20C;
	sub_82323540(ctx, base);
	// 827FF20C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FF210: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF214: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF218: 4BA2DCB9  bl 0x8222ced0
	ctx.lr = 0x827FF21C;
	sub_8222CED0(ctx, base);
	// 827FF21C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FF220: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF224: 419A0024  beq cr6, 0x827ff248
	if ctx.cr[6].eq {
	pc = 0x827FF248; continue 'dispatch;
	}
	// 827FF228: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF22C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 827FF230: 419A0018  beq cr6, 0x827ff248
	if ctx.cr[6].eq {
	pc = 0x827FF248; continue 'dispatch;
	}
	// 827FF234: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FF238: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 827FF23C: 480001C5  bl 0x827ff400
	ctx.lr = 0x827FF240;
	sub_827FF400(ctx, base);
	// 827FF240: 7F03B040  cmplw cr6, r3, r22
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[22].u32, &mut ctx.xer);
	// 827FF244: 419A001C  beq cr6, 0x827ff260
	if ctx.cr[6].eq {
	pc = 0x827FF260; continue 'dispatch;
	}
	pc = 0x827FF248; continue 'dispatch;
            }
            0x827FF248 => {
    //   block [0x827FF248..0x827FF250)
	// 827FF248: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF24C: 4BA15B8D  bl 0x82214dd8
	ctx.lr = 0x827FF250;
	sub_82214DD8(ctx, base);
	pc = 0x827FF250; continue 'dispatch;
            }
            0x827FF250 => {
    //   block [0x827FF250..0x827FF260)
	// 827FF250: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 827FF254: 7F1FB840  cmplw cr6, r31, r23
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[23].u32, &mut ctx.xer);
	// 827FF258: 409AFF58  bne cr6, 0x827ff1b0
	if !ctx.cr[6].eq {
	pc = 0x827FF1B0; continue 'dispatch;
	}
	// 827FF25C: 48000020  b 0x827ff27c
	pc = 0x827FF27C; continue 'dispatch;
            }
            0x827FF260 => {
    //   block [0x827FF260..0x827FF27C)
	// 827FF260: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 827FF264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FF268: 388BA72C  addi r4, r11, -0x58d4
	ctx.r[4].s64 = ctx.r[11].s64 + -22740;
	// 827FF26C: 4BBC05B5  bl 0x823bf820
	ctx.lr = 0x827FF270;
	sub_823BF820(ctx, base);
	// 827FF270: 7C751B78  mr r21, r3
	ctx.r[21].u64 = ctx.r[3].u64;
	// 827FF274: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF278: 4BA15B61  bl 0x82214dd8
	ctx.lr = 0x827FF27C;
	sub_82214DD8(ctx, base);
	pc = 0x827FF27C; continue 'dispatch;
            }
            0x827FF27C => {
    //   block [0x827FF27C..0x827FF284)
	// 827FF27C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 827FF280: 4BA1CAB9  bl 0x8221bd38
	ctx.lr = 0x827FF284;
	sub_8221BD38(ctx, base);
	pc = 0x827FF284; continue 'dispatch;
            }
            0x827FF284 => {
    //   block [0x827FF284..0x827FF2B0)
	// 827FF284: 3BF80088  addi r31, r24, 0x88
	ctx.r[31].s64 = ctx.r[24].s64 + 136;
	// 827FF288: 83D8008C  lwz r30, 0x8c(r24)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(140 as u32) ) } as u64;
	// 827FF28C: 38A1005C  addi r5, r1, 0x5c
	ctx.r[5].s64 = ctx.r[1].s64 + 92;
	// 827FF290: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF294: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF298: 4BB75F61  bl 0x823751f8
	ctx.lr = 0x827FF29C;
	sub_823751F8(ctx, base);
	// 827FF29C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF2A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF2A4: 419A000C  beq cr6, 0x827ff2b0
	if ctx.cr[6].eq {
	pc = 0x827FF2B0; continue 'dispatch;
	}
	// 827FF2A8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FF2AC: 419A0008  beq cr6, 0x827ff2b4
	if ctx.cr[6].eq {
	pc = 0x827FF2B4; continue 'dispatch;
	}
	pc = 0x827FF2B0; continue 'dispatch;
            }
            0x827FF2B0 => {
    //   block [0x827FF2B0..0x827FF2B4)
	// 827FF2B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF2B4; continue 'dispatch;
            }
            0x827FF2B4 => {
    //   block [0x827FF2B4..0x827FF2EC)
	// 827FF2B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF2B8: 7F0BF040  cmplw cr6, r11, r30
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FF2BC: 409A0030  bne cr6, 0x827ff2ec
	if !ctx.cr[6].eq {
	pc = 0x827FF2EC; continue 'dispatch;
	}
	// 827FF2C0: 92C10060  stw r22, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[22].u32 ) };
	// 827FF2C4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FF2C8: 48218C59  bl 0x82a17f20
	ctx.lr = 0x827FF2CC;
	sub_82A17F20(ctx, base);
	// 827FF2CC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827FF2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF2D4: 3BC10060  addi r30, r1, 0x60
	ctx.r[30].s64 = ctx.r[1].s64 + 96;
	// 827FF2D8: 48000681  bl 0x827ff958
	ctx.lr = 0x827FF2DC;
	sub_827FF958(ctx, base);
	// 827FF2DC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 827FF2E0: 4BFFC081  bl 0x827fb360
	ctx.lr = 0x827FF2E4;
	sub_827FB360(ctx, base);
	// 827FF2E4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FF2E8: 4BEDA771  bl 0x826d9a58
	ctx.lr = 0x827FF2EC;
	sub_826D9A58(ctx, base);
	pc = 0x827FF2EC; continue 'dispatch;
            }
            0x827FF2EC => {
    //   block [0x827FF2EC..0x827FF304)
	// 827FF2EC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 827FF2F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF2F4: 48000665  bl 0x827ff958
	ctx.lr = 0x827FF2F8;
	sub_827FF958(ctx, base);
	// 827FF2F8: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 827FF2FC: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 827FF300: 4BFFB469  bl 0x827fa768
	ctx.lr = 0x827FF304;
	sub_827FA768(ctx, base);
	pc = 0x827FF304; continue 'dispatch;
            }
            0x827FF304 => {
    //   block [0x827FF304..0x827FF30C)
	// 827FF304: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 827FF308: 484AA134  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF310 size=240
    let mut pc: u32 = 0x827FF310;
    'dispatch: loop {
        match pc {
            0x827FF310 => {
    //   block [0x827FF310..0x827FF348)
	// 827FF310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF314: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF318: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FF31C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF320: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF324: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF328: 480000D9  bl 0x827ff400
	ctx.lr = 0x827FF32C;
	sub_827FF400(ctx, base);
	// 827FF32C: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 827FF330: 3BFF0094  addi r31, r31, 0x94
	ctx.r[31].s64 = ctx.r[31].s64 + 148;
	// 827FF334: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FF338: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 827FF33C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 827FF340: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF344: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x827FF348; continue 'dispatch;
            }
            0x827FF348 => {
    //   block [0x827FF348..0x827FF35C)
	// 827FF348: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF34C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FF350: 419A000C  beq cr6, 0x827ff35c
	if ctx.cr[6].eq {
	pc = 0x827FF35C; continue 'dispatch;
	}
	// 827FF354: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FF358: 419A0008  beq cr6, 0x827ff360
	if ctx.cr[6].eq {
	pc = 0x827FF360; continue 'dispatch;
	}
	pc = 0x827FF35C; continue 'dispatch;
            }
            0x827FF35C => {
    //   block [0x827FF35C..0x827FF360)
	// 827FF35C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF360; continue 'dispatch;
            }
            0x827FF360 => {
    //   block [0x827FF360..0x827FF374)
	// 827FF360: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FF364: 419A0080  beq cr6, 0x827ff3e4
	if ctx.cr[6].eq {
	pc = 0x827FF3E4; continue 'dispatch;
	}
	// 827FF368: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FF36C: 409A0008  bne cr6, 0x827ff374
	if !ctx.cr[6].eq {
	pc = 0x827FF374; continue 'dispatch;
	}
	// 827FF370: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF374; continue 'dispatch;
            }
            0x827FF374 => {
    //   block [0x827FF374..0x827FF384)
	// 827FF374: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF378: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF37C: 409A0008  bne cr6, 0x827ff384
	if !ctx.cr[6].eq {
	pc = 0x827FF384; continue 'dispatch;
	}
	// 827FF380: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF384; continue 'dispatch;
            }
            0x827FF384 => {
    //   block [0x827FF384..0x827FF394)
	// 827FF384: 806B000C  lwz r3, 0xc(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF388: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF38C: 409A0008  bne cr6, 0x827ff394
	if !ctx.cr[6].eq {
	pc = 0x827FF394; continue 'dispatch;
	}
	// 827FF390: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF394; continue 'dispatch;
            }
            0x827FF394 => {
    //   block [0x827FF394..0x827FF3A8)
	// 827FF394: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 827FF398: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FF39C: 419A0034  beq cr6, 0x827ff3d0
	if ctx.cr[6].eq {
	pc = 0x827FF3D0; continue 'dispatch;
	}
	// 827FF3A0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 827FF3A4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF3A8; continue 'dispatch;
            }
            0x827FF3A8 => {
    //   block [0x827FF3A8..0x827FF3C8)
	// 827FF3A8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF3AC: 419A0024  beq cr6, 0x827ff3d0
	if ctx.cr[6].eq {
	pc = 0x827FF3D0; continue 'dispatch;
	}
	// 827FF3B0: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF3B4: 7F09F040  cmplw cr6, r9, r30
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[30].u32, &mut ctx.xer);
	// 827FF3B8: 419A0030  beq cr6, 0x827ff3e8
	if ctx.cr[6].eq {
	pc = 0x827FF3E8; continue 'dispatch;
	}
	// 827FF3BC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF3C0: 409A0008  bne cr6, 0x827ff3c8
	if !ctx.cr[6].eq {
	pc = 0x827FF3C8; continue 'dispatch;
	}
	// 827FF3C4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF3C8; continue 'dispatch;
            }
            0x827FF3C8 => {
    //   block [0x827FF3C8..0x827FF3D0)
	// 827FF3C8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF3CC: 4BFFFFDC  b 0x827ff3a8
	pc = 0x827FF3A8; continue 'dispatch;
            }
            0x827FF3D0 => {
    //   block [0x827FF3D0..0x827FF3E4)
	// 827FF3D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF3D4: 4829D145  bl 0x82a9c518
	ctx.lr = 0x827FF3D8;
	sub_82A9C518(ctx, base);
	// 827FF3D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FF3DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FF3E0: 4BFFFF68  b 0x827ff348
	pc = 0x827FF348; continue 'dispatch;
            }
            0x827FF3E4 => {
    //   block [0x827FF3E4..0x827FF3E8)
	// 827FF3E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x827FF3E8; continue 'dispatch;
            }
            0x827FF3E8 => {
    //   block [0x827FF3E8..0x827FF400)
	// 827FF3E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FF3EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF3F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF3F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FF3F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF3FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF400 size=332
    let mut pc: u32 = 0x827FF400;
    'dispatch: loop {
        match pc {
            0x827FF400 => {
    //   block [0x827FF400..0x827FF510)
	// 827FF400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF404: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF408: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF40C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF410: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF414: 4B9F0E2D  bl 0x821f0240
	ctx.lr = 0x827FF418;
	sub_821F0240(ctx, base);
	// 827FF418: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 827FF41C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF420: 3BEB0C00  addi r31, r11, 0xc00
	ctx.r[31].s64 = ctx.r[11].s64 + 3072;
	// 827FF424: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF428: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF42C: 4BA2DAA5  bl 0x8222ced0
	ctx.lr = 0x827FF430;
	sub_8222CED0(ctx, base);
	// 827FF430: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 827FF434: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF438: 388A0C04  addi r4, r10, 0xc04
	ctx.r[4].s64 = ctx.r[10].s64 + 3076;
	// 827FF43C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF440: 4BA2DA91  bl 0x8222ced0
	ctx.lr = 0x827FF444;
	sub_8222CED0(ctx, base);
	// 827FF444: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 827FF448: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 827FF44C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF450: 4B9E73F9  bl 0x821e6848
	ctx.lr = 0x827FF454;
	sub_821E6848(ctx, base);
	// 827FF454: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF458: 4BA15981  bl 0x82214dd8
	ctx.lr = 0x827FF45C;
	sub_82214DD8(ctx, base);
	// 827FF45C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF460: 4BA15979  bl 0x82214dd8
	ctx.lr = 0x827FF464;
	sub_82214DD8(ctx, base);
	// 827FF464: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF468: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF46C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF470: 4BA2DA61  bl 0x8222ced0
	ctx.lr = 0x827FF474;
	sub_8222CED0(ctx, base);
	// 827FF474: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 827FF478: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF47C: 388949E8  addi r4, r9, 0x49e8
	ctx.r[4].s64 = ctx.r[9].s64 + 18920;
	// 827FF480: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF484: 4BA2DA4D  bl 0x8222ced0
	ctx.lr = 0x827FF488;
	sub_8222CED0(ctx, base);
	// 827FF488: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FF48C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FF490: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF494: 4B9E73B5  bl 0x821e6848
	ctx.lr = 0x827FF498;
	sub_821E6848(ctx, base);
	// 827FF498: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF49C: 4BA1593D  bl 0x82214dd8
	ctx.lr = 0x827FF4A0;
	sub_82214DD8(ctx, base);
	// 827FF4A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF4A4: 4BA15935  bl 0x82214dd8
	ctx.lr = 0x827FF4A8;
	sub_82214DD8(ctx, base);
	// 827FF4A8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF4AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF4B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF4B4: 4BA2DA1D  bl 0x8222ced0
	ctx.lr = 0x827FF4B8;
	sub_8222CED0(ctx, base);
	// 827FF4B8: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 827FF4BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 827FF4C0: 38880C0C  addi r4, r8, 0xc0c
	ctx.r[4].s64 = ctx.r[8].s64 + 3084;
	// 827FF4C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF4C8: 4BA2DA09  bl 0x8222ced0
	ctx.lr = 0x827FF4CC;
	sub_8222CED0(ctx, base);
	// 827FF4CC: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 827FF4D0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 827FF4D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF4D8: 4B9E7371  bl 0x821e6848
	ctx.lr = 0x827FF4DC;
	sub_821E6848(ctx, base);
	// 827FF4DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF4E0: 4BA158F9  bl 0x82214dd8
	ctx.lr = 0x827FF4E4;
	sub_82214DD8(ctx, base);
	// 827FF4E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 827FF4E8: 4BA158F1  bl 0x82214dd8
	ctx.lr = 0x827FF4EC;
	sub_82214DD8(ctx, base);
	// 827FF4EC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 827FF4F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF4F4: 4B9EF645  bl 0x821eeb38
	ctx.lr = 0x827FF4F8;
	sub_821EEB38(ctx, base);
	// 827FF4F8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF4FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF500: 409A0010  bne cr6, 0x827ff510
	if !ctx.cr[6].eq {
	pc = 0x827FF510; continue 'dispatch;
	}
	// 827FF504: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 827FF508: 386BFFDF  addi r3, r11, -0x21
	ctx.r[3].s64 = ctx.r[11].s64 + -33;
	// 827FF50C: 48000008  b 0x827ff514
	pc = 0x827FF514; continue 'dispatch;
            }
            0x827FF510 => {
    //   block [0x827FF510..0x827FF514)
	// 827FF510: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF514; continue 'dispatch;
            }
            0x827FF514 => {
    //   block [0x827FF514..0x827FF54C)
	// 827FF514: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 827FF518: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 827FF51C: 4B9F483D  bl 0x821f3d58
	ctx.lr = 0x827FF520;
	sub_821F3D58(ctx, base);
	// 827FF520: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF524: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF528: 4BA158B1  bl 0x82214dd8
	ctx.lr = 0x827FF52C;
	sub_82214DD8(ctx, base);
	// 827FF52C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FF530: 4BA158A9  bl 0x82214dd8
	ctx.lr = 0x827FF534;
	sub_82214DD8(ctx, base);
	// 827FF534: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF538: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FF53C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF540: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF544: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF548: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF550(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF550 size=232
    let mut pc: u32 = 0x827FF550;
    'dispatch: loop {
        match pc {
            0x827FF550 => {
    //   block [0x827FF550..0x827FF578)
	// 827FF550: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF554: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF558: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF55C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 827FF560: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF564: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF568: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FF56C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FF570: 409A0030  bne cr6, 0x827ff5a0
	if !ctx.cr[6].eq {
	pc = 0x827FF5A0; continue 'dispatch;
	}
	// 827FF574: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF578; continue 'dispatch;
            }
            0x827FF578 => {
    //   block [0x827FF578..0x827FF58C)
	// 827FF578: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF57C: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FF580: 4098000C  bge cr6, 0x827ff58c
	if !ctx.cr[6].lt {
	pc = 0x827FF58C; continue 'dispatch;
	}
	// 827FF584: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF588: 4800000C  b 0x827ff594
	pc = 0x827FF594; continue 'dispatch;
            }
            0x827FF58C => {
    //   block [0x827FF58C..0x827FF594)
	// 827FF58C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FF590: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF594; continue 'dispatch;
            }
            0x827FF594 => {
    //   block [0x827FF594..0x827FF5A0)
	// 827FF594: 88EB0019  lbz r7, 0x19(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FF598: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 827FF59C: 419AFFDC  beq cr6, 0x827ff578
	if ctx.cr[6].eq {
	pc = 0x827FF578; continue 'dispatch;
	}
	pc = 0x827FF5A0; continue 'dispatch;
            }
            0x827FF5A0 => {
    //   block [0x827FF5A0..0x827FF5C8)
	// 827FF5A0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF5A4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827FF5A8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FF5AC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FF5B0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FF5B4: 419A0014  beq cr6, 0x827ff5c8
	if ctx.cr[6].eq {
	pc = 0x827FF5C8; continue 'dispatch;
	}
	// 827FF5B8: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF5BC: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF5C0: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827FF5C4: 40980044  bge cr6, 0x827ff608
	if !ctx.cr[6].lt {
	pc = 0x827FF608; continue 'dispatch;
	}
	pc = 0x827FF5C8; continue 'dispatch;
            }
            0x827FF5C8 => {
    //   block [0x827FF5C8..0x827FF608)
	// 827FF5C8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF5CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FF5D0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FF5D4: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 827FF5D8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FF5DC: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 827FF5E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FF5E4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF5E8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FF5EC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 827FF5F0: F9210064  std r9, 0x64(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u64 ) };
	// 827FF5F4: 48000555  bl 0x827ffb48
	ctx.lr = 0x827FF5F8;
	sub_827FFB48(ctx, base);
	// 827FF5F8: E9030000  ld r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 827FF5FC: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 827FF600: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FF604: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x827FF608; continue 'dispatch;
            }
            0x827FF608 => {
    //   block [0x827FF608..0x827FF614)
	// 827FF608: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FF60C: 409A0008  bne cr6, 0x827ff614
	if !ctx.cr[6].eq {
	pc = 0x827FF614; continue 'dispatch;
	}
	// 827FF610: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF614; continue 'dispatch;
            }
            0x827FF614 => {
    //   block [0x827FF614..0x827FF624)
	// 827FF614: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF618: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF61C: 409A0008  bne cr6, 0x827ff624
	if !ctx.cr[6].eq {
	pc = 0x827FF624; continue 'dispatch;
	}
	// 827FF620: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF624; continue 'dispatch;
            }
            0x827FF624 => {
    //   block [0x827FF624..0x827FF638)
	// 827FF624: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 827FF628: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 827FF62C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF630: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF634: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF638 size=144
    let mut pc: u32 = 0x827FF638;
    'dispatch: loop {
        match pc {
            0x827FF638 => {
    //   block [0x827FF638..0x827FF668)
	// 827FF638: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF63C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF640: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF644: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF648: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF64C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 827FF650: 4BA1FC09  bl 0x8221f258
	ctx.lr = 0x827FF654;
	sub_8221F258(ctx, base);
	// 827FF654: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827FF658: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827FF65C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FF660: 419A0008  beq cr6, 0x827ff668
	if ctx.cr[6].eq {
	pc = 0x827FF668; continue 'dispatch;
	}
	// 827FF664: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827FF668; continue 'dispatch;
            }
            0x827FF668 => {
    //   block [0x827FF668..0x827FF674)
	// 827FF668: 352B0004  addic. r9, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827FF66C: 41820008  beq 0x827ff674
	if ctx.cr[0].eq {
	pc = 0x827FF674; continue 'dispatch;
	}
	// 827FF670: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827FF674; continue 'dispatch;
            }
            0x827FF674 => {
    //   block [0x827FF674..0x827FF680)
	// 827FF674: 352B0008  addic. r9, r11, 8
	ctx.xer.ca = (ctx.r[11].u32 > (!(8 as u32)));
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 827FF678: 41820008  beq 0x827ff680
	if ctx.cr[0].eq {
	pc = 0x827FF680; continue 'dispatch;
	}
	// 827FF67C: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x827FF680; continue 'dispatch;
            }
            0x827FF680 => {
    //   block [0x827FF680..0x827FF6C8)
	// 827FF680: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 827FF684: 994B001D  stb r10, 0x1d(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(29 as u32), ctx.r[10].u8 ) };
	// 827FF688: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 827FF68C: 992B001C  stb r9, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 827FF690: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FF694: 992B001D  stb r9, 0x1d(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(29 as u32), ctx.r[9].u8 ) };
	// 827FF698: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF69C: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FF6A0: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF6A4: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827FF6A8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF6AC: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 827FF6B0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FF6B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827FF6B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF6BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF6C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF6C8 size=304
    let mut pc: u32 = 0x827FF6C8;
    'dispatch: loop {
        match pc {
            0x827FF6C8 => {
    //   block [0x827FF6C8..0x827FF6FC)
	// 827FF6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF6D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FF6D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF6D8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF6DC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF6E0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FF6E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF6E8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF6EC: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FF6F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FF6F4: 409A0030  bne cr6, 0x827ff724
	if !ctx.cr[6].eq {
	pc = 0x827FF724; continue 'dispatch;
	}
	// 827FF6F8: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF6FC; continue 'dispatch;
            }
            0x827FF6FC => {
    //   block [0x827FF6FC..0x827FF710)
	// 827FF6FC: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF700: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FF704: 4098000C  bge cr6, 0x827ff710
	if !ctx.cr[6].lt {
	pc = 0x827FF710; continue 'dispatch;
	}
	// 827FF708: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF70C: 4800000C  b 0x827ff718
	pc = 0x827FF718; continue 'dispatch;
            }
            0x827FF710 => {
    //   block [0x827FF710..0x827FF718)
	// 827FF710: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FF714: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF718; continue 'dispatch;
            }
            0x827FF718 => {
    //   block [0x827FF718..0x827FF724)
	// 827FF718: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FF71C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FF720: 419AFFDC  beq cr6, 0x827ff6fc
	if ctx.cr[6].eq {
	pc = 0x827FF6FC; continue 'dispatch;
	}
	pc = 0x827FF724; continue 'dispatch;
            }
            0x827FF724 => {
    //   block [0x827FF724..0x827FF750)
	// 827FF724: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF728: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827FF72C: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 827FF730: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FF734: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FF738: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FF73C: 419A0014  beq cr6, 0x827ff750
	if ctx.cr[6].eq {
	pc = 0x827FF750; continue 'dispatch;
	}
	// 827FF740: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF744: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF748: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827FF74C: 40980074  bge cr6, 0x827ff7c0
	if !ctx.cr[6].lt {
	pc = 0x827FF7C0; continue 'dispatch;
	}
	pc = 0x827FF750; continue 'dispatch;
            }
            0x827FF750 => {
    //   block [0x827FF750..0x827FF7C0)
	// 827FF750: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FF754: 4BB21435  bl 0x82320b88
	ctx.lr = 0x827FF758;
	sub_82320B88(ctx, base);
	// 827FF758: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF75C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 827FF760: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FF764: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 827FF768: 48001751  bl 0x82800eb8
	ctx.lr = 0x827FF76C;
	sub_82800EB8(ctx, base);
	// 827FF76C: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 827FF770: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF774: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FF778: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF77C: 4800069D  bl 0x827ffe18
	ctx.lr = 0x827FF780;
	sub_827FFE18(ctx, base);
	// 827FF780: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 827FF784: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 827FF788: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 827FF78C: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 827FF790: 48215601  bl 0x82a14d90
	ctx.lr = 0x827FF794;
	sub_82A14D90(ctx, base);
	// 827FF794: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 827FF798: 4BA1C5A1  bl 0x8221bd38
	ctx.lr = 0x827FF79C;
	sub_8221BD38(ctx, base);
	// 827FF79C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 827FF7A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 827FF7A4: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 827FF7A8: 482155E9  bl 0x82a14d90
	ctx.lr = 0x827FF7AC;
	sub_82A14D90(ctx, base);
	// 827FF7AC: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 827FF7B0: 4BA1C589  bl 0x8221bd38
	ctx.lr = 0x827FF7B4;
	sub_8221BD38(ctx, base);
	// 827FF7B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FF7B8: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FF7BC: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	pc = 0x827FF7C0; continue 'dispatch;
            }
            0x827FF7C0 => {
    //   block [0x827FF7C0..0x827FF7CC)
	// 827FF7C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FF7C4: 409A0008  bne cr6, 0x827ff7cc
	if !ctx.cr[6].eq {
	pc = 0x827FF7CC; continue 'dispatch;
	}
	// 827FF7C8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF7CC; continue 'dispatch;
            }
            0x827FF7CC => {
    //   block [0x827FF7CC..0x827FF7DC)
	// 827FF7CC: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF7D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FF7D4: 409A0008  bne cr6, 0x827ff7dc
	if !ctx.cr[6].eq {
	pc = 0x827FF7DC; continue 'dispatch;
	}
	// 827FF7D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FF7DC; continue 'dispatch;
            }
            0x827FF7DC => {
    //   block [0x827FF7DC..0x827FF7F8)
	// 827FF7DC: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 827FF7E0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FF7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF7EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FF7F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF7F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF7F8 size=104
    let mut pc: u32 = 0x827FF7F8;
    'dispatch: loop {
        match pc {
            0x827FF7F8 => {
    //   block [0x827FF7F8..0x827FF860)
	// 827FF7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF804: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF808: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF80C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FF810: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827FF814: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FF818: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827FF81C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF820: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF824: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FF828: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FF82C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FF830: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FF834: 48000E65  bl 0x82800698
	ctx.lr = 0x827FF838;
	sub_82800698(ctx, base);
	// 827FF838: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF83C: 4BA1C4FD  bl 0x8221bd38
	ctx.lr = 0x827FF840;
	sub_8221BD38(ctx, base);
	// 827FF840: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FF844: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FF848: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827FF84C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FF850: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF854: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF858: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF860 size=84
    let mut pc: u32 = 0x827FF860;
    'dispatch: loop {
        match pc {
            0x827FF860 => {
    //   block [0x827FF860..0x827FF8B4)
	// 827FF860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF868: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF86C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF874: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF878: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF87C: 480007BD  bl 0x82800038
	ctx.lr = 0x827FF880;
	sub_82800038(ctx, base);
	// 827FF880: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF884: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827FF888: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FF88C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF890: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FF894: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827FF898: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF89C: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 827FF8A0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827FF8A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FF8A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FF8AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FF8B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF8B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x827FF8B8 size=124
    let mut pc: u32 = 0x827FF8B8;
    'dispatch: loop {
        match pc {
            0x827FF8B8 => {
    //   block [0x827FF8B8..0x827FF8D0)
	// 827FF8B8: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF8BC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF8C0: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FF8C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FF8C8: 409A0030  bne cr6, 0x827ff8f8
	if !ctx.cr[6].eq {
	pc = 0x827FF8F8; continue 'dispatch;
	}
	// 827FF8CC: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF8D0; continue 'dispatch;
            }
            0x827FF8D0 => {
    //   block [0x827FF8D0..0x827FF8E4)
	// 827FF8D0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF8D4: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FF8D8: 4098000C  bge cr6, 0x827ff8e4
	if !ctx.cr[6].lt {
	pc = 0x827FF8E4; continue 'dispatch;
	}
	// 827FF8DC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF8E0: 4800000C  b 0x827ff8ec
	pc = 0x827FF8EC; continue 'dispatch;
            }
            0x827FF8E4 => {
    //   block [0x827FF8E4..0x827FF8EC)
	// 827FF8E4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FF8E8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF8EC; continue 'dispatch;
            }
            0x827FF8EC => {
    //   block [0x827FF8EC..0x827FF8F8)
	// 827FF8EC: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FF8F0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FF8F4: 419AFFDC  beq cr6, 0x827ff8d0
	if ctx.cr[6].eq {
	pc = 0x827FF8D0; continue 'dispatch;
	}
	pc = 0x827FF8F8; continue 'dispatch;
            }
            0x827FF8F8 => {
    //   block [0x827FF8F8..0x827FF934)
	// 827FF8F8: 81640004  lwz r11, 4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF8FC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 827FF900: 9081FFF0  stw r4, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u32 ) };
	// 827FF904: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FF908: 419A002C  beq cr6, 0x827ff934
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x827FF934);
		return;
	}
	// 827FF90C: 81250000  lwz r9, 0(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF910: 810A000C  lwz r8, 0xc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF914: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FF918: 4198001C  blt cr6, 0x827ff934
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x827FF934);
		return;
	}
	// 827FF91C: 3961FFF0  addi r11, r1, -0x10
	ctx.r[11].s64 = ctx.r[1].s64 + -16;
	// 827FF920: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF924: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF928: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827FF92C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FF930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FF958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FF958 size=300
    let mut pc: u32 = 0x827FF958;
    'dispatch: loop {
        match pc {
            0x827FF958 => {
    //   block [0x827FF958..0x827FF98C)
	// 827FF958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FF95C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FF960: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 827FF964: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FF968: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FF96C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FF970: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FF974: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF978: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF97C: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 827FF980: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FF984: 409A0030  bne cr6, 0x827ff9b4
	if !ctx.cr[6].eq {
	pc = 0x827FF9B4; continue 'dispatch;
	}
	// 827FF988: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF98C; continue 'dispatch;
            }
            0x827FF98C => {
    //   block [0x827FF98C..0x827FF9A0)
	// 827FF98C: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF990: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FF994: 4098000C  bge cr6, 0x827ff9a0
	if !ctx.cr[6].lt {
	pc = 0x827FF9A0; continue 'dispatch;
	}
	// 827FF998: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FF99C: 4800000C  b 0x827ff9a8
	pc = 0x827FF9A8; continue 'dispatch;
            }
            0x827FF9A0 => {
    //   block [0x827FF9A0..0x827FF9A8)
	// 827FF9A0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FF9A4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x827FF9A8; continue 'dispatch;
            }
            0x827FF9A8 => {
    //   block [0x827FF9A8..0x827FF9B4)
	// 827FF9A8: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 827FF9AC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FF9B0: 419AFFDC  beq cr6, 0x827ff98c
	if ctx.cr[6].eq {
	pc = 0x827FF98C; continue 'dispatch;
	}
	pc = 0x827FF9B4; continue 'dispatch;
            }
            0x827FF9B4 => {
    //   block [0x827FF9B4..0x827FF9E0)
	// 827FF9B4: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FF9B8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 827FF9BC: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 827FF9C0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FF9C4: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 827FF9C8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 827FF9CC: 419A0014  beq cr6, 0x827ff9e0
	if ctx.cr[6].eq {
	pc = 0x827FF9E0; continue 'dispatch;
	}
	// 827FF9D0: 811E0000  lwz r8, 0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF9D4: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FF9D8: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 827FF9DC: 40980070  bge cr6, 0x827ffa4c
	if !ctx.cr[6].lt {
	pc = 0x827FFA4C; continue 'dispatch;
	}
	pc = 0x827FF9E0; continue 'dispatch;
            }
            0x827FF9E0 => {
    //   block [0x827FF9E0..0x827FFA4C)
	// 827FF9E0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FF9E4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FF9E8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 827FF9EC: 48218535  bl 0x82a17f20
	ctx.lr = 0x827FF9F0;
	sub_82A17F20(ctx, base);
	// 827FF9F0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FF9F4: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 827FF9F8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FF9FC: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 827FFA00: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 827FFA04: 4821851D  bl 0x82a17f20
	ctx.lr = 0x827FFA08;
	sub_82A17F20(ctx, base);
	// 827FFA08: 38810064  addi r4, r1, 0x64
	ctx.r[4].s64 = ctx.r[1].s64 + 100;
	// 827FFA0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FFA10: 48000349  bl 0x827ffd58
	ctx.lr = 0x827FFA14;
	sub_827FFD58(ctx, base);
	// 827FFA14: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 827FFA18: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFA1C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FFA20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FFA24: 48000685  bl 0x828000a8
	ctx.lr = 0x827FFA28;
	sub_828000A8(ctx, base);
	// 827FFA28: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 827FFA2C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 827FFA30: E8E80000  ld r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 827FFA34: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 827FFA38: 4BEDA021  bl 0x826d9a58
	ctx.lr = 0x827FFA3C;
	sub_826D9A58(ctx, base);
	// 827FFA3C: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 827FFA40: 4BEDA019  bl 0x826d9a58
	ctx.lr = 0x827FFA44;
	sub_826D9A58(ctx, base);
	// 827FFA44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FFA48: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x827FFA4C; continue 'dispatch;
            }
            0x827FFA4C => {
    //   block [0x827FFA4C..0x827FFA58)
	// 827FFA4C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 827FFA50: 409A0008  bne cr6, 0x827ffa58
	if !ctx.cr[6].eq {
	pc = 0x827FFA58; continue 'dispatch;
	}
	// 827FFA54: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFA58; continue 'dispatch;
            }
            0x827FFA58 => {
    //   block [0x827FFA58..0x827FFA68)
	// 827FFA58: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFA5C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFA60: 409A0008  bne cr6, 0x827ffa68
	if !ctx.cr[6].eq {
	pc = 0x827FFA68; continue 'dispatch;
	}
	// 827FFA64: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFA68; continue 'dispatch;
            }
            0x827FFA68 => {
    //   block [0x827FFA68..0x827FFA84)
	// 827FFA68: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 827FFA6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FFA70: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FFA74: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FFA78: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 827FFA7C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FFA80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FFA88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FFA88 size=104
    let mut pc: u32 = 0x827FFA88;
    'dispatch: loop {
        match pc {
            0x827FFA88 => {
    //   block [0x827FFA88..0x827FFAF0)
	// 827FFA88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FFA8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FFA90: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FFA94: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FFA98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FFA9C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 827FFAA0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 827FFAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFAA8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 827FFAAC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFAB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFAB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FFAB8: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 827FFABC: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 827FFAC0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 827FFAC4: 48001075  bl 0x82800b38
	ctx.lr = 0x827FFAC8;
	sub_82800B38(ctx, base);
	// 827FFAC8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFACC: 4BA1C26D  bl 0x8221bd38
	ctx.lr = 0x827FFAD0;
	sub_8221BD38(ctx, base);
	// 827FFAD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FFAD4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 827FFAD8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827FFADC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FFAE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FFAE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FFAE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FFAEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FFAF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FFAF0 size=84
    let mut pc: u32 = 0x827FFAF0;
    'dispatch: loop {
        match pc {
            0x827FFAF0 => {
    //   block [0x827FFAF0..0x827FFB44)
	// 827FFAF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FFAF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 827FFAF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 827FFAFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FFB00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FFB04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB08: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB0C: 480007BD  bl 0x828002c8
	ctx.lr = 0x827FFB10;
	sub_828002C8(ctx, base);
	// 827FFB10: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB14: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 827FFB18: 91290004  stw r9, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FFB1C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB20: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FFB24: 91080000  stw r8, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 827FFB28: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB2C: 90E70008  stw r7, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 827FFB30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 827FFB34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 827FFB38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 827FFB3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 827FFB40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FFB48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FFB48 size=524
    let mut pc: u32 = 0x827FFB48;
    'dispatch: loop {
        match pc {
            0x827FFB48 => {
    //   block [0x827FFB48..0x827FFB90)
	// 827FFB48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FFB4C: 484A98B9  bl 0x82ca9404
	ctx.lr = 0x827FFB50;
	sub_82CA93D0(ctx, base);
	// 827FFB50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FFB54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827FFB58: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 827FFB5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FFB60: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 827FFB64: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827FFB68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFB6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFB70: 409A0020  bne cr6, 0x827ffb90
	if !ctx.cr[6].eq {
	pc = 0x827FFB90; continue 'dispatch;
	}
	// 827FFB74: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFB78: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFB80: 4BB6B9F1  bl 0x8236b570
	ctx.lr = 0x827FFB84;
	sub_8236B570(ctx, base);
	// 827FFB84: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFB88: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFB8C: 484A98C8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFB90 => {
    //   block [0x827FFB90..0x827FFBAC)
	// 827FFB90: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFB94: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 827FFB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFB9C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFBA0: 419A000C  beq cr6, 0x827ffbac
	if ctx.cr[6].eq {
	pc = 0x827FFBAC; continue 'dispatch;
	}
	// 827FFBA4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFBA8: 419A0008  beq cr6, 0x827ffbb0
	if ctx.cr[6].eq {
	pc = 0x827FFBB0; continue 'dispatch;
	}
	pc = 0x827FFBAC; continue 'dispatch;
            }
            0x827FFBAC => {
    //   block [0x827FFBAC..0x827FFBB0)
	// 827FFBAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFBB0; continue 'dispatch;
            }
            0x827FFBB0 => {
    //   block [0x827FFBB0..0x827FFBF0)
	// 827FFBB0: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 827FFBB4: 7F1C4840  cmplw cr6, r28, r9
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FFBB8: 409A0038  bne cr6, 0x827ffbf0
	if !ctx.cr[6].eq {
	pc = 0x827FFBF0; continue 'dispatch;
	}
	// 827FFBBC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFBC0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFBC4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFBC8: 4098015C  bge cr6, 0x827ffd24
	if !ctx.cr[6].lt {
	pc = 0x827FFD24; continue 'dispatch;
	}
	// 827FFBCC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFBD0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 827FFBD4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFBD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFBDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFBE0: 4BB6B991  bl 0x8236b570
	ctx.lr = 0x827FFBE4;
	sub_8236B570(ctx, base);
	// 827FFBE4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFBE8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFBEC: 484A9868  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFBF0 => {
    //   block [0x827FFBF0..0x827FFC00)
	// 827FFBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFBF4: 419A000C  beq cr6, 0x827ffc00
	if ctx.cr[6].eq {
	pc = 0x827FFC00; continue 'dispatch;
	}
	// 827FFBF8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFBFC: 419A0008  beq cr6, 0x827ffc04
	if ctx.cr[6].eq {
	pc = 0x827FFC04; continue 'dispatch;
	}
	pc = 0x827FFC00; continue 'dispatch;
            }
            0x827FFC00 => {
    //   block [0x827FFC00..0x827FFC04)
	// 827FFC00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFC04; continue 'dispatch;
            }
            0x827FFC04 => {
    //   block [0x827FFC04..0x827FFC40)
	// 827FFC04: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFC08: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFC0C: 409A0034  bne cr6, 0x827ffc40
	if !ctx.cr[6].eq {
	pc = 0x827FFC40; continue 'dispatch;
	}
	// 827FFC10: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFC14: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFC18: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFC1C: 40980108  bge cr6, 0x827ffd24
	if !ctx.cr[6].lt {
	pc = 0x827FFD24; continue 'dispatch;
	}
	// 827FFC20: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFC24: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827FFC28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFC2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFC30: 4BB6B941  bl 0x8236b570
	ctx.lr = 0x827FFC34;
	sub_8236B570(ctx, base);
	// 827FFC34: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFC38: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFC3C: 484A9818  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFC40 => {
    //   block [0x827FFC40..0x827FFC8C)
	// 827FFC40: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFC44: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFC48: 40980058  bge cr6, 0x827ffca0
	if !ctx.cr[6].lt {
	pc = 0x827FFCA0; continue 'dispatch;
	}
	// 827FFC4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FFC50: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 827FFC54: 4BE608F5  bl 0x82660548
	ctx.lr = 0x827FFC58;
	sub_82660548(ctx, base);
	// 827FFC58: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FFC5C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFC60: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFC64: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFC68: 40980038  bge cr6, 0x827ffca0
	if !ctx.cr[6].lt {
	pc = 0x827FFCA0; continue 'dispatch;
	}
	// 827FFC6C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFC70: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFC74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFC78: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFC7C: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFC80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FFC84: 409A008C  bne cr6, 0x827ffd10
	if !ctx.cr[6].eq {
	pc = 0x827FFD10; continue 'dispatch;
	}
	// 827FFC88: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x827FFC8C; continue 'dispatch;
            }
            0x827FFC8C => {
    //   block [0x827FFC8C..0x827FFCA0)
	// 827FFC8C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFC90: 4BB6B8E1  bl 0x8236b570
	ctx.lr = 0x827FFC94;
	sub_8236B570(ctx, base);
	// 827FFC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFC98: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFC9C: 484A97B8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFCA0 => {
    //   block [0x827FFCA0..0x827FFCD0)
	// 827FFCA0: 815C000C  lwz r10, 0xc(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFCA4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFCA8: 4098007C  bge cr6, 0x827ffd24
	if !ctx.cr[6].lt {
	pc = 0x827FFD24; continue 'dispatch;
	}
	// 827FFCAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FFCB0: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 827FFCB4: 837F0004  lwz r27, 4(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFCB8: 4BC3D139  bl 0x8243cdf0
	ctx.lr = 0x827FFCBC;
	sub_8243CDF0(ctx, base);
	// 827FFCBC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 827FFCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFCC4: 419A000C  beq cr6, 0x827ffcd0
	if ctx.cr[6].eq {
	pc = 0x827FFCD0; continue 'dispatch;
	}
	// 827FFCC8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFCCC: 419A0008  beq cr6, 0x827ffcd4
	if ctx.cr[6].eq {
	pc = 0x827FFCD4; continue 'dispatch;
	}
	pc = 0x827FFCD0; continue 'dispatch;
            }
            0x827FFCD0 => {
    //   block [0x827FFCD0..0x827FFCD4)
	// 827FFCD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFCD4; continue 'dispatch;
            }
            0x827FFCD4 => {
    //   block [0x827FFCD4..0x827FFCF0)
	// 827FFCD4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FFCD8: 7F06D840  cmplw cr6, r6, r27
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[27].u32, &mut ctx.xer);
	// 827FFCDC: 419A0014  beq cr6, 0x827ffcf0
	if ctx.cr[6].eq {
	pc = 0x827FFCF0; continue 'dispatch;
	}
	// 827FFCE0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFCE4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFCE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFCEC: 40980038  bge cr6, 0x827ffd24
	if !ctx.cr[6].lt {
	pc = 0x827FFD24; continue 'dispatch;
	}
	pc = 0x827FFCF0; continue 'dispatch;
            }
            0x827FFCF0 => {
    //   block [0x827FFCF0..0x827FFD10)
	// 827FFCF0: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFCF4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFCF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFCFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFD00: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFD04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FFD08: 419AFF84  beq cr6, 0x827ffc8c
	if ctx.cr[6].eq {
	pc = 0x827FFC8C; continue 'dispatch;
	}
	// 827FFD0C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x827FFD10; continue 'dispatch;
            }
            0x827FFD10 => {
    //   block [0x827FFD10..0x827FFD24)
	// 827FFD10: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827FFD14: 4BB6B85D  bl 0x8236b570
	ctx.lr = 0x827FFD18;
	sub_8236B570(ctx, base);
	// 827FFD18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFD1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFD20: 484A9734  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFD24 => {
    //   block [0x827FFD24..0x827FFD54)
	// 827FFD24: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827FFD28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFD2C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FFD30: 48000631  bl 0x82800360
	ctx.lr = 0x827FFD34;
	sub_82800360(ctx, base);
	// 827FFD34: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 827FFD38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFD3C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFD40: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827FFD44: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD48: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 827FFD4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 827FFD50: 484A9704  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FFD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FFD58 size=188
    let mut pc: u32 = 0x827FFD58;
    'dispatch: loop {
        match pc {
            0x827FFD58 => {
    //   block [0x827FFD58..0x827FFDB0)
	// 827FFD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FFD5C: 484A96B1  bl 0x82ca940c
	ctx.lr = 0x827FFD60;
	sub_82CA93D0(ctx, base);
	// 827FFD60: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FFD64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 827FFD68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 827FFD6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD70: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 827FFD78: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD7C: 48000725  bl 0x828004a0
	ctx.lr = 0x827FFD80;
	sub_828004A0(ctx, base);
	// 827FFD80: 907D0004  stw r3, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 827FFD84: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD88: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFD8C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827FFD90: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFD94: 890A0019  lbz r8, 0x19(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFD98: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FFD9C: 409A0064  bne cr6, 0x827ffe00
	if !ctx.cr[6].eq {
	pc = 0x827FFE00; continue 'dispatch;
	}
	// 827FFDA0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFDA4: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFDA8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FFDAC: 409A0018  bne cr6, 0x827ffdc4
	if !ctx.cr[6].eq {
	pc = 0x827FFDC4; continue 'dispatch;
	}
	pc = 0x827FFDB0; continue 'dispatch;
            }
            0x827FFDB0 => {
    //   block [0x827FFDB0..0x827FFDC4)
	// 827FFDB0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FFDB4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFDB8: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFDBC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FFDC0: 419AFFF0  beq cr6, 0x827ffdb0
	if ctx.cr[6].eq {
	pc = 0x827FFDB0; continue 'dispatch;
	}
	pc = 0x827FFDC4; continue 'dispatch;
            }
            0x827FFDC4 => {
    //   block [0x827FFDC4..0x827FFDE0)
	// 827FFDC4: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 827FFDC8: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFDCC: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFDD0: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFDD4: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFDD8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FFDDC: 409A0018  bne cr6, 0x827ffdf4
	if !ctx.cr[6].eq {
	pc = 0x827FFDF4; continue 'dispatch;
	}
	pc = 0x827FFDE0; continue 'dispatch;
            }
            0x827FFDE0 => {
    //   block [0x827FFDE0..0x827FFDF4)
	// 827FFDE0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 827FFDE4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFDE8: 890B0019  lbz r8, 0x19(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 827FFDEC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 827FFDF0: 419AFFF0  beq cr6, 0x827ffde0
	if ctx.cr[6].eq {
	pc = 0x827FFDE0; continue 'dispatch;
	}
	pc = 0x827FFDF4; continue 'dispatch;
            }
            0x827FFDF4 => {
    //   block [0x827FFDF4..0x827FFE00)
	// 827FFDF4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 827FFDF8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FFDFC: 484A9660  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFE00 => {
    //   block [0x827FFE00..0x827FFE14)
	// 827FFE00: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 827FFE04: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFE08: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 827FFE0C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 827FFE10: 484A964C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_827FFE18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x827FFE18 size=540
    let mut pc: u32 = 0x827FFE18;
    'dispatch: loop {
        match pc {
            0x827FFE18 => {
    //   block [0x827FFE18..0x827FFE6C)
	// 827FFE18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 827FFE1C: 484A95E9  bl 0x82ca9404
	ctx.lr = 0x827FFE20;
	sub_82CA93D0(ctx, base);
	// 827FFE20: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 827FFE24: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 827FFE28: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 827FFE2C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 827FFE30: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 827FFE34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 827FFE38: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 827FFE3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 827FFE40: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFE44: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 827FFE48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FFE4C: 409A0020  bne cr6, 0x827ffe6c
	if !ctx.cr[6].eq {
	pc = 0x827FFE6C; continue 'dispatch;
	}
	// 827FFE50: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFE54: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFE58: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFE5C: 48000925  bl 0x82800780
	ctx.lr = 0x827FFE60;
	sub_82800780(ctx, base);
	// 827FFE60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFE64: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FFE68: 484A95EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFE6C => {
    //   block [0x827FFE6C..0x827FFE88)
	// 827FFE6C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFE70: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 827FFE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFE78: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFE7C: 419A000C  beq cr6, 0x827ffe88
	if ctx.cr[6].eq {
	pc = 0x827FFE88; continue 'dispatch;
	}
	// 827FFE80: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFE84: 419A0008  beq cr6, 0x827ffe8c
	if ctx.cr[6].eq {
	pc = 0x827FFE8C; continue 'dispatch;
	}
	pc = 0x827FFE88; continue 'dispatch;
            }
            0x827FFE88 => {
    //   block [0x827FFE88..0x827FFE8C)
	// 827FFE88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFE8C; continue 'dispatch;
            }
            0x827FFE8C => {
    //   block [0x827FFE8C..0x827FFECC)
	// 827FFE8C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 827FFE90: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 827FFE94: 409A0038  bne cr6, 0x827ffecc
	if !ctx.cr[6].eq {
	pc = 0x827FFECC; continue 'dispatch;
	}
	// 827FFE98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFE9C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFEA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFEA4: 40980160  bge cr6, 0x82800004
	if !ctx.cr[6].lt {
	pc = 0x82800004; continue 'dispatch;
	}
	// 827FFEA8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFEAC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 827FFEB0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFEB4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFEB8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFEBC: 480008C5  bl 0x82800780
	ctx.lr = 0x827FFEC0;
	sub_82800780(ctx, base);
	// 827FFEC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFEC4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FFEC8: 484A958C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFECC => {
    //   block [0x827FFECC..0x827FFEDC)
	// 827FFECC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFED0: 419A000C  beq cr6, 0x827ffedc
	if ctx.cr[6].eq {
	pc = 0x827FFEDC; continue 'dispatch;
	}
	// 827FFED4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFED8: 419A0008  beq cr6, 0x827ffee0
	if ctx.cr[6].eq {
	pc = 0x827FFEE0; continue 'dispatch;
	}
	pc = 0x827FFEDC; continue 'dispatch;
            }
            0x827FFEDC => {
    //   block [0x827FFEDC..0x827FFEE0)
	// 827FFEDC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFEE0; continue 'dispatch;
            }
            0x827FFEE0 => {
    //   block [0x827FFEE0..0x827FFF1C)
	// 827FFEE0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFEE4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFEE8: 409A0034  bne cr6, 0x827fff1c
	if !ctx.cr[6].eq {
	pc = 0x827FFF1C; continue 'dispatch;
	}
	// 827FFEEC: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFEF0: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFEF4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFEF8: 4098010C  bge cr6, 0x82800004
	if !ctx.cr[6].lt {
	pc = 0x82800004; continue 'dispatch;
	}
	// 827FFEFC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFF00: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827FFF04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFF08: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFF0C: 48000875  bl 0x82800780
	ctx.lr = 0x827FFF10;
	sub_82800780(ctx, base);
	// 827FFF10: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFF14: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FFF18: 484A953C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFF1C => {
    //   block [0x827FFF1C..0x827FFF68)
	// 827FFF1C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFF20: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFF24: 40980058  bge cr6, 0x827fff7c
	if !ctx.cr[6].lt {
	pc = 0x827FFF7C; continue 'dispatch;
	}
	// 827FFF28: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FFF2C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 827FFF30: 48002CE1  bl 0x82802c10
	ctx.lr = 0x827FFF34;
	sub_82802C10(ctx, base);
	// 827FFF34: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FFF38: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFF3C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFF40: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFF44: 40980038  bge cr6, 0x827fff7c
	if !ctx.cr[6].lt {
	pc = 0x827FFF7C; continue 'dispatch;
	}
	// 827FFF48: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFF4C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFF50: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFF54: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFF58: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FFF5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FFF60: 409A0090  bne cr6, 0x827ffff0
	if !ctx.cr[6].eq {
	pc = 0x827FFFF0; continue 'dispatch;
	}
	// 827FFF64: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x827FFF68; continue 'dispatch;
            }
            0x827FFF68 => {
    //   block [0x827FFF68..0x827FFF7C)
	// 827FFF68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 827FFF6C: 48000815  bl 0x82800780
	ctx.lr = 0x827FFF70;
	sub_82800780(ctx, base);
	// 827FFF70: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFF74: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 827FFF78: 484A94DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x827FFF7C => {
    //   block [0x827FFF7C..0x827FFFAC)
	// 827FFF7C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFF80: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 827FFF84: 40980080  bge cr6, 0x82800004
	if !ctx.cr[6].lt {
	pc = 0x82800004; continue 'dispatch;
	}
	// 827FFF88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 827FFF8C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 827FFF90: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFF94: 4829C585  bl 0x82a9c518
	ctx.lr = 0x827FFF98;
	sub_82A9C518(ctx, base);
	// 827FFF98: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFF9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 827FFFA0: 419A000C  beq cr6, 0x827fffac
	if ctx.cr[6].eq {
	pc = 0x827FFFAC; continue 'dispatch;
	}
	// 827FFFA4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 827FFFA8: 419A0008  beq cr6, 0x827fffb0
	if ctx.cr[6].eq {
	pc = 0x827FFFB0; continue 'dispatch;
	}
	pc = 0x827FFFAC; continue 'dispatch;
            }
            0x827FFFAC => {
    //   block [0x827FFFAC..0x827FFFB0)
	// 827FFFAC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x827FFFB0; continue 'dispatch;
            }
            0x827FFFB0 => {
    //   block [0x827FFFB0..0x827FFFD0)
	// 827FFFB0: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 827FFFB4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 827FFFB8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 827FFFBC: 419A0014  beq cr6, 0x827fffd0
	if ctx.cr[6].eq {
	pc = 0x827FFFD0; continue 'dispatch;
	}
	// 827FFFC0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 827FFFC4: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 827FFFC8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 827FFFCC: 40980038  bge cr6, 0x82800004
	if !ctx.cr[6].lt {
	pc = 0x82800004; continue 'dispatch;
	}
	pc = 0x827FFFD0; continue 'dispatch;
            }
            0x827FFFD0 => {
    //   block [0x827FFFD0..0x827FFFF0)
	// 827FFFD0: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 827FFFD4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 827FFFD8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 827FFFDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFFE0: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 827FFFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 827FFFE8: 419AFF80  beq cr6, 0x827fff68
	if ctx.cr[6].eq {
	pc = 0x827FFF68; continue 'dispatch;
	}
	// 827FFFEC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x827FFFF0; continue 'dispatch;
            }
            0x827FFFF0 => {
    //   block [0x827FFFF0..0x82800004)
	// 827FFFF0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 827FFFF4: 4800078D  bl 0x82800780
	ctx.lr = 0x827FFFF8;
	sub_82800780(ctx, base);
	// 827FFFF8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 827FFFFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82800000: 484A9454  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800004 => {
    //   block [0x82800004..0x82800034)
	// 82800004: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82800008: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8280000C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82800010: 48000549  bl 0x82800558
	ctx.lr = 0x82800014;
	sub_82800558(ctx, base);
	// 82800014: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800018: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280001C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800020: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800024: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800028: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8280002C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82800030: 484A9424  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800038(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800038 size=108
    let mut pc: u32 = 0x82800038;
    'dispatch: loop {
        match pc {
            0x82800038 => {
    //   block [0x82800038..0x82800060)
	// 82800038: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280003C: 484A93CD  bl 0x82ca9408
	ctx.lr = 0x82800040;
	sub_82CA93D0(ctx, base);
	// 82800040: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800044: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82800048: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8280004C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82800050: 897F001D  lbz r11, 0x1d(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(29 as u32) ) } as u64;
	// 82800054: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800058: 409A0044  bne cr6, 0x8280009c
	if !ctx.cr[6].eq {
	pc = 0x8280009C; continue 'dispatch;
	}
	// 8280005C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x82800060; continue 'dispatch;
            }
            0x82800060 => {
    //   block [0x82800060..0x8280009C)
	// 82800060: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82800064: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800068: 4BFFFFD1  bl 0x82800038
	ctx.lr = 0x8280006C;
	sub_82800038(ctx, base);
	// 8280006C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 82800070: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800074: 48214D1D  bl 0x82a14d90
	ctx.lr = 0x82800078;
	sub_82A14D90(ctx, base);
	// 82800078: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280007C: 4BA1BCBD  bl 0x8221bd38
	ctx.lr = 0x82800080;
	sub_8221BD38(ctx, base);
	// 82800080: 939F0014  stw r28, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[28].u32 ) };
	// 82800084: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82800088: 4BA1BCB1  bl 0x8221bd38
	ctx.lr = 0x8280008C;
	sub_8221BD38(ctx, base);
	// 8280008C: 897E001D  lbz r11, 0x1d(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(29 as u32) ) } as u64;
	// 82800090: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82800094: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800098: 419AFFC8  beq cr6, 0x82800060
	if ctx.cr[6].eq {
	pc = 0x82800060; continue 'dispatch;
	}
	pc = 0x8280009C; continue 'dispatch;
            }
            0x8280009C => {
    //   block [0x8280009C..0x828000A4)
	// 8280009C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828000A0: 484A93B8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828000A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828000A8 size=540
    let mut pc: u32 = 0x828000A8;
    'dispatch: loop {
        match pc {
            0x828000A8 => {
    //   block [0x828000A8..0x828000FC)
	// 828000A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828000AC: 484A9359  bl 0x82ca9404
	ctx.lr = 0x828000B0;
	sub_82CA93D0(ctx, base);
	// 828000B0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828000B4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828000B8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828000BC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 828000C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828000C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828000C8: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 828000CC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 828000D0: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828000D4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 828000D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828000DC: 409A0020  bne cr6, 0x828000fc
	if !ctx.cr[6].eq {
	pc = 0x828000FC; continue 'dispatch;
	}
	// 828000E0: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828000E4: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828000E8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828000EC: 48000B35  bl 0x82800c20
	ctx.lr = 0x828000F0;
	sub_82800C20(ctx, base);
	// 828000F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828000F4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828000F8: 484A935C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828000FC => {
    //   block [0x828000FC..0x82800118)
	// 828000FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800100: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82800104: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800108: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280010C: 419A000C  beq cr6, 0x82800118
	if ctx.cr[6].eq {
	pc = 0x82800118; continue 'dispatch;
	}
	// 82800110: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82800114: 419A0008  beq cr6, 0x8280011c
	if ctx.cr[6].eq {
	pc = 0x8280011C; continue 'dispatch;
	}
	pc = 0x82800118; continue 'dispatch;
            }
            0x82800118 => {
    //   block [0x82800118..0x8280011C)
	// 82800118: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8280011C; continue 'dispatch;
            }
            0x8280011C => {
    //   block [0x8280011C..0x8280015C)
	// 8280011C: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82800120: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82800124: 409A0038  bne cr6, 0x8280015c
	if !ctx.cr[6].eq {
	pc = 0x8280015C; continue 'dispatch;
	}
	// 82800128: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280012C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800130: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800134: 40980160  bge cr6, 0x82800294
	if !ctx.cr[6].lt {
	pc = 0x82800294; continue 'dispatch;
	}
	// 82800138: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8280013C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82800140: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82800144: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82800148: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280014C: 48000AD5  bl 0x82800c20
	ctx.lr = 0x82800150;
	sub_82800C20(ctx, base);
	// 82800150: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800154: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82800158: 484A92FC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280015C => {
    //   block [0x8280015C..0x8280016C)
	// 8280015C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800160: 419A000C  beq cr6, 0x8280016c
	if ctx.cr[6].eq {
	pc = 0x8280016C; continue 'dispatch;
	}
	// 82800164: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82800168: 419A0008  beq cr6, 0x82800170
	if ctx.cr[6].eq {
	pc = 0x82800170; continue 'dispatch;
	}
	pc = 0x8280016C; continue 'dispatch;
            }
            0x8280016C => {
    //   block [0x8280016C..0x82800170)
	// 8280016C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82800170; continue 'dispatch;
            }
            0x82800170 => {
    //   block [0x82800170..0x828001AC)
	// 82800170: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800174: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800178: 409A0034  bne cr6, 0x828001ac
	if !ctx.cr[6].eq {
	pc = 0x828001AC; continue 'dispatch;
	}
	// 8280017C: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800180: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800184: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800188: 4098010C  bge cr6, 0x82800294
	if !ctx.cr[6].lt {
	pc = 0x82800294; continue 'dispatch;
	}
	// 8280018C: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82800190: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82800194: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82800198: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280019C: 48000A85  bl 0x82800c20
	ctx.lr = 0x828001A0;
	sub_82800C20(ctx, base);
	// 828001A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828001A4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828001A8: 484A92AC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828001AC => {
    //   block [0x828001AC..0x828001F8)
	// 828001AC: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 828001B0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828001B4: 40980058  bge cr6, 0x8280020c
	if !ctx.cr[6].lt {
	pc = 0x8280020C; continue 'dispatch;
	}
	// 828001B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828001BC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 828001C0: 4BB7E221  bl 0x8237e3e0
	ctx.lr = 0x828001C4;
	sub_8237E3E0(ctx, base);
	// 828001C4: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 828001C8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828001CC: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 828001D0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828001D4: 40980038  bge cr6, 0x8280020c
	if !ctx.cr[6].lt {
	pc = 0x8280020C; continue 'dispatch;
	}
	// 828001D8: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828001DC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 828001E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828001E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828001E8: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828001EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828001F0: 409A0090  bne cr6, 0x82800280
	if !ctx.cr[6].eq {
	pc = 0x82800280; continue 'dispatch;
	}
	// 828001F4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x828001F8; continue 'dispatch;
            }
            0x828001F8 => {
    //   block [0x828001F8..0x8280020C)
	// 828001F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828001FC: 48000A25  bl 0x82800c20
	ctx.lr = 0x82800200;
	sub_82800C20(ctx, base);
	// 82800200: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800204: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82800208: 484A924C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280020C => {
    //   block [0x8280020C..0x8280023C)
	// 8280020C: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800210: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800214: 40980080  bge cr6, 0x82800294
	if !ctx.cr[6].lt {
	pc = 0x82800294; continue 'dispatch;
	}
	// 82800218: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280021C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82800220: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800224: 4BB14905  bl 0x82314b28
	ctx.lr = 0x82800228;
	sub_82314B28(ctx, base);
	// 82800228: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280022C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800230: 419A000C  beq cr6, 0x8280023c
	if ctx.cr[6].eq {
	pc = 0x8280023C; continue 'dispatch;
	}
	// 82800234: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82800238: 419A0008  beq cr6, 0x82800240
	if ctx.cr[6].eq {
	pc = 0x82800240; continue 'dispatch;
	}
	pc = 0x8280023C; continue 'dispatch;
            }
            0x8280023C => {
    //   block [0x8280023C..0x82800240)
	// 8280023C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82800240; continue 'dispatch;
            }
            0x82800240 => {
    //   block [0x82800240..0x82800260)
	// 82800240: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800244: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82800248: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8280024C: 419A0014  beq cr6, 0x82800260
	if ctx.cr[6].eq {
	pc = 0x82800260; continue 'dispatch;
	}
	// 82800250: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800254: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800258: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8280025C: 40980038  bge cr6, 0x82800294
	if !ctx.cr[6].lt {
	pc = 0x82800294; continue 'dispatch;
	}
	pc = 0x82800260; continue 'dispatch;
            }
            0x82800260 => {
    //   block [0x82800260..0x82800280)
	// 82800260: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800264: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82800268: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8280026C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800270: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800278: 419AFF80  beq cr6, 0x828001f8
	if ctx.cr[6].eq {
	pc = 0x828001F8; continue 'dispatch;
	}
	// 8280027C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82800280; continue 'dispatch;
            }
            0x82800280 => {
    //   block [0x82800280..0x82800294)
	// 82800280: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82800284: 4800099D  bl 0x82800c20
	ctx.lr = 0x82800288;
	sub_82800C20(ctx, base);
	// 82800288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280028C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82800290: 484A91C4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800294 => {
    //   block [0x82800294..0x828002C4)
	// 82800294: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82800298: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8280029C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828002A0: 48000759  bl 0x828009f8
	ctx.lr = 0x828002A4;
	sub_828009F8(ctx, base);
	// 828002A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828002A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828002AC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828002B0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828002B4: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828002B8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828002BC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828002C0: 484A9194  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828002C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828002C8 size=148
    let mut pc: u32 = 0x828002C8;
    'dispatch: loop {
        match pc {
            0x828002C8 => {
    //   block [0x828002C8..0x828002F0)
	// 828002C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828002CC: 484A913D  bl 0x82ca9408
	ctx.lr = 0x828002D0;
	sub_82CA93D0(ctx, base);
	// 828002D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828002D4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828002D8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828002DC: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 828002E0: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 828002E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828002E8: 409A006C  bne cr6, 0x82800354
	if !ctx.cr[6].eq {
	pc = 0x82800354; continue 'dispatch;
	}
	// 828002EC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828002F0; continue 'dispatch;
            }
            0x828002F0 => {
    //   block [0x828002F0..0x82800354)
	// 828002F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828002F4: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828002F8: 4BFFFFD1  bl 0x828002c8
	ctx.lr = 0x828002FC;
	sub_828002C8(ctx, base);
	// 828002FC: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82800300: 389F0014  addi r4, r31, 0x14
	ctx.r[4].s64 = ctx.r[31].s64 + 20;
	// 82800304: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82800308: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 8280030C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82800310: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800314: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82800318: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8280031C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82800320: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82800324: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800328: 4BAF04E1  bl 0x822f0808
	ctx.lr = 0x8280032C;
	sub_822F0808(ctx, base);
	// 8280032C: 807F0018  lwz r3, 0x18(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 82800330: 4BA1BA09  bl 0x8221bd38
	ctx.lr = 0x82800334;
	sub_8221BD38(ctx, base);
	// 82800334: 93BF0018  stw r29, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 82800338: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280033C: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82800340: 4BA1B9F9  bl 0x8221bd38
	ctx.lr = 0x82800344;
	sub_8221BD38(ctx, base);
	// 82800344: 893E0021  lbz r9, 0x21(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800348: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 8280034C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800350: 419AFFA0  beq cr6, 0x828002f0
	if ctx.cr[6].eq {
	pc = 0x828002F0; continue 'dispatch;
	}
	pc = 0x82800354; continue 'dispatch;
            }
            0x82800354 => {
    //   block [0x82800354..0x8280035C)
	// 82800354: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800358: 484A9100  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82800360 size=316
    let mut pc: u32 = 0x82800360;
    'dispatch: loop {
        match pc {
            0x82800360 => {
    //   block [0x82800360..0x82800398)
	// 82800360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800364: 484A909D  bl 0x82ca9400
	ctx.lr = 0x82800368;
	sub_82CA93D0(ctx, base);
	// 82800368: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280036C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82800370: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82800374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82800378: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8280037C: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82800380: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800384: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800388: 894B0019  lbz r10, 0x19(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 8280038C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800390: 409A003C  bne cr6, 0x828003cc
	if !ctx.cr[6].eq {
	pc = 0x828003CC; continue 'dispatch;
	}
	// 82800394: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82800398; continue 'dispatch;
            }
            0x82800398 => {
    //   block [0x82800398..0x828003BC)
	// 82800398: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8280039C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828003A0: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828003A4: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 828003A8: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 828003AC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828003B0: 419A000C  beq cr6, 0x828003bc
	if ctx.cr[6].eq {
	pc = 0x828003BC; continue 'dispatch;
	}
	// 828003B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828003B8: 48000008  b 0x828003c0
	pc = 0x828003C0; continue 'dispatch;
            }
            0x828003BC => {
    //   block [0x828003BC..0x828003C0)
	// 828003BC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828003C0; continue 'dispatch;
            }
            0x828003C0 => {
    //   block [0x828003C0..0x828003CC)
	// 828003C0: 892B0019  lbz r9, 0x19(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 828003C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828003C8: 419AFFD0  beq cr6, 0x82800398
	if ctx.cr[6].eq {
	pc = 0x82800398; continue 'dispatch;
	}
	pc = 0x828003CC; continue 'dispatch;
            }
            0x828003CC => {
    //   block [0x828003CC..0x8280042C)
	// 828003CC: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828003D0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828003D4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828003D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828003DC: 419A0054  beq cr6, 0x82800430
	if ctx.cr[6].eq {
	pc = 0x82800430; continue 'dispatch;
	}
	// 828003E0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828003E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828003E8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828003EC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828003F0: 409A003C  bne cr6, 0x8280042c
	if !ctx.cr[6].eq {
	pc = 0x8280042C; continue 'dispatch;
	}
	// 828003F4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828003F8: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828003FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82800400: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82800404: 4BB6B16D  bl 0x8236b570
	ctx.lr = 0x82800408;
	sub_8236B570(ctx, base);
	// 82800408: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8280040C: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82800410: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800414: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800418: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280041C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800420: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82800424: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800428: 484A9028  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280042C => {
    //   block [0x8280042C..0x82800430)
	// 8280042C: 4BE6011D  bl 0x82660548
	ctx.lr = 0x82800430;
	sub_82660548(ctx, base);
	pc = 0x82800430; continue 'dispatch;
            }
            0x82800430 => {
    //   block [0x82800430..0x82800480)
	// 82800430: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82800434: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800438: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8280043C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800440: 40980040  bge cr6, 0x82800480
	if !ctx.cr[6].lt {
	pc = 0x82800480; continue 'dispatch;
	}
	// 82800444: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82800448: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8280044C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82800450: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82800454: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800458: 4BB6B119  bl 0x8236b570
	ctx.lr = 0x8280045C;
	sub_8236B570(ctx, base);
	// 8280045C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800460: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82800464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800468: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280046C: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800470: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800474: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82800478: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8280047C: 484A8FD4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800480 => {
    //   block [0x82800480..0x8280049C)
	// 82800480: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82800484: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82800488: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280048C: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82800490: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82800494: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800498: 484A8FB8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828004A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828004A0 size=184
    let mut pc: u32 = 0x828004A0;
    'dispatch: loop {
        match pc {
            0x828004A0 => {
    //   block [0x828004A0..0x82800514)
	// 828004A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828004A4: 484A8F59  bl 0x82ca93fc
	ctx.lr = 0x828004A8;
	sub_82CA93D0(ctx, base);
	// 828004A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828004AC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828004B0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828004B4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828004B8: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 828004BC: 833C0004  lwz r25, 4(r28)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828004C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828004C4: 409A0088  bne cr6, 0x8280054c
	if !ctx.cr[6].eq {
	pc = 0x8280054C; continue 'dispatch;
	}
	// 828004C8: 3860001C  li r3, 0x1c
	ctx.r[3].s64 = 28;
	// 828004CC: 8B7E0018  lbz r27, 0x18(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 828004D0: 573D003E  slwi r29, r25, 0
	ctx.r[29].u32 = ctx.r[25].u32.wrapping_shl(0);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 828004D4: 4BA1ED85  bl 0x8221f258
	ctx.lr = 0x828004D8;
	sub_8221F258(ctx, base);
	// 828004D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828004DC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828004E0: 419A0034  beq cr6, 0x82800514
	if ctx.cr[6].eq {
	pc = 0x82800514; continue 'dispatch;
	}
	// 828004E4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828004E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828004EC: 935F0004  stw r26, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 828004F0: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828004F4: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828004F8: 915F000C  stw r10, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 828004FC: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 82800500: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82800504: 811E0014  lwz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 82800508: 911F0014  stw r8, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 8280050C: 9B7F0018  stb r27, 0x18(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[27].u8 ) };
	// 82800510: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	pc = 0x82800514; continue 'dispatch;
            }
            0x82800514 => {
    //   block [0x82800514..0x82800524)
	// 82800514: 89790019  lbz r11, 0x19(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(25 as u32) ) } as u64;
	// 82800518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280051C: 419A0008  beq cr6, 0x82800524
	if ctx.cr[6].eq {
	pc = 0x82800524; continue 'dispatch;
	}
	// 82800520: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	pc = 0x82800524; continue 'dispatch;
            }
            0x82800524 => {
    //   block [0x82800524..0x8280054C)
	// 82800524: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82800528: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280052C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800530: 4BFFFF71  bl 0x828004a0
	ctx.lr = 0x82800534;
	sub_828004A0(ctx, base);
	// 82800534: 907F0000  stw r3, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 82800538: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8280053C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800540: 809E0008  lwz r4, 8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800544: 4BFFFF5D  bl 0x828004a0
	ctx.lr = 0x82800548;
	sub_828004A0(ctx, base);
	// 82800548: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x8280054C; continue 'dispatch;
            }
            0x8280054C => {
    //   block [0x8280054C..0x82800558)
	// 8280054C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82800550: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800554: 484A8EF8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800558(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82800558 size=316
    let mut pc: u32 = 0x82800558;
    'dispatch: loop {
        match pc {
            0x82800558 => {
    //   block [0x82800558..0x82800590)
	// 82800558: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280055C: 484A8EA5  bl 0x82ca9400
	ctx.lr = 0x82800560;
	sub_82CA93D0(ctx, base);
	// 82800560: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800564: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82800568: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 8280056C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82800570: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82800574: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82800578: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280057C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800580: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82800584: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800588: 409A003C  bne cr6, 0x828005c4
	if !ctx.cr[6].eq {
	pc = 0x828005C4; continue 'dispatch;
	}
	// 8280058C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82800590; continue 'dispatch;
            }
            0x82800590 => {
    //   block [0x82800590..0x828005B4)
	// 82800590: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800594: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82800598: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 8280059C: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 828005A0: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 828005A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828005A8: 419A000C  beq cr6, 0x828005b4
	if ctx.cr[6].eq {
	pc = 0x828005B4; continue 'dispatch;
	}
	// 828005AC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828005B0: 48000008  b 0x828005b8
	pc = 0x828005B8; continue 'dispatch;
            }
            0x828005B4 => {
    //   block [0x828005B4..0x828005B8)
	// 828005B4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828005B8; continue 'dispatch;
            }
            0x828005B8 => {
    //   block [0x828005B8..0x828005C4)
	// 828005B8: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828005BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828005C0: 419AFFD0  beq cr6, 0x82800590
	if ctx.cr[6].eq {
	pc = 0x82800590; continue 'dispatch;
	}
	pc = 0x828005C4; continue 'dispatch;
            }
            0x828005C4 => {
    //   block [0x828005C4..0x82800624)
	// 828005C4: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 828005C8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828005CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 828005D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828005D4: 419A0054  beq cr6, 0x82800628
	if ctx.cr[6].eq {
	pc = 0x82800628; continue 'dispatch;
	}
	// 828005D8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828005DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828005E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828005E4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828005E8: 409A003C  bne cr6, 0x82800624
	if !ctx.cr[6].eq {
	pc = 0x82800624; continue 'dispatch;
	}
	// 828005EC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 828005F0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828005F4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828005F8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828005FC: 48000185  bl 0x82800780
	ctx.lr = 0x82800600;
	sub_82800780(ctx, base);
	// 82800600: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800604: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82800608: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280060C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800610: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800614: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800618: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8280061C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800620: 484A8E30  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800624 => {
    //   block [0x82800624..0x82800628)
	// 82800624: 480025ED  bl 0x82802c10
	ctx.lr = 0x82800628;
	sub_82802C10(ctx, base);
	pc = 0x82800628; continue 'dispatch;
            }
            0x82800628 => {
    //   block [0x82800628..0x82800678)
	// 82800628: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8280062C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800630: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800634: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800638: 40980040  bge cr6, 0x82800678
	if !ctx.cr[6].lt {
	pc = 0x82800678; continue 'dispatch;
	}
	// 8280063C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82800640: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82800644: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82800648: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8280064C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800650: 48000131  bl 0x82800780
	ctx.lr = 0x82800654;
	sub_82800780(ctx, base);
	// 82800654: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800658: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 8280065C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800660: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800664: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800668: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8280066C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82800670: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800674: 484A8DDC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800678 => {
    //   block [0x82800678..0x82800694)
	// 82800678: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8280067C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82800680: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800684: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82800688: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8280068C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800690: 484A8DC0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800698 size=232
    let mut pc: u32 = 0x82800698;
    'dispatch: loop {
        match pc {
            0x82800698 => {
    //   block [0x82800698..0x828006D0)
	// 82800698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280069C: 484A8D69  bl 0x82ca9404
	ctx.lr = 0x828006A0;
	sub_82CA93D0(ctx, base);
	// 828006A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828006A4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828006A8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828006AC: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828006B0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 828006B4: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828006B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828006BC: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828006C0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828006C4: 419A000C  beq cr6, 0x828006d0
	if ctx.cr[6].eq {
	pc = 0x828006D0; continue 'dispatch;
	}
	// 828006C8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828006CC: 419A0008  beq cr6, 0x828006d4
	if ctx.cr[6].eq {
	pc = 0x828006D4; continue 'dispatch;
	}
	pc = 0x828006D0; continue 'dispatch;
            }
            0x828006D0 => {
    //   block [0x828006D0..0x828006D4)
	// 828006D0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828006D4; continue 'dispatch;
            }
            0x828006D4 => {
    //   block [0x828006D4..0x828006F8)
	// 828006D4: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828006D8: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 828006DC: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 828006E0: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828006E4: 409A0044  bne cr6, 0x82800728
	if !ctx.cr[6].eq {
	pc = 0x82800728; continue 'dispatch;
	}
	// 828006E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 828006EC: 419A000C  beq cr6, 0x828006f8
	if ctx.cr[6].eq {
	pc = 0x828006F8; continue 'dispatch;
	}
	// 828006F0: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828006F4: 419A0008  beq cr6, 0x828006fc
	if ctx.cr[6].eq {
	pc = 0x828006FC; continue 'dispatch;
	}
	pc = 0x828006F8; continue 'dispatch;
            }
            0x828006F8 => {
    //   block [0x828006F8..0x828006FC)
	// 828006F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828006FC; continue 'dispatch;
            }
            0x828006FC => {
    //   block [0x828006FC..0x82800728)
	// 828006FC: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82800700: 409A0028  bne cr6, 0x82800728
	if !ctx.cr[6].eq {
	pc = 0x82800728; continue 'dispatch;
	}
	// 82800704: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82800708: 4BFFF159  bl 0x827ff860
	ctx.lr = 0x8280070C;
	sub_827FF860(ctx, base);
	// 8280070C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800710: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82800714: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800718: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280071C: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82800720: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800724: 484A8D30  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800728 => {
    //   block [0x82800728..0x82800738)
	// 82800728: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8280072C: 419A000C  beq cr6, 0x82800738
	if ctx.cr[6].eq {
	pc = 0x82800738; continue 'dispatch;
	}
	// 82800730: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82800734: 419A0008  beq cr6, 0x8280073c
	if ctx.cr[6].eq {
	pc = 0x8280073C; continue 'dispatch;
	}
	pc = 0x82800738; continue 'dispatch;
            }
            0x82800738 => {
    //   block [0x82800738..0x8280073C)
	// 82800738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8280073C; continue 'dispatch;
            }
            0x8280073C => {
    //   block [0x8280073C..0x82800770)
	// 8280073C: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82800740: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82800744: 419A002C  beq cr6, 0x82800770
	if ctx.cr[6].eq {
	pc = 0x82800770; continue 'dispatch;
	}
	// 82800748: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 8280074C: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82800750: 4829BDC9  bl 0x82a9c518
	ctx.lr = 0x82800754;
	sub_82A9C518(ctx, base);
	// 82800754: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82800758: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8280075C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800760: 4BB52F11  bl 0x82353670
	ctx.lr = 0x82800764;
	sub_82353670(ctx, base);
	// 82800764: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82800768: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 8280076C: 4BFFFFBC  b 0x82800728
	pc = 0x82800728; continue 'dispatch;
            }
            0x82800770 => {
    //   block [0x82800770..0x82800780)
	// 82800770: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82800774: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800778: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8280077C: 484A8CD8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800780(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800780 size=632
    let mut pc: u32 = 0x82800780;
    'dispatch: loop {
        match pc {
            0x82800780 => {
    //   block [0x82800780..0x828007F8)
	// 82800780: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800784: 484A8C75  bl 0x82ca93f8
	ctx.lr = 0x82800788;
	sub_82CA93D0(ctx, base);
	// 82800788: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280078C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 82800790: 3D600FFF  lis r11, 0xfff
	ctx.r[11].s64 = 268369920;
	// 82800794: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82800798: 6169FFFE  ori r9, r11, 0xfffe
	ctx.r[9].u64 = ctx.r[11].u64 | 65534;
	// 8280079C: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828007A0: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828007A4: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828007A8: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 828007AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828007B0: 41980048  blt cr6, 0x828007f8
	if ctx.cr[6].lt {
	pc = 0x828007F8; continue 'dispatch;
	}
	// 828007B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828007B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828007BC: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 828007C0: 4BAF1781  bl 0x822f1f40
	ctx.lr = 0x828007C4;
	sub_822F1F40(ctx, base);
	// 828007C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828007C8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828007CC: 4BAF15E5  bl 0x822f1db0
	ctx.lr = 0x828007D0;
	sub_822F1DB0(ctx, base);
	// 828007D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828007D4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828007D8: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 828007DC: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828007E0: 4BAF1641  bl 0x822f1e20
	ctx.lr = 0x828007E4;
	sub_822F1E20(ctx, base);
	// 828007E4: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 828007E8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 828007EC: 4BE7AFF5  bl 0x8267b7e0
	ctx.lr = 0x828007F0;
	sub_8267B7E0(ctx, base);
	// 828007F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828007F4: 4B97101D  bl 0x82171810
	ctx.lr = 0x828007F8;
	sub_82171810(ctx, base);
	pc = 0x828007F8; continue 'dispatch;
            }
            0x828007F8 => {
    //   block [0x828007F8..0x82800840)
	// 828007F8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 828007FC: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800800: 4BA1EA59  bl 0x8221f258
	ctx.lr = 0x82800804;
	sub_8221F258(ctx, base);
	// 82800804: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82800808: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 8280080C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 82800810: 419A0030  beq cr6, 0x82800840
	if ctx.cr[6].eq {
	pc = 0x82800840; continue 'dispatch;
	}
	// 82800814: 397B000C  addi r11, r27, 0xc
	ctx.r[11].s64 = ctx.r[27].s64 + 12;
	// 82800818: 93DB0000  stw r30, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8280081C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82800820: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 82800824: 93DB0008  stw r30, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82800828: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 8280082C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800830: 917B000C  stw r11, 0xc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82800834: 48000685  bl 0x82800eb8
	ctx.lr = 0x82800838;
	sub_82800EB8(ctx, base);
	// 82800838: 9B3B001C  stb r25, 0x1c(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8280083C: 9B3B001D  stb r25, 0x1d(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(29 as u32), ctx.r[25].u8 ) };
	pc = 0x82800840; continue 'dispatch;
            }
            0x82800840 => {
    //   block [0x82800840..0x82800870)
	// 82800840: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800844: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800848: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8280084C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800850: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82800854: 409A001C  bne cr6, 0x82800870
	if !ctx.cr[6].eq {
	pc = 0x82800870; continue 'dispatch;
	}
	// 82800858: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 8280085C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800860: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82800864: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800868: 936A0008  stw r27, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8280086C: 48000044  b 0x828008b0
	pc = 0x828008B0; continue 'dispatch;
            }
            0x82800870 => {
    //   block [0x82800870..0x82800898)
	// 82800870: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 82800874: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800878: 419A0020  beq cr6, 0x82800898
	if ctx.cr[6].eq {
	pc = 0x82800898; continue 'dispatch;
	}
	// 8280087C: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82800880: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800884: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800888: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8280088C: 409A0024  bne cr6, 0x828008b0
	if !ctx.cr[6].eq {
	pc = 0x828008B0; continue 'dispatch;
	}
	// 82800890: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82800894: 4800001C  b 0x828008b0
	pc = 0x828008B0; continue 'dispatch;
            }
            0x82800898 => {
    //   block [0x82800898..0x828008B0)
	// 82800898: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 8280089C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828008A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828008A4: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828008A8: 409A0008  bne cr6, 0x828008b0
	if !ctx.cr[6].eq {
	pc = 0x828008B0; continue 'dispatch;
	}
	// 828008AC: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x828008B0; continue 'dispatch;
            }
            0x828008B0 => {
    //   block [0x828008B0..0x828008CC)
	// 828008B0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828008B4: 397B0004  addi r11, r27, 4
	ctx.r[11].s64 = ctx.r[27].s64 + 4;
	// 828008B8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 828008BC: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828008C0: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828008C4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828008C8: 409A0110  bne cr6, 0x828009d8
	if !ctx.cr[6].eq {
	pc = 0x828009D8; continue 'dispatch;
	}
	pc = 0x828008CC; continue 'dispatch;
            }
            0x828008CC => {
    //   block [0x828008CC..0x82800914)
	// 828008CC: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828008D0: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 828008D4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828008D8: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828008DC: 409A0078  bne cr6, 0x82800954
	if !ctx.cr[6].eq {
	pc = 0x82800954; continue 'dispatch;
	}
	// 828008E0: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 828008E4: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828008E8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828008EC: 409A0028  bne cr6, 0x82800914
	if !ctx.cr[6].eq {
	pc = 0x82800914; continue 'dispatch;
	}
	// 828008F0: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 828008F4: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 828008F8: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 828008FC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800900: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800904: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82800908: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280090C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800910: 480000B4  b 0x828009c4
	pc = 0x828009C4; continue 'dispatch;
            }
            0x82800914 => {
    //   block [0x82800914..0x8280092C)
	// 82800914: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800918: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8280091C: 409A0010  bne cr6, 0x8280092c
	if !ctx.cr[6].eq {
	pc = 0x8280092C; continue 'dispatch;
	}
	// 82800920: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82800924: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82800928: 48369EF9  bl 0x82b6a820
	ctx.lr = 0x8280092C;
	sub_82B6A820(ctx, base);
	pc = 0x8280092C; continue 'dispatch;
            }
            0x8280092C => {
    //   block [0x8280092C..0x82800954)
	// 8280092C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800930: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82800934: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82800938: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280093C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800940: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 82800944: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800948: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280094C: 4843ADED  bl 0x82c3b738
	ctx.lr = 0x82800950;
	sub_82C3B738(ctx, base);
	// 82800950: 48000074  b 0x828009c4
	pc = 0x828009C4; continue 'dispatch;
            }
            0x82800954 => {
    //   block [0x82800954..0x82800988)
	// 82800954: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800958: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8280095C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800960: 409A0028  bne cr6, 0x82800988
	if !ctx.cr[6].eq {
	pc = 0x82800988; continue 'dispatch;
	}
	// 82800964: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800968: 9BC9001C  stb r30, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 8280096C: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 82800970: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800974: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800978: 9B27001C  stb r25, 0x1c(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 8280097C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800980: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800984: 48000040  b 0x828009c4
	pc = 0x828009C4; continue 'dispatch;
            }
            0x82800988 => {
    //   block [0x82800988..0x828009A0)
	// 82800988: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280098C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800990: 409A0010  bne cr6, 0x828009a0
	if !ctx.cr[6].eq {
	pc = 0x828009A0; continue 'dispatch;
	}
	// 82800994: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82800998: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8280099C: 4843AD9D  bl 0x82c3b738
	ctx.lr = 0x828009A0;
	sub_82C3B738(ctx, base);
	pc = 0x828009A0; continue 'dispatch;
            }
            0x828009A0 => {
    //   block [0x828009A0..0x828009C4)
	// 828009A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828009A8: 9BCB001C  stb r30, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 828009AC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009B0: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009B4: 9B29001C  stb r25, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[25].u8 ) };
	// 828009B8: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009BC: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009C0: 48369E61  bl 0x82b6a820
	ctx.lr = 0x828009C4;
	sub_82B6A820(ctx, base);
	pc = 0x828009C4; continue 'dispatch;
            }
            0x828009C4 => {
    //   block [0x828009C4..0x828009D8)
	// 828009C4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009C8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828009CC: 892A001C  lbz r9, 0x1c(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 828009D0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828009D4: 419AFEF8  beq cr6, 0x828008cc
	if ctx.cr[6].eq {
	pc = 0x828008CC; continue 'dispatch;
	}
	pc = 0x828009D8; continue 'dispatch;
            }
            0x828009D8 => {
    //   block [0x828009D8..0x828009F8)
	// 828009D8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009DC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 828009E0: 93780004  stw r27, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 828009E4: 93B80000  stw r29, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828009E8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828009EC: 9BCA001C  stb r30, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 828009F0: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 828009F4: 484A8A54  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828009F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828009F8 size=316
    let mut pc: u32 = 0x828009F8;
    'dispatch: loop {
        match pc {
            0x828009F8 => {
    //   block [0x828009F8..0x82800A30)
	// 828009F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828009FC: 484A8A05  bl 0x82ca9400
	ctx.lr = 0x82800A00;
	sub_82CA93D0(ctx, base);
	// 82800A00: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800A04: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82800A08: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 82800A0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82800A10: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82800A14: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 82800A18: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800A1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800A20: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800A24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800A28: 409A003C  bne cr6, 0x82800a64
	if !ctx.cr[6].eq {
	pc = 0x82800A64; continue 'dispatch;
	}
	// 82800A2C: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82800A30; continue 'dispatch;
            }
            0x82800A30 => {
    //   block [0x82800A30..0x82800A54)
	// 82800A30: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800A34: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82800A38: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 82800A3C: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 82800A40: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 82800A44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82800A48: 419A000C  beq cr6, 0x82800a54
	if ctx.cr[6].eq {
	pc = 0x82800A54; continue 'dispatch;
	}
	// 82800A4C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800A50: 48000008  b 0x82800a58
	pc = 0x82800A58; continue 'dispatch;
            }
            0x82800A54 => {
    //   block [0x82800A54..0x82800A58)
	// 82800A54: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82800A58; continue 'dispatch;
            }
            0x82800A58 => {
    //   block [0x82800A58..0x82800A64)
	// 82800A58: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800A5C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800A60: 419AFFD0  beq cr6, 0x82800a30
	if ctx.cr[6].eq {
	pc = 0x82800A30; continue 'dispatch;
	}
	pc = 0x82800A64; continue 'dispatch;
            }
            0x82800A64 => {
    //   block [0x82800A64..0x82800AC4)
	// 82800A64: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82800A68: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82800A6C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82800A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800A74: 419A0054  beq cr6, 0x82800ac8
	if ctx.cr[6].eq {
	pc = 0x82800AC8; continue 'dispatch;
	}
	// 82800A78: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800A7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800A80: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800A84: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800A88: 409A003C  bne cr6, 0x82800ac4
	if !ctx.cr[6].eq {
	pc = 0x82800AC4; continue 'dispatch;
	}
	// 82800A8C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82800A90: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82800A94: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82800A98: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82800A9C: 48000185  bl 0x82800c20
	ctx.lr = 0x82800AA0;
	sub_82800C20(ctx, base);
	// 82800AA0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800AA4: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82800AA8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800AAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800AB0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800AB4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800AB8: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82800ABC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800AC0: 484A8990  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800AC4 => {
    //   block [0x82800AC4..0x82800AC8)
	// 82800AC4: 4BB7D91D  bl 0x8237e3e0
	ctx.lr = 0x82800AC8;
	sub_8237E3E0(ctx, base);
	pc = 0x82800AC8; continue 'dispatch;
            }
            0x82800AC8 => {
    //   block [0x82800AC8..0x82800B18)
	// 82800AC8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82800ACC: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800AD0: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82800AD4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800AD8: 40980040  bge cr6, 0x82800b18
	if !ctx.cr[6].lt {
	pc = 0x82800B18; continue 'dispatch;
	}
	// 82800ADC: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82800AE0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 82800AE4: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82800AE8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82800AEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800AF0: 48000131  bl 0x82800c20
	ctx.lr = 0x82800AF4;
	sub_82800C20(ctx, base);
	// 82800AF4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800AF8: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82800AFC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800B00: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800B04: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800B08: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82800B0C: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82800B10: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800B14: 484A893C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800B18 => {
    //   block [0x82800B18..0x82800B34)
	// 82800B18: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82800B1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82800B20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82800B24: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 82800B28: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82800B2C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800B30: 484A8920  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800B38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800B38 size=232
    let mut pc: u32 = 0x82800B38;
    'dispatch: loop {
        match pc {
            0x82800B38 => {
    //   block [0x82800B38..0x82800B70)
	// 82800B38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800B3C: 484A88C9  bl 0x82ca9404
	ctx.lr = 0x82800B40;
	sub_82CA93D0(ctx, base);
	// 82800B40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800B44: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82800B48: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 82800B4C: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82800B50: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82800B54: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 82800B58: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800B5C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800B60: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800B64: 419A000C  beq cr6, 0x82800b70
	if ctx.cr[6].eq {
	pc = 0x82800B70; continue 'dispatch;
	}
	// 82800B68: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82800B6C: 419A0008  beq cr6, 0x82800b74
	if ctx.cr[6].eq {
	pc = 0x82800B74; continue 'dispatch;
	}
	pc = 0x82800B70; continue 'dispatch;
            }
            0x82800B70 => {
    //   block [0x82800B70..0x82800B74)
	// 82800B70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82800B74; continue 'dispatch;
            }
            0x82800B74 => {
    //   block [0x82800B74..0x82800B98)
	// 82800B74: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82800B78: 83A100BC  lwz r29, 0xbc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82800B7C: 83C100B8  lwz r30, 0xb8(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82800B80: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800B84: 409A0044  bne cr6, 0x82800bc8
	if !ctx.cr[6].eq {
	pc = 0x82800BC8; continue 'dispatch;
	}
	// 82800B88: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82800B8C: 419A000C  beq cr6, 0x82800b98
	if ctx.cr[6].eq {
	pc = 0x82800B98; continue 'dispatch;
	}
	// 82800B90: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82800B94: 419A0008  beq cr6, 0x82800b9c
	if ctx.cr[6].eq {
	pc = 0x82800B9C; continue 'dispatch;
	}
	pc = 0x82800B98; continue 'dispatch;
            }
            0x82800B98 => {
    //   block [0x82800B98..0x82800B9C)
	// 82800B98: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82800B9C; continue 'dispatch;
            }
            0x82800B9C => {
    //   block [0x82800B9C..0x82800BC8)
	// 82800B9C: 7F1D4840  cmplw cr6, r29, r9
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82800BA0: 409A0028  bne cr6, 0x82800bc8
	if !ctx.cr[6].eq {
	pc = 0x82800BC8; continue 'dispatch;
	}
	// 82800BA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82800BA8: 4BFFEF49  bl 0x827ffaf0
	ctx.lr = 0x82800BAC;
	sub_827FFAF0(ctx, base);
	// 82800BAC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800BB0: 93FC0000  stw r31, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82800BB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800BB8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800BBC: 915C0004  stw r10, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82800BC0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800BC4: 484A8890  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82800BC8 => {
    //   block [0x82800BC8..0x82800BD8)
	// 82800BC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82800BCC: 419A000C  beq cr6, 0x82800bd8
	if ctx.cr[6].eq {
	pc = 0x82800BD8; continue 'dispatch;
	}
	// 82800BD0: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82800BD4: 419A0008  beq cr6, 0x82800bdc
	if ctx.cr[6].eq {
	pc = 0x82800BDC; continue 'dispatch;
	}
	pc = 0x82800BD8; continue 'dispatch;
            }
            0x82800BD8 => {
    //   block [0x82800BD8..0x82800BDC)
	// 82800BD8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82800BDC; continue 'dispatch;
            }
            0x82800BDC => {
    //   block [0x82800BDC..0x82800C10)
	// 82800BDC: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82800BE0: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82800BE4: 419A002C  beq cr6, 0x82800c10
	if ctx.cr[6].eq {
	pc = 0x82800C10; continue 'dispatch;
	}
	// 82800BE8: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82800BEC: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82800BF0: 4BB13F39  bl 0x82314b28
	ctx.lr = 0x82800BF4;
	sub_82314B28(ctx, base);
	// 82800BF4: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 82800BF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82800BFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800C00: 48000359  bl 0x82800f58
	ctx.lr = 0x82800C04;
	sub_82800F58(ctx, base);
	// 82800C04: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 82800C08: 814100B0  lwz r10, 0xb0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 82800C0C: 4BFFFFBC  b 0x82800bc8
	pc = 0x82800BC8; continue 'dispatch;
            }
            0x82800C10 => {
    //   block [0x82800C10..0x82800C20)
	// 82800C10: F8BC0000  std r5, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 82800C14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800C18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82800C1C: 484A8838  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800C20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800C20 size=660
    let mut pc: u32 = 0x82800C20;
    'dispatch: loop {
        match pc {
            0x82800C20 => {
    //   block [0x82800C20..0x82800C98)
	// 82800C20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800C24: 484A87D1  bl 0x82ca93f4
	ctx.lr = 0x82800C28;
	sub_82CA93D0(ctx, base);
	// 82800C28: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800C2C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82800C30: 3D600CCC  lis r11, 0xccc
	ctx.r[11].s64 = 214695936;
	// 82800C34: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 82800C38: 6169CCCB  ori r9, r11, 0xcccb
	ctx.r[9].u64 = ctx.r[11].u64 | 52427;
	// 82800C3C: 7CB82B78  mr r24, r5
	ctx.r[24].u64 = ctx.r[5].u64;
	// 82800C40: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800C44: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 82800C48: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	// 82800C4C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82800C50: 41980048  blt cr6, 0x82800c98
	if ctx.cr[6].lt {
	pc = 0x82800C98; continue 'dispatch;
	}
	// 82800C54: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82800C58: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800C5C: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 82800C60: 4BAF12E1  bl 0x822f1f40
	ctx.lr = 0x82800C64;
	sub_822F1F40(ctx, base);
	// 82800C64: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82800C68: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82800C6C: 4BAF1145  bl 0x822f1db0
	ctx.lr = 0x82800C70;
	sub_822F1DB0(ctx, base);
	// 82800C70: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82800C74: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82800C78: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82800C7C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82800C80: 4BAF11A1  bl 0x822f1e20
	ctx.lr = 0x82800C84;
	sub_822F1E20(ctx, base);
	// 82800C84: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82800C88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82800C8C: 4BE7AB55  bl 0x8267b7e0
	ctx.lr = 0x82800C90;
	sub_8267B7E0(ctx, base);
	// 82800C90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82800C94: 4B970B7D  bl 0x82171810
	ctx.lr = 0x82800C98;
	sub_82171810(ctx, base);
	pc = 0x82800C98; continue 'dispatch;
            }
            0x82800C98 => {
    //   block [0x82800C98..0x82800CFC)
	// 82800C98: 38600024  li r3, 0x24
	ctx.r[3].s64 = 36;
	// 82800C9C: 839A0004  lwz r28, 4(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800CA0: 4BA1E5B9  bl 0x8221f258
	ctx.lr = 0x82800CA4;
	sub_8221F258(ctx, base);
	// 82800CA4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82800CA8: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82800CAC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82800CB0: 419A004C  beq cr6, 0x82800cfc
	if ctx.cr[6].eq {
	pc = 0x82800CFC; continue 'dispatch;
	}
	// 82800CB4: 939E0000  stw r28, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82800CB8: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 82800CBC: 939E0008  stw r28, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 82800CC0: 3B7D0004  addi r27, r29, 4
	ctx.r[27].s64 = ctx.r[29].s64 + 4;
	// 82800CC4: 93FE0004  stw r31, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82800CC8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82800CCC: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800CD0: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82800CD4: 3B8B0004  addi r28, r11, 4
	ctx.r[28].s64 = ctx.r[11].s64 + 4;
	// 82800CD8: 813D0004  lwz r9, 4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800CDC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800CE0: 913E0010  stw r9, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 82800CE4: 4821723D  bl 0x82a17f20
	ctx.lr = 0x82800CE8;
	sub_82A17F20(ctx, base);
	// 82800CE8: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 82800CEC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82800CF0: 4BFFF069  bl 0x827ffd58
	ctx.lr = 0x82800CF4;
	sub_827FFD58(ctx, base);
	// 82800CF4: 9B3E0020  stb r25, 0x20(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82800CF8: 9B3E0021  stb r25, 0x21(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(33 as u32), ctx.r[25].u8 ) };
	pc = 0x82800CFC; continue 'dispatch;
            }
            0x82800CFC => {
    //   block [0x82800CFC..0x82800D2C)
	// 82800CFC: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800D00: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D04: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82800D08: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800D0C: 915A0008  stw r10, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82800D10: 409A001C  bne cr6, 0x82800d2c
	if !ctx.cr[6].eq {
	pc = 0x82800D2C; continue 'dispatch;
	}
	// 82800D14: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82800D18: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D1C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82800D20: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D24: 93CA0008  stw r30, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82800D28: 48000044  b 0x82800d6c
	pc = 0x82800D6C; continue 'dispatch;
            }
            0x82800D2C => {
    //   block [0x82800D2C..0x82800D54)
	// 82800D2C: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 82800D30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800D34: 419A0020  beq cr6, 0x82800d54
	if ctx.cr[6].eq {
	pc = 0x82800D54; continue 'dispatch;
	}
	// 82800D38: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82800D3C: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D40: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800D44: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800D48: 409A0024  bne cr6, 0x82800d6c
	if !ctx.cr[6].eq {
	pc = 0x82800D6C; continue 'dispatch;
	}
	// 82800D4C: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82800D50: 4800001C  b 0x82800d6c
	pc = 0x82800D6C; continue 'dispatch;
            }
            0x82800D54 => {
    //   block [0x82800D54..0x82800D6C)
	// 82800D54: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82800D58: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D5C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800D60: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82800D64: 409A0008  bne cr6, 0x82800d6c
	if !ctx.cr[6].eq {
	pc = 0x82800D6C; continue 'dispatch;
	}
	// 82800D68: 93CB0008  stw r30, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	pc = 0x82800D6C; continue 'dispatch;
            }
            0x82800D6C => {
    //   block [0x82800D6C..0x82800D88)
	// 82800D6C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D70: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 82800D74: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82800D78: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82800D7C: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82800D80: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800D84: 409A0110  bne cr6, 0x82800e94
	if !ctx.cr[6].eq {
	pc = 0x82800E94; continue 'dispatch;
	}
	pc = 0x82800D88; continue 'dispatch;
            }
            0x82800D88 => {
    //   block [0x82800D88..0x82800DD0)
	// 82800D88: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800D8C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800D90: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800D94: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82800D98: 409A0078  bne cr6, 0x82800e10
	if !ctx.cr[6].eq {
	pc = 0x82800E10; continue 'dispatch;
	}
	// 82800D9C: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800DA0: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82800DA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800DA8: 409A0028  bne cr6, 0x82800dd0
	if !ctx.cr[6].eq {
	pc = 0x82800DD0; continue 'dispatch;
	}
	// 82800DAC: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82800DB0: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800DB4: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800DB8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800DBC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800DC0: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82800DC4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800DC8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800DCC: 480000B4  b 0x82800e80
	pc = 0x82800E80; continue 'dispatch;
            }
            0x82800DD0 => {
    //   block [0x82800DD0..0x82800DE8)
	// 82800DD0: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800DD4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800DD8: 409A0010  bne cr6, 0x82800de8
	if !ctx.cr[6].eq {
	pc = 0x82800DE8; continue 'dispatch;
	}
	// 82800DDC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82800DE0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82800DE4: 480B0A9D  bl 0x828b1880
	ctx.lr = 0x82800DE8;
	sub_828B1880(ctx, base);
	pc = 0x82800DE8; continue 'dispatch;
            }
            0x82800DE8 => {
    //   block [0x82800DE8..0x82800E10)
	// 82800DE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800DEC: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82800DF0: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800DF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800DF8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800DFC: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82800E00: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E04: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E08: 4BB12CF1  bl 0x82313af8
	ctx.lr = 0x82800E0C;
	sub_82313AF8(ctx, base);
	// 82800E0C: 48000074  b 0x82800e80
	pc = 0x82800E80; continue 'dispatch;
            }
            0x82800E10 => {
    //   block [0x82800E10..0x82800E44)
	// 82800E10: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800E14: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82800E18: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800E1C: 409A0028  bne cr6, 0x82800e44
	if !ctx.cr[6].eq {
	pc = 0x82800E44; continue 'dispatch;
	}
	// 82800E20: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800E24: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800E28: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800E2C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800E30: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E34: 9B270020  stb r25, 0x20(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82800E38: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800E3C: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E40: 48000040  b 0x82800e80
	pc = 0x82800E80; continue 'dispatch;
            }
            0x82800E44 => {
    //   block [0x82800E44..0x82800E5C)
	// 82800E44: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800E48: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82800E4C: 409A0010  bne cr6, 0x82800e5c
	if !ctx.cr[6].eq {
	pc = 0x82800E5C; continue 'dispatch;
	}
	// 82800E50: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82800E54: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82800E58: 4BB12CA1  bl 0x82313af8
	ctx.lr = 0x82800E5C;
	sub_82313AF8(ctx, base);
	pc = 0x82800E5C; continue 'dispatch;
            }
            0x82800E5C => {
    //   block [0x82800E5C..0x82800E80)
	// 82800E5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E60: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82800E64: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800E68: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E6C: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E70: 9B290020  stb r25, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[25].u8 ) };
	// 82800E74: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E78: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E7C: 480B0A05  bl 0x828b1880
	ctx.lr = 0x82800E80;
	sub_828B1880(ctx, base);
	pc = 0x82800E80; continue 'dispatch;
            }
            0x82800E80 => {
    //   block [0x82800E80..0x82800E94)
	// 82800E80: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E84: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82800E88: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82800E8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800E90: 419AFEF8  beq cr6, 0x82800d88
	if ctx.cr[6].eq {
	pc = 0x82800D88; continue 'dispatch;
	}
	pc = 0x82800E94; continue 'dispatch;
            }
            0x82800E94 => {
    //   block [0x82800E94..0x82800EB4)
	// 82800E94: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800E98: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82800E9C: 93D70004  stw r30, 4(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82800EA0: 93570000  stw r26, 0(r23)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 82800EA4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800EA8: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82800EAC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82800EB0: 484A8594  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800EB8 size=160
    let mut pc: u32 = 0x82800EB8;
    'dispatch: loop {
        match pc {
            0x82800EB8 => {
    //   block [0x82800EB8..0x82800EEC)
	// 82800EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800EBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82800EC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82800EC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82800EC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800ECC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82800ED0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82800ED4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82800ED8: 4BA1E381  bl 0x8221f258
	ctx.lr = 0x82800EDC;
	sub_8221F258(ctx, base);
	// 82800EDC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82800EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800EE4: 419A0008  beq cr6, 0x82800eec
	if ctx.cr[6].eq {
	pc = 0x82800EEC; continue 'dispatch;
	}
	// 82800EE8: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82800EEC; continue 'dispatch;
            }
            0x82800EEC => {
    //   block [0x82800EEC..0x82800EF8)
	// 82800EEC: 354B0004  addic. r10, r11, 4
	ctx.xer.ca = (ctx.r[11].u32 > (!(4 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82800EF0: 41820008  beq 0x82800ef8
	if ctx.cr[0].eq {
	pc = 0x82800EF8; continue 'dispatch;
	}
	// 82800EF4: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82800EF8; continue 'dispatch;
            }
            0x82800EF8 => {
    //   block [0x82800EF8..0x82800F58)
	// 82800EF8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82800EFC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82800F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82800F04: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82800F08: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82800F0C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82800F10: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800F14: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 82800F18: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800F1C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 82800F20: 90E10064  stw r7, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[7].u32 ) };
	// 82800F24: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 82800F28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82800F2C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82800F30: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82800F34: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82800F38: 4BC50349  bl 0x82451280
	ctx.lr = 0x82800F3C;
	sub_82451280(ctx, base);
	// 82800F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82800F40: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82800F44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82800F48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82800F4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82800F50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82800F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82800F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82800F58 size=1108
    let mut pc: u32 = 0x82800F58;
    'dispatch: loop {
        match pc {
            0x82800F58 => {
    //   block [0x82800F58..0x82800FC4)
	// 82800F58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82800F5C: 484A84A1  bl 0x82ca93fc
	ctx.lr = 0x82800F60;
	sub_82CA93D0(ctx, base);
	// 82800F60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82800F64: F8A10110  std r5, 0x110(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[5].u64 ) };
	// 82800F68: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82800F6C: 83E10114  lwz r31, 0x114(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82800F70: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82800F74: 897F0021  lbz r11, 0x21(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800F78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800F7C: 419A0048  beq cr6, 0x82800fc4
	if ctx.cr[6].eq {
	pc = 0x82800FC4; continue 'dispatch;
	}
	// 82800F80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82800F84: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82800F88: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82800F8C: 4BAF0FB5  bl 0x822f1f40
	ctx.lr = 0x82800F90;
	sub_822F1F40(ctx, base);
	// 82800F90: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82800F94: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82800F98: 4BAF0E19  bl 0x822f1db0
	ctx.lr = 0x82800F9C;
	sub_822F1DB0(ctx, base);
	// 82800F9C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82800FA0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82800FA4: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 82800FA8: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82800FAC: 4BAF0E75  bl 0x822f1e20
	ctx.lr = 0x82800FB0;
	sub_822F1E20(ctx, base);
	// 82800FB0: 93C10080  stw r30, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 82800FB4: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82800FB8: 4BE7A829  bl 0x8267b7e0
	ctx.lr = 0x82800FBC;
	sub_8267B7E0(ctx, base);
	// 82800FBC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82800FC0: 4B970851  bl 0x82171810
	ctx.lr = 0x82800FC4;
	sub_82171810(ctx, base);
	pc = 0x82800FC4; continue 'dispatch;
            }
            0x82800FC4 => {
    //   block [0x82800FC4..0x82800FE8)
	// 82800FC4: 38610110  addi r3, r1, 0x110
	ctx.r[3].s64 = ctx.r[1].s64 + 272;
	// 82800FC8: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 82800FCC: 4BB13B5D  bl 0x82314b28
	ctx.lr = 0x82800FD0;
	sub_82314B28(ctx, base);
	// 82800FD0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82800FD4: 896A0021  lbz r11, 0x21(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82800FDC: 419A000C  beq cr6, 0x82800fe8
	if ctx.cr[6].eq {
	pc = 0x82800FE8; continue 'dispatch;
	}
	// 82800FE0: 839A0008  lwz r28, 8(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800FE4: 4800002C  b 0x82801010
	pc = 0x82801010; continue 'dispatch;
            }
            0x82800FE8 => {
    //   block [0x82800FE8..0x82801000)
	// 82800FE8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82800FEC: 892B0021  lbz r9, 0x21(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82800FF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82800FF4: 419A000C  beq cr6, 0x82801000
	if ctx.cr[6].eq {
	pc = 0x82801000; continue 'dispatch;
	}
	// 82800FF8: 7D5C5378  mr r28, r10
	ctx.r[28].u64 = ctx.r[10].u64;
	// 82800FFC: 48000014  b 0x82801010
	pc = 0x82801010; continue 'dispatch;
            }
            0x82801000 => {
    //   block [0x82801000..0x82801010)
	// 82801000: 81610114  lwz r11, 0x114(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82801004: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801008: 838B0008  lwz r28, 8(r11)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280100C: 409A00F0  bne cr6, 0x828010fc
	if !ctx.cr[6].eq {
	pc = 0x828010FC; continue 'dispatch;
	}
	pc = 0x82801010; continue 'dispatch;
            }
            0x82801010 => {
    //   block [0x82801010..0x82801024)
	// 82801010: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801014: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280101C: 409A0008  bne cr6, 0x82801024
	if !ctx.cr[6].eq {
	pc = 0x82801024; continue 'dispatch;
	}
	// 82801020: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82801024; continue 'dispatch;
            }
            0x82801024 => {
    //   block [0x82801024..0x8280103C)
	// 82801024: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801028: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280102C: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801030: 409A000C  bne cr6, 0x8280103c
	if !ctx.cr[6].eq {
	pc = 0x8280103C; continue 'dispatch;
	}
	// 82801034: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 82801038: 4800001C  b 0x82801054
	pc = 0x82801054; continue 'dispatch;
            }
            0x8280103C => {
    //   block [0x8280103C..0x82801050)
	// 8280103C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801040: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801044: 409A000C  bne cr6, 0x82801050
	if !ctx.cr[6].eq {
	pc = 0x82801050; continue 'dispatch;
	}
	// 82801048: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8280104C: 48000008  b 0x82801054
	pc = 0x82801054; continue 'dispatch;
            }
            0x82801050 => {
    //   block [0x82801050..0x82801054)
	// 82801050: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x82801054; continue 'dispatch;
            }
            0x82801054 => {
    //   block [0x82801054..0x82801078)
	// 82801054: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801058: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280105C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801060: 409A0044  bne cr6, 0x828010a4
	if !ctx.cr[6].eq {
	pc = 0x828010A4; continue 'dispatch;
	}
	// 82801064: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280106C: 419A000C  beq cr6, 0x82801078
	if ctx.cr[6].eq {
	pc = 0x82801078; continue 'dispatch;
	}
	// 82801070: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82801074: 4800002C  b 0x828010a0
	pc = 0x828010A0; continue 'dispatch;
            }
            0x82801078 => {
    //   block [0x82801078..0x8280108C)
	// 82801078: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280107C: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 82801080: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801084: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82801088: 409A0018  bne cr6, 0x828010a0
	if !ctx.cr[6].eq {
	pc = 0x828010A0; continue 'dispatch;
	}
	pc = 0x8280108C; continue 'dispatch;
            }
            0x8280108C => {
    //   block [0x8280108C..0x828010A0)
	// 8280108C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82801090: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801094: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801098: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8280109C: 419AFFF0  beq cr6, 0x8280108c
	if ctx.cr[6].eq {
	pc = 0x8280108C; continue 'dispatch;
	}
	pc = 0x828010A0; continue 'dispatch;
            }
            0x828010A0 => {
    //   block [0x828010A0..0x828010A4)
	// 828010A0: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x828010A4; continue 'dispatch;
            }
            0x828010A4 => {
    //   block [0x828010A4..0x828010CC)
	// 828010A4: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828010A8: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 828010AC: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828010B0: 409A00E0  bne cr6, 0x82801190
	if !ctx.cr[6].eq {
	pc = 0x82801190; continue 'dispatch;
	}
	// 828010B4: 897C0021  lbz r11, 0x21(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 828010B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828010BC: 419A0010  beq cr6, 0x828010cc
	if ctx.cr[6].eq {
	pc = 0x828010CC; continue 'dispatch;
	}
	// 828010C0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828010C4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828010C8: 480000C8  b 0x82801190
	pc = 0x82801190; continue 'dispatch;
            }
            0x828010CC => {
    //   block [0x828010CC..0x828010E0)
	// 828010CC: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828010D0: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 828010D4: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828010D8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828010DC: 409A0018  bne cr6, 0x828010f4
	if !ctx.cr[6].eq {
	pc = 0x828010F4; continue 'dispatch;
	}
	pc = 0x828010E0; continue 'dispatch;
            }
            0x828010E0 => {
    //   block [0x828010E0..0x828010F4)
	// 828010E0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828010E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828010E8: 890B0021  lbz r8, 0x21(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828010EC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828010F0: 419AFFF0  beq cr6, 0x828010e0
	if ctx.cr[6].eq {
	pc = 0x828010E0; continue 'dispatch;
	}
	pc = 0x828010F4; continue 'dispatch;
            }
            0x828010F4 => {
    //   block [0x828010F4..0x828010FC)
	// 828010F4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828010F8: 48000098  b 0x82801190
	pc = 0x82801190; continue 'dispatch;
            }
            0x828010FC => {
    //   block [0x828010FC..0x8280111C)
	// 828010FC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82801100: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801104: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82801108: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280110C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82801110: 409A000C  bne cr6, 0x8280111c
	if !ctx.cr[6].eq {
	pc = 0x8280111C; continue 'dispatch;
	}
	// 82801114: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82801118: 4800002C  b 0x82801144
	pc = 0x82801144; continue 'dispatch;
            }
            0x8280111C => {
    //   block [0x8280111C..0x82801130)
	// 8280111C: 895C0021  lbz r10, 0x21(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801120: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801124: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801128: 409A0008  bne cr6, 0x82801130
	if !ctx.cr[6].eq {
	pc = 0x82801130; continue 'dispatch;
	}
	// 8280112C: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82801130; continue 'dispatch;
            }
            0x82801130 => {
    //   block [0x82801130..0x82801144)
	// 82801130: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82801134: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801138: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8280113C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801140: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82801144; continue 'dispatch;
            }
            0x82801144 => {
    //   block [0x82801144..0x8280115C)
	// 82801144: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801148: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280114C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801150: 409A000C  bne cr6, 0x8280115c
	if !ctx.cr[6].eq {
	pc = 0x8280115C; continue 'dispatch;
	}
	// 82801154: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82801158: 48000020  b 0x82801178
	pc = 0x82801178; continue 'dispatch;
            }
            0x8280115C => {
    //   block [0x8280115C..0x82801174)
	// 8280115C: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801160: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801164: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82801168: 409A000C  bne cr6, 0x82801174
	if !ctx.cr[6].eq {
	pc = 0x82801174; continue 'dispatch;
	}
	// 8280116C: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82801170: 48000008  b 0x82801178
	pc = 0x82801178; continue 'dispatch;
            }
            0x82801174 => {
    //   block [0x82801174..0x82801178)
	// 82801174: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82801178; continue 'dispatch;
            }
            0x82801178 => {
    //   block [0x82801178..0x82801190)
	// 82801178: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280117C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82801180: 890B0020  lbz r8, 0x20(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801184: 893A0020  lbz r9, 0x20(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801188: 992B0020  stb r9, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u8 ) };
	// 8280118C: 991A0020  stb r8, 0x20(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(32 as u32), ctx.r[8].u8 ) };
	pc = 0x82801190; continue 'dispatch;
            }
            0x82801190 => {
    //   block [0x82801190..0x828011B4)
	// 82801190: 897A0020  lbz r11, 0x20(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801194: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82801198: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8280119C: 409A0194  bne cr6, 0x82801330
	if !ctx.cr[6].eq {
	pc = 0x82801330; continue 'dispatch;
	}
	// 828011A0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828011A4: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828011A8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828011AC: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828011B0: 419A017C  beq cr6, 0x8280132c
	if ctx.cr[6].eq {
	pc = 0x8280132C; continue 'dispatch;
	}
	pc = 0x828011B4; continue 'dispatch;
            }
            0x828011B4 => {
    //   block [0x828011B4..0x828011F4)
	// 828011B4: 897C0020  lbz r11, 0x20(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 828011B8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828011BC: 409A0170  bne cr6, 0x8280132c
	if !ctx.cr[6].eq {
	pc = 0x8280132C; continue 'dispatch;
	}
	// 828011C0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828011C4: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828011C8: 409A00A8  bne cr6, 0x82801270
	if !ctx.cr[6].eq {
	pc = 0x82801270; continue 'dispatch;
	}
	// 828011CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828011D0: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 828011D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828011D8: 409A001C  bne cr6, 0x828011f4
	if !ctx.cr[6].eq {
	pc = 0x828011F4; continue 'dispatch;
	}
	// 828011DC: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 828011E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828011E4: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 828011E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828011EC: 480B0695  bl 0x828b1880
	ctx.lr = 0x828011F0;
	sub_828B1880(ctx, base);
	// 828011F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828011F4; continue 'dispatch;
            }
            0x828011F4 => {
    //   block [0x828011F4..0x82801220)
	// 828011F4: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 828011F8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828011FC: 409A00C8  bne cr6, 0x828012c4
	if !ctx.cr[6].eq {
	pc = 0x828012C4; continue 'dispatch;
	}
	// 82801200: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801204: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801208: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 8280120C: 409A0014  bne cr6, 0x82801220
	if !ctx.cr[6].eq {
	pc = 0x82801220; continue 'dispatch;
	}
	// 82801210: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801214: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801218: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 8280121C: 419A00A4  beq cr6, 0x828012c0
	if ctx.cr[6].eq {
	pc = 0x828012C0; continue 'dispatch;
	}
	pc = 0x82801220; continue 'dispatch;
            }
            0x82801220 => {
    //   block [0x82801220..0x8280124C)
	// 82801220: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801224: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801228: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 8280122C: 409A0020  bne cr6, 0x8280124c
	if !ctx.cr[6].eq {
	pc = 0x8280124C; continue 'dispatch;
	}
	// 82801230: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801234: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82801238: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8280123C: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801240: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82801244: 4BB128B5  bl 0x82313af8
	ctx.lr = 0x82801248;
	sub_82313AF8(ctx, base);
	// 82801248: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x8280124C; continue 'dispatch;
            }
            0x8280124C => {
    //   block [0x8280124C..0x82801270)
	// 8280124C: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801250: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82801254: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801258: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 8280125C: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801260: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801264: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801268: 480B0619  bl 0x828b1880
	ctx.lr = 0x8280126C;
	sub_828B1880(ctx, base);
	// 8280126C: 480000C0  b 0x8280132c
	pc = 0x8280132C; continue 'dispatch;
            }
            0x82801270 => {
    //   block [0x82801270..0x82801294)
	// 82801270: 894B0020  lbz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801274: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801278: 409A001C  bne cr6, 0x82801294
	if !ctx.cr[6].eq {
	pc = 0x82801294; continue 'dispatch;
	}
	// 8280127C: 9BAB0020  stb r29, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801280: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82801284: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82801288: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8280128C: 4BB1286D  bl 0x82313af8
	ctx.lr = 0x82801290;
	sub_82313AF8(ctx, base);
	// 82801290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82801294; continue 'dispatch;
            }
            0x82801294 => {
    //   block [0x82801294..0x828012C0)
	// 82801294: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 82801298: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8280129C: 409A0028  bne cr6, 0x828012c4
	if !ctx.cr[6].eq {
	pc = 0x828012C4; continue 'dispatch;
	}
	// 828012A0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828012A4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828012A8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828012AC: 409A0034  bne cr6, 0x828012e0
	if !ctx.cr[6].eq {
	pc = 0x828012E0; continue 'dispatch;
	}
	// 828012B0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828012B4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828012B8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828012BC: 409A0024  bne cr6, 0x828012e0
	if !ctx.cr[6].eq {
	pc = 0x828012E0; continue 'dispatch;
	}
	pc = 0x828012C0; continue 'dispatch;
            }
            0x828012C0 => {
    //   block [0x828012C0..0x828012C4)
	// 828012C0: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	pc = 0x828012C4; continue 'dispatch;
            }
            0x828012C4 => {
    //   block [0x828012C4..0x828012E0)
	// 828012C4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828012C8: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 828012CC: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828012D0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828012D4: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828012D8: 409AFEDC  bne cr6, 0x828011b4
	if !ctx.cr[6].eq {
	pc = 0x828011B4; continue 'dispatch;
	}
	// 828012DC: 48000050  b 0x8280132c
	pc = 0x8280132C; continue 'dispatch;
            }
            0x828012E0 => {
    //   block [0x828012E0..0x8280130C)
	// 828012E0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828012E4: 892A0020  lbz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 828012E8: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828012EC: 409A0020  bne cr6, 0x8280130c
	if !ctx.cr[6].eq {
	pc = 0x8280130C; continue 'dispatch;
	}
	// 828012F0: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828012F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828012F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828012FC: 9BAA0020  stb r29, 0x20(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801300: 9BCB0020  stb r30, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 82801304: 480B057D  bl 0x828b1880
	ctx.lr = 0x82801308;
	sub_828B1880(ctx, base);
	// 82801308: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8280130C; continue 'dispatch;
            }
            0x8280130C => {
    //   block [0x8280130C..0x8280132C)
	// 8280130C: 895F0020  lbz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82801310: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82801314: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801318: 994B0020  stb r10, 0x20(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 8280131C: 9BBF0020  stb r29, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801320: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801324: 9BA90020  stb r29, 0x20(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	// 82801328: 4BB127D1  bl 0x82313af8
	ctx.lr = 0x8280132C;
	sub_82313AF8(ctx, base);
	pc = 0x8280132C; continue 'dispatch;
            }
            0x8280132C => {
    //   block [0x8280132C..0x82801330)
	// 8280132C: 9BBC0020  stb r29, 0x20(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), ctx.r[29].u8 ) };
	pc = 0x82801330; continue 'dispatch;
            }
            0x82801330 => {
    //   block [0x82801330..0x8280139C)
	// 82801330: 817A0018  lwz r11, 0x18(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82801334: 389A0014  addi r4, r26, 0x14
	ctx.r[4].s64 = ctx.r[26].s64 + 20;
	// 82801338: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8280133C: 90810058  stw r4, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 82801340: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 82801344: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82801348: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280134C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82801350: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82801354: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82801358: 4BAEF4B1  bl 0x822f0808
	ctx.lr = 0x8280135C;
	sub_822F0808(ctx, base);
	// 8280135C: 807A0018  lwz r3, 0x18(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(24 as u32) ) } as u64;
	// 82801360: 4BA1A9D9  bl 0x8221bd38
	ctx.lr = 0x82801364;
	sub_8221BD38(ctx, base);
	// 82801364: 93DA0018  stw r30, 0x18(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82801368: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8280136C: 93DA001C  stw r30, 0x1c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82801370: 4BA1A9C9  bl 0x8221bd38
	ctx.lr = 0x82801374;
	sub_8221BD38(ctx, base);
	// 82801374: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801378: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8280137C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801380: 419A001C  beq cr6, 0x8280139c
	if ctx.cr[6].eq {
	pc = 0x8280139C; continue 'dispatch;
	}
	// 82801384: E9410110  ld r10, 0x110(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 82801388: 392BFFFF  addi r9, r11, -1
	ctx.r[9].s64 = ctx.r[11].s64 + -1;
	// 8280138C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 82801390: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82801394: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82801398: 484A80B4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280139C => {
    //   block [0x8280139C..0x828013AC)
	// 8280139C: E9610110  ld r11, 0x110(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 828013A0: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828013A4: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 828013A8: 484A80A4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828013B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828013B0 size=584
    let mut pc: u32 = 0x828013B0;
    'dispatch: loop {
        match pc {
            0x828013B0 => {
    //   block [0x828013B0..0x828013D8)
	// 828013B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828013B4: 484A804D  bl 0x82ca9400
	ctx.lr = 0x828013B8;
	sub_82CA93D0(ctx, base);
	// 828013B8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828013BC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828013C0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 828013C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828013C8: 409A0010  bne cr6, 0x828013d8
	if !ctx.cr[6].eq {
	pc = 0x828013D8; continue 'dispatch;
	}
	// 828013CC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 828013D0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 828013D4: 48000008  b 0x828013dc
	pc = 0x828013DC; continue 'dispatch;
            }
            0x828013D8 => {
    //   block [0x828013D8..0x828013DC)
	// 828013D8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828013DC; continue 'dispatch;
            }
            0x828013DC => {
    //   block [0x828013DC..0x82801454)
	// 828013DC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 828013E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828013E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828013E8: 4BBCD1D9  bl 0x823ce5c0
	ctx.lr = 0x828013EC;
	sub_823CE5C0(ctx, base);
	// 828013EC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828013F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828013F4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 828013F8: 4BBCCE09  bl 0x823ce200
	ctx.lr = 0x828013FC;
	sub_823CE200(ctx, base);
	// 828013FC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82801400: 4B9B6719  bl 0x821b7b18
	ctx.lr = 0x82801404;
	sub_821B7B18(ctx, base);
	// 82801404: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 82801408: 4BA1DE51  bl 0x8221f258
	ctx.lr = 0x8280140C;
	sub_8221F258(ctx, base);
	// 8280140C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82801410: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82801414: 419A0040  beq cr6, 0x82801454
	if ctx.cr[6].eq {
	pc = 0x82801454; continue 'dispatch;
	}
	// 82801418: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 8280141C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82801420: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 82801424: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82801428: 4BA1DE31  bl 0x8221f258
	ctx.lr = 0x8280142C;
	sub_8221F258(ctx, base);
	// 8280142C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82801430: 419A0028  beq cr6, 0x82801458
	if ctx.cr[6].eq {
	pc = 0x82801458; continue 'dispatch;
	}
	// 82801434: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 82801438: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 8280143C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801440: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 82801444: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82801448: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8280144C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82801450: 4800000C  b 0x8280145c
	pc = 0x8280145C; continue 'dispatch;
            }
            0x82801454 => {
    //   block [0x82801454..0x82801458)
	// 82801454: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x82801458; continue 'dispatch;
            }
            0x82801458 => {
    //   block [0x82801458..0x8280145C)
	// 82801458: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x8280145C; continue 'dispatch;
            }
            0x8280145C => {
    //   block [0x8280145C..0x82801560)
	// 8280145C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82801460: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82801464: 419A00FC  beq cr6, 0x82801560
	if ctx.cr[6].eq {
	pc = 0x82801560; continue 'dispatch;
	}
	// 82801468: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280146C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 82801470: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801474: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82801478: 4BA27C91  bl 0x82229108
	ctx.lr = 0x8280147C;
	sub_82229108(ctx, base);
	// 8280147C: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 82801480: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82801484: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82801488: 3BCB1B20  addi r30, r11, 0x1b20
	ctx.r[30].s64 = ctx.r[11].s64 + 6944;
	// 8280148C: 4BA263F5  bl 0x82227880
	ctx.lr = 0x82801490;
	sub_82227880(ctx, base);
	// 82801490: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82801494: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 82801498: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8280149C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 828014A0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828014A4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828014A8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828014AC: 4B9995D5  bl 0x8219aa80
	ctx.lr = 0x828014B0;
	sub_8219AA80(ctx, base);
	// 828014B0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 828014B4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 828014B8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 828014BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828014C0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828014C4: 4BBCCF5D  bl 0x823ce420
	ctx.lr = 0x828014C8;
	sub_823CE420(ctx, base);
	// 828014C8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 828014CC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 828014D0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 828014D4: 482231F5  bl 0x82a246c8
	ctx.lr = 0x828014D8;
	sub_82A246C8(ctx, base);
	// 828014D8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828014DC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828014E0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 828014E4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 828014E8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828014EC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828014F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828014F4: 4BA27C15  bl 0x82229108
	ctx.lr = 0x828014F8;
	sub_82229108(ctx, base);
	// 828014F8: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 828014FC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82801500: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82801504: 3BEB1B60  addi r31, r11, 0x1b60
	ctx.r[31].s64 = ctx.r[11].s64 + 7008;
	// 82801508: 4BA26379  bl 0x82227880
	ctx.lr = 0x8280150C;
	sub_82227880(ctx, base);
	// 8280150C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 82801510: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 82801514: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82801518: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 8280151C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82801520: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82801524: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82801528: 4B999559  bl 0x8219aa80
	ctx.lr = 0x8280152C;
	sub_8219AA80(ctx, base);
	// 8280152C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 82801530: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82801534: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 82801538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280153C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801540: 4BBCCEE1  bl 0x823ce420
	ctx.lr = 0x82801544;
	sub_823CE420(ctx, base);
	// 82801544: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801548: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8280154C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82801550: 48223179  bl 0x82a246c8
	ctx.lr = 0x82801554;
	sub_82A246C8(ctx, base);
	// 82801554: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801558: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 8280155C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x82801560; continue 'dispatch;
            }
            0x82801560 => {
    //   block [0x82801560..0x82801570)
	// 82801560: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 82801564: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82801568: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 8280156C: 419A0020  beq cr6, 0x8280158c
	if ctx.cr[6].eq {
	pc = 0x8280158C; continue 'dispatch;
	}
	pc = 0x82801570; continue 'dispatch;
            }
            0x82801570 => {
    //   block [0x82801570..0x8280158C)
	// 82801570: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82801574: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801578: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8280157C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82801580: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82801584: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801588: 4082FFE8  bne 0x82801570
	if !ctx.cr[0].eq {
	pc = 0x82801570; continue 'dispatch;
	}
	pc = 0x8280158C; continue 'dispatch;
            }
            0x8280158C => {
    //   block [0x8280158C..0x828015AC)
	// 8280158C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801590: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82801594: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82801598: 4BAF43B1  bl 0x822f5948
	ctx.lr = 0x8280159C;
	sub_822F5948(ctx, base);
	// 8280159C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828015A0: 4B9B6579  bl 0x821b7b18
	ctx.lr = 0x828015A4;
	sub_821B7B18(ctx, base);
	// 828015A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 828015A8: 419A0040  beq cr6, 0x828015e8
	if ctx.cr[6].eq {
	pc = 0x828015E8; continue 'dispatch;
	}
	pc = 0x828015AC; continue 'dispatch;
            }
            0x828015AC => {
    //   block [0x828015AC..0x828015E8)
	// 828015AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828015B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828015B4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828015B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828015BC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828015C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828015C4: 4082FFE8  bne 0x828015ac
	if !ctx.cr[0].eq {
	pc = 0x828015AC; continue 'dispatch;
	}
	// 828015C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828015CC: 409A001C  bne cr6, 0x828015e8
	if !ctx.cr[6].eq {
	pc = 0x828015E8; continue 'dispatch;
	}
	// 828015D0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 828015D4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828015D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828015DC: 4E800421  bctrl
	ctx.lr = 0x828015E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828015E0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828015E4: 4BA1A755  bl 0x8221bd38
	ctx.lr = 0x828015E8;
	sub_8221BD38(ctx, base);
            }
            0x828015E8 => {
    //   block [0x828015E8..0x828015F8)
	// 828015E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828015EC: 4B9B652D  bl 0x821b7b18
	ctx.lr = 0x828015F0;
	sub_821B7B18(ctx, base);
	// 828015F0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828015F4: 484A7E5C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828015F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828015F8 size=512
    let mut pc: u32 = 0x828015F8;
    'dispatch: loop {
        match pc {
            0x828015F8 => {
    //   block [0x828015F8..0x82801630)
	// 828015F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828015FC: 484A7E01  bl 0x82ca93fc
	ctx.lr = 0x82801600;
	sub_82CA93D0(ctx, base);
	// 82801600: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801604: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82801608: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8280160C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82801610: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 82801614: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82801618: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280161C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82801620: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82801624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801628: 419A0008  beq cr6, 0x82801630
	if ctx.cr[6].eq {
	pc = 0x82801630; continue 'dispatch;
	}
	// 8280162C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82801630; continue 'dispatch;
            }
            0x82801630 => {
    //   block [0x82801630..0x828016C4)
	// 82801630: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801634: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82801638: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280163C: 4BBCCF85  bl 0x823ce5c0
	ctx.lr = 0x82801640;
	sub_823CE5C0(ctx, base);
	// 82801640: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82801644: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82801648: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8280164C: 4BBCCAC5  bl 0x823ce110
	ctx.lr = 0x82801650;
	sub_823CE110(ctx, base);
	// 82801650: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82801654: 4B9B64C5  bl 0x821b7b18
	ctx.lr = 0x82801658;
	sub_821B7B18(ctx, base);
	// 82801658: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8280165C: 4BA1DBFD  bl 0x8221f258
	ctx.lr = 0x82801660;
	sub_8221F258(ctx, base);
	// 82801660: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82801664: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82801668: 419A005C  beq cr6, 0x828016c4
	if ctx.cr[6].eq {
	pc = 0x828016C4; continue 'dispatch;
	}
	// 8280166C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82801670: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82801674: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82801678: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8280167C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82801680: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82801684: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82801688: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8280168C: 4B9EEBB5  bl 0x821f0240
	ctx.lr = 0x82801690;
	sub_821F0240(ctx, base);
	// 82801690: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82801694: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82801698: 4BA1DBC1  bl 0x8221f258
	ctx.lr = 0x8280169C;
	sub_8221F258(ctx, base);
	// 8280169C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828016A0: 419A0028  beq cr6, 0x828016c8
	if ctx.cr[6].eq {
	pc = 0x828016C8; continue 'dispatch;
	}
	// 828016A4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828016A8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828016AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828016B0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828016B4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828016B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828016BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828016C0: 4800000C  b 0x828016cc
	pc = 0x828016CC; continue 'dispatch;
            }
            0x828016C4 => {
    //   block [0x828016C4..0x828016C8)
	// 828016C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828016C8; continue 'dispatch;
            }
            0x828016C8 => {
    //   block [0x828016C8..0x828016CC)
	// 828016C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828016CC; continue 'dispatch;
            }
            0x828016CC => {
    //   block [0x828016CC..0x828016E0)
	// 828016CC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828016D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828016D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828016D8: 419A0008  beq cr6, 0x828016e0
	if ctx.cr[6].eq {
	pc = 0x828016E0; continue 'dispatch;
	}
	// 828016DC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828016E0; continue 'dispatch;
            }
            0x828016E0 => {
    //   block [0x828016E0..0x82801760)
	// 828016E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828016E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828016E8: 419A0078  beq cr6, 0x82801760
	if ctx.cr[6].eq {
	pc = 0x82801760; continue 'dispatch;
	}
	// 828016EC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828016F0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828016F4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828016F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828016FC: 4BA27A0D  bl 0x82229108
	ctx.lr = 0x82801700;
	sub_82229108(ctx, base);
	// 82801700: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 82801704: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82801708: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8280170C: 3BCB1B68  addi r30, r11, 0x1b68
	ctx.r[30].s64 = ctx.r[11].s64 + 7016;
	// 82801710: 4BA26171  bl 0x82227880
	ctx.lr = 0x82801714;
	sub_82227880(ctx, base);
	// 82801714: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82801718: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 8280171C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82801720: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 82801724: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801728: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8280172C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82801730: 4B999351  bl 0x8219aa80
	ctx.lr = 0x82801734;
	sub_8219AA80(ctx, base);
	// 82801734: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801738: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8280173C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82801740: 4BBCCCE1  bl 0x823ce420
	ctx.lr = 0x82801744;
	sub_823CE420(ctx, base);
	// 82801744: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801748: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8280174C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801750: 48222F79  bl 0x82a246c8
	ctx.lr = 0x82801754;
	sub_82A246C8(ctx, base);
	// 82801754: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801758: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8280175C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82801760; continue 'dispatch;
            }
            0x82801760 => {
    //   block [0x82801760..0x82801770)
	// 82801760: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82801764: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82801768: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8280176C: 419A0020  beq cr6, 0x8280178c
	if ctx.cr[6].eq {
	pc = 0x8280178C; continue 'dispatch;
	}
	pc = 0x82801770; continue 'dispatch;
            }
            0x82801770 => {
    //   block [0x82801770..0x8280178C)
	// 82801770: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82801774: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801778: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8280177C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82801780: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82801784: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801788: 4082FFE8  bne 0x82801770
	if !ctx.cr[0].eq {
	pc = 0x82801770; continue 'dispatch;
	}
	pc = 0x8280178C; continue 'dispatch;
            }
            0x8280178C => {
    //   block [0x8280178C..0x828017AC)
	// 8280178C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801790: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82801794: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82801798: 4BAF41B1  bl 0x822f5948
	ctx.lr = 0x8280179C;
	sub_822F5948(ctx, base);
	// 8280179C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828017A0: 4B9B6379  bl 0x821b7b18
	ctx.lr = 0x828017A4;
	sub_821B7B18(ctx, base);
	// 828017A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828017A8: 419A0040  beq cr6, 0x828017e8
	if ctx.cr[6].eq {
	pc = 0x828017E8; continue 'dispatch;
	}
	pc = 0x828017AC; continue 'dispatch;
            }
            0x828017AC => {
    //   block [0x828017AC..0x828017E8)
	// 828017AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828017B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828017B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828017B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828017BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828017C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828017C4: 4082FFE8  bne 0x828017ac
	if !ctx.cr[0].eq {
	pc = 0x828017AC; continue 'dispatch;
	}
	// 828017C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828017CC: 409A001C  bne cr6, 0x828017e8
	if !ctx.cr[6].eq {
	pc = 0x828017E8; continue 'dispatch;
	}
	// 828017D0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828017D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828017D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828017DC: 4E800421  bctrl
	ctx.lr = 0x828017E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828017E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828017E4: 4BA1A555  bl 0x8221bd38
	ctx.lr = 0x828017E8;
	sub_8221BD38(ctx, base);
            }
            0x828017E8 => {
    //   block [0x828017E8..0x828017F8)
	// 828017E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828017EC: 4B9B632D  bl 0x821b7b18
	ctx.lr = 0x828017F0;
	sub_821B7B18(ctx, base);
	// 828017F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828017F4: 484A7C58  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828017F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828017F8 size=512
    let mut pc: u32 = 0x828017F8;
    'dispatch: loop {
        match pc {
            0x828017F8 => {
    //   block [0x828017F8..0x82801830)
	// 828017F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828017FC: 484A7C01  bl 0x82ca93fc
	ctx.lr = 0x82801800;
	sub_82CA93D0(ctx, base);
	// 82801800: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801804: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82801808: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 8280180C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82801810: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 82801814: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82801818: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280181C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82801820: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 82801824: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801828: 419A0008  beq cr6, 0x82801830
	if ctx.cr[6].eq {
	pc = 0x82801830; continue 'dispatch;
	}
	// 8280182C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82801830; continue 'dispatch;
            }
            0x82801830 => {
    //   block [0x82801830..0x828018C4)
	// 82801830: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801834: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82801838: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280183C: 4BBCCD85  bl 0x823ce5c0
	ctx.lr = 0x82801840;
	sub_823CE5C0(ctx, base);
	// 82801840: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82801844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82801848: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8280184C: 4BBCC8C5  bl 0x823ce110
	ctx.lr = 0x82801850;
	sub_823CE110(ctx, base);
	// 82801850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82801854: 4B9B62C5  bl 0x821b7b18
	ctx.lr = 0x82801858;
	sub_821B7B18(ctx, base);
	// 82801858: 38600010  li r3, 0x10
	ctx.r[3].s64 = 16;
	// 8280185C: 4BA1D9FD  bl 0x8221f258
	ctx.lr = 0x82801860;
	sub_8221F258(ctx, base);
	// 82801860: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82801864: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82801868: 419A005C  beq cr6, 0x828018c4
	if ctx.cr[6].eq {
	pc = 0x828018C4; continue 'dispatch;
	}
	// 8280186C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82801870: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 82801874: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82801878: 392B7960  addi r9, r11, 0x7960
	ctx.r[9].s64 = ctx.r[11].s64 + 31072;
	// 8280187C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82801880: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82801884: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82801888: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 8280188C: 4B9EE9B5  bl 0x821f0240
	ctx.lr = 0x82801890;
	sub_821F0240(ctx, base);
	// 82801890: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82801894: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 82801898: 4BA1D9C1  bl 0x8221f258
	ctx.lr = 0x8280189C;
	sub_8221F258(ctx, base);
	// 8280189C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828018A0: 419A0028  beq cr6, 0x828018c8
	if ctx.cr[6].eq {
	pc = 0x828018C8; continue 'dispatch;
	}
	// 828018A4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 828018A8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 828018AC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828018B0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 828018B4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828018B8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 828018BC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828018C0: 4800000C  b 0x828018cc
	pc = 0x828018CC; continue 'dispatch;
            }
            0x828018C4 => {
    //   block [0x828018C4..0x828018C8)
	// 828018C4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x828018C8; continue 'dispatch;
            }
            0x828018C8 => {
    //   block [0x828018C8..0x828018CC)
	// 828018C8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x828018CC; continue 'dispatch;
            }
            0x828018CC => {
    //   block [0x828018CC..0x828018E0)
	// 828018CC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828018D0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 828018D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828018D8: 419A0008  beq cr6, 0x828018e0
	if ctx.cr[6].eq {
	pc = 0x828018E0; continue 'dispatch;
	}
	// 828018DC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828018E0; continue 'dispatch;
            }
            0x828018E0 => {
    //   block [0x828018E0..0x82801960)
	// 828018E0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 828018E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828018E8: 419A0078  beq cr6, 0x82801960
	if ctx.cr[6].eq {
	pc = 0x82801960; continue 'dispatch;
	}
	// 828018EC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828018F0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 828018F4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828018F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 828018FC: 4BA2780D  bl 0x82229108
	ctx.lr = 0x82801900;
	sub_82229108(ctx, base);
	// 82801900: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 82801904: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82801908: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8280190C: 3BCB1CC8  addi r30, r11, 0x1cc8
	ctx.r[30].s64 = ctx.r[11].s64 + 7368;
	// 82801910: 4BA25F71  bl 0x82227880
	ctx.lr = 0x82801914;
	sub_82227880(ctx, base);
	// 82801914: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82801918: 3D40825A  lis r10, -0x7da6
	ctx.r[10].s64 = -2108030976;
	// 8280191C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82801920: 388A11E0  addi r4, r10, 0x11e0
	ctx.r[4].s64 = ctx.r[10].s64 + 4576;
	// 82801924: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801928: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 8280192C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82801930: 4B999151  bl 0x8219aa80
	ctx.lr = 0x82801934;
	sub_8219AA80(ctx, base);
	// 82801934: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801938: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8280193C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82801940: 4BBCCAE1  bl 0x823ce420
	ctx.lr = 0x82801944;
	sub_823CE420(ctx, base);
	// 82801944: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82801948: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 8280194C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82801950: 48222D79  bl 0x82a246c8
	ctx.lr = 0x82801954;
	sub_82A246C8(ctx, base);
	// 82801954: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801958: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 8280195C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82801960; continue 'dispatch;
            }
            0x82801960 => {
    //   block [0x82801960..0x82801970)
	// 82801960: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82801964: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82801968: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 8280196C: 419A0020  beq cr6, 0x8280198c
	if ctx.cr[6].eq {
	pc = 0x8280198C; continue 'dispatch;
	}
	pc = 0x82801970; continue 'dispatch;
            }
            0x82801970 => {
    //   block [0x82801970..0x8280198C)
	// 82801970: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82801974: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801978: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 8280197C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82801980: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82801984: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82801988: 4082FFE8  bne 0x82801970
	if !ctx.cr[0].eq {
	pc = 0x82801970; continue 'dispatch;
	}
	pc = 0x8280198C; continue 'dispatch;
            }
            0x8280198C => {
    //   block [0x8280198C..0x828019AC)
	// 8280198C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801990: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82801994: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 82801998: 4BAF3FB1  bl 0x822f5948
	ctx.lr = 0x8280199C;
	sub_822F5948(ctx, base);
	// 8280199C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828019A0: 4B9B6179  bl 0x821b7b18
	ctx.lr = 0x828019A4;
	sub_821B7B18(ctx, base);
	// 828019A4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 828019A8: 419A0040  beq cr6, 0x828019e8
	if ctx.cr[6].eq {
	pc = 0x828019E8; continue 'dispatch;
	}
	pc = 0x828019AC; continue 'dispatch;
            }
            0x828019AC => {
    //   block [0x828019AC..0x828019E8)
	// 828019AC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 828019B0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828019B4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 828019B8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 828019BC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 828019C0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 828019C4: 4082FFE8  bne 0x828019ac
	if !ctx.cr[0].eq {
	pc = 0x828019AC; continue 'dispatch;
	}
	// 828019C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 828019CC: 409A001C  bne cr6, 0x828019e8
	if !ctx.cr[6].eq {
	pc = 0x828019E8; continue 'dispatch;
	}
	// 828019D0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 828019D4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 828019D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 828019DC: 4E800421  bctrl
	ctx.lr = 0x828019E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 828019E0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828019E4: 4BA1A355  bl 0x8221bd38
	ctx.lr = 0x828019E8;
	sub_8221BD38(ctx, base);
            }
            0x828019E8 => {
    //   block [0x828019E8..0x828019F8)
	// 828019E8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828019EC: 4B9B612D  bl 0x821b7b18
	ctx.lr = 0x828019F0;
	sub_821B7B18(ctx, base);
	// 828019F0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 828019F4: 484A7A58  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828019F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828019F8 size=296
    let mut pc: u32 = 0x828019F8;
    'dispatch: loop {
        match pc {
            0x828019F8 => {
    //   block [0x828019F8..0x82801A4C)
	// 828019F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828019FC: 484A7A01  bl 0x82ca93fc
	ctx.lr = 0x82801A00;
	sub_82CA93D0(ctx, base);
	// 82801A00: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801A04: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82801A08: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 82801A0C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 82801A10: 2F1B0007  cmpwi cr6, r27, 7
	ctx.cr[6].compare_i32(ctx.r[27].s32, 7, &mut ctx.xer);
	// 82801A14: 419A0048  beq cr6, 0x82801a5c
	if ctx.cr[6].eq {
	pc = 0x82801A5C; continue 'dispatch;
	}
	// 82801A18: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 82801A1C: 419A0040  beq cr6, 0x82801a5c
	if ctx.cr[6].eq {
	pc = 0x82801A5C; continue 'dispatch;
	}
	// 82801A20: 2F1B0009  cmpwi cr6, r27, 9
	ctx.cr[6].compare_i32(ctx.r[27].s32, 9, &mut ctx.xer);
	// 82801A24: 419A0028  beq cr6, 0x82801a4c
	if ctx.cr[6].eq {
	pc = 0x82801A4C; continue 'dispatch;
	}
	// 82801A28: 2F1B0008  cmpwi cr6, r27, 8
	ctx.cr[6].compare_i32(ctx.r[27].s32, 8, &mut ctx.xer);
	// 82801A2C: 419A0020  beq cr6, 0x82801a4c
	if ctx.cr[6].eq {
	pc = 0x82801A4C; continue 'dispatch;
	}
	// 82801A30: 81230000  lwz r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801A34: 576B083C  slwi r11, r27, 1
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82801A38: 7D1B5A14  add r8, r27, r11
	ctx.r[8].u64 = ctx.r[27].u64 + ctx.r[11].u64;
	// 82801A3C: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82801A40: 8169007C  lwz r11, 0x7c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(124 as u32) ) } as u64;
	// 82801A44: 7F8B5214  add r28, r11, r10
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82801A48: 4800001C  b 0x82801a64
	pc = 0x82801A64; continue 'dispatch;
            }
            0x82801A4C => {
    //   block [0x82801A4C..0x82801A5C)
	// 82801A4C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801A50: 816B007C  lwz r11, 0x7c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 82801A54: 3B8B0018  addi r28, r11, 0x18
	ctx.r[28].s64 = ctx.r[11].s64 + 24;
	// 82801A58: 4800000C  b 0x82801a64
	pc = 0x82801A64; continue 'dispatch;
            }
            0x82801A5C => {
    //   block [0x82801A5C..0x82801A64)
	// 82801A5C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801A60: 3B8B0008  addi r28, r11, 8
	ctx.r[28].s64 = ctx.r[11].s64 + 8;
	pc = 0x82801A64; continue 'dispatch;
            }
            0x82801A64 => {
    //   block [0x82801A64..0x82801A7C)
	// 82801A64: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801A6C: 419A0010  beq cr6, 0x82801a7c
	if ctx.cr[6].eq {
	pc = 0x82801A7C; continue 'dispatch;
	}
	// 82801A70: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82801A74: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82801A78: 4800000C  b 0x82801a84
	pc = 0x82801A84; continue 'dispatch;
            }
            0x82801A7C => {
    //   block [0x82801A7C..0x82801A80)
	// 82801A7C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	pc = 0x82801A80; continue 'dispatch;
            }
            0x82801A80 => {
    //   block [0x82801A80..0x82801A84)
	// 82801A80: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	pc = 0x82801A84; continue 'dispatch;
            }
            0x82801A84 => {
    //   block [0x82801A84..0x82801AA0)
	// 82801A84: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82801A88: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801A8C: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82801A90: 409A0010  bne cr6, 0x82801aa0
	if !ctx.cr[6].eq {
	pc = 0x82801AA0; continue 'dispatch;
	}
	// 82801A94: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82801A98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801A9C: 419A0008  beq cr6, 0x82801aa4
	if ctx.cr[6].eq {
	pc = 0x82801AA4; continue 'dispatch;
	}
	pc = 0x82801AA0; continue 'dispatch;
            }
            0x82801AA0 => {
    //   block [0x82801AA0..0x82801AA4)
	// 82801AA0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801AA4; continue 'dispatch;
            }
            0x82801AA4 => {
    //   block [0x82801AA4..0x82801B04)
	// 82801AA4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801AAC: 409A006C  bne cr6, 0x82801b18
	if !ctx.cr[6].eq {
	pc = 0x82801B18; continue 'dispatch;
	}
	// 82801AB0: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801AB4: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 82801AB8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82801ABC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82801AC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801AC4: 419A0040  beq cr6, 0x82801b04
	if ctx.cr[6].eq {
	pc = 0x82801B04; continue 'dispatch;
	}
	// 82801AC8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82801ACC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82801AD0: 4BA01B11  bl 0x822035e0
	ctx.lr = 0x82801AD4;
	sub_822035E0(ctx, base);
	// 82801AD4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82801AD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801ADC: 419A0028  beq cr6, 0x82801b04
	if ctx.cr[6].eq {
	pc = 0x82801B04; continue 'dispatch;
	}
	// 82801AE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82801AE4: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82801AE8: 4BD0E239  bl 0x8250fd20
	ctx.lr = 0x82801AEC;
	sub_8250FD20(ctx, base);
	// 82801AEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82801AF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801AF4: 419A0010  beq cr6, 0x82801b04
	if ctx.cr[6].eq {
	pc = 0x82801B04; continue 'dispatch;
	}
	// 82801AF8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82801AFC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82801B00: 4B9DA201  bl 0x821dbd00
	ctx.lr = 0x82801B04;
	sub_821DBD00(ctx, base);
	pc = 0x82801B04; continue 'dispatch;
            }
            0x82801B04 => {
    //   block [0x82801B04..0x82801B18)
	// 82801B04: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801B08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801B0C: 419AFF74  beq cr6, 0x82801a80
	if ctx.cr[6].eq {
	pc = 0x82801A80; continue 'dispatch;
	}
	// 82801B10: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 82801B14: 4BFFFF70  b 0x82801a84
	pc = 0x82801A84; continue 'dispatch;
            }
            0x82801B18 => {
    //   block [0x82801B18..0x82801B20)
	// 82801B18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82801B1C: 484A7930  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801B20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82801B20 size=56
    let mut pc: u32 = 0x82801B20;
    'dispatch: loop {
        match pc {
            0x82801B20 => {
    //   block [0x82801B20..0x82801B3C)
	// 82801B20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82801B24: 419A0018  beq cr6, 0x82801b3c
	if ctx.cr[6].eq {
	pc = 0x82801B3C; continue 'dispatch;
	}
	// 82801B28: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82801B2C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82801B30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801B34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801B38: 409A0008  bne cr6, 0x82801b40
	if !ctx.cr[6].eq {
	pc = 0x82801B40; continue 'dispatch;
	}
	pc = 0x82801B3C; continue 'dispatch;
            }
            0x82801B3C => {
    //   block [0x82801B3C..0x82801B40)
	// 82801B3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801B40; continue 'dispatch;
            }
            0x82801B40 => {
    //   block [0x82801B40..0x82801B58)
	// 82801B40: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801B44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801B48: 419A0010  beq cr6, 0x82801b58
	if ctx.cr[6].eq {
		sub_82801B58(ctx, base);
		return;
	}
	// 82801B4C: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82801B50: 556337FE  rlwinm r3, r11, 6, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x03FFFFFFu64;
	// 82801B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82801B58 size=8
    let mut pc: u32 = 0x82801B58;
    'dispatch: loop {
        match pc {
            0x82801B58 => {
    //   block [0x82801B58..0x82801B60)
	// 82801B58: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82801B5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82801B60 size=8
    let mut pc: u32 = 0x82801B60;
    'dispatch: loop {
        match pc {
            0x82801B60 => {
    //   block [0x82801B60..0x82801B68)
	// 82801B60: 386000FA  li r3, 0xfa
	ctx.r[3].s64 = 250;
	// 82801B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801B68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82801B68 size=352
    let mut pc: u32 = 0x82801B68;
    'dispatch: loop {
        match pc {
            0x82801B68 => {
    //   block [0x82801B68..0x82801B90)
	// 82801B68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82801B6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82801B70: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801B74: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82801B78: 419A0018  beq cr6, 0x82801b90
	if ctx.cr[6].eq {
	pc = 0x82801B90; continue 'dispatch;
	}
	// 82801B7C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 82801B80: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 82801B84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801B88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801B8C: 409A0008  bne cr6, 0x82801b94
	if !ctx.cr[6].eq {
	pc = 0x82801B94; continue 'dispatch;
	}
	pc = 0x82801B90; continue 'dispatch;
            }
            0x82801B90 => {
    //   block [0x82801B90..0x82801B94)
	// 82801B90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801B94; continue 'dispatch;
            }
            0x82801B94 => {
    //   block [0x82801B94..0x82801BDC)
	// 82801B94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801B98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801B9C: 419A011C  beq cr6, 0x82801cb8
	if ctx.cr[6].eq {
	pc = 0x82801CB8; continue 'dispatch;
	}
	// 82801BA0: 81440040  lwz r10, 0x40(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 82801BA4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82801BA8: 554937FE  rlwinm r9, r10, 6, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x03FFFFFFu64;
	// 82801BAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82801BB0: 419A00E8  beq cr6, 0x82801c98
	if ctx.cr[6].eq {
	pc = 0x82801C98; continue 'dispatch;
	}
	// 82801BB4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 82801BB8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 82801BBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801BC0: 419A001C  beq cr6, 0x82801bdc
	if ctx.cr[6].eq {
	pc = 0x82801BDC; continue 'dispatch;
	}
	// 82801BC4: 896B00FA  lbz r11, 0xfa(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(250 as u32) ) } as u64;
	// 82801BC8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 82801BCC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82801BD0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801BD4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801BD8: 480000C4  b 0x82801c9c
	pc = 0x82801C9C; continue 'dispatch;
            }
            0x82801BDC => {
    //   block [0x82801BDC..0x82801BF8)
	// 82801BDC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 82801BE0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82801BE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82801BE8: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82801BEC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82801BF0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82801BF4: 40810054  ble 0x82801c48
	if !ctx.cr[0].gt {
	pc = 0x82801C48; continue 'dispatch;
	}
	pc = 0x82801BF8; continue 'dispatch;
            }
            0x82801BF8 => {
    //   block [0x82801BF8..0x82801C18)
	// 82801BF8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82801BFC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82801C00: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82801C04: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801C08: 2F0700FA  cmpwi cr6, r7, 0xfa
	ctx.cr[6].compare_i32(ctx.r[7].s32, 250, &mut ctx.xer);
	// 82801C0C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82801C10: 41980008  blt cr6, 0x82801c18
	if ctx.cr[6].lt {
	pc = 0x82801C18; continue 'dispatch;
	}
	// 82801C14: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82801C18; continue 'dispatch;
            }
            0x82801C18 => {
    //   block [0x82801C18..0x82801C34)
	// 82801C18: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82801C1C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82801C20: 419A0014  beq cr6, 0x82801c34
	if ctx.cr[6].eq {
	pc = 0x82801C34; continue 'dispatch;
	}
	// 82801C24: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82801C28: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82801C2C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82801C30: 4800000C  b 0x82801c3c
	pc = 0x82801C3C; continue 'dispatch;
            }
            0x82801C34 => {
    //   block [0x82801C34..0x82801C3C)
	// 82801C34: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82801C38: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82801C3C; continue 'dispatch;
            }
            0x82801C3C => {
    //   block [0x82801C3C..0x82801C48)
	// 82801C3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82801C40: 4199FFB8  bgt cr6, 0x82801bf8
	if ctx.cr[6].gt {
	pc = 0x82801BF8; continue 'dispatch;
	}
	// 82801C44: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82801C48; continue 'dispatch;
            }
            0x82801C48 => {
    //   block [0x82801C48..0x82801C64)
	// 82801C48: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82801C4C: 419A003C  beq cr6, 0x82801c88
	if ctx.cr[6].eq {
	pc = 0x82801C88; continue 'dispatch;
	}
	// 82801C50: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801C54: 2F0B00FA  cmpwi cr6, r11, 0xfa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 250, &mut ctx.xer);
	// 82801C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801C5C: 41990008  bgt cr6, 0x82801c64
	if ctx.cr[6].gt {
	pc = 0x82801C64; continue 'dispatch;
	}
	// 82801C60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801C64; continue 'dispatch;
            }
            0x82801C64 => {
    //   block [0x82801C64..0x82801C88)
	// 82801C64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801C6C: 409A001C  bne cr6, 0x82801c88
	if !ctx.cr[6].eq {
	pc = 0x82801C88; continue 'dispatch;
	}
	// 82801C70: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82801C74: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801C78: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82801C7C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82801C80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801C84: 48000018  b 0x82801c9c
	pc = 0x82801C9C; continue 'dispatch;
            }
            0x82801C88 => {
    //   block [0x82801C88..0x82801C98)
	// 82801C88: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82801C8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801C90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801C94: 48000008  b 0x82801c9c
	pc = 0x82801C9C; continue 'dispatch;
            }
            0x82801C98 => {
    //   block [0x82801C98..0x82801C9C)
	// 82801C98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82801C9C; continue 'dispatch;
            }
            0x82801C9C => {
    //   block [0x82801C9C..0x82801CB8)
	// 82801C9C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82801CA0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801CA4: 419A0014  beq cr6, 0x82801cb8
	if ctx.cr[6].eq {
	pc = 0x82801CB8; continue 'dispatch;
	}
	// 82801CA8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801CAC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 82801CB0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82801CB4: 4E800421  bctrl
	ctx.lr = 0x82801CB8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82801CB8 => {
    //   block [0x82801CB8..0x82801CC8)
	// 82801CB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82801CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82801CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82801CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82801CC8 size=376
    let mut pc: u32 = 0x82801CC8;
    'dispatch: loop {
        match pc {
            0x82801CC8 => {
    //   block [0x82801CC8..0x82801CF4)
	// 82801CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82801CCC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82801CD0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801CD4: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 82801CD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801CDC: 419A0018  beq cr6, 0x82801cf4
	if ctx.cr[6].eq {
	pc = 0x82801CF4; continue 'dispatch;
	}
	// 82801CE0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 82801CE4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82801CE8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801CEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82801CF0: 409A0008  bne cr6, 0x82801cf8
	if !ctx.cr[6].eq {
	pc = 0x82801CF8; continue 'dispatch;
	}
	pc = 0x82801CF4; continue 'dispatch;
            }
            0x82801CF4 => {
    //   block [0x82801CF4..0x82801CF8)
	// 82801CF4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x82801CF8; continue 'dispatch;
            }
            0x82801CF8 => {
    //   block [0x82801CF8..0x82801D44)
	// 82801CF8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 82801CFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801D00: 419A0130  beq cr6, 0x82801e30
	if ctx.cr[6].eq {
	pc = 0x82801E30; continue 'dispatch;
	}
	// 82801D04: 812B0040  lwz r9, 0x40(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82801D08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82801D0C: 552837FE  rlwinm r8, r9, 6, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x03FFFFFFu64;
	// 82801D10: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82801D14: 419A00F8  beq cr6, 0x82801e0c
	if ctx.cr[6].eq {
	pc = 0x82801E0C; continue 'dispatch;
	}
	// 82801D18: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82801D1C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801D20: 419A0024  beq cr6, 0x82801d44
	if ctx.cr[6].eq {
	pc = 0x82801D44; continue 'dispatch;
	}
	// 82801D24: 892A00FA  lbz r9, 0xfa(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(250 as u32) ) } as u64;
	// 82801D28: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82801D2C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 82801D30: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82801D34: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801D38: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82801D3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801D40: 480000D0  b 0x82801e10
	pc = 0x82801E10; continue 'dispatch;
            }
            0x82801D44 => {
    //   block [0x82801D44..0x82801D64)
	// 82801D44: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 82801D48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82801D4C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 82801D50: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 82801D54: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 82801D58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82801D5C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82801D60: 40810054  ble 0x82801db4
	if !ctx.cr[0].gt {
	pc = 0x82801DB4; continue 'dispatch;
	}
	pc = 0x82801D64; continue 'dispatch;
            }
            0x82801D64 => {
    //   block [0x82801D64..0x82801D84)
	// 82801D64: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82801D68: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82801D6C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 82801D70: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801D74: 2F0700FA  cmpwi cr6, r7, 0xfa
	ctx.cr[6].compare_i32(ctx.r[7].s32, 250, &mut ctx.xer);
	// 82801D78: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 82801D7C: 41980008  blt cr6, 0x82801d84
	if ctx.cr[6].lt {
	pc = 0x82801D84; continue 'dispatch;
	}
	// 82801D80: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x82801D84; continue 'dispatch;
            }
            0x82801D84 => {
    //   block [0x82801D84..0x82801DA0)
	// 82801D84: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 82801D88: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82801D8C: 419A0014  beq cr6, 0x82801da0
	if ctx.cr[6].eq {
	pc = 0x82801DA0; continue 'dispatch;
	}
	// 82801D90: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 82801D94: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 82801D98: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82801D9C: 4800000C  b 0x82801da8
	pc = 0x82801DA8; continue 'dispatch;
            }
            0x82801DA0 => {
    //   block [0x82801DA0..0x82801DA8)
	// 82801DA0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 82801DA4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x82801DA8; continue 'dispatch;
            }
            0x82801DA8 => {
    //   block [0x82801DA8..0x82801DB4)
	// 82801DA8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82801DAC: 4199FFB8  bgt cr6, 0x82801d64
	if ctx.cr[6].gt {
	pc = 0x82801D64; continue 'dispatch;
	}
	// 82801DB0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x82801DB4; continue 'dispatch;
            }
            0x82801DB4 => {
    //   block [0x82801DB4..0x82801DD0)
	// 82801DB4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 82801DB8: 419A0040  beq cr6, 0x82801df8
	if ctx.cr[6].eq {
	pc = 0x82801DF8; continue 'dispatch;
	}
	// 82801DBC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82801DC0: 2F0B00FA  cmpwi cr6, r11, 0xfa
	ctx.cr[6].compare_i32(ctx.r[11].s32, 250, &mut ctx.xer);
	// 82801DC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801DC8: 41990008  bgt cr6, 0x82801dd0
	if ctx.cr[6].gt {
	pc = 0x82801DD0; continue 'dispatch;
	}
	// 82801DCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801DD0; continue 'dispatch;
            }
            0x82801DD0 => {
    //   block [0x82801DD0..0x82801DF8)
	// 82801DD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801DD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801DD8: 409A0020  bne cr6, 0x82801df8
	if !ctx.cr[6].eq {
	pc = 0x82801DF8; continue 'dispatch;
	}
	// 82801DDC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82801DE0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82801DE4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82801DE8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801DEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82801DF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801DF4: 4800001C  b 0x82801e10
	pc = 0x82801E10; continue 'dispatch;
            }
            0x82801DF8 => {
    //   block [0x82801DF8..0x82801E0C)
	// 82801DF8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 82801DFC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801E00: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82801E04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82801E08: 48000008  b 0x82801e10
	pc = 0x82801E10; continue 'dispatch;
            }
            0x82801E0C => {
    //   block [0x82801E0C..0x82801E10)
	// 82801E0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82801E10; continue 'dispatch;
            }
            0x82801E10 => {
    //   block [0x82801E10..0x82801E30)
	// 82801E10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82801E14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801E18: 419A0018  beq cr6, 0x82801e30
	if ctx.cr[6].eq {
	pc = 0x82801E30; continue 'dispatch;
	}
	// 82801E1C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801E20: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 82801E24: 7D435378  mr r3, r10
	ctx.r[3].u64 = ctx.r[10].u64;
	// 82801E28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82801E2C: 4E800421  bctrl
	ctx.lr = 0x82801E30;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x82801E30 => {
    //   block [0x82801E30..0x82801E40)
	// 82801E30: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82801E34: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82801E38: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82801E3C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801E40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82801E40 size=108
    let mut pc: u32 = 0x82801E40;
    'dispatch: loop {
        match pc {
            0x82801E40 => {
    //   block [0x82801E40..0x82801EAC)
	// 82801E40: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 82801E44: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 82801E48: F881FFF0  std r4, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[4].u64 ) };
	// 82801E4C: 894BEB8E  lbz r10, -0x1472(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5234 as u32) ) } as u64;
	// 82801E50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82801E54: 419A0058  beq cr6, 0x82801eac
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82801EAC);
		return;
	}
	// 82801E58: 3D608336  lis r11, -0x7cca
	ctx.r[11].s64 = -2093613056;
	// 82801E5C: 394B0320  addi r10, r11, 0x320
	ctx.r[10].s64 = ctx.r[11].s64 + 800;
	// 82801E60: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82801E64: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82801E68: 409A0044  bne cr6, 0x82801eac
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82801EAC);
		return;
	}
	// 82801E6C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82801E70: C1A10018  lfs f13, 0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82801E74: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82801E78: 816B5FE8  lwz r11, 0x5fe8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24552 as u32) ) } as u64;
	// 82801E7C: C00AB960  lfs f0, -0x46a0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-18080 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82801E80: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 82801E84: F921FFF8  std r9, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[9].u64 ) };
	// 82801E88: C981FFF8  lfd f12, -8(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 82801E8C: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 82801E90: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82801E94: ED205024  fdivs f9, f0, f10
	ctx.f[9].f64 = ((ctx.f[0].f64 / ctx.f[10].f64) as f32) as f64;
	// 82801E98: ED090372  fmuls f8, f9, f13
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82801E9C: D101FFF0  stfs f8, -0x10(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 82801EA0: E901FFF0  ld r8, -0x10(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82801EA4: F9030004  std r8, 4(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[8].u64 ) };
	// 82801EA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82801EB8 size=212
    let mut pc: u32 = 0x82801EB8;
    'dispatch: loop {
        match pc {
            0x82801EB8 => {
    //   block [0x82801EB8..0x82801F8C)
	// 82801EB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82801EBC: 484A754D  bl 0x82ca9408
	ctx.lr = 0x82801EC0;
	sub_82CA93D0(ctx, base);
	// 82801EC0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801EC4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82801EC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82801ECC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82801ED0: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 82801ED4: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 82801ED8: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 82801EDC: 9BFD0010  stb r31, 0x10(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[31].u8 ) };
	// 82801EE0: 480000B1  bl 0x82801f90
	ctx.lr = 0x82801EE4;
	sub_82801F90(ctx, base);
	// 82801EE4: 3BC00034  li r30, 0x34
	ctx.r[30].s64 = 52;
	// 82801EE8: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 82801EEC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82801EF0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 82801EF4: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82801EF8: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82801EFC: 3B8BBB28  addi r28, r11, -0x44d8
	ctx.r[28].s64 = ctx.r[11].s64 + -17624;
	// 82801F00: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82801F04: 4B9EE33D  bl 0x821f0240
	ctx.lr = 0x82801F08;
	sub_821F0240(ctx, base);
	// 82801F08: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 82801F0C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82801F10: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82801F14: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 82801F18: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82801F1C: 4B9EE325  bl 0x821f0240
	ctx.lr = 0x82801F20;
	sub_821F0240(ctx, base);
	// 82801F20: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82801F24: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 82801F28: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82801F2C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 82801F30: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82801F34: 4BA6326D  bl 0x822651a0
	ctx.lr = 0x82801F38;
	sub_822651A0(ctx, base);
	// 82801F38: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82801F3C: 39000035  li r8, 0x35
	ctx.r[8].s64 = 53;
	// 82801F40: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 82801F44: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82801F48: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 82801F4C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82801F50: 3887BB2C  addi r4, r7, -0x44d4
	ctx.r[4].s64 = ctx.r[7].s64 + -17620;
	// 82801F54: 4BA6324D  bl 0x822651a0
	ctx.lr = 0x82801F58;
	sub_822651A0(ctx, base);
	// 82801F58: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82801F5C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82801F60: 48000121  bl 0x82802080
	ctx.lr = 0x82801F64;
	sub_82802080(ctx, base);
	// 82801F64: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82801F68: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82801F6C: 48000115  bl 0x82802080
	ctx.lr = 0x82801F70;
	sub_82802080(ctx, base);
	// 82801F70: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82801F74: 4BA12E65  bl 0x82214dd8
	ctx.lr = 0x82801F78;
	sub_82214DD8(ctx, base);
	// 82801F78: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 82801F7C: 4BA12E5D  bl 0x82214dd8
	ctx.lr = 0x82801F80;
	sub_82214DD8(ctx, base);
	// 82801F80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82801F84: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82801F88: 484A74D0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82801F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82801F90 size=240
    let mut pc: u32 = 0x82801F90;
    'dispatch: loop {
        match pc {
            0x82801F90 => {
    //   block [0x82801F90..0x82801FC0)
	// 82801F90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82801F94: 484A7471  bl 0x82ca9404
	ctx.lr = 0x82801F98;
	sub_82CA93D0(ctx, base);
	// 82801F98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82801F9C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82801FA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801FA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82801FA8: 419A0018  beq cr6, 0x82801fc0
	if ctx.cr[6].eq {
	pc = 0x82801FC0; continue 'dispatch;
	}
	// 82801FAC: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 82801FB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82801FB4: 7D2B2670  srawi r11, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 4) as i64;
	// 82801FB8: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 82801FBC: 409800BC  bge cr6, 0x82802078
	if !ctx.cr[6].lt {
	pc = 0x82802078; continue 'dispatch;
	}
	pc = 0x82801FC0; continue 'dispatch;
            }
            0x82801FC0 => {
    //   block [0x82801FC0..0x82801FFC)
	// 82801FC0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82801FC4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82801FC8: 4BC21271  bl 0x82423238
	ctx.lr = 0x82801FCC;
	sub_82423238(ctx, base);
	// 82801FCC: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82801FD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82801FD4: 839D0008  lwz r28, 8(r29)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82801FD8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82801FDC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82801FE0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82801FE4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82801FE8: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82801FEC: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82801FF0: 419A0048  beq cr6, 0x82802038
	if ctx.cr[6].eq {
	pc = 0x82802038; continue 'dispatch;
	}
	// 82801FF4: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82801FF8: 3BDB0008  addi r30, r27, 8
	ctx.r[30].s64 = ctx.r[27].s64 + 8;
	pc = 0x82801FFC; continue 'dispatch;
            }
            0x82801FFC => {
    //   block [0x82801FFC..0x82802028)
	// 82801FFC: 357EFFF8  addic. r11, r30, -8
	ctx.xer.ca = (ctx.r[30].u32 > (!(-8 as u32)));
	ctx.r[11].s64 = ctx.r[30].s64 + -8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82802000: 41820028  beq 0x82802028
	if ctx.cr[0].eq {
	pc = 0x82802028; continue 'dispatch;
	}
	// 82802004: 897F0000  lbz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802008: 389F000C  addi r4, r31, 0xc
	ctx.r[4].s64 = ctx.r[31].s64 + 12;
	// 8280200C: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 82802010: 997EFFF8  stb r11, -8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), ctx.r[11].u8 ) };
	// 82802014: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802018: 915EFFFC  stw r10, -4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 8280201C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802020: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82802024: 4B9EE21D  bl 0x821f0240
	ctx.lr = 0x82802028;
	sub_821F0240(ctx, base);
	pc = 0x82802028; continue 'dispatch;
            }
            0x82802028 => {
    //   block [0x82802028..0x82802038)
	// 82802028: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 8280202C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82802030: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82802034: 409AFFC8  bne cr6, 0x82801ffc
	if !ctx.cr[6].eq {
	pc = 0x82801FFC; continue 'dispatch;
	}
	pc = 0x82802038; continue 'dispatch;
            }
            0x82802038 => {
    //   block [0x82802038..0x82802060)
	// 82802038: 809D0004  lwz r4, 4(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280203C: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802040: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82802044: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 82802048: 7D7F2670  srawi r31, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[31].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8280204C: 419A0014  beq cr6, 0x82802060
	if ctx.cr[6].eq {
	pc = 0x82802060; continue 'dispatch;
	}
	// 82802050: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82802054: 4BBC87DD  bl 0x823ca830
	ctx.lr = 0x82802058;
	sub_823CA830(ctx, base);
	// 82802058: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280205C: 4BA19CDD  bl 0x8221bd38
	ctx.lr = 0x82802060;
	sub_8221BD38(ctx, base);
	pc = 0x82802060; continue 'dispatch;
            }
            0x82802060 => {
    //   block [0x82802060..0x82802078)
	// 82802060: 57EB2036  slwi r11, r31, 4
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82802064: 937D0004  stw r27, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82802068: 395B0020  addi r10, r27, 0x20
	ctx.r[10].s64 = ctx.r[27].s64 + 32;
	// 8280206C: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 82802070: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 82802074: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x82802078; continue 'dispatch;
            }
            0x82802078 => {
    //   block [0x82802078..0x82802080)
	// 82802078: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8280207C: 484A73D8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802080 size=188
    let mut pc: u32 = 0x82802080;
    'dispatch: loop {
        match pc {
            0x82802080 => {
    //   block [0x82802080..0x828020B0)
	// 82802080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802084: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82802088: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8280208C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82802090: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802094: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82802098: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 8280209C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828020A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828020A4: 409A000C  bne cr6, 0x828020b0
	if !ctx.cr[6].eq {
	pc = 0x828020B0; continue 'dispatch;
	}
	// 828020A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828020AC: 48000010  b 0x828020bc
	pc = 0x828020BC; continue 'dispatch;
            }
            0x828020B0 => {
    //   block [0x828020B0..0x828020BC)
	// 828020B0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 828020B4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 828020B8: 7D2A2670  srawi r10, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x828020BC; continue 'dispatch;
            }
            0x828020BC => {
    //   block [0x828020BC..0x828020FC)
	// 828020BC: 83FE0008  lwz r31, 8(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828020C0: 7D6BF850  subf r11, r11, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 828020C4: 7D692670  srawi r9, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828020C8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828020CC: 4098003C  bge cr6, 0x82802108
	if !ctx.cr[6].lt {
	pc = 0x82802108; continue 'dispatch;
	}
	// 828020D0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828020D4: 419A0028  beq cr6, 0x828020fc
	if ctx.cr[6].eq {
	pc = 0x828020FC; continue 'dispatch;
	}
	// 828020D8: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828020DC: 3886000C  addi r4, r6, 0xc
	ctx.r[4].s64 = ctx.r[6].s64 + 12;
	// 828020E0: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 828020E4: 997F0000  stb r11, 0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 828020E8: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828020EC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828020F0: 81260008  lwz r9, 8(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828020F4: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828020F8: 4B9EE149  bl 0x821f0240
	ctx.lr = 0x828020FC;
	sub_821F0240(ctx, base);
	pc = 0x828020FC; continue 'dispatch;
            }
            0x828020FC => {
    //   block [0x828020FC..0x82802108)
	// 828020FC: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 82802100: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82802104: 48000020  b 0x82802124
	pc = 0x82802124; continue 'dispatch;
            }
            0x82802108 => {
    //   block [0x82802108..0x82802124)
	// 82802108: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8280210C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82802110: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82802114: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802118: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8280211C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82802120: 48000091  bl 0x828021b0
	ctx.lr = 0x82802124;
	sub_828021B0(ctx, base);
	pc = 0x82802124; continue 'dispatch;
            }
            0x82802124 => {
    //   block [0x82802124..0x8280213C)
	// 82802124: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82802128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8280212C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82802130: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82802134: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82802138: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802140 size=112
    let mut pc: u32 = 0x82802140;
    'dispatch: loop {
        match pc {
            0x82802140 => {
    //   block [0x82802140..0x82802168)
	// 82802140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802144: 484A72C1  bl 0x82ca9404
	ctx.lr = 0x82802148;
	sub_82CA93D0(ctx, base);
	// 82802148: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280214C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82802150: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 82802154: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82802158: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8280215C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82802160: 419A0040  beq cr6, 0x828021a0
	if ctx.cr[6].eq {
	pc = 0x828021A0; continue 'dispatch;
	}
	// 82802164: 3BFB0008  addi r31, r27, 8
	ctx.r[31].s64 = ctx.r[27].s64 + 8;
	pc = 0x82802168; continue 'dispatch;
            }
            0x82802168 => {
    //   block [0x82802168..0x82802194)
	// 82802168: 357FFFF8  addic. r11, r31, -8
	ctx.xer.ca = (ctx.r[31].u32 > (!(-8 as u32)));
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8280216C: 41820028  beq 0x82802194
	if ctx.cr[0].eq {
	pc = 0x82802194; continue 'dispatch;
	}
	// 82802170: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802174: 389E000C  addi r4, r30, 0xc
	ctx.r[4].s64 = ctx.r[30].s64 + 12;
	// 82802178: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8280217C: 997FFFF8  stb r11, -8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[11].u8 ) };
	// 82802180: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802184: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 82802188: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280218C: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 82802190: 4B9EE0B1  bl 0x821f0240
	ctx.lr = 0x82802194;
	sub_821F0240(ctx, base);
	pc = 0x82802194; continue 'dispatch;
            }
            0x82802194 => {
    //   block [0x82802194..0x828021A0)
	// 82802194: 37BDFFFF  addic. r29, r29, -1
	ctx.xer.ca = (ctx.r[29].u32 > (!(-1 as u32)));
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 82802198: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 8280219C: 4082FFCC  bne 0x82802168
	if !ctx.cr[0].eq {
	pc = 0x82802168; continue 'dispatch;
	}
	pc = 0x828021A0; continue 'dispatch;
            }
            0x828021A0 => {
    //   block [0x828021A0..0x828021B0)
	// 828021A0: 578B2036  slwi r11, r28, 4
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828021A4: 7C6BDA14  add r3, r11, r27
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 828021A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828021AC: 484A72A8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828021B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828021B0 size=684
    let mut pc: u32 = 0x828021B0;
    'dispatch: loop {
        match pc {
            0x828021B0 => {
    //   block [0x828021B0..0x828021FC)
	// 828021B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828021B4: 484A7251  bl 0x82ca9404
	ctx.lr = 0x828021B8;
	sub_82CA93D0(ctx, base);
	// 828021B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828021BC: 89660000  lbz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 828021C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828021C4: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828021C8: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828021CC: 81260008  lwz r9, 8(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 828021D0: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 828021D4: 3886000C  addi r4, r6, 0xc
	ctx.r[4].s64 = ctx.r[6].s64 + 12;
	// 828021D8: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 828021DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828021E0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 828021E4: 4B9EE05D  bl 0x821f0240
	ctx.lr = 0x828021E8;
	sub_821F0240(ctx, base);
	// 828021E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828021EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828021F0: 409A000C  bne cr6, 0x828021fc
	if !ctx.cr[6].eq {
	pc = 0x828021FC; continue 'dispatch;
	}
	// 828021F4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 828021F8: 48000010  b 0x82802208
	pc = 0x82802208; continue 'dispatch;
            }
            0x828021FC => {
    //   block [0x828021FC..0x82802208)
	// 828021FC: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802200: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82802204: 7D292670  srawi r9, r9, 4
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 4) as i64;
	pc = 0x82802208; continue 'dispatch;
            }
            0x82802208 => {
    //   block [0x82802208..0x8280223C)
	// 82802208: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280220C: 3D400FFF  lis r10, 0xfff
	ctx.r[10].s64 = 268369920;
	// 82802210: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 82802214: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 82802218: 7D0B2670  srawi r11, r8, 4
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 4) as i64;
	// 8280221C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82802220: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 82802224: 40980018  bge cr6, 0x8280223c
	if !ctx.cr[6].lt {
	pc = 0x8280223C; continue 'dispatch;
	}
	// 82802228: 482452A1  bl 0x82a474c8
	ctx.lr = 0x8280222C;
	sub_82A474C8(ctx, base);
	// 8280222C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82802230: 4BA12BA9  bl 0x82214dd8
	ctx.lr = 0x82802234;
	sub_82214DD8(ctx, base);
	// 82802234: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82802238: 484A721C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280223C => {
    //   block [0x8280223C..0x82802260)
	// 8280223C: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 82802240: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82802244: 409800D0  bge cr6, 0x82802314
	if !ctx.cr[6].lt {
	pc = 0x82802314; continue 'dispatch;
	}
	// 82802248: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8280224C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82802250: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 82802254: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82802258: 41980008  blt cr6, 0x82802260
	if ctx.cr[6].lt {
	pc = 0x82802260; continue 'dispatch;
	}
	// 8280225C: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x82802260; continue 'dispatch;
            }
            0x82802260 => {
    //   block [0x82802260..0x8280226C)
	// 82802260: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82802264: 40980008  bge cr6, 0x8280226c
	if !ctx.cr[6].lt {
	pc = 0x8280226C; continue 'dispatch;
	}
	// 82802268: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x8280226C; continue 'dispatch;
            }
            0x8280226C => {
    //   block [0x8280226C..0x828022E8)
	// 8280226C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82802270: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82802274: 4BC20FC5  bl 0x82423238
	ctx.lr = 0x82802278;
	sub_82423238(ctx, base);
	// 82802278: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 8280227C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82802280: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802284: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82802288: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 8280228C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82802290: 480001D1  bl 0x82802460
	ctx.lr = 0x82802294;
	sub_82802460(ctx, base);
	// 82802294: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82802298: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8280229C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 828022A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828022A4: 4BFFFE9D  bl 0x82802140
	ctx.lr = 0x828022A8;
	sub_82802140(ctx, base);
	// 828022A8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 828022AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828022B0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828022B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828022B8: 480001A9  bl 0x82802460
	ctx.lr = 0x828022BC;
	sub_82802460(ctx, base);
	// 828022BC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828022C0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828022C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 828022C8: 7D642850  subf r11, r4, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[4].s64;
	// 828022CC: 7D6B2670  srawi r11, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 828022D0: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 828022D4: 419A0014  beq cr6, 0x828022e8
	if ctx.cr[6].eq {
	pc = 0x828022E8; continue 'dispatch;
	}
	// 828022D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828022DC: 4BBC8555  bl 0x823ca830
	ctx.lr = 0x828022E0;
	sub_823CA830(ctx, base);
	// 828022E0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828022E4: 4BA19A55  bl 0x8221bd38
	ctx.lr = 0x828022E8;
	sub_8221BD38(ctx, base);
	pc = 0x828022E8; continue 'dispatch;
            }
            0x828022E8 => {
    //   block [0x828022E8..0x82802314)
	// 828022E8: 57AB2036  slwi r11, r29, 4
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828022EC: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 828022F0: 578A2036  slwi r10, r28, 4
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 828022F4: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 828022F8: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 828022FC: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 82802300: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82802304: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82802308: 4BA12AD1  bl 0x82214dd8
	ctx.lr = 0x8280230C;
	sub_82214DD8(ctx, base);
	// 8280230C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82802310: 484A7144  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802314 => {
    //   block [0x82802314..0x8280237C)
	// 82802314: 83C100AC  lwz r30, 0xac(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 82802318: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280231C: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 82802320: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 82802324: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 82802328: 4098008C  bge cr6, 0x828023b4
	if !ctx.cr[6].lt {
	pc = 0x828023B4; continue 'dispatch;
	}
	// 8280232C: 38DE0010  addi r6, r30, 0x10
	ctx.r[6].s64 = ctx.r[30].s64 + 16;
	// 82802330: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82802334: 4800012D  bl 0x82802460
	ctx.lr = 0x82802338;
	sub_82802460(ctx, base);
	// 82802338: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280233C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82802340: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 82802344: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82802348: 7D6A2670  srawi r10, r11, 4
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 4) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 4) as i64;
	// 8280234C: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 82802350: 4BFFFDF1  bl 0x82802140
	ctx.lr = 0x82802354;
	sub_82802140(ctx, base);
	// 82802354: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802358: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8280235C: 3BABFFF0  addi r29, r11, -0x10
	ctx.r[29].s64 = ctx.r[11].s64 + -16;
	// 82802360: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82802364: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82802368: 419A00E4  beq cr6, 0x8280244c
	if ctx.cr[6].eq {
	pc = 0x8280244C; continue 'dispatch;
	}
	// 8280236C: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82802370: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82802374: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802378: 8B610050  lbz r27, 0x50(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x8280237C; continue 'dispatch;
            }
            0x8280237C => {
    //   block [0x8280237C..0x828023B4)
	// 8280237C: 9B7FFFF8  stb r27, -8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[27].u8 ) };
	// 82802380: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82802384: 939FFFFC  stw r28, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[28].u32 ) };
	// 82802388: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8280238C: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82802390: 4BA62E11  bl 0x822651a0
	ctx.lr = 0x82802394;
	sub_822651A0(ctx, base);
	// 82802394: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82802398: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 8280239C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828023A0: 409AFFDC  bne cr6, 0x8280237c
	if !ctx.cr[6].eq {
	pc = 0x8280237C; continue 'dispatch;
	}
	// 828023A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828023A8: 4BA12A31  bl 0x82214dd8
	ctx.lr = 0x828023AC;
	sub_82214DD8(ctx, base);
	// 828023AC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828023B0: 484A70A4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x828023B4 => {
    //   block [0x828023B4..0x828023D4)
	// 828023B4: 3BA5FFF0  addi r29, r5, -0x10
	ctx.r[29].s64 = ctx.r[5].s64 + -16;
	// 828023B8: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 828023BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 828023C0: 480000A1  bl 0x82802460
	ctx.lr = 0x828023C4;
	sub_82802460(ctx, base);
	// 828023C4: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 828023C8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 828023CC: 419A003C  beq cr6, 0x82802408
	if ctx.cr[6].eq {
	pc = 0x82802408; continue 'dispatch;
	}
	// 828023D0: 3BFD0018  addi r31, r29, 0x18
	ctx.r[31].s64 = ctx.r[29].s64 + 24;
	pc = 0x828023D4; continue 'dispatch;
            }
            0x828023D4 => {
    //   block [0x828023D4..0x82802408)
	// 828023D4: 3BBDFFF0  addi r29, r29, -0x10
	ctx.r[29].s64 = ctx.r[29].s64 + -16;
	// 828023D8: 3BFFFFF0  addi r31, r31, -0x10
	ctx.r[31].s64 = ctx.r[31].s64 + -16;
	// 828023DC: 389FFFF4  addi r4, r31, -0xc
	ctx.r[4].s64 = ctx.r[31].s64 + -12;
	// 828023E0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828023E4: 897D0000  lbz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 828023E8: 997FFFF8  stb r11, -8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[11].u8 ) };
	// 828023EC: 815FFFEC  lwz r10, -0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20 as u32) ) } as u64;
	// 828023F0: 915FFFFC  stw r10, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[10].u32 ) };
	// 828023F4: 813FFFF0  lwz r9, -0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) } as u64;
	// 828023F8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828023FC: 4BA62DA5  bl 0x822651a0
	ctx.lr = 0x82802400;
	sub_822651A0(ctx, base);
	// 82802400: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 82802404: 409AFFD0  bne cr6, 0x828023d4
	if !ctx.cr[6].eq {
	pc = 0x828023D4; continue 'dispatch;
	}
	pc = 0x82802408; continue 'dispatch;
            }
            0x82802408 => {
    //   block [0x82802408..0x82802424)
	// 82802408: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 8280240C: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82802410: 419A003C  beq cr6, 0x8280244c
	if ctx.cr[6].eq {
	pc = 0x8280244C; continue 'dispatch;
	}
	// 82802414: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 82802418: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8280241C: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802420: 8B810050  lbz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82802424; continue 'dispatch;
            }
            0x82802424 => {
    //   block [0x82802424..0x8280244C)
	// 82802424: 9B9FFFF8  stb r28, -8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), ctx.r[28].u8 ) };
	// 82802428: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 8280242C: 93BFFFFC  stw r29, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[29].u32 ) };
	// 82802430: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82802434: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82802438: 4BA62D69  bl 0x822651a0
	ctx.lr = 0x8280243C;
	sub_822651A0(ctx, base);
	// 8280243C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82802440: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 82802444: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 82802448: 409AFFDC  bne cr6, 0x82802424
	if !ctx.cr[6].eq {
	pc = 0x82802424; continue 'dispatch;
	}
	pc = 0x8280244C; continue 'dispatch;
            }
            0x8280244C => {
    //   block [0x8280244C..0x8280245C)
	// 8280244C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82802450: 4BA12989  bl 0x82214dd8
	ctx.lr = 0x82802454;
	sub_82214DD8(ctx, base);
	// 82802454: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82802458: 484A6FFC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802460(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802460 size=112
    let mut pc: u32 = 0x82802460;
    'dispatch: loop {
        match pc {
            0x82802460 => {
    //   block [0x82802460..0x82802484)
	// 82802460: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802464: 484A6FA5  bl 0x82ca9408
	ctx.lr = 0x82802468;
	sub_82CA93D0(ctx, base);
	// 82802468: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280246C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82802470: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82802474: 7F04E040  cmplw cr6, r4, r28
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82802478: 419A004C  beq cr6, 0x828024c4
	if ctx.cr[6].eq {
	pc = 0x828024C4; continue 'dispatch;
	}
	// 8280247C: 3BE40008  addi r31, r4, 8
	ctx.r[31].s64 = ctx.r[4].s64 + 8;
	// 82802480: 7FA4F050  subf r29, r4, r30
	ctx.r[29].s64 = ctx.r[30].s64 - ctx.r[4].s64;
	pc = 0x82802484; continue 'dispatch;
            }
            0x82802484 => {
    //   block [0x82802484..0x828024B0)
	// 82802484: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82802488: 419A0028  beq cr6, 0x828024b0
	if ctx.cr[6].eq {
	pc = 0x828024B0; continue 'dispatch;
	}
	// 8280248C: 897FFFF8  lbz r11, -8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82802490: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82802494: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 82802498: 997E0000  stb r11, 0(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 8280249C: 815FFFFC  lwz r10, -4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 828024A0: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 828024A4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828024A8: 7D3DF92E  stwx r9, r29, r31
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[31].u32), ctx.r[9].u32) };
	// 828024AC: 4B9EDD95  bl 0x821f0240
	ctx.lr = 0x828024B0;
	sub_821F0240(ctx, base);
	pc = 0x828024B0; continue 'dispatch;
            }
            0x828024B0 => {
    //   block [0x828024B0..0x828024C4)
	// 828024B0: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 828024B4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 828024B8: 397FFFF8  addi r11, r31, -8
	ctx.r[11].s64 = ctx.r[31].s64 + -8;
	// 828024BC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 828024C0: 409AFFC4  bne cr6, 0x82802484
	if !ctx.cr[6].eq {
	pc = 0x82802484; continue 'dispatch;
	}
	pc = 0x828024C4; continue 'dispatch;
            }
            0x828024C4 => {
    //   block [0x828024C4..0x828024D0)
	// 828024C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828024C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828024CC: 484A6F8C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828024D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x828024D0 size=44
    let mut pc: u32 = 0x828024D0;
    'dispatch: loop {
        match pc {
            0x828024D0 => {
    //   block [0x828024D0..0x828024FC)
	// 828024D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828024D4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828024D8: 394ABE04  addi r10, r10, -0x41fc
	ctx.r[10].s64 = ctx.r[10].s64 + -16892;
	// 828024DC: C00B0000  lfs f0, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 828024E0: C1AAFFF8  lfs f13, -8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 828024E4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 828024E8: 40980014  bge cr6, 0x828024fc
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x828024FC);
		return;
	}
	// 828024EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 828024F0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 828024F4: 994B0004  stb r10, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u8 ) };
	// 828024F8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802538(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82802538 size=352
    let mut pc: u32 = 0x82802538;
    'dispatch: loop {
        match pc {
            0x82802538 => {
    //   block [0x82802538..0x8280256C)
	// 82802538: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280253C: 484A6EC1  bl 0x82ca93fc
	ctx.lr = 0x82802540;
	sub_82CA93D0(ctx, base);
	// 82802540: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 82802544: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802548: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8280254C: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 82802550: 3BD90004  addi r30, r25, 4
	ctx.r[30].s64 = ctx.r[25].s64 + 4;
	// 82802554: 90990000  stw r4, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82802558: 4BA1CD01  bl 0x8221f258
	ctx.lr = 0x8280255C;
	sub_8221F258(ctx, base);
	// 8280255C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82802560: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82802564: 419A0008  beq cr6, 0x8280256c
	if ctx.cr[6].eq {
	pc = 0x8280256C; continue 'dispatch;
	}
	// 82802568: 93A30000  stw r29, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x8280256C; continue 'dispatch;
            }
            0x8280256C => {
    //   block [0x8280256C..0x82802578)
	// 8280256C: 35630004  addic. r11, r3, 4
	ctx.xer.ca = (ctx.r[3].u32 > (!(4 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82802570: 41820008  beq 0x82802578
	if ctx.cr[0].eq {
	pc = 0x82802578; continue 'dispatch;
	}
	// 82802574: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82802578; continue 'dispatch;
            }
            0x82802578 => {
    //   block [0x82802578..0x82802584)
	// 82802578: 35630008  addic. r11, r3, 8
	ctx.xer.ca = (ctx.r[3].u32 > (!(8 as u32)));
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8280257C: 41820008  beq 0x82802584
	if ctx.cr[0].eq {
	pc = 0x82802584; continue 'dispatch;
	}
	// 82802580: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	pc = 0x82802584; continue 'dispatch;
            }
            0x82802584 => {
    //   block [0x82802584..0x828025F4)
	// 82802584: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82802588: 9BA3001D  stb r29, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[29].u8 ) };
	// 8280258C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 82802590: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802594: 9B63001C  stb r27, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[27].u8 ) };
	// 82802598: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8280259C: 9B63001D  stb r27, 0x1d(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(29 as u32), ctx.r[27].u8 ) };
	// 828025A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828025A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828025A8: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828025AC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828025B0: 914A0000  stw r10, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828025B4: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828025B8: 91290008  stw r9, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 828025BC: 93A10084  stw r29, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	// 828025C0: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828025C4: 93A10088  stw r29, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[29].u32 ) };
	// 828025C8: 93A1008C  stw r29, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[29].u32 ) };
	// 828025CC: 4BD7CE5D  bl 0x8257f428
	ctx.lr = 0x828025D0;
	sub_8257F428(ctx, base);
	// 828025D0: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 828025D4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 828025D8: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 828025DC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 828025E0: 4BD7CE49  bl 0x8257f428
	ctx.lr = 0x828025E4;
	sub_8257F428(ctx, base);
	// 828025E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828025E8: 7FBCEB78  mr r28, r29
	ctx.r[28].u64 = ctx.r[29].u64;
	// 828025EC: 3B4B9484  addi r26, r11, -0x6b7c
	ctx.r[26].s64 = ctx.r[11].s64 + -27516;
	// 828025F0: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x828025F4; continue 'dispatch;
            }
            0x828025F4 => {
    //   block [0x828025F4..0x82802684)
	// 828025F4: 80610084  lwz r3, 0x84(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 828025F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 828025FC: 419A008C  beq cr6, 0x82802688
	if ctx.cr[6].eq {
	pc = 0x82802688; continue 'dispatch;
	}
	// 82802600: 81610088  lwz r11, 0x88(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) } as u64;
	// 82802604: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 82802608: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 8280260C: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82802610: 40980074  bge cr6, 0x82802684
	if !ctx.cr[6].lt {
	pc = 0x82802684; continue 'dispatch;
	}
	// 82802614: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82802618: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8280261C: 7FFC182E  lwzx r31, r28, r3
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 82802620: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82802624: 9B61005C  stb r27, 0x5c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u8 ) };
	// 82802628: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8280262C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82802630: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 82802634: 91610098  stw r11, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82802638: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8280263C: 93E10090  stw r31, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82802640: 93E1009C  stw r31, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[31].u32 ) };
	// 82802644: 4800026D  bl 0x828028b0
	ctx.lr = 0x82802648;
	sub_828028B0(ctx, base);
	// 82802648: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 8280264C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802650: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802654: 4800015D  bl 0x828027b0
	ctx.lr = 0x82802658;
	sub_828027B0(ctx, base);
	// 82802658: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8280265C: C01A2984  lfs f0, 0x2984(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82802660: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82802664: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802668: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280266C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82802670: 48000141  bl 0x828027b0
	ctx.lr = 0x82802674;
	sub_828027B0(ctx, base);
	// 82802674: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 82802678: 9B630004  stb r27, 4(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[27].u8 ) };
	// 8280267C: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82802680: 4BFFFF74  b 0x828025f4
	pc = 0x828025F4; continue 'dispatch;
            }
            0x82802684 => {
    //   block [0x82802684..0x82802688)
	// 82802684: 4BA196B5  bl 0x8221bd38
	ctx.lr = 0x82802688;
	sub_8221BD38(ctx, base);
	pc = 0x82802688; continue 'dispatch;
            }
            0x82802688 => {
    //   block [0x82802688..0x82802698)
	// 82802688: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8280268C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82802690: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82802694: 484A6DB8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802698(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82802698 size=280
    let mut pc: u32 = 0x82802698;
    'dispatch: loop {
        match pc {
            0x82802698 => {
    //   block [0x82802698..0x828026C0)
	// 82802698: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280269C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828026A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828026A4: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 828026A8: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828026AC: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 828026B0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828026B4: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828026B8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828026BC: 409A002C  bne cr6, 0x828026e8
	if !ctx.cr[6].eq {
	pc = 0x828026E8; continue 'dispatch;
	}
	pc = 0x828026C0; continue 'dispatch;
            }
            0x828026C0 => {
    //   block [0x828026C0..0x828026D4)
	// 828026C0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828026C4: 7F082040  cmplw cr6, r8, r4
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[4].u32, &mut ctx.xer);
	// 828026C8: 4098000C  bge cr6, 0x828026d4
	if !ctx.cr[6].lt {
	pc = 0x828026D4; continue 'dispatch;
	}
	// 828026CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828026D0: 4800000C  b 0x828026dc
	pc = 0x828026DC; continue 'dispatch;
            }
            0x828026D4 => {
    //   block [0x828026D4..0x828026DC)
	// 828026D4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828026D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828026DC; continue 'dispatch;
            }
            0x828026DC => {
    //   block [0x828026DC..0x828026E8)
	// 828026DC: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828026E0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828026E4: 419AFFDC  beq cr6, 0x828026c0
	if ctx.cr[6].eq {
	pc = 0x828026C0; continue 'dispatch;
	}
	pc = 0x828026E8; continue 'dispatch;
            }
            0x828026E8 => {
    //   block [0x828026E8..0x82802710)
	// 828026E8: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828026EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 828026F0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 828026F4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828026F8: 419A0018  beq cr6, 0x82802710
	if ctx.cr[6].eq {
	pc = 0x82802710; continue 'dispatch;
	}
	// 828026FC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802700: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802704: 4198000C  blt cr6, 0x82802710
	if ctx.cr[6].lt {
	pc = 0x82802710; continue 'dispatch;
	}
	// 82802708: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8280270C: 48000010  b 0x8280271c
	pc = 0x8280271C; continue 'dispatch;
            }
            0x82802710 => {
    //   block [0x82802710..0x8280271C)
	// 82802710: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82802714: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82802718: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	pc = 0x8280271C; continue 'dispatch;
            }
            0x8280271C => {
    //   block [0x8280271C..0x82802738)
	// 8280271C: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82802720: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82802724: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82802728: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280272C: 419A000C  beq cr6, 0x82802738
	if ctx.cr[6].eq {
	pc = 0x82802738; continue 'dispatch;
	}
	// 82802730: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82802734: 419A0008  beq cr6, 0x8280273c
	if ctx.cr[6].eq {
	pc = 0x8280273C; continue 'dispatch;
	}
	pc = 0x82802738; continue 'dispatch;
            }
            0x82802738 => {
    //   block [0x82802738..0x8280273C)
	// 82802738: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8280273C; continue 'dispatch;
            }
            0x8280273C => {
    //   block [0x8280273C..0x82802774)
	// 8280273C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82802740: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82802744: 419A005C  beq cr6, 0x828027a0
	if ctx.cr[6].eq {
	pc = 0x828027A0; continue 'dispatch;
	}
	// 82802748: 90810050  stw r4, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u32 ) };
	// 8280274C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802750: 48000061  bl 0x828027b0
	ctx.lr = 0x82802754;
	sub_828027B0(ctx, base);
	// 82802754: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82802758: 4BFFFD79  bl 0x828024d0
	ctx.lr = 0x8280275C;
	sub_828024D0(ctx, base);
	// 8280275C: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82802760: 419A0030  beq cr6, 0x82802790
	if ctx.cr[6].eq {
	pc = 0x82802790; continue 'dispatch;
	}
	// 82802764: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 82802768: 419A000C  beq cr6, 0x82802774
	if ctx.cr[6].eq {
	pc = 0x82802774; continue 'dispatch;
	}
	// 8280276C: 2F030003  cmpwi cr6, r3, 3
	ctx.cr[6].compare_i32(ctx.r[3].s32, 3, &mut ctx.xer);
	// 82802770: 409A0030  bne cr6, 0x828027a0
	if !ctx.cr[6].eq {
	pc = 0x828027A0; continue 'dispatch;
	}
	pc = 0x82802774; continue 'dispatch;
            }
            0x82802774 => {
    //   block [0x82802774..0x82802790)
	// 82802774: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82802778: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8280277C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82802780: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82802784: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82802788: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8280278C: 4E800020  blr
	return;
            }
            0x82802790 => {
    //   block [0x82802790..0x828027A0)
	// 82802790: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82802794: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 82802798: C00A2978  lfs f0, 0x2978(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8280279C: D0090000  stfs f0, 0(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x828027A0; continue 'dispatch;
            }
            0x828027A0 => {
    //   block [0x828027A0..0x828027B0)
	// 828027A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828027A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828027A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828027AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828027B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828027B0 size=256
    let mut pc: u32 = 0x828027B0;
    'dispatch: loop {
        match pc {
            0x828027B0 => {
    //   block [0x828027B0..0x828027D8)
	// 828027B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828027B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828027B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828027BC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828027C0: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 828027C4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828027C8: 890B001D  lbz r8, 0x1d(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828027CC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828027D0: 409A0030  bne cr6, 0x82802800
	if !ctx.cr[6].eq {
	pc = 0x82802800; continue 'dispatch;
	}
	// 828027D4: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828027D8; continue 'dispatch;
            }
            0x828027D8 => {
    //   block [0x828027D8..0x828027EC)
	// 828027D8: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828027DC: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 828027E0: 4098000C  bge cr6, 0x828027ec
	if !ctx.cr[6].lt {
	pc = 0x828027EC; continue 'dispatch;
	}
	// 828027E4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828027E8: 4800000C  b 0x828027f4
	pc = 0x828027F4; continue 'dispatch;
            }
            0x828027EC => {
    //   block [0x828027EC..0x828027F4)
	// 828027EC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828027F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828027F4; continue 'dispatch;
            }
            0x828027F4 => {
    //   block [0x828027F4..0x82802800)
	// 828027F4: 88EB001D  lbz r7, 0x1d(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828027F8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 828027FC: 419AFFDC  beq cr6, 0x828027d8
	if ctx.cr[6].eq {
	pc = 0x828027D8; continue 'dispatch;
	}
	pc = 0x82802800; continue 'dispatch;
            }
            0x82802800 => {
    //   block [0x82802800..0x82802828)
	// 82802800: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802804: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82802808: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8280280C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82802810: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 82802814: 419A0014  beq cr6, 0x82802828
	if ctx.cr[6].eq {
	pc = 0x82802828; continue 'dispatch;
	}
	// 82802818: 81040000  lwz r8, 0(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280281C: 80EA000C  lwz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802820: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82802824: 4098005C  bge cr6, 0x82802880
	if !ctx.cr[6].lt {
	pc = 0x82802880; continue 'dispatch;
	}
	pc = 0x82802828; continue 'dispatch;
            }
            0x82802828 => {
    //   block [0x82802828..0x82802880)
	// 82802828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8280282C: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82802830: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 82802834: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802838: 99610054  stb r11, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u8 ) };
	// 8280283C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82802840: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802844: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 82802848: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 8280284C: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 82802850: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82802854: C0089484  lfs f0, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82802858: 91410070  stw r10, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u32 ) };
	// 8280285C: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82802860: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82802864: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82802868: 90E10078  stw r7, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[7].u32 ) };
	// 8280286C: 48000185  bl 0x828029f0
	ctx.lr = 0x82802870;
	sub_828029F0(ctx, base);
	// 82802870: E9430000  ld r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82802874: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 82802878: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8280287C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82802880; continue 'dispatch;
            }
            0x82802880 => {
    //   block [0x82802880..0x8280288C)
	// 82802880: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802884: 409A0008  bne cr6, 0x8280288c
	if !ctx.cr[6].eq {
	pc = 0x8280288C; continue 'dispatch;
	}
	// 82802888: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8280288C; continue 'dispatch;
            }
            0x8280288C => {
    //   block [0x8280288C..0x8280289C)
	// 8280288C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802890: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802894: 409A0008  bne cr6, 0x8280289c
	if !ctx.cr[6].eq {
	pc = 0x8280289C; continue 'dispatch;
	}
	// 82802898: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x8280289C; continue 'dispatch;
            }
            0x8280289C => {
    //   block [0x8280289C..0x828028B0)
	// 8280289C: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 828028A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828028A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828028A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828028AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828028B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x828028B0 size=316
    let mut pc: u32 = 0x828028B0;
    'dispatch: loop {
        match pc {
            0x828028B0 => {
    //   block [0x828028B0..0x828028E8)
	// 828028B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828028B4: 484A6B4D  bl 0x82ca9400
	ctx.lr = 0x828028B8;
	sub_82CA93D0(ctx, base);
	// 828028B8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828028BC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828028C0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828028C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828028C8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 828028CC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 828028D0: 83FC0004  lwz r31, 4(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828028D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828028D8: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 828028DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828028E0: 409A003C  bne cr6, 0x8280291c
	if !ctx.cr[6].eq {
	pc = 0x8280291C; continue 'dispatch;
	}
	// 828028E4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828028E8; continue 'dispatch;
            }
            0x828028E8 => {
    //   block [0x828028E8..0x8280290C)
	// 828028E8: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 828028EC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 828028F0: 7D095010  subfc r8, r9, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[9].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 828028F4: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 828028F8: 54FD07FE  clrlwi r29, r7, 0x1f
	ctx.r[29].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 828028FC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82802900: 419A000C  beq cr6, 0x8280290c
	if ctx.cr[6].eq {
	pc = 0x8280290C; continue 'dispatch;
	}
	// 82802904: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802908: 48000008  b 0x82802910
	pc = 0x82802910; continue 'dispatch;
            }
            0x8280290C => {
    //   block [0x8280290C..0x82802910)
	// 8280290C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82802910; continue 'dispatch;
            }
            0x82802910 => {
    //   block [0x82802910..0x8280291C)
	// 82802910: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802914: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802918: 419AFFD0  beq cr6, 0x828028e8
	if ctx.cr[6].eq {
	pc = 0x828028E8; continue 'dispatch;
	}
	pc = 0x8280291C; continue 'dispatch;
            }
            0x8280291C => {
    //   block [0x8280291C..0x8280297C)
	// 8280291C: 57AB063E  clrlwi r11, r29, 0x18
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 82802920: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 82802924: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 82802928: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280292C: 419A0054  beq cr6, 0x82802980
	if ctx.cr[6].eq {
	pc = 0x82802980; continue 'dispatch;
	}
	// 82802930: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802934: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802938: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280293C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802940: 409A003C  bne cr6, 0x8280297c
	if !ctx.cr[6].eq {
	pc = 0x8280297C; continue 'dispatch;
	}
	// 82802944: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82802948: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8280294C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82802950: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82802954: 4836BDBD  bl 0x82b6e710
	ctx.lr = 0x82802958;
	sub_82B6E710(ctx, base);
	// 82802958: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8280295C: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 82802960: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802964: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802968: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280296C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82802970: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82802974: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82802978: 484A6AD8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x8280297C => {
    //   block [0x8280297C..0x82802980)
	// 8280297C: 48000295  bl 0x82802c10
	ctx.lr = 0x82802980;
	sub_82802C10(ctx, base);
	pc = 0x82802980; continue 'dispatch;
            }
            0x82802980 => {
    //   block [0x82802980..0x828029D0)
	// 82802980: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802984: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802988: 812B000C  lwz r9, 0xc(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8280298C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802990: 40980040  bge cr6, 0x828029d0
	if !ctx.cr[6].lt {
	pc = 0x828029D0; continue 'dispatch;
	}
	// 82802994: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 82802998: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8280299C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828029A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828029A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828029A8: 4836BD69  bl 0x82b6e710
	ctx.lr = 0x828029AC;
	sub_82B6E710(ctx, base);
	// 828029AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828029B0: 9B5E0008  stb r26, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[26].u8 ) };
	// 828029B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828029B8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828029BC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828029C0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828029C4: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 828029C8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828029CC: 484A6A84  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x828029D0 => {
    //   block [0x828029D0..0x828029EC)
	// 828029D0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 828029D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828029D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828029DC: 995E0008  stb r10, 8(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828029E0: F97E0000  std r11, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828029E4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828029E8: 484A6A68  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828029F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828029F0 size=540
    let mut pc: u32 = 0x828029F0;
    'dispatch: loop {
        match pc {
            0x828029F0 => {
    //   block [0x828029F0..0x82802A44)
	// 828029F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828029F4: 484A6A11  bl 0x82ca9404
	ctx.lr = 0x828029F8;
	sub_82CA93D0(ctx, base);
	// 828029F8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828029FC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82802A00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82802A04: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 82802A08: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82802A0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82802A10: FB8100C0  std r28, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[28].u64 ) };
	// 82802A14: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82802A18: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802A1C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82802A20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802A24: 409A0020  bne cr6, 0x82802a44
	if !ctx.cr[6].eq {
	pc = 0x82802A44; continue 'dispatch;
	}
	// 82802A28: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82802A2C: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802A30: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82802A34: 4836BCDD  bl 0x82b6e710
	ctx.lr = 0x82802A38;
	sub_82B6E710(ctx, base);
	// 82802A38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802A3C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802A40: 484A6A14  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802A44 => {
    //   block [0x82802A44..0x82802A60)
	// 82802A44: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802A48: 816100C0  lwz r11, 0xc0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82802A4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802A50: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802A54: 419A000C  beq cr6, 0x82802a60
	if ctx.cr[6].eq {
	pc = 0x82802A60; continue 'dispatch;
	}
	// 82802A58: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82802A5C: 419A0008  beq cr6, 0x82802a64
	if ctx.cr[6].eq {
	pc = 0x82802A64; continue 'dispatch;
	}
	pc = 0x82802A60; continue 'dispatch;
            }
            0x82802A60 => {
    //   block [0x82802A60..0x82802A64)
	// 82802A60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82802A64; continue 'dispatch;
            }
            0x82802A64 => {
    //   block [0x82802A64..0x82802AA4)
	// 82802A64: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82802A68: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82802A6C: 409A0038  bne cr6, 0x82802aa4
	if !ctx.cr[6].eq {
	pc = 0x82802AA4; continue 'dispatch;
	}
	// 82802A70: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802A74: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802A78: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802A7C: 40980160  bge cr6, 0x82802bdc
	if !ctx.cr[6].lt {
	pc = 0x82802BDC; continue 'dispatch;
	}
	// 82802A80: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82802A84: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82802A88: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82802A8C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802A90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802A94: 4836BC7D  bl 0x82b6e710
	ctx.lr = 0x82802A98;
	sub_82B6E710(ctx, base);
	// 82802A98: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802A9C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802AA0: 484A69B4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802AA4 => {
    //   block [0x82802AA4..0x82802AB4)
	// 82802AA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802AA8: 419A000C  beq cr6, 0x82802ab4
	if ctx.cr[6].eq {
	pc = 0x82802AB4; continue 'dispatch;
	}
	// 82802AAC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82802AB0: 419A0008  beq cr6, 0x82802ab8
	if ctx.cr[6].eq {
	pc = 0x82802AB8; continue 'dispatch;
	}
	pc = 0x82802AB4; continue 'dispatch;
            }
            0x82802AB4 => {
    //   block [0x82802AB4..0x82802AB8)
	// 82802AB4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82802AB8; continue 'dispatch;
            }
            0x82802AB8 => {
    //   block [0x82802AB8..0x82802AF4)
	// 82802AB8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802ABC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802AC0: 409A0034  bne cr6, 0x82802af4
	if !ctx.cr[6].eq {
	pc = 0x82802AF4; continue 'dispatch;
	}
	// 82802AC4: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802AC8: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802ACC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82802AD0: 4098010C  bge cr6, 0x82802bdc
	if !ctx.cr[6].lt {
	pc = 0x82802BDC; continue 'dispatch;
	}
	// 82802AD4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82802AD8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82802ADC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802AE0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802AE4: 4836BC2D  bl 0x82b6e710
	ctx.lr = 0x82802AE8;
	sub_82B6E710(ctx, base);
	// 82802AE8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802AEC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802AF0: 484A6964  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802AF4 => {
    //   block [0x82802AF4..0x82802B40)
	// 82802AF4: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802AF8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802AFC: 40980058  bge cr6, 0x82802b54
	if !ctx.cr[6].lt {
	pc = 0x82802B54; continue 'dispatch;
	}
	// 82802B00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802B04: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82802B08: 48000109  bl 0x82802c10
	ctx.lr = 0x82802B0C;
	sub_82802C10(ctx, base);
	// 82802B0C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802B10: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802B14: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802B18: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82802B1C: 40980038  bge cr6, 0x82802b54
	if !ctx.cr[6].lt {
	pc = 0x82802B54; continue 'dispatch;
	}
	// 82802B20: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802B24: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82802B28: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802B2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802B30: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802B34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802B38: 409A0090  bne cr6, 0x82802bc8
	if !ctx.cr[6].eq {
	pc = 0x82802BC8; continue 'dispatch;
	}
	// 82802B3C: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82802B40; continue 'dispatch;
            }
            0x82802B40 => {
    //   block [0x82802B40..0x82802B54)
	// 82802B40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82802B44: 4836BBCD  bl 0x82b6e710
	ctx.lr = 0x82802B48;
	sub_82B6E710(ctx, base);
	// 82802B48: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802B4C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802B50: 484A6904  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802B54 => {
    //   block [0x82802B54..0x82802B84)
	// 82802B54: 815B000C  lwz r10, 0xc(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802B58: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82802B5C: 40980080  bge cr6, 0x82802bdc
	if !ctx.cr[6].lt {
	pc = 0x82802BDC; continue 'dispatch;
	}
	// 82802B60: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802B64: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 82802B68: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802B6C: 482999AD  bl 0x82a9c518
	ctx.lr = 0x82802B70;
	sub_82A9C518(ctx, base);
	// 82802B70: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802B78: 419A000C  beq cr6, 0x82802b84
	if ctx.cr[6].eq {
	pc = 0x82802B84; continue 'dispatch;
	}
	// 82802B7C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82802B80: 419A0008  beq cr6, 0x82802b88
	if ctx.cr[6].eq {
	pc = 0x82802B88; continue 'dispatch;
	}
	pc = 0x82802B84; continue 'dispatch;
            }
            0x82802B84 => {
    //   block [0x82802B84..0x82802B88)
	// 82802B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82802B88; continue 'dispatch;
            }
            0x82802B88 => {
    //   block [0x82802B88..0x82802BA8)
	// 82802B88: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802B8C: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82802B90: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82802B94: 419A0014  beq cr6, 0x82802ba8
	if ctx.cr[6].eq {
	pc = 0x82802BA8; continue 'dispatch;
	}
	// 82802B98: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802B9C: 8146000C  lwz r10, 0xc(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 82802BA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82802BA4: 40980038  bge cr6, 0x82802bdc
	if !ctx.cr[6].lt {
	pc = 0x82802BDC; continue 'dispatch;
	}
	pc = 0x82802BA8; continue 'dispatch;
            }
            0x82802BA8 => {
    //   block [0x82802BA8..0x82802BC8)
	// 82802BA8: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802BAC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 82802BB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802BB4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802BB8: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802BBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802BC0: 419AFF80  beq cr6, 0x82802b40
	if ctx.cr[6].eq {
	pc = 0x82802B40; continue 'dispatch;
	}
	// 82802BC4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82802BC8; continue 'dispatch;
            }
            0x82802BC8 => {
    //   block [0x82802BC8..0x82802BDC)
	// 82802BC8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82802BCC: 4836BB45  bl 0x82b6e710
	ctx.lr = 0x82802BD0;
	sub_82B6E710(ctx, base);
	// 82802BD0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802BD4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802BD8: 484A687C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82802BDC => {
    //   block [0x82802BDC..0x82802C0C)
	// 82802BDC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 82802BE0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802BE4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82802BE8: 4BFFFCC9  bl 0x828028b0
	ctx.lr = 0x82802BEC;
	sub_828028B0(ctx, base);
	// 82802BEC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82802BF0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802BF4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802BF8: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82802BFC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802C00: 913E0004  stw r9, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82802C04: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82802C08: 484A684C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802C10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82802C10 size=60
    let mut pc: u32 = 0x82802C10;
    'dispatch: loop {
        match pc {
            0x82802C10 => {
    //   block [0x82802C10..0x82802C20)
	// 82802C10: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802C14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802C18: 409A0008  bne cr6, 0x82802c20
	if !ctx.cr[6].eq {
	pc = 0x82802C20; continue 'dispatch;
	}
	// 82802C1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82802C20; continue 'dispatch;
            }
            0x82802C20 => {
    //   block [0x82802C20..0x82802C4C)
	// 82802C20: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802C24: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C28: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802C2C: 419A0020  beq cr6, 0x82802c4c
	if ctx.cr[6].eq {
		sub_82802C4C(ctx, base);
		return;
	}
	// 82802C30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802C34: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82802C38: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802C40: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82802C44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	// 82802C48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802C4C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82802C4C size=60
    let mut pc: u32 = 0x82802C4C;
    'dispatch: loop {
        match pc {
            0x82802C4C => {
    //   block [0x82802C4C..0x82802C6C)
	// 82802C4C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802C50: 892A001D  lbz r9, 0x1d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C54: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802C58: 409A0030  bne cr6, 0x82802c88
	if !ctx.cr[6].eq {
		sub_82802C88(ctx, base);
		return;
	}
	// 82802C5C: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802C60: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C64: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802C68: 409A0018  bne cr6, 0x82802c80
	if !ctx.cr[6].eq {
	pc = 0x82802C80; continue 'dispatch;
	}
	pc = 0x82802C6C; continue 'dispatch;
            }
            0x82802C6C => {
    //   block [0x82802C6C..0x82802C80)
	// 82802C6C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82802C70: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82802C74: 892B001D  lbz r9, 0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C78: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802C7C: 419AFFF0  beq cr6, 0x82802c6c
	if ctx.cr[6].eq {
	pc = 0x82802C6C; continue 'dispatch;
	}
	pc = 0x82802C80; continue 'dispatch;
            }
            0x82802C80 => {
    //   block [0x82802C80..0x82802C88)
	// 82802C80: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82802C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82802C88 size=80
    let mut pc: u32 = 0x82802C88;
    'dispatch: loop {
        match pc {
            0x82802C88 => {
    //   block [0x82802C88..0x82802C98)
	// 82802C88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802C8C: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802C90: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802C94: 409A002C  bne cr6, 0x82802cc0
	if !ctx.cr[6].eq {
	pc = 0x82802CC0; continue 'dispatch;
	}
	pc = 0x82802C98; continue 'dispatch;
            }
            0x82802C98 => {
    //   block [0x82802C98..0x82802CC0)
	// 82802C98: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802C9C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802CA0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82802CA4: 409A001C  bne cr6, 0x82802cc0
	if !ctx.cr[6].eq {
	pc = 0x82802CC0; continue 'dispatch;
	}
	// 82802CA8: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82802CAC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82802CB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802CB4: 894B001D  lbz r10, 0x1d(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802CB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82802CBC: 419AFFDC  beq cr6, 0x82802c98
	if ctx.cr[6].eq {
	pc = 0x82802C98; continue 'dispatch;
	}
	pc = 0x82802CC0; continue 'dispatch;
            }
            0x82802CC0 => {
    //   block [0x82802CC0..0x82802CD8)
	// 82802CC0: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82802CC4: 892A001D  lbz r9, 0x1d(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(29 as u32) ) } as u64;
	// 82802CC8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82802CCC: 409AFF78  bne cr6, 0x82802c44
	if !ctx.cr[6].eq {
		sub_82802C10(ctx, base);
		return;
	}
	// 82802CD0: 91630004  stw r11, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82802CD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802CD8 size=220
    let mut pc: u32 = 0x82802CD8;
    'dispatch: loop {
        match pc {
            0x82802CD8 => {
    //   block [0x82802CD8..0x82802CFC)
	// 82802CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802CDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82802CE0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82802CE4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802CE8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82802CEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82802CF0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82802CF4: 38EB7088  addi r7, r11, 0x7088
	ctx.r[7].s64 = ctx.r[11].s64 + 28808;
	// 82802CF8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	pc = 0x82802CFC; continue 'dispatch;
            }
            0x82802CFC => {
    //   block [0x82802CFC..0x82802DB4)
	// 82802CFC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82802D00: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802D04: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82802D08: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82802D0C: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82802D10: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802D14: 4082FFE8  bne 0x82802cfc
	if !ctx.cr[0].eq {
	pc = 0x82802CFC; continue 'dispatch;
	}
	// 82802D18: 3CC0820E  lis r6, -0x7df2
	ctx.r[6].s64 = -2113011712;
	// 82802D1C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 82802D20: 3886A818  addi r4, r6, -0x57e8
	ctx.r[4].s64 = ctx.r[6].s64 + -22504;
	// 82802D24: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82802D28: 4BA2A1A9  bl 0x8222ced0
	ctx.lr = 0x82802D2C;
	sub_8222CED0(ctx, base);
	// 82802D2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82802D30: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82802D34: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 82802D38: 4B9E03D1  bl 0x821e3108
	ctx.lr = 0x82802D3C;
	sub_821E3108(ctx, base);
	// 82802D3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82802D40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D44: 4B9ED4FD  bl 0x821f0240
	ctx.lr = 0x82802D48;
	sub_821F0240(ctx, base);
	// 82802D48: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 82802D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D50: 388504E8  addi r4, r5, 0x4e8
	ctx.r[4].s64 = ctx.r[5].s64 + 1256;
	// 82802D54: 4B9D7C6D  bl 0x821da9c0
	ctx.lr = 0x82802D58;
	sub_821DA9C0(ctx, base);
	// 82802D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802D5C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82802D60: 4BA62441  bl 0x822651a0
	ctx.lr = 0x82802D64;
	sub_822651A0(ctx, base);
	// 82802D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D68: 4BA12071  bl 0x82214dd8
	ctx.lr = 0x82802D6C;
	sub_82214DD8(ctx, base);
	// 82802D6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82802D70: 4BA12069  bl 0x82214dd8
	ctx.lr = 0x82802D74;
	sub_82214DD8(ctx, base);
	// 82802D74: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82802D78: 4BA12061  bl 0x82214dd8
	ctx.lr = 0x82802D7C;
	sub_82214DD8(ctx, base);
	// 82802D7C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82802D80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D84: 4B9EBDB5  bl 0x821eeb38
	ctx.lr = 0x82802D88;
	sub_821EEB38(ctx, base);
	// 82802D88: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D8C: 48400A65  bl 0x82c037f0
	ctx.lr = 0x82802D90;
	sub_82C037F0(ctx, base);
	// 82802D90: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802D94: 4BA12045  bl 0x82214dd8
	ctx.lr = 0x82802D98;
	sub_82214DD8(ctx, base);
	// 82802D98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82802D9C: 4BA1203D  bl 0x82214dd8
	ctx.lr = 0x82802DA0;
	sub_82214DD8(ctx, base);
	// 82802DA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82802DA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82802DA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82802DAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82802DB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802DB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802DB8 size=276
    let mut pc: u32 = 0x82802DB8;
    'dispatch: loop {
        match pc {
            0x82802DB8 => {
    //   block [0x82802DB8..0x82802E74)
	// 82802DB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802DBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82802DC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82802DC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82802DC8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802DCC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82802DD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82802DD4: 387E0010  addi r3, r30, 0x10
	ctx.r[3].s64 = ctx.r[30].s64 + 16;
	// 82802DD8: 4BAB5AD1  bl 0x822b88a8
	ctx.lr = 0x82802DDC;
	sub_822B88A8(ctx, base);
	// 82802DDC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82802DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802DE4: 4BA84E45  bl 0x82287c28
	ctx.lr = 0x82802DE8;
	sub_82287C28(ctx, base);
	// 82802DE8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82802DEC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82802DF0: 388B062C  addi r4, r11, 0x62c
	ctx.r[4].s64 = ctx.r[11].s64 + 1580;
	// 82802DF4: 4BAD3615  bl 0x822d6408
	ctx.lr = 0x82802DF8;
	sub_822D6408(ctx, base);
	// 82802DF8: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 82802DFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82802E00: 388ADF4C  addi r4, r10, -0x20b4
	ctx.r[4].s64 = ctx.r[10].s64 + -8372;
	// 82802E04: 4BAD3605  bl 0x822d6408
	ctx.lr = 0x82802E08;
	sub_822D6408(ctx, base);
	// 82802E08: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 82802E0C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82802E10: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802E14: 4833BD55  bl 0x82b3eb68
	ctx.lr = 0x82802E18;
	sub_82B3EB68(ctx, base);
	// 82802E18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82802E1C: 4B9C39DD  bl 0x821c67f8
	ctx.lr = 0x82802E20;
	sub_821C67F8(ctx, base);
	// 82802E20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82802E24: 4B9C39D5  bl 0x821c67f8
	ctx.lr = 0x82802E28;
	sub_821C67F8(ctx, base);
	// 82802E28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802E2C: 48366405  bl 0x82b69230
	ctx.lr = 0x82802E30;
	sub_82B69230(ctx, base);
	// 82802E30: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82802E34: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802E38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802E3C: 4800037D  bl 0x828031b8
	ctx.lr = 0x82802E40;
	sub_828031B8(ctx, base);
	// 82802E40: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82802E44: 4BA1C415  bl 0x8221f258
	ctx.lr = 0x82802E48;
	sub_8221F258(ctx, base);
	// 82802E48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82802E4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82802E50: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82802E54: 419A0020  beq cr6, 0x82802e74
	if ctx.cr[6].eq {
	pc = 0x82802E74; continue 'dispatch;
	}
	// 82802E58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82802E5C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82802E60: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82802E64: 4BA84DC5  bl 0x82287c28
	ctx.lr = 0x82802E68;
	sub_82287C28(ctx, base);
	// 82802E68: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82802E6C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82802E70: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x82802E74; continue 'dispatch;
            }
            0x82802E74 => {
    //   block [0x82802E74..0x82802E90)
	// 82802E74: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82802E78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802E7C: 419A0014  beq cr6, 0x82802e90
	if ctx.cr[6].eq {
	pc = 0x82802E90; continue 'dispatch;
	}
	// 82802E80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82802E84: 48000E6D  bl 0x82803cf0
	ctx.lr = 0x82802E88;
	sub_82803CF0(ctx, base);
	// 82802E88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82802E8C: 48000010  b 0x82802e9c
	pc = 0x82802E9C; continue 'dispatch;
            }
            0x82802E90 => {
    //   block [0x82802E90..0x82802E9C)
	// 82802E90: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82802E94: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82802E98: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x82802E9C; continue 'dispatch;
            }
            0x82802E9C => {
    //   block [0x82802E9C..0x82802ECC)
	// 82802E9C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802EA0: 4BC4DF19  bl 0x82450db8
	ctx.lr = 0x82802EA4;
	sub_82450DB8(ctx, base);
	// 82802EA4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82802EA8: 4B9B4C71  bl 0x821b7b18
	ctx.lr = 0x82802EAC;
	sub_821B7B18(ctx, base);
	// 82802EAC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802EB0: 4B9C3949  bl 0x821c67f8
	ctx.lr = 0x82802EB4;
	sub_821C67F8(ctx, base);
	// 82802EB4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82802EB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82802EBC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82802EC0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82802EC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82802EC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802ED0 size=176
    let mut pc: u32 = 0x82802ED0;
    'dispatch: loop {
        match pc {
            0x82802ED0 => {
    //   block [0x82802ED0..0x82802F04)
	// 82802ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802ED4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82802ED8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82802EDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82802EE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802EE4: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 82802EE8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82802EEC: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82802EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802EF4: 409A0010  bne cr6, 0x82802f04
	if !ctx.cr[6].eq {
	pc = 0x82802F04; continue 'dispatch;
	}
	// 82802EF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82802EFC: 388B9218  addi r4, r11, -0x6de8
	ctx.r[4].s64 = ctx.r[11].s64 + -28136;
	// 82802F00: 48000008  b 0x82802f08
	pc = 0x82802F08; continue 'dispatch;
            }
            0x82802F04 => {
    //   block [0x82802F04..0x82802F08)
	// 82802F04: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82802F08; continue 'dispatch;
            }
            0x82802F08 => {
    //   block [0x82802F08..0x82802F24)
	// 82802F08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802F0C: 4BAD34FD  bl 0x822d6408
	ctx.lr = 0x82802F10;
	sub_822D6408(ctx, base);
	// 82802F10: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82802F14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82802F18: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82802F1C: 419A0024  beq cr6, 0x82802f40
	if ctx.cr[6].eq {
	pc = 0x82802F40; continue 'dispatch;
	}
	// 82802F20: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	pc = 0x82802F24; continue 'dispatch;
            }
            0x82802F24 => {
    //   block [0x82802F24..0x82802F40)
	// 82802F24: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82802F28: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802F2C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82802F30: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82802F34: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82802F38: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802F3C: 4082FFE8  bne 0x82802f24
	if !ctx.cr[0].eq {
	pc = 0x82802F24; continue 'dispatch;
	}
	pc = 0x82802F40; continue 'dispatch;
            }
            0x82802F40 => {
    //   block [0x82802F40..0x82802F80)
	// 82802F40: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82802F44: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82802F48: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82802F4C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802F50: 48000169  bl 0x828030b8
	ctx.lr = 0x82802F54;
	sub_828030B8(ctx, base);
	// 82802F54: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802F58: 4B9C38A1  bl 0x821c67f8
	ctx.lr = 0x82802F5C;
	sub_821C67F8(ctx, base);
	// 82802F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82802F60: 4BA2ED59  bl 0x82231cb8
	ctx.lr = 0x82802F64;
	sub_82231CB8(ctx, base);
	// 82802F64: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82802F68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82802F6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82802F70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82802F74: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82802F78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82802F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82802F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82802F80 size=312
    let mut pc: u32 = 0x82802F80;
    'dispatch: loop {
        match pc {
            0x82802F80 => {
    //   block [0x82802F80..0x82802FA0)
	// 82802F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82802F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82802F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82802F8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82802F90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82802F94: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82802F98: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82802F9C: 3909708C  addi r8, r9, 0x708c
	ctx.r[8].s64 = ctx.r[9].s64 + 28812;
	pc = 0x82802FA0; continue 'dispatch;
            }
            0x82802FA0 => {
    //   block [0x82802FA0..0x82803080)
	// 82802FA0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82802FA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802FA8: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82802FAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82802FB0: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82802FB4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82802FB8: 4082FFE8  bne 0x82802fa0
	if !ctx.cr[0].eq {
	pc = 0x82802FA0; continue 'dispatch;
	}
	// 82802FBC: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 82802FC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82802FC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802FC8: 4833BAD1  bl 0x82b3ea98
	ctx.lr = 0x82802FCC;
	sub_82B3EA98(ctx, base);
	// 82802FCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82802FD0: 48000AF9  bl 0x82803ac8
	ctx.lr = 0x82802FD4;
	sub_82803AC8(ctx, base);
	// 82802FD4: 2B030022  cmplwi cr6, r3, 0x22
	ctx.cr[6].compare_u32(ctx.r[3].u32, 34 as u32, &mut ctx.xer);
	// 82802FD8: 419900B8  bgt cr6, 0x82803090
	if ctx.cr[6].gt {
	pc = 0x82803090; continue 'dispatch;
	}
	// 82802FDC: 3D808280  lis r12, -0x7d80
	ctx.r[12].s64 = -2105540608;
	// 82802FE0: 398C2FF4  addi r12, r12, 0x2ff4
	ctx.r[12].s64 = ctx.r[12].s64 + 12276;
	// 82802FE4: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82802FE8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82802FEC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82802FF0: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x82803098; continue 'dispatch;
		},
		1 => {
	pc = 0x82803098; continue 'dispatch;
		},
		2 => {
	pc = 0x82803098; continue 'dispatch;
		},
		3 => {
	pc = 0x82803098; continue 'dispatch;
		},
		4 => {
	pc = 0x82803098; continue 'dispatch;
		},
		5 => {
	pc = 0x82803098; continue 'dispatch;
		},
		6 => {
	pc = 0x82803090; continue 'dispatch;
		},
		7 => {
	pc = 0x82803090; continue 'dispatch;
		},
		8 => {
	pc = 0x82803090; continue 'dispatch;
		},
		9 => {
	pc = 0x82803090; continue 'dispatch;
		},
		10 => {
	pc = 0x82803090; continue 'dispatch;
		},
		11 => {
	pc = 0x82803098; continue 'dispatch;
		},
		12 => {
	pc = 0x82803090; continue 'dispatch;
		},
		13 => {
	pc = 0x82803090; continue 'dispatch;
		},
		14 => {
	pc = 0x82803090; continue 'dispatch;
		},
		15 => {
	pc = 0x82803090; continue 'dispatch;
		},
		16 => {
	pc = 0x82803090; continue 'dispatch;
		},
		17 => {
	pc = 0x82803090; continue 'dispatch;
		},
		18 => {
	pc = 0x82803090; continue 'dispatch;
		},
		19 => {
	pc = 0x82803090; continue 'dispatch;
		},
		20 => {
	pc = 0x82803090; continue 'dispatch;
		},
		21 => {
	pc = 0x82803090; continue 'dispatch;
		},
		22 => {
	pc = 0x82803090; continue 'dispatch;
		},
		23 => {
	pc = 0x82803090; continue 'dispatch;
		},
		24 => {
	pc = 0x82803090; continue 'dispatch;
		},
		25 => {
	pc = 0x82803090; continue 'dispatch;
		},
		26 => {
	pc = 0x82803090; continue 'dispatch;
		},
		27 => {
	pc = 0x82803090; continue 'dispatch;
		},
		28 => {
	pc = 0x82803090; continue 'dispatch;
		},
		29 => {
	pc = 0x82803090; continue 'dispatch;
		},
		30 => {
	pc = 0x82803080; continue 'dispatch;
		},
		31 => {
	pc = 0x82803080; continue 'dispatch;
		},
		32 => {
	pc = 0x82803080; continue 'dispatch;
		},
		33 => {
	pc = 0x82803080; continue 'dispatch;
		},
		34 => {
	pc = 0x82803080; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82802FF4: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82802FF8: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82802FFC: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82803000: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82803004: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82803008: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 8280300C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803010: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803014: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803018: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280301C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803020: 82803098  lwz r20, 0x3098(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12440u32 ) } as u64;
	// 82803024: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803028: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280302C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803030: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803034: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803038: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280303C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803040: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803044: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803048: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280304C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803050: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803054: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803058: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280305C: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803060: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803064: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 82803068: 82803090  lwz r20, 0x3090(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12432u32 ) } as u64;
	// 8280306C: 82803080  lwz r20, 0x3080(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12416u32 ) } as u64;
	// 82803070: 82803080  lwz r20, 0x3080(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12416u32 ) } as u64;
	// 82803074: 82803080  lwz r20, 0x3080(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12416u32 ) } as u64;
	// 82803078: 82803080  lwz r20, 0x3080(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12416u32 ) } as u64;
	// 8280307C: 82803080  lwz r20, 0x3080(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 12416u32 ) } as u64;
            }
            0x82803080 => {
    //   block [0x82803080..0x82803090)
	// 82803080: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82803084: 816B6D48  lwz r11, 0x6d48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27976 as u32) ) } as u64;
	// 82803088: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8280308C: 4800000C  b 0x82803098
	pc = 0x82803098; continue 'dispatch;
            }
            0x82803090 => {
    //   block [0x82803090..0x82803098)
	// 82803090: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82803094: 83EB6D48  lwz r31, 0x6d48(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27976 as u32) ) } as u64;
	pc = 0x82803098; continue 'dispatch;
            }
            0x82803098 => {
    //   block [0x82803098..0x828030B8)
	// 82803098: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280309C: 4B9C375D  bl 0x821c67f8
	ctx.lr = 0x828030A0;
	sub_821C67F8(ctx, base);
	// 828030A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828030A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828030A8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828030AC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828030B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828030B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828030B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828030B8 size=128
    let mut pc: u32 = 0x828030B8;
    'dispatch: loop {
        match pc {
            0x828030B8 => {
    //   block [0x828030B8..0x828030FC)
	// 828030B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828030BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828030C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 828030C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828030C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828030CC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828030D0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828030D4: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 828030D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828030DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828030E0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828030E4: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 828030E8: 91496D48  stw r10, 0x6d48(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(27976 as u32), ctx.r[10].u32 ) };
	// 828030EC: 409A0010  bne cr6, 0x828030fc
	if !ctx.cr[6].eq {
	pc = 0x828030FC; continue 'dispatch;
	}
	// 828030F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828030F4: 38AB9218  addi r5, r11, -0x6de8
	ctx.r[5].s64 = ctx.r[11].s64 + -28136;
	// 828030F8: 48000008  b 0x82803100
	pc = 0x82803100; continue 'dispatch;
            }
            0x828030FC => {
    //   block [0x828030FC..0x82803100)
	// 828030FC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82803100; continue 'dispatch;
            }
            0x82803100 => {
    //   block [0x82803100..0x82803138)
	// 82803100: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 82803104: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803108: 38EB2F80  addi r7, r11, 0x2f80
	ctx.r[7].s64 = ctx.r[11].s64 + 12160;
	// 8280310C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82803110: 4836E391  bl 0x82b714a0
	ctx.lr = 0x82803114;
	sub_82B714A0(ctx, base);
	// 82803114: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803118: 4BA2EBA1  bl 0x82231cb8
	ctx.lr = 0x8280311C;
	sub_82231CB8(ctx, base);
	// 8280311C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82803120: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82803124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82803128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8280312C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82803130: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82803134: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803138 size=128
    let mut pc: u32 = 0x82803138;
    'dispatch: loop {
        match pc {
            0x82803138 => {
    //   block [0x82803138..0x8280317C)
	// 82803138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280313C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82803140: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82803144: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82803148: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280314C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82803150: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803154: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 82803158: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8280315C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803160: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803164: 814A0018  lwz r10, 0x18(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 82803168: 91496D48  stw r10, 0x6d48(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(27976 as u32), ctx.r[10].u32 ) };
	// 8280316C: 409A0010  bne cr6, 0x8280317c
	if !ctx.cr[6].eq {
	pc = 0x8280317C; continue 'dispatch;
	}
	// 82803170: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82803174: 38AB9218  addi r5, r11, -0x6de8
	ctx.r[5].s64 = ctx.r[11].s64 + -28136;
	// 82803178: 48000008  b 0x82803180
	pc = 0x82803180; continue 'dispatch;
            }
            0x8280317C => {
    //   block [0x8280317C..0x82803180)
	// 8280317C: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82803180; continue 'dispatch;
            }
            0x82803180 => {
    //   block [0x82803180..0x828031B8)
	// 82803180: 3D608280  lis r11, -0x7d80
	ctx.r[11].s64 = -2105540608;
	// 82803184: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803188: 390B2F80  addi r8, r11, 0x2f80
	ctx.r[8].s64 = ctx.r[11].s64 + 12160;
	// 8280318C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82803190: 4836E591  bl 0x82b71720
	ctx.lr = 0x82803194;
	sub_82B71720(ctx, base);
	// 82803194: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803198: 4BA2EB21  bl 0x82231cb8
	ctx.lr = 0x8280319C;
	sub_82231CB8(ctx, base);
	// 8280319C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828031A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828031A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828031A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828031AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828031B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828031B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828031B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828031B8 size=992
    let mut pc: u32 = 0x828031B8;
    'dispatch: loop {
        match pc {
            0x828031B8 => {
    //   block [0x828031B8..0x82803268)
	// 828031B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828031BC: 484A6231  bl 0x82ca93ec
	ctx.lr = 0x828031C0;
	sub_82CA93D0(ctx, base);
	// 828031C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828031C4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 828031C8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 828031CC: 3BCB0AF8  addi r30, r11, 0xaf8
	ctx.r[30].s64 = ctx.r[11].s64 + 2808;
	// 828031D0: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 828031D4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 828031D8: 7EFABB78  mr r26, r23
	ctx.r[26].u64 = ctx.r[23].u64;
	// 828031DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828031E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828031E4: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 828031E8: 7CB52B78  mr r21, r5
	ctx.r[21].u64 = ctx.r[5].u64;
	// 828031EC: 4BAD321D  bl 0x822d6408
	ctx.lr = 0x828031F0;
	sub_822D6408(ctx, base);
	// 828031F0: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 828031F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828031F8: 388BABD4  addi r4, r11, -0x542c
	ctx.r[4].s64 = ctx.r[11].s64 + -21548;
	// 828031FC: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 82803200: 4833BFC9  bl 0x82b3f1c8
	ctx.lr = 0x82803204;
	sub_82B3F1C8(ctx, base);
	// 82803204: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82803208: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8280320C: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 82803210: 3B6BABD8  addi r27, r11, -0x5428
	ctx.r[27].s64 = ctx.r[11].s64 + -21544;
	// 82803214: 419A0054  beq cr6, 0x82803268
	if ctx.cr[6].eq {
	pc = 0x82803268; continue 'dispatch;
	}
	// 82803218: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8280321C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82803220: 4833BFA9  bl 0x82b3f1c8
	ctx.lr = 0x82803224;
	sub_82B3F1C8(ctx, base);
	// 82803224: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 82803228: 2F18FFFF  cmpwi cr6, r24, -1
	ctx.cr[6].compare_i32(ctx.r[24].s32, -1, &mut ctx.xer);
	// 8280322C: 419A003C  beq cr6, 0x82803268
	if ctx.cr[6].eq {
	pc = 0x82803268; continue 'dispatch;
	}
	// 82803230: 7F18F800  cmpw cr6, r24, r31
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82803234: 40990034  ble cr6, 0x82803268
	if !ctx.cr[6].gt {
	pc = 0x82803268; continue 'dispatch;
	}
	// 82803238: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8280323C: 38BF0001  addi r5, r31, 1
	ctx.r[5].s64 = ctx.r[31].s64 + 1;
	// 82803240: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82803244: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82803248: 4833C511  bl 0x82b3f758
	ctx.lr = 0x8280324C;
	sub_82B3F758(ctx, base);
	// 8280324C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803250: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82803254: 4BAB5655  bl 0x822b88a8
	ctx.lr = 0x82803258;
	sub_822B88A8(ctx, base);
	// 82803258: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8280325C: 4B9C359D  bl 0x821c67f8
	ctx.lr = 0x82803260;
	sub_821C67F8(ctx, base);
	// 82803260: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82803264: 48000008  b 0x8280326c
	pc = 0x8280326C; continue 'dispatch;
            }
            0x82803268 => {
    //   block [0x82803268..0x8280326C)
	// 82803268: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8280326C; continue 'dispatch;
            }
            0x8280326C => {
    //   block [0x8280326C..0x82803298)
	// 8280326C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82803270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803274: 419A0314  beq cr6, 0x82803588
	if ctx.cr[6].eq {
	pc = 0x82803588; continue 'dispatch;
	}
	// 82803278: 3B20FFFF  li r25, -1
	ctx.r[25].s64 = -1;
	// 8280327C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82803280: 409900A8  ble cr6, 0x82803328
	if !ctx.cr[6].gt {
	pc = 0x82803328; continue 'dispatch;
	}
	// 82803284: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280328C: 409A000C  bne cr6, 0x82803298
	if !ctx.cr[6].eq {
	pc = 0x82803298; continue 'dispatch;
	}
	// 82803290: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82803294: 48000008  b 0x8280329c
	pc = 0x8280329C; continue 'dispatch;
            }
            0x82803298 => {
    //   block [0x82803298..0x8280329C)
	// 82803298: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x8280329C; continue 'dispatch;
            }
            0x8280329C => {
    //   block [0x8280329C..0x828032E8)
	// 8280329C: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 828032A0: 40980088  bge cr6, 0x82803328
	if !ctx.cr[6].lt {
	pc = 0x82803328; continue 'dispatch;
	}
	// 828032A4: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 828032A8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 828032AC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828032B0: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828032B4: 4833C4A5  bl 0x82b3f758
	ctx.lr = 0x828032B8;
	sub_82B3F758(ctx, base);
	// 828032B8: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828032BC: 4BA1BF9D  bl 0x8221f258
	ctx.lr = 0x828032C0;
	sub_8221F258(ctx, base);
	// 828032C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828032C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828032C8: 419A0020  beq cr6, 0x828032e8
	if ctx.cr[6].eq {
	pc = 0x828032E8; continue 'dispatch;
	}
	// 828032CC: 92BF0000  stw r21, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 828032D0: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828032D4: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828032D8: 4BA84951  bl 0x82287c28
	ctx.lr = 0x828032DC;
	sub_82287C28(ctx, base);
	// 828032DC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828032E0: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828032E4: 48000008  b 0x828032ec
	pc = 0x828032EC; continue 'dispatch;
            }
            0x828032E8 => {
    //   block [0x828032E8..0x828032EC)
	// 828032E8: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x828032EC; continue 'dispatch;
            }
            0x828032EC => {
    //   block [0x828032EC..0x82803308)
	// 828032EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 828032F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828032F4: 419A0014  beq cr6, 0x82803308
	if ctx.cr[6].eq {
	pc = 0x82803308; continue 'dispatch;
	}
	// 828032F8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 828032FC: 480009F5  bl 0x82803cf0
	ctx.lr = 0x82803300;
	sub_82803CF0(ctx, base);
	// 82803300: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803304: 4800000C  b 0x82803310
	pc = 0x82803310; continue 'dispatch;
            }
            0x82803308 => {
    //   block [0x82803308..0x82803310)
	// 82803308: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8280330C: 92E10064  stw r23, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	pc = 0x82803310; continue 'dispatch;
            }
            0x82803310 => {
    //   block [0x82803310..0x82803328)
	// 82803310: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82803314: 4BC4DAA5  bl 0x82450db8
	ctx.lr = 0x82803318;
	sub_82450DB8(ctx, base);
	// 82803318: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8280331C: 4B9B47FD  bl 0x821b7b18
	ctx.lr = 0x82803320;
	sub_821B7B18(ctx, base);
	// 82803320: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82803324: 4B9C34D5  bl 0x821c67f8
	ctx.lr = 0x82803328;
	sub_821C67F8(ctx, base);
	pc = 0x82803328; continue 'dispatch;
            }
            0x82803328 => {
    //   block [0x82803328..0x82803348)
	// 82803328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280332C: 4800079D  bl 0x82803ac8
	ctx.lr = 0x82803330;
	sub_82803AC8(ctx, base);
	// 82803330: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82803334: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 82803338: 41980010  blt cr6, 0x82803348
	if ctx.cr[6].lt {
	pc = 0x82803348; continue 'dispatch;
	}
	// 8280333C: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 82803340: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82803344: 40990008  ble cr6, 0x8280334c
	if !ctx.cr[6].gt {
	pc = 0x8280334C; continue 'dispatch;
	}
	pc = 0x82803348; continue 'dispatch;
            }
            0x82803348 => {
    //   block [0x82803348..0x8280334C)
	// 82803348: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8280334C; continue 'dispatch;
            }
            0x8280334C => {
    //   block [0x8280334C..0x828033B0)
	// 8280334C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82803350: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803354: 419A0160  beq cr6, 0x828034b4
	if ctx.cr[6].eq {
	pc = 0x828034B4; continue 'dispatch;
	}
	// 82803358: 3D60820E  lis r11, -0x7df2
	ctx.r[11].s64 = -2113011712;
	// 8280335C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82803360: 388BABDC  addi r4, r11, -0x5424
	ctx.r[4].s64 = ctx.r[11].s64 + -21540;
	// 82803364: 4BAD30A5  bl 0x822d6408
	ctx.lr = 0x82803368;
	sub_822D6408(ctx, base);
	// 82803368: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8280336C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82803370: 4833BAE1  bl 0x82b3ee50
	ctx.lr = 0x82803374;
	sub_82B3EE50(ctx, base);
	// 82803374: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82803378: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8280337C: 4BA848AD  bl 0x82287c28
	ctx.lr = 0x82803380;
	sub_82287C28(ctx, base);
	// 82803380: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82803384: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82803388: 4833BB99  bl 0x82b3ef20
	ctx.lr = 0x8280338C;
	sub_82B3EF20(ctx, base);
	// 8280338C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82803390: 4B9C3469  bl 0x821c67f8
	ctx.lr = 0x82803394;
	sub_821C67F8(ctx, base);
	// 82803394: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82803398: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280339C: 409A0014  bne cr6, 0x828033b0
	if !ctx.cr[6].eq {
	pc = 0x828033B0; continue 'dispatch;
	}
	// 828033A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 828033A4: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	// 828033A8: 388B9218  addi r4, r11, -0x6de8
	ctx.r[4].s64 = ctx.r[11].s64 + -28136;
	// 828033AC: 4800000C  b 0x828033b8
	pc = 0x828033B8; continue 'dispatch;
            }
            0x828033B0 => {
    //   block [0x828033B0..0x828033B8)
	// 828033B0: 836B0004  lwz r27, 4(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828033B4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828033B8; continue 'dispatch;
            }
            0x828033B8 => {
    //   block [0x828033B8..0x828033E0)
	// 828033B8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828033BC: 4833BE0D  bl 0x82b3f1c8
	ctx.lr = 0x828033C0;
	sub_82B3F1C8(ctx, base);
	// 828033C0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828033C4: 2F1EFFFF  cmpwi cr6, r30, -1
	ctx.cr[6].compare_i32(ctx.r[30].s32, -1, &mut ctx.xer);
	// 828033C8: 409A001C  bne cr6, 0x828033e4
	if !ctx.cr[6].eq {
	pc = 0x828033E4; continue 'dispatch;
	}
	// 828033CC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 828033D0: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 828033D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828033D8: 419A0008  beq cr6, 0x828033e0
	if ctx.cr[6].eq {
	pc = 0x828033E0; continue 'dispatch;
	}
	// 828033DC: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828033E0; continue 'dispatch;
            }
            0x828033E0 => {
    //   block [0x828033E0..0x828033E4)
	// 828033E0: 7EFBBB78  mr r27, r23
	ctx.r[27].u64 = ctx.r[23].u64;
	pc = 0x828033E4; continue 'dispatch;
            }
            0x828033E4 => {
    //   block [0x828033E4..0x82803438)
	// 828033E4: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 828033E8: 38B80001  addi r5, r24, 1
	ctx.r[5].s64 = ctx.r[24].s64 + 1;
	// 828033EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 828033F0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828033F4: 4833C365  bl 0x82b3f758
	ctx.lr = 0x828033F8;
	sub_82B3F758(ctx, base);
	// 828033F8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 828033FC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82803400: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82803404: 4BFFFDB5  bl 0x828031b8
	ctx.lr = 0x82803408;
	sub_828031B8(ctx, base);
	// 82803408: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 8280340C: 4BA1BE4D  bl 0x8221f258
	ctx.lr = 0x82803410;
	sub_8221F258(ctx, base);
	// 82803410: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82803414: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82803418: 419A0020  beq cr6, 0x82803438
	if ctx.cr[6].eq {
	pc = 0x82803438; continue 'dispatch;
	}
	// 8280341C: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82803420: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82803424: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82803428: 4BA84801  bl 0x82287c28
	ctx.lr = 0x8280342C;
	sub_82287C28(ctx, base);
	// 8280342C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82803430: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 82803434: 48000008  b 0x8280343c
	pc = 0x8280343C; continue 'dispatch;
            }
            0x82803438 => {
    //   block [0x82803438..0x8280343C)
	// 82803438: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x8280343C; continue 'dispatch;
            }
            0x8280343C => {
    //   block [0x8280343C..0x82803458)
	// 8280343C: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82803440: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803444: 419A0014  beq cr6, 0x82803458
	if ctx.cr[6].eq {
	pc = 0x82803458; continue 'dispatch;
	}
	// 82803448: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8280344C: 480008A5  bl 0x82803cf0
	ctx.lr = 0x82803450;
	sub_82803CF0(ctx, base);
	// 82803450: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803454: 4800000C  b 0x82803460
	pc = 0x82803460; continue 'dispatch;
            }
            0x82803458 => {
    //   block [0x82803458..0x82803460)
	// 82803458: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8280345C: 92E1006C  stw r23, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[23].u32 ) };
	pc = 0x82803460; continue 'dispatch;
            }
            0x82803460 => {
    //   block [0x82803460..0x82803484)
	// 82803460: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82803464: 4BC4D955  bl 0x82450db8
	ctx.lr = 0x82803468;
	sub_82450DB8(ctx, base);
	// 82803468: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8280346C: 4B9B46AD  bl 0x821b7b18
	ctx.lr = 0x82803470;
	sub_821B7B18(ctx, base);
	// 82803470: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803474: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82803478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280347C: 419A0008  beq cr6, 0x82803484
	if ctx.cr[6].eq {
	pc = 0x82803484; continue 'dispatch;
	}
	// 82803480: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82803484; continue 'dispatch;
            }
            0x82803484 => {
    //   block [0x82803484..0x828034B4)
	// 82803484: 7CBEDA14  add r5, r30, r27
	ctx.r[5].u64 = ctx.r[30].u64 + ctx.r[27].u64;
	// 82803488: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8280348C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 82803490: 4833C2C9  bl 0x82b3f758
	ctx.lr = 0x82803494;
	sub_82B3F758(ctx, base);
	// 82803494: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803498: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280349C: 4BAB540D  bl 0x822b88a8
	ctx.lr = 0x828034A0;
	sub_822B88A8(ctx, base);
	// 828034A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 828034A4: 4B9C3355  bl 0x821c67f8
	ctx.lr = 0x828034A8;
	sub_821C67F8(ctx, base);
	// 828034A8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 828034AC: 4B9C334D  bl 0x821c67f8
	ctx.lr = 0x828034B0;
	sub_821C67F8(ctx, base);
	// 828034B0: 480000C0  b 0x82803570
	pc = 0x82803570; continue 'dispatch;
            }
            0x828034B4 => {
    //   block [0x828034B4..0x828034F4)
	// 828034B4: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 828034B8: 4BA1BDA1  bl 0x8221f258
	ctx.lr = 0x828034BC;
	sub_8221F258(ctx, base);
	// 828034BC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828034C0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828034C4: 419A0030  beq cr6, 0x828034f4
	if ctx.cr[6].eq {
	pc = 0x828034F4; continue 'dispatch;
	}
	// 828034C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 828034CC: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 828034D0: 4BAD2F39  bl 0x822d6408
	ctx.lr = 0x828034D4;
	sub_822D6408(ctx, base);
	// 828034D4: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828034D8: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 828034DC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 828034E0: 3B400001  li r26, 1
	ctx.r[26].s64 = 1;
	// 828034E4: 4BA84745  bl 0x82287c28
	ctx.lr = 0x828034E8;
	sub_82287C28(ctx, base);
	// 828034E8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 828034EC: 933F0008  stw r25, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 828034F0: 48000008  b 0x828034f8
	pc = 0x828034F8; continue 'dispatch;
            }
            0x828034F4 => {
    //   block [0x828034F4..0x828034F8)
	// 828034F4: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x828034F8; continue 'dispatch;
            }
            0x828034F8 => {
    //   block [0x828034F8..0x82803514)
	// 828034F8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 828034FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803500: 419A0014  beq cr6, 0x82803514
	if ctx.cr[6].eq {
	pc = 0x82803514; continue 'dispatch;
	}
	// 82803504: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82803508: 480007E9  bl 0x82803cf0
	ctx.lr = 0x8280350C;
	sub_82803CF0(ctx, base);
	// 8280350C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803510: 4800000C  b 0x8280351c
	pc = 0x8280351C; continue 'dispatch;
            }
            0x82803514 => {
    //   block [0x82803514..0x8280351C)
	// 82803514: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82803518: 92E10074  stw r23, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[23].u32 ) };
	pc = 0x8280351C; continue 'dispatch;
            }
            0x8280351C => {
    //   block [0x8280351C..0x82803540)
	// 8280351C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82803520: 4BC4D899  bl 0x82450db8
	ctx.lr = 0x82803524;
	sub_82450DB8(ctx, base);
	// 82803524: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82803528: 4B9B45F1  bl 0x821b7b18
	ctx.lr = 0x8280352C;
	sub_821B7B18(ctx, base);
	// 8280352C: 574B07FE  clrlwi r11, r26, 0x1f
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x00000001u64;
	// 82803530: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82803534: 419A000C  beq cr6, 0x82803540
	if ctx.cr[6].eq {
	pc = 0x82803540; continue 'dispatch;
	}
	// 82803538: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 8280353C: 4B9C32BD  bl 0x821c67f8
	ctx.lr = 0x82803540;
	sub_821C67F8(ctx, base);
	pc = 0x82803540; continue 'dispatch;
            }
            0x82803540 => {
    //   block [0x82803540..0x82803554)
	// 82803540: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803544: 7EE6BB78  mr r6, r23
	ctx.r[6].u64 = ctx.r[23].u64;
	// 82803548: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280354C: 419A0008  beq cr6, 0x82803554
	if ctx.cr[6].eq {
	pc = 0x82803554; continue 'dispatch;
	}
	// 82803550: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82803554; continue 'dispatch;
            }
            0x82803554 => {
    //   block [0x82803554..0x82803570)
	// 82803554: 38B80001  addi r5, r24, 1
	ctx.r[5].s64 = ctx.r[24].s64 + 1;
	// 82803558: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8280355C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82803560: 4833C1F9  bl 0x82b3f758
	ctx.lr = 0x82803564;
	sub_82B3F758(ctx, base);
	// 82803564: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82803568: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280356C: 4BAB533D  bl 0x822b88a8
	ctx.lr = 0x82803570;
	sub_822B88A8(ctx, base);
	pc = 0x82803570; continue 'dispatch;
            }
            0x82803570 => {
    //   block [0x82803570..0x82803588)
	// 82803570: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 82803574: 4B9C3285  bl 0x821c67f8
	ctx.lr = 0x82803578;
	sub_821C67F8(ctx, base);
	// 82803578: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 8280357C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82803580: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 82803584: 4BFFFC35  bl 0x828031b8
	ctx.lr = 0x82803588;
	sub_828031B8(ctx, base);
	pc = 0x82803588; continue 'dispatch;
            }
            0x82803588 => {
    //   block [0x82803588..0x82803598)
	// 82803588: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280358C: 4B9C326D  bl 0x821c67f8
	ctx.lr = 0x82803590;
	sub_821C67F8(ctx, base);
	// 82803590: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82803594: 484A5EA8  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803598(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803598 size=1324
    let mut pc: u32 = 0x82803598;
    'dispatch: loop {
        match pc {
            0x82803598 => {
    //   block [0x82803598..0x82803AB0)
	// 82803598: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280359C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828035A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828035A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828035A8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828035AC: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 828035B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828035B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828035B8: 409A04F8  bne cr6, 0x82803ab0
	if !ctx.cr[6].eq {
	pc = 0x82803AB0; continue 'dispatch;
	}
	// 828035BC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828035C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828035C4: 388BBB3C  addi r4, r11, -0x44c4
	ctx.r[4].s64 = ctx.r[11].s64 + -17604;
	// 828035C8: 480005E1  bl 0x82803ba8
	ctx.lr = 0x828035CC;
	sub_82803BA8(ctx, base);
	// 828035CC: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 828035D0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 828035D4: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 828035D8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828035DC: 3888BB40  addi r4, r8, -0x44c0
	ctx.r[4].s64 = ctx.r[8].s64 + -17600;
	// 828035E0: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 828035E4: 480005C5  bl 0x82803ba8
	ctx.lr = 0x828035E8;
	sub_82803BA8(ctx, base);
	// 828035E8: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 828035EC: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 828035F0: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828035F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828035F8: 3885BB44  addi r4, r5, -0x44bc
	ctx.r[4].s64 = ctx.r[5].s64 + -17596;
	// 828035FC: 90C70000  stw r6, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82803600: 480005A9  bl 0x82803ba8
	ctx.lr = 0x82803604;
	sub_82803BA8(ctx, base);
	// 82803604: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803608: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8280360C: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82803610: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803614: 3889BB48  addi r4, r9, -0x44b8
	ctx.r[4].s64 = ctx.r[9].s64 + -17592;
	// 82803618: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8280361C: 4800058D  bl 0x82803ba8
	ctx.lr = 0x82803620;
	sub_82803BA8(ctx, base);
	// 82803620: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82803624: 38E00004  li r7, 4
	ctx.r[7].s64 = 4;
	// 82803628: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8280362C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803630: 3886BB4C  addi r4, r6, -0x44b4
	ctx.r[4].s64 = ctx.r[6].s64 + -17588;
	// 82803634: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82803638: 48000571  bl 0x82803ba8
	ctx.lr = 0x8280363C;
	sub_82803BA8(ctx, base);
	// 8280363C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82803640: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82803644: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82803648: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280364C: 388ABB50  addi r4, r10, -0x44b0
	ctx.r[4].s64 = ctx.r[10].s64 + -17584;
	// 82803650: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82803654: 48000555  bl 0x82803ba8
	ctx.lr = 0x82803658;
	sub_82803BA8(ctx, base);
	// 82803658: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8280365C: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 82803660: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82803664: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803668: 3887BB54  addi r4, r7, -0x44ac
	ctx.r[4].s64 = ctx.r[7].s64 + -17580;
	// 8280366C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82803670: 48000539  bl 0x82803ba8
	ctx.lr = 0x82803674;
	sub_82803BA8(ctx, base);
	// 82803674: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82803678: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 8280367C: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 82803680: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803684: 3884BB58  addi r4, r4, -0x44a8
	ctx.r[4].s64 = ctx.r[4].s64 + -17576;
	// 82803688: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8280368C: 4800051D  bl 0x82803ba8
	ctx.lr = 0x82803690;
	sub_82803BA8(ctx, base);
	// 82803690: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803694: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 82803698: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8280369C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828036A0: 3889BB5C  addi r4, r9, -0x44a4
	ctx.r[4].s64 = ctx.r[9].s64 + -17572;
	// 828036A4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828036A8: 48000501  bl 0x82803ba8
	ctx.lr = 0x828036AC;
	sub_82803BA8(ctx, base);
	// 828036AC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828036B0: 38E00009  li r7, 9
	ctx.r[7].s64 = 9;
	// 828036B4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828036B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828036BC: 3886BB60  addi r4, r6, -0x44a0
	ctx.r[4].s64 = ctx.r[6].s64 + -17568;
	// 828036C0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828036C4: 480004E5  bl 0x82803ba8
	ctx.lr = 0x828036C8;
	sub_82803BA8(ctx, base);
	// 828036C8: 38A0000A  li r5, 0xa
	ctx.r[5].s64 = 10;
	// 828036CC: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 828036D0: 90A30000  stw r5, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 828036D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828036D8: 3884BB64  addi r4, r4, -0x449c
	ctx.r[4].s64 = ctx.r[4].s64 + -17564;
	// 828036DC: 480004CD  bl 0x82803ba8
	ctx.lr = 0x828036E0;
	sub_82803BA8(ctx, base);
	// 828036E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828036E4: 3940000B  li r10, 0xb
	ctx.r[10].s64 = 11;
	// 828036E8: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 828036EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828036F0: 3889BB68  addi r4, r9, -0x4498
	ctx.r[4].s64 = ctx.r[9].s64 + -17560;
	// 828036F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828036F8: 480004B1  bl 0x82803ba8
	ctx.lr = 0x828036FC;
	sub_82803BA8(ctx, base);
	// 828036FC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82803700: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 82803704: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82803708: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8280370C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803710: 3886BB6C  addi r4, r6, -0x4494
	ctx.r[4].s64 = ctx.r[6].s64 + -17556;
	// 82803714: 48000495  bl 0x82803ba8
	ctx.lr = 0x82803718;
	sub_82803BA8(ctx, base);
	// 82803718: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8280371C: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 82803720: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82803724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803728: 388ABB70  addi r4, r10, -0x4490
	ctx.r[4].s64 = ctx.r[10].s64 + -17552;
	// 8280372C: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82803730: 48000479  bl 0x82803ba8
	ctx.lr = 0x82803734;
	sub_82803BA8(ctx, base);
	// 82803734: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82803738: 3900000E  li r8, 0xe
	ctx.r[8].s64 = 14;
	// 8280373C: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82803740: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803744: 3887BB74  addi r4, r7, -0x448c
	ctx.r[4].s64 = ctx.r[7].s64 + -17548;
	// 82803748: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 8280374C: 4800045D  bl 0x82803ba8
	ctx.lr = 0x82803750;
	sub_82803BA8(ctx, base);
	// 82803750: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82803754: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 82803758: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 8280375C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803760: 3884BB78  addi r4, r4, -0x4488
	ctx.r[4].s64 = ctx.r[4].s64 + -17544;
	// 82803764: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82803768: 48000441  bl 0x82803ba8
	ctx.lr = 0x8280376C;
	sub_82803BA8(ctx, base);
	// 8280376C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803770: 39400010  li r10, 0x10
	ctx.r[10].s64 = 16;
	// 82803774: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82803778: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280377C: 3889BB7C  addi r4, r9, -0x4484
	ctx.r[4].s64 = ctx.r[9].s64 + -17540;
	// 82803780: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803784: 48000425  bl 0x82803ba8
	ctx.lr = 0x82803788;
	sub_82803BA8(ctx, base);
	// 82803788: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8280378C: 38E00011  li r7, 0x11
	ctx.r[7].s64 = 17;
	// 82803790: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82803794: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803798: 3886BB80  addi r4, r6, -0x4480
	ctx.r[4].s64 = ctx.r[6].s64 + -17536;
	// 8280379C: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828037A0: 48000409  bl 0x82803ba8
	ctx.lr = 0x828037A4;
	sub_82803BA8(ctx, base);
	// 828037A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828037A8: 39600012  li r11, 0x12
	ctx.r[11].s64 = 18;
	// 828037AC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828037B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828037B4: 388ABB84  addi r4, r10, -0x447c
	ctx.r[4].s64 = ctx.r[10].s64 + -17532;
	// 828037B8: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828037BC: 480003ED  bl 0x82803ba8
	ctx.lr = 0x828037C0;
	sub_82803BA8(ctx, base);
	// 828037C0: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828037C4: 39000013  li r8, 0x13
	ctx.r[8].s64 = 19;
	// 828037C8: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828037CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828037D0: 3887BB88  addi r4, r7, -0x4478
	ctx.r[4].s64 = ctx.r[7].s64 + -17528;
	// 828037D4: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828037D8: 480003D1  bl 0x82803ba8
	ctx.lr = 0x828037DC;
	sub_82803BA8(ctx, base);
	// 828037DC: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	// 828037E0: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828037E4: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828037E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828037EC: 3885BB8C  addi r4, r5, -0x4474
	ctx.r[4].s64 = ctx.r[5].s64 + -17524;
	// 828037F0: 480003B9  bl 0x82803ba8
	ctx.lr = 0x828037F4;
	sub_82803BA8(ctx, base);
	// 828037F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 828037F8: 39400015  li r10, 0x15
	ctx.r[10].s64 = 21;
	// 828037FC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82803800: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803804: 3889BB90  addi r4, r9, -0x4470
	ctx.r[4].s64 = ctx.r[9].s64 + -17520;
	// 82803808: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8280380C: 4800039D  bl 0x82803ba8
	ctx.lr = 0x82803810;
	sub_82803BA8(ctx, base);
	// 82803810: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82803814: 38E00016  li r7, 0x16
	ctx.r[7].s64 = 22;
	// 82803818: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 8280381C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803820: 3886BB94  addi r4, r6, -0x446c
	ctx.r[4].s64 = ctx.r[6].s64 + -17516;
	// 82803824: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82803828: 48000381  bl 0x82803ba8
	ctx.lr = 0x8280382C;
	sub_82803BA8(ctx, base);
	// 8280382C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803830: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 82803834: 39400017  li r10, 0x17
	ctx.r[10].s64 = 23;
	// 82803838: 3885BB98  addi r4, r5, -0x4468
	ctx.r[4].s64 = ctx.r[5].s64 + -17512;
	// 8280383C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803840: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803844: 48000365  bl 0x82803ba8
	ctx.lr = 0x82803848;
	sub_82803BA8(ctx, base);
	// 82803848: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8280384C: 39000018  li r8, 0x18
	ctx.r[8].s64 = 24;
	// 82803850: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82803854: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803858: 3887BB9C  addi r4, r7, -0x4464
	ctx.r[4].s64 = ctx.r[7].s64 + -17508;
	// 8280385C: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82803860: 48000349  bl 0x82803ba8
	ctx.lr = 0x82803864;
	sub_82803BA8(ctx, base);
	// 82803864: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82803868: 38A00019  li r5, 0x19
	ctx.r[5].s64 = 25;
	// 8280386C: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 82803870: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803874: 3884BBA0  addi r4, r4, -0x4460
	ctx.r[4].s64 = ctx.r[4].s64 + -17504;
	// 82803878: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 8280387C: 4800032D  bl 0x82803ba8
	ctx.lr = 0x82803880;
	sub_82803BA8(ctx, base);
	// 82803880: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803884: 3940001A  li r10, 0x1a
	ctx.r[10].s64 = 26;
	// 82803888: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8280388C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803890: 3889BBA4  addi r4, r9, -0x445c
	ctx.r[4].s64 = ctx.r[9].s64 + -17500;
	// 82803894: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803898: 48000311  bl 0x82803ba8
	ctx.lr = 0x8280389C;
	sub_82803BA8(ctx, base);
	// 8280389C: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828038A0: 38E0001B  li r7, 0x1b
	ctx.r[7].s64 = 27;
	// 828038A4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828038A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828038AC: 3886BBA8  addi r4, r6, -0x4458
	ctx.r[4].s64 = ctx.r[6].s64 + -17496;
	// 828038B0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828038B4: 480002F5  bl 0x82803ba8
	ctx.lr = 0x828038B8;
	sub_82803BA8(ctx, base);
	// 828038B8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828038BC: 3960001C  li r11, 0x1c
	ctx.r[11].s64 = 28;
	// 828038C0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828038C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828038C8: 388ABBAC  addi r4, r10, -0x4454
	ctx.r[4].s64 = ctx.r[10].s64 + -17492;
	// 828038CC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828038D0: 480002D9  bl 0x82803ba8
	ctx.lr = 0x828038D4;
	sub_82803BA8(ctx, base);
	// 828038D4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828038D8: 3900001D  li r8, 0x1d
	ctx.r[8].s64 = 29;
	// 828038DC: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828038E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828038E4: 3887BBB0  addi r4, r7, -0x4450
	ctx.r[4].s64 = ctx.r[7].s64 + -17488;
	// 828038E8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828038EC: 480002BD  bl 0x82803ba8
	ctx.lr = 0x828038F0;
	sub_82803BA8(ctx, base);
	// 828038F0: 38C0001E  li r6, 0x1e
	ctx.r[6].s64 = 30;
	// 828038F4: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 828038F8: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 828038FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803900: 3885BBB4  addi r4, r5, -0x444c
	ctx.r[4].s64 = ctx.r[5].s64 + -17484;
	// 82803904: 480002A5  bl 0x82803ba8
	ctx.lr = 0x82803908;
	sub_82803BA8(ctx, base);
	// 82803908: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8280390C: 3940001F  li r10, 0x1f
	ctx.r[10].s64 = 31;
	// 82803910: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82803914: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803918: 3889BBB8  addi r4, r9, -0x4448
	ctx.r[4].s64 = ctx.r[9].s64 + -17480;
	// 8280391C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803920: 48000289  bl 0x82803ba8
	ctx.lr = 0x82803924;
	sub_82803BA8(ctx, base);
	// 82803924: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82803928: 38E00020  li r7, 0x20
	ctx.r[7].s64 = 32;
	// 8280392C: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82803930: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803934: 3886BBBC  addi r4, r6, -0x4444
	ctx.r[4].s64 = ctx.r[6].s64 + -17476;
	// 82803938: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 8280393C: 4800026D  bl 0x82803ba8
	ctx.lr = 0x82803940;
	sub_82803BA8(ctx, base);
	// 82803940: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82803944: 39600021  li r11, 0x21
	ctx.r[11].s64 = 33;
	// 82803948: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 8280394C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803950: 388ABBC0  addi r4, r10, -0x4440
	ctx.r[4].s64 = ctx.r[10].s64 + -17472;
	// 82803954: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82803958: 48000251  bl 0x82803ba8
	ctx.lr = 0x8280395C;
	sub_82803BA8(ctx, base);
	// 8280395C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82803960: 39000022  li r8, 0x22
	ctx.r[8].s64 = 34;
	// 82803964: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82803968: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280396C: 3887BBC4  addi r4, r7, -0x443c
	ctx.r[4].s64 = ctx.r[7].s64 + -17468;
	// 82803970: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82803974: 48000235  bl 0x82803ba8
	ctx.lr = 0x82803978;
	sub_82803BA8(ctx, base);
	// 82803978: 38C00023  li r6, 0x23
	ctx.r[6].s64 = 35;
	// 8280397C: 3CA0834A  lis r5, -0x7cb6
	ctx.r[5].s64 = -2092302336;
	// 82803980: 90C30000  stw r6, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 82803984: 3885BBC8  addi r4, r5, -0x4438
	ctx.r[4].s64 = ctx.r[5].s64 + -17464;
	// 82803988: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280398C: 4800021D  bl 0x82803ba8
	ctx.lr = 0x82803990;
	sub_82803BA8(ctx, base);
	// 82803990: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803994: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 82803998: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 8280399C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828039A0: 3889BBCC  addi r4, r9, -0x4434
	ctx.r[4].s64 = ctx.r[9].s64 + -17460;
	// 828039A4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828039A8: 48000201  bl 0x82803ba8
	ctx.lr = 0x828039AC;
	sub_82803BA8(ctx, base);
	// 828039AC: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 828039B0: 38E00025  li r7, 0x25
	ctx.r[7].s64 = 37;
	// 828039B4: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 828039B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828039BC: 3886BBD0  addi r4, r6, -0x4430
	ctx.r[4].s64 = ctx.r[6].s64 + -17456;
	// 828039C0: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 828039C4: 480001E5  bl 0x82803ba8
	ctx.lr = 0x828039C8;
	sub_82803BA8(ctx, base);
	// 828039C8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 828039CC: 39600026  li r11, 0x26
	ctx.r[11].s64 = 38;
	// 828039D0: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 828039D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828039D8: 388ABBD4  addi r4, r10, -0x442c
	ctx.r[4].s64 = ctx.r[10].s64 + -17452;
	// 828039DC: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828039E0: 480001C9  bl 0x82803ba8
	ctx.lr = 0x828039E4;
	sub_82803BA8(ctx, base);
	// 828039E4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 828039E8: 39000027  li r8, 0x27
	ctx.r[8].s64 = 39;
	// 828039EC: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 828039F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828039F4: 3887BBD8  addi r4, r7, -0x4428
	ctx.r[4].s64 = ctx.r[7].s64 + -17448;
	// 828039F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 828039FC: 480001AD  bl 0x82803ba8
	ctx.lr = 0x82803A00;
	sub_82803BA8(ctx, base);
	// 82803A00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82803A04: 38A00028  li r5, 0x28
	ctx.r[5].s64 = 40;
	// 82803A08: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 82803A0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A10: 3884BBDC  addi r4, r4, -0x4424
	ctx.r[4].s64 = ctx.r[4].s64 + -17444;
	// 82803A14: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82803A18: 48000191  bl 0x82803ba8
	ctx.lr = 0x82803A1C;
	sub_82803BA8(ctx, base);
	// 82803A1C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803A20: 39400029  li r10, 0x29
	ctx.r[10].s64 = 41;
	// 82803A24: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 82803A28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A2C: 3889BBE0  addi r4, r9, -0x4420
	ctx.r[4].s64 = ctx.r[9].s64 + -17440;
	// 82803A30: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803A34: 48000175  bl 0x82803ba8
	ctx.lr = 0x82803A38;
	sub_82803BA8(ctx, base);
	// 82803A38: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 82803A3C: 38E0002A  li r7, 0x2a
	ctx.r[7].s64 = 42;
	// 82803A40: 3CC0834A  lis r6, -0x7cb6
	ctx.r[6].s64 = -2092302336;
	// 82803A44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A48: 3886BBE4  addi r4, r6, -0x441c
	ctx.r[4].s64 = ctx.r[6].s64 + -17436;
	// 82803A4C: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 82803A50: 48000159  bl 0x82803ba8
	ctx.lr = 0x82803A54;
	sub_82803BA8(ctx, base);
	// 82803A54: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82803A58: 3960002B  li r11, 0x2b
	ctx.r[11].s64 = 43;
	// 82803A5C: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82803A60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A64: 388ABBE8  addi r4, r10, -0x4418
	ctx.r[4].s64 = ctx.r[10].s64 + -17432;
	// 82803A68: 91650000  stw r11, 0(r5)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82803A6C: 4800013D  bl 0x82803ba8
	ctx.lr = 0x82803A70;
	sub_82803BA8(ctx, base);
	// 82803A70: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 82803A74: 3900002C  li r8, 0x2c
	ctx.r[8].s64 = 44;
	// 82803A78: 3CE0834A  lis r7, -0x7cb6
	ctx.r[7].s64 = -2092302336;
	// 82803A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A80: 3887BBEC  addi r4, r7, -0x4414
	ctx.r[4].s64 = ctx.r[7].s64 + -17428;
	// 82803A84: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82803A88: 48000121  bl 0x82803ba8
	ctx.lr = 0x82803A8C;
	sub_82803BA8(ctx, base);
	// 82803A8C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 82803A90: 38A0002D  li r5, 0x2d
	ctx.r[5].s64 = 45;
	// 82803A94: 3C80834A  lis r4, -0x7cb6
	ctx.r[4].s64 = -2092302336;
	// 82803A98: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803A9C: 3884BBF0  addi r4, r4, -0x4410
	ctx.r[4].s64 = ctx.r[4].s64 + -17424;
	// 82803AA0: 90A60000  stw r5, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 82803AA4: 48000105  bl 0x82803ba8
	ctx.lr = 0x82803AA8;
	sub_82803BA8(ctx, base);
	// 82803AA8: 3960002E  li r11, 0x2e
	ctx.r[11].s64 = 46;
	// 82803AAC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x82803AB0; continue 'dispatch;
            }
            0x82803AB0 => {
    //   block [0x82803AB0..0x82803AC4)
	// 82803AB0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82803AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82803AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82803ABC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82803AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803AC8 size=224
    let mut pc: u32 = 0x82803AC8;
    'dispatch: loop {
        match pc {
            0x82803AC8 => {
    //   block [0x82803AC8..0x82803B10)
	// 82803AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803ACC: 484A593D  bl 0x82ca9408
	ctx.lr = 0x82803AD0;
	sub_82CA93D0(ctx, base);
	// 82803AD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803AD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82803AD8: 4BFFFAC1  bl 0x82803598
	ctx.lr = 0x82803ADC;
	sub_82803598(ctx, base);
	// 82803ADC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82803AE0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803AE4: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 82803AE8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82803AEC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803AF0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 82803AF4: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803AF8: 480004F9  bl 0x82803ff0
	ctx.lr = 0x82803AFC;
	sub_82803FF0(ctx, base);
	// 82803AFC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82803B00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803B04: 419A000C  beq cr6, 0x82803b10
	if ctx.cr[6].eq {
	pc = 0x82803B10; continue 'dispatch;
	}
	// 82803B08: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803B0C: 419A0008  beq cr6, 0x82803b14
	if ctx.cr[6].eq {
	pc = 0x82803B14; continue 'dispatch;
	}
	pc = 0x82803B10; continue 'dispatch;
            }
            0x82803B10 => {
    //   block [0x82803B10..0x82803B14)
	// 82803B10: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803B14; continue 'dispatch;
            }
            0x82803B14 => {
    //   block [0x82803B14..0x82803B48)
	// 82803B14: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803B18: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803B1C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82803B20: 419A002C  beq cr6, 0x82803b4c
	if ctx.cr[6].eq {
	pc = 0x82803B4C; continue 'dispatch;
	}
	// 82803B24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803B28: 38AA000C  addi r5, r10, 0xc
	ctx.r[5].s64 = ctx.r[10].s64 + 12;
	// 82803B2C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803B30: 48000561  bl 0x82804090
	ctx.lr = 0x82803B34;
	sub_82804090(ctx, base);
	// 82803B34: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803B38: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803B3C: 409A000C  bne cr6, 0x82803b48
	if !ctx.cr[6].eq {
	pc = 0x82803B48; continue 'dispatch;
	}
	// 82803B40: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 82803B44: 48000014  b 0x82803b58
	pc = 0x82803B58; continue 'dispatch;
            }
            0x82803B48 => {
    //   block [0x82803B48..0x82803B4C)
	// 82803B48: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82803B4C; continue 'dispatch;
            }
            0x82803B4C => {
    //   block [0x82803B4C..0x82803B58)
	// 82803B4C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82803B50: 39610058  addi r11, r1, 0x58
	ctx.r[11].s64 = ctx.r[1].s64 + 88;
	// 82803B54: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x82803B58; continue 'dispatch;
            }
            0x82803B58 => {
    //   block [0x82803B58..0x82803B74)
	// 82803B58: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82803B5C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82803B60: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 82803B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803B68: 419A000C  beq cr6, 0x82803b74
	if ctx.cr[6].eq {
	pc = 0x82803B74; continue 'dispatch;
	}
	// 82803B6C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803B70: 419A0008  beq cr6, 0x82803b78
	if ctx.cr[6].eq {
	pc = 0x82803B78; continue 'dispatch;
	}
	pc = 0x82803B74; continue 'dispatch;
            }
            0x82803B74 => {
    //   block [0x82803B74..0x82803B78)
	// 82803B74: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803B78; continue 'dispatch;
            }
            0x82803B78 => {
    //   block [0x82803B78..0x82803B9C)
	// 82803B78: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 82803B7C: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 82803B80: 419A001C  beq cr6, 0x82803b9c
	if ctx.cr[6].eq {
	pc = 0x82803B9C; continue 'dispatch;
	}
	// 82803B84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803B88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803B8C: 4800001D  bl 0x82803ba8
	ctx.lr = 0x82803B90;
	sub_82803BA8(ctx, base);
	// 82803B90: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803B94: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82803B98: 484A58C0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803B9C => {
    //   block [0x82803B9C..0x82803BA8)
	// 82803B9C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82803BA0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82803BA4: 484A58B4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803BA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803BA8 size=216
    let mut pc: u32 = 0x82803BA8;
    'dispatch: loop {
        match pc {
            0x82803BA8 => {
    //   block [0x82803BA8..0x82803BE4)
	// 82803BA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803BAC: 484A585D  bl 0x82ca9408
	ctx.lr = 0x82803BB0;
	sub_82CA93D0(ctx, base);
	// 82803BB0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803BB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82803BB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82803BBC: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 82803BC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803BC4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82803BC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803BCC: 48000425  bl 0x82803ff0
	ctx.lr = 0x82803BD0;
	sub_82803FF0(ctx, base);
	// 82803BD0: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82803BD4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82803BD8: 419A000C  beq cr6, 0x82803be4
	if ctx.cr[6].eq {
	pc = 0x82803BE4; continue 'dispatch;
	}
	// 82803BDC: 7F1CF840  cmplw cr6, r28, r31
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803BE0: 419A0008  beq cr6, 0x82803be8
	if ctx.cr[6].eq {
	pc = 0x82803BE8; continue 'dispatch;
	}
	pc = 0x82803BE4; continue 'dispatch;
            }
            0x82803BE4 => {
    //   block [0x82803BE4..0x82803BE8)
	// 82803BE4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803BE8; continue 'dispatch;
            }
            0x82803BE8 => {
    //   block [0x82803BE8..0x82803C14)
	// 82803BE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803BEC: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803BF0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82803BF4: 419A0020  beq cr6, 0x82803c14
	if ctx.cr[6].eq {
	pc = 0x82803C14; continue 'dispatch;
	}
	// 82803BF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803BFC: 38BD000C  addi r5, r29, 0xc
	ctx.r[5].s64 = ctx.r[29].s64 + 12;
	// 82803C00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803C04: 4800048D  bl 0x82804090
	ctx.lr = 0x82803C08;
	sub_82804090(ctx, base);
	// 82803C08: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803C0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803C10: 419A0048  beq cr6, 0x82803c58
	if ctx.cr[6].eq {
	pc = 0x82803C58; continue 'dispatch;
	}
	pc = 0x82803C14; continue 'dispatch;
            }
            0x82803C14 => {
    //   block [0x82803C14..0x82803C58)
	// 82803C14: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82803C1C: 4BA8400D  bl 0x82287c28
	ctx.lr = 0x82803C20;
	sub_82287C28(ctx, base);
	// 82803C20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82803C24: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803C28: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82803C2C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82803C30: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 82803C34: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82803C38: 48000121  bl 0x82803d58
	ctx.lr = 0x82803C3C;
	sub_82803D58(ctx, base);
	// 82803C3C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 82803C40: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82803C44: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82803C48: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82803C4C: 4B9C2BAD  bl 0x821c67f8
	ctx.lr = 0x82803C50;
	sub_821C67F8(ctx, base);
	// 82803C50: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803C54: 83810050  lwz r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82803C58; continue 'dispatch;
            }
            0x82803C58 => {
    //   block [0x82803C58..0x82803C64)
	// 82803C58: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 82803C5C: 409A0008  bne cr6, 0x82803c64
	if !ctx.cr[6].eq {
	pc = 0x82803C64; continue 'dispatch;
	}
	// 82803C60: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803C64; continue 'dispatch;
            }
            0x82803C64 => {
    //   block [0x82803C64..0x82803C74)
	// 82803C64: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803C68: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82803C6C: 409A0008  bne cr6, 0x82803c74
	if !ctx.cr[6].eq {
	pc = 0x82803C74; continue 'dispatch;
	}
	// 82803C70: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803C74; continue 'dispatch;
            }
            0x82803C74 => {
    //   block [0x82803C74..0x82803C80)
	// 82803C74: 387D0010  addi r3, r29, 0x10
	ctx.r[3].s64 = ctx.r[29].s64 + 16;
	// 82803C78: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82803C7C: 484A57DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803C80 size=112
    let mut pc: u32 = 0x82803C80;
    'dispatch: loop {
        match pc {
            0x82803C80 => {
    //   block [0x82803C80..0x82803CF0)
	// 82803C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803C84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82803C88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82803C8C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803C90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82803C94: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82803C98: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 82803C9C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 82803CA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803CA4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 82803CA8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803CAC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803CB0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 82803CB4: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82803CB8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 82803CBC: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82803CC0: 480005F9  bl 0x828042b8
	ctx.lr = 0x82803CC4;
	sub_828042B8(ctx, base);
	// 82803CC4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803CC8: 4BA18071  bl 0x8221bd38
	ctx.lr = 0x82803CCC;
	sub_8221BD38(ctx, base);
	// 82803CCC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82803CD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82803CD4: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82803CD8: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82803CDC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82803CE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82803CE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82803CE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82803CEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803CF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803CF0 size=104
    let mut pc: u32 = 0x82803CF0;
    'dispatch: loop {
        match pc {
            0x82803CF0 => {
    //   block [0x82803CF0..0x82803D3C)
	// 82803CF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803CF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82803CF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82803CFC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803D00: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82803D04: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 82803D08: 4BA1B551  bl 0x8221f258
	ctx.lr = 0x82803D0C;
	sub_8221F258(ctx, base);
	// 82803D0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803D10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803D18: 419A0024  beq cr6, 0x82803d3c
	if ctx.cr[6].eq {
	pc = 0x82803D3C; continue 'dispatch;
	}
	// 82803D1C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803D20: 3D208280  lis r9, -0x7d80
	ctx.r[9].s64 = -2105540608;
	// 82803D24: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 82803D28: 38E940F0  addi r7, r9, 0x40f0
	ctx.r[7].s64 = ctx.r[9].s64 + 16624;
	// 82803D2C: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 82803D30: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 82803D34: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82803D38: 48000008  b 0x82803d40
	pc = 0x82803D40; continue 'dispatch;
            }
            0x82803D3C => {
    //   block [0x82803D3C..0x82803D40)
	// 82803D3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82803D40; continue 'dispatch;
            }
            0x82803D40 => {
    //   block [0x82803D40..0x82803D58)
	// 82803D40: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82803D44: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82803D48: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82803D4C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82803D50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82803D54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803D58 size=664
    let mut pc: u32 = 0x82803D58;
    'dispatch: loop {
        match pc {
            0x82803D58 => {
    //   block [0x82803D58..0x82803DB4)
	// 82803D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803D5C: 484A56A5  bl 0x82ca9400
	ctx.lr = 0x82803D60;
	sub_82CA93D0(ctx, base);
	// 82803D60: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803D64: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82803D68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82803D6C: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 82803D70: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82803D74: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 82803D78: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82803D7C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 82803D80: FB4100C0  std r26, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u64 ) };
	// 82803D84: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 82803D88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82803D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803D90: 409A0024  bne cr6, 0x82803db4
	if !ctx.cr[6].eq {
	pc = 0x82803DB4; continue 'dispatch;
	}
	// 82803D94: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803D98: 80DF0004  lwz r6, 4(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803D9C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82803DA0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82803DA4: 48000625  bl 0x828043c8
	ctx.lr = 0x82803DA8;
	sub_828043C8(ctx, base);
	// 82803DA8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803DAC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803DB0: 484A56A0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803DB4 => {
    //   block [0x82803DB4..0x82803DD0)
	// 82803DB4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803DB8: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 82803DBC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803DC0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803DC4: 419A000C  beq cr6, 0x82803dd0
	if ctx.cr[6].eq {
	pc = 0x82803DD0; continue 'dispatch;
	}
	// 82803DC8: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803DCC: 419A0008  beq cr6, 0x82803dd4
	if ctx.cr[6].eq {
	pc = 0x82803DD4; continue 'dispatch;
	}
	pc = 0x82803DD0; continue 'dispatch;
            }
            0x82803DD0 => {
    //   block [0x82803DD0..0x82803DD4)
	// 82803DD0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803DD4; continue 'dispatch;
            }
            0x82803DD4 => {
    //   block [0x82803DD4..0x82803E20)
	// 82803DD4: 836100C4  lwz r27, 0xc4(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 82803DD8: 7F1B4840  cmplw cr6, r27, r9
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82803DDC: 409A0044  bne cr6, 0x82803e20
	if !ctx.cr[6].eq {
	pc = 0x82803E20; continue 'dispatch;
	}
	// 82803DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803DE4: 38BB000C  addi r5, r27, 0xc
	ctx.r[5].s64 = ctx.r[27].s64 + 12;
	// 82803DE8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803DEC: 480002A5  bl 0x82804090
	ctx.lr = 0x82803DF0;
	sub_82804090(ctx, base);
	// 82803DF0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803DF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803DF8: 419A01C8  beq cr6, 0x82803fc0
	if ctx.cr[6].eq {
	pc = 0x82803FC0; continue 'dispatch;
	}
	// 82803DFC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803E00: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82803E04: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82803E08: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82803E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803E10: 480005B9  bl 0x828043c8
	ctx.lr = 0x82803E14;
	sub_828043C8(ctx, base);
	// 82803E14: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803E18: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803E1C: 484A5634  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803E20 => {
    //   block [0x82803E20..0x82803E30)
	// 82803E20: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803E24: 419A000C  beq cr6, 0x82803e30
	if ctx.cr[6].eq {
	pc = 0x82803E30; continue 'dispatch;
	}
	// 82803E28: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803E2C: 419A0008  beq cr6, 0x82803e34
	if ctx.cr[6].eq {
	pc = 0x82803E34; continue 'dispatch;
	}
	pc = 0x82803E30; continue 'dispatch;
            }
            0x82803E30 => {
    //   block [0x82803E30..0x82803E34)
	// 82803E30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803E34; continue 'dispatch;
            }
            0x82803E34 => {
    //   block [0x82803E34..0x82803E84)
	// 82803E34: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82803E38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803E3C: 409A0048  bne cr6, 0x82803e84
	if !ctx.cr[6].eq {
	pc = 0x82803E84; continue 'dispatch;
	}
	// 82803E40: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82803E44: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803E48: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82803E4C: 48000245  bl 0x82804090
	ctx.lr = 0x82803E50;
	sub_82804090(ctx, base);
	// 82803E50: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803E54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803E58: 419A0168  beq cr6, 0x82803fc0
	if ctx.cr[6].eq {
	pc = 0x82803FC0; continue 'dispatch;
	}
	// 82803E5C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803E60: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803E64: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82803E68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82803E6C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803E70: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82803E74: 48000555  bl 0x828043c8
	ctx.lr = 0x82803E78;
	sub_828043C8(ctx, base);
	// 82803E78: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803E7C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803E80: 484A55D0  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803E84 => {
    //   block [0x82803E84..0x82803F04)
	// 82803E84: 3B9B000C  addi r28, r27, 0xc
	ctx.r[28].s64 = ctx.r[27].s64 + 12;
	// 82803E88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803E8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 82803E90: 48000201  bl 0x82804090
	ctx.lr = 0x82803E94;
	sub_82804090(ctx, base);
	// 82803E94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803E9C: 419A0068  beq cr6, 0x82803f04
	if ctx.cr[6].eq {
	pc = 0x82803F04; continue 'dispatch;
	}
	// 82803EA0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82803EA4: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82803EA8: 482B0651  bl 0x82ab44f8
	ctx.lr = 0x82803EAC;
	sub_82AB44F8(ctx, base);
	// 82803EAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803EB4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803EB8: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 82803EBC: 480001D5  bl 0x82804090
	ctx.lr = 0x82803EC0;
	sub_82804090(ctx, base);
	// 82803EC0: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803EC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803EC8: 419A003C  beq cr6, 0x82803f04
	if ctx.cr[6].eq {
	pc = 0x82803F04; continue 'dispatch;
	}
	// 82803ECC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803ED0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803ED4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82803ED8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803EDC: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 82803EE0: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82803EE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803EE8: 409A00AC  bne cr6, 0x82803f94
	if !ctx.cr[6].eq {
	pc = 0x82803F94; continue 'dispatch;
	}
	// 82803EEC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82803EF0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82803EF4: 480004D5  bl 0x828043c8
	ctx.lr = 0x82803EF8;
	sub_828043C8(ctx, base);
	// 82803EF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803EFC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803F00: 484A5550  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803F04 => {
    //   block [0x82803F04..0x82803F44)
	// 82803F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803F08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803F0C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82803F10: 48000181  bl 0x82804090
	ctx.lr = 0x82803F14;
	sub_82804090(ctx, base);
	// 82803F14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803F18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803F1C: 419A00A4  beq cr6, 0x82803fc0
	if ctx.cr[6].eq {
	pc = 0x82803FC0; continue 'dispatch;
	}
	// 82803F20: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82803F24: 839F0004  lwz r28, 4(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803F28: FB410050  std r26, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u64 ) };
	// 82803F2C: 4BD5292D  bl 0x82556858
	ctx.lr = 0x82803F30;
	sub_82556858(ctx, base);
	// 82803F30: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82803F38: 419A000C  beq cr6, 0x82803f44
	if ctx.cr[6].eq {
	pc = 0x82803F44; continue 'dispatch;
	}
	// 82803F3C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82803F40: 419A0008  beq cr6, 0x82803f48
	if ctx.cr[6].eq {
	pc = 0x82803F48; continue 'dispatch;
	}
	pc = 0x82803F44; continue 'dispatch;
            }
            0x82803F44 => {
    //   block [0x82803F44..0x82803F48)
	// 82803F44: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82803F48; continue 'dispatch;
            }
            0x82803F48 => {
    //   block [0x82803F48..0x82803F74)
	// 82803F48: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803F4C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 82803F50: 419A0024  beq cr6, 0x82803f74
	if ctx.cr[6].eq {
	pc = 0x82803F74; continue 'dispatch;
	}
	// 82803F54: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803F58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82803F5C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82803F60: 38AB000C  addi r5, r11, 0xc
	ctx.r[5].s64 = ctx.r[11].s64 + 12;
	// 82803F64: 4800012D  bl 0x82804090
	ctx.lr = 0x82803F68;
	sub_82804090(ctx, base);
	// 82803F68: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82803F6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803F70: 419A0050  beq cr6, 0x82803fc0
	if ctx.cr[6].eq {
	pc = 0x82803FC0; continue 'dispatch;
	}
	pc = 0x82803F74; continue 'dispatch;
            }
            0x82803F74 => {
    //   block [0x82803F74..0x82803F94)
	// 82803F74: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 82803F78: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803F7C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 82803F80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803F84: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82803F88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82803F8C: 419A001C  beq cr6, 0x82803fa8
	if ctx.cr[6].eq {
	pc = 0x82803FA8; continue 'dispatch;
	}
	// 82803F90: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	pc = 0x82803F94; continue 'dispatch;
            }
            0x82803F94 => {
    //   block [0x82803F94..0x82803FA8)
	// 82803F94: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82803F98: 48000431  bl 0x828043c8
	ctx.lr = 0x82803F9C;
	sub_828043C8(ctx, base);
	// 82803F9C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803FA0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803FA4: 484A54AC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803FA8 => {
    //   block [0x82803FA8..0x82803FC0)
	// 82803FA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82803FAC: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82803FB0: 48000419  bl 0x828043c8
	ctx.lr = 0x82803FB4;
	sub_828043C8(ctx, base);
	// 82803FB4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803FB8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803FBC: 484A5494  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x82803FC0 => {
    //   block [0x82803FC0..0x82803FF0)
	// 82803FC0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82803FC4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 82803FC8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 82803FCC: 4800016D  bl 0x82804138
	ctx.lr = 0x82803FD0;
	sub_82804138(ctx, base);
	// 82803FD0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82803FD4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82803FD8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82803FDC: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82803FE0: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82803FE4: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82803FE8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82803FEC: 484A5464  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82803FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82803FF0 size=156
    let mut pc: u32 = 0x82803FF0;
    'dispatch: loop {
        match pc {
            0x82803FF0 => {
    //   block [0x82803FF0..0x82804028)
	// 82803FF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82803FF4: 484A540D  bl 0x82ca9400
	ctx.lr = 0x82803FF8;
	sub_82CA93D0(ctx, base);
	// 82803FF8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82803FFC: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82804000: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82804004: 3B6BBBF4  addi r27, r11, -0x440c
	ctx.r[27].s64 = ctx.r[11].s64 + -17420;
	// 82804008: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 8280400C: 83DB0004  lwz r30, 4(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804010: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804014: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804018: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280401C: 409A005C  bne cr6, 0x82804078
	if !ctx.cr[6].eq {
	pc = 0x82804078; continue 'dispatch;
	}
	// 82804020: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82804024: 3BAB9218  addi r29, r11, -0x6de8
	ctx.r[29].s64 = ctx.r[11].s64 + -28136;
	pc = 0x82804028; continue 'dispatch;
            }
            0x82804028 => {
    //   block [0x82804028..0x8280403C)
	// 82804028: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280402C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82804030: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804034: 419A0008  beq cr6, 0x8280403c
	if ctx.cr[6].eq {
	pc = 0x8280403C; continue 'dispatch;
	}
	// 82804038: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8280403C; continue 'dispatch;
            }
            0x8280403C => {
    //   block [0x8280403C..0x82804050)
	// 8280403C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82804040: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82804044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804048: 419A0008  beq cr6, 0x82804050
	if ctx.cr[6].eq {
	pc = 0x82804050; continue 'dispatch;
	}
	// 8280404C: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82804050; continue 'dispatch;
            }
            0x82804050 => {
    //   block [0x82804050..0x82804064)
	// 82804050: 484AC199  bl 0x82cb01e8
	ctx.lr = 0x82804054;
	sub_82CB01E8(ctx, base);
	// 82804054: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82804058: 4098000C  bge cr6, 0x82804064
	if !ctx.cr[6].lt {
	pc = 0x82804064; continue 'dispatch;
	}
	// 8280405C: 83FF0008  lwz r31, 8(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804060: 4800000C  b 0x8280406c
	pc = 0x8280406C; continue 'dispatch;
            }
            0x82804064 => {
    //   block [0x82804064..0x8280406C)
	// 82804064: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82804068: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8280406C; continue 'dispatch;
            }
            0x8280406C => {
    //   block [0x8280406C..0x82804078)
	// 8280406C: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804074: 419AFFB4  beq cr6, 0x82804028
	if ctx.cr[6].eq {
	pc = 0x82804028; continue 'dispatch;
	}
	pc = 0x82804078; continue 'dispatch;
            }
            0x82804078 => {
    //   block [0x82804078..0x8280408C)
	// 82804078: 93DC0004  stw r30, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 8280407C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82804080: 937C0000  stw r27, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82804084: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82804088: 484A53C8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804090 size=92
    let mut pc: u32 = 0x82804090;
    'dispatch: loop {
        match pc {
            0x82804090 => {
    //   block [0x82804090..0x828040BC)
	// 82804090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804094: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82804098: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280409C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 828040A0: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 828040A4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 828040A8: 386A9218  addi r3, r10, -0x6de8
	ctx.r[3].s64 = ctx.r[10].s64 + -28136;
	// 828040AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828040B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 828040B4: 419A0008  beq cr6, 0x828040bc
	if ctx.cr[6].eq {
	pc = 0x828040BC; continue 'dispatch;
	}
	// 828040B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828040BC; continue 'dispatch;
            }
            0x828040BC => {
    //   block [0x828040BC..0x828040CC)
	// 828040BC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 828040C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828040C4: 419A0008  beq cr6, 0x828040cc
	if ctx.cr[6].eq {
	pc = 0x828040CC; continue 'dispatch;
	}
	// 828040C8: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828040CC; continue 'dispatch;
            }
            0x828040CC => {
    //   block [0x828040CC..0x828040EC)
	// 828040CC: 484AC11D  bl 0x82cb01e8
	ctx.lr = 0x828040D0;
	sub_82CB01E8(ctx, base);
	// 828040D0: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828040D4: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828040D8: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828040DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828040E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828040E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828040E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828040F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828040F0 size=68
    let mut pc: u32 = 0x828040F0;
    'dispatch: loop {
        match pc {
            0x828040F0 => {
    //   block [0x828040F0..0x82804120)
	// 828040F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828040F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 828040F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 828040FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82804104: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82804108: 419A0018  beq cr6, 0x82804120
	if ctx.cr[6].eq {
	pc = 0x82804120; continue 'dispatch;
	}
	// 8280410C: 4BA6CB45  bl 0x82270c50
	ctx.lr = 0x82804110;
	sub_82270C50(ctx, base);
	// 82804110: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 82804114: 4B9C26E5  bl 0x821c67f8
	ctx.lr = 0x82804118;
	sub_821C67F8(ctx, base);
	// 82804118: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280411C: 4BA17C1D  bl 0x8221bd38
	ctx.lr = 0x82804120;
	sub_8221BD38(ctx, base);
	pc = 0x82804120; continue 'dispatch;
            }
            0x82804120 => {
    //   block [0x82804120..0x82804134)
	// 82804120: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82804124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82804128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8280412C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82804130: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804138(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804138 size=380
    let mut pc: u32 = 0x82804138;
    'dispatch: loop {
        match pc {
            0x82804138 => {
    //   block [0x82804138..0x8280417C)
	// 82804138: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280413C: 484A52BD  bl 0x82ca93f8
	ctx.lr = 0x82804140;
	sub_82CA93D0(ctx, base);
	// 82804140: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804144: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 82804148: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 8280414C: 3B8BBBF4  addi r28, r11, -0x440c
	ctx.r[28].s64 = ctx.r[11].s64 + -17420;
	// 82804150: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82804154: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 82804158: 7F1FC378  mr r31, r24
	ctx.r[31].u64 = ctx.r[24].u64;
	// 8280415C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804160: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	// 82804164: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804168: 895E0015  lbz r10, 0x15(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 8280416C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82804170: 409A006C  bne cr6, 0x828041dc
	if !ctx.cr[6].eq {
	pc = 0x828041DC; continue 'dispatch;
	}
	// 82804174: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82804178: 3B2B9218  addi r25, r11, -0x6de8
	ctx.r[25].s64 = ctx.r[11].s64 + -28136;
	pc = 0x8280417C; continue 'dispatch;
            }
            0x8280417C => {
    //   block [0x8280417C..0x82804194)
	// 8280417C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 82804180: 7FDBF378  mr r27, r30
	ctx.r[27].u64 = ctx.r[30].u64;
	// 82804184: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 82804188: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8280418C: 419A0008  beq cr6, 0x82804194
	if ctx.cr[6].eq {
	pc = 0x82804194; continue 'dispatch;
	}
	// 82804190: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82804194; continue 'dispatch;
            }
            0x82804194 => {
    //   block [0x82804194..0x828041A8)
	// 82804194: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804198: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8280419C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828041A0: 419A0008  beq cr6, 0x828041a8
	if ctx.cr[6].eq {
	pc = 0x828041A8; continue 'dispatch;
	}
	// 828041A4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x828041A8; continue 'dispatch;
            }
            0x828041A8 => {
    //   block [0x828041A8..0x828041C8)
	// 828041A8: 484AC041  bl 0x82cb01e8
	ctx.lr = 0x828041AC;
	sub_82CB01E8(ctx, base);
	// 828041AC: 7C6B0034  cntlzw r11, r3
	ctx.r[11].u64 = if ctx.r[3].u32 == 0 { 32 } else { ctx.r[3].u32.leading_zeros() as u64 };
	// 828041B0: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 828041B4: 555FDFFE  rlwinm r31, r10, 0x1b, 0x1f, 0x1f
	ctx.r[31].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 828041B8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 828041BC: 419A000C  beq cr6, 0x828041c8
	if ctx.cr[6].eq {
	pc = 0x828041C8; continue 'dispatch;
	}
	// 828041C0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828041C4: 48000008  b 0x828041cc
	pc = 0x828041CC; continue 'dispatch;
            }
            0x828041C8 => {
    //   block [0x828041C8..0x828041CC)
	// 828041C8: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828041CC; continue 'dispatch;
            }
            0x828041CC => {
    //   block [0x828041CC..0x828041DC)
	// 828041CC: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 828041D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828041D4: 419AFFA8  beq cr6, 0x8280417c
	if ctx.cr[6].eq {
	pc = 0x8280417C; continue 'dispatch;
	}
	// 828041D8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x828041DC; continue 'dispatch;
            }
            0x828041DC => {
    //   block [0x828041DC..0x82804238)
	// 828041DC: 57EA063E  clrlwi r10, r31, 0x18
	ctx.r[10].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 828041E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 828041E4: 93610054  stw r27, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[27].u32 ) };
	// 828041E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828041EC: 419A0050  beq cr6, 0x8280423c
	if ctx.cr[6].eq {
	pc = 0x8280423C; continue 'dispatch;
	}
	// 828041F0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828041F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828041F8: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828041FC: 409A003C  bne cr6, 0x82804238
	if !ctx.cr[6].eq {
	pc = 0x82804238; continue 'dispatch;
	}
	// 82804200: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82804204: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82804208: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8280420C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 82804210: 480001B9  bl 0x828043c8
	ctx.lr = 0x82804214;
	sub_828043C8(ctx, base);
	// 82804214: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82804218: 9B1D0008  stb r24, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[24].u8 ) };
	// 8280421C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82804220: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804224: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804228: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8280422C: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82804230: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82804234: 484A5214  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82804238 => {
    //   block [0x82804238..0x8280423C)
	// 82804238: 482B02C1  bl 0x82ab44f8
	ctx.lr = 0x8280423C;
	sub_82AB44F8(ctx, base);
	pc = 0x8280423C; continue 'dispatch;
            }
            0x8280423C => {
    //   block [0x8280423C..0x82804298)
	// 8280423C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 82804240: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82804244: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 82804248: 388B000C  addi r4, r11, 0xc
	ctx.r[4].s64 = ctx.r[11].s64 + 12;
	// 8280424C: 4BFFFE45  bl 0x82804090
	ctx.lr = 0x82804250;
	sub_82804090(ctx, base);
	// 82804250: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 82804254: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82804258: 419A0040  beq cr6, 0x82804298
	if ctx.cr[6].eq {
	pc = 0x82804298; continue 'dispatch;
	}
	// 8280425C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 82804260: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 82804264: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 82804268: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8280426C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82804270: 48000159  bl 0x828043c8
	ctx.lr = 0x82804274;
	sub_828043C8(ctx, base);
	// 82804274: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82804278: 9B1D0008  stb r24, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[24].u8 ) };
	// 8280427C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82804280: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804284: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804288: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8280428C: 913D0004  stw r9, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82804290: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82804294: 484A51B4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x82804298 => {
    //   block [0x82804298..0x828042B4)
	// 82804298: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8280429C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 828042A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 828042A4: 995D0008  stb r10, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u8 ) };
	// 828042A8: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 828042AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 828042B0: 484A5198  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828042B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828042B8 size=272
    let mut pc: u32 = 0x828042B8;
    'dispatch: loop {
        match pc {
            0x828042B8 => {
    //   block [0x828042B8..0x828042F4)
	// 828042B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828042BC: 484A5149  bl 0x82ca9404
	ctx.lr = 0x828042C0;
	sub_82CA93D0(ctx, base);
	// 828042C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828042C4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828042C8: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 828042CC: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828042D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 828042D4: 3BEBBBF4  addi r31, r11, -0x440c
	ctx.r[31].s64 = ctx.r[11].s64 + -17420;
	// 828042D8: F8C100B8  std r6, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[6].u64 ) };
	// 828042DC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828042E0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828042E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828042E8: 419A000C  beq cr6, 0x828042f4
	if ctx.cr[6].eq {
	pc = 0x828042F4; continue 'dispatch;
	}
	// 828042EC: 7F09F840  cmplw cr6, r9, r31
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[31].u32, &mut ctx.xer);
	// 828042F0: 419A0008  beq cr6, 0x828042f8
	if ctx.cr[6].eq {
	pc = 0x828042F8; continue 'dispatch;
	}
	pc = 0x828042F4; continue 'dispatch;
            }
            0x828042F4 => {
    //   block [0x828042F4..0x828042F8)
	// 828042F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x828042F8; continue 'dispatch;
            }
            0x828042F8 => {
    //   block [0x828042F8..0x8280431C)
	// 828042F8: 810100B4  lwz r8, 0xb4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 828042FC: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 82804300: 83A100B8  lwz r29, 0xb8(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 82804304: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82804308: 409A0068  bne cr6, 0x82804370
	if !ctx.cr[6].eq {
	pc = 0x82804370; continue 'dispatch;
	}
	// 8280430C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82804310: 419A000C  beq cr6, 0x8280431c
	if ctx.cr[6].eq {
	pc = 0x8280431C; continue 'dispatch;
	}
	// 82804314: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82804318: 419A0008  beq cr6, 0x82804320
	if ctx.cr[6].eq {
	pc = 0x82804320; continue 'dispatch;
	}
	pc = 0x8280431C; continue 'dispatch;
            }
            0x8280431C => {
    //   block [0x8280431C..0x82804320)
	// 8280431C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82804320; continue 'dispatch;
            }
            0x82804320 => {
    //   block [0x82804320..0x82804370)
	// 82804320: 7F1C5840  cmplw cr6, r28, r11
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804324: 409A004C  bne cr6, 0x82804370
	if !ctx.cr[6].eq {
	pc = 0x82804370; continue 'dispatch;
	}
	// 82804328: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8280432C: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804330: 48000869  bl 0x82804b98
	ctx.lr = 0x82804334;
	sub_82804B98(ctx, base);
	// 82804334: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804338: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8280433C: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82804340: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82804344: 916B0004  stw r11, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804348: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8280434C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804350: 916B0000  stw r11, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82804354: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804358: 916B0008  stw r11, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8280435C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804360: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804364: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804368: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8280436C: 484A50E8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x82804370 => {
    //   block [0x82804370..0x82804380)
	// 82804370: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804374: 419A000C  beq cr6, 0x82804380
	if ctx.cr[6].eq {
	pc = 0x82804380; continue 'dispatch;
	}
	// 82804378: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8280437C: 419A0008  beq cr6, 0x82804384
	if ctx.cr[6].eq {
	pc = 0x82804384; continue 'dispatch;
	}
	pc = 0x82804380; continue 'dispatch;
            }
            0x82804380 => {
    //   block [0x82804380..0x82804384)
	// 82804380: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate  TODO: implement trap semantics
	pc = 0x82804384; continue 'dispatch;
            }
            0x82804384 => {
    //   block [0x82804384..0x828043B8)
	// 82804384: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 82804388: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8280438C: 419A002C  beq cr6, 0x828043b8
	if ctx.cr[6].eq {
	pc = 0x828043B8; continue 'dispatch;
	}
	// 82804390: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82804394: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 82804398: 4BD524C1  bl 0x82556858
	ctx.lr = 0x8280439C;
	sub_82556858(ctx, base);
	// 8280439C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828043A0: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 828043A4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828043A8: 48000299  bl 0x82804640
	ctx.lr = 0x828043AC;
	sub_82804640(ctx, base);
	// 828043AC: E8A100B0  ld r5, 0xb0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 828043B0: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 828043B4: 4BFFFFBC  b 0x82804370
	pc = 0x82804370; continue 'dispatch;
            }
            0x828043B8 => {
    //   block [0x828043B8..0x828043C8)
	// 828043B8: F8BE0000  std r5, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[5].u64 ) };
	// 828043BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828043C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 828043C4: 484A5090  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828043C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828043C8 size=632
    let mut pc: u32 = 0x828043C8;
    'dispatch: loop {
        match pc {
            0x828043C8 => {
    //   block [0x828043C8..0x82804444)
	// 828043C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828043CC: 484A502D  bl 0x82ca93f8
	ctx.lr = 0x828043D0;
	sub_82CA93D0(ctx, base);
	// 828043D0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828043D4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 828043D8: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 828043DC: 3BCBBBF4  addi r30, r11, -0x440c
	ctx.r[30].s64 = ctx.r[11].s64 + -17420;
	// 828043E0: 6149FFFE  ori r9, r10, 0xfffe
	ctx.r[9].u64 = ctx.r[10].u64 | 65534;
	// 828043E4: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 828043E8: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 828043EC: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 828043F0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 828043F4: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 828043F8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 828043FC: 41980048  blt cr6, 0x82804444
	if ctx.cr[6].lt {
	pc = 0x82804444; continue 'dispatch;
	}
	// 82804400: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82804404: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82804408: 388B1690  addi r4, r11, 0x1690
	ctx.r[4].s64 = ctx.r[11].s64 + 5776;
	// 8280440C: 4BAEDB35  bl 0x822f1f40
	ctx.lr = 0x82804410;
	sub_822F1F40(ctx, base);
	// 82804410: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82804414: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82804418: 4BAED999  bl 0x822f1db0
	ctx.lr = 0x8280441C;
	sub_822F1DB0(ctx, base);
	// 8280441C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82804420: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82804424: 3BAA1720  addi r29, r10, 0x1720
	ctx.r[29].s64 = ctx.r[10].s64 + 5920;
	// 82804428: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 8280442C: 4BAED9F5  bl 0x822f1e20
	ctx.lr = 0x82804430;
	sub_822F1E20(ctx, base);
	// 82804430: 93A10070  stw r29, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u32 ) };
	// 82804434: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82804438: 4BE773A9  bl 0x8267b7e0
	ctx.lr = 0x8280443C;
	sub_8267B7E0(ctx, base);
	// 8280443C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82804440: 4B96D3D1  bl 0x82171810
	ctx.lr = 0x82804444;
	sub_82171810(ctx, base);
	pc = 0x82804444; continue 'dispatch;
            }
            0x82804444 => {
    //   block [0x82804444..0x82804488)
	// 82804444: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 82804448: 83BE0004  lwz r29, 4(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280444C: 4BA1AE0D  bl 0x8221f258
	ctx.lr = 0x82804450;
	sub_8221F258(ctx, base);
	// 82804450: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82804454: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 82804458: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8280445C: 419A002C  beq cr6, 0x82804488
	if ctx.cr[6].eq {
	pc = 0x82804488; continue 'dispatch;
	}
	// 82804460: 93BC0000  stw r29, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 82804464: 387C000C  addi r3, r28, 0xc
	ctx.r[3].s64 = ctx.r[28].s64 + 12;
	// 82804468: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8280446C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 82804470: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 82804474: 4BA837B5  bl 0x82287c28
	ctx.lr = 0x82804478;
	sub_82287C28(ctx, base);
	// 82804478: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280447C: 917C0010  stw r11, 0x10(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82804480: 9B3C0014  stb r25, 0x14(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82804484: 9B3C0015  stb r25, 0x15(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(21 as u32), ctx.r[25].u8 ) };
	pc = 0x82804488; continue 'dispatch;
            }
            0x82804488 => {
    //   block [0x82804488..0x828044B4)
	// 82804488: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280448C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804490: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82804494: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804498: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8280449C: 409A0018  bne cr6, 0x828044b4
	if !ctx.cr[6].eq {
	pc = 0x828044B4; continue 'dispatch;
	}
	// 828044A0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 828044A4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828044A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828044AC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828044B0: 48000044  b 0x828044f4
	pc = 0x828044F4; continue 'dispatch;
            }
            0x828044B4 => {
    //   block [0x828044B4..0x828044E0)
	// 828044B4: 574B063E  clrlwi r11, r26, 0x18
	ctx.r[11].u64 = ctx.r[26].u32 as u64 & 0x000000FFu64;
	// 828044B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828044BC: 419A0024  beq cr6, 0x828044e0
	if ctx.cr[6].eq {
	pc = 0x828044E0; continue 'dispatch;
	}
	// 828044C0: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828044C4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828044C8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828044CC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828044D0: 409A0028  bne cr6, 0x828044f8
	if !ctx.cr[6].eq {
	pc = 0x828044F8; continue 'dispatch;
	}
	// 828044D4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828044D8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 828044DC: 4800001C  b 0x828044f8
	pc = 0x828044F8; continue 'dispatch;
            }
            0x828044E0 => {
    //   block [0x828044E0..0x828044F4)
	// 828044E0: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 828044E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828044E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828044EC: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828044F0: 409A0008  bne cr6, 0x828044f8
	if !ctx.cr[6].eq {
	pc = 0x828044F8; continue 'dispatch;
	}
	pc = 0x828044F4; continue 'dispatch;
            }
            0x828044F4 => {
    //   block [0x828044F4..0x828044F8)
	// 828044F4: 938B0008  stw r28, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	pc = 0x828044F8; continue 'dispatch;
            }
            0x828044F8 => {
    //   block [0x828044F8..0x82804514)
	// 828044F8: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828044FC: 397C0004  addi r11, r28, 4
	ctx.r[11].s64 = ctx.r[28].s64 + 4;
	// 82804500: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82804504: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 82804508: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280450C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804510: 409A0110  bne cr6, 0x82804620
	if !ctx.cr[6].eq {
	pc = 0x82804620; continue 'dispatch;
	}
	pc = 0x82804514; continue 'dispatch;
            }
            0x82804514 => {
    //   block [0x82804514..0x8280455C)
	// 82804514: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804518: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280451C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804520: 7F044840  cmplw cr6, r4, r9
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82804524: 409A0078  bne cr6, 0x8280459c
	if !ctx.cr[6].eq {
	pc = 0x8280459C; continue 'dispatch;
	}
	// 82804528: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280452C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804530: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804534: 409A0028  bne cr6, 0x8280455c
	if !ctx.cr[6].eq {
	pc = 0x8280455C; continue 'dispatch;
	}
	// 82804538: 5489003E  slwi r9, r4, 0
	ctx.r[9].u32 = ctx.r[4].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8280453C: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804540: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804544: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804548: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280454C: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82804550: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804554: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804558: 480000B4  b 0x8280460c
	pc = 0x8280460C; continue 'dispatch;
            }
            0x8280455C => {
    //   block [0x8280455C..0x82804574)
	// 8280455C: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804560: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804564: 409A0010  bne cr6, 0x82804574
	if !ctx.cr[6].eq {
	pc = 0x82804574; continue 'dispatch;
	}
	// 82804568: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280456C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82804570: 48000529  bl 0x82804a98
	ctx.lr = 0x82804574;
	sub_82804A98(ctx, base);
	pc = 0x82804574; continue 'dispatch;
            }
            0x82804574 => {
    //   block [0x82804574..0x8280459C)
	// 82804574: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804578: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8280457C: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804580: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804584: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804588: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 8280458C: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804590: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804594: 48000585  bl 0x82804b18
	ctx.lr = 0x82804598;
	sub_82804B18(ctx, base);
	// 82804598: 48000074  b 0x8280460c
	pc = 0x8280460C; continue 'dispatch;
            }
            0x8280459C => {
    //   block [0x8280459C..0x828045D0)
	// 8280459C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 828045A0: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828045A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828045A8: 409A0028  bne cr6, 0x828045d0
	if !ctx.cr[6].eq {
	pc = 0x828045D0; continue 'dispatch;
	}
	// 828045AC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828045B0: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 828045B4: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 828045B8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828045BC: 80E80004  lwz r7, 4(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 828045C0: 9B270014  stb r25, 0x14(r7)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[7].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 828045C4: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828045C8: 83E60004  lwz r31, 4(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 828045CC: 48000040  b 0x8280460c
	pc = 0x8280460C; continue 'dispatch;
            }
            0x828045D0 => {
    //   block [0x828045D0..0x828045E8)
	// 828045D0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828045D4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828045D8: 409A0010  bne cr6, 0x828045e8
	if !ctx.cr[6].eq {
	pc = 0x828045E8; continue 'dispatch;
	}
	// 828045DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828045E0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 828045E4: 48000535  bl 0x82804b18
	ctx.lr = 0x828045E8;
	sub_82804B18(ctx, base);
	pc = 0x828045E8; continue 'dispatch;
            }
            0x828045E8 => {
    //   block [0x828045E8..0x8280460C)
	// 828045E8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828045EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828045F0: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 828045F4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828045F8: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 828045FC: 9B290014  stb r25, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[25].u8 ) };
	// 82804600: 811F0004  lwz r8, 4(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804604: 80880004  lwz r4, 4(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804608: 48000491  bl 0x82804a98
	ctx.lr = 0x8280460C;
	sub_82804A98(ctx, base);
	pc = 0x8280460C; continue 'dispatch;
            }
            0x8280460C => {
    //   block [0x8280460C..0x82804620)
	// 8280460C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804610: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82804614: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804618: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8280461C: 419AFEF8  beq cr6, 0x82804514
	if ctx.cr[6].eq {
	pc = 0x82804514; continue 'dispatch;
	}
	pc = 0x82804620; continue 'dispatch;
            }
            0x82804620 => {
    //   block [0x82804620..0x82804640)
	// 82804620: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804624: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 82804628: 93980004  stw r28, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 8280462C: 93D80000  stw r30, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82804630: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804634: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804638: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8280463C: 484A4E0C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804640 size=1112
    let mut pc: u32 = 0x82804640;
    'dispatch: loop {
        match pc {
            0x82804640 => {
    //   block [0x82804640..0x828046A8)
	// 82804640: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804644: 484A4DB9  bl 0x82ca93fc
	ctx.lr = 0x82804648;
	sub_82CA93D0(ctx, base);
	// 82804648: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280464C: F8A10100  std r5, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[5].u64 ) };
	// 82804650: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 82804654: 83E10104  lwz r31, 0x104(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 82804658: 897F0015  lbz r11, 0x15(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 8280465C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804660: 419A0048  beq cr6, 0x828046a8
	if ctx.cr[6].eq {
	pc = 0x828046A8; continue 'dispatch;
	}
	// 82804664: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82804668: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8280466C: 388B16C0  addi r4, r11, 0x16c0
	ctx.r[4].s64 = ctx.r[11].s64 + 5824;
	// 82804670: 4BAED8D1  bl 0x822f1f40
	ctx.lr = 0x82804674;
	sub_822F1F40(ctx, base);
	// 82804674: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82804678: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8280467C: 4BAED735  bl 0x822f1db0
	ctx.lr = 0x82804680;
	sub_822F1DB0(ctx, base);
	// 82804680: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82804684: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82804688: 3BCA1720  addi r30, r10, 0x1720
	ctx.r[30].s64 = ctx.r[10].s64 + 5920;
	// 8280468C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82804690: 4BAED791  bl 0x822f1e20
	ctx.lr = 0x82804694;
	sub_822F1E20(ctx, base);
	// 82804694: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 82804698: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8280469C: 4BE77145  bl 0x8267b7e0
	ctx.lr = 0x828046A0;
	sub_8267B7E0(ctx, base);
	// 828046A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828046A4: 4B96D16D  bl 0x82171810
	ctx.lr = 0x828046A8;
	sub_82171810(ctx, base);
	pc = 0x828046A8; continue 'dispatch;
            }
            0x828046A8 => {
    //   block [0x828046A8..0x828046CC)
	// 828046A8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 828046AC: 7FFAFB78  mr r26, r31
	ctx.r[26].u64 = ctx.r[31].u64;
	// 828046B0: 4BD521A9  bl 0x82556858
	ctx.lr = 0x828046B4;
	sub_82556858(ctx, base);
	// 828046B4: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828046B8: 896A0015  lbz r11, 0x15(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 828046BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828046C0: 419A000C  beq cr6, 0x828046cc
	if ctx.cr[6].eq {
	pc = 0x828046CC; continue 'dispatch;
	}
	// 828046C4: 837A0008  lwz r27, 8(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828046C8: 4800002C  b 0x828046f4
	pc = 0x828046F4; continue 'dispatch;
            }
            0x828046CC => {
    //   block [0x828046CC..0x828046E4)
	// 828046CC: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828046D0: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828046D4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828046D8: 419A000C  beq cr6, 0x828046e4
	if ctx.cr[6].eq {
	pc = 0x828046E4; continue 'dispatch;
	}
	// 828046DC: 7D5B5378  mr r27, r10
	ctx.r[27].u64 = ctx.r[10].u64;
	// 828046E0: 48000014  b 0x828046f4
	pc = 0x828046F4; continue 'dispatch;
            }
            0x828046E4 => {
    //   block [0x828046E4..0x828046F4)
	// 828046E4: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 828046E8: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828046EC: 836B0008  lwz r27, 8(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828046F0: 409A00FC  bne cr6, 0x828047ec
	if !ctx.cr[6].eq {
	pc = 0x828047EC; continue 'dispatch;
	}
	pc = 0x828046F4; continue 'dispatch;
            }
            0x828046F4 => {
    //   block [0x828046F4..0x82804708)
	// 828046F4: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 828046F8: 83FA0004  lwz r31, 4(r26)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 828046FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804700: 409A0008  bne cr6, 0x82804708
	if !ctx.cr[6].eq {
	pc = 0x82804708; continue 'dispatch;
	}
	// 82804704: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82804708; continue 'dispatch;
            }
            0x82804708 => {
    //   block [0x82804708..0x82804728)
	// 82804708: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 8280470C: 3B8BBBF4  addi r28, r11, -0x440c
	ctx.r[28].s64 = ctx.r[11].s64 + -17420;
	// 82804710: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804714: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804718: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8280471C: 409A000C  bne cr6, 0x82804728
	if !ctx.cr[6].eq {
	pc = 0x82804728; continue 'dispatch;
	}
	// 82804720: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82804724: 4800001C  b 0x82804740
	pc = 0x82804740; continue 'dispatch;
            }
            0x82804728 => {
    //   block [0x82804728..0x8280473C)
	// 82804728: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280472C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82804730: 409A000C  bne cr6, 0x8280473c
	if !ctx.cr[6].eq {
	pc = 0x8280473C; continue 'dispatch;
	}
	// 82804734: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82804738: 48000008  b 0x82804740
	pc = 0x82804740; continue 'dispatch;
            }
            0x8280473C => {
    //   block [0x8280473C..0x82804740)
	// 8280473C: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x82804740; continue 'dispatch;
            }
            0x82804740 => {
    //   block [0x82804740..0x82804764)
	// 82804740: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804744: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804748: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 8280474C: 409A0048  bne cr6, 0x82804794
	if !ctx.cr[6].eq {
	pc = 0x82804794; continue 'dispatch;
	}
	// 82804750: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804758: 419A000C  beq cr6, 0x82804764
	if ctx.cr[6].eq {
	pc = 0x82804764; continue 'dispatch;
	}
	// 8280475C: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 82804760: 4800002C  b 0x8280478c
	pc = 0x8280478C; continue 'dispatch;
            }
            0x82804764 => {
    //   block [0x82804764..0x82804778)
	// 82804764: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804768: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 8280476C: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804770: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804774: 409A0018  bne cr6, 0x8280478c
	if !ctx.cr[6].eq {
	pc = 0x8280478C; continue 'dispatch;
	}
	pc = 0x82804778; continue 'dispatch;
            }
            0x82804778 => {
    //   block [0x82804778..0x8280478C)
	// 82804778: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8280477C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804780: 892B0015  lbz r9, 0x15(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804784: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804788: 419AFFF0  beq cr6, 0x82804778
	if ctx.cr[6].eq {
	pc = 0x82804778; continue 'dispatch;
	}
	pc = 0x8280478C; continue 'dispatch;
            }
            0x8280478C => {
    //   block [0x8280478C..0x82804794)
	// 8280478C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804790: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x82804794; continue 'dispatch;
            }
            0x82804794 => {
    //   block [0x82804794..0x828047BC)
	// 82804794: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804798: 81690008  lwz r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280479C: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 828047A0: 409A00E8  bne cr6, 0x82804888
	if !ctx.cr[6].eq {
	pc = 0x82804888; continue 'dispatch;
	}
	// 828047A4: 897B0015  lbz r11, 0x15(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 828047A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828047AC: 419A0010  beq cr6, 0x828047bc
	if ctx.cr[6].eq {
	pc = 0x828047BC; continue 'dispatch;
	}
	// 828047B0: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	// 828047B4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828047B8: 480000D0  b 0x82804888
	pc = 0x82804888; continue 'dispatch;
            }
            0x828047BC => {
    //   block [0x828047BC..0x828047D0)
	// 828047BC: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 828047C0: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 828047C4: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828047C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828047CC: 409A0018  bne cr6, 0x828047e4
	if !ctx.cr[6].eq {
	pc = 0x828047E4; continue 'dispatch;
	}
	pc = 0x828047D0; continue 'dispatch;
            }
            0x828047D0 => {
    //   block [0x828047D0..0x828047E4)
	// 828047D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 828047D4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828047D8: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828047DC: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 828047E0: 419AFFF0  beq cr6, 0x828047d0
	if ctx.cr[6].eq {
	pc = 0x828047D0; continue 'dispatch;
	}
	pc = 0x828047E4; continue 'dispatch;
            }
            0x828047E4 => {
    //   block [0x828047E4..0x828047EC)
	// 828047E4: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 828047E8: 480000A0  b 0x82804888
	pc = 0x82804888; continue 'dispatch;
            }
            0x828047EC => {
    //   block [0x828047EC..0x8280480C)
	// 828047EC: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 828047F0: 815A0000  lwz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 828047F4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 828047F8: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 828047FC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 82804800: 409A000C  bne cr6, 0x8280480c
	if !ctx.cr[6].eq {
	pc = 0x8280480C; continue 'dispatch;
	}
	// 82804804: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 82804808: 4800002C  b 0x82804834
	pc = 0x82804834; continue 'dispatch;
            }
            0x8280480C => {
    //   block [0x8280480C..0x82804820)
	// 8280480C: 895B0015  lbz r10, 0x15(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804810: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82804818: 409A0008  bne cr6, 0x82804820
	if !ctx.cr[6].eq {
	pc = 0x82804820; continue 'dispatch;
	}
	// 8280481C: 93FB0004  stw r31, 4(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	pc = 0x82804820; continue 'dispatch;
            }
            0x82804820 => {
    //   block [0x82804820..0x82804834)
	// 82804820: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82804824: 815A0008  lwz r10, 8(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804828: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 8280482C: 813A0008  lwz r9, 8(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804830: 91690004  stw r11, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x82804834; continue 'dispatch;
            }
            0x82804834 => {
    //   block [0x82804834..0x82804854)
	// 82804834: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82804838: 3B8ABBF4  addi r28, r10, -0x440c
	ctx.r[28].s64 = ctx.r[10].s64 + -17420;
	// 8280483C: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804840: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804844: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82804848: 409A000C  bne cr6, 0x82804854
	if !ctx.cr[6].eq {
	pc = 0x82804854; continue 'dispatch;
	}
	// 8280484C: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804850: 48000020  b 0x82804870
	pc = 0x82804870; continue 'dispatch;
            }
            0x82804854 => {
    //   block [0x82804854..0x8280486C)
	// 82804854: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804858: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280485C: 7F09D040  cmplw cr6, r9, r26
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[26].u32, &mut ctx.xer);
	// 82804860: 409A000C  bne cr6, 0x8280486c
	if !ctx.cr[6].eq {
	pc = 0x8280486C; continue 'dispatch;
	}
	// 82804864: 916A0000  stw r11, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82804868: 48000008  b 0x82804870
	pc = 0x82804870; continue 'dispatch;
            }
            0x8280486C => {
    //   block [0x8280486C..0x82804870)
	// 8280486C: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x82804870; continue 'dispatch;
            }
            0x82804870 => {
    //   block [0x82804870..0x82804888)
	// 82804870: 815A0004  lwz r10, 4(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804874: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82804878: 893A0014  lbz r9, 0x14(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280487C: 890B0014  lbz r8, 0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804880: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 82804884: 991A0014  stb r8, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	pc = 0x82804888; continue 'dispatch;
            }
            0x82804888 => {
    //   block [0x82804888..0x828048AC)
	// 82804888: 897A0014  lbz r11, 0x14(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280488C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82804890: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 82804894: 409A0194  bne cr6, 0x82804a28
	if !ctx.cr[6].eq {
	pc = 0x82804A28; continue 'dispatch;
	}
	// 82804898: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8280489C: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 828048A0: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828048A4: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828048A8: 419A017C  beq cr6, 0x82804a24
	if ctx.cr[6].eq {
	pc = 0x82804A24; continue 'dispatch;
	}
	pc = 0x828048AC; continue 'dispatch;
            }
            0x828048AC => {
    //   block [0x828048AC..0x828048EC)
	// 828048AC: 897B0014  lbz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 828048B0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 828048B4: 409A0170  bne cr6, 0x82804a24
	if !ctx.cr[6].eq {
	pc = 0x82804A24; continue 'dispatch;
	}
	// 828048B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 828048BC: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 828048C0: 409A00A8  bne cr6, 0x82804968
	if !ctx.cr[6].eq {
	pc = 0x82804968; continue 'dispatch;
	}
	// 828048C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 828048C8: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 828048CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828048D0: 409A001C  bne cr6, 0x828048ec
	if !ctx.cr[6].eq {
	pc = 0x828048EC; continue 'dispatch;
	}
	// 828048D4: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 828048D8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828048DC: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 828048E0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 828048E4: 480001B5  bl 0x82804a98
	ctx.lr = 0x828048E8;
	sub_82804A98(ctx, base);
	// 828048E8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x828048EC; continue 'dispatch;
            }
            0x828048EC => {
    //   block [0x828048EC..0x82804918)
	// 828048EC: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 828048F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 828048F4: 409A00C8  bne cr6, 0x828049bc
	if !ctx.cr[6].eq {
	pc = 0x828049BC; continue 'dispatch;
	}
	// 828048F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828048FC: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804900: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82804904: 409A0014  bne cr6, 0x82804918
	if !ctx.cr[6].eq {
	pc = 0x82804918; continue 'dispatch;
	}
	// 82804908: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280490C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804910: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82804914: 419A00A4  beq cr6, 0x828049b8
	if ctx.cr[6].eq {
	pc = 0x828049B8; continue 'dispatch;
	}
	pc = 0x82804918; continue 'dispatch;
            }
            0x82804918 => {
    //   block [0x82804918..0x82804944)
	// 82804918: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280491C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804920: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 82804924: 409A0020  bne cr6, 0x82804944
	if !ctx.cr[6].eq {
	pc = 0x82804944; continue 'dispatch;
	}
	// 82804928: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8280492C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82804930: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 82804934: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804938: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 8280493C: 480001DD  bl 0x82804b18
	ctx.lr = 0x82804940;
	sub_82804B18(ctx, base);
	// 82804940: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	pc = 0x82804944; continue 'dispatch;
            }
            0x82804944 => {
    //   block [0x82804944..0x82804968)
	// 82804944: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804948: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280494C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82804950: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82804954: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804958: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280495C: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804960: 48000139  bl 0x82804a98
	ctx.lr = 0x82804964;
	sub_82804A98(ctx, base);
	// 82804964: 480000C0  b 0x82804a24
	pc = 0x82804A24; continue 'dispatch;
            }
            0x82804968 => {
    //   block [0x82804968..0x8280498C)
	// 82804968: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280496C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82804970: 409A001C  bne cr6, 0x8280498c
	if !ctx.cr[6].eq {
	pc = 0x8280498C; continue 'dispatch;
	}
	// 82804974: 9BAB0014  stb r29, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804978: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280497C: 9BDF0014  stb r30, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 82804980: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82804984: 48000195  bl 0x82804b18
	ctx.lr = 0x82804988;
	sub_82804B18(ctx, base);
	// 82804988: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8280498C; continue 'dispatch;
            }
            0x8280498C => {
    //   block [0x8280498C..0x828049B8)
	// 8280498C: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804990: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82804994: 409A0028  bne cr6, 0x828049bc
	if !ctx.cr[6].eq {
	pc = 0x828049BC; continue 'dispatch;
	}
	// 82804998: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8280499C: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828049A0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828049A4: 409A0034  bne cr6, 0x828049d8
	if !ctx.cr[6].eq {
	pc = 0x828049D8; continue 'dispatch;
	}
	// 828049A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828049AC: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828049B0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828049B4: 409A0024  bne cr6, 0x828049d8
	if !ctx.cr[6].eq {
	pc = 0x828049D8; continue 'dispatch;
	}
	pc = 0x828049B8; continue 'dispatch;
            }
            0x828049B8 => {
    //   block [0x828049B8..0x828049BC)
	// 828049B8: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	pc = 0x828049BC; continue 'dispatch;
            }
            0x828049BC => {
    //   block [0x828049BC..0x828049D8)
	// 828049BC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 828049C0: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 828049C4: 83FF0004  lwz r31, 4(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 828049C8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828049CC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 828049D0: 409AFEDC  bne cr6, 0x828048ac
	if !ctx.cr[6].eq {
	pc = 0x828048AC; continue 'dispatch;
	}
	// 828049D4: 48000050  b 0x82804a24
	pc = 0x82804A24; continue 'dispatch;
            }
            0x828049D8 => {
    //   block [0x828049D8..0x82804A04)
	// 828049D8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 828049DC: 892A0014  lbz r9, 0x14(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 828049E0: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 828049E4: 409A0020  bne cr6, 0x82804a04
	if !ctx.cr[6].eq {
	pc = 0x82804A04; continue 'dispatch;
	}
	// 828049E8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828049EC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 828049F0: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 828049F4: 9BAA0014  stb r29, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 828049F8: 9BCB0014  stb r30, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[30].u8 ) };
	// 828049FC: 4800009D  bl 0x82804a98
	ctx.lr = 0x82804A00;
	sub_82804A98(ctx, base);
	// 82804A00: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x82804A04; continue 'dispatch;
            }
            0x82804A04 => {
    //   block [0x82804A04..0x82804A24)
	// 82804A04: 895F0014  lbz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804A08: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82804A0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82804A10: 994B0014  stb r10, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 82804A14: 9BBF0014  stb r29, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804A18: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804A1C: 9BA90014  stb r29, 0x14(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	// 82804A20: 480000F9  bl 0x82804b18
	ctx.lr = 0x82804A24;
	sub_82804B18(ctx, base);
	pc = 0x82804A24; continue 'dispatch;
            }
            0x82804A24 => {
    //   block [0x82804A24..0x82804A28)
	// 82804A24: 9BBB0014  stb r29, 0x14(r27)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[29].u8 ) };
	pc = 0x82804A28; continue 'dispatch;
            }
            0x82804A28 => {
    //   block [0x82804A28..0x82804A38)
	// 82804A28: 387A000C  addi r3, r26, 0xc
	ctx.r[3].s64 = ctx.r[26].s64 + 12;
	// 82804A2C: 4B9C1D3D  bl 0x821c6768
	ctx.lr = 0x82804A30;
	sub_821C6768(ctx, base);
	// 82804A30: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82804A34: 390B708C  addi r8, r11, 0x708c
	ctx.r[8].s64 = ctx.r[11].s64 + 28812;
	pc = 0x82804A38; continue 'dispatch;
            }
            0x82804A38 => {
    //   block [0x82804A38..0x82804A88)
	// 82804A38: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 82804A3C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82804A40: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 82804A44: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 82804A48: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82804A4C: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82804A50: 4082FFE8  bne 0x82804a38
	if !ctx.cr[0].eq {
	pc = 0x82804A38; continue 'dispatch;
	}
	// 82804A54: 93DA000C  stw r30, 0xc(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82804A58: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82804A5C: 4BA172DD  bl 0x8221bd38
	ctx.lr = 0x82804A60;
	sub_8221BD38(ctx, base);
	// 82804A60: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804A64: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 82804A68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804A6C: 419A001C  beq cr6, 0x82804a88
	if ctx.cr[6].eq {
	pc = 0x82804A88; continue 'dispatch;
	}
	// 82804A70: E9410100  ld r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82804A74: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82804A78: 917C0008  stw r11, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82804A7C: F9590000  std r10, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82804A80: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82804A84: 484A49C8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x82804A88 => {
    //   block [0x82804A88..0x82804A98)
	// 82804A88: E9610100  ld r11, 0x100(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	// 82804A8C: F9790000  std r11, 0(r25)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82804A90: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 82804A94: 484A49B8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82804A98 size=80
    let mut pc: u32 = 0x82804A98;
    'dispatch: loop {
        match pc {
            0x82804A98 => {
    //   block [0x82804A98..0x82804AB8)
	// 82804A98: 81640008  lwz r11, 8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804A9C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804AA0: 91440008  stw r10, 8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 82804AA4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804AA8: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804AAC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804AB0: 409A0008  bne cr6, 0x82804ab8
	if !ctx.cr[6].eq {
	pc = 0x82804AB8; continue 'dispatch;
	}
	// 82804AB4: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82804AB8; continue 'dispatch;
            }
            0x82804AB8 => {
    //   block [0x82804AB8..0x82804AE8)
	// 82804AB8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82804ABC: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804AC0: 390ABBF4  addi r8, r10, -0x440c
	ctx.r[8].s64 = ctx.r[10].s64 + -17420;
	// 82804AC4: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82804AC8: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804ACC: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804AD0: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82804AD4: 409A0014  bne cr6, 0x82804ae8
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82804AE8);
		return;
	}
	// 82804AD8: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804ADC: 908B0000  stw r4, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 82804AE0: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804AE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82804B18 size=80
    let mut pc: u32 = 0x82804B18;
    'dispatch: loop {
        match pc {
            0x82804B18 => {
    //   block [0x82804B18..0x82804B38)
	// 82804B18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804B1C: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804B20: 91440000  stw r10, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82804B24: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804B28: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804B2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804B30: 409A0008  bne cr6, 0x82804b38
	if !ctx.cr[6].eq {
	pc = 0x82804B38; continue 'dispatch;
	}
	// 82804B34: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	pc = 0x82804B38; continue 'dispatch;
            }
            0x82804B38 => {
    //   block [0x82804B38..0x82804B68)
	// 82804B38: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 82804B3C: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804B40: 390ABBF4  addi r8, r10, -0x440c
	ctx.r[8].s64 = ctx.r[10].s64 + -17420;
	// 82804B44: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82804B48: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804B4C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804B50: 7F043840  cmplw cr6, r4, r7
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82804B54: 409A0014  bne cr6, 0x82804b68
	if !ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82804B68);
		return;
	}
	// 82804B58: 916A0004  stw r11, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804B5C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 82804B60: 91640004  stw r11, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804B64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804B98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804B98 size=140
    let mut pc: u32 = 0x82804B98;
    'dispatch: loop {
        match pc {
            0x82804B98 => {
    //   block [0x82804B98..0x82804BC8)
	// 82804B98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804B9C: 484A4869  bl 0x82ca9404
	ctx.lr = 0x82804BA0;
	sub_82CA93D0(ctx, base);
	// 82804BA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804BA4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82804BA8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82804BAC: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 82804BB0: 897E0015  lbz r11, 0x15(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804BB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804BB8: 409A0064  bne cr6, 0x82804c1c
	if !ctx.cr[6].eq {
	pc = 0x82804C1C; continue 'dispatch;
	}
	// 82804BBC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82804BC0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 82804BC4: 3BAB708C  addi r29, r11, 0x708c
	ctx.r[29].s64 = ctx.r[11].s64 + 28812;
	pc = 0x82804BC8; continue 'dispatch;
            }
            0x82804BC8 => {
    //   block [0x82804BC8..0x82804BE4)
	// 82804BC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 82804BCC: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804BD0: 4BFFFFC9  bl 0x82804b98
	ctx.lr = 0x82804BD4;
	sub_82804B98(ctx, base);
	// 82804BD4: 387E000C  addi r3, r30, 0xc
	ctx.r[3].s64 = ctx.r[30].s64 + 12;
	// 82804BD8: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804BDC: 4B9C1B8D  bl 0x821c6768
	ctx.lr = 0x82804BE0;
	sub_821C6768(ctx, base);
	// 82804BE0: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	pc = 0x82804BE4; continue 'dispatch;
            }
            0x82804BE4 => {
    //   block [0x82804BE4..0x82804C1C)
	// 82804BE4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 82804BE8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82804BEC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 82804BF0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82804BF4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 82804BF8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 82804BFC: 4082FFE8  bne 0x82804be4
	if !ctx.cr[0].eq {
	pc = 0x82804BE4; continue 'dispatch;
	}
	// 82804C00: 937E000C  stw r27, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 82804C04: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82804C08: 4BA17131  bl 0x8221bd38
	ctx.lr = 0x82804C0C;
	sub_8221BD38(ctx, base);
	// 82804C0C: 891F0015  lbz r8, 0x15(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 82804C10: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 82804C14: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82804C18: 419AFFB0  beq cr6, 0x82804bc8
	if ctx.cr[6].eq {
	pc = 0x82804BC8; continue 'dispatch;
	}
	pc = 0x82804C1C; continue 'dispatch;
            }
            0x82804C1C => {
    //   block [0x82804C1C..0x82804C24)
	// 82804C1C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82804C20: 484A4834  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804C28 size=148
    let mut pc: u32 = 0x82804C28;
    'dispatch: loop {
        match pc {
            0x82804C28 => {
    //   block [0x82804C28..0x82804C5C)
	// 82804C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82804C30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82804C34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804C38: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 82804C3C: 4BAA5025  bl 0x822a9c60
	ctx.lr = 0x82804C40;
	sub_822A9C60(ctx, base);
	// 82804C40: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82804C44: 419A0064  beq cr6, 0x82804ca8
	if ctx.cr[6].eq {
	pc = 0x82804CA8; continue 'dispatch;
	}
	// 82804C48: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804C4C: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804C50: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804C54: 419A0054  beq cr6, 0x82804ca8
	if ctx.cr[6].eq {
	pc = 0x82804CA8; continue 'dispatch;
	}
	// 82804C58: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82804C5C; continue 'dispatch;
            }
            0x82804C5C => {
    //   block [0x82804C5C..0x82804C98)
	// 82804C5C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804C60: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804C64: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804C68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804C6C: 419A002C  beq cr6, 0x82804c98
	if ctx.cr[6].eq {
	pc = 0x82804C98; continue 'dispatch;
	}
	// 82804C70: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804C74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804C78: 419A0020  beq cr6, 0x82804c98
	if ctx.cr[6].eq {
	pc = 0x82804C98; continue 'dispatch;
	}
	// 82804C7C: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804C80: 80EB0200  lwz r7, 0x200(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(512 as u32) ) } as u64;
	// 82804C84: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82804C88: 419A0010  beq cr6, 0x82804c98
	if ctx.cr[6].eq {
	pc = 0x82804C98; continue 'dispatch;
	}
	// 82804C8C: 992B0224  stb r9, 0x224(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(548 as u32), ctx.r[9].u8 ) };
	// 82804C90: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804C94: 910B0200  stw r8, 0x200(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(512 as u32), ctx.r[8].u32 ) };
	pc = 0x82804C98; continue 'dispatch;
            }
            0x82804C98 => {
    //   block [0x82804C98..0x82804CA8)
	// 82804C98: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804C9C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82804CA0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804CA4: 409AFFB8  bne cr6, 0x82804c5c
	if !ctx.cr[6].eq {
	pc = 0x82804C5C; continue 'dispatch;
	}
	pc = 0x82804CA8; continue 'dispatch;
            }
            0x82804CA8 => {
    //   block [0x82804CA8..0x82804CBC)
	// 82804CA8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82804CAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82804CB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82804CB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82804CB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82804CC0 size=188
    let mut pc: u32 = 0x82804CC0;
    'dispatch: loop {
        match pc {
            0x82804CC0 => {
    //   block [0x82804CC0..0x82804D10)
	// 82804CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804CC4: 484A4745  bl 0x82ca9408
	ctx.lr = 0x82804CC8;
	sub_82CA93D0(ctx, base);
	// 82804CC8: DBC1FFC8  stfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 82804CCC: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 82804CD0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804CD4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82804CD8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82804CDC: 808B7C68  lwz r4, 0x7c68(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(31848 as u32) ) } as u64;
	// 82804CE0: 4BAA4F81  bl 0x822a9c60
	ctx.lr = 0x82804CE4;
	sub_822A9C60(ctx, base);
	// 82804CE4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82804CE8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82804CEC: 419A0080  beq cr6, 0x82804d6c
	if ctx.cr[6].eq {
	pc = 0x82804D6C; continue 'dispatch;
	}
	// 82804CF0: 83FD0004  lwz r31, 4(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804CF4: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804CF8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82804CFC: 419A0070  beq cr6, 0x82804d6c
	if ctx.cr[6].eq {
	pc = 0x82804D6C; continue 'dispatch;
	}
	// 82804D00: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 82804D04: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 82804D08: 3D608210  lis r11, -0x7df0
	ctx.r[11].s64 = -2112880640;
	// 82804D0C: C3EB13E0  lfs f31, 0x13e0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(5088 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x82804D10; continue 'dispatch;
            }
            0x82804D10 => {
    //   block [0x82804D10..0x82804D6C)
	// 82804D10: 897E0002  lbz r11, 2(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 82804D14: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82804D18: 895E0001  lbz r10, 1(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 82804D1C: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804D20: 88DE0003  lbz r6, 3(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(3 as u32) ) } as u64;
	// 82804D24: 839F0000  lwz r28, 0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804D28: 99610052  stb r11, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[11].u8 ) };
	// 82804D2C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 82804D30: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 82804D34: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 82804D38: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82804D3C: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 82804D40: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804D44: FFC06818  frsp f30, f13
	ctx.f[30].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82804D48: 4BC20F11  bl 0x82425c58
	ctx.lr = 0x82804D4C;
	sub_82425C58(ctx, base);
	// 82804D4C: 809C0008  lwz r4, 8(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804D50: EC3E07F2  fmuls f1, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = (((ctx.f[30].f64 * ctx.f[31].f64) as f32) as f64);
	// 82804D54: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804D58: 4BC21321  bl 0x82426078
	ctx.lr = 0x82804D5C;
	sub_82426078(ctx, base);
	// 82804D5C: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804D60: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 82804D64: 7F1F2840  cmplw cr6, r31, r5
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82804D68: 409AFFA8  bne cr6, 0x82804d10
	if !ctx.cr[6].eq {
	pc = 0x82804D10; continue 'dispatch;
	}
	pc = 0x82804D6C; continue 'dispatch;
            }
            0x82804D6C => {
    //   block [0x82804D6C..0x82804D7C)
	// 82804D6C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 82804D70: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82804D74: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82804D78: 484A46E0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804D80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804D80 size=216
    let mut pc: u32 = 0x82804D80;
    'dispatch: loop {
        match pc {
            0x82804D80 => {
    //   block [0x82804D80..0x82804DA8)
	// 82804D80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804D84: 484A4689  bl 0x82ca940c
	ctx.lr = 0x82804D88;
	sub_82CA93D0(ctx, base);
	// 82804D88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804D8C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82804D90: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82804D94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804D98: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82804D9C: 409A000C  bne cr6, 0x82804da8
	if !ctx.cr[6].eq {
	pc = 0x82804DA8; continue 'dispatch;
	}
	// 82804DA0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 82804DA4: 48000024  b 0x82804dc8
	pc = 0x82804DC8; continue 'dispatch;
            }
            0x82804DA8 => {
    //   block [0x82804DA8..0x82804DC4)
	// 82804DA8: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 82804DAC: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82804DB0: 392AFFFF  addi r9, r10, -1
	ctx.r[9].s64 = ctx.r[10].s64 + -1;
	// 82804DB4: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82804DB8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82804DBC: 40980008  bge cr6, 0x82804dc4
	if !ctx.cr[6].lt {
	pc = 0x82804DC4; continue 'dispatch;
	}
	// 82804DC0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x82804DC4; continue 'dispatch;
            }
            0x82804DC4 => {
    //   block [0x82804DC4..0x82804DC8)
	// 82804DC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x82804DC8; continue 'dispatch;
            }
            0x82804DC8 => {
    //   block [0x82804DC8..0x82804DF8)
	// 82804DC8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82804DCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804DD0: 419A0080  beq cr6, 0x82804e50
	if ctx.cr[6].eq {
	pc = 0x82804E50; continue 'dispatch;
	}
	// 82804DD4: 817D0014  lwz r11, 0x14(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804DD8: 3BFD0014  addi r31, r29, 0x14
	ctx.r[31].s64 = ctx.r[29].s64 + 20;
	// 82804DDC: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82804DE0: 419A0020  beq cr6, 0x82804e00
	if ctx.cr[6].eq {
	pc = 0x82804E00; continue 'dispatch;
	}
	// 82804DE4: 40990014  ble cr6, 0x82804df8
	if !ctx.cr[6].gt {
	pc = 0x82804DF8; continue 'dispatch;
	}
	// 82804DE8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82804DEC: 4199000C  bgt cr6, 0x82804df8
	if ctx.cr[6].gt {
	pc = 0x82804DF8; continue 'dispatch;
	}
	// 82804DF0: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82804DF4: 48000010  b 0x82804e04
	pc = 0x82804E04; continue 'dispatch;
            }
            0x82804DF8 => {
    //   block [0x82804DF8..0x82804E00)
	// 82804DF8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82804DFC: 48000010  b 0x82804e0c
	pc = 0x82804E0C; continue 'dispatch;
            }
            0x82804E00 => {
    //   block [0x82804E00..0x82804E04)
	// 82804E00: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82804E04; continue 'dispatch;
            }
            0x82804E04 => {
    //   block [0x82804E04..0x82804E0C)
	// 82804E04: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 82804E08: 554BDFFE  rlwinm r11, r10, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x82804E0C; continue 'dispatch;
            }
            0x82804E0C => {
    //   block [0x82804E0C..0x82804E2C)
	// 82804E0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82804E10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804E14: 409A0018  bne cr6, 0x82804e2c
	if !ctx.cr[6].eq {
	pc = 0x82804E2C; continue 'dispatch;
	}
	// 82804E18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82804E1C: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82804E20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82804E24: 997D0008  stb r11, 8(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u8 ) };
	// 82804E28: 48000539  bl 0x82805360
	ctx.lr = 0x82804E2C;
	sub_82805360(ctx, base);
	pc = 0x82804E2C; continue 'dispatch;
            }
            0x82804E2C => {
    //   block [0x82804E2C..0x82804E50)
	// 82804E2C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82804E30: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 82804E34: 915D0004  stw r10, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82804E38: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 82804E3C: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82804E40: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82804E44: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82804E48: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82804E4C: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	pc = 0x82804E50; continue 'dispatch;
            }
            0x82804E50 => {
    //   block [0x82804E50..0x82804E58)
	// 82804E50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82804E54: 484A4608  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804E58 size=104
    let mut pc: u32 = 0x82804E58;
    'dispatch: loop {
        match pc {
            0x82804E58 => {
    //   block [0x82804E58..0x82804EC0)
	// 82804E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82804E60: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82804E64: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82804E68: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804E6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82804E70: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82804E74: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82804E78: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82804E7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804E80: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82804E84: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82804E88: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82804E8C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82804E90: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82804E94: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82804E98: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82804E9C: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82804EA0: 48000109  bl 0x82804fa8
	ctx.lr = 0x82804EA4;
	sub_82804FA8(ctx, base);
	// 82804EA4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82804EA8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82804EAC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82804EB0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82804EB4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82804EB8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82804EBC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804EC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804EC0 size=232
    let mut pc: u32 = 0x82804EC0;
    'dispatch: loop {
        match pc {
            0x82804EC0 => {
    //   block [0x82804EC0..0x82804F50)
	// 82804EC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804EC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82804EC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82804ECC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82804ED0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804ED4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82804ED8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82804EDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82804EE0: 7D68F030  slw r8, r11, r30
	if (ctx.r[30].u8 & 0x20) != 0 {
		ctx.r[8].u64 = 0;
	} else {
		ctx.r[8].u64 = ((ctx.r[11].u32) << ((ctx.r[30].u8 & 0x1F) as u32)) as u64;
	}
	// 82804EE4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82804EE8: 893F0008  lbz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82804EEC: 7D075378  or r7, r8, r10
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[10].u64;
	// 82804EF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82804EF4: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 82804EF8: 409A0098  bne cr6, 0x82804f90
	if !ctx.cr[6].eq {
	pc = 0x82804F90; continue 'dispatch;
	}
	// 82804EFC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804F00: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82804F04: 419A004C  beq cr6, 0x82804f50
	if ctx.cr[6].eq {
	pc = 0x82804F50; continue 'dispatch;
	}
	// 82804F08: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82804F0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82804F10: 419A0080  beq cr6, 0x82804f90
	if ctx.cr[6].eq {
	pc = 0x82804F90; continue 'dispatch;
	}
	// 82804F14: 7F0BF000  cmpw cr6, r11, r30
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[30].s32, &mut ctx.xer);
	// 82804F18: 419A0078  beq cr6, 0x82804f90
	if ctx.cr[6].eq {
	pc = 0x82804F90; continue 'dispatch;
	}
	// 82804F1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82804F20: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 82804F24: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82804F28: 395F0014  addi r10, r31, 0x14
	ctx.r[10].s64 = ctx.r[31].s64 + 20;
	// 82804F2C: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 82804F30: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 82804F34: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82804F38: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 82804F3C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82804F40: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82804F44: 917F0024  stw r11, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82804F48: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82804F4C: 48000044  b 0x82804f90
	pc = 0x82804F90; continue 'dispatch;
            }
            0x82804F50 => {
    //   block [0x82804F50..0x82804F90)
	// 82804F50: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 82804F54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82804F58: 419A0038  beq cr6, 0x82804f90
	if ctx.cr[6].eq {
	pc = 0x82804F90; continue 'dispatch;
	}
	// 82804F5C: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 82804F60: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 82804F64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 82804F68: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 82804F6C: 814A6B08  lwz r10, 0x6b08(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27400 as u32) ) } as u64;
	// 82804F70: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82804F74: 812A0020  lwz r9, 0x20(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) } as u64;
	// 82804F78: 80690038  lwz r3, 0x38(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) } as u64;
	// 82804F7C: 4BBCD6DD  bl 0x823d2658
	ctx.lr = 0x82804F80;
	sub_823D2658(ctx, base);
	// 82804F80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82804F84: 387F0014  addi r3, r31, 0x14
	ctx.r[3].s64 = ctx.r[31].s64 + 20;
	// 82804F88: 4BBCE301  bl 0x823d3288
	ctx.lr = 0x82804F8C;
	sub_823D3288(ctx, base);
	// 82804F8C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x82804F90; continue 'dispatch;
            }
            0x82804F90 => {
    //   block [0x82804F90..0x82804FA8)
	// 82804F90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82804F94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82804F98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82804F9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82804FA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82804FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82804FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82804FA8 size=172
    let mut pc: u32 = 0x82804FA8;
    'dispatch: loop {
        match pc {
            0x82804FA8 => {
    //   block [0x82804FA8..0x82805000)
	// 82804FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82804FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82804FB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82804FB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82804FB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82804FBC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82804FC0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82804FC4: 2F0BFFFF  cmpwi cr6, r11, -1
	ctx.cr[6].compare_i32(ctx.r[11].s32, -1, &mut ctx.xer);
	// 82804FC8: 419A0038  beq cr6, 0x82805000
	if ctx.cr[6].eq {
	pc = 0x82805000; continue 'dispatch;
	}
	// 82804FCC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82804FD0: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82804FD4: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82804FD8: 397F0014  addi r11, r31, 0x14
	ctx.r[11].s64 = ctx.r[31].s64 + 20;
	// 82804FDC: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82804FE0: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82804FE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82804FE8: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 82804FEC: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 82804FF0: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 82804FF4: 93DF0024  stw r30, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
	// 82804FF8: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 82804FFC: 48000040  b 0x8280503c
	pc = 0x8280503C; continue 'dispatch;
            }
            0x82805000 => {
    //   block [0x82805000..0x82805038)
	// 82805000: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 82805004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82805008: 419A0034  beq cr6, 0x8280503c
	if ctx.cr[6].eq {
	pc = 0x8280503C; continue 'dispatch;
	}
	// 8280500C: 897F0008  lbz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82805010: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82805014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82805018: 419A0020  beq cr6, 0x82805038
	if ctx.cr[6].eq {
	pc = 0x82805038; continue 'dispatch;
	}
	// 8280501C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82805020: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82805024: 816B6B08  lwz r11, 0x6b08(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27400 as u32) ) } as u64;
	// 82805028: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8280502C: 806A003C  lwz r3, 0x3c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(60 as u32) ) } as u64;
	// 82805030: 4BEA55A9  bl 0x826aa5d8
	ctx.lr = 0x82805034;
	sub_826AA5D8(ctx, base);
	// 82805034: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	pc = 0x82805038; continue 'dispatch;
            }
            0x82805038 => {
    //   block [0x82805038..0x8280503C)
	// 82805038: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	pc = 0x8280503C; continue 'dispatch;
            }
            0x8280503C => {
    //   block [0x8280503C..0x82805054)
	// 8280503C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82805040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82805044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82805048: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8280504C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82805050: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82805058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82805058 size=96
    let mut pc: u32 = 0x82805058;
    'dispatch: loop {
        match pc {
            0x82805058 => {
    //   block [0x82805058..0x828050B8)
	// 82805058: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280505C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82805060: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82805064: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82805068: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8280506C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82805070: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82805074: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82805078: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 8280507C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82805080: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 82805084: 93DF0008  stw r30, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u32 ) };
	// 82805088: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8280508C: 93DF0010  stw r30, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[30].u32 ) };
	// 82805090: 4B988EA9  bl 0x8218df38
	ctx.lr = 0x82805094;
	sub_8218DF38(ctx, base);
	// 82805094: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 82805098: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 8280509C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828050A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 828050A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828050A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828050AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 828050B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 828050B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828050B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x828050B8 size=308
    let mut pc: u32 = 0x828050B8;
    'dispatch: loop {
        match pc {
            0x828050B8 => {
    //   block [0x828050B8..0x82805140)
	// 828050B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 828050BC: 484A434D  bl 0x82ca9408
	ctx.lr = 0x828050C0;
	sub_82CA93D0(ctx, base);
	// 828050C0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 828050C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 828050C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 828050CC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 828050D0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 828050D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 828050D8: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 828050DC: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 828050E0: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 828050E4: 93BF0010  stw r29, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u32 ) };
	// 828050E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 828050EC: 917F0014  stw r11, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 828050F0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 828050F4: 915F0018  stw r10, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[10].u32 ) };
	// 828050F8: 4B9AD401  bl 0x821b24f8
	ctx.lr = 0x828050FC;
	sub_821B24F8(ctx, base);
	// 828050FC: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 82805100: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82805104: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82805108: 3869E9C4  addi r3, r9, -0x163c
	ctx.r[3].s64 = ctx.r[9].s64 + -5692;
	// 8280510C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82805110: 4B9EEC49  bl 0x821f3d58
	ctx.lr = 0x82805114;
	sub_821F3D58(ctx, base);
	// 82805114: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82805118: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280511C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82805120: 481FB5A9  bl 0x82a006c8
	ctx.lr = 0x82805124;
	sub_82A006C8(ctx, base);
	// 82805124: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82805128: 419A0018  beq cr6, 0x82805140
	if ctx.cr[6].eq {
	pc = 0x82805140; continue 'dispatch;
	}
	// 8280512C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 82805130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82805134: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82805138: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8280513C: 484A431C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82805140 => {
    //   block [0x82805140..0x82805180)
	// 82805140: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82805144: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 82805148: 386BEA00  addi r3, r11, -0x1600
	ctx.r[3].s64 = ctx.r[11].s64 + -5632;
	// 8280514C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 82805150: 4B9EEC09  bl 0x821f3d58
	ctx.lr = 0x82805154;
	sub_821F3D58(ctx, base);
	// 82805154: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82805158: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8280515C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 82805160: 481FB569  bl 0x82a006c8
	ctx.lr = 0x82805164;
	sub_82A006C8(ctx, base);
	// 82805164: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82805168: 419A0018  beq cr6, 0x82805180
	if ctx.cr[6].eq {
	pc = 0x82805180; continue 'dispatch;
	}
	// 8280516C: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82805170: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82805174: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82805178: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8280517C: 484A42DC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x82805180 => {
    //   block [0x82805180..0x828051B8)
	// 82805180: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82805184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82805188: 419A0054  beq cr6, 0x828051dc
	if ctx.cr[6].eq {
	pc = 0x828051DC; continue 'dispatch;
	}
	// 8280518C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 82805190: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 82805194: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82805198: 816A008C  lwz r11, 0x8c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 8280519C: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 828051A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 828051A4: 419A0014  beq cr6, 0x828051b8
	if ctx.cr[6].eq {
	pc = 0x828051B8; continue 'dispatch;
	}
	// 828051A8: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 828051AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828051B0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 828051B4: 409A0008  bne cr6, 0x828051bc
	if !ctx.cr[6].eq {
	pc = 0x828051BC; continue 'dispatch;
	}
	pc = 0x828051B8; continue 'dispatch;
            }
            0x828051B8 => {
    //   block [0x828051B8..0x828051BC)
	// 828051B8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x828051BC; continue 'dispatch;
            }
            0x828051BC => {
    //   block [0x828051BC..0x828051DC)
	// 828051BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 828051C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828051C4: 419A0018  beq cr6, 0x828051dc
	if ctx.cr[6].eq {
	pc = 0x828051DC; continue 'dispatch;
	}
	// 828051C8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 828051CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828051D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 828051D4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828051D8: 484A4280  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x828051DC => {
    //   block [0x828051DC..0x828051EC)
	// 828051DC: 93BF0000  stw r29, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 828051E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 828051E4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 828051E8: 484A4270  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_828051F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x828051F0 size=44
    let mut pc: u32 = 0x828051F0;
    'dispatch: loop {
        match pc {
            0x828051F0 => {
    //   block [0x828051F0..0x8280521C)
	// 828051F0: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 828051F4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 828051F8: 419A0024  beq cr6, 0x8280521c
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8280521C);
		return;
	}
	// 828051FC: 4099004C  ble cr6, 0x82805248
	if !ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82805248);
		return;
	}
	// 82805200: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82805204: 41990044  bgt cr6, 0x82805248
	if ctx.cr[6].gt {
		crate::recompiler::externs::call(ctx, base, 0x82805248);
		return;
	}
	// 82805208: 81640014  lwz r11, 0x14(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 8280520C: 81440018  lwz r10, 0x18(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 82805210: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82805214: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82805218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82805258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82805258 size=260
    let mut pc: u32 = 0x82805258;
    'dispatch: loop {
        match pc {
            0x82805258 => {
    //   block [0x82805258..0x8280529C)
	// 82805258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8280525C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82805260: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82805264: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82805268: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8280526C: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 82805270: 419900D8  bgt cr6, 0x82805348
	if ctx.cr[6].gt {
	pc = 0x82805348; continue 'dispatch;
	}
	// 82805274: 3D808280  lis r12, -0x7d80
	ctx.r[12].s64 = -2105540608;
	// 82805278: 398C528C  addi r12, r12, 0x528c
	ctx.r[12].s64 = ctx.r[12].s64 + 21132;
	// 8280527C: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82805280: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82805284: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82805288: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8280529C; continue 'dispatch;
		},
		1 => {
	pc = 0x82805330; continue 'dispatch;
		},
		2 => {
	pc = 0x82805330; continue 'dispatch;
		},
		3 => {
	pc = 0x828052FC; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8280528C: 8280529C  lwz r20, 0x529c(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 21148u32 ) } as u64;
	// 82805290: 82805330  lwz r20, 0x5330(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 21296u32 ) } as u64;
	// 82805294: 82805330  lwz r20, 0x5330(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 21296u32 ) } as u64;
	// 82805298: 828052FC  lwz r20, 0x52fc(0)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, 21244u32 ) } as u64;
            }
            0x8280529C => {
    //   block [0x8280529C..0x828052C8)
	// 8280529C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 828052A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828052A4: 419A00A4  beq cr6, 0x82805348
	if ctx.cr[6].eq {
	pc = 0x82805348; continue 'dispatch;
	}
	// 828052A8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 828052AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 828052B0: 419A0018  beq cr6, 0x828052c8
	if ctx.cr[6].eq {
	pc = 0x828052C8; continue 'dispatch;
	}
	// 828052B4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 828052B8: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 828052BC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 828052C0: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 828052C4: 48000010  b 0x828052d4
	pc = 0x828052D4; continue 'dispatch;
            }
            0x828052C8 => {
    //   block [0x828052C8..0x828052D4)
	// 828052C8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 828052CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 828052D0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x828052D4; continue 'dispatch;
            }
            0x828052D4 => {
    //   block [0x828052D4..0x828052FC)
	// 828052D4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 828052D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 828052DC: 38EBF11C  addi r7, r11, -0xee4
	ctx.r[7].s64 = ctx.r[11].s64 + -3812;
	// 828052E0: 4B9AD219  bl 0x821b24f8
	ctx.lr = 0x828052E4;
	sub_821B24F8(ctx, base);
	// 828052E4: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 828052E8: 4BAA4701  bl 0x822a99e8
	ctx.lr = 0x828052EC;
	sub_822A99E8(ctx, base);
	// 828052EC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 828052F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 828052F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 828052F8: 4E800020  blr
	return;
            }
            0x828052FC => {
    //   block [0x828052FC..0x82805330)
	// 828052FC: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82805300: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82805304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82805308: 419A0040  beq cr6, 0x82805348
	if ctx.cr[6].eq {
	pc = 0x82805348; continue 'dispatch;
	}
	// 8280530C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82805310: 38EBF11C  addi r7, r11, -0xee4
	ctx.r[7].s64 = ctx.r[11].s64 + -3812;
	// 82805314: 4B9AD1E5  bl 0x821b24f8
	ctx.lr = 0x82805318;
	sub_821B24F8(ctx, base);
	// 82805318: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 8280531C: 4BAA46CD  bl 0x822a99e8
	ctx.lr = 0x82805320;
	sub_822A99E8(ctx, base);
	// 82805320: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82805324: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82805328: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8280532C: 4E800020  blr
	return;
            }
            0x82805330 => {
    //   block [0x82805330..0x82805348)
	// 82805330: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 82805334: 4B9AD1C5  bl 0x821b24f8
	ctx.lr = 0x82805338;
	sub_821B24F8(ctx, base);
	// 82805338: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8280533C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82805340: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82805344: 4E800020  blr
	return;
            }
            0x82805348 => {
    //   block [0x82805348..0x8280535C)
	// 82805348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8280534C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82805350: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82805354: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82805358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


