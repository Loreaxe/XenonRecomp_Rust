pub fn sub_825AB4E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AB4E8 size=184
    let mut pc: u32 = 0x825AB4E8;
    'dispatch: loop {
        match pc {
            0x825AB4E8 => {
    //   block [0x825AB4E8..0x825AB580)
	// 825AB4E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB4EC: 486FDF15  bl 0x82ca9400
	ctx.lr = 0x825AB4F0;
	sub_82CA93D0(ctx, base);
	// 825AB4F0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825AB4F4: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB4F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB4FC: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825AB500: 817F0050  lwz r11, 0x50(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AB504: 894B004A  lbz r10, 0x4a(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(74 as u32) ) } as u64;
	// 825AB508: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB50C: 419A0074  beq cr6, 0x825ab580
	if ctx.cr[6].eq {
	pc = 0x825AB580; continue 'dispatch;
	}
	// 825AB510: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AB514: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AB518: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AB51C: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825AB520: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AB524: 3BA10054  addi r29, r1, 0x54
	ctx.r[29].s64 = ctx.r[1].s64 + 84;
	// 825AB528: 88EB0047  lbz r7, 0x47(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(71 as u32) ) } as u64;
	// 825AB52C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AB530: C3EA9484  lfs f31, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AB534: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 825AB538: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825AB53C: 3B610058  addi r27, r1, 0x58
	ctx.r[27].s64 = ctx.r[1].s64 + 88;
	// 825AB540: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AB544: 7CFA0034  cntlzw r26, r7
	ctx.r[26].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 825AB548: 4BBC88F1  bl 0x82173e38
	ctx.lr = 0x825AB54C;
	sub_82173E38(ctx, base);
	// 825AB54C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AB550: 5745DFFE  rlwinm r5, r26, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[26].u32 as u64 & 0x0000001Fu64;
	// 825AB554: 807F0050  lwz r3, 0x50(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AB558: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825AB55C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825AB560: 7FA8EB78  mr r8, r29
	ctx.r[8].u64 = ctx.r[29].u64;
	// 825AB564: 4BFFA875  bl 0x825a5dd8
	ctx.lr = 0x825AB568;
	sub_825A5DD8(ctx, base);
	// 825AB568: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AB56C: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 825AB570: 40990010  ble cr6, 0x825ab580
	if !ctx.cr[6].gt {
	pc = 0x825AB580; continue 'dispatch;
	}
	// 825AB574: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB578: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825AB57C: 419A0014  beq cr6, 0x825ab590
	if ctx.cr[6].eq {
	pc = 0x825AB590; continue 'dispatch;
	}
	pc = 0x825AB580; continue 'dispatch;
            }
            0x825AB580 => {
    //   block [0x825AB580..0x825AB590)
	// 825AB580: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AB584: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AB588: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825AB58C: 486FDEC4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AB590 => {
    //   block [0x825AB590..0x825AB5A0)
	// 825AB590: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB594: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AB598: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825AB59C: 486FDEB4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB5A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AB5A0 size=392
    let mut pc: u32 = 0x825AB5A0;
    'dispatch: loop {
        match pc {
            0x825AB5A0 => {
    //   block [0x825AB5A0..0x825AB61C)
	// 825AB5A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB5A4: 486FDE69  bl 0x82ca940c
	ctx.lr = 0x825AB5A8;
	sub_82CA93D0(ctx, base);
	// 825AB5A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB5AC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AB5B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB5B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825AB5BC: 48000E2D  bl 0x825ac3e8
	ctx.lr = 0x825AB5C0;
	sub_825AC3E8(ctx, base);
	// 825AB5C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB5C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5C8: 419A0154  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB5CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB5D0: 4BFFFF19  bl 0x825ab4e8
	ctx.lr = 0x825AB5D4;
	sub_825AB4E8(ctx, base);
	// 825AB5D4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB5D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5DC: 419A0140  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB5E0: 815F0024  lwz r10, 0x24(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AB5E4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825AB5E8: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 825AB5EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AB5F0: 419A00E8  beq cr6, 0x825ab6d8
	if ctx.cr[6].eq {
	pc = 0x825AB6D8; continue 'dispatch;
	}
	// 825AB5F4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AB5F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB5FC: 419A0020  beq cr6, 0x825ab61c
	if ctx.cr[6].eq {
	pc = 0x825AB61C; continue 'dispatch;
	}
	// 825AB600: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AB604: 817F0048  lwz r11, 0x48(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB608: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AB60C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AB610: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB614: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB618: 480000C4  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
            }
            0x825AB61C => {
    //   block [0x825AB61C..0x825AB638)
	// 825AB61C: 815F0048  lwz r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB620: 80DF004C  lwz r6, 0x4c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AB624: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825AB628: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AB62C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB630: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB634: 40810054  ble 0x825ab688
	if !ctx.cr[0].gt {
	pc = 0x825AB688; continue 'dispatch;
	}
	pc = 0x825AB638; continue 'dispatch;
            }
            0x825AB638 => {
    //   block [0x825AB638..0x825AB658)
	// 825AB638: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AB63C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AB640: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AB644: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB648: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AB64C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AB650: 41980008  blt cr6, 0x825ab658
	if ctx.cr[6].lt {
	pc = 0x825AB658; continue 'dispatch;
	}
	// 825AB654: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x825AB658; continue 'dispatch;
            }
            0x825AB658 => {
    //   block [0x825AB658..0x825AB674)
	// 825AB658: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AB65C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AB660: 419A0014  beq cr6, 0x825ab674
	if ctx.cr[6].eq {
	pc = 0x825AB674; continue 'dispatch;
	}
	// 825AB664: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AB668: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AB66C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AB670: 4800000C  b 0x825ab67c
	pc = 0x825AB67C; continue 'dispatch;
            }
            0x825AB674 => {
    //   block [0x825AB674..0x825AB67C)
	// 825AB674: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AB678: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AB67C; continue 'dispatch;
            }
            0x825AB67C => {
    //   block [0x825AB67C..0x825AB688)
	// 825AB67C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB680: 4199FFB8  bgt cr6, 0x825ab638
	if ctx.cr[6].gt {
	pc = 0x825AB638; continue 'dispatch;
	}
	// 825AB684: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AB688; continue 'dispatch;
            }
            0x825AB688 => {
    //   block [0x825AB688..0x825AB6A4)
	// 825AB688: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AB68C: 419A003C  beq cr6, 0x825ab6c8
	if ctx.cr[6].eq {
	pc = 0x825AB6C8; continue 'dispatch;
	}
	// 825AB690: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB694: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AB698: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB69C: 41990008  bgt cr6, 0x825ab6a4
	if ctx.cr[6].gt {
	pc = 0x825AB6A4; continue 'dispatch;
	}
	// 825AB6A0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825AB6A4; continue 'dispatch;
            }
            0x825AB6A4 => {
    //   block [0x825AB6A4..0x825AB6C8)
	// 825AB6A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB6A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB6AC: 409A001C  bne cr6, 0x825ab6c8
	if !ctx.cr[6].eq {
	pc = 0x825AB6C8; continue 'dispatch;
	}
	// 825AB6B0: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AB6B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB6B8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AB6BC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB6C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB6C4: 48000018  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
            }
            0x825AB6C8 => {
    //   block [0x825AB6C8..0x825AB6D8)
	// 825AB6C8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AB6CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AB6D0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB6D4: 48000008  b 0x825ab6dc
	pc = 0x825AB6DC; continue 'dispatch;
            }
            0x825AB6D8 => {
    //   block [0x825AB6D8..0x825AB6DC)
	// 825AB6D8: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x825AB6DC; continue 'dispatch;
            }
            0x825AB6DC => {
    //   block [0x825AB6DC..0x825AB71C)
	// 825AB6DC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825AB6E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB6E4: 419A0038  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB6E8: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AB6EC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825AB6F0: 4BC49C31  bl 0x821f5320
	ctx.lr = 0x825AB6F4;
	sub_821F5320(ctx, base);
	// 825AB6F4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB6F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AB6FC: 419A0020  beq cr6, 0x825ab71c
	if ctx.cr[6].eq {
	pc = 0x825AB71C; continue 'dispatch;
	}
	// 825AB700: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB704: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB708: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AB70C: 4E800421  bctrl
	ctx.lr = 0x825AB710;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AB710: 2F030030  cmpwi cr6, r3, 0x30
	ctx.cr[6].compare_i32(ctx.r[3].s32, 48, &mut ctx.xer);
	// 825AB714: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB718: 419A0008  beq cr6, 0x825ab720
	if ctx.cr[6].eq {
	pc = 0x825AB720; continue 'dispatch;
	}
            }
            0x825AB71C => {
    //   block [0x825AB71C..0x825AB720)
	// 825AB71C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x825AB720; continue 'dispatch;
            }
            0x825AB720 => {
    //   block [0x825AB720..0x825AB728)
	// 825AB720: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AB724: 486FDD38  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AB728 size=548
    let mut pc: u32 = 0x825AB728;
    'dispatch: loop {
        match pc {
            0x825AB728 => {
    //   block [0x825AB728..0x825AB760)
	// 825AB728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB72C: 486FDCE1  bl 0x82ca940c
	ctx.lr = 0x825AB730;
	sub_82CA93D0(ctx, base);
	// 825AB730: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AB734: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AB738: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AB73C: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 825AB740: 817D000C  lwz r11, 0xc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AB744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB748: 419A0020  beq cr6, 0x825ab768
	if ctx.cr[6].eq {
	pc = 0x825AB768; continue 'dispatch;
	}
	// 825AB74C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB754: 419A000C  beq cr6, 0x825ab760
	if ctx.cr[6].eq {
	pc = 0x825AB760; continue 'dispatch;
	}
	// 825AB758: 5543003E  slwi r3, r10, 0
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825AB75C: 48000010  b 0x825ab76c
	pc = 0x825AB76C; continue 'dispatch;
            }
            0x825AB760 => {
    //   block [0x825AB760..0x825AB768)
	// 825AB760: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB764: 4BBE86D5  bl 0x82193e38
	ctx.lr = 0x825AB768;
	sub_82193E38(ctx, base);
	pc = 0x825AB768; continue 'dispatch;
            }
            0x825AB768 => {
    //   block [0x825AB768..0x825AB76C)
	// 825AB768: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825AB76C; continue 'dispatch;
            }
            0x825AB76C => {
    //   block [0x825AB76C..0x825AB7D4)
	// 825AB76C: 48000C7D  bl 0x825ac3e8
	ctx.lr = 0x825AB770;
	sub_825AC3E8(ctx, base);
	// 825AB770: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB778: 419A01CC  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB77C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AB780: 4BFFFD69  bl 0x825ab4e8
	ctx.lr = 0x825AB784;
	sub_825AB4E8(ctx, base);
	// 825AB784: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB788: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB78C: 419A01B8  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB794: 4BBC86A5  bl 0x82173e38
	ctx.lr = 0x825AB798;
	sub_82173E38(ctx, base);
	// 825AB798: 81630024  lwz r11, 0x24(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AB79C: 556A5FFE  rlwinm r10, r11, 0xb, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x001FFFFFu64;
	// 825AB7A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AB7A4: 419A00F4  beq cr6, 0x825ab898
	if ctx.cr[6].eq {
	pc = 0x825AB898; continue 'dispatch;
	}
	// 825AB7A8: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AB7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB7B0: 419A0024  beq cr6, 0x825ab7d4
	if ctx.cr[6].eq {
	pc = 0x825AB7D4; continue 'dispatch;
	}
	// 825AB7B4: 894B0015  lbz r10, 0x15(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AB7B8: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB7BC: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AB7C0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AB7C4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB7C8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB7CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB7D0: 480000CC  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
            }
            0x825AB7D4 => {
    //   block [0x825AB7D4..0x825AB7F0)
	// 825AB7D4: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AB7D8: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AB7DC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AB7E0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AB7E4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AB7E8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB7EC: 40810054  ble 0x825ab840
	if !ctx.cr[0].gt {
	pc = 0x825AB840; continue 'dispatch;
	}
	pc = 0x825AB7F0; continue 'dispatch;
            }
            0x825AB7F0 => {
    //   block [0x825AB7F0..0x825AB810)
	// 825AB7F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AB7F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AB7F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AB7FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB800: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AB804: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AB808: 41980008  blt cr6, 0x825ab810
	if ctx.cr[6].lt {
	pc = 0x825AB810; continue 'dispatch;
	}
	// 825AB80C: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825AB810; continue 'dispatch;
            }
            0x825AB810 => {
    //   block [0x825AB810..0x825AB82C)
	// 825AB810: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AB814: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AB818: 419A0014  beq cr6, 0x825ab82c
	if ctx.cr[6].eq {
	pc = 0x825AB82C; continue 'dispatch;
	}
	// 825AB81C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AB820: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AB824: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AB828: 4800000C  b 0x825ab834
	pc = 0x825AB834; continue 'dispatch;
            }
            0x825AB82C => {
    //   block [0x825AB82C..0x825AB834)
	// 825AB82C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AB830: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AB834; continue 'dispatch;
            }
            0x825AB834 => {
    //   block [0x825AB834..0x825AB840)
	// 825AB834: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AB838: 4199FFB8  bgt cr6, 0x825ab7f0
	if ctx.cr[6].gt {
	pc = 0x825AB7F0; continue 'dispatch;
	}
	// 825AB83C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AB840; continue 'dispatch;
            }
            0x825AB840 => {
    //   block [0x825AB840..0x825AB85C)
	// 825AB840: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AB844: 419A0040  beq cr6, 0x825ab884
	if ctx.cr[6].eq {
	pc = 0x825AB884; continue 'dispatch;
	}
	// 825AB848: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AB84C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AB850: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB854: 41990008  bgt cr6, 0x825ab85c
	if ctx.cr[6].gt {
	pc = 0x825AB85C; continue 'dispatch;
	}
	// 825AB858: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825AB85C; continue 'dispatch;
            }
            0x825AB85C => {
    //   block [0x825AB85C..0x825AB884)
	// 825AB85C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB860: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB864: 409A0020  bne cr6, 0x825ab884
	if !ctx.cr[6].eq {
	pc = 0x825AB884; continue 'dispatch;
	}
	// 825AB868: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AB86C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AB870: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AB874: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB878: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB87C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB880: 4800001C  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
            }
            0x825AB884 => {
    //   block [0x825AB884..0x825AB898)
	// 825AB884: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AB888: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AB88C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AB890: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AB894: 48000008  b 0x825ab89c
	pc = 0x825AB89C; continue 'dispatch;
            }
            0x825AB898 => {
    //   block [0x825AB898..0x825AB89C)
	// 825AB898: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825AB89C; continue 'dispatch;
            }
            0x825AB89C => {
    //   block [0x825AB89C..0x825AB8CC)
	// 825AB89C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AB8A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB8A4: 419A0028  beq cr6, 0x825ab8cc
	if ctx.cr[6].eq {
	pc = 0x825AB8CC; continue 'dispatch;
	}
	// 825AB8A8: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825AB8AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB8B0: 4BC53D19  bl 0x821ff5c8
	ctx.lr = 0x825AB8B4;
	sub_821FF5C8(ctx, base);
	// 825AB8B4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AB8B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AB8BC: 409A0010  bne cr6, 0x825ab8cc
	if !ctx.cr[6].eq {
	pc = 0x825AB8CC; continue 'dispatch;
	}
	// 825AB8C0: 38800030  li r4, 0x30
	ctx.r[4].s64 = 48;
	// 825AB8C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AB8C8: 4BE740E1  bl 0x8241f9a8
	ctx.lr = 0x825AB8CC;
	sub_8241F9A8(ctx, base);
	pc = 0x825AB8CC; continue 'dispatch;
            }
            0x825AB8CC => {
    //   block [0x825AB8CC..0x825AB944)
	// 825AB8CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AB8D0: 4BBC8569  bl 0x82173e38
	ctx.lr = 0x825AB8D4;
	sub_82173E38(ctx, base);
	// 825AB8D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AB8D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AB8DC: 4BFFFCC5  bl 0x825ab5a0
	ctx.lr = 0x825AB8E0;
	sub_825AB5A0(ctx, base);
	// 825AB8E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AB8E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AB8E8: 419A005C  beq cr6, 0x825ab944
	if ctx.cr[6].eq {
	pc = 0x825AB944; continue 'dispatch;
	}
	// 825AB8EC: 396000A0  li r11, 0xa0
	ctx.r[11].s64 = 160;
	// 825AB8F0: 394000B0  li r10, 0xb0
	ctx.r[10].s64 = 176;
	// 825AB8F4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AB8F8: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 825AB8FC: 38E990C0  addi r7, r9, -0x6f40
	ctx.r[7].s64 = ctx.r[9].s64 + -28480;
	pc = 0x825AB944; continue 'dispatch;
            }
            0x825AB944 => {
    //   block [0x825AB944..0x825AB94C)
	// 825AB944: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AB948: 486FDB14  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AB950(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AB950 size=952
    let mut pc: u32 = 0x825AB950;
    'dispatch: loop {
        match pc {
            0x825AB950 => {
    //   block [0x825AB950..0x825ABD08)
	// 825AB950: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AB954: 486FDAA5  bl 0x82ca93f8
	ctx.lr = 0x825AB958;
	sub_82CA93D0(ctx, base);
	// 825AB958: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825AB95C: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABD08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825ABD08 size=132
    let mut pc: u32 = 0x825ABD08;
    'dispatch: loop {
        match pc {
            0x825ABD08 => {
    //   block [0x825ABD08..0x825ABD8C)
	// 825ABD08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABD0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ABD10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ABD14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ABD18: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABD90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ABD90 size=548
    let mut pc: u32 = 0x825ABD90;
    'dispatch: loop {
        match pc {
            0x825ABD90 => {
    //   block [0x825ABD90..0x825ABDC0)
	// 825ABD90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABD94: 486FD661  bl 0x82ca93f4
	ctx.lr = 0x825ABD98;
	sub_82CA93D0(ctx, base);
	// 825ABD98: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ABD9C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825ABDA0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825ABDA4: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 825ABDA8: 419A0018  beq cr6, 0x825abdc0
	if ctx.cr[6].eq {
	pc = 0x825ABDC0; continue 'dispatch;
	}
	// 825ABDAC: 89770090  lbz r11, 0x90(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[23].u32.wrapping_add(144 as u32) ) } as u64;
	// 825ABDB0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825ABDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ABDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABDBC: 409A0008  bne cr6, 0x825abdc4
	if !ctx.cr[6].eq {
	pc = 0x825ABDC4; continue 'dispatch;
	}
	pc = 0x825ABDC0; continue 'dispatch;
            }
            0x825ABDC0 => {
    //   block [0x825ABDC0..0x825ABDC4)
	// 825ABDC0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825ABDC4; continue 'dispatch;
            }
            0x825ABDC4 => {
    //   block [0x825ABDC4..0x825ABE34)
	// 825ABDC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ABDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABDCC: 419A01E0  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABDD0: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 825ABDD4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ABDD8: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 825ABDDC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825ABDE0: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825ABDE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825ABDE8: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825ABDEC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825ABDF0: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ABDF4: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ABDF8: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABDFC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ABE00: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825ABE04: 4BF0617D  bl 0x824b1f80
	ctx.lr = 0x825ABE08;
	sub_824B1F80(ctx, base);
	// 825ABE08: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825ABE0C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABE10: 40990190  ble cr6, 0x825abfa0
	if !ctx.cr[6].gt {
	pc = 0x825ABFA0; continue 'dispatch;
	}
	// 825ABE14: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 825ABE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE1C: 419A0190  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABE20: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE24: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE28: 7D581671  srawi. r24, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[24].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825ABE2C: 40810174  ble 0x825abfa0
	if !ctx.cr[0].gt {
	pc = 0x825ABFA0; continue 'dispatch;
	}
	// 825ABE30: 7F3ACB78  mr r26, r25
	ctx.r[26].u64 = ctx.r[25].u64;
	pc = 0x825ABE34; continue 'dispatch;
            }
            0x825ABE34 => {
    //   block [0x825ABE34..0x825ABE50)
	// 825ABE34: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE38: 419A0018  beq cr6, 0x825abe50
	if ctx.cr[6].eq {
	pc = 0x825ABE50; continue 'dispatch;
	}
	// 825ABE3C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE40: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE44: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABE48: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABE4C: 41980008  blt cr6, 0x825abe54
	if ctx.cr[6].lt {
	pc = 0x825ABE54; continue 'dispatch;
	}
	pc = 0x825ABE50; continue 'dispatch;
            }
            0x825ABE50 => {
    //   block [0x825ABE50..0x825ABE54)
	// 825ABE50: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825ABE54; continue 'dispatch;
            }
            0x825ABE54 => {
    //   block [0x825ABE54..0x825ABE90)
	// 825ABE54: 7C7A182E  lwzx r3, r26, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABE58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABE5C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825ABE60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825ABE64: 4E800421  bctrl
	ctx.lr = 0x825ABE68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ABE68: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825ABE6C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABE70: 409A0030  bne cr6, 0x825abea0
	if !ctx.cr[6].eq {
	pc = 0x825ABEA0; continue 'dispatch;
	}
	// 825ABE74: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABE78: 419A0018  beq cr6, 0x825abe90
	if ctx.cr[6].eq {
	pc = 0x825ABE90; continue 'dispatch;
	}
	// 825ABE7C: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABE80: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABE84: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABE88: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABE8C: 41980008  blt cr6, 0x825abe94
	if ctx.cr[6].lt {
	pc = 0x825ABE94; continue 'dispatch;
	}
            }
            0x825ABE90 => {
    //   block [0x825ABE90..0x825ABE94)
	// 825ABE90: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825ABE94; continue 'dispatch;
            }
            0x825ABE94 => {
    //   block [0x825ABE94..0x825ABEA0)
	// 825ABE94: 7D7A182E  lwzx r11, r26, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABE98: 83CB00C8  lwz r30, 0xc8(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825ABE9C: 4800002C  b 0x825abec8
	pc = 0x825ABEC8; continue 'dispatch;
            }
            0x825ABEA0 => {
    //   block [0x825ABEA0..0x825ABEBC)
	// 825ABEA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABEA4: 419A0018  beq cr6, 0x825abebc
	if ctx.cr[6].eq {
	pc = 0x825ABEBC; continue 'dispatch;
	}
	// 825ABEA8: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825ABEAC: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825ABEB0: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825ABEB4: 7F1B5840  cmplw cr6, r27, r11
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825ABEB8: 41980008  blt cr6, 0x825abec0
	if ctx.cr[6].lt {
	pc = 0x825ABEC0; continue 'dispatch;
	}
	pc = 0x825ABEBC; continue 'dispatch;
            }
            0x825ABEBC => {
    //   block [0x825ABEBC..0x825ABEC0)
	// 825ABEBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825ABEC0; continue 'dispatch;
            }
            0x825ABEC0 => {
    //   block [0x825ABEC0..0x825ABEC8)
	// 825ABEC0: 7D7A182E  lwzx r11, r26, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[26].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825ABEC4: 83CB00E4  lwz r30, 0xe4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	pc = 0x825ABEC8; continue 'dispatch;
            }
            0x825ABEC8 => {
    //   block [0x825ABEC8..0x825ABF00)
	// 825ABEC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825ABECC: 419A00C4  beq cr6, 0x825abf90
	if ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABED0: 897E0044  lbz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825ABED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABED8: 409A00B8  bne cr6, 0x825abf90
	if !ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABEDC: 815E00EC  lwz r10, 0xec(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(236 as u32) ) } as u64;
	// 825ABEE0: 397E00E8  addi r11, r30, 0xe8
	ctx.r[11].s64 = ctx.r[30].s64 + 232;
	// 825ABEE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABEE8: 419A0024  beq cr6, 0x825abf0c
	if ctx.cr[6].eq {
	pc = 0x825ABF0C; continue 'dispatch;
	}
	// 825ABEEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABEF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825ABEF4: 419A000C  beq cr6, 0x825abf00
	if ctx.cr[6].eq {
	pc = 0x825ABF00; continue 'dispatch;
	}
	// 825ABEF8: 552B003E  slwi r11, r9, 0
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ABEFC: 48000014  b 0x825abf10
	pc = 0x825ABF10; continue 'dispatch;
            }
            0x825ABF00 => {
    //   block [0x825ABF00..0x825ABF0C)
	// 825ABF00: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825ABF04: 4BBE7F35  bl 0x82193e38
	ctx.lr = 0x825ABF08;
	sub_82193E38(ctx, base);
	// 825ABF08: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825ABF0C; continue 'dispatch;
            }
            0x825ABF0C => {
    //   block [0x825ABF0C..0x825ABF10)
	// 825ABF0C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825ABF10; continue 'dispatch;
            }
            0x825ABF10 => {
    //   block [0x825ABF10..0x825ABF2C)
	// 825ABF10: 7F0BB840  cmplw cr6, r11, r23
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[23].u32, &mut ctx.xer);
	// 825ABF14: 409A007C  bne cr6, 0x825abf90
	if !ctx.cr[6].eq {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABF18: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ABF1C: 7F3FCB78  mr r31, r25
	ctx.r[31].u64 = ctx.r[25].u64;
	// 825ABF20: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825ABF24: 4099006C  ble cr6, 0x825abf90
	if !ctx.cr[6].gt {
	pc = 0x825ABF90; continue 'dispatch;
	}
	// 825ABF28: 3BBE0074  addi r29, r30, 0x74
	ctx.r[29].s64 = ctx.r[30].s64 + 116;
	pc = 0x825ABF2C; continue 'dispatch;
            }
            0x825ABF2C => {
    //   block [0x825ABF2C..0x825ABF5C)
	// 825ABF2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABF30: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	// 825ABF34: 7F1F5800  cmpw cr6, r31, r11
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825ABF38: 40980028  bge cr6, 0x825abf60
	if !ctx.cr[6].lt {
	pc = 0x825ABF60; continue 'dispatch;
	}
	// 825ABF3C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ABF40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABF44: 419A001C  beq cr6, 0x825abf60
	if ctx.cr[6].eq {
	pc = 0x825ABF60; continue 'dispatch;
	}
	// 825ABF48: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ABF4C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825ABF50: 419A000C  beq cr6, 0x825abf5c
	if ctx.cr[6].eq {
	pc = 0x825ABF5C; continue 'dispatch;
	}
	// 825ABF54: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825ABF58: 409A0008  bne cr6, 0x825abf60
	if !ctx.cr[6].eq {
	pc = 0x825ABF60; continue 'dispatch;
	}
	pc = 0x825ABF5C; continue 'dispatch;
            }
            0x825ABF5C => {
    //   block [0x825ABF5C..0x825ABF60)
	// 825ABF5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x825ABF60; continue 'dispatch;
            }
            0x825ABF60 => {
    //   block [0x825ABF60..0x825ABF7C)
	// 825ABF60: 554B063E  clrlwi r11, r10, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825ABF64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABF68: 419A0014  beq cr6, 0x825abf7c
	if ctx.cr[6].eq {
	pc = 0x825ABF7C; continue 'dispatch;
	}
	// 825ABF6C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ABF70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ABF74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825ABF78: 4BFF7221  bl 0x825a3198
	ctx.lr = 0x825ABF7C;
	sub_825A3198(ctx, base);
	pc = 0x825ABF7C; continue 'dispatch;
            }
            0x825ABF7C => {
    //   block [0x825ABF7C..0x825ABF90)
	// 825ABF7C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825ABF80: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 825ABF84: 7F1FE000  cmpw cr6, r31, r28
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825ABF88: 4198FFA4  blt cr6, 0x825abf2c
	if ctx.cr[6].lt {
	pc = 0x825ABF2C; continue 'dispatch;
	}
	// 825ABF8C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825ABF90; continue 'dispatch;
            }
            0x825ABF90 => {
    //   block [0x825ABF90..0x825ABFA0)
	// 825ABF90: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825ABF94: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ABF98: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ABF9C: 4198FE98  blt cr6, 0x825abe34
	if ctx.cr[6].lt {
	pc = 0x825ABE34; continue 'dispatch;
	}
	pc = 0x825ABFA0; continue 'dispatch;
            }
            0x825ABFA0 => {
    //   block [0x825ABFA0..0x825ABFAC)
	// 825ABFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ABFA4: 419A0008  beq cr6, 0x825abfac
	if ctx.cr[6].eq {
	pc = 0x825ABFAC; continue 'dispatch;
	}
	// 825ABFA8: 4BC6FD91  bl 0x8221bd38
	ctx.lr = 0x825ABFAC;
	sub_8221BD38(ctx, base);
	pc = 0x825ABFAC; continue 'dispatch;
            }
            0x825ABFAC => {
    //   block [0x825ABFAC..0x825ABFB4)
	// 825ABFAC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825ABFB0: 486FD494  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ABFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ABFB8 size=396
    let mut pc: u32 = 0x825ABFB8;
    'dispatch: loop {
        match pc {
            0x825ABFB8 => {
    //   block [0x825ABFB8..0x825ABFEC)
	// 825ABFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ABFBC: 486FD44D  bl 0x82ca9408
	ctx.lr = 0x825ABFC0;
	sub_82CA93D0(ctx, base);
	// 825ABFC0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ABFC4: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825ABFC8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ABFCC: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825ABFD0: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825ABFD4: 419A0018  beq cr6, 0x825abfec
	if ctx.cr[6].eq {
	pc = 0x825ABFEC; continue 'dispatch;
	}
	// 825ABFD8: 89660090  lbz r11, 0x90(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(144 as u32) ) } as u64;
	// 825ABFDC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825ABFE0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825ABFE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ABFE8: 409A0008  bne cr6, 0x825abff0
	if !ctx.cr[6].eq {
	pc = 0x825ABFF0; continue 'dispatch;
	}
	pc = 0x825ABFEC; continue 'dispatch;
            }
            0x825ABFEC => {
    //   block [0x825ABFEC..0x825ABFF0)
	// 825ABFEC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825ABFF0; continue 'dispatch;
            }
            0x825ABFF0 => {
    //   block [0x825ABFF0..0x825AC058)
	// 825ABFF0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ABFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ABFF8: 419A0144  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825ABFFC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825AC000: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC004: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825AC008: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AC00C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AC010: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825AC014: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC018: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC01C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC020: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC024: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC028: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC02C: 4BF05F55  bl 0x824b1f80
	ctx.lr = 0x825AC030;
	sub_824B1F80(ctx, base);
	// 825AC030: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC034: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC038: 409900F8  ble cr6, 0x825ac130
	if !ctx.cr[6].gt {
	pc = 0x825AC130; continue 'dispatch;
	}
	// 825AC03C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC040: 419A00FC  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825AC044: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC048: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC04C: 7D7D1671  srawi. r29, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825AC050: 408100E0  ble 0x825ac130
	if !ctx.cr[0].gt {
	pc = 0x825AC130; continue 'dispatch;
	}
	// 825AC054: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x825AC058; continue 'dispatch;
            }
            0x825AC058 => {
    //   block [0x825AC058..0x825AC070)
	// 825AC058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC05C: 419A0014  beq cr6, 0x825ac070
	if ctx.cr[6].eq {
	pc = 0x825AC070; continue 'dispatch;
	}
	// 825AC060: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC064: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC068: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC06C: 41980008  blt cr6, 0x825ac074
	if ctx.cr[6].lt {
	pc = 0x825AC074; continue 'dispatch;
	}
	pc = 0x825AC070; continue 'dispatch;
            }
            0x825AC070 => {
    //   block [0x825AC070..0x825AC074)
	// 825AC070: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC074; continue 'dispatch;
            }
            0x825AC074 => {
    //   block [0x825AC074..0x825AC0B0)
	// 825AC074: 7C7E182E  lwzx r3, r30, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC078: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC07C: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825AC080: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC084: 4E800421  bctrl
	ctx.lr = 0x825AC088;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC088: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC08C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC090: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC094: 409A002C  bne cr6, 0x825ac0c0
	if !ctx.cr[6].eq {
	pc = 0x825AC0C0; continue 'dispatch;
	}
	// 825AC098: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC09C: 419A0014  beq cr6, 0x825ac0b0
	if ctx.cr[6].eq {
	pc = 0x825AC0B0; continue 'dispatch;
	}
	// 825AC0A0: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC0A4: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC0A8: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC0AC: 41980008  blt cr6, 0x825ac0b4
	if ctx.cr[6].lt {
	pc = 0x825AC0B4; continue 'dispatch;
	}
            }
            0x825AC0B0 => {
    //   block [0x825AC0B0..0x825AC0B4)
	// 825AC0B0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC0B4; continue 'dispatch;
            }
            0x825AC0B4 => {
    //   block [0x825AC0B4..0x825AC0C0)
	// 825AC0B4: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC0B8: 814B00C8  lwz r10, 0xc8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825AC0BC: 48000028  b 0x825ac0e4
	pc = 0x825AC0E4; continue 'dispatch;
            }
            0x825AC0C0 => {
    //   block [0x825AC0C0..0x825AC0D8)
	// 825AC0C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC0C4: 419A0014  beq cr6, 0x825ac0d8
	if ctx.cr[6].eq {
	pc = 0x825AC0D8; continue 'dispatch;
	}
	// 825AC0C8: 7D634850  subf r11, r3, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC0CC: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC0D0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC0D4: 41980008  blt cr6, 0x825ac0dc
	if ctx.cr[6].lt {
	pc = 0x825AC0DC; continue 'dispatch;
	}
	pc = 0x825AC0D8; continue 'dispatch;
            }
            0x825AC0D8 => {
    //   block [0x825AC0D8..0x825AC0DC)
	// 825AC0D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC0DC; continue 'dispatch;
            }
            0x825AC0DC => {
    //   block [0x825AC0DC..0x825AC0E4)
	// 825AC0DC: 7D7E182E  lwzx r11, r30, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC0E0: 814B00E4  lwz r10, 0xe4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	pc = 0x825AC0E4; continue 'dispatch;
            }
            0x825AC0E4 => {
    //   block [0x825AC0E4..0x825AC110)
	// 825AC0E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC0E8: 419A0038  beq cr6, 0x825ac120
	if ctx.cr[6].eq {
	pc = 0x825AC120; continue 'dispatch;
	}
	// 825AC0EC: 894A0044  lbz r10, 0x44(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC0F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC0F4: 409A002C  bne cr6, 0x825ac120
	if !ctx.cr[6].eq {
	pc = 0x825AC120; continue 'dispatch;
	}
	// 825AC0F8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC0FC: 419A0014  beq cr6, 0x825ac110
	if ctx.cr[6].eq {
	pc = 0x825AC110; continue 'dispatch;
	}
	// 825AC100: 7D434850  subf r10, r3, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[3].s64;
	// 825AC104: 7D4A1670  srawi r10, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825AC108: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC10C: 41980008  blt cr6, 0x825ac114
	if ctx.cr[6].lt {
	pc = 0x825AC114; continue 'dispatch;
	}
	pc = 0x825AC110; continue 'dispatch;
            }
            0x825AC110 => {
    //   block [0x825AC110..0x825AC114)
	// 825AC110: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC114; continue 'dispatch;
            }
            0x825AC114 => {
    //   block [0x825AC114..0x825AC120)
	// 825AC114: 9B8B0048  stb r28, 0x48(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(72 as u32), ctx.r[28].u8 ) };
	// 825AC118: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC11C: 80610054  lwz r3, 0x54(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825AC120; continue 'dispatch;
            }
            0x825AC120 => {
    //   block [0x825AC120..0x825AC130)
	// 825AC120: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825AC124: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825AC128: 7F1FE800  cmpw cr6, r31, r29
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[29].s32, &mut ctx.xer);
	// 825AC12C: 4198FF2C  blt cr6, 0x825ac058
	if ctx.cr[6].lt {
	pc = 0x825AC058; continue 'dispatch;
	}
	pc = 0x825AC130; continue 'dispatch;
            }
            0x825AC130 => {
    //   block [0x825AC130..0x825AC13C)
	// 825AC130: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC134: 419A0008  beq cr6, 0x825ac13c
	if ctx.cr[6].eq {
	pc = 0x825AC13C; continue 'dispatch;
	}
	// 825AC138: 4BC6FC01  bl 0x8221bd38
	ctx.lr = 0x825AC13C;
	sub_8221BD38(ctx, base);
	pc = 0x825AC13C; continue 'dispatch;
            }
            0x825AC13C => {
    //   block [0x825AC13C..0x825AC144)
	// 825AC13C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AC140: 486FD318  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC148(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC148 size=280
    let mut pc: u32 = 0x825AC148;
    'dispatch: loop {
        match pc {
            0x825AC148 => {
    //   block [0x825AC148..0x825AC18C)
	// 825AC148: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC14C: 486FD2AD  bl 0x82ca93f8
	ctx.lr = 0x825AC150;
	sub_82CA93D0(ctx, base);
	// 825AC150: DBE1FFB0  stfd f31, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825AC154: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC158: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825AC15C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825AC160: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC164: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825AC168: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825AC16C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825AC170: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825AC174: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 825AC178: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 825AC17C: 4804EE1D  bl 0x825faf98
	ctx.lr = 0x825AC180;
	sub_825FAF98(ctx, base);
	// 825AC180: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC184: 409A0008  bne cr6, 0x825ac18c
	if !ctx.cr[6].eq {
	pc = 0x825AC18C; continue 'dispatch;
	}
	// 825AC188: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	pc = 0x825AC18C; continue 'dispatch;
            }
            0x825AC18C => {
    //   block [0x825AC18C..0x825AC250)
	// 825AC18C: 39010054  addi r8, r1, 0x54
	ctx.r[8].s64 = ctx.r[1].s64 + 84;
	// 825AC190: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	// 825AC194: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 825AC198: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825AC19C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1A0: 48055249  bl 0x826013e8
	ctx.lr = 0x825AC1A4;
	sub_826013E8(ctx, base);
	// 825AC1A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC1A8: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825AC1AC: 394B9484  addi r10, r11, -0x6b7c
	ctx.r[10].s64 = ctx.r[11].s64 + -27516;
	// 825AC1B0: 5729063E  clrlwi r9, r25, 0x18
	ctx.r[9].u64 = ctx.r[25].u32 as u64 & 0x000000FFu64;
	// 825AC1B4: C3EB9484  lfs f31, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AC1B8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AC1BC: D3FD0000  stfs f31, 0(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1C0: C00A000C  lfs f0, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AC1C4: D01C0000  stfs f0, 0(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1C8: D01B0000  stfs f0, 0(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1CC: 419A0084  beq cr6, 0x825ac250
	if ctx.cr[6].eq {
	pc = 0x825AC250; continue 'dispatch;
	}
	// 825AC1D0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC1D4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AC1D8: 419A0078  beq cr6, 0x825ac250
	if ctx.cr[6].eq {
	pc = 0x825AC250; continue 'dispatch;
	}
	// 825AC1DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC1E0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC1E8: 48339FA9  bl 0x828e6190
	ctx.lr = 0x825AC1EC;
	sub_828E6190(ctx, base);
	// 825AC1EC: D03C0000  stfs f1, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC1F0: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC1F4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC1F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC1FC: 48339F2D  bl 0x828e6128
	ctx.lr = 0x825AC200;
	sub_828E6128(ctx, base);
	// 825AC200: D03B0000  stfs f1, 0(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC204: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AC208: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC20C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AC210: 48339FF1  bl 0x828e6200
	ctx.lr = 0x825AC214;
	sub_828E6200(ctx, base);
	// 825AC214: D03D0000  stfs f1, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC218: 9B010050  stb r24, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u8 ) };
	// 825AC21C: 38A10051  addi r5, r1, 0x51
	ctx.r[5].s64 = ctx.r[1].s64 + 81;
	// 825AC220: 9B010051  stb r24, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[24].u8 ) };
	// 825AC224: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AC228: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825AC22C: 480511FD  bl 0x825fd428
	ctx.lr = 0x825AC230;
	sub_825FD428(ctx, base);
	// 825AC230: 89410050  lbz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC234: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825AC238: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC23C: 419A0018  beq cr6, 0x825ac254
	if ctx.cr[6].eq {
	pc = 0x825AC254; continue 'dispatch;
	}
	// 825AC240: D3FD0000  stfs f31, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AC244: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC248: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825AC24C: 486FD1FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AC250 => {
    //   block [0x825AC250..0x825AC254)
	// 825AC250: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	pc = 0x825AC254; continue 'dispatch;
            }
            0x825AC254 => {
    //   block [0x825AC254..0x825AC260)
	// 825AC254: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC258: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825AC25C: 486FD1EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC260 size=132
    let mut pc: u32 = 0x825AC260;
    'dispatch: loop {
        match pc {
            0x825AC260 => {
    //   block [0x825AC260..0x825AC2E4)
	// 825AC260: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC264: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC268: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC26C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC270: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825AC274: 11A1104A  vsubfp v13, v1, v2
	ctx.fpscr.enable_flush_mode_unconditional();
	for i in 0..4 {
		ctx.v[13].f32[i] = ctx.v[1].f32[i] - ctx.v[2].f32[i];
	}
	// 825AC278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC27C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 825AC280: 392B90F0  addi r9, r11, -0x6f10
	ctx.r[9].s64 = ctx.r[11].s64 + -28432;
	// 825AC284: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC2E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AC2E8 size=252
    let mut pc: u32 = 0x825AC2E8;
    'dispatch: loop {
        match pc {
            0x825AC2E8 => {
    //   block [0x825AC2E8..0x825AC3E4)
	// 825AC2E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC2EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC2F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC2F4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825AC2F8: 3980FFD0  li r12, -0x30
	ctx.r[12].s64 = -48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC3E8 size=172
    let mut pc: u32 = 0x825AC3E8;
    'dispatch: loop {
        match pc {
            0x825AC3E8 => {
    //   block [0x825AC3E8..0x825AC420)
	// 825AC3E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC3EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC3F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC3F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC3F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC3FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC400: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC404: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AC408: 419A0018  beq cr6, 0x825ac420
	if ctx.cr[6].eq {
	pc = 0x825AC420; continue 'dispatch;
	}
	// 825AC40C: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AC410: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AC414: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC418: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC41C: 409A0008  bne cr6, 0x825ac424
	if !ctx.cr[6].eq {
	pc = 0x825AC424; continue 'dispatch;
	}
	pc = 0x825AC420; continue 'dispatch;
            }
            0x825AC420 => {
    //   block [0x825AC420..0x825AC424)
	// 825AC420: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AC424; continue 'dispatch;
            }
            0x825AC424 => {
    //   block [0x825AC424..0x825AC470)
	// 825AC424: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC42C: 419A0050  beq cr6, 0x825ac47c
	if ctx.cr[6].eq {
	pc = 0x825AC47C; continue 'dispatch;
	}
	// 825AC430: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC434: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AC438: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 825AC43C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC440: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC444: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC448: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC44C: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC450: 4BC86329  bl 0x82232778
	ctx.lr = 0x825AC454;
	sub_82232778(ctx, base);
	// 825AC454: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AC458: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC45C: 409A0014  bne cr6, 0x825ac470
	if !ctx.cr[6].eq {
	pc = 0x825AC470; continue 'dispatch;
	}
	// 825AC460: 817F0034  lwz r11, 0x34(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 825AC464: 556A0FFE  srwi r10, r11, 0x1f
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shr(31);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825AC468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AC46C: 419A000C  beq cr6, 0x825ac478
	if ctx.cr[6].eq {
	pc = 0x825AC478; continue 'dispatch;
	}
	pc = 0x825AC470; continue 'dispatch;
            }
            0x825AC470 => {
    //   block [0x825AC470..0x825AC478)
	// 825AC470: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AC474: 48000008  b 0x825ac47c
	pc = 0x825AC47C; continue 'dispatch;
            }
            0x825AC478 => {
    //   block [0x825AC478..0x825AC47C)
	// 825AC478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	pc = 0x825AC47C; continue 'dispatch;
            }
            0x825AC47C => {
    //   block [0x825AC47C..0x825AC494)
	// 825AC47C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC480: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC484: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC488: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC48C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC490: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC498 size=444
    let mut pc: u32 = 0x825AC498;
    'dispatch: loop {
        match pc {
            0x825AC498 => {
    //   block [0x825AC498..0x825AC52C)
	// 825AC498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC49C: 486FCF69  bl 0x82ca9404
	ctx.lr = 0x825AC4A0;
	sub_82CA93D0(ctx, base);
	// 825AC4A0: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825AC4A4: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC4A8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825AC4AC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AC4B0: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825AC4B4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825AC4B8: C3EB923C  lfs f31, -0x6dc4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28100 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825AC4BC: C00A9484  lfs f0, -0x6b7c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AC4C0: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 825AC4C4: 40990184  ble cr6, 0x825ac648
	if !ctx.cr[6].gt {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC4C8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AC4CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AC4D0: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825AC4D4: 38E10060  addi r7, r1, 0x60
	ctx.r[7].s64 = ctx.r[1].s64 + 96;
	// 825AC4D8: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825AC4DC: 38A0FFFE  li r5, -2
	ctx.r[5].s64 = -2;
	// 825AC4E0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825AC4E4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AC4E8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AC4EC: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AC4F0: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AC4F4: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC4F8: 80680044  lwz r3, 0x44(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC4FC: 4BF05A85  bl 0x824b1f80
	ctx.lr = 0x825AC500;
	sub_824B1F80(ctx, base);
	// 825AC500: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC504: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC508: 40990134  ble cr6, 0x825ac63c
	if !ctx.cr[6].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC50C: 7FFDFB78  mr r29, r31
	ctx.r[29].u64 = ctx.r[31].u64;
	// 825AC510: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825AC514: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC518: 419A0130  beq cr6, 0x825ac648
	if ctx.cr[6].eq {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC51C: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC520: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC524: 7D7C1671  srawi. r28, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[28].s64 = (ctx.r[11].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 825AC528: 40810114  ble 0x825ac63c
	if !ctx.cr[0].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	pc = 0x825AC52C; continue 'dispatch;
            }
            0x825AC52C => {
    //   block [0x825AC52C..0x825AC544)
	// 825AC52C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC530: 419A0014  beq cr6, 0x825ac544
	if ctx.cr[6].eq {
	pc = 0x825AC544; continue 'dispatch;
	}
	// 825AC534: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC538: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC53C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC540: 41980008  blt cr6, 0x825ac548
	if ctx.cr[6].lt {
	pc = 0x825AC548; continue 'dispatch;
	}
	pc = 0x825AC544; continue 'dispatch;
            }
            0x825AC544 => {
    //   block [0x825AC544..0x825AC548)
	// 825AC544: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC548; continue 'dispatch;
            }
            0x825AC548 => {
    //   block [0x825AC548..0x825AC584)
	// 825AC548: 7C7F182E  lwzx r3, r31, r3
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC54C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC550: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825AC554: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC558: 4E800421  bctrl
	ctx.lr = 0x825AC55C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC55C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AC560: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC564: 81410068  lwz r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC568: 409A002C  bne cr6, 0x825ac594
	if !ctx.cr[6].eq {
	pc = 0x825AC594; continue 'dispatch;
	}
	// 825AC56C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC570: 419A0014  beq cr6, 0x825ac584
	if ctx.cr[6].eq {
	pc = 0x825AC584; continue 'dispatch;
	}
	// 825AC574: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC578: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC57C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC580: 41980008  blt cr6, 0x825ac588
	if ctx.cr[6].lt {
	pc = 0x825AC588; continue 'dispatch;
	}
            }
            0x825AC584 => {
    //   block [0x825AC584..0x825AC588)
	// 825AC584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC588; continue 'dispatch;
            }
            0x825AC588 => {
    //   block [0x825AC588..0x825AC594)
	// 825AC588: 7D7F182E  lwzx r11, r31, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC58C: 816B00C8  lwz r11, 0xc8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(200 as u32) ) } as u64;
	// 825AC590: 48000028  b 0x825ac5b8
	pc = 0x825AC5B8; continue 'dispatch;
            }
            0x825AC594 => {
    //   block [0x825AC594..0x825AC5AC)
	// 825AC594: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC598: 419A0014  beq cr6, 0x825ac5ac
	if ctx.cr[6].eq {
	pc = 0x825AC5AC; continue 'dispatch;
	}
	// 825AC59C: 7D635050  subf r11, r3, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[3].s64;
	// 825AC5A0: 7D6B1670  srawi r11, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825AC5A4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825AC5A8: 41980008  blt cr6, 0x825ac5b0
	if ctx.cr[6].lt {
	pc = 0x825AC5B0; continue 'dispatch;
	}
	pc = 0x825AC5AC; continue 'dispatch;
            }
            0x825AC5AC => {
    //   block [0x825AC5AC..0x825AC5B0)
	// 825AC5AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AC5B0; continue 'dispatch;
            }
            0x825AC5B0 => {
    //   block [0x825AC5B0..0x825AC5B8)
	// 825AC5B0: 7D7F182E  lwzx r11, r31, r3
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[3].u32)) } as u64;
	// 825AC5B4: 816B00E4  lwz r11, 0xe4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(228 as u32) ) } as u64;
	pc = 0x825AC5B8; continue 'dispatch;
            }
            0x825AC5B8 => {
    //   block [0x825AC5B8..0x825AC5E4)
	// 825AC5B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC5BC: 419A0028  beq cr6, 0x825ac5e4
	if ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5C0: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825AC5C4: 419A0020  beq cr6, 0x825ac5e4
	if ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5C8: 892B0044  lbz r9, 0x44(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(68 as u32) ) } as u64;
	// 825AC5CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AC5D0: 409A0014  bne cr6, 0x825ac5e4
	if !ctx.cr[6].eq {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5D4: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC5D8: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825AC5DC: 40980008  bge cr6, 0x825ac5e4
	if !ctx.cr[6].lt {
	pc = 0x825AC5E4; continue 'dispatch;
	}
	// 825AC5E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	pc = 0x825AC5E4; continue 'dispatch;
            }
            0x825AC5E4 => {
    //   block [0x825AC5E4..0x825AC63C)
	// 825AC5E4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825AC5E8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825AC5EC: 7F1EE000  cmpw cr6, r30, r28
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[28].s32, &mut ctx.xer);
	// 825AC5F0: 4198FF3C  blt cr6, 0x825ac52c
	if ctx.cr[6].lt {
	pc = 0x825AC52C; continue 'dispatch;
	}
	// 825AC5F4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825AC5F8: 40990044  ble cr6, 0x825ac63c
	if !ctx.cr[6].gt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC5FC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825AC600: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825AC604: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825AC608: C80A9660  lfd f0, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825AC60C: 7D3D5850  subf r9, r29, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[29].s64;
	// 825AC610: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 825AC614: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825AC618: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC61C: FD806E9C  fcfid f12, f13
	ctx.f[12].f64 = (ctx.f[13].s64 as f64);
	// 825AC620: FD606018  frsp f11, f12
	ctx.f[11].f64 = (ctx.f[12].f64 as f32) as f64;
	// 825AC624: FD4B0024  fdiv f10, f11, f0
	ctx.f[10].f64 = ctx.f[11].f64 / ctx.f[0].f64;
	// 825AC628: FC005018  frsp f0, f10
	ctx.f[0].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825AC62C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 825AC630: 4098000C  bge cr6, 0x825ac63c
	if !ctx.cr[6].lt {
	pc = 0x825AC63C; continue 'dispatch;
	}
	// 825AC634: EC00F824  fdivs f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[31].f64) as f32) as f64;
	// 825AC638: D01B0040  stfs f0, 0x40(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x825AC63C; continue 'dispatch;
            }
            0x825AC63C => {
    //   block [0x825AC63C..0x825AC648)
	// 825AC63C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC640: 419A0008  beq cr6, 0x825ac648
	if ctx.cr[6].eq {
	pc = 0x825AC648; continue 'dispatch;
	}
	// 825AC644: 4BC6F6F5  bl 0x8221bd38
	ctx.lr = 0x825AC648;
	sub_8221BD38(ctx, base);
	pc = 0x825AC648; continue 'dispatch;
            }
            0x825AC648 => {
    //   block [0x825AC648..0x825AC654)
	// 825AC648: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825AC64C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825AC650: 486FCE04  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC658(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC658 size=328
    let mut pc: u32 = 0x825AC658;
    'dispatch: loop {
        match pc {
            0x825AC658 => {
    //   block [0x825AC658..0x825AC690)
	// 825AC658: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC65C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC660: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC664: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC668: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC66C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC670: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC674: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AC678: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC67C: 41980014  blt cr6, 0x825ac690
	if ctx.cr[6].lt {
	pc = 0x825AC690; continue 'dispatch;
	}
	// 825AC680: 4BCEC0B9  bl 0x82298738
	ctx.lr = 0x825AC684;
	sub_82298738(ctx, base);
	// 825AC684: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC688: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC68C: 409A0008  bne cr6, 0x825ac694
	if !ctx.cr[6].eq {
	pc = 0x825AC694; continue 'dispatch;
	}
	pc = 0x825AC690; continue 'dispatch;
            }
            0x825AC690 => {
    //   block [0x825AC690..0x825AC694)
	// 825AC690: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AC694; continue 'dispatch;
            }
            0x825AC694 => {
    //   block [0x825AC694..0x825AC6D4)
	// 825AC694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC69C: 419A00E8  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC6A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC6A4: 4BD1AD85  bl 0x822c7428
	ctx.lr = 0x825AC6A8;
	sub_822C7428(ctx, base);
	// 825AC6A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC6AC: 419A00D8  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC6B0: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC6B4: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825AC6B8: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC6BC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC6C0: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 825AC6C4: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AC6C8: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC6CC: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC6D0: 4081005C  ble 0x825ac72c
	if !ctx.cr[0].gt {
	pc = 0x825AC72C; continue 'dispatch;
	}
	pc = 0x825AC6D4; continue 'dispatch;
            }
            0x825AC6D4 => {
    //   block [0x825AC6D4..0x825AC6FC)
	// 825AC6D4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AC6D8: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC6DC: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AC6E0: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC6E4: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825AC6E8: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC6EC: 2F070002  cmpwi cr6, r7, 2
	ctx.cr[6].compare_i32(ctx.r[7].s32, 2, &mut ctx.xer);
	// 825AC6F0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AC6F4: 41980008  blt cr6, 0x825ac6fc
	if ctx.cr[6].lt {
	pc = 0x825AC6FC; continue 'dispatch;
	}
	// 825AC6F8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825AC6FC; continue 'dispatch;
            }
            0x825AC6FC => {
    //   block [0x825AC6FC..0x825AC718)
	// 825AC6FC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AC700: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC704: 419A0014  beq cr6, 0x825ac718
	if ctx.cr[6].eq {
	pc = 0x825AC718; continue 'dispatch;
	}
	// 825AC708: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825AC70C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825AC710: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AC714: 4800000C  b 0x825ac720
	pc = 0x825AC720; continue 'dispatch;
            }
            0x825AC718 => {
    //   block [0x825AC718..0x825AC720)
	// 825AC718: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825AC71C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x825AC720; continue 'dispatch;
            }
            0x825AC720 => {
    //   block [0x825AC720..0x825AC72C)
	// 825AC720: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC724: 4199FFB0  bgt cr6, 0x825ac6d4
	if ctx.cr[6].gt {
	pc = 0x825AC6D4; continue 'dispatch;
	}
	// 825AC728: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x825AC72C; continue 'dispatch;
            }
            0x825AC72C => {
    //   block [0x825AC72C..0x825AC748)
	// 825AC72C: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AC730: 419A0034  beq cr6, 0x825ac764
	if ctx.cr[6].eq {
	pc = 0x825AC764; continue 'dispatch;
	}
	// 825AC734: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC738: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825AC73C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC740: 41990008  bgt cr6, 0x825ac748
	if ctx.cr[6].gt {
	pc = 0x825AC748; continue 'dispatch;
	}
	// 825AC744: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AC748; continue 'dispatch;
            }
            0x825AC748 => {
    //   block [0x825AC748..0x825AC764)
	// 825AC748: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC74C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC750: 409A0014  bne cr6, 0x825ac764
	if !ctx.cr[6].eq {
	pc = 0x825AC764; continue 'dispatch;
	}
	// 825AC754: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC758: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AC75C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC760: 48000008  b 0x825ac768
	pc = 0x825AC768; continue 'dispatch;
            }
            0x825AC764 => {
    //   block [0x825AC764..0x825AC768)
	// 825AC764: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825AC768; continue 'dispatch;
            }
            0x825AC768 => {
    //   block [0x825AC768..0x825AC784)
	// 825AC768: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC76C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC770: 419A0014  beq cr6, 0x825ac784
	if ctx.cr[6].eq {
	pc = 0x825AC784; continue 'dispatch;
	}
	// 825AC774: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC778: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825AC77C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AC780: 48000008  b 0x825ac788
	pc = 0x825AC788; continue 'dispatch;
            }
            0x825AC784 => {
    //   block [0x825AC784..0x825AC788)
	// 825AC784: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x825AC788; continue 'dispatch;
            }
            0x825AC788 => {
    //   block [0x825AC788..0x825AC7A0)
	// 825AC788: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC78C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC790: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC794: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC798: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC79C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AC7A0 size=328
    let mut pc: u32 = 0x825AC7A0;
    'dispatch: loop {
        match pc {
            0x825AC7A0 => {
    //   block [0x825AC7A0..0x825AC7D8)
	// 825AC7A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC7A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AC7A8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AC7AC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AC7B0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC7B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AC7B8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AC7BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AC7C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC7C4: 41980014  blt cr6, 0x825ac7d8
	if ctx.cr[6].lt {
	pc = 0x825AC7D8; continue 'dispatch;
	}
	// 825AC7C8: 4BCEBF71  bl 0x82298738
	ctx.lr = 0x825AC7CC;
	sub_82298738(ctx, base);
	// 825AC7CC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC7D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC7D4: 409A0008  bne cr6, 0x825ac7dc
	if !ctx.cr[6].eq {
	pc = 0x825AC7DC; continue 'dispatch;
	}
	pc = 0x825AC7D8; continue 'dispatch;
            }
            0x825AC7D8 => {
    //   block [0x825AC7D8..0x825AC7DC)
	// 825AC7D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AC7DC; continue 'dispatch;
            }
            0x825AC7DC => {
    //   block [0x825AC7DC..0x825AC81C)
	// 825AC7DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC7E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC7E4: 419A00E8  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC7EC: 4BD1AC3D  bl 0x822c7428
	ctx.lr = 0x825AC7F0;
	sub_822C7428(ctx, base);
	// 825AC7F0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AC7F4: 419A00D8  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC7F8: 81230018  lwz r9, 0x18(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825AC7FC: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825AC800: 80C3001C  lwz r6, 0x1c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC808: 7D093050  subf r8, r9, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 825AC80C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AC810: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AC814: 7D685BD7  divw. r11, r8, r11
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[11].s32;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC818: 4081005C  ble 0x825ac874
	if !ctx.cr[0].gt {
	pc = 0x825AC874; continue 'dispatch;
	}
	pc = 0x825AC81C; continue 'dispatch;
            }
            0x825AC81C => {
    //   block [0x825AC81C..0x825AC844)
	// 825AC81C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AC820: 5548083C  slwi r8, r10, 1
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC824: 7D0A4214  add r8, r10, r8
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AC828: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AC82C: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825AC830: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC834: 2F070004  cmpwi cr6, r7, 4
	ctx.cr[6].compare_i32(ctx.r[7].s32, 4, &mut ctx.xer);
	// 825AC838: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AC83C: 41980008  blt cr6, 0x825ac844
	if ctx.cr[6].lt {
	pc = 0x825AC844; continue 'dispatch;
	}
	// 825AC840: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825AC844; continue 'dispatch;
            }
            0x825AC844 => {
    //   block [0x825AC844..0x825AC860)
	// 825AC844: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AC848: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AC84C: 419A0014  beq cr6, 0x825ac860
	if ctx.cr[6].eq {
	pc = 0x825AC860; continue 'dispatch;
	}
	// 825AC850: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825AC854: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825AC858: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AC85C: 4800000C  b 0x825ac868
	pc = 0x825AC868; continue 'dispatch;
            }
            0x825AC860 => {
    //   block [0x825AC860..0x825AC868)
	// 825AC860: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825AC864: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x825AC868; continue 'dispatch;
            }
            0x825AC868 => {
    //   block [0x825AC868..0x825AC874)
	// 825AC868: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AC86C: 4199FFB0  bgt cr6, 0x825ac81c
	if ctx.cr[6].gt {
	pc = 0x825AC81C; continue 'dispatch;
	}
	// 825AC870: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	pc = 0x825AC874; continue 'dispatch;
            }
            0x825AC874 => {
    //   block [0x825AC874..0x825AC890)
	// 825AC874: 7F093040  cmplw cr6, r9, r6
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AC878: 419A0034  beq cr6, 0x825ac8ac
	if ctx.cr[6].eq {
	pc = 0x825AC8AC; continue 'dispatch;
	}
	// 825AC87C: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC880: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825AC884: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AC888: 41990008  bgt cr6, 0x825ac890
	if ctx.cr[6].gt {
	pc = 0x825AC890; continue 'dispatch;
	}
	// 825AC88C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AC890; continue 'dispatch;
            }
            0x825AC890 => {
    //   block [0x825AC890..0x825AC8AC)
	// 825AC890: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AC894: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC898: 409A0014  bne cr6, 0x825ac8ac
	if !ctx.cr[6].eq {
	pc = 0x825AC8AC; continue 'dispatch;
	}
	// 825AC89C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AC8A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AC8A4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AC8A8: 48000008  b 0x825ac8b0
	pc = 0x825AC8B0; continue 'dispatch;
            }
            0x825AC8AC => {
    //   block [0x825AC8AC..0x825AC8B0)
	// 825AC8AC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825AC8B0; continue 'dispatch;
            }
            0x825AC8B0 => {
    //   block [0x825AC8B0..0x825AC8CC)
	// 825AC8B0: 8143001C  lwz r10, 0x1c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825AC8B4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AC8B8: 419A0014  beq cr6, 0x825ac8cc
	if ctx.cr[6].eq {
	pc = 0x825AC8CC; continue 'dispatch;
	}
	// 825AC8BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC8C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825AC8C4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AC8C8: 48000008  b 0x825ac8d0
	pc = 0x825AC8D0; continue 'dispatch;
            }
            0x825AC8CC => {
    //   block [0x825AC8CC..0x825AC8D0)
	// 825AC8CC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x825AC8D0; continue 'dispatch;
            }
            0x825AC8D0 => {
    //   block [0x825AC8D0..0x825AC8E8)
	// 825AC8D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AC8D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AC8D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AC8DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AC8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AC8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AC8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AC8E8 size=328
    let mut pc: u32 = 0x825AC8E8;
    'dispatch: loop {
        match pc {
            0x825AC8E8 => {
    //   block [0x825AC8E8..0x825AC93C)
	// 825AC8E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AC8EC: 486FCB21  bl 0x82ca940c
	ctx.lr = 0x825AC8F0;
	sub_82CA93D0(ctx, base);
	// 825AC8F0: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AC8F4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AC8F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AC8FC: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825AC900: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AC904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AC908: 40990120  ble cr6, 0x825aca28
	if !ctx.cr[6].gt {
	pc = 0x825ACA28; continue 'dispatch;
	}
	// 825AC90C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AC914: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AC918: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC91C: 4E800421  bctrl
	ctx.lr = 0x825AC920;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC920: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825AC924: B0610068  sth r3, 0x68(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[3].u16 ) };
	// 825AC928: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825AC92C: 419A0010  beq cr6, 0x825ac93c
	if ctx.cr[6].eq {
	pc = 0x825AC93C; continue 'dispatch;
	}
	// 825AC930: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AC934: 93C1006C  stw r30, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 825AC938: 48000010  b 0x825ac948
	pc = 0x825AC948; continue 'dispatch;
            }
            0x825AC93C => {
    //   block [0x825AC93C..0x825AC948)
	// 825AC93C: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825AC940: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825AC944: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x825AC948; continue 'dispatch;
            }
            0x825AC948 => {
    //   block [0x825AC948..0x825ACA28)
	// 825AC948: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825AC94C: 99410070  stb r10, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u8 ) };
	// 825AC950: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825AC954: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825AC958: 486DB689  bl 0x82c87fe0
	ctx.lr = 0x825AC95C;
	sub_82C87FE0(ctx, base);
	// 825AC95C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AC960: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AC964: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825AC968: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825AC96C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825AC970: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC974: 486DB62D  bl 0x82c87fa0
	ctx.lr = 0x825AC978;
	sub_82C87FA0(ctx, base);
	// 825AC978: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AC97C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC980: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825AC984: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825AC988: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825AC98C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC990: 4BD5D1A9  bl 0x82309b38
	ctx.lr = 0x825AC994;
	sub_82309B38(ctx, base);
	// 825AC994: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC998: 889F0004  lbz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AC99C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9A4: 80C70088  lwz r6, 0x88(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(136 as u32) ) } as u64;
	// 825AC9A8: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825AC9AC: 4E800421  bctrl
	ctx.lr = 0x825AC9B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC9B0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9B4: 389F0010  addi r4, r31, 0x10
	ctx.r[4].s64 = ctx.r[31].s64 + 16;
	// 825AC9B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9BC: 4BDA21DD  bl 0x8234eb98
	ctx.lr = 0x825AC9C0;
	sub_8234EB98(ctx, base);
	// 825AC9C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9C4: 389F0020  addi r4, r31, 0x20
	ctx.r[4].s64 = ctx.r[31].s64 + 32;
	// 825AC9C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9CC: 4BDA21CD  bl 0x8234eb98
	ctx.lr = 0x825AC9D0;
	sub_8234EB98(ctx, base);
	// 825AC9D0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC9D4: E89F0030  ld r4, 0x30(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	// 825AC9D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9E0: 814B0068  lwz r10, 0x68(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AC9E4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AC9E8: 4E800421  bctrl
	ctx.lr = 0x825AC9EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AC9EC: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AC9F0: C03F0038  lfs f1, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825AC9F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AC9F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AC9FC: 81090064  lwz r8, 0x64(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACA00: 7D0903A6  mtctr r8
	ctx.ctr.u64 = ctx.r[8].u64;
	// 825ACA04: 4E800421  bctrl
	ctx.lr = 0x825ACA08;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACA08: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ACA0C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825ACA10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ACA14: 4BD88A65  bl 0x82335478
	ctx.lr = 0x825ACA18;
	sub_82335478(ctx, base);
	// 825ACA18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825ACA1C: 485EA45D  bl 0x82b96e78
	ctx.lr = 0x825ACA20;
	sub_82B96E78(ctx, base);
	// 825ACA20: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACA24: 485EA455  bl 0x82b96e78
	ctx.lr = 0x825ACA28;
	sub_82B96E78(ctx, base);
            }
            0x825ACA28 => {
    //   block [0x825ACA28..0x825ACA30)
	// 825ACA28: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825ACA2C: 486FCA30  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACA30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ACA30 size=240
    let mut pc: u32 = 0x825ACA30;
    'dispatch: loop {
        match pc {
            0x825ACA30 => {
    //   block [0x825ACA30..0x825ACA84)
	// 825ACA30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACA34: 486FC9D9  bl 0x82ca940c
	ctx.lr = 0x825ACA38;
	sub_82CA93D0(ctx, base);
	// 825ACA38: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACA3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825ACA40: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825ACA44: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825ACA48: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACA4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACA50: 409900C8  ble cr6, 0x825acb18
	if !ctx.cr[6].gt {
	pc = 0x825ACB18; continue 'dispatch;
	}
	// 825ACA54: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACA58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACA5C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACA60: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825ACA64: 4E800421  bctrl
	ctx.lr = 0x825ACA68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACA68: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825ACA6C: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 825ACA70: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825ACA74: 419A0010  beq cr6, 0x825aca84
	if ctx.cr[6].eq {
	pc = 0x825ACA84; continue 'dispatch;
	}
	// 825ACA78: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825ACA7C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825ACA80: 48000010  b 0x825aca90
	pc = 0x825ACA90; continue 'dispatch;
            }
            0x825ACA84 => {
    //   block [0x825ACA84..0x825ACA90)
	// 825ACA84: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825ACA88: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ACA8C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x825ACA90; continue 'dispatch;
            }
            0x825ACA90 => {
    //   block [0x825ACA90..0x825ACB18)
	// 825ACA90: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825ACA94: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825ACA98: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825ACA9C: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACAA0: 486DB541  bl 0x82c87fe0
	ctx.lr = 0x825ACAA4;
	sub_82C87FE0(ctx, base);
	// 825ACAA4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825ACAA8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825ACAAC: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825ACAB0: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825ACAB4: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825ACAB8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACABC: 486DB4E5  bl 0x82c87fa0
	ctx.lr = 0x825ACAC0;
	sub_82C87FA0(ctx, base);
	// 825ACAC0: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825ACAC4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ACAC8: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825ACACC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ACAD0: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825ACAD4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACAD8: 4BD5D061  bl 0x82309b38
	ctx.lr = 0x825ACADC;
	sub_82309B38(ctx, base);
	// 825ACADC: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACAE0: 889F0004  lbz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACAE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825ACAE8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACAEC: 80C70088  lwz r6, 0x88(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(136 as u32) ) } as u64;
	// 825ACAF0: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825ACAF4: 4E800421  bctrl
	ctx.lr = 0x825ACAF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825ACAF8: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825ACAFC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825ACB00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825ACB04: 4BD88975  bl 0x82335478
	ctx.lr = 0x825ACB08;
	sub_82335478(ctx, base);
	// 825ACB08: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825ACB0C: 485EA36D  bl 0x82b96e78
	ctx.lr = 0x825ACB10;
	sub_82B96E78(ctx, base);
	// 825ACB10: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825ACB14: 485EA365  bl 0x82b96e78
	ctx.lr = 0x825ACB18;
	sub_82B96E78(ctx, base);
            }
            0x825ACB18 => {
    //   block [0x825ACB18..0x825ACB20)
	// 825ACB18: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825ACB1C: 486FC940  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ACB20 size=528
    let mut pc: u32 = 0x825ACB20;
    'dispatch: loop {
        match pc {
            0x825ACB20 => {
    //   block [0x825ACB20..0x825ACBB8)
	// 825ACB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACB24: 486FC8AD  bl 0x82ca93d0
	ctx.lr = 0x825ACB28;
	sub_82CA93D0(ctx, base);
	// 825ACB28: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACB2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB30: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825ACB34: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 825ACB38: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825ACB3C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825ACB40: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 825ACB44: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB48: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 825ACB4C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 825ACB50: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825ACB54: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ACB58: 81396C10  lwz r9, 0x6c10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACB5C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACB60: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 825ACB64: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 825ACB68: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 825ACB6C: 93F96C10  stw r31, 0x6c10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 825ACB70: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACB74: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACB78: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 825ACB7C: 82890064  lwz r20, 0x64(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACB80: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825ACB84: 4BCB8EA5  bl 0x82265a28
	ctx.lr = 0x825ACB88;
	sub_82265A28(ctx, base);
	// 825ACB88: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACB8C: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 825ACB90: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACB94: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825ACB98: 40990190  ble cr6, 0x825acd28
	if !ctx.cr[6].gt {
	pc = 0x825ACD28; continue 'dispatch;
	}
	// 825ACB9C: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ACBA0: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 825ACBA4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825ACBA8: 39EBFFFF  addi r15, r11, -1
	ctx.r[15].s64 = ctx.r[11].s64 + -1;
	// 825ACBAC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825ACBB0: 39CAFFFF  addi r14, r10, -1
	ctx.r[14].s64 = ctx.r[10].s64 + -1;
	// 825ACBB4: 3A0BA2F8  addi r16, r11, -0x5d08
	ctx.r[16].s64 = ctx.r[11].s64 + -23816;
	pc = 0x825ACBB8; continue 'dispatch;
            }
            0x825ACBB8 => {
    //   block [0x825ACBB8..0x825ACBFC)
	// 825ACBB8: 39700004  addi r11, r16, 4
	ctx.r[11].s64 = ctx.r[16].s64 + 4;
	// 825ACBBC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACBC0: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACBC4: 7CF5582E  lwzx r7, r21, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ACBC8: 7D5B3E30  sraw r27, r10, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 825ACBCC: 7D0A3E30  sraw r10, r8, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 825ACBD0: 7DEB3E30  sraw r11, r15, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 825ACBD4: 3B0B0001  addi r24, r11, 1
	ctx.r[24].s64 = ctx.r[11].s64 + 1;
	// 825ACBD8: 7DCB3E30  sraw r11, r14, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 825ACBDC: 7E5BC051  subf. r18, r27, r24
	ctx.r[18].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 825ACBE0: 3A2B0001  addi r17, r11, 1
	ctx.r[17].s64 = ctx.r[11].s64 + 1;
	// 825ACBE4: 41820128  beq 0x825acd0c
	if ctx.cr[0].eq {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	// 825ACBE8: 7D6A8851  subf. r11, r10, r17
	ctx.r[11].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ACBEC: 41820120  beq 0x825acd0c
	if ctx.cr[0].eq {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	// 825ACBF0: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825ACBF4: 7F0A8800  cmpw cr6, r10, r17
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACBF8: 40980114  bge cr6, 0x825acd0c
	if !ctx.cr[6].lt {
	pc = 0x825ACD0C; continue 'dispatch;
	}
	pc = 0x825ACBFC; continue 'dispatch;
            }
            0x825ACBFC => {
    //   block [0x825ACBFC..0x825ACC30)
	// 825ACBFC: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACC00: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ACC04: 81540018  lwz r10, 0x18(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(24 as u32) ) } as u64;
	// 825ACC08: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 825ACC0C: 7D4AAA14  add r10, r10, r21
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 825ACC10: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC14: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC18: 7D69B1D6  mullw r11, r9, r22
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[22].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825ACC1C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825ACC20: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ACC24: 7F4B5214  add r26, r11, r10
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825ACC28: 409800D0  bge cr6, 0x825accf8
	if !ctx.cr[6].lt {
	pc = 0x825ACCF8; continue 'dispatch;
	}
	// 825ACC2C: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	pc = 0x825ACC30; continue 'dispatch;
            }
            0x825ACC30 => {
    //   block [0x825ACC30..0x825ACC3C)
	// 825ACC30: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC34: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACC38: 419A00B4  beq cr6, 0x825accec
	if ctx.cr[6].eq {
	pc = 0x825ACCEC; continue 'dispatch;
	}
	pc = 0x825ACC3C; continue 'dispatch;
            }
            0x825ACC3C => {
    //   block [0x825ACC3C..0x825ACCBC)
	// 825ACC3C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC40: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ACC44: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825ACC48: 40980098  bge cr6, 0x825acce0
	if !ctx.cr[6].lt {
	pc = 0x825ACCE0; continue 'dispatch;
	}
	// 825ACC4C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 825ACC50: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC54: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC58: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACC5C: 4BC56985  bl 0x822035e0
	ctx.lr = 0x825ACC60;
	sub_822035E0(ctx, base);
	// 825ACC60: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC68: 419A0074  beq cr6, 0x825accdc
	if ctx.cr[6].eq {
	pc = 0x825ACCDC; continue 'dispatch;
	}
	// 825ACC6C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC70: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACC74: 807E0000  lwz r3, 0(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACC78: 4BC526B9  bl 0x821ff330
	ctx.lr = 0x825ACC7C;
	sub_821FF330(ctx, base);
	// 825ACC7C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC84: 419A0038  beq cr6, 0x825accbc
	if ctx.cr[6].eq {
	pc = 0x825ACCBC; continue 'dispatch;
	}
	// 825ACC88: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACC8C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACC90: 4BFF6D29  bl 0x825a39b8
	ctx.lr = 0x825ACC94;
	sub_825A39B8(ctx, base);
	// 825ACC94: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACC9C: 419A0020  beq cr6, 0x825accbc
	if ctx.cr[6].eq {
	pc = 0x825ACCBC; continue 'dispatch;
	}
	// 825ACCA0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACCA4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACCA8: 4BF64091  bl 0x82510d38
	ctx.lr = 0x825ACCAC;
	sub_82510D38(ctx, base);
	// 825ACCAC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACCB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACCB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ACCB8: 409A0008  bne cr6, 0x825accc0
	if !ctx.cr[6].eq {
	pc = 0x825ACCC0; continue 'dispatch;
	}
	pc = 0x825ACCBC; continue 'dispatch;
            }
            0x825ACCBC => {
    //   block [0x825ACCBC..0x825ACCC0)
	// 825ACCBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825ACCC0; continue 'dispatch;
            }
            0x825ACCC0 => {
    //   block [0x825ACCC0..0x825ACCDC)
	// 825ACCC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ACCC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACCC8: 419A0014  beq cr6, 0x825accdc
	if ctx.cr[6].eq {
	pc = 0x825ACCDC; continue 'dispatch;
	}
	// 825ACCCC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825ACCD0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ACCD4: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACCD8: 4859CA79  bl 0x82b49750
	ctx.lr = 0x825ACCDC;
	sub_82B49750(ctx, base);
	pc = 0x825ACCDC; continue 'dispatch;
            }
            0x825ACCDC => {
    //   block [0x825ACCDC..0x825ACCE0)
	// 825ACCDC: 83F96C10  lwz r31, 0x6c10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x825ACCE0; continue 'dispatch;
            }
            0x825ACCE0 => {
    //   block [0x825ACCE0..0x825ACCEC)
	// 825ACCE0: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACCE4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACCE8: 409AFF54  bne cr6, 0x825acc3c
	if !ctx.cr[6].eq {
	pc = 0x825ACC3C; continue 'dispatch;
	}
	pc = 0x825ACCEC; continue 'dispatch;
            }
            0x825ACCEC => {
    //   block [0x825ACCEC..0x825ACCF8)
	// 825ACCEC: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 825ACCF0: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ACCF4: 4082FF3C  bne 0x825acc30
	if !ctx.cr[0].eq {
	pc = 0x825ACC30; continue 'dispatch;
	}
	pc = 0x825ACCF8; continue 'dispatch;
            }
            0x825ACCF8 => {
    //   block [0x825ACCF8..0x825ACD0C)
	// 825ACCF8: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825ACCFC: 7F168800  cmpw cr6, r22, r17
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACD00: 4198FEFC  blt cr6, 0x825acbfc
	if ctx.cr[6].lt {
	pc = 0x825ACBFC; continue 'dispatch;
	}
	// 825ACD04: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACD08: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x825ACD0C; continue 'dispatch;
            }
            0x825ACD0C => {
    //   block [0x825ACD0C..0x825ACD28)
	// 825ACD0C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ACD10: 3A730014  addi r19, r19, 0x14
	ctx.r[19].s64 = ctx.r[19].s64 + 20;
	// 825ACD14: 3AB50010  addi r21, r21, 0x10
	ctx.r[21].s64 = ctx.r[21].s64 + 16;
	// 825ACD18: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACD1C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ACD20: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825ACD24: 4198FE94  blt cr6, 0x825acbb8
	if ctx.cr[6].lt {
	pc = 0x825ACBB8; continue 'dispatch;
	}
	pc = 0x825ACD28; continue 'dispatch;
            }
            0x825ACD28 => {
    //   block [0x825ACD28..0x825ACD30)
	// 825ACD28: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825ACD2C: 486FC6F4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ACD30 size=552
    let mut pc: u32 = 0x825ACD30;
    'dispatch: loop {
        match pc {
            0x825ACD30 => {
    //   block [0x825ACD30..0x825ACDC8)
	// 825ACD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACD34: 486FC69D  bl 0x82ca93d0
	ctx.lr = 0x825ACD38;
	sub_82CA93D0(ctx, base);
	// 825ACD38: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACD3C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD40: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825ACD44: 3CE08349  lis r7, -0x7cb7
	ctx.r[7].s64 = -2092367872;
	// 825ACD48: 3A600000  li r19, 0
	ctx.r[19].s64 = 0;
	// 825ACD4C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825ACD50: 7E6A9B78  mr r10, r19
	ctx.r[10].u64 = ctx.r[19].u64;
	// 825ACD54: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD58: 3D008349  lis r8, -0x7cb7
	ctx.r[8].s64 = -2092367872;
	// 825ACD5C: 91476C0C  stw r10, 0x6c0c(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(27660 as u32), ctx.r[10].u32 ) };
	// 825ACD60: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825ACD64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ACD68: 81396C10  lwz r9, 0x6c10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	// 825ACD6C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACD70: 81450024  lwz r10, 0x24(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(36 as u32) ) } as u64;
	// 825ACD74: 3BE90001  addi r31, r9, 1
	ctx.r[31].s64 = ctx.r[9].s64 + 1;
	// 825ACD78: 81686C08  lwz r11, 0x6c08(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(27656 as u32) ) } as u64;
	// 825ACD7C: 93F96C10  stw r31, 0x6c10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(27664 as u32), ctx.r[31].u32 ) };
	// 825ACD80: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACD84: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACD88: 91686C08  stw r11, 0x6c08(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(27656 as u32), ctx.r[11].u32 ) };
	// 825ACD8C: 82890064  lwz r20, 0x64(r9)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACD90: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825ACD94: 4BCB8C95  bl 0x82265a28
	ctx.lr = 0x825ACD98;
	sub_82265A28(ctx, base);
	// 825ACD98: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACD9C: 92610050  stw r19, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[19].u32 ) };
	// 825ACDA0: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	// 825ACDA4: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825ACDA8: 409901A8  ble cr6, 0x825acf50
	if !ctx.cr[6].gt {
	pc = 0x825ACF50; continue 'dispatch;
	}
	// 825ACDAC: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825ACDB0: 7E759B78  mr r21, r19
	ctx.r[21].u64 = ctx.r[19].u64;
	// 825ACDB4: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825ACDB8: 39EBFFFF  addi r15, r11, -1
	ctx.r[15].s64 = ctx.r[11].s64 + -1;
	// 825ACDBC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825ACDC0: 39CAFFFF  addi r14, r10, -1
	ctx.r[14].s64 = ctx.r[10].s64 + -1;
	// 825ACDC4: 3A0BA2F8  addi r16, r11, -0x5d08
	ctx.r[16].s64 = ctx.r[11].s64 + -23816;
	pc = 0x825ACDC8; continue 'dispatch;
            }
            0x825ACDC8 => {
    //   block [0x825ACDC8..0x825ACE0C)
	// 825ACDC8: 39700004  addi r11, r16, 4
	ctx.r[11].s64 = ctx.r[16].s64 + 4;
	// 825ACDCC: 81410060  lwz r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825ACDD0: 81010064  lwz r8, 0x64(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825ACDD4: 7CF5582E  lwzx r7, r21, r11
	ctx.r[7].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 825ACDD8: 7D5B3E30  sraw r27, r10, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[10].s32 >> tmp.u32) as i64;
	// 825ACDDC: 7D0A3E30  sraw r10, r8, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> tmp.u32) as i64;
	// 825ACDE0: 7DEB3E30  sraw r11, r15, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[15].s32 < 0) && ((ctx.r[15].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[15].s32 >> tmp.u32) as i64;
	// 825ACDE4: 3B0B0001  addi r24, r11, 1
	ctx.r[24].s64 = ctx.r[11].s64 + 1;
	// 825ACDE8: 7DCB3E30  sraw r11, r14, r7
	tmp.u32 = ctx.r[7].u32 & 0x3F;
	if tmp.u32 > 0x1F { tmp.u32 = 0x1F; }
	ctx.xer.ca = (ctx.r[14].s32 < 0) && ((ctx.r[14].u32 & ((1u32 << tmp.u32) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[14].s32 >> tmp.u32) as i64;
	// 825ACDEC: 7E5BC051  subf. r18, r27, r24
	ctx.r[18].s64 = ctx.r[24].s64 - ctx.r[27].s64;
	ctx.cr[0].compare_i32(ctx.r[18].s32, 0, &mut ctx.xer);
	// 825ACDF0: 3A2B0001  addi r17, r11, 1
	ctx.r[17].s64 = ctx.r[11].s64 + 1;
	// 825ACDF4: 41820140  beq 0x825acf34
	if ctx.cr[0].eq {
	pc = 0x825ACF34; continue 'dispatch;
	}
	// 825ACDF8: 7D6A8851  subf. r11, r10, r17
	ctx.r[11].s64 = ctx.r[17].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ACDFC: 41820138  beq 0x825acf34
	if ctx.cr[0].eq {
	pc = 0x825ACF34; continue 'dispatch;
	}
	// 825ACE00: 7D565378  mr r22, r10
	ctx.r[22].u64 = ctx.r[10].u64;
	// 825ACE04: 7F0A8800  cmpw cr6, r10, r17
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACE08: 4098012C  bge cr6, 0x825acf34
	if !ctx.cr[6].lt {
	pc = 0x825ACF34; continue 'dispatch;
	}
	pc = 0x825ACE0C; continue 'dispatch;
            }
            0x825ACE0C => {
    //   block [0x825ACE0C..0x825ACE40)
	// 825ACE0C: 81740008  lwz r11, 8(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACE10: 7F1BC000  cmpw cr6, r27, r24
	ctx.cr[6].compare_i32(ctx.r[27].s32, ctx.r[24].s32, &mut ctx.xer);
	// 825ACE14: 81540018  lwz r10, 0x18(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(24 as u32) ) } as u64;
	// 825ACE18: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 825ACE1C: 7D4AAA14  add r10, r10, r21
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[21].u64;
	// 825ACE20: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE24: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE28: 7D69B1D6  mullw r11, r9, r22
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * ctx.r[22].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825ACE2C: 7D0BDA14  add r8, r11, r27
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825ACE30: 550B103A  slwi r11, r8, 2
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ACE34: 7F4B5214  add r26, r11, r10
	ctx.r[26].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825ACE38: 409800E8  bge cr6, 0x825acf20
	if !ctx.cr[6].lt {
	pc = 0x825ACF20; continue 'dispatch;
	}
	// 825ACE3C: 7E579378  mr r23, r18
	ctx.r[23].u64 = ctx.r[18].u64;
	pc = 0x825ACE40; continue 'dispatch;
            }
            0x825ACE40 => {
    //   block [0x825ACE40..0x825ACE4C)
	// 825ACE40: 839A0000  lwz r28, 0(r26)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE44: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACE48: 419A00CC  beq cr6, 0x825acf14
	if ctx.cr[6].eq {
	pc = 0x825ACF14; continue 'dispatch;
	}
	pc = 0x825ACE4C; continue 'dispatch;
            }
            0x825ACE4C => {
    //   block [0x825ACE4C..0x825ACEE4)
	// 825ACE4C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE50: 814B004C  lwz r10, 0x4c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ACE54: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825ACE58: 409800B0  bge cr6, 0x825acf08
	if !ctx.cr[6].lt {
	pc = 0x825ACF08; continue 'dispatch;
	}
	// 825ACE5C: 93EB004C  stw r31, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	// 825ACE60: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE64: 809D0000  lwz r4, 0(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825ACE6C: 4BC56775  bl 0x822035e0
	ctx.lr = 0x825ACE70;
	sub_822035E0(ctx, base);
	// 825ACE70: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACE74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACE78: 419A008C  beq cr6, 0x825acf04
	if ctx.cr[6].eq {
	pc = 0x825ACF04; continue 'dispatch;
	}
	// 825ACE7C: 83DD0004  lwz r30, 4(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE80: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACE88: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825ACE8C: 419A0058  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACE90: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACE94: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACE98: 4BC52499  bl 0x821ff330
	ctx.lr = 0x825ACE9C;
	sub_821FF330(ctx, base);
	// 825ACE9C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACEA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEA4: 419A0040  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACEA8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACEAC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACEB0: 4BC53239  bl 0x822000e8
	ctx.lr = 0x825ACEB4;
	sub_822000E8(ctx, base);
	// 825ACEB4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACEB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEBC: 419A0028  beq cr6, 0x825acee4
	if ctx.cr[6].eq {
	pc = 0x825ACEE4; continue 'dispatch;
	}
	// 825ACEC0: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ACEC4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ACEC8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACECC: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ACED0: 48052C09  bl 0x825ffad8
	ctx.lr = 0x825ACED4;
	sub_825FFAD8(ctx, base);
	// 825ACED4: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825ACED8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ACEDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ACEE0: 409A0008  bne cr6, 0x825acee8
	if !ctx.cr[6].eq {
	pc = 0x825ACEE8; continue 'dispatch;
	}
	pc = 0x825ACEE4; continue 'dispatch;
            }
            0x825ACEE4 => {
    //   block [0x825ACEE4..0x825ACEE8)
	// 825ACEE4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825ACEE8; continue 'dispatch;
            }
            0x825ACEE8 => {
    //   block [0x825ACEE8..0x825ACF04)
	// 825ACEE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ACEEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ACEF0: 419A0014  beq cr6, 0x825acf04
	if ctx.cr[6].eq {
	pc = 0x825ACF04; continue 'dispatch;
	}
	// 825ACEF4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825ACEF8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ACEFC: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825ACF00: 4859C851  bl 0x82b49750
	ctx.lr = 0x825ACF04;
	sub_82B49750(ctx, base);
	pc = 0x825ACF04; continue 'dispatch;
            }
            0x825ACF04 => {
    //   block [0x825ACF04..0x825ACF08)
	// 825ACF04: 83F96C10  lwz r31, 0x6c10(r25)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(27664 as u32) ) } as u64;
	pc = 0x825ACF08; continue 'dispatch;
            }
            0x825ACF08 => {
    //   block [0x825ACF08..0x825ACF14)
	// 825ACF08: 839C0004  lwz r28, 4(r28)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ACF0C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825ACF10: 409AFF3C  bne cr6, 0x825ace4c
	if !ctx.cr[6].eq {
	pc = 0x825ACE4C; continue 'dispatch;
	}
	pc = 0x825ACF14; continue 'dispatch;
            }
            0x825ACF14 => {
    //   block [0x825ACF14..0x825ACF20)
	// 825ACF14: 36F7FFFF  addic. r23, r23, -1
	ctx.xer.ca = (ctx.r[23].u32 > (!(-1 as u32)));
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[23].s32, 0, &mut ctx.xer);
	// 825ACF18: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 825ACF1C: 4082FF24  bne 0x825ace40
	if !ctx.cr[0].eq {
	pc = 0x825ACE40; continue 'dispatch;
	}
	pc = 0x825ACF20; continue 'dispatch;
            }
            0x825ACF20 => {
    //   block [0x825ACF20..0x825ACF34)
	// 825ACF20: 3AD60001  addi r22, r22, 1
	ctx.r[22].s64 = ctx.r[22].s64 + 1;
	// 825ACF24: 7F168800  cmpw cr6, r22, r17
	ctx.cr[6].compare_i32(ctx.r[22].s32, ctx.r[17].s32, &mut ctx.xer);
	// 825ACF28: 4198FEE4  blt cr6, 0x825ace0c
	if ctx.cr[6].lt {
	pc = 0x825ACE0C; continue 'dispatch;
	}
	// 825ACF2C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ACF30: 812B6CE4  lwz r9, 0x6ce4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27876 as u32) ) } as u64;
	pc = 0x825ACF34; continue 'dispatch;
            }
            0x825ACF34 => {
    //   block [0x825ACF34..0x825ACF50)
	// 825ACF34: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825ACF38: 3A730014  addi r19, r19, 0x14
	ctx.r[19].s64 = ctx.r[19].s64 + 20;
	// 825ACF3C: 3AB50010  addi r21, r21, 0x10
	ctx.r[21].s64 = ctx.r[21].s64 + 16;
	// 825ACF40: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825ACF44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ACF48: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825ACF4C: 4198FE7C  blt cr6, 0x825acdc8
	if ctx.cr[6].lt {
	pc = 0x825ACDC8; continue 'dispatch;
	}
	pc = 0x825ACF50; continue 'dispatch;
            }
            0x825ACF50 => {
    //   block [0x825ACF50..0x825ACF58)
	// 825ACF50: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825ACF54: 486FC4CC  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ACF58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ACF58 size=296
    let mut pc: u32 = 0x825ACF58;
    'dispatch: loop {
        match pc {
            0x825ACF58 => {
    //   block [0x825ACF58..0x825AD080)
	// 825ACF58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ACF5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ACF60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ACF64: DBC1FFE0  stfd f30, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 825ACF68: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 825ACF6C: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ACF70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ACF74: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 825ACF78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ACF7C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	// 825ACF80: 4BC07509  bl 0x821b4488
	ctx.lr = 0x825ACF84;
	sub_821B4488(ctx, base);
	// 825ACF84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825ACF88: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825ACF8C: 4BFF1715  bl 0x8259e6a0
	ctx.lr = 0x825ACF90;
	sub_8259E6A0(ctx, base);
	// 825ACF90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ACF94: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825ACF98: 4BF10C71  bl 0x824bdc08
	ctx.lr = 0x825ACF9C;
	sub_824BDC08(ctx, base);
	// 825ACF9C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825ACFA0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825ACFA4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825ACFA8: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825ACFAC: 38E99060  addi r7, r9, -0x6fa0
	ctx.r[7].s64 = ctx.r[9].s64 + -28576;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD080(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD080 size=1176
    let mut pc: u32 = 0x825AD080;
    'dispatch: loop {
        match pc {
            0x825AD080 => {
    //   block [0x825AD080..0x825AD0DC)
	// 825AD080: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD084: 486FC369  bl 0x82ca93ec
	ctx.lr = 0x825AD088;
	sub_82CA93D0(ctx, base);
	// 825AD088: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD08C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AD090: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD094: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825AD098: 392B20B4  addi r9, r11, 0x20b4
	ctx.r[9].s64 = ctx.r[11].s64 + 8372;
	// 825AD09C: 390A0B7C  addi r8, r10, 0xb7c
	ctx.r[8].s64 = ctx.r[10].s64 + 2940;
	// 825AD0A0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AD0A4: 90DE0004  stw r6, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825AD0A8: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD0AC: 7C962378  mr r22, r4
	ctx.r[22].u64 = ctx.r[4].u64;
	// 825AD0B0: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825AD0B4: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD0B8: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825AD0BC: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825AD0C0: 4BC677D9  bl 0x82214898
	ctx.lr = 0x825AD0C4;
	sub_82214898(ctx, base);
	// 825AD0C4: 80F60000  lwz r7, 0(r22)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD0C8: 90FE0010  stw r7, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825AD0CC: 81760004  lwz r11, 4(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD0D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD0D4: 917E0014  stw r11, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AD0D8: 419A0020  beq cr6, 0x825ad0f8
	if ctx.cr[6].eq {
	pc = 0x825AD0F8; continue 'dispatch;
	}
	pc = 0x825AD0DC; continue 'dispatch;
            }
            0x825AD0DC => {
    //   block [0x825AD0DC..0x825AD0F8)
	// 825AD0DC: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD0E0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD0E4: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD0E8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD0EC: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD0F0: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD0F4: 4082FFE8  bne 0x825ad0dc
	if !ctx.cr[0].eq {
	pc = 0x825AD0DC; continue 'dispatch;
	}
	pc = 0x825AD0F8; continue 'dispatch;
            }
            0x825AD0F8 => {
    //   block [0x825AD0F8..0x825AD120)
	// 825AD0F8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AD0FC: 93FE0018  stw r31, 0x18(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(24 as u32), ctx.r[31].u32 ) };
	// 825AD100: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 825AD104: 3BBE0018  addi r29, r30, 0x18
	ctx.r[29].s64 = ctx.r[30].s64 + 24;
	// 825AD108: 390B7088  addi r8, r11, 0x7088
	ctx.r[8].s64 = ctx.r[11].s64 + 28808;
	// 825AD10C: 93FE0020  stw r31, 0x20(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(32 as u32), ctx.r[31].u32 ) };
	// 825AD110: 93FE0024  stw r31, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 825AD114: 3B9E0020  addi r28, r30, 0x20
	ctx.r[28].s64 = ctx.r[30].s64 + 32;
	// 825AD118: 7D074378  mr r7, r8
	ctx.r[7].u64 = ctx.r[8].u64;
	// 825AD11C: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD120; continue 'dispatch;
            }
            0x825AD120 => {
    //   block [0x825AD120..0x825AD150)
	// 825AD120: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD124: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD128: 7D403828  lwarx r10, 0, r7
	// lwarx
	let ea = ctx.r[7].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD12C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD130: 7D40392D  stwcx. r10, 0, r7
	// stwcx.
	let addr = ctx.r[7].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD134: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD138: 4082FFE8  bne 0x825ad120
	if !ctx.cr[0].eq {
	pc = 0x825AD120; continue 'dispatch;
	}
	// 825AD13C: 93FE002C  stw r31, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[31].u32 ) };
	// 825AD140: 3B7E002C  addi r27, r30, 0x2c
	ctx.r[27].s64 = ctx.r[30].s64 + 44;
	// 825AD144: 93FE0030  stw r31, 0x30(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(48 as u32), ctx.r[31].u32 ) };
	// 825AD148: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 825AD14C: 93FE0034  stw r31, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD150; continue 'dispatch;
            }
            0x825AD150 => {
    //   block [0x825AD150..0x825AD180)
	// 825AD150: 7CA000A6  mfmsr r5
	ctx.r[5].u64 = ctx.msr;
	// 825AD154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD158: 7CC02028  lwarx r6, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[6].u64 = ctx.reserved.u32 as u64;
	// 825AD15C: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 825AD160: 7CC0212D  stwcx. r6, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[6].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD164: 7CA10164  mtmsrd r5, 1
	ctx.msr = (ctx.r[5].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD168: 4082FFE8  bne 0x825ad150
	if !ctx.cr[0].eq {
	pc = 0x825AD150; continue 'dispatch;
	}
	// 825AD16C: 93FE0038  stw r31, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[31].u32 ) };
	// 825AD170: 3B5E0038  addi r26, r30, 0x38
	ctx.r[26].s64 = ctx.r[30].s64 + 56;
	// 825AD174: 93FE003C  stw r31, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[31].u32 ) };
	// 825AD178: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825AD17C: 93FE0040  stw r31, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD180; continue 'dispatch;
            }
            0x825AD180 => {
    //   block [0x825AD180..0x825AD1B0)
	// 825AD180: 7D6000A6  mfmsr r11
	ctx.r[11].u64 = ctx.msr;
	// 825AD184: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD188: 7C605028  lwarx r3, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[3].u64 = ctx.reserved.u32 as u64;
	// 825AD18C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 825AD190: 7C60512D  stwcx. r3, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[3].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD194: 7D610164  mtmsrd r11, 1
	ctx.msr = (ctx.r[11].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD198: 4082FFE8  bne 0x825ad180
	if !ctx.cr[0].eq {
	pc = 0x825AD180; continue 'dispatch;
	}
	// 825AD19C: 93FE0044  stw r31, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[31].u32 ) };
	// 825AD1A0: 3B3E0044  addi r25, r30, 0x44
	ctx.r[25].s64 = ctx.r[30].s64 + 68;
	// 825AD1A4: 93FE0048  stw r31, 0x48(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(72 as u32), ctx.r[31].u32 ) };
	// 825AD1A8: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 825AD1AC: 93FE004C  stw r31, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD1B0; continue 'dispatch;
            }
            0x825AD1B0 => {
    //   block [0x825AD1B0..0x825AD1E0)
	// 825AD1B0: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825AD1B4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1B8: 7D203028  lwarx r9, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825AD1BC: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825AD1C0: 7D20312D  stwcx. r9, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD1C4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1C8: 4082FFE8  bne 0x825ad1b0
	if !ctx.cr[0].eq {
	pc = 0x825AD1B0; continue 'dispatch;
	}
	// 825AD1CC: 93FE0050  stw r31, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AD1D0: 3B1E0050  addi r24, r30, 0x50
	ctx.r[24].s64 = ctx.r[30].s64 + 80;
	// 825AD1D4: 93FE0054  stw r31, 0x54(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825AD1D8: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 825AD1DC: 93FE0058  stw r31, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD1E0; continue 'dispatch;
            }
            0x825AD1E0 => {
    //   block [0x825AD1E0..0x825AD20C)
	// 825AD1E0: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 825AD1E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1E8: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 825AD1EC: 38A50001  addi r5, r5, 1
	ctx.r[5].s64 = ctx.r[5].s64 + 1;
	// 825AD1F0: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD1F4: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD1F8: 4082FFE8  bne 0x825ad1e0
	if !ctx.cr[0].eq {
	pc = 0x825AD1E0; continue 'dispatch;
	}
	// 825AD1FC: 93FE005C  stw r31, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AD200: 3AFE005C  addi r23, r30, 0x5c
	ctx.r[23].s64 = ctx.r[30].s64 + 92;
	// 825AD204: 93FE0060  stw r31, 0x60(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825AD208: 93FE0064  stw r31, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	pc = 0x825AD20C; continue 'dispatch;
            }
            0x825AD20C => {
    //   block [0x825AD20C..0x825AD294)
	// 825AD20C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825AD210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD214: 7D604028  lwarx r11, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825AD218: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825AD21C: 7D60412D  stwcx. r11, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD220: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD224: 4082FFE8  bne 0x825ad20c
	if !ctx.cr[0].eq {
	pc = 0x825AD20C; continue 'dispatch;
	}
	// 825AD228: 9BFE0068  stb r31, 0x68(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[31].u8 ) };
	// 825AD22C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD230: 9BFE0069  stb r31, 0x69(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(105 as u32), ctx.r[31].u8 ) };
	// 825AD234: 3D00820B  lis r8, -0x7df5
	ctx.r[8].s64 = -2113208320;
	// 825AD238: 9BFE006A  stb r31, 0x6a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(106 as u32), ctx.r[31].u8 ) };
	// 825AD23C: 38C94F68  addi r6, r9, 0x4f68
	ctx.r[6].s64 = ctx.r[9].s64 + 20328;
	// 825AD240: 9BFE006B  stb r31, 0x6b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(107 as u32), ctx.r[31].u8 ) };
	// 825AD244: 38A8F19C  addi r5, r8, -0xe64
	ctx.r[5].s64 = ctx.r[8].s64 + -3684;
	// 825AD248: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825AD24C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825AD250: 4BE00289  bl 0x823ad4d8
	ctx.lr = 0x825AD254;
	sub_823AD4D8(ctx, base);
	// 825AD254: 80E10068  lwz r7, 0x68(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AD258: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AD25C: 419A0298  beq cr6, 0x825ad4f4
	if ctx.cr[6].eq {
	pc = 0x825AD4F4; continue 'dispatch;
	}
	// 825AD260: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825AD264: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825AD268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AD26C: 48001735  bl 0x825ae9a0
	ctx.lr = 0x825AD270;
	sub_825AE9A0(ctx, base);
	// 825AD270: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD274: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AD278: 4BBCE121  bl 0x8217b398
	ctx.lr = 0x825AD27C;
	sub_8217B398(ctx, base);
	// 825AD27C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AD280: 4BC0A899  bl 0x821b7b18
	ctx.lr = 0x825AD284;
	sub_821B7B18(ctx, base);
	// 825AD284: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD28C: 419A0008  beq cr6, 0x825ad294
	if ctx.cr[6].eq {
	pc = 0x825AD294; continue 'dispatch;
	}
	// 825AD290: 9BEB000C  stb r31, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[31].u8 ) };
	pc = 0x825AD294; continue 'dispatch;
            }
            0x825AD294 => {
    //   block [0x825AD294..0x825AD31C)
	// 825AD294: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD298: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD29C: 419A0080  beq cr6, 0x825ad31c
	if ctx.cr[6].eq {
	pc = 0x825AD31C; continue 'dispatch;
	}
	// 825AD2A0: 82AB0000  lwz r21, 0(r11)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD2A4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AD2A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD2AC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2B0: 4BC7BE59  bl 0x82229108
	ctx.lr = 0x825AD2B4;
	sub_82229108(ctx, base);
	// 825AD2B4: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AD2B8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825AD2BC: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2C0: 3BEBD7D8  addi r31, r11, -0x2828
	ctx.r[31].s64 = ctx.r[11].s64 + -10280;
	// 825AD2C4: 4BC7A5BD  bl 0x82227880
	ctx.lr = 0x825AD2C8;
	sub_82227880(ctx, base);
	// 825AD2C8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AD2CC: 3D408245  lis r10, -0x7dbb
	ctx.r[10].s64 = -2109407232;
	// 825AD2D0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AD2D4: 388A1240  addi r4, r10, 0x1240
	ctx.r[4].s64 = ctx.r[10].s64 + 4672;
	// 825AD2D8: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD2DC: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825AD2E0: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825AD2E4: 4BBED79D  bl 0x8219aa80
	ctx.lr = 0x825AD2E8;
	sub_8219AA80(ctx, base);
	// 825AD2E8: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD2EC: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825AD2F0: 3BE94F78  addi r31, r9, 0x4f78
	ctx.r[31].s64 = ctx.r[9].s64 + 20344;
	// 825AD2F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AD2F8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AD2FC: 4BE21125  bl 0x823ce420
	ctx.lr = 0x825AD300;
	sub_823CE420(ctx, base);
	// 825AD300: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825AD304: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825AD308: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825AD30C: 484773BD  bl 0x82a246c8
	ctx.lr = 0x825AD310;
	sub_82A246C8(ctx, base);
	// 825AD310: 81750008  lwz r11, 8(r21)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[21].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AD314: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825AD318: 91150008  stw r8, 8(r21)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[21].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825AD31C; continue 'dispatch;
            }
            0x825AD31C => {
    //   block [0x825AD31C..0x825AD354)
	// 825AD31C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD320: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD324: 38CB4F84  addi r6, r11, 0x4f84
	ctx.r[6].s64 = ctx.r[11].s64 + 20356;
	// 825AD328: 38AA4FA0  addi r5, r10, 0x4fa0
	ctx.r[5].s64 = ctx.r[10].s64 + 20384;
	// 825AD32C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD330: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD334: 4BEB606D  bl 0x824633a0
	ctx.lr = 0x825AD338;
	sub_824633A0(ctx, base);
	// 825AD338: 81210058  lwz r9, 0x58(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AD33C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AD340: 419A0014  beq cr6, 0x825ad354
	if ctx.cr[6].eq {
	pc = 0x825AD354; continue 'dispatch;
	}
	// 825AD344: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD348: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD34C: 480017D5  bl 0x825aeb20
	ctx.lr = 0x825AD350;
	sub_825AEB20(ctx, base);
	// 825AD350: 987E006A  stb r3, 0x6a(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(106 as u32), ctx.r[3].u8 ) };
	pc = 0x825AD354; continue 'dispatch;
            }
            0x825AD354 => {
    //   block [0x825AD354..0x825AD4F4)
	// 825AD354: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD358: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD35C: 38CB4FB0  addi r6, r11, 0x4fb0
	ctx.r[6].s64 = ctx.r[11].s64 + 20400;
	// 825AD360: 38AA4FC4  addi r5, r10, 0x4fc4
	ctx.r[5].s64 = ctx.r[10].s64 + 20420;
	// 825AD364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD368: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD36C: 4BEB6035  bl 0x824633a0
	ctx.lr = 0x825AD370;
	sub_824633A0(ctx, base);
	// 825AD370: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD374: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD378: 4BBED3E1  bl 0x8219a758
	ctx.lr = 0x825AD37C;
	sub_8219A758(ctx, base);
	// 825AD37C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD380: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825AD384: 38C94FCC  addi r6, r9, 0x4fcc
	ctx.r[6].s64 = ctx.r[9].s64 + 20428;
	// 825AD388: 38A84FE4  addi r5, r8, 0x4fe4
	ctx.r[5].s64 = ctx.r[8].s64 + 20452;
	// 825AD38C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD390: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825AD394: 4BEB600D  bl 0x824633a0
	ctx.lr = 0x825AD398;
	sub_824633A0(ctx, base);
	// 825AD398: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD39C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AD3A0: 4BEB0691  bl 0x8245da30
	ctx.lr = 0x825AD3A4;
	sub_8245DA30(ctx, base);
	// 825AD3A4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825AD3A8: 4BC67A31  bl 0x82214dd8
	ctx.lr = 0x825AD3AC;
	sub_82214DD8(ctx, base);
	// 825AD3AC: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825AD3B0: 4BC0A769  bl 0x821b7b18
	ctx.lr = 0x825AD3B4;
	sub_821B7B18(ctx, base);
	// 825AD3B4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AD3B8: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 825AD3BC: 38C74FF0  addi r6, r7, 0x4ff0
	ctx.r[6].s64 = ctx.r[7].s64 + 20464;
	// 825AD3C0: 38A5A1B4  addi r5, r5, -0x5e4c
	ctx.r[5].s64 = ctx.r[5].s64 + -24140;
	// 825AD3C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD3C8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825AD3CC: 4BEB5FD5  bl 0x824633a0
	ctx.lr = 0x825AD3D0;
	sub_824633A0(ctx, base);
	// 825AD3D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD3D4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825AD3D8: 4BEB0659  bl 0x8245da30
	ctx.lr = 0x825AD3DC;
	sub_8245DA30(ctx, base);
	// 825AD3DC: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825AD3E0: 4BC679F9  bl 0x82214dd8
	ctx.lr = 0x825AD3E4;
	sub_82214DD8(ctx, base);
	// 825AD3E4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 825AD3E8: 4BC0A731  bl 0x821b7b18
	ctx.lr = 0x825AD3EC;
	sub_821B7B18(ctx, base);
	// 825AD3EC: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AD3F0: 3C60820C  lis r3, -0x7df4
	ctx.r[3].s64 = -2113142784;
	// 825AD3F4: 38C45008  addi r6, r4, 0x5008
	ctx.r[6].s64 = ctx.r[4].s64 + 20488;
	// 825AD3F8: 38A35020  addi r5, r3, 0x5020
	ctx.r[5].s64 = ctx.r[3].s64 + 20512;
	// 825AD3FC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD400: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825AD404: 4BEB5F9D  bl 0x824633a0
	ctx.lr = 0x825AD408;
	sub_824633A0(ctx, base);
	// 825AD408: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD40C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825AD410: 4BEB0621  bl 0x8245da30
	ctx.lr = 0x825AD414;
	sub_8245DA30(ctx, base);
	// 825AD414: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825AD418: 4BC679C1  bl 0x82214dd8
	ctx.lr = 0x825AD41C;
	sub_82214DD8(ctx, base);
	// 825AD41C: 386100A8  addi r3, r1, 0xa8
	ctx.r[3].s64 = ctx.r[1].s64 + 168;
	// 825AD420: 4BC0A6F9  bl 0x821b7b18
	ctx.lr = 0x825AD424;
	sub_821B7B18(ctx, base);
	// 825AD424: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AD428: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AD42C: 38CB502C  addi r6, r11, 0x502c
	ctx.r[6].s64 = ctx.r[11].s64 + 20524;
	// 825AD430: 38AA5040  addi r5, r10, 0x5040
	ctx.r[5].s64 = ctx.r[10].s64 + 20544;
	// 825AD434: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD438: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825AD43C: 4BEB5F65  bl 0x824633a0
	ctx.lr = 0x825AD440;
	sub_824633A0(ctx, base);
	// 825AD440: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD444: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825AD448: 4BEB05E9  bl 0x8245da30
	ctx.lr = 0x825AD44C;
	sub_8245DA30(ctx, base);
	// 825AD44C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825AD450: 4BC67989  bl 0x82214dd8
	ctx.lr = 0x825AD454;
	sub_82214DD8(ctx, base);
	// 825AD454: 386100B8  addi r3, r1, 0xb8
	ctx.r[3].s64 = ctx.r[1].s64 + 184;
	// 825AD458: 4BC0A6C1  bl 0x821b7b18
	ctx.lr = 0x825AD45C;
	sub_821B7B18(ctx, base);
	// 825AD45C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AD460: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825AD464: 38C95048  addi r6, r9, 0x5048
	ctx.r[6].s64 = ctx.r[9].s64 + 20552;
	// 825AD468: 38A85068  addi r5, r8, 0x5068
	ctx.r[5].s64 = ctx.r[8].s64 + 20584;
	// 825AD46C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD470: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825AD474: 4BEB5F2D  bl 0x824633a0
	ctx.lr = 0x825AD478;
	sub_824633A0(ctx, base);
	// 825AD478: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD47C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825AD480: 4BEB05B1  bl 0x8245da30
	ctx.lr = 0x825AD484;
	sub_8245DA30(ctx, base);
	// 825AD484: 386100D0  addi r3, r1, 0xd0
	ctx.r[3].s64 = ctx.r[1].s64 + 208;
	// 825AD488: 4BC67951  bl 0x82214dd8
	ctx.lr = 0x825AD48C;
	sub_82214DD8(ctx, base);
	// 825AD48C: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825AD490: 4BC0A689  bl 0x821b7b18
	ctx.lr = 0x825AD494;
	sub_821B7B18(ctx, base);
	// 825AD494: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AD498: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 825AD49C: 38C7507C  addi r6, r7, 0x507c
	ctx.r[6].s64 = ctx.r[7].s64 + 20604;
	// 825AD4A0: 38A57B08  addi r5, r5, 0x7b08
	ctx.r[5].s64 = ctx.r[5].s64 + 31496;
	// 825AD4A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AD4A8: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825AD4AC: 4BEB5EF5  bl 0x824633a0
	ctx.lr = 0x825AD4B0;
	sub_824633A0(ctx, base);
	// 825AD4B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AD4B4: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825AD4B8: 4BEB0579  bl 0x8245da30
	ctx.lr = 0x825AD4BC;
	sub_8245DA30(ctx, base);
	// 825AD4BC: 386100E0  addi r3, r1, 0xe0
	ctx.r[3].s64 = ctx.r[1].s64 + 224;
	// 825AD4C0: 4BC67919  bl 0x82214dd8
	ctx.lr = 0x825AD4C4;
	sub_82214DD8(ctx, base);
	// 825AD4C4: 386100D8  addi r3, r1, 0xd8
	ctx.r[3].s64 = ctx.r[1].s64 + 216;
	// 825AD4C8: 4BC0A651  bl 0x821b7b18
	ctx.lr = 0x825AD4CC;
	sub_821B7B18(ctx, base);
	// 825AD4CC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AD4D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AD4D4: 989E006B  stb r4, 0x6b(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(107 as u32), ctx.r[4].u8 ) };
	// 825AD4D8: 4BC67901  bl 0x82214dd8
	ctx.lr = 0x825AD4DC;
	sub_82214DD8(ctx, base);
	// 825AD4DC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825AD4E0: 4BC0A639  bl 0x821b7b18
	ctx.lr = 0x825AD4E4;
	sub_821B7B18(ctx, base);
	// 825AD4E4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825AD4E8: 4BC678F1  bl 0x82214dd8
	ctx.lr = 0x825AD4EC;
	sub_82214DD8(ctx, base);
	// 825AD4EC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AD4F0: 4BC0A629  bl 0x821b7b18
	ctx.lr = 0x825AD4F4;
	sub_821B7B18(ctx, base);
	pc = 0x825AD4F4; continue 'dispatch;
            }
            0x825AD4F4 => {
    //   block [0x825AD4F4..0x825AD518)
	// 825AD4F4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825AD4F8: 4BC678E1  bl 0x82214dd8
	ctx.lr = 0x825AD4FC;
	sub_82214DD8(ctx, base);
	// 825AD4FC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825AD500: 4BC0A619  bl 0x821b7b18
	ctx.lr = 0x825AD504;
	sub_821B7B18(ctx, base);
	// 825AD504: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825AD508: 4BC0A611  bl 0x821b7b18
	ctx.lr = 0x825AD50C;
	sub_821B7B18(ctx, base);
	// 825AD50C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD510: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825AD514: 486FBF28  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD518(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD518 size=80
    let mut pc: u32 = 0x825AD518;
    'dispatch: loop {
        match pc {
            0x825AD518 => {
    //   block [0x825AD518..0x825AD550)
	// 825AD518: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD51C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AD520: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AD524: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AD528: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD52C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD530: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AD534: 4800018D  bl 0x825ad6c0
	ctx.lr = 0x825AD538;
	sub_825AD6C0(ctx, base);
	// 825AD538: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825AD53C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AD540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD544: 419A000C  beq cr6, 0x825ad550
	if ctx.cr[6].eq {
	pc = 0x825AD550; continue 'dispatch;
	}
	// 825AD548: 4BC6E7F1  bl 0x8221bd38
	ctx.lr = 0x825AD54C;
	sub_8221BD38(ctx, base);
	// 825AD54C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825AD550; continue 'dispatch;
            }
            0x825AD550 => {
    //   block [0x825AD550..0x825AD568)
	// 825AD550: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AD554: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AD558: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AD55C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AD560: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AD564: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD568(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AD568 size=340
    let mut pc: u32 = 0x825AD568;
    'dispatch: loop {
        match pc {
            0x825AD568 => {
    //   block [0x825AD568..0x825AD5B4)
	// 825AD568: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD56C: 90830004  stw r4, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825AD570: 3D008200  lis r8, -0x7e00
	ctx.r[8].s64 = -2113929216;
	// 825AD574: 38EB20B4  addi r7, r11, 0x20b4
	ctx.r[7].s64 = ctx.r[11].s64 + 8372;
	// 825AD578: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AD57C: 38C80B7C  addi r6, r8, 0xb7c
	ctx.r[6].s64 = ctx.r[8].s64 + 2940;
	// 825AD580: 90E30000  stw r7, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AD584: 3CA08349  lis r5, -0x7cb7
	ctx.r[5].s64 = -2092367872;
	// 825AD588: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825AD58C: 90C30008  stw r6, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825AD590: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825AD594: 38857088  addi r4, r5, 0x7088
	ctx.r[4].s64 = ctx.r[5].s64 + 28808;
	// 825AD598: 91630014  stw r11, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[11].u32 ) };
	// 825AD59C: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 825AD5A0: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD5A4: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825AD5A8: 91630020  stw r11, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 825AD5AC: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 825AD5B0: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD5B4; continue 'dispatch;
            }
            0x825AD5B4 => {
    //   block [0x825AD5B4..0x825AD5E0)
	// 825AD5B4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD5B8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5BC: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD5C0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD5C4: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD5C8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5CC: 4082FFE8  bne 0x825ad5b4
	if !ctx.cr[0].eq {
	pc = 0x825AD5B4; continue 'dispatch;
	}
	// 825AD5D0: 9163002C  stw r11, 0x2c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 825AD5D4: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825AD5D8: 91630030  stw r11, 0x30(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), ctx.r[11].u32 ) };
	// 825AD5DC: 91630034  stw r11, 0x34(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD5E0; continue 'dispatch;
            }
            0x825AD5E0 => {
    //   block [0x825AD5E0..0x825AD60C)
	// 825AD5E0: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD5E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5E8: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD5EC: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD5F0: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD5F4: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD5F8: 4082FFE8  bne 0x825ad5e0
	if !ctx.cr[0].eq {
	pc = 0x825AD5E0; continue 'dispatch;
	}
	// 825AD5FC: 91630038  stw r11, 0x38(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825AD600: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD604: 9163003C  stw r11, 0x3c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 825AD608: 91630040  stw r11, 0x40(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD60C; continue 'dispatch;
            }
            0x825AD60C => {
    //   block [0x825AD60C..0x825AD638)
	// 825AD60C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD610: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD614: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD618: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD61C: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD620: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD624: 4082FFE8  bne 0x825ad60c
	if !ctx.cr[0].eq {
	pc = 0x825AD60C; continue 'dispatch;
	}
	// 825AD628: 91630044  stw r11, 0x44(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 825AD62C: 7C852378  mr r5, r4
	ctx.r[5].u64 = ctx.r[4].u64;
	// 825AD630: 91630048  stw r11, 0x48(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), ctx.r[11].u32 ) };
	// 825AD634: 9163004C  stw r11, 0x4c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD638; continue 'dispatch;
            }
            0x825AD638 => {
    //   block [0x825AD638..0x825AD664)
	// 825AD638: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD63C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD640: 7CE02828  lwarx r7, 0, r5
	// lwarx
	let ea = ctx.r[5].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD644: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD648: 7CE0292D  stwcx. r7, 0, r5
	// stwcx.
	let addr = ctx.r[5].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD64C: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD650: 4082FFE8  bne 0x825ad638
	if !ctx.cr[0].eq {
	pc = 0x825AD638; continue 'dispatch;
	}
	// 825AD654: 91630050  stw r11, 0x50(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AD658: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 825AD65C: 91630054  stw r11, 0x54(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825AD660: 91630058  stw r11, 0x58(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD664; continue 'dispatch;
            }
            0x825AD664 => {
    //   block [0x825AD664..0x825AD68C)
	// 825AD664: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825AD668: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD66C: 7D404028  lwarx r10, 0, r8
	// lwarx
	let ea = ctx.r[8].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825AD670: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825AD674: 7D40412D  stwcx. r10, 0, r8
	// stwcx.
	let addr = ctx.r[8].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD678: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD67C: 4082FFE8  bne 0x825ad664
	if !ctx.cr[0].eq {
	pc = 0x825AD664; continue 'dispatch;
	}
	// 825AD680: 9163005C  stw r11, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825AD684: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AD688: 91630064  stw r11, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x825AD68C; continue 'dispatch;
            }
            0x825AD68C => {
    //   block [0x825AD68C..0x825AD6BC)
	// 825AD68C: 7CC000A6  mfmsr r6
	ctx.r[6].u64 = ctx.msr;
	// 825AD690: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD694: 7CE02028  lwarx r7, 0, r4
	// lwarx
	let ea = ctx.r[4].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[7].u64 = ctx.reserved.u32 as u64;
	// 825AD698: 38E70001  addi r7, r7, 1
	ctx.r[7].s64 = ctx.r[7].s64 + 1;
	// 825AD69C: 7CE0212D  stwcx. r7, 0, r4
	// stwcx.
	let addr = ctx.r[4].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[7].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825AD6A0: 7CC10164  mtmsrd r6, 1
	ctx.msr = (ctx.r[6].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825AD6A4: 4082FFE8  bne 0x825ad68c
	if !ctx.cr[0].eq {
	pc = 0x825AD68C; continue 'dispatch;
	}
	// 825AD6A8: 99630068  stb r11, 0x68(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 825AD6AC: 99630069  stb r11, 0x69(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 825AD6B0: 9963006A  stb r11, 0x6a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(106 as u32), ctx.r[11].u8 ) };
	// 825AD6B4: 9963006B  stb r11, 0x6b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(107 as u32), ctx.r[11].u8 ) };
	// 825AD6B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD6C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD6C0 size=276
    let mut pc: u32 = 0x825AD6C0;
    'dispatch: loop {
        match pc {
            0x825AD6C0 => {
    //   block [0x825AD6C0..0x825AD6F4)
	// 825AD6C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD6C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AD6C8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AD6CC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AD6D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD6D4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD6D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD6DC: 392B20B4  addi r9, r11, 0x20b4
	ctx.r[9].s64 = ctx.r[11].s64 + 8372;
	// 825AD6E0: 895F0068  lbz r10, 0x68(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 825AD6E4: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD6E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD6EC: 419A0008  beq cr6, 0x825ad6f4
	if ctx.cr[6].eq {
	pc = 0x825AD6F4; continue 'dispatch;
	}
	// 825AD6F0: 480003E1  bl 0x825adad0
	ctx.lr = 0x825AD6F4;
	sub_825ADAD0(ctx, base);
	pc = 0x825AD6F4; continue 'dispatch;
            }
            0x825AD6F4 => {
    //   block [0x825AD6F4..0x825AD70C)
	// 825AD6F4: 897F006B  lbz r11, 0x6b(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(107 as u32) ) } as u64;
	// 825AD6F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD6FC: 419A0010  beq cr6, 0x825ad70c
	if ctx.cr[6].eq {
	pc = 0x825AD70C; continue 'dispatch;
	}
	// 825AD700: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AD704: 387F0044  addi r3, r31, 0x44
	ctx.r[3].s64 = ctx.r[31].s64 + 68;
	// 825AD708: 4BBED051  bl 0x8219a758
	ctx.lr = 0x825AD70C;
	sub_8219A758(ctx, base);
	pc = 0x825AD70C; continue 'dispatch;
            }
            0x825AD70C => {
    //   block [0x825AD70C..0x825AD7D4)
	// 825AD70C: 3BDF005C  addi r30, r31, 0x5c
	ctx.r[30].s64 = ctx.r[31].s64 + 92;
	// 825AD710: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD714: 4BC676C5  bl 0x82214dd8
	ctx.lr = 0x825AD718;
	sub_82214DD8(ctx, base);
	// 825AD718: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD71C: 4BC0A3FD  bl 0x821b7b18
	ctx.lr = 0x825AD720;
	sub_821B7B18(ctx, base);
	// 825AD720: 3BDF0050  addi r30, r31, 0x50
	ctx.r[30].s64 = ctx.r[31].s64 + 80;
	// 825AD724: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD728: 4BC676B1  bl 0x82214dd8
	ctx.lr = 0x825AD72C;
	sub_82214DD8(ctx, base);
	// 825AD72C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD730: 4BC0A3E9  bl 0x821b7b18
	ctx.lr = 0x825AD734;
	sub_821B7B18(ctx, base);
	// 825AD734: 3BDF0044  addi r30, r31, 0x44
	ctx.r[30].s64 = ctx.r[31].s64 + 68;
	// 825AD738: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD73C: 4BC6769D  bl 0x82214dd8
	ctx.lr = 0x825AD740;
	sub_82214DD8(ctx, base);
	// 825AD740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD744: 4BC0A3D5  bl 0x821b7b18
	ctx.lr = 0x825AD748;
	sub_821B7B18(ctx, base);
	// 825AD748: 3BDF0038  addi r30, r31, 0x38
	ctx.r[30].s64 = ctx.r[31].s64 + 56;
	// 825AD74C: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD750: 4BC67689  bl 0x82214dd8
	ctx.lr = 0x825AD754;
	sub_82214DD8(ctx, base);
	// 825AD754: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD758: 4BC0A3C1  bl 0x821b7b18
	ctx.lr = 0x825AD75C;
	sub_821B7B18(ctx, base);
	// 825AD75C: 3BDF002C  addi r30, r31, 0x2c
	ctx.r[30].s64 = ctx.r[31].s64 + 44;
	// 825AD760: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD764: 4BC67675  bl 0x82214dd8
	ctx.lr = 0x825AD768;
	sub_82214DD8(ctx, base);
	// 825AD768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD76C: 4BC0A3AD  bl 0x821b7b18
	ctx.lr = 0x825AD770;
	sub_821B7B18(ctx, base);
	// 825AD770: 3BDF0020  addi r30, r31, 0x20
	ctx.r[30].s64 = ctx.r[31].s64 + 32;
	// 825AD774: 387E0008  addi r3, r30, 8
	ctx.r[3].s64 = ctx.r[30].s64 + 8;
	// 825AD778: 4BC67661  bl 0x82214dd8
	ctx.lr = 0x825AD77C;
	sub_82214DD8(ctx, base);
	// 825AD77C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD780: 4BC0A399  bl 0x821b7b18
	ctx.lr = 0x825AD784;
	sub_821B7B18(ctx, base);
	// 825AD784: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825AD788: 4BC0A391  bl 0x821b7b18
	ctx.lr = 0x825AD78C;
	sub_821B7B18(ctx, base);
	// 825AD78C: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825AD790: 4BC0A389  bl 0x821b7b18
	ctx.lr = 0x825AD794;
	sub_821B7B18(ctx, base);
	// 825AD794: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825AD798: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825AD79C: 394B0B7C  addi r10, r11, 0xb7c
	ctx.r[10].s64 = ctx.r[11].s64 + 2940;
	// 825AD7A0: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825AD7A4: 4BBE6695  bl 0x82193e38
	ctx.lr = 0x825AD7A8;
	sub_82193E38(ctx, base);
	// 825AD7A8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AD7AC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AD7B0: 38E946D4  addi r7, r9, 0x46d4
	ctx.r[7].s64 = ctx.r[9].s64 + 18132;
	// 825AD7B4: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825AD7B8: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825AD7BC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AD7C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AD7C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AD7C8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AD7CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AD7D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AD7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AD7E8 size=744
    let mut pc: u32 = 0x825AD7E8;
    'dispatch: loop {
        match pc {
            0x825AD7E8 => {
    //   block [0x825AD7E8..0x825AD82C)
	// 825AD7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AD7EC: 486FBC0D  bl 0x82ca93f8
	ctx.lr = 0x825AD7F0;
	sub_82CA93D0(ctx, base);
	// 825AD7F0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AD7F4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825AD7F8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825AD7FC: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825AD800: 93E100BC  stw r31, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[31].u32 ) };
	// 825AD804: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD808: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825AD80C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825AD810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD814: 419A001C  beq cr6, 0x825ad830
	if ctx.cr[6].eq {
	pc = 0x825AD830; continue 'dispatch;
	}
	// 825AD818: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD81C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD820: 419A000C  beq cr6, 0x825ad82c
	if ctx.cr[6].eq {
	pc = 0x825AD82C; continue 'dispatch;
	}
	// 825AD824: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AD828: 4800000C  b 0x825ad834
	pc = 0x825AD834; continue 'dispatch;
            }
            0x825AD82C => {
    //   block [0x825AD82C..0x825AD830)
	// 825AD82C: 4BBE660D  bl 0x82193e38
	ctx.lr = 0x825AD830;
	sub_82193E38(ctx, base);
	pc = 0x825AD830; continue 'dispatch;
            }
            0x825AD830 => {
    //   block [0x825AD830..0x825AD834)
	// 825AD830: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x825AD834; continue 'dispatch;
            }
            0x825AD834 => {
    //   block [0x825AD834..0x825AD858)
	// 825AD834: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AD838: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AD83C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AD840: 419A0018  beq cr6, 0x825ad858
	if ctx.cr[6].eq {
	pc = 0x825AD858; continue 'dispatch;
	}
	// 825AD844: 897F0090  lbz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AD848: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AD84C: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AD850: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD854: 409A0008  bne cr6, 0x825ad85c
	if !ctx.cr[6].eq {
	pc = 0x825AD85C; continue 'dispatch;
	}
	pc = 0x825AD858; continue 'dispatch;
            }
            0x825AD858 => {
    //   block [0x825AD858..0x825AD85C)
	// 825AD858: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x825AD85C; continue 'dispatch;
            }
            0x825AD85C => {
    //   block [0x825AD85C..0x825AD890)
	// 825AD85C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AD860: 38790008  addi r3, r25, 8
	ctx.r[3].s64 = ctx.r[25].s64 + 8;
	// 825AD864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD868: 419A0028  beq cr6, 0x825ad890
	if ctx.cr[6].eq {
	pc = 0x825AD890; continue 'dispatch;
	}
	// 825AD86C: 4BBC65CD  bl 0x82173e38
	ctx.lr = 0x825AD870;
	sub_82173E38(ctx, base);
	// 825AD870: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825AD874: 38E100BC  addi r7, r1, 0xbc
	ctx.r[7].s64 = ctx.r[1].s64 + 188;
	// 825AD878: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AD87C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AD880: 38990018  addi r4, r25, 0x18
	ctx.r[4].s64 = ctx.r[25].s64 + 24;
	// 825AD884: 38790020  addi r3, r25, 0x20
	ctx.r[3].s64 = ctx.r[25].s64 + 32;
	// 825AD888: 480013D1  bl 0x825aec58
	ctx.lr = 0x825AD88C;
	sub_825AEC58(ctx, base);
	// 825AD88C: 48000020  b 0x825ad8ac
	pc = 0x825AD8AC; continue 'dispatch;
            }
            0x825AD890 => {
    //   block [0x825AD890..0x825AD8AC)
	// 825AD890: 4BBC65A9  bl 0x82173e38
	ctx.lr = 0x825AD894;
	sub_82173E38(ctx, base);
	// 825AD894: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 825AD898: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AD89C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AD8A0: 38990018  addi r4, r25, 0x18
	ctx.r[4].s64 = ctx.r[25].s64 + 24;
	// 825AD8A4: 38790020  addi r3, r25, 0x20
	ctx.r[3].s64 = ctx.r[25].s64 + 32;
	// 825AD8A8: 480014C9  bl 0x825aed70
	ctx.lr = 0x825AD8AC;
	sub_825AED70(ctx, base);
	pc = 0x825AD8AC; continue 'dispatch;
            }
            0x825AD8AC => {
    //   block [0x825AD8AC..0x825AD8FC)
	// 825AD8AC: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825AD8B0: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825AD8B4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD8B8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD8BC: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825AD8C0: 4BE9E0B9  bl 0x8244b978
	ctx.lr = 0x825AD8C4;
	sub_8244B978(ctx, base);
	// 825AD8C4: 8959006A  lbz r10, 0x6a(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(106 as u32) ) } as u64;
	// 825AD8C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AD8CC: 419A01F8  beq cr6, 0x825adac4
	if ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825AD8D0: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD8D4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD8D8: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD8DC: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8E0: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8E4: 550A003E  slwi r10, r8, 0
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825AD8E8: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD8EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825AD8F0: 409A000C  bne cr6, 0x825ad8fc
	if !ctx.cr[6].eq {
	pc = 0x825AD8FC; continue 'dispatch;
	}
	// 825AD8F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 825AD8F8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825AD8FC; continue 'dispatch;
            }
            0x825AD8FC => {
    //   block [0x825AD8FC..0x825AD930)
	// 825AD8FC: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AD900: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AD904: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD908: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AD90C: 4E800421  bctrl
	ctx.lr = 0x825AD910;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AD910: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AD914: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825AD918: 419A0018  beq cr6, 0x825ad930
	if ctx.cr[6].eq {
	pc = 0x825AD930; continue 'dispatch;
	}
	// 825AD91C: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 825AD920: 419A0010  beq cr6, 0x825ad930
	if ctx.cr[6].eq {
	pc = 0x825AD930; continue 'dispatch;
	}
	// 825AD924: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 825AD928: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825AD92C: 409A0008  bne cr6, 0x825ad934
	if !ctx.cr[6].eq {
	pc = 0x825AD934; continue 'dispatch;
	}
            }
            0x825AD930 => {
    //   block [0x825AD930..0x825AD934)
	// 825AD930: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x825AD934; continue 'dispatch;
            }
            0x825AD934 => {
    //   block [0x825AD934..0x825AD95C)
	// 825AD934: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AD938: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AD93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AD940: 419A001C  beq cr6, 0x825ad95c
	if ctx.cr[6].eq {
	pc = 0x825AD95C; continue 'dispatch;
	}
	// 825AD944: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD948: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825AD94C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD950: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD954: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD958: 4BD6AEA9  bl 0x82318800
	ctx.lr = 0x825AD95C;
	sub_82318800(ctx, base);
	pc = 0x825AD95C; continue 'dispatch;
            }
            0x825AD95C => {
    //   block [0x825AD95C..0x825AD9E0)
	// 825AD95C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825AD960: 4BC718F9  bl 0x8221f258
	ctx.lr = 0x825AD964;
	sub_8221F258(ctx, base);
	// 825AD964: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AD968: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AD96C: 419A0074  beq cr6, 0x825ad9e0
	if ctx.cr[6].eq {
	pc = 0x825AD9E0; continue 'dispatch;
	}
	// 825AD970: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825AD974: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825AD978: 3940000C  li r10, 0xc
	ctx.r[10].s64 = 12;
	// 825AD97C: 935F000C  stw r26, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[26].u32 ) };
	// 825AD980: 392BED9C  addi r9, r11, -0x1264
	ctx.r[9].s64 = ctx.r[11].s64 + -4708;
	// 825AD984: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 825AD988: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AD98C: 3BDF0004  addi r30, r31, 4
	ctx.r[30].s64 = ctx.r[31].s64 + 4;
	// 825AD990: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AD994: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD998: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD99C: 4BFD1A8D  bl 0x8257f428
	ctx.lr = 0x825AD9A0;
	sub_8257F428(ctx, base);
	// 825AD9A0: 39000009  li r8, 9
	ctx.r[8].s64 = 9;
	// 825AD9A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9A8: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AD9AC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9B0: 4BFD1A79  bl 0x8257f428
	ctx.lr = 0x825AD9B4;
	sub_8257F428(ctx, base);
	// 825AD9B4: 38E0000B  li r7, 0xb
	ctx.r[7].s64 = 11;
	// 825AD9B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9BC: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 825AD9C0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9C4: 4BFD1A65  bl 0x8257f428
	ctx.lr = 0x825AD9C8;
	sub_8257F428(ctx, base);
	// 825AD9C8: 93010054  stw r24, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[24].u32 ) };
	// 825AD9CC: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AD9D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AD9D4: 4BFD1A55  bl 0x8257f428
	ctx.lr = 0x825AD9D8;
	sub_8257F428(ctx, base);
	// 825AD9D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AD9DC: 48000008  b 0x825ad9e4
	pc = 0x825AD9E4; continue 'dispatch;
            }
            0x825AD9E0 => {
    //   block [0x825AD9E0..0x825AD9E4)
	// 825AD9E0: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x825AD9E4; continue 'dispatch;
            }
            0x825AD9E4 => {
    //   block [0x825AD9E4..0x825ADA24)
	// 825AD9E4: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AD9E8: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AD9EC: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825AD9F0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AD9F4: 4BD6AD25  bl 0x82318718
	ctx.lr = 0x825AD9F8;
	sub_82318718(ctx, base);
	// 825AD9F8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825AD9FC: 419A00C8  beq cr6, 0x825adac4
	if ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825ADA00: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825ADA04: 409A0020  bne cr6, 0x825ada24
	if !ctx.cr[6].eq {
	pc = 0x825ADA24; continue 'dispatch;
	}
	// 825ADA08: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825ADA0C: 4BC7184D  bl 0x8221f258
	ctx.lr = 0x825ADA10;
	sub_8221F258(ctx, base);
	// 825ADA10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825ADA14: 419A0098  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA18: 4BE27231  bl 0x823d4c48
	ctx.lr = 0x825ADA1C;
	sub_823D4C48(ctx, base);
	// 825ADA1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825ADA20: 48000090  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
            }
            0x825ADA24 => {
    //   block [0x825ADA24..0x825ADA60)
	// 825ADA24: 2F1C0002  cmpwi cr6, r28, 2
	ctx.cr[6].compare_i32(ctx.r[28].s32, 2, &mut ctx.xer);
	// 825ADA28: 409A0038  bne cr6, 0x825ada60
	if !ctx.cr[6].eq {
	pc = 0x825ADA60; continue 'dispatch;
	}
	// 825ADA2C: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825ADA30: 4BC71829  bl 0x8221f258
	ctx.lr = 0x825ADA34;
	sub_8221F258(ctx, base);
	// 825ADA34: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADA38: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825ADA3C: 419A0070  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA40: 4BE27209  bl 0x823d4c48
	ctx.lr = 0x825ADA44;
	sub_823D4C48(ctx, base);
	// 825ADA44: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825ADA48: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 825ADA4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADA50: 394BECA0  addi r10, r11, -0x1360
	ctx.r[10].s64 = ctx.r[11].s64 + -4960;
	// 825ADA54: 9B5F0015  stb r26, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[26].u8 ) };
	// 825ADA58: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825ADA5C: 48000054  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
            }
            0x825ADA60 => {
    //   block [0x825ADA60..0x825ADAAC)
	// 825ADA60: 2F1C0003  cmpwi cr6, r28, 3
	ctx.cr[6].compare_i32(ctx.r[28].s32, 3, &mut ctx.xer);
	// 825ADA64: 409A0060  bne cr6, 0x825adac4
	if !ctx.cr[6].eq {
	pc = 0x825ADAC4; continue 'dispatch;
	}
	// 825ADA68: 38600018  li r3, 0x18
	ctx.r[3].s64 = 24;
	// 825ADA6C: 4BC717ED  bl 0x8221f258
	ctx.lr = 0x825ADA70;
	sub_8221F258(ctx, base);
	// 825ADA70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADA74: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825ADA78: 419A0034  beq cr6, 0x825adaac
	if ctx.cr[6].eq {
	pc = 0x825ADAAC; continue 'dispatch;
	}
	// 825ADA7C: 4BE271CD  bl 0x823d4c48
	ctx.lr = 0x825ADA80;
	sub_823D4C48(ctx, base);
	// 825ADA80: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825ADA84: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 825ADA88: 9B5F0014  stb r26, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[26].u8 ) };
	// 825ADA8C: 392BECC4  addi r9, r11, -0x133c
	ctx.r[9].s64 = ctx.r[11].s64 + -4924;
	// 825ADA90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825ADA94: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825ADA98: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825ADA9C: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825ADAA0: 4BFD1989  bl 0x8257f428
	ctx.lr = 0x825ADAA4;
	sub_8257F428(ctx, base);
	// 825ADAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADAA8: 48000008  b 0x825adab0
	pc = 0x825ADAB0; continue 'dispatch;
            }
            0x825ADAAC => {
    //   block [0x825ADAAC..0x825ADAB0)
	// 825ADAAC: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	pc = 0x825ADAB0; continue 'dispatch;
            }
            0x825ADAB0 => {
    //   block [0x825ADAB0..0x825ADAC4)
	// 825ADAB0: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADAB4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADAB8: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825ADABC: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADAC0: 4BD6AC59  bl 0x82318718
	ctx.lr = 0x825ADAC4;
	sub_82318718(ctx, base);
	pc = 0x825ADAC4; continue 'dispatch;
            }
            0x825ADAC4 => {
    //   block [0x825ADAC4..0x825ADAD0)
	// 825ADAC4: 9B190068  stb r24, 0x68(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(104 as u32), ctx.r[24].u8 ) };
	// 825ADAC8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825ADACC: 486FB97C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADAD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825ADAD0 size=176
    let mut pc: u32 = 0x825ADAD0;
    'dispatch: loop {
        match pc {
            0x825ADAD0 => {
    //   block [0x825ADAD0..0x825ADB34)
	// 825ADAD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADAD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825ADAD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825ADADC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825ADAE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADAE4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADAE8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADAEC: 387F0038  addi r3, r31, 0x38
	ctx.r[3].s64 = ctx.r[31].s64 + 56;
	// 825ADAF0: 4BBECC69  bl 0x8219a758
	ctx.lr = 0x825ADAF4;
	sub_8219A758(ctx, base);
	// 825ADAF4: 3FC08349  lis r30, -0x7cb7
	ctx.r[30].s64 = -2092367872;
	// 825ADAF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825ADAFC: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADB00: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADB04: 806B007C  lwz r3, 0x7c(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(124 as u32) ) } as u64;
	// 825ADB08: 4BE9DF21  bl 0x8244ba28
	ctx.lr = 0x825ADB0C;
	sub_8244BA28(ctx, base);
	// 825ADB0C: 895F006A  lbz r10, 0x6a(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(106 as u32) ) } as u64;
	// 825ADB10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADB14: 419A0060  beq cr6, 0x825adb74
	if ctx.cr[6].eq {
	pc = 0x825ADB74; continue 'dispatch;
	}
	// 825ADB18: 817E6AB8  lwz r11, 0x6ab8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825ADB1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825ADB20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADB24: 419A0010  beq cr6, 0x825adb34
	if ctx.cr[6].eq {
	pc = 0x825ADB34; continue 'dispatch;
	}
	// 825ADB28: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825ADB2C: 894A6A5E  lbz r10, 0x6a5e(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(27230 as u32) ) } as u64;
	// 825ADB30: 48000008  b 0x825adb38
	pc = 0x825ADB38; continue 'dispatch;
            }
            0x825ADB34 => {
    //   block [0x825ADB34..0x825ADB38)
	// 825ADB34: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	pc = 0x825ADB38; continue 'dispatch;
            }
            0x825ADB38 => {
    //   block [0x825ADB38..0x825ADB58)
	// 825ADB38: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825ADB3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADB40: 419A0018  beq cr6, 0x825adb58
	if ctx.cr[6].eq {
	pc = 0x825ADB58; continue 'dispatch;
	}
	// 825ADB44: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825ADB48: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 825ADB4C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 825ADB50: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADB54: 4BD6ACAD  bl 0x82318800
	ctx.lr = 0x825ADB58;
	sub_82318800(ctx, base);
	pc = 0x825ADB58; continue 'dispatch;
            }
            0x825ADB58 => {
    //   block [0x825ADB58..0x825ADB5C)
	// 825ADB58: 9BDF0068  stb r30, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u8 ) };
	pc = 0x825ADB5C; continue 'dispatch;
            }
            0x825ADB5C => {
    //   block [0x825ADB5C..0x825ADB74)
	// 825ADB5C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825ADB60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825ADB64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825ADB68: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825ADB6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825ADB70: 4E800020  blr
	return;
            }
            0x825ADB74 => {
    //   block [0x825ADB74..0x825ADB80)
	// 825ADB74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825ADB78: 997F0068  stb r11, 0x68(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[11].u8 ) };
	// 825ADB7C: 4BFFFFE0  b 0x825adb5c
	pc = 0x825ADB5C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADB80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ADB80 size=472
    let mut pc: u32 = 0x825ADB80;
    'dispatch: loop {
        match pc {
            0x825ADB80 => {
    //   block [0x825ADB80..0x825ADBC4)
	// 825ADB80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADB84: 486FB885  bl 0x82ca9408
	ctx.lr = 0x825ADB88;
	sub_82CA93D0(ctx, base);
	// 825ADB88: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADB8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825ADB90: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825ADB94: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825ADB98: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825ADB9C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADBA0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825ADBA4: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825ADBA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADBAC: 419A001C  beq cr6, 0x825adbc8
	if ctx.cr[6].eq {
	pc = 0x825ADBC8; continue 'dispatch;
	}
	// 825ADBB0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADBB4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADBB8: 419A000C  beq cr6, 0x825adbc4
	if ctx.cr[6].eq {
	pc = 0x825ADBC4; continue 'dispatch;
	}
	// 825ADBBC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825ADBC0: 4800000C  b 0x825adbcc
	pc = 0x825ADBCC; continue 'dispatch;
            }
            0x825ADBC4 => {
    //   block [0x825ADBC4..0x825ADBC8)
	// 825ADBC4: 4BBE6275  bl 0x82193e38
	ctx.lr = 0x825ADBC8;
	sub_82193E38(ctx, base);
	pc = 0x825ADBC8; continue 'dispatch;
            }
            0x825ADBC8 => {
    //   block [0x825ADBC8..0x825ADBCC)
	// 825ADBC8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825ADBCC; continue 'dispatch;
            }
            0x825ADBCC => {
    //   block [0x825ADBCC..0x825ADC08)
	// 825ADBCC: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825ADBD0: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825ADBD4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825ADBD8: 419A00F4  beq cr6, 0x825adccc
	if ctx.cr[6].eq {
	pc = 0x825ADCCC; continue 'dispatch;
	}
	// 825ADBDC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825ADBE0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADBE4: 419A0024  beq cr6, 0x825adc08
	if ctx.cr[6].eq {
	pc = 0x825ADC08; continue 'dispatch;
	}
	// 825ADBE8: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 825ADBEC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825ADBF0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825ADBF4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825ADBF8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADBFC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADC00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADC04: 480000CC  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
            }
            0x825ADC08 => {
    //   block [0x825ADC08..0x825ADC24)
	// 825ADC08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825ADC0C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825ADC10: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825ADC14: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825ADC18: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825ADC1C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ADC20: 40810054  ble 0x825adc74
	if !ctx.cr[0].gt {
	pc = 0x825ADC74; continue 'dispatch;
	}
	pc = 0x825ADC24; continue 'dispatch;
            }
            0x825ADC24 => {
    //   block [0x825ADC24..0x825ADC44)
	// 825ADC24: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825ADC28: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825ADC2C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825ADC30: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADC34: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825ADC38: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825ADC3C: 41980008  blt cr6, 0x825adc44
	if ctx.cr[6].lt {
	pc = 0x825ADC44; continue 'dispatch;
	}
	// 825ADC40: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825ADC44; continue 'dispatch;
            }
            0x825ADC44 => {
    //   block [0x825ADC44..0x825ADC60)
	// 825ADC44: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825ADC48: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825ADC4C: 419A0014  beq cr6, 0x825adc60
	if ctx.cr[6].eq {
	pc = 0x825ADC60; continue 'dispatch;
	}
	// 825ADC50: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825ADC54: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825ADC58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825ADC5C: 4800000C  b 0x825adc68
	pc = 0x825ADC68; continue 'dispatch;
            }
            0x825ADC60 => {
    //   block [0x825ADC60..0x825ADC68)
	// 825ADC60: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825ADC64: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825ADC68; continue 'dispatch;
            }
            0x825ADC68 => {
    //   block [0x825ADC68..0x825ADC74)
	// 825ADC68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825ADC6C: 4199FFB8  bgt cr6, 0x825adc24
	if ctx.cr[6].gt {
	pc = 0x825ADC24; continue 'dispatch;
	}
	// 825ADC70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825ADC74; continue 'dispatch;
            }
            0x825ADC74 => {
    //   block [0x825ADC74..0x825ADC90)
	// 825ADC74: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825ADC78: 419A0040  beq cr6, 0x825adcb8
	if ctx.cr[6].eq {
	pc = 0x825ADCB8; continue 'dispatch;
	}
	// 825ADC7C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADC80: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825ADC84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADC88: 41990008  bgt cr6, 0x825adc90
	if ctx.cr[6].gt {
	pc = 0x825ADC90; continue 'dispatch;
	}
	// 825ADC8C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825ADC90; continue 'dispatch;
            }
            0x825ADC90 => {
    //   block [0x825ADC90..0x825ADCB8)
	// 825ADC90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ADC94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADC98: 409A0020  bne cr6, 0x825adcb8
	if !ctx.cr[6].eq {
	pc = 0x825ADCB8; continue 'dispatch;
	}
	// 825ADC9C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825ADCA0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825ADCA4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825ADCA8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADCAC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADCB0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADCB4: 4800001C  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
            }
            0x825ADCB8 => {
    //   block [0x825ADCB8..0x825ADCCC)
	// 825ADCB8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825ADCBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825ADCC0: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825ADCC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825ADCC8: 48000008  b 0x825adcd0
	pc = 0x825ADCD0; continue 'dispatch;
            }
            0x825ADCCC => {
    //   block [0x825ADCCC..0x825ADCD0)
	// 825ADCCC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825ADCD0; continue 'dispatch;
            }
            0x825ADCD0 => {
    //   block [0x825ADCD0..0x825ADCFC)
	// 825ADCD0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825ADCD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADCD8: 419A0024  beq cr6, 0x825adcfc
	if ctx.cr[6].eq {
	pc = 0x825ADCFC; continue 'dispatch;
	}
	// 825ADCDC: 817F007C  lwz r11, 0x7c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 825ADCE0: 556AE7FE  rlwinm r10, r11, 0x1c, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 825ADCE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADCE8: 409A0068  bne cr6, 0x825add50
	if !ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADCEC: 897F002A  lbz r11, 0x2a(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(42 as u32) ) } as u64;
	// 825ADCF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADCF4: 419A0008  beq cr6, 0x825adcfc
	if ctx.cr[6].eq {
	pc = 0x825ADCFC; continue 'dispatch;
	}
	// 825ADCF8: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	pc = 0x825ADCFC; continue 'dispatch;
            }
            0x825ADCFC => {
    //   block [0x825ADCFC..0x825ADD34)
	// 825ADCFC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ADD00: 894B6BE9  lbz r10, 0x6be9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27625 as u32) ) } as u64;
	// 825ADD04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADD08: 409A0048  bne cr6, 0x825add50
	if !ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADD0C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADD10: 2F0B0039  cmpwi cr6, r11, 0x39
	ctx.cr[6].compare_i32(ctx.r[11].s32, 57, &mut ctx.xer);
	// 825ADD14: 419A003C  beq cr6, 0x825add50
	if ctx.cr[6].eq {
	pc = 0x825ADD50; continue 'dispatch;
	}
	// 825ADD18: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 825ADD1C: C01D0008  lfs f0, 8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADD20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825ADD24: 419A0010  beq cr6, 0x825add34
	if ctx.cr[6].eq {
	pc = 0x825ADD34; continue 'dispatch;
	}
	// 825ADD28: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825ADD2C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825ADD30: 48000008  b 0x825add38
	pc = 0x825ADD38; continue 'dispatch;
            }
            0x825ADD34 => {
    //   block [0x825ADD34..0x825ADD38)
	// 825ADD34: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x825ADD38; continue 'dispatch;
            }
            0x825ADD38 => {
    //   block [0x825ADD38..0x825ADD50)
	// 825ADD38: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825ADD3C: 38DD0004  addi r6, r29, 4
	ctx.r[6].s64 = ctx.r[29].s64 + 4;
	// 825ADD40: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825ADD44: 389E0018  addi r4, r30, 0x18
	ctx.r[4].s64 = ctx.r[30].s64 + 24;
	// 825ADD48: 387E0050  addi r3, r30, 0x50
	ctx.r[3].s64 = ctx.r[30].s64 + 80;
	// 825ADD4C: 4800112D  bl 0x825aee78
	ctx.lr = 0x825ADD50;
	sub_825AEE78(ctx, base);
	pc = 0x825ADD50; continue 'dispatch;
            }
            0x825ADD50 => {
    //   block [0x825ADD50..0x825ADD58)
	// 825ADD50: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825ADD54: 486FB704  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825ADD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825ADD58 size=2584
    let mut pc: u32 = 0x825ADD58;
    'dispatch: loop {
        match pc {
            0x825ADD58 => {
    //   block [0x825ADD58..0x825ADDE0)
	// 825ADD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825ADD5C: 486FB69D  bl 0x82ca93f8
	ctx.lr = 0x825ADD60;
	sub_82CA93D0(ctx, base);
	// 825ADD60: 9421F700  stwu r1, -0x900(r1)
	ea = ctx.r[1].u32.wrapping_add(-2304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825ADD64: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825ADD68: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825ADD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825ADD70: 894B6BE9  lbz r10, 0x6be9(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27625 as u32) ) } as u64;
	// 825ADD74: 817A002C  lwz r11, 0x2c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(44 as u32) ) } as u64;
	// 825ADD78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825ADD7C: 419A04BC  beq cr6, 0x825ae238
	if ctx.cr[6].eq {
	pc = 0x825AE238; continue 'dispatch;
	}
	// 825ADD80: 2F0B000B  cmpwi cr6, r11, 0xb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 11, &mut ctx.xer);
	// 825ADD84: 409A005C  bne cr6, 0x825adde0
	if !ctx.cr[6].eq {
	pc = 0x825ADDE0; continue 'dispatch;
	}
	// 825ADD88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825ADD8C: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADD90: 48451041  bl 0x829fedd0
	ctx.lr = 0x825ADD94;
	sub_829FEDD0(ctx, base);
	// 825ADD94: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ADD98: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADD9C: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADDA0: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825ADDA4: 4845102D  bl 0x829fedd0
	ctx.lr = 0x825ADDA8;
	sub_829FEDD0(ctx, base);
	// 825ADDA8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 825ADDAC: C1A10070  lfs f13, 0x70(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ADDB0: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825ADDB4: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825ADDB8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ADDBC: 38C10058  addi r6, r1, 0x58
	ctx.r[6].s64 = ctx.r[1].s64 + 88;
	// 825ADDC0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ADDC4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADDC8: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825ADDCC: 480010AD  bl 0x825aee78
	ctx.lr = 0x825ADDD0;
	sub_825AEE78(ctx, base);
	// 825ADDD0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ADDD4: 995A0038  stb r10, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 825ADDD8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825ADDDC: 486FB66C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825ADDE0 => {
    //   block [0x825ADDE0..0x825ADE40)
	// 825ADDE0: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 825ADDE4: 409A005C  bne cr6, 0x825ade40
	if !ctx.cr[6].eq {
	pc = 0x825ADE40; continue 'dispatch;
	}
	// 825ADDE8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825ADDEC: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADDF0: 48450FE1  bl 0x829fedd0
	ctx.lr = 0x825ADDF4;
	sub_829FEDD0(ctx, base);
	// 825ADDF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825ADDF8: C0010074  lfs f0, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825ADDFC: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825ADE00: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825ADE04: 48450FCD  bl 0x829fedd0
	ctx.lr = 0x825ADE08;
	sub_829FEDD0(ctx, base);
	// 825ADE08: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 825ADE0C: C1A10060  lfs f13, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825ADE10: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825ADE14: 38E10058  addi r7, r1, 0x58
	ctx.r[7].s64 = ctx.r[1].s64 + 88;
	// 825ADE18: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825ADE1C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825ADE20: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825ADE24: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825ADE28: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825ADE2C: 4800104D  bl 0x825aee78
	ctx.lr = 0x825ADE30;
	sub_825AEE78(ctx, base);
	// 825ADE30: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825ADE34: 995A0038  stb r10, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[10].u8 ) };
	// 825ADE38: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825ADE3C: 486FB60C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825ADE40 => {
    //   block [0x825ADE40..0x825ADFF8)
	// 825ADE40: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825ADE44: 409A0924  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825ADE48: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825ADE4C: 396BFFEF  addi r11, r11, -0x11
	ctx.r[11].s64 = ctx.r[11].s64 + -17;
	// 825ADE50: 2B0B0061  cmplwi cr6, r11, 0x61
	ctx.cr[6].compare_u32(ctx.r[11].u32, 97 as u32, &mut ctx.xer);
	// 825ADE54: 41990914  bgt cr6, 0x825ae768
	if ctx.cr[6].gt {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825ADE58: 3D80825B  lis r12, -0x7da5
	ctx.r[12].s64 = -2107965440;
	// 825ADE5C: 398CDE70  addi r12, r12, -0x2190
	ctx.r[12].s64 = ctx.r[12].s64 + -8592;
	// 825ADE60: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 825ADE64: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 825ADE68: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 825ADE6C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x825ADFF8; continue 'dispatch;
		},
		1 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		2 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		3 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		4 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		5 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		6 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		7 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		8 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		9 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		10 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		11 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		12 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		13 => {
	pc = 0x825AE088; continue 'dispatch;
		},
		14 => {
	pc = 0x825AE040; continue 'dispatch;
		},
		15 => {
	pc = 0x825AE0D0; continue 'dispatch;
		},
		16 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		17 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		18 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		19 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		20 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		21 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		22 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		23 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		24 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		25 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		26 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		27 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		28 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		29 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		30 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		31 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		32 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		33 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		34 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		35 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		36 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		37 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		38 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		39 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		40 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		41 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		42 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		43 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		44 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		45 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		46 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		47 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		48 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		49 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		50 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		51 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		52 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		53 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		54 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		55 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		56 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		57 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		58 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		59 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		60 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		61 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		62 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		63 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		64 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		65 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		66 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		67 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		68 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		69 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		70 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		71 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		72 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		73 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		74 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		75 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		76 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		77 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		78 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		79 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		80 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		81 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		82 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		83 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		84 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		85 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		86 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		87 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		88 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		89 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		90 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		91 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		92 => {
	pc = 0x825AE118; continue 'dispatch;
		},
		93 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		94 => {
	pc = 0x825AE1A8; continue 'dispatch;
		},
		95 => {
	pc = 0x825AE1F0; continue 'dispatch;
		},
		96 => {
	pc = 0x825AE768; continue 'dispatch;
		},
		97 => {
	pc = 0x825AE160; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 825ADE70: 825ADFF8  lwz r18, -0x2008(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8200 as u32) ) } as u64;
	// 825ADE74: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE78: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE7C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE80: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE84: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE88: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE8C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE90: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE94: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE98: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADE9C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEA0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEA4: 825AE088  lwz r18, -0x1f78(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8056 as u32) ) } as u64;
	// 825ADEA8: 825AE040  lwz r18, -0x1fc0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-8128 as u32) ) } as u64;
	// 825ADEAC: 825AE0D0  lwz r18, -0x1f30(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7984 as u32) ) } as u64;
	// 825ADEB0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEB4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEB8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEBC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEC8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADECC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADED8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEDC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEE8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEEC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEF8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADEFC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF00: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF04: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF08: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF0C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF10: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF14: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF18: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF1C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF20: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF24: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF28: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF2C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF30: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF34: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF38: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF3C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF40: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF44: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF48: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF4C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF50: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF54: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF58: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF5C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF60: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF64: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF68: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF6C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF70: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF74: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF78: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF7C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF80: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF84: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF88: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF8C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF90: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF94: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF98: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADF9C: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFA8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFAC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFB8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFBC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFC8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFCC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFD8: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFDC: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFE0: 825AE118  lwz r18, -0x1ee8(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7912 as u32) ) } as u64;
	// 825ADFE4: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFE8: 825AE1A8  lwz r18, -0x1e58(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7768 as u32) ) } as u64;
	// 825ADFEC: 825AE1F0  lwz r18, -0x1e10(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7696 as u32) ) } as u64;
	// 825ADFF0: 825AE768  lwz r18, -0x1898(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-6296 as u32) ) } as u64;
	// 825ADFF4: 825AE160  lwz r18, -0x1ea0(r26)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7840 as u32) ) } as u64;
            }
            0x825ADFF8 => {
    //   block [0x825ADFF8..0x825AE040)
	// 825ADFF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825ADFFC: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE000: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE004: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE008: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE00C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE010: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE014: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE018: C0094138  lfs f0, 0x4138(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE01C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE020: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE024: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE028: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE02C: 48000E4D  bl 0x825aee78
	ctx.lr = 0x825AE030;
	sub_825AEE78(ctx, base);
	// 825AE030: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE034: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE038: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE03C: 486FB40C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE040 => {
    //   block [0x825AE040..0x825AE088)
	// 825AE040: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE044: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE048: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE04C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE050: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE054: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE058: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE05C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE060: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE064: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE068: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE06C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE070: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE074: 48000E05  bl 0x825aee78
	ctx.lr = 0x825AE078;
	sub_825AEE78(ctx, base);
	// 825AE078: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE07C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE080: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE084: 486FB3C4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE088 => {
    //   block [0x825AE088..0x825AE0D0)
	// 825AE088: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE08C: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE090: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE094: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE098: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE09C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE0A0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE0A4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE0A8: C009FFF4  lfs f0, -0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0AC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE0B0: C1A94138  lfs f13, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE0B4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE0B8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE0BC: 48000DBD  bl 0x825aee78
	ctx.lr = 0x825AE0C0;
	sub_825AEE78(ctx, base);
	// 825AE0C0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE0C4: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE0C8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE0CC: 486FB37C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE0D0 => {
    //   block [0x825AE0D0..0x825AE118)
	// 825AE0D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE0D4: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825AE0D8: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE0DC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE0E0: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825AE0E4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AE0E8: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0EC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE0F0: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE0F4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE0F8: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE0FC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE100: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE104: 48000D75  bl 0x825aee78
	ctx.lr = 0x825AE108;
	sub_825AEE78(ctx, base);
	// 825AE108: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE10C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE110: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE114: 486FB334  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE118 => {
    //   block [0x825AE118..0x825AE160)
	// 825AE118: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE11C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE120: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE124: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE128: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE12C: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE130: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE134: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE138: C0094138  lfs f0, 0x4138(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE13C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE140: C1A9FFF4  lfs f13, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE144: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE148: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE14C: 48000D2D  bl 0x825aee78
	ctx.lr = 0x825AE150;
	sub_825AEE78(ctx, base);
	// 825AE150: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE154: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE158: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE15C: 486FB2EC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE160 => {
    //   block [0x825AE160..0x825AE1A8)
	// 825AE160: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE164: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE168: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE16C: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE170: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE174: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE178: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE17C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE180: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE184: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE188: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE18C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE190: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE194: 48000CE5  bl 0x825aee78
	ctx.lr = 0x825AE198;
	sub_825AEE78(ctx, base);
	// 825AE198: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE19C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE1A0: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE1A4: 486FB2A4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE1A8 => {
    //   block [0x825AE1A8..0x825AE1F0)
	// 825AE1A8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE1AC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE1B0: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE1B4: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE1B8: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 825AE1BC: 38C10054  addi r6, r1, 0x54
	ctx.r[6].s64 = ctx.r[1].s64 + 84;
	// 825AE1C0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE1C4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE1C8: C009FFF4  lfs f0, -0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE1CC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE1D0: C1A94138  lfs f13, 0x4138(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16696 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE1D4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE1D8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE1DC: 48000C9D  bl 0x825aee78
	ctx.lr = 0x825AE1E0;
	sub_825AEE78(ctx, base);
	// 825AE1E0: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE1E4: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE1E8: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE1EC: 486FB25C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE1F0 => {
    //   block [0x825AE1F0..0x825AE238)
	// 825AE1F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE1F4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AE1F8: 392B9490  addi r9, r11, -0x6b70
	ctx.r[9].s64 = ctx.r[11].s64 + -27504;
	// 825AE1FC: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE200: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 825AE204: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825AE208: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE20C: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE210: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 825AE214: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE218: C009FFF4  lfs f0, -0xc(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE21C: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE220: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825AE224: 48000C55  bl 0x825aee78
	ctx.lr = 0x825AE228;
	sub_825AEE78(ctx, base);
	// 825AE228: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AE22C: 991A0038  stb r8, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[8].u8 ) };
	// 825AE230: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE234: 486FB214  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE238 => {
    //   block [0x825AE238..0x825AE2BC)
	// 825AE238: 2F0B000D  cmpwi cr6, r11, 0xd
	ctx.cr[6].compare_i32(ctx.r[11].s32, 13, &mut ctx.xer);
	// 825AE23C: 409A04B8  bne cr6, 0x825ae6f4
	if !ctx.cr[6].eq {
	pc = 0x825AE6F4; continue 'dispatch;
	}
	// 825AE240: 897A0008  lbz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE244: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 825AE248: 409A027C  bne cr6, 0x825ae4c4
	if !ctx.cr[6].eq {
	pc = 0x825AE4C4; continue 'dispatch;
	}
	// 825AE24C: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825AE250: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE254: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE258: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE25C: 83AA009C  lwz r29, 0x9c(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AE264: 4BCB5FCD  bl 0x82264230
	ctx.lr = 0x825AE268;
	sub_82264230(ctx, base);
	// 825AE268: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AE26C: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825AE270: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE274: 419A0168  beq cr6, 0x825ae3dc
	if ctx.cr[6].eq {
	pc = 0x825AE3DC; continue 'dispatch;
	}
	// 825AE278: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE27C: 83DA0028  lwz r30, 0x28(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE280: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 825AE284: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825AE288: 5525DFFE  rlwinm r5, r9, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 825AE28C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AE290: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE294: 409A0028  bne cr6, 0x825ae2bc
	if !ctx.cr[6].eq {
	pc = 0x825AE2BC; continue 'dispatch;
	}
	// 825AE298: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE29C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AE2A0: 4BCB5F91  bl 0x82264230
	ctx.lr = 0x825AE2A4;
	sub_82264230(ctx, base);
	// 825AE2A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE2A8: 419A0014  beq cr6, 0x825ae2bc
	if ctx.cr[6].eq {
	pc = 0x825AE2BC; continue 'dispatch;
	}
	// 825AE2AC: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE2B0: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 825AE2B4: 7D490034  cntlzw r9, r10
	ctx.r[9].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 825AE2B8: 5525DFFE  rlwinm r5, r9, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	pc = 0x825AE2BC; continue 'dispatch;
            }
            0x825AE2BC => {
    //   block [0x825AE2BC..0x825AE308)
	// 825AE2BC: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825AE2C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE2C4: 419A0114  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE2C8: 7F8B0034  cntlzw r11, r28
	ctx.r[11].u64 = if ctx.r[28].u32 == 0 { 32 } else { ctx.r[28].u32.leading_zeros() as u64 };
	// 825AE2CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AE2D0: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825AE2D4: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE2D8: 394B000A  addi r10, r11, 0xa
	ctx.r[10].s64 = ctx.r[11].s64 + 10;
	// 825AE2DC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE2E0: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AE2E4: 48000CE5  bl 0x825aefc8
	ctx.lr = 0x825AE2E8;
	sub_825AEFC8(ctx, base);
	// 825AE2E8: 813B6AB8  lwz r9, 0x6ab8(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE2EC: 8169000C  lwz r11, 0xc(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE2F0: 810B011C  lwz r8, 0x11c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE2F4: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 825AE2F8: 409A0010  bne cr6, 0x825ae308
	if !ctx.cr[6].eq {
	pc = 0x825AE308; continue 'dispatch;
	}
	// 825AE2FC: 38800047  li r4, 0x47
	ctx.r[4].s64 = 71;
	// 825AE300: 806B00A8  lwz r3, 0xa8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 825AE304: 4BEA2615  bl 0x82450918
	ctx.lr = 0x825AE308;
	sub_82450918(ctx, base);
	pc = 0x825AE308; continue 'dispatch;
            }
            0x825AE308 => {
    //   block [0x825AE308..0x825AE36C)
	// 825AE308: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE30C: 815A0028  lwz r10, 0x28(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE310: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE314: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825AE318: 409A00C0  bne cr6, 0x825ae3d8
	if !ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE31C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE320: 480004C9  bl 0x825ae7e8
	ctx.lr = 0x825AE324;
	sub_825AE7E8(ctx, base);
	// 825AE324: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE328: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE32C: 419A00AC  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE330: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AE334: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE338: 4BC3A859  bl 0x821e8b90
	ctx.lr = 0x825AE33C;
	sub_821E8B90(ctx, base);
	// 825AE33C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE344: 409A0094  bne cr6, 0x825ae3d8
	if !ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	// 825AE348: 817B6AB8  lwz r11, 0x6ab8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE34C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE350: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE354: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825AE358: 409A0014  bne cr6, 0x825ae36c
	if !ctx.cr[6].eq {
	pc = 0x825AE36C; continue 'dispatch;
	}
	// 825AE35C: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE360: 894B00DE  lbz r10, 0xde(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(222 as u32) ) } as u64;
	// 825AE364: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE368: 419A0070  beq cr6, 0x825ae3d8
	if ctx.cr[6].eq {
	pc = 0x825AE3D8; continue 'dispatch;
	}
	pc = 0x825AE36C; continue 'dispatch;
            }
            0x825AE36C => {
    //   block [0x825AE36C..0x825AE3A8)
	// 825AE36C: 38600014  li r3, 0x14
	ctx.r[3].s64 = 20;
	// 825AE370: 4BC70EE9  bl 0x8221f258
	ctx.lr = 0x825AE374;
	sub_8221F258(ctx, base);
	// 825AE374: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE378: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AE37C: 419A002C  beq cr6, 0x825ae3a8
	if ctx.cr[6].eq {
	pc = 0x825AE3A8; continue 'dispatch;
	}
	// 825AE380: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE384: 4BCF0AF5  bl 0x8229ee78
	ctx.lr = 0x825AE388;
	sub_8229EE78(ctx, base);
	// 825AE388: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE38C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE390: 4BDBEC81  bl 0x8236d010
	ctx.lr = 0x825AE394;
	sub_8236D010(ctx, base);
	// 825AE394: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AE398: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825AE39C: 392A5098  addi r9, r10, 0x5098
	ctx.r[9].s64 = ctx.r[10].s64 + 20632;
	// 825AE3A0: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AE3A4: 48000008  b 0x825ae3ac
	pc = 0x825AE3AC; continue 'dispatch;
            }
            0x825AE3A8 => {
    //   block [0x825AE3A8..0x825AE3AC)
	// 825AE3A8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE3AC; continue 'dispatch;
            }
            0x825AE3AC => {
    //   block [0x825AE3AC..0x825AE3C8)
	// 825AE3AC: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825AE3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE3B4: 419A0014  beq cr6, 0x825ae3c8
	if ctx.cr[6].eq {
	pc = 0x825AE3C8; continue 'dispatch;
	}
	// 825AE3B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AE3BC: 48456905  bl 0x82a04cc0
	ctx.lr = 0x825AE3C0;
	sub_82A04CC0(ctx, base);
	// 825AE3C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AE3C4: 4800000C  b 0x825ae3d0
	pc = 0x825AE3D0; continue 'dispatch;
            }
            0x825AE3C8 => {
    //   block [0x825AE3C8..0x825AE3D0)
	// 825AE3C8: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825AE3CC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	pc = 0x825AE3D0; continue 'dispatch;
            }
            0x825AE3D0 => {
    //   block [0x825AE3D0..0x825AE3D8)
	// 825AE3D0: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE3D4: 4BDDB7AD  bl 0x82389b80
	ctx.lr = 0x825AE3D8;
	sub_82389B80(ctx, base);
	pc = 0x825AE3D8; continue 'dispatch;
            }
            0x825AE3D8 => {
    //   block [0x825AE3D8..0x825AE3DC)
	// 825AE3D8: 9B1A0038  stb r24, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[24].u8 ) };
	pc = 0x825AE3DC; continue 'dispatch;
            }
            0x825AE3DC => {
    //   block [0x825AE3DC..0x825AE404)
	// 825AE3DC: 815B6AB8  lwz r10, 0x6ab8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE3E0: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE3E4: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE3E8: 892B0034  lbz r9, 0x34(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 825AE3EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE3F0: 419A0014  beq cr6, 0x825ae404
	if ctx.cr[6].eq {
	pc = 0x825AE404; continue 'dispatch;
	}
	// 825AE3F4: 896B0036  lbz r11, 0x36(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 825AE3F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE3FC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE400: 409A0008  bne cr6, 0x825ae408
	if !ctx.cr[6].eq {
	pc = 0x825AE408; continue 'dispatch;
	}
	pc = 0x825AE404; continue 'dispatch;
            }
            0x825AE404 => {
    //   block [0x825AE404..0x825AE408)
	// 825AE404: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE408; continue 'dispatch;
            }
            0x825AE408 => {
    //   block [0x825AE408..0x825AE4B8)
	// 825AE408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE40C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE410: 419A0358  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE414: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE418: 396B6474  addi r11, r11, 0x6474
	ctx.r[11].s64 = ctx.r[11].s64 + 25716;
	// 825AE41C: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825AE420: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE424: 83EA008C  lwz r31, 0x8c(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE428: 813F0064  lwz r9, 0x64(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AE42C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE430: 40990088  ble cr6, 0x825ae4b8
	if !ctx.cr[6].gt {
	pc = 0x825AE4B8; continue 'dispatch;
	}
	// 825AE434: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE438: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825AE43C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825AE440: 4E800421  bctrl
	ctx.lr = 0x825AE444;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AE444: B0610060  sth r3, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u16 ) };
	// 825AE448: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825AE44C: 388100AC  addi r4, r1, 0xac
	ctx.r[4].s64 = ctx.r[1].s64 + 172;
	// 825AE450: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 825AE454: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825AE458: 9B010068  stb r24, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[24].u8 ) };
	// 825AE45C: 486D9B85  bl 0x82c87fe0
	ctx.lr = 0x825AE460;
	sub_82C87FE0(ctx, base);
	// 825AE460: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825AE464: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825AE468: 39093D70  addi r8, r9, 0x3d70
	ctx.r[8].s64 = ctx.r[9].s64 + 15728;
	// 825AE46C: 388100A4  addi r4, r1, 0xa4
	ctx.r[4].s64 = ctx.r[1].s64 + 164;
	// 825AE470: 910100A0  stw r8, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 825AE474: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AE478: 486D9B29  bl 0x82c87fa0
	ctx.lr = 0x825AE47C;
	sub_82C87FA0(ctx, base);
	// 825AE47C: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 825AE480: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AE484: 38C73C90  addi r6, r7, 0x3c90
	ctx.r[6].s64 = ctx.r[7].s64 + 15504;
	// 825AE488: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825AE48C: 90C10080  stw r6, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[6].u32 ) };
	// 825AE490: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825AE494: 4BD5B6A5  bl 0x82309b38
	ctx.lr = 0x825AE498;
	sub_82309B38(ctx, base);
	// 825AE498: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825AE49C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825AE4A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE4A4: 4BD86FD5  bl 0x82335478
	ctx.lr = 0x825AE4A8;
	sub_82335478(ctx, base);
	// 825AE4A8: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825AE4AC: 485E89CD  bl 0x82b96e78
	ctx.lr = 0x825AE4B0;
	sub_82B96E78(ctx, base);
	// 825AE4B0: 386100A4  addi r3, r1, 0xa4
	ctx.r[3].s64 = ctx.r[1].s64 + 164;
	// 825AE4B4: 485E89C5  bl 0x82b96e78
	ctx.lr = 0x825AE4B8;
	sub_82B96E78(ctx, base);
            }
            0x825AE4B8 => {
    //   block [0x825AE4B8..0x825AE4C4)
	// 825AE4B8: 9B1A0038  stb r24, 0x38(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(56 as u32), ctx.r[24].u8 ) };
	// 825AE4BC: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE4C0: 486FAF88  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE4C4 => {
    //   block [0x825AE4C4..0x825AE510)
	// 825AE4C4: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 825AE4C8: 409A02A0  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE4CC: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AE4D0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE4D4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE4D8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE4DC: 83CA009C  lwz r30, 0x9c(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE4E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE4E4: 4BCB5D4D  bl 0x82264230
	ctx.lr = 0x825AE4E8;
	sub_82264230(ctx, base);
	// 825AE4E8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE4EC: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825AE4F0: 3B000001  li r24, 1
	ctx.r[24].s64 = 1;
	// 825AE4F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AE4F8: 419A0018  beq cr6, 0x825ae510
	if ctx.cr[6].eq {
	pc = 0x825AE510; continue 'dispatch;
	}
	// 825AE4FC: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE500: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE504: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825AE508: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE50C: 419A0008  beq cr6, 0x825ae514
	if ctx.cr[6].eq {
	pc = 0x825AE514; continue 'dispatch;
	}
	pc = 0x825AE510; continue 'dispatch;
            }
            0x825AE510 => {
    //   block [0x825AE510..0x825AE514)
	// 825AE510: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE514; continue 'dispatch;
            }
            0x825AE514 => {
    //   block [0x825AE514..0x825AE54C)
	// 825AE514: 5565063E  clrlwi r5, r11, 0x18
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE518: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825AE51C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825AE520: 409A002C  bne cr6, 0x825ae54c
	if !ctx.cr[6].eq {
	pc = 0x825AE54C; continue 'dispatch;
	}
	// 825AE524: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE528: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE52C: 4BCB5D05  bl 0x82264230
	ctx.lr = 0x825AE530;
	sub_82264230(ctx, base);
	// 825AE530: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE534: 419A0018  beq cr6, 0x825ae54c
	if ctx.cr[6].eq {
	pc = 0x825AE54C; continue 'dispatch;
	}
	// 825AE538: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE53C: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE540: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825AE544: 7D280034  cntlzw r8, r9
	ctx.r[8].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 825AE548: 5505DFFE  rlwinm r5, r8, 0x1b, 0x1f, 0x1f
	ctx.r[5].u64 = ctx.r[8].u32 as u64 & 0x0000001Fu64;
	pc = 0x825AE54C; continue 'dispatch;
            }
            0x825AE54C => {
    //   block [0x825AE54C..0x825AE570)
	// 825AE54C: 54AB063E  clrlwi r11, r5, 0x18
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825AE550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE554: 419A0214  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE558: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825AE55C: 409A0014  bne cr6, 0x825ae570
	if !ctx.cr[6].eq {
	pc = 0x825AE570; continue 'dispatch;
	}
	// 825AE560: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825AE564: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE568: 4BCB5CC9  bl 0x82264230
	ctx.lr = 0x825AE56C;
	sub_82264230(ctx, base);
	// 825AE56C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x825AE570; continue 'dispatch;
            }
            0x825AE570 => {
    //   block [0x825AE570..0x825AE5B8)
	// 825AE570: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AE574: 419A01F4  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE578: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 825AE57C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE580: 4BC3A611  bl 0x821e8b90
	ctx.lr = 0x825AE584;
	sub_821E8B90(ctx, base);
	// 825AE584: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE588: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE58C: 409A01DC  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE590: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE594: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	// 825AE598: 4BCF08E1  bl 0x8229ee78
	ctx.lr = 0x825AE59C;
	sub_8229EE78(ctx, base);
	// 825AE59C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE5A0: 419A0018  beq cr6, 0x825ae5b8
	if ctx.cr[6].eq {
	pc = 0x825AE5B8; continue 'dispatch;
	}
	// 825AE5A4: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825AE5A8: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825AE5AC: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE5B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE5B4: 409A0008  bne cr6, 0x825ae5bc
	if !ctx.cr[6].eq {
	pc = 0x825AE5BC; continue 'dispatch;
	}
	pc = 0x825AE5B8; continue 'dispatch;
            }
            0x825AE5B8 => {
    //   block [0x825AE5B8..0x825AE5BC)
	// 825AE5B8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE5BC; continue 'dispatch;
            }
            0x825AE5BC => {
    //   block [0x825AE5BC..0x825AE60C)
	// 825AE5BC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE5C4: 419A01A4  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE5C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE5CC: 4BCF08AD  bl 0x8229ee78
	ctx.lr = 0x825AE5D0;
	sub_8229EE78(ctx, base);
	// 825AE5D0: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE5D4: 556AFFFE  rlwinm r10, r11, 0x1f, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 825AE5D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE5DC: 419A00F4  beq cr6, 0x825ae6d0
	if ctx.cr[6].eq {
	pc = 0x825AE6D0; continue 'dispatch;
	}
	// 825AE5E0: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE5E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE5E8: 419A0024  beq cr6, 0x825ae60c
	if ctx.cr[6].eq {
	pc = 0x825AE60C; continue 'dispatch;
	}
	// 825AE5EC: 894B0021  lbz r10, 0x21(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(33 as u32) ) } as u64;
	// 825AE5F0: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE5F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AE5F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AE5FC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE600: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE604: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE608: 480000CC  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
            }
            0x825AE60C => {
    //   block [0x825AE60C..0x825AE628)
	// 825AE60C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE610: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AE614: 93210058  stw r25, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[25].u32 ) };
	// 825AE618: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AE61C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825AE620: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE624: 40810054  ble 0x825ae678
	if !ctx.cr[0].gt {
	pc = 0x825AE678; continue 'dispatch;
	}
	pc = 0x825AE628; continue 'dispatch;
            }
            0x825AE628 => {
    //   block [0x825AE628..0x825AE648)
	// 825AE628: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AE62C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AE630: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825AE634: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE638: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825AE63C: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 825AE640: 41980008  blt cr6, 0x825ae648
	if ctx.cr[6].lt {
	pc = 0x825AE648; continue 'dispatch;
	}
	// 825AE644: 7F27CB78  mr r7, r25
	ctx.r[7].u64 = ctx.r[25].u64;
	pc = 0x825AE648; continue 'dispatch;
            }
            0x825AE648 => {
    //   block [0x825AE648..0x825AE664)
	// 825AE648: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AE64C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AE650: 419A0014  beq cr6, 0x825ae664
	if ctx.cr[6].eq {
	pc = 0x825AE664; continue 'dispatch;
	}
	// 825AE654: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AE658: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AE65C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AE660: 4800000C  b 0x825ae66c
	pc = 0x825AE66C; continue 'dispatch;
            }
            0x825AE664 => {
    //   block [0x825AE664..0x825AE66C)
	// 825AE664: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AE668: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AE66C; continue 'dispatch;
            }
            0x825AE66C => {
    //   block [0x825AE66C..0x825AE678)
	// 825AE66C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE670: 4199FFB8  bgt cr6, 0x825ae628
	if ctx.cr[6].gt {
	pc = 0x825AE628; continue 'dispatch;
	}
	// 825AE674: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x825AE678; continue 'dispatch;
            }
            0x825AE678 => {
    //   block [0x825AE678..0x825AE694)
	// 825AE678: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AE67C: 419A0040  beq cr6, 0x825ae6bc
	if ctx.cr[6].eq {
	pc = 0x825AE6BC; continue 'dispatch;
	}
	// 825AE680: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE684: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825AE688: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE68C: 41990008  bgt cr6, 0x825ae694
	if ctx.cr[6].gt {
	pc = 0x825AE694; continue 'dispatch;
	}
	// 825AE690: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE694; continue 'dispatch;
            }
            0x825AE694 => {
    //   block [0x825AE694..0x825AE6BC)
	// 825AE694: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE69C: 409A0020  bne cr6, 0x825ae6bc
	if !ctx.cr[6].eq {
	pc = 0x825AE6BC; continue 'dispatch;
	}
	// 825AE6A0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AE6A4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825AE6A8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825AE6AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE6B0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE6B4: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE6B8: 4800001C  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
            }
            0x825AE6BC => {
    //   block [0x825AE6BC..0x825AE6D0)
	// 825AE6BC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AE6C0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE6C4: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825AE6C8: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	// 825AE6CC: 48000008  b 0x825ae6d4
	pc = 0x825AE6D4; continue 'dispatch;
            }
            0x825AE6D0 => {
    //   block [0x825AE6D0..0x825AE6D4)
	// 825AE6D0: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825AE6D4; continue 'dispatch;
            }
            0x825AE6D4 => {
    //   block [0x825AE6D4..0x825AE6F4)
	// 825AE6D4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE6D8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE6DC: 419A008C  beq cr6, 0x825ae768
	if ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE6E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AE6E8: 4BE3B829  bl 0x823e9f10
	ctx.lr = 0x825AE6EC;
	sub_823E9F10(ctx, base);
	// 825AE6EC: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE6F0: 486FAD58  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825AE6F4 => {
    //   block [0x825AE6F4..0x825AE768)
	// 825AE6F4: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 825AE6F8: 409A0070  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE6FC: 3FE08349  lis r31, -0x7cb7
	ctx.r[31].s64 = -2092367872;
	// 825AE700: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE704: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE708: 814B011C  lwz r10, 0x11c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(284 as u32) ) } as u64;
	// 825AE70C: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825AE710: 409A0058  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE714: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE718: 894B00DE  lbz r10, 0xde(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(222 as u32) ) } as u64;
	// 825AE71C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE720: 409A0048  bne cr6, 0x825ae768
	if !ctx.cr[6].eq {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE724: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AE728: E89A0000  ld r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	// 825AE72C: 484506A5  bl 0x829fedd0
	ctx.lr = 0x825AE730;
	sub_829FEDD0(ctx, base);
	// 825AE730: C001005C  lfs f0, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE734: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 825AE738: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825AE73C: C1AB9A80  lfs f13, -0x6580(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825AE740: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AE744: ED60603A  fmadds f11, f0, f0, f12
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 825AE748: FF0B6800  fcmpu cr6, f11, f13
	ctx.cr[6].compare_f64(ctx.f[11].f64, ctx.f[13].f64);
	// 825AE74C: 4099001C  ble cr6, 0x825ae768
	if !ctx.cr[6].gt {
	pc = 0x825AE768; continue 'dispatch;
	}
	// 825AE750: 817F6AB8  lwz r11, 0x6ab8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE754: 38800047  li r4, 0x47
	ctx.r[4].s64 = 71;
	// 825AE758: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE75C: 814B00A8  lwz r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) } as u64;
	// 825AE760: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE764: 4BC06AFD  bl 0x821b5260
	ctx.lr = 0x825AE768;
	sub_821B5260(ctx, base);
	pc = 0x825AE768; continue 'dispatch;
            }
            0x825AE768 => {
    //   block [0x825AE768..0x825AE770)
	// 825AE768: 38210900  addi r1, r1, 0x900
	ctx.r[1].s64 = ctx.r[1].s64 + 2304;
	// 825AE76C: 486FACDC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825AE770 size=24
    let mut pc: u32 = 0x825AE770;
    'dispatch: loop {
        match pc {
            0x825AE770 => {
    //   block [0x825AE770..0x825AE788)
	// 825AE770: 8963006A  lbz r11, 0x6a(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(106 as u32) ) } as u64;
	// 825AE774: 214B0000  subfic r10, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[10].s64 = (0 as i64) - ctx.r[11].s64;
	// 825AE778: 7D2A5110  subfe r9, r10, r10
	let x = (!ctx.r[10].u32);
	let y = ctx.r[10].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[9].u32 = res;
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825AE77C: 552B077A  rlwinm r11, r9, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 825AE780: 386B0005  addi r3, r11, 5
	ctx.r[3].s64 = ctx.r[11].s64 + 5;
	// 825AE784: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE788(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE788 size=96
    let mut pc: u32 = 0x825AE788;
    'dispatch: loop {
        match pc {
            0x825AE788 => {
    //   block [0x825AE788..0x825AE7D4)
	// 825AE788: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE78C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE790: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE794: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE798: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825AE79C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825AE7A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AE7A4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825AE7A8: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE7AC: 806A009C  lwz r3, 0x9c(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) } as u64;
	// 825AE7B0: 4BCB5A81  bl 0x82264230
	ctx.lr = 0x825AE7B4;
	sub_82264230(ctx, base);
	// 825AE7B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AE7B8: 419A001C  beq cr6, 0x825ae7d4
	if ctx.cr[6].eq {
	pc = 0x825AE7D4; continue 'dispatch;
	}
	// 825AE7BC: 3960000B  li r11, 0xb
	ctx.r[11].s64 = 11;
	// 825AE7C0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AE7C4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825AE7C8: 389F0018  addi r4, r31, 0x18
	ctx.r[4].s64 = ctx.r[31].s64 + 24;
	// 825AE7CC: 387F0050  addi r3, r31, 0x50
	ctx.r[3].s64 = ctx.r[31].s64 + 80;
	// 825AE7D0: 480007F9  bl 0x825aefc8
	ctx.lr = 0x825AE7D4;
	sub_825AEFC8(ctx, base);
	pc = 0x825AE7D4; continue 'dispatch;
            }
            0x825AE7D4 => {
    //   block [0x825AE7D4..0x825AE7E8)
	// 825AE7D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE7D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE7DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE7E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE7E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE7E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE7E8 size=436
    let mut pc: u32 = 0x825AE7E8;
    'dispatch: loop {
        match pc {
            0x825AE7E8 => {
    //   block [0x825AE7E8..0x825AE82C)
	// 825AE7E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE7EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AE7F0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AE7F4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AE7F8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE7FC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AE800: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AE804: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE808: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825AE80C: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825AE810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE814: 419A001C  beq cr6, 0x825ae830
	if ctx.cr[6].eq {
	pc = 0x825AE830; continue 'dispatch;
	}
	// 825AE818: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE81C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE820: 419A000C  beq cr6, 0x825ae82c
	if ctx.cr[6].eq {
	pc = 0x825AE82C; continue 'dispatch;
	}
	// 825AE824: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825AE828: 4800000C  b 0x825ae834
	pc = 0x825AE834; continue 'dispatch;
            }
            0x825AE82C => {
    //   block [0x825AE82C..0x825AE830)
	// 825AE82C: 4BBE560D  bl 0x82193e38
	ctx.lr = 0x825AE830;
	sub_82193E38(ctx, base);
	pc = 0x825AE830; continue 'dispatch;
            }
            0x825AE830 => {
    //   block [0x825AE830..0x825AE834)
	// 825AE830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825AE834; continue 'dispatch;
            }
            0x825AE834 => {
    //   block [0x825AE834..0x825AE870)
	// 825AE834: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AE838: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 825AE83C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE840: 419A00F4  beq cr6, 0x825ae934
	if ctx.cr[6].eq {
	pc = 0x825AE934; continue 'dispatch;
	}
	// 825AE844: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AE848: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AE84C: 419A0024  beq cr6, 0x825ae870
	if ctx.cr[6].eq {
	pc = 0x825AE870; continue 'dispatch;
	}
	// 825AE850: 892A0031  lbz r9, 0x31(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 825AE854: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE858: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825AE85C: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825AE860: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE864: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE868: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE86C: 480000CC  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
            }
            0x825AE870 => {
    //   block [0x825AE870..0x825AE88C)
	// 825AE870: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AE874: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AE878: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825AE87C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AE880: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AE884: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE888: 40810054  ble 0x825ae8dc
	if !ctx.cr[0].gt {
	pc = 0x825AE8DC; continue 'dispatch;
	}
	pc = 0x825AE88C; continue 'dispatch;
            }
            0x825AE88C => {
    //   block [0x825AE88C..0x825AE8AC)
	// 825AE88C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AE890: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AE894: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AE898: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE89C: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825AE8A0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AE8A4: 41980008  blt cr6, 0x825ae8ac
	if ctx.cr[6].lt {
	pc = 0x825AE8AC; continue 'dispatch;
	}
	// 825AE8A8: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825AE8AC; continue 'dispatch;
            }
            0x825AE8AC => {
    //   block [0x825AE8AC..0x825AE8C8)
	// 825AE8AC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AE8B0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AE8B4: 419A0014  beq cr6, 0x825ae8c8
	if ctx.cr[6].eq {
	pc = 0x825AE8C8; continue 'dispatch;
	}
	// 825AE8B8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AE8BC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AE8C0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AE8C4: 4800000C  b 0x825ae8d0
	pc = 0x825AE8D0; continue 'dispatch;
            }
            0x825AE8C8 => {
    //   block [0x825AE8C8..0x825AE8D0)
	// 825AE8C8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AE8CC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AE8D0; continue 'dispatch;
            }
            0x825AE8D0 => {
    //   block [0x825AE8D0..0x825AE8DC)
	// 825AE8D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AE8D4: 4199FFB8  bgt cr6, 0x825ae88c
	if ctx.cr[6].gt {
	pc = 0x825AE88C; continue 'dispatch;
	}
	// 825AE8D8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AE8DC; continue 'dispatch;
            }
            0x825AE8DC => {
    //   block [0x825AE8DC..0x825AE8F8)
	// 825AE8DC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AE8E0: 419A0040  beq cr6, 0x825ae920
	if ctx.cr[6].eq {
	pc = 0x825AE920; continue 'dispatch;
	}
	// 825AE8E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE8E8: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825AE8EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE8F0: 41990008  bgt cr6, 0x825ae8f8
	if ctx.cr[6].gt {
	pc = 0x825AE8F8; continue 'dispatch;
	}
	// 825AE8F4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825AE8F8; continue 'dispatch;
            }
            0x825AE8F8 => {
    //   block [0x825AE8F8..0x825AE920)
	// 825AE8F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE8FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE900: 409A0020  bne cr6, 0x825ae920
	if !ctx.cr[6].eq {
	pc = 0x825AE920; continue 'dispatch;
	}
	// 825AE904: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AE908: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AE90C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AE910: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE914: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE918: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE91C: 4800001C  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
            }
            0x825AE920 => {
    //   block [0x825AE920..0x825AE934)
	// 825AE920: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AE924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE928: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AE92C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AE930: 48000008  b 0x825ae938
	pc = 0x825AE938; continue 'dispatch;
            }
            0x825AE934 => {
    //   block [0x825AE934..0x825AE938)
	// 825AE934: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825AE938; continue 'dispatch;
            }
            0x825AE938 => {
    //   block [0x825AE938..0x825AE96C)
	// 825AE938: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AE93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE940: 419A002C  beq cr6, 0x825ae96c
	if ctx.cr[6].eq {
	pc = 0x825AE96C; continue 'dispatch;
	}
	// 825AE944: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE94C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 825AE950: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825AE954: 4E800421  bctrl
	ctx.lr = 0x825AE958;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825AE958: 5469063E  clrlwi r9, r3, 0x18
	ctx.r[9].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE95C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AE960: 419A000C  beq cr6, 0x825ae96c
	if ctx.cr[6].eq {
	pc = 0x825AE96C; continue 'dispatch;
	}
	// 825AE964: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825AE968: 4800001C  b 0x825ae984
	pc = 0x825AE984; continue 'dispatch;
            }
            0x825AE96C => {
    //   block [0x825AE96C..0x825AE984)
	// 825AE96C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE970: 4BCF0509  bl 0x8229ee78
	ctx.lr = 0x825AE974;
	sub_8229EE78(ctx, base);
	// 825AE974: 4804E5AD  bl 0x825fcf20
	ctx.lr = 0x825AE978;
	sub_825FCF20(ctx, base);
	// 825AE978: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AE97C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825AE980: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	pc = 0x825AE984; continue 'dispatch;
            }
            0x825AE984 => {
    //   block [0x825AE984..0x825AE99C)
	// 825AE984: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AE988: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AE98C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AE990: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AE994: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AE998: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AE9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AE9A0 size=384
    let mut pc: u32 = 0x825AE9A0;
    'dispatch: loop {
        match pc {
            0x825AE9A0 => {
    //   block [0x825AE9A0..0x825AEA28)
	// 825AE9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AE9A4: 486FAA61  bl 0x82ca9404
	ctx.lr = 0x825AE9A8;
	sub_82CA93D0(ctx, base);
	// 825AE9A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AE9AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AE9B0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AE9B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AE9B8: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825AE9BC: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825AE9C0: 917C0004  stw r11, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825AE9C4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE9C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AE9CC: 419A0148  beq cr6, 0x825aeb14
	if ctx.cr[6].eq {
	pc = 0x825AEB14; continue 'dispatch;
	}
	// 825AE9D0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AE9D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AE9D8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AE9DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AE9E0: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AE9E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AE9E8: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AE9EC: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825AE9F0: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825AE9F4: 4BBEC08D  bl 0x8219aa80
	ctx.lr = 0x825AE9F8;
	sub_8219AA80(ctx, base);
	// 825AE9F8: 80FD0000  lwz r7, 0(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AE9FC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEA00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA04: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA08: 4BC7A701  bl 0x82229108
	ctx.lr = 0x825AEA0C;
	sub_82229108(ctx, base);
	// 825AEA0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEA14: 419A0014  beq cr6, 0x825aea28
	if ctx.cr[6].eq {
	pc = 0x825AEA28; continue 'dispatch;
	}
	// 825AEA18: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEA1C: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEA20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA24: 4BC7A6E5  bl 0x82229108
	ctx.lr = 0x825AEA28;
	sub_82229108(ctx, base);
	pc = 0x825AEA28; continue 'dispatch;
            }
            0x825AEA28 => {
    //   block [0x825AEA28..0x825AEAC4)
	// 825AEA28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA2C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AEA30: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEA34: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEA38: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 825AEA3C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AEA40: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 825AEA44: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEA48: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEA4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEA50: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825AEA54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEA58: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AEA5C: 4BBEBDE5  bl 0x8219a840
	ctx.lr = 0x825AEA60;
	sub_8219A840(ctx, base);
	// 825AEA60: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEA64: 409A0088  bne cr6, 0x825aeaec
	if !ctx.cr[6].eq {
	pc = 0x825AEAEC; continue 'dispatch;
	}
	// 825AEA68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEA6C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AEA70: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 825AEA74: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEA78: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825AEA7C: 419A008C  beq cr6, 0x825aeb08
	if ctx.cr[6].eq {
	pc = 0x825AEB08; continue 'dispatch;
	}
	// 825AEA80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEA84: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 825AEA88: 409A0080  bne cr6, 0x825aeb08
	if !ctx.cr[6].eq {
	pc = 0x825AEB08; continue 'dispatch;
	}
	// 825AEA8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825AEA90: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEA94: 388B9FCC  addi r4, r11, -0x6034
	ctx.r[4].s64 = ctx.r[11].s64 + -24628;
	// 825AEA98: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEA9C: 4BC7E435  bl 0x8222ced0
	ctx.lr = 0x825AEAA0;
	sub_8222CED0(ctx, base);
	// 825AEAA0: 389D0008  addi r4, r29, 8
	ctx.r[4].s64 = ctx.r[29].s64 + 8;
	// 825AEAA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEAA8: 4BC3DD51  bl 0x821ec7f8
	ctx.lr = 0x825AEAAC;
	sub_821EC7F8(ctx, base);
	// 825AEAAC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AEAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEAB4: 409A0010  bne cr6, 0x825aeac4
	if !ctx.cr[6].eq {
	pc = 0x825AEAC4; continue 'dispatch;
	}
	// 825AEAB8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825AEABC: 38ABFFDF  addi r5, r11, -0x21
	ctx.r[5].s64 = ctx.r[11].s64 + -33;
	// 825AEAC0: 48000008  b 0x825aeac8
	pc = 0x825AEAC8; continue 'dispatch;
            }
            0x825AEAC4 => {
    //   block [0x825AEAC4..0x825AEAC8)
	// 825AEAC4: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825AEAC8; continue 'dispatch;
            }
            0x825AEAC8 => {
    //   block [0x825AEAC8..0x825AEAEC)
	// 825AEAC8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AEACC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEAD0: 4BD0AD21  bl 0x822b97f0
	ctx.lr = 0x825AEAD4;
	sub_822B97F0(ctx, base);
	// 825AEAD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEAD8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEADC: 4BBCC8BD  bl 0x8217b398
	ctx.lr = 0x825AEAE0;
	sub_8217B398(ctx, base);
	// 825AEAE0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEAE4: 4BC09035  bl 0x821b7b18
	ctx.lr = 0x825AEAE8;
	sub_821B7B18(ctx, base);
	// 825AEAE8: 48000018  b 0x825aeb00
	pc = 0x825AEB00; continue 'dispatch;
            }
            0x825AEAEC => {
    //   block [0x825AEAEC..0x825AEB00)
	// 825AEAEC: 4864DD1D  bl 0x82bfc808
	ctx.lr = 0x825AEAF0;
	sub_82BFC808(ctx, base);
	// 825AEAF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEAF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEAF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEAFC: 4BC7E3D5  bl 0x8222ced0
	ctx.lr = 0x825AEB00;
	sub_8222CED0(ctx, base);
	pc = 0x825AEB00; continue 'dispatch;
            }
            0x825AEB00 => {
    //   block [0x825AEB00..0x825AEB08)
	// 825AEB00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEB04: 4BC662D5  bl 0x82214dd8
	ctx.lr = 0x825AEB08;
	sub_82214DD8(ctx, base);
	pc = 0x825AEB08; continue 'dispatch;
            }
            0x825AEB08 => {
    //   block [0x825AEB08..0x825AEB14)
	// 825AEB08: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AEB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB10: 4861D1F9  bl 0x82bcbd08
	ctx.lr = 0x825AEB14;
	sub_82BCBD08(ctx, base);
	pc = 0x825AEB14; continue 'dispatch;
            }
            0x825AEB14 => {
    //   block [0x825AEB14..0x825AEB20)
	// 825AEB14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEB18: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEB1C: 486FA938  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEB20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEB20 size=308
    let mut pc: u32 = 0x825AEB20;
    'dispatch: loop {
        match pc {
            0x825AEB20 => {
    //   block [0x825AEB20..0x825AEB9C)
	// 825AEB20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEB24: 486FA8E1  bl 0x82ca9404
	ctx.lr = 0x825AEB28;
	sub_82CA93D0(ctx, base);
	// 825AEB28: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEB2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEB30: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEB34: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825AEB38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEB40: 419A0108  beq cr6, 0x825aec48
	if ctx.cr[6].eq {
	pc = 0x825AEC48; continue 'dispatch;
	}
	// 825AEB44: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB48: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEB4C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEB50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB54: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEB58: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825AEB5C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEB60: 7D0A4850  subf r8, r10, r9
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825AEB64: 7D1B1E70  srawi r27, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[27].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825AEB68: 4BBEBF19  bl 0x8219aa80
	ctx.lr = 0x825AEB6C;
	sub_8219AA80(ctx, base);
	// 825AEB6C: 80FE0000  lwz r7, 0(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB70: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEB74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB78: 80A70008  lwz r5, 8(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEB7C: 4BC7A58D  bl 0x82229108
	ctx.lr = 0x825AEB80;
	sub_82229108(ctx, base);
	// 825AEB80: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEB84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEB88: 419A0014  beq cr6, 0x825aeb9c
	if ctx.cr[6].eq {
	pc = 0x825AEB9C; continue 'dispatch;
	}
	// 825AEB8C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEB90: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEB94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEB98: 4BC7A571  bl 0x82229108
	ctx.lr = 0x825AEB9C;
	sub_82229108(ctx, base);
	pc = 0x825AEB9C; continue 'dispatch;
            }
            0x825AEB9C => {
    //   block [0x825AEB9C..0x825AEC20)
	// 825AEB9C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEBA0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825AEBA4: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEBA8: 811F0020  lwz r8, 0x20(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEBAC: 394BFFF0  addi r10, r11, -0x10
	ctx.r[10].s64 = ctx.r[11].s64 + -16;
	// 825AEBB0: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825AEBB4: 396BFFE8  addi r11, r11, -0x18
	ctx.r[11].s64 = ctx.r[11].s64 + -24;
	// 825AEBB8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825AEBBC: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEBC0: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825AEBC4: 7CE85850  subf r7, r8, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	// 825AEBC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEBCC: 7CC85050  subf r6, r8, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AEBD0: 4BBEBC71  bl 0x8219a840
	ctx.lr = 0x825AEBD4;
	sub_8219A840(ctx, base);
	// 825AEBD4: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEBD8: 409A0048  bne cr6, 0x825aec20
	if !ctx.cr[6].eq {
	pc = 0x825AEC20; continue 'dispatch;
	}
	// 825AEBDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEBE0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AEBE4: 392A9700  addi r9, r10, -0x6900
	ctx.r[9].s64 = ctx.r[10].s64 + -26880;
	// 825AEBE8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEBEC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825AEBF0: 419A004C  beq cr6, 0x825aec3c
	if ctx.cr[6].eq {
	pc = 0x825AEC3C; continue 'dispatch;
	}
	// 825AEBF4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEBF8: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825AEBFC: 409A0040  bne cr6, 0x825aec3c
	if !ctx.cr[6].eq {
	pc = 0x825AEC3C; continue 'dispatch;
	}
	// 825AEC00: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825AEC04: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEC08: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825AEC0C: 9B8B0000  stb r28, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u8 ) };
	// 825AEC10: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AEC14: 4BD53285  bl 0x82301e98
	ctx.lr = 0x825AEC18;
	sub_82301E98(ctx, base);
	// 825AEC18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825AEC1C: 48000020  b 0x825aec3c
	pc = 0x825AEC3C; continue 'dispatch;
            }
            0x825AEC20 => {
    //   block [0x825AEC20..0x825AEC3C)
	// 825AEC20: 4864DBE9  bl 0x82bfc808
	ctx.lr = 0x825AEC24;
	sub_82BFC808(ctx, base);
	// 825AEC24: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEC28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEC2C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEC30: 4BC7E2A1  bl 0x8222ced0
	ctx.lr = 0x825AEC34;
	sub_8222CED0(ctx, base);
	// 825AEC34: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825AEC38: 4BC661A1  bl 0x82214dd8
	ctx.lr = 0x825AEC3C;
	sub_82214DD8(ctx, base);
	pc = 0x825AEC3C; continue 'dispatch;
            }
            0x825AEC3C => {
    //   block [0x825AEC3C..0x825AEC48)
	// 825AEC3C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AEC40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEC44: 4861D0C5  bl 0x82bcbd08
	ctx.lr = 0x825AEC48;
	sub_82BCBD08(ctx, base);
	pc = 0x825AEC48; continue 'dispatch;
            }
            0x825AEC48 => {
    //   block [0x825AEC48..0x825AEC54)
	// 825AEC48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825AEC4C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEC50: 486FA804  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEC58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AEC58 size=276
    let mut pc: u32 = 0x825AEC58;
    'dispatch: loop {
        match pc {
            0x825AEC58 => {
    //   block [0x825AEC58..0x825AECCC)
	// 825AEC58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEC5C: 486FA7A5  bl 0x82ca9400
	ctx.lr = 0x825AEC60;
	sub_82CA93D0(ctx, base);
	// 825AEC60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEC64: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEC68: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEC6C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AEC70: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825AEC74: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 825AEC78: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEC80: 419A00E4  beq cr6, 0x825aed64
	if ctx.cr[6].eq {
	pc = 0x825AED64; continue 'dispatch;
	}
	// 825AEC84: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEC88: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEC8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEC90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEC94: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEC98: 4BBEBDE9  bl 0x8219aa80
	ctx.lr = 0x825AEC9C;
	sub_8219AA80(ctx, base);
	// 825AEC9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECA0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AECA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECA8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AECAC: 4BC7A45D  bl 0x82229108
	ctx.lr = 0x825AECB0;
	sub_82229108(ctx, base);
	// 825AECB0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AECB8: 419A0014  beq cr6, 0x825aeccc
	if ctx.cr[6].eq {
	pc = 0x825AECCC; continue 'dispatch;
	}
	// 825AECBC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AECC0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AECC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECC8: 4BC7A441  bl 0x82229108
	ctx.lr = 0x825AECCC;
	sub_82229108(ctx, base);
	pc = 0x825AECCC; continue 'dispatch;
            }
            0x825AECCC => {
    //   block [0x825AECCC..0x825AED58)
	// 825AECCC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECD0: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECD4: 4BDF42ED  bl 0x823a2fc0
	ctx.lr = 0x825AECD8;
	sub_823A2FC0(ctx, base);
	// 825AECD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECDC: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECE0: 4BDF42E1  bl 0x823a2fc0
	ctx.lr = 0x825AECE4;
	sub_823A2FC0(ctx, base);
	// 825AECE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AECE8: 809A0000  lwz r4, 0(r26)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AECEC: 4BDF42D5  bl 0x823a2fc0
	ctx.lr = 0x825AECF0;
	sub_823A2FC0(ctx, base);
	// 825AECF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AECF4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AECF8: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AECFC: 394BFFD8  addi r10, r11, -0x28
	ctx.r[10].s64 = ctx.r[11].s64 + -40;
	// 825AED00: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AED04: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825AED08: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AED0C: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 825AED10: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 825AED14: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AED18: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 825AED1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AED20: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825AED24: 4BBEBB1D  bl 0x8219a840
	ctx.lr = 0x825AED28;
	sub_8219A840(ctx, base);
	// 825AED28: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AED2C: 419A002C  beq cr6, 0x825aed58
	if ctx.cr[6].eq {
	pc = 0x825AED58; continue 'dispatch;
	}
	// 825AED30: 4864DAD9  bl 0x82bfc808
	ctx.lr = 0x825AED34;
	sub_82BFC808(ctx, base);
	// 825AED34: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AED38: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AED3C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AED40: 4BC7E191  bl 0x8222ced0
	ctx.lr = 0x825AED44;
	sub_8222CED0(ctx, base);
	// 825AED44: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AED48: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AED4C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AED50: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AED54: 4BC66085  bl 0x82214dd8
	ctx.lr = 0x825AED58;
	sub_82214DD8(ctx, base);
	pc = 0x825AED58; continue 'dispatch;
            }
            0x825AED58 => {
    //   block [0x825AED58..0x825AED64)
	// 825AED58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AED5C: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AED60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825AED64; continue 'dispatch;
            }
            0x825AED64 => {
    //   block [0x825AED64..0x825AED6C)
	// 825AED64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AED68: 486FA6E8  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AED70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AED70 size=260
    let mut pc: u32 = 0x825AED70;
    'dispatch: loop {
        match pc {
            0x825AED70 => {
    //   block [0x825AED70..0x825AEDE0)
	// 825AED70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AED74: 486FA691  bl 0x82ca9404
	ctx.lr = 0x825AED78;
	sub_82CA93D0(ctx, base);
	// 825AED78: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AED7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AED80: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AED84: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AED88: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825AED8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AED90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AED94: 419A00D8  beq cr6, 0x825aee6c
	if ctx.cr[6].eq {
	pc = 0x825AEE6C; continue 'dispatch;
	}
	// 825AED98: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AED9C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEDA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEDA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDA8: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEDAC: 4BBEBCD5  bl 0x8219aa80
	ctx.lr = 0x825AEDB0;
	sub_8219AA80(ctx, base);
	// 825AEDB0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDB4: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEDB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDBC: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEDC0: 4BC7A349  bl 0x82229108
	ctx.lr = 0x825AEDC4;
	sub_82229108(ctx, base);
	// 825AEDC4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEDCC: 419A0014  beq cr6, 0x825aede0
	if ctx.cr[6].eq {
	pc = 0x825AEDE0; continue 'dispatch;
	}
	// 825AEDD0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEDD4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEDD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDDC: 4BC7A32D  bl 0x82229108
	ctx.lr = 0x825AEDE0;
	sub_82229108(ctx, base);
	pc = 0x825AEDE0; continue 'dispatch;
            }
            0x825AEDE0 => {
    //   block [0x825AEDE0..0x825AEE60)
	// 825AEDE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDE4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDE8: 4BDF41D9  bl 0x823a2fc0
	ctx.lr = 0x825AEDEC;
	sub_823A2FC0(ctx, base);
	// 825AEDEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEDF0: 809B0000  lwz r4, 0(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEDF4: 4BDF41CD  bl 0x823a2fc0
	ctx.lr = 0x825AEDF8;
	sub_823A2FC0(ctx, base);
	// 825AEDF8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEDFC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825AEE00: 80DF0020  lwz r6, 0x20(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEE04: 394BFFE0  addi r10, r11, -0x20
	ctx.r[10].s64 = ctx.r[11].s64 + -32;
	// 825AEE08: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825AEE0C: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 825AEE10: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEE14: 3D0082A2  lis r8, -0x7d5e
	ctx.r[8].s64 = -2103312384;
	// 825AEE18: 7CE65850  subf r7, r6, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[6].s64;
	// 825AEE1C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEE20: 38884808  addi r4, r8, 0x4808
	ctx.r[4].s64 = ctx.r[8].s64 + 18440;
	// 825AEE24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEE28: 7CC65050  subf r6, r6, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825AEE2C: 4BBEBA15  bl 0x8219a840
	ctx.lr = 0x825AEE30;
	sub_8219A840(ctx, base);
	// 825AEE30: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEE34: 419A002C  beq cr6, 0x825aee60
	if ctx.cr[6].eq {
	pc = 0x825AEE60; continue 'dispatch;
	}
	// 825AEE38: 4864D9D1  bl 0x82bfc808
	ctx.lr = 0x825AEE3C;
	sub_82BFC808(ctx, base);
	// 825AEE3C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEE40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEE44: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEE48: 4BC7E089  bl 0x8222ced0
	ctx.lr = 0x825AEE4C;
	sub_8222CED0(ctx, base);
	// 825AEE4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEE50: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEE54: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEE58: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEE5C: 4BC65F7D  bl 0x82214dd8
	ctx.lr = 0x825AEE60;
	sub_82214DD8(ctx, base);
	pc = 0x825AEE60; continue 'dispatch;
            }
            0x825AEE60 => {
    //   block [0x825AEE60..0x825AEE6C)
	// 825AEE60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEE64: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEE68: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825AEE6C; continue 'dispatch;
            }
            0x825AEE6C => {
    //   block [0x825AEE6C..0x825AEE74)
	// 825AEE6C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AEE70: 486FA5E4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEE78(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AEE78 size=336
    let mut pc: u32 = 0x825AEE78;
    'dispatch: loop {
        match pc {
            0x825AEE78 => {
    //   block [0x825AEE78..0x825AEEEC)
	// 825AEE78: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEE7C: 486FA585  bl 0x82ca9400
	ctx.lr = 0x825AEE80;
	sub_82CA93D0(ctx, base);
	// 825AEE80: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEE84: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEE88: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825AEE8C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825AEE90: 7CDC3378  mr r28, r6
	ctx.r[28].u64 = ctx.r[6].u64;
	// 825AEE94: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825AEE98: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEE9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEEA0: 419A0120  beq cr6, 0x825aefc0
	if ctx.cr[6].eq {
	pc = 0x825AEFC0; continue 'dispatch;
	}
	// 825AEEA4: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEEA8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEEAC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEB4: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AEEB8: 4BBEBBC9  bl 0x8219aa80
	ctx.lr = 0x825AEEBC;
	sub_8219AA80(ctx, base);
	// 825AEEBC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEEC0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEEC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEC8: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEECC: 4BC7A23D  bl 0x82229108
	ctx.lr = 0x825AEED0;
	sub_82229108(ctx, base);
	// 825AEED0: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEED8: 419A0014  beq cr6, 0x825aeeec
	if ctx.cr[6].eq {
	pc = 0x825AEEEC; continue 'dispatch;
	}
	// 825AEEDC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AEEE0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEEE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEEE8: 4BC7A221  bl 0x82229108
	ctx.lr = 0x825AEEEC;
	sub_82229108(ctx, base);
	pc = 0x825AEEEC; continue 'dispatch;
            }
            0x825AEEEC => {
    //   block [0x825AEEEC..0x825AEFB4)
	// 825AEEEC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEEF0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AEEF4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEEF8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AEEFC: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825AEF00: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AEF04: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AEF08: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 825AEF0C: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AEF10: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825AEF14: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AEF18: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825AEF1C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF20: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF24: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF28: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF2C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF30: C17C0000  lfs f11, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825AEF34: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF38: D16B0000  stfs f11, 0(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF3C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF40: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF44: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF48: C15B0000  lfs f10, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825AEF4C: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AEF50: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AEF54: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEF58: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AEF5C: 394BFFD8  addi r10, r11, -0x28
	ctx.r[10].s64 = ctx.r[11].s64 + -40;
	// 825AEF60: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEF64: 396BFFD0  addi r11, r11, -0x30
	ctx.r[11].s64 = ctx.r[11].s64 + -48;
	// 825AEF68: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AEF6C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AEF70: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AEF74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEF78: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AEF7C: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825AEF80: 4BBEB8C1  bl 0x8219a840
	ctx.lr = 0x825AEF84;
	sub_8219A840(ctx, base);
	// 825AEF84: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AEF88: 419A002C  beq cr6, 0x825aefb4
	if ctx.cr[6].eq {
	pc = 0x825AEFB4; continue 'dispatch;
	}
	// 825AEF8C: 4864D87D  bl 0x82bfc808
	ctx.lr = 0x825AEF90;
	sub_82BFC808(ctx, base);
	// 825AEF90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AEF94: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEF98: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AEF9C: 4BC7DF35  bl 0x8222ced0
	ctx.lr = 0x825AEFA0;
	sub_8222CED0(ctx, base);
	// 825AEFA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEFA4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AEFA8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEFAC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AEFB0: 4BC65E29  bl 0x82214dd8
	ctx.lr = 0x825AEFB4;
	sub_82214DD8(ctx, base);
	pc = 0x825AEFB4; continue 'dispatch;
            }
            0x825AEFB4 => {
    //   block [0x825AEFB4..0x825AEFC0)
	// 825AEFB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AEFB8: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AEFBC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825AEFC0; continue 'dispatch;
            }
            0x825AEFC0 => {
    //   block [0x825AEFC0..0x825AEFC8)
	// 825AEFC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825AEFC4: 486FA48C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AEFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AEFC8 size=280
    let mut pc: u32 = 0x825AEFC8;
    'dispatch: loop {
        match pc {
            0x825AEFC8 => {
    //   block [0x825AEFC8..0x825AF034)
	// 825AEFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AEFCC: 486FA43D  bl 0x82ca9408
	ctx.lr = 0x825AEFD0;
	sub_82CA93D0(ctx, base);
	// 825AEFD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AEFD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AEFD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825AEFDC: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825AEFE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AEFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AEFE8: 419A00F0  beq cr6, 0x825af0d8
	if ctx.cr[6].eq {
	pc = 0x825AF0D8; continue 'dispatch;
	}
	// 825AEFEC: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AEFF0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 825AEFF4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825AEFF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AEFFC: 388BEE10  addi r4, r11, -0x11f0
	ctx.r[4].s64 = ctx.r[11].s64 + -4592;
	// 825AF000: 4BBEBA81  bl 0x8219aa80
	ctx.lr = 0x825AF004;
	sub_8219AA80(ctx, base);
	// 825AF004: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF008: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AF00C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF010: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF014: 4BC7A0F5  bl 0x82229108
	ctx.lr = 0x825AF018;
	sub_82229108(ctx, base);
	// 825AF018: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF01C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF020: 419A0014  beq cr6, 0x825af034
	if ctx.cr[6].eq {
	pc = 0x825AF034; continue 'dispatch;
	}
	// 825AF024: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825AF028: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF02C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF030: 4BC7A0D9  bl 0x82229108
	ctx.lr = 0x825AF034;
	sub_82229108(ctx, base);
	pc = 0x825AF034; continue 'dispatch;
            }
            0x825AF034 => {
    //   block [0x825AF034..0x825AF0CC)
	// 825AF034: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF038: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 825AF03C: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF040: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825AF044: 7D6707B4  extsw r7, r11
	ctx.r[7].s64 = ctx.r[11].s32 as i64;
	// 825AF048: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825AF04C: 3CC082A2  lis r6, -0x7d5e
	ctx.r[6].s64 = -2103312384;
	// 825AF050: F8E10058  std r7, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u64 ) };
	// 825AF054: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF058: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825AF05C: 38864808  addi r4, r6, 0x4808
	ctx.r[4].s64 = ctx.r[6].s64 + 18440;
	// 825AF060: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825AF064: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825AF068: D1890000  stfs f12, 0(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825AF06C: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825AF070: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF074: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825AF078: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 825AF07C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF080: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825AF084: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825AF088: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF08C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF090: 7CC95050  subf r6, r9, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825AF094: 7CE95850  subf r7, r9, r11
	ctx.r[7].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AF098: 4BBEB7A9  bl 0x8219a840
	ctx.lr = 0x825AF09C;
	sub_8219A840(ctx, base);
	// 825AF09C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825AF0A0: 419A002C  beq cr6, 0x825af0cc
	if ctx.cr[6].eq {
	pc = 0x825AF0CC; continue 'dispatch;
	}
	// 825AF0A4: 4864D765  bl 0x82bfc808
	ctx.lr = 0x825AF0A8;
	sub_82BFC808(ctx, base);
	// 825AF0A8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825AF0AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF0B0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF0B4: 4BC7DE1D  bl 0x8222ced0
	ctx.lr = 0x825AF0B8;
	sub_8222CED0(ctx, base);
	// 825AF0B8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF0BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF0C0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AF0C4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF0C8: 4BC65D11  bl 0x82214dd8
	ctx.lr = 0x825AF0CC;
	sub_82214DD8(ctx, base);
	pc = 0x825AF0CC; continue 'dispatch;
            }
            0x825AF0CC => {
    //   block [0x825AF0CC..0x825AF0D8)
	// 825AF0CC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF0D0: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	// 825AF0D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825AF0D8; continue 'dispatch;
            }
            0x825AF0D8 => {
    //   block [0x825AF0D8..0x825AF0E0)
	// 825AF0D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AF0DC: 486FA37C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825AF0E0 size=8
    let mut pc: u32 = 0x825AF0E0;
    'dispatch: loop {
        match pc {
            0x825AF0E0 => {
    //   block [0x825AF0E0..0x825AF0E8)
	// 825AF0E0: 80630060  lwz r3, 0x60(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AF0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF0F8 size=92
    let mut pc: u32 = 0x825AF0F8;
    'dispatch: loop {
        match pc {
            0x825AF0F8 => {
    //   block [0x825AF0F8..0x825AF12C)
	// 825AF0F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF0FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AF100: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AF104: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF108: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AF10C: 387F0074  addi r3, r31, 0x74
	ctx.r[3].s64 = ctx.r[31].s64 + 116;
	// 825AF110: 4BC08A09  bl 0x821b7b18
	ctx.lr = 0x825AF114;
	sub_821B7B18(ctx, base);
	// 825AF114: 387F0058  addi r3, r31, 0x58
	ctx.r[3].s64 = ctx.r[31].s64 + 88;
	// 825AF118: 4BCEB739  bl 0x8229a850
	ctx.lr = 0x825AF11C;
	sub_8229A850(ctx, base);
	// 825AF11C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825AF120: 397F0054  addi r11, r31, 0x54
	ctx.r[11].s64 = ctx.r[31].s64 + 84;
	// 825AF124: 409A0008  bne cr6, 0x825af12c
	if !ctx.cr[6].eq {
	pc = 0x825AF12C; continue 'dispatch;
	}
	// 825AF128: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825AF12C; continue 'dispatch;
            }
            0x825AF12C => {
    //   block [0x825AF12C..0x825AF154)
	// 825AF12C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 825AF130: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF134: 392A04D4  addi r9, r10, 0x4d4
	ctx.r[9].s64 = ctx.r[10].s64 + 1236;
	// 825AF138: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825AF13C: 4BBFD9F5  bl 0x821acb30
	ctx.lr = 0x825AF140;
	sub_821ACB30(ctx, base);
	// 825AF140: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AF144: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AF148: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AF14C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AF150: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF158(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF158 size=68
    let mut pc: u32 = 0x825AF158;
    'dispatch: loop {
        match pc {
            0x825AF158 => {
    //   block [0x825AF158..0x825AF19C)
	// 825AF158: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF15C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AF160: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825AF164: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AF168: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF16C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AF170: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825AF174: 4BF22D55  bl 0x824d1ec8
	ctx.lr = 0x825AF178;
	sub_824D1EC8(ctx, base);
	// 825AF178: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825AF17C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AF180: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825AF184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825AF188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AF18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AF190: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825AF194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AF198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF1A0 size=1832
    let mut pc: u32 = 0x825AF1A0;
    'dispatch: loop {
        match pc {
            0x825AF1A0 => {
    //   block [0x825AF1A0..0x825AF8C8)
	// 825AF1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF1A4: 486FA269  bl 0x82ca940c
	ctx.lr = 0x825AF1A8;
	sub_82CA93D0(ctx, base);
	// 825AF1A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF1AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825AF1B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AF1B4: 3BAB50DC  addi r29, r11, 0x50dc
	ctx.r[29].s64 = ctx.r[11].s64 + 20700;
	// 825AF1B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF1BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF1C0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF1C4: 4BC7DD0D  bl 0x8222ced0
	ctx.lr = 0x825AF1C8;
	sub_8222CED0(ctx, base);
	// 825AF1C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF1CC: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AF1D0: 480023F1  bl 0x825b15c0
	ctx.lr = 0x825AF1D4;
	sub_825B15C0(ctx, base);
	// 825AF1D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF1D8: 4BC65C01  bl 0x82214dd8
	ctx.lr = 0x825AF1DC;
	sub_82214DD8(ctx, base);
	// 825AF1DC: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825AF1E0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825AF1E4: 390AFEE0  addi r8, r10, -0x120
	ctx.r[8].s64 = ctx.r[10].s64 + -288;
	// 825AF1E8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825AF1EC: 388950E4  addi r4, r9, 0x50e4
	ctx.r[4].s64 = ctx.r[9].s64 + 20708;
	// 825AF1F0: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825AF1F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF1F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF1FC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF200: 4BC7DCD1  bl 0x8222ced0
	ctx.lr = 0x825AF204;
	sub_8222CED0(ctx, base);
	// 825AF204: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF208: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF20C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF210: 4BC7DCC1  bl 0x8222ced0
	ctx.lr = 0x825AF214;
	sub_8222CED0(ctx, base);
	// 825AF214: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF218: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825AF21C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF220: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825AF224: 480025E5  bl 0x825b1808
	ctx.lr = 0x825AF228;
	sub_825B1808(ctx, base);
	// 825AF228: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF22C: 4BC65BAD  bl 0x82214dd8
	ctx.lr = 0x825AF230;
	sub_82214DD8(ctx, base);
	// 825AF230: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF234: 4BC65BA5  bl 0x82214dd8
	ctx.lr = 0x825AF238;
	sub_82214DD8(ctx, base);
	// 825AF238: 3CE0825B  lis r7, -0x7da5
	ctx.r[7].s64 = -2107965440;
	// 825AF23C: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825AF240: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF244: 3867F0E0  addi r3, r7, -0xf20
	ctx.r[3].s64 = ctx.r[7].s64 + -3872;
	// 825AF248: 388650F0  addi r4, r6, 0x50f0
	ctx.r[4].s64 = ctx.r[6].s64 + 20720;
	// 825AF24C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF250: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF254: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF258: 4BC7DC79  bl 0x8222ced0
	ctx.lr = 0x825AF25C;
	sub_8222CED0(ctx, base);
	// 825AF25C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF264: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF268: 4BC7DC69  bl 0x8222ced0
	ctx.lr = 0x825AF26C;
	sub_8222CED0(ctx, base);
	// 825AF26C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF270: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF274: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF278: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF27C: 4800360D  bl 0x825b2888
	ctx.lr = 0x825AF280;
	sub_825B2888(ctx, base);
	// 825AF280: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF284: 4BC65B55  bl 0x82214dd8
	ctx.lr = 0x825AF288;
	sub_82214DD8(ctx, base);
	// 825AF288: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF28C: 4BC65B4D  bl 0x82214dd8
	ctx.lr = 0x825AF290;
	sub_82214DD8(ctx, base);
	// 825AF290: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF294: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF298: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF29C: 392BFF40  addi r9, r11, -0xc0
	ctx.r[9].s64 = ctx.r[11].s64 + -192;
	// 825AF2A0: 388A5100  addi r4, r10, 0x5100
	ctx.r[4].s64 = ctx.r[10].s64 + 20736;
	// 825AF2A4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2A8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF2AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF2B0: 4BC7DC21  bl 0x8222ced0
	ctx.lr = 0x825AF2B4;
	sub_8222CED0(ctx, base);
	// 825AF2B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF2B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2BC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF2C0: 4BC7DC11  bl 0x8222ced0
	ctx.lr = 0x825AF2C4;
	sub_8222CED0(ctx, base);
	// 825AF2C4: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF2C8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF2CC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF2D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF2D4: 48002745  bl 0x825b1a18
	ctx.lr = 0x825AF2D8;
	sub_825B1A18(ctx, base);
	// 825AF2D8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF2DC: 4BC65AFD  bl 0x82214dd8
	ctx.lr = 0x825AF2E0;
	sub_82214DD8(ctx, base);
	// 825AF2E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF2E4: 4BC65AF5  bl 0x82214dd8
	ctx.lr = 0x825AF2E8;
	sub_82214DD8(ctx, base);
	// 825AF2E8: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF2EC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF2F0: 38C80010  addi r6, r8, 0x10
	ctx.r[6].s64 = ctx.r[8].s64 + 16;
	// 825AF2F4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF2F8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF2FC: 38875118  addi r4, r7, 0x5118
	ctx.r[4].s64 = ctx.r[7].s64 + 20760;
	// 825AF300: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF304: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF308: 4BC7DBC9  bl 0x8222ced0
	ctx.lr = 0x825AF30C;
	sub_8222CED0(ctx, base);
	// 825AF30C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF310: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF314: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF318: 4BC7DBB9  bl 0x8222ced0
	ctx.lr = 0x825AF31C;
	sub_8222CED0(ctx, base);
	// 825AF31C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF320: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF324: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF328: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF32C: 480026ED  bl 0x825b1a18
	ctx.lr = 0x825AF330;
	sub_825B1A18(ctx, base);
	// 825AF330: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF334: 4BC65AA5  bl 0x82214dd8
	ctx.lr = 0x825AF338;
	sub_82214DD8(ctx, base);
	// 825AF338: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF33C: 4BC65A9D  bl 0x82214dd8
	ctx.lr = 0x825AF340;
	sub_82214DD8(ctx, base);
	// 825AF340: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF344: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF348: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF34C: 3865FFA8  addi r3, r5, -0x58
	ctx.r[3].s64 = ctx.r[5].s64 + -88;
	// 825AF350: 38845130  addi r4, r4, 0x5130
	ctx.r[4].s64 = ctx.r[4].s64 + 20784;
	// 825AF354: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF358: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF35C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF360: 4BC7DB71  bl 0x8222ced0
	ctx.lr = 0x825AF364;
	sub_8222CED0(ctx, base);
	// 825AF364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF368: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF36C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF370: 4BC7DB61  bl 0x8222ced0
	ctx.lr = 0x825AF374;
	sub_8222CED0(ctx, base);
	// 825AF374: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF378: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF37C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF380: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF384: 48002695  bl 0x825b1a18
	ctx.lr = 0x825AF388;
	sub_825B1A18(ctx, base);
	// 825AF388: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF38C: 4BC65A4D  bl 0x82214dd8
	ctx.lr = 0x825AF390;
	sub_82214DD8(ctx, base);
	// 825AF390: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF394: 4BC65A45  bl 0x82214dd8
	ctx.lr = 0x825AF398;
	sub_82214DD8(ctx, base);
	// 825AF398: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF39C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF3A0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF3A4: 392BFEF8  addi r9, r11, -0x108
	ctx.r[9].s64 = ctx.r[11].s64 + -264;
	// 825AF3A8: 388A5144  addi r4, r10, 0x5144
	ctx.r[4].s64 = ctx.r[10].s64 + 20804;
	// 825AF3AC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF3B0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF3B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF3B8: 4BC7DB19  bl 0x8222ced0
	ctx.lr = 0x825AF3BC;
	sub_8222CED0(ctx, base);
	// 825AF3BC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF3C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF3C4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF3C8: 4BC7DB09  bl 0x8222ced0
	ctx.lr = 0x825AF3CC;
	sub_8222CED0(ctx, base);
	// 825AF3CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF3D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF3D4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF3D8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF3DC: 4800284D  bl 0x825b1c28
	ctx.lr = 0x825AF3E0;
	sub_825B1C28(ctx, base);
	// 825AF3E0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF3E4: 4BC659F5  bl 0x82214dd8
	ctx.lr = 0x825AF3E8;
	sub_82214DD8(ctx, base);
	// 825AF3E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF3EC: 4BC659ED  bl 0x82214dd8
	ctx.lr = 0x825AF3F0;
	sub_82214DD8(ctx, base);
	// 825AF3F0: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF3F4: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF3F8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF3FC: 38C80078  addi r6, r8, 0x78
	ctx.r[6].s64 = ctx.r[8].s64 + 120;
	// 825AF400: 38875158  addi r4, r7, 0x5158
	ctx.r[4].s64 = ctx.r[7].s64 + 20824;
	// 825AF404: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF408: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF40C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF410: 4BC7DAC1  bl 0x8222ced0
	ctx.lr = 0x825AF414;
	sub_8222CED0(ctx, base);
	// 825AF414: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF418: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF41C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF420: 4BC7DAB1  bl 0x8222ced0
	ctx.lr = 0x825AF424;
	sub_8222CED0(ctx, base);
	// 825AF424: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF428: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF42C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF430: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF434: 480025E5  bl 0x825b1a18
	ctx.lr = 0x825AF438;
	sub_825B1A18(ctx, base);
	// 825AF438: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF43C: 4BC6599D  bl 0x82214dd8
	ctx.lr = 0x825AF440;
	sub_82214DD8(ctx, base);
	// 825AF440: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF444: 4BC65995  bl 0x82214dd8
	ctx.lr = 0x825AF448;
	sub_82214DD8(ctx, base);
	// 825AF448: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF44C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF450: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF454: 386500B0  addi r3, r5, 0xb0
	ctx.r[3].s64 = ctx.r[5].s64 + 176;
	// 825AF458: 38845168  addi r4, r4, 0x5168
	ctx.r[4].s64 = ctx.r[4].s64 + 20840;
	// 825AF45C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF460: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF464: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF468: 4BC7DA69  bl 0x8222ced0
	ctx.lr = 0x825AF46C;
	sub_8222CED0(ctx, base);
	// 825AF46C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF470: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF474: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF478: 4BC7DA59  bl 0x8222ced0
	ctx.lr = 0x825AF47C;
	sub_8222CED0(ctx, base);
	// 825AF47C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF480: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF484: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF488: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF48C: 480029AD  bl 0x825b1e38
	ctx.lr = 0x825AF490;
	sub_825B1E38(ctx, base);
	// 825AF490: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF494: 4BC65945  bl 0x82214dd8
	ctx.lr = 0x825AF498;
	sub_82214DD8(ctx, base);
	// 825AF498: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF49C: 4BC6593D  bl 0x82214dd8
	ctx.lr = 0x825AF4A0;
	sub_82214DD8(ctx, base);
	// 825AF4A0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF4A4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF4A8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF4AC: 392BFBF8  addi r9, r11, -0x408
	ctx.r[9].s64 = ctx.r[11].s64 + -1032;
	// 825AF4B0: 388A5180  addi r4, r10, 0x5180
	ctx.r[4].s64 = ctx.r[10].s64 + 20864;
	// 825AF4B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF4B8: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF4BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF4C0: 4BC7DA11  bl 0x8222ced0
	ctx.lr = 0x825AF4C4;
	sub_8222CED0(ctx, base);
	// 825AF4C4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF4C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF4CC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF4D0: 4BC7DA01  bl 0x8222ced0
	ctx.lr = 0x825AF4D4;
	sub_8222CED0(ctx, base);
	// 825AF4D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF4D8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF4DC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF4E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF4E4: 48002B65  bl 0x825b2048
	ctx.lr = 0x825AF4E8;
	sub_825B2048(ctx, base);
	// 825AF4E8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF4EC: 4BC658ED  bl 0x82214dd8
	ctx.lr = 0x825AF4F0;
	sub_82214DD8(ctx, base);
	// 825AF4F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF4F4: 4BC658E5  bl 0x82214dd8
	ctx.lr = 0x825AF4F8;
	sub_82214DD8(ctx, base);
	// 825AF4F8: 3D00822A  lis r8, -0x7dd6
	ctx.r[8].s64 = -2111176704;
	// 825AF4FC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF500: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF504: 38C8C620  addi r6, r8, -0x39e0
	ctx.r[6].s64 = ctx.r[8].s64 + -14816;
	// 825AF508: 38875194  addi r4, r7, 0x5194
	ctx.r[4].s64 = ctx.r[7].s64 + 20884;
	// 825AF50C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF510: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF514: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF518: 4BC7D9B9  bl 0x8222ced0
	ctx.lr = 0x825AF51C;
	sub_8222CED0(ctx, base);
	// 825AF51C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF520: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF524: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF528: 4BC7D9A9  bl 0x8222ced0
	ctx.lr = 0x825AF52C;
	sub_8222CED0(ctx, base);
	// 825AF52C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF530: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF534: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF53C: 48002D1D  bl 0x825b2258
	ctx.lr = 0x825AF540;
	sub_825B2258(ctx, base);
	// 825AF540: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF544: 4BC65895  bl 0x82214dd8
	ctx.lr = 0x825AF548;
	sub_82214DD8(ctx, base);
	// 825AF548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF54C: 4BC6588D  bl 0x82214dd8
	ctx.lr = 0x825AF550;
	sub_82214DD8(ctx, base);
	// 825AF550: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF554: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF558: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF55C: 386500E8  addi r3, r5, 0xe8
	ctx.r[3].s64 = ctx.r[5].s64 + 232;
	// 825AF560: 388451AC  addi r4, r4, 0x51ac
	ctx.r[4].s64 = ctx.r[4].s64 + 20908;
	// 825AF564: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF568: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF56C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF570: 4BC7D961  bl 0x8222ced0
	ctx.lr = 0x825AF574;
	sub_8222CED0(ctx, base);
	// 825AF574: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF578: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF57C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF580: 4BC7D951  bl 0x8222ced0
	ctx.lr = 0x825AF584;
	sub_8222CED0(ctx, base);
	// 825AF584: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF588: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF58C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF590: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF594: 48002CC5  bl 0x825b2258
	ctx.lr = 0x825AF598;
	sub_825B2258(ctx, base);
	// 825AF598: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF59C: 4BC6583D  bl 0x82214dd8
	ctx.lr = 0x825AF5A0;
	sub_82214DD8(ctx, base);
	// 825AF5A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5A4: 4BC65835  bl 0x82214dd8
	ctx.lr = 0x825AF5A8;
	sub_82214DD8(ctx, base);
	// 825AF5A8: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF5AC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF5B0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF5B4: 392B0190  addi r9, r11, 0x190
	ctx.r[9].s64 = ctx.r[11].s64 + 400;
	// 825AF5B8: 388A51CC  addi r4, r10, 0x51cc
	ctx.r[4].s64 = ctx.r[10].s64 + 20940;
	// 825AF5BC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF5C0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF5C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5C8: 4BC7D909  bl 0x8222ced0
	ctx.lr = 0x825AF5CC;
	sub_8222CED0(ctx, base);
	// 825AF5CC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF5D0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF5D4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF5D8: 4BC7D8F9  bl 0x8222ced0
	ctx.lr = 0x825AF5DC;
	sub_8222CED0(ctx, base);
	// 825AF5DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF5E0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF5E4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF5E8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF5EC: 48002E7D  bl 0x825b2468
	ctx.lr = 0x825AF5F0;
	sub_825B2468(ctx, base);
	// 825AF5F0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF5F4: 4BC657E5  bl 0x82214dd8
	ctx.lr = 0x825AF5F8;
	sub_82214DD8(ctx, base);
	// 825AF5F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF5FC: 4BC657DD  bl 0x82214dd8
	ctx.lr = 0x825AF600;
	sub_82214DD8(ctx, base);
	// 825AF600: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF604: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF608: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF60C: 38C80CD8  addi r6, r8, 0xcd8
	ctx.r[6].s64 = ctx.r[8].s64 + 3288;
	// 825AF610: 388751E8  addi r4, r7, 0x51e8
	ctx.r[4].s64 = ctx.r[7].s64 + 20968;
	// 825AF614: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF618: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF61C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF620: 4BC7D8B1  bl 0x8222ced0
	ctx.lr = 0x825AF624;
	sub_8222CED0(ctx, base);
	// 825AF624: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF628: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF62C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF630: 4BC7D8A1  bl 0x8222ced0
	ctx.lr = 0x825AF634;
	sub_8222CED0(ctx, base);
	// 825AF634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF638: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF63C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF640: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF644: 48003035  bl 0x825b2678
	ctx.lr = 0x825AF648;
	sub_825B2678(ctx, base);
	// 825AF648: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF64C: 4BC6578D  bl 0x82214dd8
	ctx.lr = 0x825AF650;
	sub_82214DD8(ctx, base);
	// 825AF650: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF654: 4BC65785  bl 0x82214dd8
	ctx.lr = 0x825AF658;
	sub_82214DD8(ctx, base);
	// 825AF658: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF65C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF660: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF664: 38650E00  addi r3, r5, 0xe00
	ctx.r[3].s64 = ctx.r[5].s64 + 3584;
	// 825AF668: 388451F8  addi r4, r4, 0x51f8
	ctx.r[4].s64 = ctx.r[4].s64 + 20984;
	// 825AF66C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF670: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF674: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF678: 4BC7D859  bl 0x8222ced0
	ctx.lr = 0x825AF67C;
	sub_8222CED0(ctx, base);
	// 825AF67C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF680: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF684: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF688: 4BC7D849  bl 0x8222ced0
	ctx.lr = 0x825AF68C;
	sub_8222CED0(ctx, base);
	// 825AF68C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF690: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF694: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF698: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF69C: 480031ED  bl 0x825b2888
	ctx.lr = 0x825AF6A0;
	sub_825B2888(ctx, base);
	// 825AF6A0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6A4: 4BC65735  bl 0x82214dd8
	ctx.lr = 0x825AF6A8;
	sub_82214DD8(ctx, base);
	// 825AF6A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF6AC: 4BC6572D  bl 0x82214dd8
	ctx.lr = 0x825AF6B0;
	sub_82214DD8(ctx, base);
	// 825AF6B0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF6B4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF6B8: 392B0DF8  addi r9, r11, 0xdf8
	ctx.r[9].s64 = ctx.r[11].s64 + 3576;
	// 825AF6BC: 388A5214  addi r4, r10, 0x5214
	ctx.r[4].s64 = ctx.r[10].s64 + 21012;
	// 825AF6C0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF6C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF6C8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF6CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF6D0: 4BC7D801  bl 0x8222ced0
	ctx.lr = 0x825AF6D4;
	sub_8222CED0(ctx, base);
	// 825AF6D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF6D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF6DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6E0: 4BC7D7F1  bl 0x8222ced0
	ctx.lr = 0x825AF6E4;
	sub_8222CED0(ctx, base);
	// 825AF6E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF6E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF6EC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF6F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF6F4: 48003195  bl 0x825b2888
	ctx.lr = 0x825AF6F8;
	sub_825B2888(ctx, base);
	// 825AF6F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF6FC: 4BC656DD  bl 0x82214dd8
	ctx.lr = 0x825AF700;
	sub_82214DD8(ctx, base);
	// 825AF700: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF704: 4BC656D5  bl 0x82214dd8
	ctx.lr = 0x825AF708;
	sub_82214DD8(ctx, base);
	// 825AF708: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF70C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF710: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF714: 38C80E08  addi r6, r8, 0xe08
	ctx.r[6].s64 = ctx.r[8].s64 + 3592;
	// 825AF718: 38875230  addi r4, r7, 0x5230
	ctx.r[4].s64 = ctx.r[7].s64 + 21040;
	// 825AF71C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF720: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF724: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF728: 4BC7D7A9  bl 0x8222ced0
	ctx.lr = 0x825AF72C;
	sub_8222CED0(ctx, base);
	// 825AF72C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF730: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF734: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF738: 4BC7D799  bl 0x8222ced0
	ctx.lr = 0x825AF73C;
	sub_8222CED0(ctx, base);
	// 825AF73C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF740: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF744: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF748: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF74C: 480024DD  bl 0x825b1c28
	ctx.lr = 0x825AF750;
	sub_825B1C28(ctx, base);
	// 825AF750: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF754: 4BC65685  bl 0x82214dd8
	ctx.lr = 0x825AF758;
	sub_82214DD8(ctx, base);
	// 825AF758: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF75C: 4BC6567D  bl 0x82214dd8
	ctx.lr = 0x825AF760;
	sub_82214DD8(ctx, base);
	// 825AF760: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF764: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF768: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF76C: 3865F0E8  addi r3, r5, -0xf18
	ctx.r[3].s64 = ctx.r[5].s64 + -3864;
	// 825AF770: 38845240  addi r4, r4, 0x5240
	ctx.r[4].s64 = ctx.r[4].s64 + 21056;
	// 825AF774: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF778: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF77C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF780: 4BC7D751  bl 0x8222ced0
	ctx.lr = 0x825AF784;
	sub_8222CED0(ctx, base);
	// 825AF784: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF788: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF78C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF790: 4BC7D741  bl 0x8222ced0
	ctx.lr = 0x825AF794;
	sub_8222CED0(ctx, base);
	// 825AF794: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF798: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF79C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF7A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF7A4: 480030E5  bl 0x825b2888
	ctx.lr = 0x825AF7A8;
	sub_825B2888(ctx, base);
	// 825AF7A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF7AC: 4BC6562D  bl 0x82214dd8
	ctx.lr = 0x825AF7B0;
	sub_82214DD8(ctx, base);
	// 825AF7B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF7B4: 4BC65625  bl 0x82214dd8
	ctx.lr = 0x825AF7B8;
	sub_82214DD8(ctx, base);
	// 825AF7B8: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825AF7BC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825AF7C0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF7C4: 392BF0F0  addi r9, r11, -0xf10
	ctx.r[9].s64 = ctx.r[11].s64 + -3856;
	// 825AF7C8: 388A5254  addi r4, r10, 0x5254
	ctx.r[4].s64 = ctx.r[10].s64 + 21076;
	// 825AF7CC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF7D0: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825AF7D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF7D8: 4BC7D6F9  bl 0x8222ced0
	ctx.lr = 0x825AF7DC;
	sub_8222CED0(ctx, base);
	// 825AF7DC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF7E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF7E4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF7E8: 4BC7D6E9  bl 0x8222ced0
	ctx.lr = 0x825AF7EC;
	sub_8222CED0(ctx, base);
	// 825AF7EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF7F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF7F4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF7F8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF7FC: 4800308D  bl 0x825b2888
	ctx.lr = 0x825AF800;
	sub_825B2888(ctx, base);
	// 825AF800: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF804: 4BC655D5  bl 0x82214dd8
	ctx.lr = 0x825AF808;
	sub_82214DD8(ctx, base);
	// 825AF808: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF80C: 4BC655CD  bl 0x82214dd8
	ctx.lr = 0x825AF810;
	sub_82214DD8(ctx, base);
	// 825AF810: 3D00825B  lis r8, -0x7da5
	ctx.r[8].s64 = -2107965440;
	// 825AF814: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825AF818: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF81C: 38C80E20  addi r6, r8, 0xe20
	ctx.r[6].s64 = ctx.r[8].s64 + 3616;
	// 825AF820: 38875268  addi r4, r7, 0x5268
	ctx.r[4].s64 = ctx.r[7].s64 + 21096;
	// 825AF824: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF828: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825AF82C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF830: 4BC7D6A1  bl 0x8222ced0
	ctx.lr = 0x825AF834;
	sub_8222CED0(ctx, base);
	// 825AF834: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF838: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF83C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF840: 4BC7D691  bl 0x8222ced0
	ctx.lr = 0x825AF844;
	sub_8222CED0(ctx, base);
	// 825AF844: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF848: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF84C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF850: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF854: 480023D5  bl 0x825b1c28
	ctx.lr = 0x825AF858;
	sub_825B1C28(ctx, base);
	// 825AF858: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF85C: 4BC6557D  bl 0x82214dd8
	ctx.lr = 0x825AF860;
	sub_82214DD8(ctx, base);
	// 825AF860: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF864: 4BC65575  bl 0x82214dd8
	ctx.lr = 0x825AF868;
	sub_82214DD8(ctx, base);
	// 825AF868: 3CA0825B  lis r5, -0x7da5
	ctx.r[5].s64 = -2107965440;
	// 825AF86C: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825AF870: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825AF874: 38650F58  addi r3, r5, 0xf58
	ctx.r[3].s64 = ctx.r[5].s64 + 3928;
	// 825AF878: 38845280  addi r4, r4, 0x5280
	ctx.r[4].s64 = ctx.r[4].s64 + 21120;
	// 825AF87C: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825AF880: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF884: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF888: 4BC7D649  bl 0x8222ced0
	ctx.lr = 0x825AF88C;
	sub_8222CED0(ctx, base);
	// 825AF88C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825AF890: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825AF894: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF898: 4BC7D639  bl 0x8222ced0
	ctx.lr = 0x825AF89C;
	sub_8222CED0(ctx, base);
	// 825AF89C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825AF8A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825AF8A4: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825AF8A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825AF8AC: 4800237D  bl 0x825b1c28
	ctx.lr = 0x825AF8B0;
	sub_825B1C28(ctx, base);
	// 825AF8B0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825AF8B4: 4BC65525  bl 0x82214dd8
	ctx.lr = 0x825AF8B8;
	sub_82214DD8(ctx, base);
	// 825AF8B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825AF8BC: 4BC6551D  bl 0x82214dd8
	ctx.lr = 0x825AF8C0;
	sub_82214DD8(ctx, base);
	// 825AF8C0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AF8C4: 486F9B98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AF8C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AF8C8 size=816
    let mut pc: u32 = 0x825AF8C8;
    'dispatch: loop {
        match pc {
            0x825AF8C8 => {
    //   block [0x825AF8C8..0x825AF928)
	// 825AF8C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AF8CC: 486F9B39  bl 0x82ca9404
	ctx.lr = 0x825AF8D0;
	sub_82CA93D0(ctx, base);
	// 825AF8D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AF8D4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825AF8D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825AF8DC: 807B0004  lwz r3, 4(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF8E0: 4BDDDBD9  bl 0x8238d4b8
	ctx.lr = 0x825AF8E4;
	sub_8238D4B8(ctx, base);
	// 825AF8E4: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF8E8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825AF8EC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AF8F0: 55490FFE  srwi r9, r10, 0x1f
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shr(31);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825AF8F4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AF8F8: 419A00F4  beq cr6, 0x825af9ec
	if ctx.cr[6].eq {
	pc = 0x825AF9EC; continue 'dispatch;
	}
	// 825AF8FC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AF900: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AF904: 419A0024  beq cr6, 0x825af928
	if ctx.cr[6].eq {
	pc = 0x825AF928; continue 'dispatch;
	}
	// 825AF908: 894A001F  lbz r10, 0x1f(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(31 as u32) ) } as u64;
	// 825AF90C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AF910: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AF914: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AF918: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF91C: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF924: 480000D0  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
            }
            0x825AF928 => {
    //   block [0x825AF928..0x825AF944)
	// 825AF928: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AF92C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AF930: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825AF934: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AF938: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AF93C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AF940: 40810054  ble 0x825af994
	if !ctx.cr[0].gt {
	pc = 0x825AF994; continue 'dispatch;
	}
	pc = 0x825AF944; continue 'dispatch;
            }
            0x825AF944 => {
    //   block [0x825AF944..0x825AF964)
	// 825AF944: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AF948: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AF94C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AF950: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF954: 2F07001F  cmpwi cr6, r7, 0x1f
	ctx.cr[6].compare_i32(ctx.r[7].s32, 31, &mut ctx.xer);
	// 825AF958: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AF95C: 41980008  blt cr6, 0x825af964
	if ctx.cr[6].lt {
	pc = 0x825AF964; continue 'dispatch;
	}
	// 825AF960: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x825AF964; continue 'dispatch;
            }
            0x825AF964 => {
    //   block [0x825AF964..0x825AF980)
	// 825AF964: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AF968: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AF96C: 419A0014  beq cr6, 0x825af980
	if ctx.cr[6].eq {
	pc = 0x825AF980; continue 'dispatch;
	}
	// 825AF970: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AF974: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AF978: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AF97C: 4800000C  b 0x825af988
	pc = 0x825AF988; continue 'dispatch;
            }
            0x825AF980 => {
    //   block [0x825AF980..0x825AF988)
	// 825AF980: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AF984: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AF988; continue 'dispatch;
            }
            0x825AF988 => {
    //   block [0x825AF988..0x825AF994)
	// 825AF988: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AF98C: 4199FFB8  bgt cr6, 0x825af944
	if ctx.cr[6].gt {
	pc = 0x825AF944; continue 'dispatch;
	}
	// 825AF990: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AF994; continue 'dispatch;
            }
            0x825AF994 => {
    //   block [0x825AF994..0x825AF9B0)
	// 825AF994: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AF998: 419A0040  beq cr6, 0x825af9d8
	if ctx.cr[6].eq {
	pc = 0x825AF9D8; continue 'dispatch;
	}
	// 825AF99C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AF9A0: 2F0B001F  cmpwi cr6, r11, 0x1f
	ctx.cr[6].compare_i32(ctx.r[11].s32, 31, &mut ctx.xer);
	// 825AF9A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9A8: 41990008  bgt cr6, 0x825af9b0
	if ctx.cr[6].gt {
	pc = 0x825AF9B0; continue 'dispatch;
	}
	// 825AF9AC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825AF9B0; continue 'dispatch;
            }
            0x825AF9B0 => {
    //   block [0x825AF9B0..0x825AF9D8)
	// 825AF9B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AF9B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF9B8: 409A0020  bne cr6, 0x825af9d8
	if !ctx.cr[6].eq {
	pc = 0x825AF9D8; continue 'dispatch;
	}
	// 825AF9BC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AF9C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AF9C4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AF9C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF9CC: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF9D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9D4: 48000020  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
            }
            0x825AF9D8 => {
    //   block [0x825AF9D8..0x825AF9EC)
	// 825AF9D8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AF9DC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AF9E0: 7D7D5B78  mr r29, r11
	ctx.r[29].u64 = ctx.r[11].u64;
	// 825AF9E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AF9E8: 4800000C  b 0x825af9f4
	pc = 0x825AF9F4; continue 'dispatch;
            }
            0x825AF9EC => {
    //   block [0x825AF9EC..0x825AF9F4)
	// 825AF9EC: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AF9F0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825AF9F4; continue 'dispatch;
            }
            0x825AF9F4 => {
    //   block [0x825AF9F4..0x825AFA28)
	// 825AF9F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AF9F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AF9FC: 419A0098  beq cr6, 0x825afa94
	if ctx.cr[6].eq {
	pc = 0x825AFA94; continue 'dispatch;
	}
	// 825AFA00: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825AFA04: 4BC6F855  bl 0x8221f258
	ctx.lr = 0x825AFA08;
	sub_8221F258(ctx, base);
	// 825AFA08: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AFA0C: 419A001C  beq cr6, 0x825afa28
	if ctx.cr[6].eq {
	pc = 0x825AFA28; continue 'dispatch;
	}
	// 825AFA10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825AFA14: 93830004  stw r28, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825AFA18: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825AFA1C: 394B0E0C  addi r10, r11, 0xe0c
	ctx.r[10].s64 = ctx.r[11].s64 + 3596;
	// 825AFA20: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825AFA24: 48000008  b 0x825afa2c
	pc = 0x825AFA2C; continue 'dispatch;
            }
            0x825AFA28 => {
    //   block [0x825AFA28..0x825AFA2C)
	// 825AFA28: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	pc = 0x825AFA2C; continue 'dispatch;
            }
            0x825AFA2C => {
    //   block [0x825AFA2C..0x825AFA78)
	// 825AFA2C: 3BFB0048  addi r31, r27, 0x48
	ctx.r[31].s64 = ctx.r[27].s64 + 72;
	// 825AFA30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFA34: 4BC080E5  bl 0x821b7b18
	ctx.lr = 0x825AFA38;
	sub_821B7B18(ctx, base);
	// 825AFA38: 93DB0048  stw r30, 0x48(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 825AFA3C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825AFA40: 419A0040  beq cr6, 0x825afa80
	if ctx.cr[6].eq {
	pc = 0x825AFA80; continue 'dispatch;
	}
	// 825AFA44: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825AFA48: 4BC6F811  bl 0x8221f258
	ctx.lr = 0x825AFA4C;
	sub_8221F258(ctx, base);
	// 825AFA4C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825AFA50: 419A0028  beq cr6, 0x825afa78
	if ctx.cr[6].eq {
	pc = 0x825AFA78; continue 'dispatch;
	}
	// 825AFA54: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFA58: 3D208253  lis r9, -0x7dad
	ctx.r[9].s64 = -2108489728;
	// 825AFA5C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 825AFA60: 38E99238  addi r7, r9, -0x6dc8
	ctx.r[7].s64 = ctx.r[9].s64 + -28104;
	// 825AFA64: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825AFA68: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825AFA6C: 90E30004  stw r7, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825AFA70: 91430008  stw r10, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825AFA74: 48000008  b 0x825afa7c
	pc = 0x825AFA7C; continue 'dispatch;
            }
            0x825AFA78 => {
    //   block [0x825AFA78..0x825AFA7C)
	// 825AFA78: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825AFA7C; continue 'dispatch;
            }
            0x825AFA7C => {
    //   block [0x825AFA7C..0x825AFA80)
	// 825AFA7C: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	pc = 0x825AFA80; continue 'dispatch;
            }
            0x825AFA80 => {
    //   block [0x825AFA80..0x825AFA94)
	// 825AFA80: 38C0000A  li r6, 0xa
	ctx.r[6].s64 = 10;
	// 825AFA84: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFA88: 38BB000C  addi r5, r27, 0xc
	ctx.r[5].s64 = ctx.r[27].s64 + 12;
	// 825AFA8C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AFA90: 48015539  bl 0x825c4fc8
	ctx.lr = 0x825AFA94;
	sub_825C4FC8(ctx, base);
	pc = 0x825AFA94; continue 'dispatch;
            }
            0x825AFA94 => {
    //   block [0x825AFA94..0x825AFAD4)
	// 825AFA94: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFA98: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825AFA9C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AFAA0: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 825AFAA4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AFAA8: 419A00E8  beq cr6, 0x825afb90
	if ctx.cr[6].eq {
	pc = 0x825AFB90; continue 'dispatch;
	}
	// 825AFAAC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFAB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFAB4: 419A0020  beq cr6, 0x825afad4
	if ctx.cr[6].eq {
	pc = 0x825AFAD4; continue 'dispatch;
	}
	// 825AFAB8: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825AFABC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFAC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AFAC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AFAC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFACC: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFAD0: 480000C4  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
            }
            0x825AFAD4 => {
    //   block [0x825AFAD4..0x825AFAF0)
	// 825AFAD4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFAD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFADC: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825AFAE0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFAE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFAE8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFAEC: 40810054  ble 0x825afb40
	if !ctx.cr[0].gt {
	pc = 0x825AFB40; continue 'dispatch;
	}
	pc = 0x825AFAF0; continue 'dispatch;
            }
            0x825AFAF0 => {
    //   block [0x825AFAF0..0x825AFB10)
	// 825AFAF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFAF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFAF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFAFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFB00: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825AFB04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFB08: 41980008  blt cr6, 0x825afb10
	if ctx.cr[6].lt {
	pc = 0x825AFB10; continue 'dispatch;
	}
	// 825AFB0C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x825AFB10; continue 'dispatch;
            }
            0x825AFB10 => {
    //   block [0x825AFB10..0x825AFB2C)
	// 825AFB10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFB14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFB18: 419A0014  beq cr6, 0x825afb2c
	if ctx.cr[6].eq {
	pc = 0x825AFB2C; continue 'dispatch;
	}
	// 825AFB1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFB20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFB24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFB28: 4800000C  b 0x825afb34
	pc = 0x825AFB34; continue 'dispatch;
            }
            0x825AFB2C => {
    //   block [0x825AFB2C..0x825AFB34)
	// 825AFB2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFB30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AFB34; continue 'dispatch;
            }
            0x825AFB34 => {
    //   block [0x825AFB34..0x825AFB40)
	// 825AFB34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFB38: 4199FFB8  bgt cr6, 0x825afaf0
	if ctx.cr[6].gt {
	pc = 0x825AFAF0; continue 'dispatch;
	}
	// 825AFB3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AFB40; continue 'dispatch;
            }
            0x825AFB40 => {
    //   block [0x825AFB40..0x825AFB5C)
	// 825AFB40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFB44: 419A003C  beq cr6, 0x825afb80
	if ctx.cr[6].eq {
	pc = 0x825AFB80; continue 'dispatch;
	}
	// 825AFB48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFB4C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825AFB50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB54: 41990008  bgt cr6, 0x825afb5c
	if ctx.cr[6].gt {
	pc = 0x825AFB5C; continue 'dispatch;
	}
	// 825AFB58: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825AFB5C; continue 'dispatch;
            }
            0x825AFB5C => {
    //   block [0x825AFB5C..0x825AFB80)
	// 825AFB5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFB60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFB64: 409A001C  bne cr6, 0x825afb80
	if !ctx.cr[6].eq {
	pc = 0x825AFB80; continue 'dispatch;
	}
	// 825AFB68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFB6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFB70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFB74: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFB78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB7C: 48000018  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
            }
            0x825AFB80 => {
    //   block [0x825AFB80..0x825AFB90)
	// 825AFB80: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFB84: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFB88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFB8C: 48000008  b 0x825afb94
	pc = 0x825AFB94; continue 'dispatch;
            }
            0x825AFB90 => {
    //   block [0x825AFB90..0x825AFB94)
	// 825AFB90: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825AFB94; continue 'dispatch;
            }
            0x825AFB94 => {
    //   block [0x825AFB94..0x825AFBF0)
	// 825AFB94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFB98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFB9C: 419A0054  beq cr6, 0x825afbf0
	if ctx.cr[6].eq {
	pc = 0x825AFBF0; continue 'dispatch;
	}
	// 825AFBA0: 38DB0010  addi r6, r27, 0x10
	ctx.r[6].s64 = ctx.r[27].s64 + 16;
	// 825AFBA4: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825AFBA8: 389B0050  addi r4, r27, 0x50
	ctx.r[4].s64 = ctx.r[27].s64 + 80;
	// 825AFBAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFBB0: 4BFCDE29  bl 0x8257d9d8
	ctx.lr = 0x825AFBB4;
	sub_8257D9D8(ctx, base);
	// 825AFBB4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825AFBB8: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBBC: 388BC254  addi r4, r11, -0x3dac
	ctx.r[4].s64 = ctx.r[11].s64 + -15788;
	// 825AFBC0: 4BC05949  bl 0x821b5508
	ctx.lr = 0x825AFBC4;
	sub_821B5508(ctx, base);
	// 825AFBC4: 907B0020  stw r3, 0x20(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 825AFBC8: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 825AFBCC: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBD0: 388AC258  addi r4, r10, -0x3da8
	ctx.r[4].s64 = ctx.r[10].s64 + -15784;
	// 825AFBD4: 4BC05935  bl 0x821b5508
	ctx.lr = 0x825AFBD8;
	sub_821B5508(ctx, base);
	// 825AFBD8: 907B002C  stw r3, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[3].u32 ) };
	// 825AFBDC: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 825AFBE0: 807F0094  lwz r3, 0x94(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 825AFBE4: 3889C250  addi r4, r9, -0x3db0
	ctx.r[4].s64 = ctx.r[9].s64 + -15792;
	// 825AFBE8: 4BC05921  bl 0x821b5508
	ctx.lr = 0x825AFBEC;
	sub_821B5508(ctx, base);
	// 825AFBEC: 907B0038  stw r3, 0x38(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(56 as u32), ctx.r[3].u32 ) };
	pc = 0x825AFBF0; continue 'dispatch;
            }
            0x825AFBF0 => {
    //   block [0x825AFBF0..0x825AFBF8)
	// 825AFBF0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825AFBF4: 486F9860  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFC28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825AFC28 size=696
    let mut pc: u32 = 0x825AFC28;
    'dispatch: loop {
        match pc {
            0x825AFC28 => {
    //   block [0x825AFC28..0x825AFC50)
	// 825AFC28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFC2C: 486F97E1  bl 0x82ca940c
	ctx.lr = 0x825AFC30;
	sub_82CA93D0(ctx, base);
	// 825AFC30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFC34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825AFC38: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825AFC3C: 817D0060  lwz r11, 0x60(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFC40: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFC44: 419A000C  beq cr6, 0x825afc50
	if ctx.cr[6].eq {
	pc = 0x825AFC50; continue 'dispatch;
	}
	// 825AFC48: 93DD0060  stw r30, 0x60(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825AFC4C: 4800170D  bl 0x825b1358
	ctx.lr = 0x825AFC50;
	sub_825B1358(ctx, base);
	pc = 0x825AFC50; continue 'dispatch;
            }
            0x825AFC50 => {
    //   block [0x825AFC50..0x825AFCA8)
	// 825AFC50: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825AFC54: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFC58: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 825AFC5C: 7FDFF378  mr r31, r30
	ctx.r[31].u64 = ctx.r[30].u64;
	// 825AFC60: 913D0074  stw r9, 0x74(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 825AFC64: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825AFC68: D01D0078  stfs f0, 0x78(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825AFC6C: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825AFC70: 5507FFFE  rlwinm r7, r8, 0x1f, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825AFC74: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFC78: 419A00F4  beq cr6, 0x825afd6c
	if ctx.cr[6].eq {
	pc = 0x825AFD6C; continue 'dispatch;
	}
	// 825AFC7C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFC80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFC84: 419A0024  beq cr6, 0x825afca8
	if ctx.cr[6].eq {
	pc = 0x825AFCA8; continue 'dispatch;
	}
	// 825AFC88: 894A0021  lbz r10, 0x21(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(33 as u32) ) } as u64;
	// 825AFC8C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFC90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825AFC94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825AFC98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFC9C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFCA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFCA4: 480000CC  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
            }
            0x825AFCA8 => {
    //   block [0x825AFCA8..0x825AFCC4)
	// 825AFCA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFCAC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFCB0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825AFCB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFCB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFCBC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFCC0: 40810054  ble 0x825afd14
	if !ctx.cr[0].gt {
	pc = 0x825AFD14; continue 'dispatch;
	}
	pc = 0x825AFCC4; continue 'dispatch;
            }
            0x825AFCC4 => {
    //   block [0x825AFCC4..0x825AFCE4)
	// 825AFCC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFCC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFCCC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFCD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFCD4: 2F070021  cmpwi cr6, r7, 0x21
	ctx.cr[6].compare_i32(ctx.r[7].s32, 33, &mut ctx.xer);
	// 825AFCD8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFCDC: 41980008  blt cr6, 0x825afce4
	if ctx.cr[6].lt {
	pc = 0x825AFCE4; continue 'dispatch;
	}
	// 825AFCE0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x825AFCE4; continue 'dispatch;
            }
            0x825AFCE4 => {
    //   block [0x825AFCE4..0x825AFD00)
	// 825AFCE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFCE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFCEC: 419A0014  beq cr6, 0x825afd00
	if ctx.cr[6].eq {
	pc = 0x825AFD00; continue 'dispatch;
	}
	// 825AFCF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFCF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFCF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFCFC: 4800000C  b 0x825afd08
	pc = 0x825AFD08; continue 'dispatch;
            }
            0x825AFD00 => {
    //   block [0x825AFD00..0x825AFD08)
	// 825AFD00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFD04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AFD08; continue 'dispatch;
            }
            0x825AFD08 => {
    //   block [0x825AFD08..0x825AFD14)
	// 825AFD08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFD0C: 4199FFB8  bgt cr6, 0x825afcc4
	if ctx.cr[6].gt {
	pc = 0x825AFCC4; continue 'dispatch;
	}
	// 825AFD10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AFD14; continue 'dispatch;
            }
            0x825AFD14 => {
    //   block [0x825AFD14..0x825AFD30)
	// 825AFD14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFD18: 419A0040  beq cr6, 0x825afd58
	if ctx.cr[6].eq {
	pc = 0x825AFD58; continue 'dispatch;
	}
	// 825AFD1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFD20: 2F0B0021  cmpwi cr6, r11, 0x21
	ctx.cr[6].compare_i32(ctx.r[11].s32, 33, &mut ctx.xer);
	// 825AFD24: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD28: 41990008  bgt cr6, 0x825afd30
	if ctx.cr[6].gt {
	pc = 0x825AFD30; continue 'dispatch;
	}
	// 825AFD2C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825AFD30; continue 'dispatch;
            }
            0x825AFD30 => {
    //   block [0x825AFD30..0x825AFD58)
	// 825AFD30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFD34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFD38: 409A0020  bne cr6, 0x825afd58
	if !ctx.cr[6].eq {
	pc = 0x825AFD58; continue 'dispatch;
	}
	// 825AFD3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFD40: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFD44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFD48: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD4C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFD50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD54: 4800001C  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
            }
            0x825AFD58 => {
    //   block [0x825AFD58..0x825AFD6C)
	// 825AFD58: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFD5C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD60: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFD64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFD68: 48000008  b 0x825afd70
	pc = 0x825AFD70; continue 'dispatch;
            }
            0x825AFD6C => {
    //   block [0x825AFD6C..0x825AFD70)
	// 825AFD6C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825AFD70; continue 'dispatch;
            }
            0x825AFD70 => {
    //   block [0x825AFD70..0x825AFD94)
	// 825AFD70: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFD74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFD78: 419A001C  beq cr6, 0x825afd94
	if ctx.cr[6].eq {
	pc = 0x825AFD94; continue 'dispatch;
	}
	// 825AFD7C: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 825AFD80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFD84: 4BE3A13D  bl 0x823e9ec0
	ctx.lr = 0x825AFD88;
	sub_823E9EC0(ctx, base);
	// 825AFD88: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 825AFD8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFD90: 4BE39F01  bl 0x823e9c90
	ctx.lr = 0x825AFD94;
	sub_823E9C90(ctx, base);
	pc = 0x825AFD94; continue 'dispatch;
            }
            0x825AFD94 => {
    //   block [0x825AFD94..0x825AFDD4)
	// 825AFD94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFD98: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825AFD9C: 55495FFE  rlwinm r9, r10, 0xb, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x001FFFFFu64;
	// 825AFDA0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825AFDA4: 419A00F4  beq cr6, 0x825afe98
	if ctx.cr[6].eq {
	pc = 0x825AFE98; continue 'dispatch;
	}
	// 825AFDA8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825AFDAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825AFDB0: 419A0024  beq cr6, 0x825afdd4
	if ctx.cr[6].eq {
	pc = 0x825AFDD4; continue 'dispatch;
	}
	// 825AFDB4: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 825AFDB8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFDBC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825AFDC0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825AFDC4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFDC8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFDCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFDD0: 480000D0  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
            }
            0x825AFDD4 => {
    //   block [0x825AFDD4..0x825AFDF0)
	// 825AFDD4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825AFDD8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825AFDDC: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825AFDE0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825AFDE4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825AFDE8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFDEC: 40810054  ble 0x825afe40
	if !ctx.cr[0].gt {
	pc = 0x825AFE40; continue 'dispatch;
	}
	pc = 0x825AFDF0; continue 'dispatch;
            }
            0x825AFDF0 => {
    //   block [0x825AFDF0..0x825AFE10)
	// 825AFDF0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825AFDF4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825AFDF8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825AFDFC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFE00: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825AFE04: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825AFE08: 41980008  blt cr6, 0x825afe10
	if ctx.cr[6].lt {
	pc = 0x825AFE10; continue 'dispatch;
	}
	// 825AFE0C: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x825AFE10; continue 'dispatch;
            }
            0x825AFE10 => {
    //   block [0x825AFE10..0x825AFE2C)
	// 825AFE10: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825AFE14: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825AFE18: 419A0014  beq cr6, 0x825afe2c
	if ctx.cr[6].eq {
	pc = 0x825AFE2C; continue 'dispatch;
	}
	// 825AFE1C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825AFE20: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825AFE24: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825AFE28: 4800000C  b 0x825afe34
	pc = 0x825AFE34; continue 'dispatch;
            }
            0x825AFE2C => {
    //   block [0x825AFE2C..0x825AFE34)
	// 825AFE2C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825AFE30: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825AFE34; continue 'dispatch;
            }
            0x825AFE34 => {
    //   block [0x825AFE34..0x825AFE40)
	// 825AFE34: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825AFE38: 4199FFB8  bgt cr6, 0x825afdf0
	if ctx.cr[6].gt {
	pc = 0x825AFDF0; continue 'dispatch;
	}
	// 825AFE3C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825AFE40; continue 'dispatch;
            }
            0x825AFE40 => {
    //   block [0x825AFE40..0x825AFE5C)
	// 825AFE40: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825AFE44: 419A0040  beq cr6, 0x825afe84
	if ctx.cr[6].eq {
	pc = 0x825AFE84; continue 'dispatch;
	}
	// 825AFE48: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825AFE4C: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825AFE50: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE54: 41990008  bgt cr6, 0x825afe5c
	if ctx.cr[6].gt {
	pc = 0x825AFE5C; continue 'dispatch;
	}
	// 825AFE58: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825AFE5C; continue 'dispatch;
            }
            0x825AFE5C => {
    //   block [0x825AFE5C..0x825AFE84)
	// 825AFE5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFE60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFE64: 409A0020  bne cr6, 0x825afe84
	if !ctx.cr[6].eq {
	pc = 0x825AFE84; continue 'dispatch;
	}
	// 825AFE68: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825AFE6C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825AFE70: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825AFE74: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFE78: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFE7C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE80: 48000020  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
            }
            0x825AFE84 => {
    //   block [0x825AFE84..0x825AFE98)
	// 825AFE84: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825AFE88: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825AFE8C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825AFE90: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825AFE94: 4800000C  b 0x825afea0
	pc = 0x825AFEA0; continue 'dispatch;
            }
            0x825AFE98 => {
    //   block [0x825AFE98..0x825AFEA0)
	// 825AFE98: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825AFE9C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825AFEA0; continue 'dispatch;
            }
            0x825AFEA0 => {
    //   block [0x825AFEA0..0x825AFED0)
	// 825AFEA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825AFEA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFEA8: 419A0028  beq cr6, 0x825afed0
	if ctx.cr[6].eq {
	pc = 0x825AFED0; continue 'dispatch;
	}
	// 825AFEAC: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825AFEB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFEB4: 4BC4F715  bl 0x821ff5c8
	ctx.lr = 0x825AFEB8;
	sub_821FF5C8(ctx, base);
	// 825AFEB8: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825AFEBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825AFEC0: 419A0010  beq cr6, 0x825afed0
	if ctx.cr[6].eq {
	pc = 0x825AFED0; continue 'dispatch;
	}
	// 825AFEC4: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825AFEC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825AFECC: 4BE703D5  bl 0x824202a0
	ctx.lr = 0x825AFED0;
	sub_824202A0(ctx, base);
	pc = 0x825AFED0; continue 'dispatch;
            }
            0x825AFED0 => {
    //   block [0x825AFED0..0x825AFEE0)
	// 825AFED0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825AFED4: 480009FD  bl 0x825b08d0
	ctx.lr = 0x825AFED8;
	sub_825B08D0(ctx, base);
	// 825AFED8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825AFEDC: 486F9580  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFEF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFEF8 size=68
    let mut pc: u32 = 0x825AFEF8;
    'dispatch: loop {
        match pc {
            0x825AFEF8 => {
    //   block [0x825AFEF8..0x825AFF20)
	// 825AFEF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFEFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFF00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFF04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFF08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFF0C: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFF10: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825AFF14: 419A000C  beq cr6, 0x825aff20
	if ctx.cr[6].eq {
	pc = 0x825AFF20; continue 'dispatch;
	}
	// 825AFF18: 909F0060  stw r4, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[4].u32 ) };
	// 825AFF1C: 4800143D  bl 0x825b1358
	ctx.lr = 0x825AFF20;
	sub_825B1358(ctx, base);
	pc = 0x825AFF20; continue 'dispatch;
            }
            0x825AFF20 => {
    //   block [0x825AFF20..0x825AFF3C)
	// 825AFF20: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFF24: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFF28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFF38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFF40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFF40 size=100
    let mut pc: u32 = 0x825AFF40;
    'dispatch: loop {
        match pc {
            0x825AFF40 => {
    //   block [0x825AFF40..0x825AFF88)
	// 825AFF40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFF44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFF48: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFF4C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFF50: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFF54: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFF58: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825AFF5C: 419A002C  beq cr6, 0x825aff88
	if ctx.cr[6].eq {
	pc = 0x825AFF88; continue 'dispatch;
	}
	// 825AFF60: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825AFF64: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AFF68: 480013F1  bl 0x825b1358
	ctx.lr = 0x825AFF6C;
	sub_825B1358(ctx, base);
	// 825AFF6C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AFF70: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825AFF74: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF78: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF7C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF80: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFF84: 4E800020  blr
	return;
            }
            0x825AFF88 => {
    //   block [0x825AFF88..0x825AFFA4)
	// 825AFF88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFF8C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFF90: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFF94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFF98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFF9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825AFFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825AFFA8 size=100
    let mut pc: u32 = 0x825AFFA8;
    'dispatch: loop {
        match pc {
            0x825AFFA8 => {
    //   block [0x825AFFA8..0x825AFFF0)
	// 825AFFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825AFFAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825AFFB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825AFFB4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825AFFB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825AFFBC: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825AFFC0: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 825AFFC4: 419A002C  beq cr6, 0x825afff0
	if ctx.cr[6].eq {
	pc = 0x825AFFF0; continue 'dispatch;
	}
	// 825AFFC8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 825AFFCC: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825AFFD0: 48001389  bl 0x825b1358
	ctx.lr = 0x825AFFD4;
	sub_825B1358(ctx, base);
	// 825AFFD4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825AFFD8: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825AFFDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFFE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825AFFE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825AFFE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825AFFEC: 4E800020  blr
	return;
            }
            0x825AFFF0 => {
    //   block [0x825AFFF0..0x825B000C)
	// 825AFFF0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825AFFF4: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825AFFF8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825AFFFC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0000: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0004: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0008: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0010(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0010 size=100
    let mut pc: u32 = 0x825B0010;
    'dispatch: loop {
        match pc {
            0x825B0010 => {
    //   block [0x825B0010..0x825B0058)
	// 825B0010: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0014: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0018: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B001C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0020: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B0024: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B0028: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825B002C: 419A002C  beq cr6, 0x825b0058
	if ctx.cr[6].eq {
	pc = 0x825B0058; continue 'dispatch;
	}
	// 825B0030: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0034: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B0038: 48001321  bl 0x825b1358
	ctx.lr = 0x825B003C;
	sub_825B1358(ctx, base);
	// 825B003C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0040: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 825B0044: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B0048: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B004C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0050: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0054: 4E800020  blr
	return;
            }
            0x825B0058 => {
    //   block [0x825B0058..0x825B0074)
	// 825B0058: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B005C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 825B0060: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B0064: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0068: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B006C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0070: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0078 size=52
    let mut pc: u32 = 0x825B0078;
    'dispatch: loop {
        match pc {
            0x825B0078 => {
    //   block [0x825B0078..0x825B00AC)
	// 825B0078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B007C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B0084: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0088: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B008C: 4BFFFB9D  bl 0x825afc28
	ctx.lr = 0x825B0090;
	sub_825AFC28(ctx, base);
	// 825B0090: 387F0068  addi r3, r31, 0x68
	ctx.r[3].s64 = ctx.r[31].s64 + 104;
	// 825B0094: 48464CFD  bl 0x82a14d90
	ctx.lr = 0x825B0098;
	sub_82A14D90(ctx, base);
	// 825B0098: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B009C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B00A0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B00A4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B00A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B00B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B00B0 size=56
    let mut pc: u32 = 0x825B00B0;
    'dispatch: loop {
        match pc {
            0x825B00B0 => {
    //   block [0x825B00B0..0x825B00E8)
	// 825B00B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B00B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B00B8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B00BC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B00C0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B00C4: 4BCEC55D  bl 0x8229c620
	ctx.lr = 0x825B00C8;
	sub_8229C620(ctx, base);
	// 825B00C8: 7D63F850  subf r11, r3, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[3].s64;
	// 825B00CC: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B00D0: 5543DFFE  rlwinm r3, r10, 0x1b, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825B00D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B00D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B00DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B00E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B00E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B00E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B00E8 size=164
    let mut pc: u32 = 0x825B00E8;
    'dispatch: loop {
        match pc {
            0x825B00E8 => {
    //   block [0x825B00E8..0x825B012C)
	// 825B00E8: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B00EC: 8103006C  lwz r8, 0x6c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B00F0: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825B00F4: 39230068  addi r9, r3, 0x68
	ctx.r[9].s64 = ctx.r[3].s64 + 104;
	// 825B00F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B00FC: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 825B0100: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825B0104: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0108: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B010C: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0110: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825B0114: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 825B0118: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B011C: 7CA65050  subf r5, r6, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825B0120: 7CAAFE70  srawi r10, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 825B0124: 7D472838  and r7, r10, r5
	ctx.r[7].u64 = ctx.r[10].u64 & ctx.r[5].u64;
	// 825B0128: 7CE72850  subf r7, r7, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[7].s64;
	pc = 0x825B012C; continue 'dispatch;
            }
            0x825B012C => {
    //   block [0x825B012C..0x825B0138)
	// 825B012C: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B0130: 419A0008  beq cr6, 0x825b0138
	if ctx.cr[6].eq {
	pc = 0x825B0138; continue 'dispatch;
	}
	// 825B0134: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0138; continue 'dispatch;
            }
            0x825B0138 => {
    //   block [0x825B0138..0x825B0150)
	// 825B0138: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B013C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B0140: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0144: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0148: 409A0008  bne cr6, 0x825b0150
	if !ctx.cr[6].eq {
	pc = 0x825B0150; continue 'dispatch;
	}
	// 825B014C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0150; continue 'dispatch;
            }
            0x825B0150 => {
    //   block [0x825B0150..0x825B0174)
	// 825B0150: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B0154: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 825B0158: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825B015C: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B0160: 40990014  ble cr6, 0x825b0174
	if !ctx.cr[6].gt {
	pc = 0x825B0174; continue 'dispatch;
	}
	// 825B0164: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B0168: 7F043040  cmplw cr6, r4, r6
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B016C: 419A0008  beq cr6, 0x825b0174
	if ctx.cr[6].eq {
	pc = 0x825B0174; continue 'dispatch;
	}
	// 825B0170: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x825B0174; continue 'dispatch;
            }
            0x825B0174 => {
    //   block [0x825B0174..0x825B0180)
	// 825B0174: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0178: 409A0008  bne cr6, 0x825b0180
	if !ctx.cr[6].eq {
	pc = 0x825B0180; continue 'dispatch;
	}
	// 825B017C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0180; continue 'dispatch;
            }
            0x825B0180 => {
    //   block [0x825B0180..0x825B018C)
	// 825B0180: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0184: 4BFFFFA8  b 0x825b012c
	pc = 0x825B012C; continue 'dispatch;
	// 825B0188: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0190 size=152
    let mut pc: u32 = 0x825B0190;
    'dispatch: loop {
        match pc {
            0x825B0190 => {
    //   block [0x825B0190..0x825B01D4)
	// 825B0190: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0194: 8103006C  lwz r8, 0x6c(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B0198: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825B019C: 39230068  addi r9, r3, 0x68
	ctx.r[9].s64 = ctx.r[3].s64 + 104;
	// 825B01A0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B01A4: C80B9660  lfd f0, -0x69a0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(-27040 as u32) ) };
	// 825B01A8: FC010032  fmul f0, f1, f0
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[0].f64;
	// 825B01AC: 814A9650  lwz r10, -0x69b0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B01B0: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B01B4: 81670000  lwz r11, 0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B01B8: FDA0001E  fctiwz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 825B01BC: D9A1FFF0  stfd f13, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.f[13].u64 ) };
	// 825B01C0: 80C1FFF4  lwz r6, -0xc(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B01C4: 7CA65050  subf r5, r6, r10
	ctx.r[5].s64 = ctx.r[10].s64 - ctx.r[6].s64;
	// 825B01C8: 7CA4FE70  srawi r4, r5, 0x1f
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 31) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[5].s32 >> 31) as i64;
	// 825B01CC: 7C8A2838  and r10, r4, r5
	ctx.r[10].u64 = ctx.r[4].u64 & ctx.r[5].u64;
	// 825B01D0: 7CEA2850  subf r7, r10, r5
	ctx.r[7].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	pc = 0x825B01D4; continue 'dispatch;
            }
            0x825B01D4 => {
    //   block [0x825B01D4..0x825B01E0)
	// 825B01D4: 7F094840  cmplw cr6, r9, r9
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B01D8: 419A0008  beq cr6, 0x825b01e0
	if ctx.cr[6].eq {
	pc = 0x825B01E0; continue 'dispatch;
	}
	// 825B01DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B01E0; continue 'dispatch;
            }
            0x825B01E0 => {
    //   block [0x825B01E0..0x825B01F8)
	// 825B01E0: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B01E4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B01E8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B01EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B01F0: 409A0008  bne cr6, 0x825b01f8
	if !ctx.cr[6].eq {
	pc = 0x825B01F8; continue 'dispatch;
	}
	// 825B01F4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B01F8; continue 'dispatch;
            }
            0x825B01F8 => {
    //   block [0x825B01F8..0x825B0210)
	// 825B01F8: E8CB0008  ld r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 825B01FC: F8C1FFF0  std r6, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[6].u64 ) };
	// 825B0200: 80A1FFF0  lwz r5, -0x10(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825B0204: 7F053800  cmpw cr6, r5, r7
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[7].s32, &mut ctx.xer);
	// 825B0208: 40990008  ble cr6, 0x825b0210
	if !ctx.cr[6].gt {
	pc = 0x825B0210; continue 'dispatch;
	}
	// 825B020C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	pc = 0x825B0210; continue 'dispatch;
            }
            0x825B0210 => {
    //   block [0x825B0210..0x825B021C)
	// 825B0210: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B0214: 409A0008  bne cr6, 0x825b021c
	if !ctx.cr[6].eq {
	pc = 0x825B021C; continue 'dispatch;
	}
	// 825B0218: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B021C; continue 'dispatch;
            }
            0x825B021C => {
    //   block [0x825B021C..0x825B0228)
	// 825B021C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0220: 4BFFFFB4  b 0x825b01d4
	pc = 0x825B01D4; continue 'dispatch;
	// 825B0224: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0228(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0228 size=672
    let mut pc: u32 = 0x825B0228;
    'dispatch: loop {
        match pc {
            0x825B0228 => {
    //   block [0x825B0228..0x825B02A0)
	// 825B0228: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B022C: 486F91E1  bl 0x82ca940c
	ctx.lr = 0x825B0230;
	sub_82CA93D0(ctx, base);
	// 825B0230: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0234: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B0238: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B023C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0240: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0244: 409A027C  bne cr6, 0x825b04c0
	if !ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B0248: 897E001A  lbz r11, 0x1a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(26 as u32) ) } as u64;
	// 825B024C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0250: 419A0050  beq cr6, 0x825b02a0
	if ctx.cr[6].eq {
	pc = 0x825B02A0; continue 'dispatch;
	}
	// 825B0254: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 825B0258: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B025C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B0260: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0264: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B0268: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B026C: 4BC7CC65  bl 0x8222ced0
	ctx.lr = 0x825B0270;
	sub_8222CED0(ctx, base);
	// 825B0270: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0274: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B0278: 4BBEC371  bl 0x8219c5e8
	ctx.lr = 0x825B027C;
	sub_8219C5E8(ctx, base);
	// 825B027C: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B0280: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0284: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0288: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B028C: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0290: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B0294: 4BC64B45  bl 0x82214dd8
	ctx.lr = 0x825B0298;
	sub_82214DD8(ctx, base);
	// 825B0298: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B029C: 486F91C0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B02A0 => {
    //   block [0x825B02A0..0x825B0334)
	// 825B02A0: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 825B02A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B02A8: 409A0218  bne cr6, 0x825b04c0
	if !ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B02AC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 825B02B0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B02B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B02B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B02BC: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B02C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B02C4: 4BC7CC0D  bl 0x8222ced0
	ctx.lr = 0x825B02C8;
	sub_8222CED0(ctx, base);
	// 825B02C8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B02CC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B02D0: 4BBEC319  bl 0x8219c5e8
	ctx.lr = 0x825B02D4;
	sub_8219C5E8(ctx, base);
	// 825B02D4: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B02D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B02DC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B02E0: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B02E4: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B02E8: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B02EC: 4BC64AED  bl 0x82214dd8
	ctx.lr = 0x825B02F0;
	sub_82214DD8(ctx, base);
	// 825B02F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B02F4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B02F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B02FC: 419A0038  beq cr6, 0x825b0334
	if ctx.cr[6].eq {
	pc = 0x825B0334; continue 'dispatch;
	}
	// 825B0300: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0304: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0308: 419A0080  beq cr6, 0x825b0388
	if ctx.cr[6].eq {
	pc = 0x825B0388; continue 'dispatch;
	}
	// 825B030C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0314: 419A0020  beq cr6, 0x825b0334
	if ctx.cr[6].eq {
	pc = 0x825B0334; continue 'dispatch;
	}
	// 825B0318: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B031C: 4BBC3B1D  bl 0x82173e38
	ctx.lr = 0x825B0320;
	sub_82173E38(ctx, base);
	// 825B0320: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B0324: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0328: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B032C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0330: 409A0008  bne cr6, 0x825b0338
	if !ctx.cr[6].eq {
	pc = 0x825B0338; continue 'dispatch;
	}
	pc = 0x825B0334; continue 'dispatch;
            }
            0x825B0334 => {
    //   block [0x825B0334..0x825B0338)
	// 825B0334: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0338; continue 'dispatch;
            }
            0x825B0338 => {
    //   block [0x825B0338..0x825B0388)
	// 825B0338: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B033C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0340: 419A0180  beq cr6, 0x825b04c0
	if ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B0344: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0348: 4BBC3AF1  bl 0x82173e38
	ctx.lr = 0x825B034C;
	sub_82173E38(ctx, base);
	// 825B034C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0350: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 825B0354: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0358: 419A0100  beq cr6, 0x825b0458
	if ctx.cr[6].eq {
	pc = 0x825B0458; continue 'dispatch;
	}
	// 825B035C: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0364: 419A0030  beq cr6, 0x825b0394
	if ctx.cr[6].eq {
	pc = 0x825B0394; continue 'dispatch;
	}
	// 825B0368: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 825B036C: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0370: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0374: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0378: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B037C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0380: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0384: 480000DC  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
            }
            0x825B0388 => {
    //   block [0x825B0388..0x825B0394)
	// 825B0388: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B038C: 4BBE3AAD  bl 0x82193e38
	ctx.lr = 0x825B0390;
	sub_82193E38(ctx, base);
	// 825B0390: 4BFFFFA4  b 0x825b0334
	pc = 0x825B0334; continue 'dispatch;
            }
            0x825B0394 => {
    //   block [0x825B0394..0x825B03B0)
	// 825B0394: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0398: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B039C: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B03A0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B03A4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B03A8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B03AC: 40810054  ble 0x825b0400
	if !ctx.cr[0].gt {
	pc = 0x825B0400; continue 'dispatch;
	}
	pc = 0x825B03B0; continue 'dispatch;
            }
            0x825B03B0 => {
    //   block [0x825B03B0..0x825B03D0)
	// 825B03B0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B03B4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B03B8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B03BC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B03C0: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825B03C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B03C8: 41980008  blt cr6, 0x825b03d0
	if ctx.cr[6].lt {
	pc = 0x825B03D0; continue 'dispatch;
	}
	// 825B03CC: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x825B03D0; continue 'dispatch;
            }
            0x825B03D0 => {
    //   block [0x825B03D0..0x825B03EC)
	// 825B03D0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B03D4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B03D8: 419A0014  beq cr6, 0x825b03ec
	if ctx.cr[6].eq {
	pc = 0x825B03EC; continue 'dispatch;
	}
	// 825B03DC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B03E0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B03E4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B03E8: 4800000C  b 0x825b03f4
	pc = 0x825B03F4; continue 'dispatch;
            }
            0x825B03EC => {
    //   block [0x825B03EC..0x825B03F4)
	// 825B03EC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B03F0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B03F4; continue 'dispatch;
            }
            0x825B03F4 => {
    //   block [0x825B03F4..0x825B0400)
	// 825B03F4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B03F8: 4199FFB8  bgt cr6, 0x825b03b0
	if ctx.cr[6].gt {
	pc = 0x825B03B0; continue 'dispatch;
	}
	// 825B03FC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B0400; continue 'dispatch;
            }
            0x825B0400 => {
    //   block [0x825B0400..0x825B041C)
	// 825B0400: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B0404: 419A0040  beq cr6, 0x825b0444
	if ctx.cr[6].eq {
	pc = 0x825B0444; continue 'dispatch;
	}
	// 825B0408: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B040C: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825B0410: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0414: 41990008  bgt cr6, 0x825b041c
	if ctx.cr[6].gt {
	pc = 0x825B041C; continue 'dispatch;
	}
	// 825B0418: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B041C; continue 'dispatch;
            }
            0x825B041C => {
    //   block [0x825B041C..0x825B0444)
	// 825B041C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0420: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0424: 409A0020  bne cr6, 0x825b0444
	if !ctx.cr[6].eq {
	pc = 0x825B0444; continue 'dispatch;
	}
	// 825B0428: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B042C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B0430: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0434: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0438: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B043C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0440: 48000020  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
            }
            0x825B0444 => {
    //   block [0x825B0444..0x825B0458)
	// 825B0444: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0448: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B044C: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0450: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0454: 4800000C  b 0x825b0460
	pc = 0x825B0460; continue 'dispatch;
            }
            0x825B0458 => {
    //   block [0x825B0458..0x825B0460)
	// 825B0458: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B045C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0460; continue 'dispatch;
            }
            0x825B0460 => {
    //   block [0x825B0460..0x825B04C0)
	// 825B0460: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0464: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0468: 419A0058  beq cr6, 0x825b04c0
	if ctx.cr[6].eq {
	pc = 0x825B04C0; continue 'dispatch;
	}
	// 825B046C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 825B0470: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0474: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B0478: 48160C29  bl 0x827110a0
	ctx.lr = 0x825B047C;
	sub_827110A0(ctx, base);
	// 825B047C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B0480: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B0484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0488: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B048C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B0490: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B0494: 4E800421  bctrl
	ctx.lr = 0x825B0498;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B0498: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B049C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B04A0: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 825B04A4: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B04A8: 4BBE3991  bl 0x82193e38
	ctx.lr = 0x825B04AC;
	sub_82193E38(ctx, base);
	// 825B04AC: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825B04B0: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825B04B4: 4BC64925  bl 0x82214dd8
	ctx.lr = 0x825B04B8;
	sub_82214DD8(ctx, base);
	// 825B04B8: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B04BC: 4BBFC675  bl 0x821acb30
	ctx.lr = 0x825B04C0;
	sub_821ACB30(ctx, base);
            }
            0x825B04C0 => {
    //   block [0x825B04C0..0x825B04C8)
	// 825B04C0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B04C4: 486F8F98  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B04C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B04C8 size=316
    let mut pc: u32 = 0x825B04C8;
    'dispatch: loop {
        match pc {
            0x825B04C8 => {
    //   block [0x825B04C8..0x825B0508)
	// 825B04C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B04CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B04D0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B04D4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B04D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B04DC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B04E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B04E4: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B04E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B04EC: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B04F0: C00B9484  lfs f0, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B04F4: D01E006C  stfs f0, 0x6c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825B04F8: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 825B04FC: 409A000C  bne cr6, 0x825b0508
	if !ctx.cr[6].eq {
	pc = 0x825B0508; continue 'dispatch;
	}
	// 825B0500: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0504: 4BFFFD25  bl 0x825b0228
	ctx.lr = 0x825B0508;
	sub_825B0228(ctx, base);
	pc = 0x825B0508; continue 'dispatch;
            }
            0x825B0508 => {
    //   block [0x825B0508..0x825B051C)
	// 825B0508: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B050C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0510: 419A000C  beq cr6, 0x825b051c
	if ctx.cr[6].eq {
	pc = 0x825B051C; continue 'dispatch;
	}
	// 825B0514: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B0518: 409A0048  bne cr6, 0x825b0560
	if !ctx.cr[6].eq {
	pc = 0x825B0560; continue 'dispatch;
	}
	pc = 0x825B051C; continue 'dispatch;
            }
            0x825B051C => {
    //   block [0x825B051C..0x825B0558)
	// 825B051C: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 825B0520: 894BEAEB  lbz r10, -0x1515(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5397 as u32) ) } as u64;
	// 825B0524: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0528: 409A0030  bne cr6, 0x825b0558
	if !ctx.cr[6].eq {
	pc = 0x825B0558; continue 'dispatch;
	}
	// 825B052C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B0530: 809EFFF8  lwz r4, -8(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0534: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B0538: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B053C: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B0540: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0544: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0548: 4BC82231  bl 0x82232778
	ctx.lr = 0x825B054C;
	sub_82232778(ctx, base);
	// 825B054C: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0550: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0554: 409A000C  bne cr6, 0x825b0560
	if !ctx.cr[6].eq {
	pc = 0x825B0560; continue 'dispatch;
	}
	pc = 0x825B0558; continue 'dispatch;
            }
            0x825B0558 => {
    //   block [0x825B0558..0x825B0560)
	// 825B0558: 387EFFF4  addi r3, r30, -0xc
	ctx.r[3].s64 = ctx.r[30].s64 + -12;
	// 825B055C: 4BFFF6CD  bl 0x825afc28
	ctx.lr = 0x825B0560;
	sub_825AFC28(ctx, base);
	pc = 0x825B0560; continue 'dispatch;
            }
            0x825B0560 => {
    //   block [0x825B0560..0x825B0588)
	// 825B0560: 817E0064  lwz r11, 0x64(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B0564: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 825B0568: 409A0054  bne cr6, 0x825b05bc
	if !ctx.cr[6].eq {
	pc = 0x825B05BC; continue 'dispatch;
	}
	// 825B056C: 815E0060  lwz r10, 0x60(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B0570: 3BFE005C  addi r31, r30, 0x5c
	ctx.r[31].s64 = ctx.r[30].s64 + 92;
	// 825B0574: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B0578: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B057C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B0580: 409A0008  bne cr6, 0x825b0588
	if !ctx.cr[6].eq {
	pc = 0x825B0588; continue 'dispatch;
	}
	// 825B0584: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0588; continue 'dispatch;
            }
            0x825B0588 => {
    //   block [0x825B0588..0x825B05BC)
	// 825B0588: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B058C: 419A0030  beq cr6, 0x825b05bc
	if ctx.cr[6].eq {
	pc = 0x825B05BC; continue 'dispatch;
	}
	// 825B0590: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0594: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B0598: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B059C: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B05A0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B05A4: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B05A8: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825B05AC: 4BC6B78D  bl 0x8221bd38
	ctx.lr = 0x825B05B0;
	sub_8221BD38(ctx, base);
	// 825B05B0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B05B4: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 825B05B8: 90DF0008  stw r6, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x825B05BC; continue 'dispatch;
            }
            0x825B05BC => {
    //   block [0x825B05BC..0x825B0604)
	// 825B05BC: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B05C0: 815E0054  lwz r10, 0x54(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B05C4: 813E0060  lwz r9, 0x60(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B05C8: 387E005C  addi r3, r30, 0x5c
	ctx.r[3].s64 = ctx.r[30].s64 + 92;
	// 825B05CC: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825B05D0: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825B05D4: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B05D8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B05DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B05E0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B05E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825B05E8: 480D35B9  bl 0x82683ba0
	ctx.lr = 0x825B05EC;
	sub_82683BA0(ctx, base);
	// 825B05EC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B05F0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B05F4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B05F8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B05FC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0600: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0608(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0608 size=712
    let mut pc: u32 = 0x825B0608;
    'dispatch: loop {
        match pc {
            0x825B0608 => {
    //   block [0x825B0608..0x825B0638)
	// 825B0608: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B060C: 486F8E01  bl 0x82ca940c
	ctx.lr = 0x825B0610;
	sub_82CA93D0(ctx, base);
	// 825B0610: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0614: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B0618: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B061C: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B0620: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0624: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 825B0628: 409A0010  bne cr6, 0x825b0638
	if !ctx.cr[6].eq {
	pc = 0x825B0638; continue 'dispatch;
	}
	// 825B062C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0630: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0634: 4BFFFBF5  bl 0x825b0228
	ctx.lr = 0x825B0638;
	sub_825B0228(ctx, base);
	pc = 0x825B0638; continue 'dispatch;
            }
            0x825B0638 => {
    //   block [0x825B0638..0x825B06A8)
	// 825B0638: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B063C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0640: 409A0288  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0644: 817D0054  lwz r11, 0x54(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B0648: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825B064C: 409A027C  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0650: 897E001A  lbz r11, 0x1a(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(26 as u32) ) } as u64;
	// 825B0654: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0658: 419A0050  beq cr6, 0x825b06a8
	if ctx.cr[6].eq {
	pc = 0x825B06A8; continue 'dispatch;
	}
	// 825B065C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 825B0660: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B0664: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B0668: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B066C: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B0670: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0674: 4BC7C85D  bl 0x8222ced0
	ctx.lr = 0x825B0678;
	sub_8222CED0(ctx, base);
	// 825B0678: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B067C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B0680: 4BBEBF69  bl 0x8219c5e8
	ctx.lr = 0x825B0684;
	sub_8219C5E8(ctx, base);
	// 825B0684: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B0688: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B068C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0690: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B0694: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0698: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B069C: 4BC6473D  bl 0x82214dd8
	ctx.lr = 0x825B06A0;
	sub_82214DD8(ctx, base);
	// 825B06A0: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B06A4: 486F8DB8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B06A8 => {
    //   block [0x825B06A8..0x825B073C)
	// 825B06A8: 897E0019  lbz r11, 0x19(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(25 as u32) ) } as u64;
	// 825B06AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B06B0: 409A0218  bne cr6, 0x825b08c8
	if !ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B06B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B06B8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B06BC: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B06C0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B06C4: 388A52AC  addi r4, r10, 0x52ac
	ctx.r[4].s64 = ctx.r[10].s64 + 21164;
	// 825B06C8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B06CC: 4BC7C805  bl 0x8222ced0
	ctx.lr = 0x825B06D0;
	sub_8222CED0(ctx, base);
	// 825B06D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B06D4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B06D8: 4BBEBF11  bl 0x8219c5e8
	ctx.lr = 0x825B06DC;
	sub_8219C5E8(ctx, base);
	// 825B06DC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B06E0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B06E4: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B06E8: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B06EC: 80E90004  lwz r7, 4(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06F0: 90FF000C  stw r7, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B06F4: 4BC646E5  bl 0x82214dd8
	ctx.lr = 0x825B06F8;
	sub_82214DD8(ctx, base);
	// 825B06F8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B06FC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B0700: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0704: 419A0038  beq cr6, 0x825b073c
	if ctx.cr[6].eq {
	pc = 0x825B073C; continue 'dispatch;
	}
	// 825B0708: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B070C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0710: 419A0080  beq cr6, 0x825b0790
	if ctx.cr[6].eq {
	pc = 0x825B0790; continue 'dispatch;
	}
	// 825B0714: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B071C: 419A0020  beq cr6, 0x825b073c
	if ctx.cr[6].eq {
	pc = 0x825B073C; continue 'dispatch;
	}
	// 825B0720: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0724: 4BBC3715  bl 0x82173e38
	ctx.lr = 0x825B0728;
	sub_82173E38(ctx, base);
	// 825B0728: 89630090  lbz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B072C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0730: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0734: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0738: 409A0008  bne cr6, 0x825b0740
	if !ctx.cr[6].eq {
	pc = 0x825B0740; continue 'dispatch;
	}
	pc = 0x825B073C; continue 'dispatch;
            }
            0x825B073C => {
    //   block [0x825B073C..0x825B0740)
	// 825B073C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0740; continue 'dispatch;
            }
            0x825B0740 => {
    //   block [0x825B0740..0x825B0790)
	// 825B0740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0748: 419A0180  beq cr6, 0x825b08c8
	if ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B074C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0750: 4BBC36E9  bl 0x82173e38
	ctx.lr = 0x825B0754;
	sub_82173E38(ctx, base);
	// 825B0754: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0758: 556A7FFE  rlwinm r10, r11, 0xf, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 825B075C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0760: 419A0100  beq cr6, 0x825b0860
	if ctx.cr[6].eq {
	pc = 0x825B0860; continue 'dispatch;
	}
	// 825B0764: 8163008C  lwz r11, 0x8c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0768: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B076C: 419A0030  beq cr6, 0x825b079c
	if ctx.cr[6].eq {
	pc = 0x825B079C; continue 'dispatch;
	}
	// 825B0770: 894B0031  lbz r10, 0x31(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(49 as u32) ) } as u64;
	// 825B0774: 81630048  lwz r11, 0x48(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0778: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B077C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0780: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0784: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0788: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B078C: 480000DC  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
            }
            0x825B0790 => {
    //   block [0x825B0790..0x825B079C)
	// 825B0790: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B0794: 4BBE36A5  bl 0x82193e38
	ctx.lr = 0x825B0798;
	sub_82193E38(ctx, base);
	// 825B0798: 4BFFFFA4  b 0x825b073c
	pc = 0x825B073C; continue 'dispatch;
            }
            0x825B079C => {
    //   block [0x825B079C..0x825B07B8)
	// 825B079C: 81430048  lwz r10, 0x48(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B07A0: 80C3004C  lwz r6, 0x4c(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B07A4: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B07A8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B07AC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B07B0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B07B4: 40810054  ble 0x825b0808
	if !ctx.cr[0].gt {
	pc = 0x825B0808; continue 'dispatch;
	}
	pc = 0x825B07B8; continue 'dispatch;
            }
            0x825B07B8 => {
    //   block [0x825B07B8..0x825B07D8)
	// 825B07B8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B07BC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B07C0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B07C4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B07C8: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825B07CC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B07D0: 41980008  blt cr6, 0x825b07d8
	if ctx.cr[6].lt {
	pc = 0x825B07D8; continue 'dispatch;
	}
	// 825B07D4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x825B07D8; continue 'dispatch;
            }
            0x825B07D8 => {
    //   block [0x825B07D8..0x825B07F4)
	// 825B07D8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B07DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B07E0: 419A0014  beq cr6, 0x825b07f4
	if ctx.cr[6].eq {
	pc = 0x825B07F4; continue 'dispatch;
	}
	// 825B07E4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B07E8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B07EC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B07F0: 4800000C  b 0x825b07fc
	pc = 0x825B07FC; continue 'dispatch;
            }
            0x825B07F4 => {
    //   block [0x825B07F4..0x825B07FC)
	// 825B07F4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B07F8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B07FC; continue 'dispatch;
            }
            0x825B07FC => {
    //   block [0x825B07FC..0x825B0808)
	// 825B07FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0800: 4199FFB8  bgt cr6, 0x825b07b8
	if ctx.cr[6].gt {
	pc = 0x825B07B8; continue 'dispatch;
	}
	// 825B0804: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B0808; continue 'dispatch;
            }
            0x825B0808 => {
    //   block [0x825B0808..0x825B0824)
	// 825B0808: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B080C: 419A0040  beq cr6, 0x825b084c
	if ctx.cr[6].eq {
	pc = 0x825B084C; continue 'dispatch;
	}
	// 825B0810: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0814: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825B0818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B081C: 41990008  bgt cr6, 0x825b0824
	if ctx.cr[6].gt {
	pc = 0x825B0824; continue 'dispatch;
	}
	// 825B0820: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0824; continue 'dispatch;
            }
            0x825B0824 => {
    //   block [0x825B0824..0x825B084C)
	// 825B0824: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0828: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B082C: 409A0020  bne cr6, 0x825b084c
	if !ctx.cr[6].eq {
	pc = 0x825B084C; continue 'dispatch;
	}
	// 825B0830: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B0834: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B0838: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B083C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0840: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0844: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0848: 48000020  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
            }
            0x825B084C => {
    //   block [0x825B084C..0x825B0860)
	// 825B084C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0850: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0854: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B0858: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B085C: 4800000C  b 0x825b0868
	pc = 0x825B0868; continue 'dispatch;
            }
            0x825B0860 => {
    //   block [0x825B0860..0x825B0868)
	// 825B0860: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B0864: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B0868; continue 'dispatch;
            }
            0x825B0868 => {
    //   block [0x825B0868..0x825B08C8)
	// 825B0868: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B086C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0870: 419A0058  beq cr6, 0x825b08c8
	if ctx.cr[6].eq {
	pc = 0x825B08C8; continue 'dispatch;
	}
	// 825B0874: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B0878: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B087C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B0880: 48160821  bl 0x827110a0
	ctx.lr = 0x825B0884;
	sub_827110A0(ctx, base);
	// 825B0884: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B0888: 817E0044  lwz r11, 0x44(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(68 as u32) ) } as u64;
	// 825B088C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0890: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B0894: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B0898: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B089C: 4E800421  bctrl
	ctx.lr = 0x825B08A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B08A0: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B08A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B08A8: 392A0B7C  addi r9, r10, 0xb7c
	ctx.r[9].s64 = ctx.r[10].s64 + 2940;
	// 825B08AC: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B08B0: 4BBE3589  bl 0x82193e38
	ctx.lr = 0x825B08B4;
	sub_82193E38(ctx, base);
	// 825B08B4: 93A1005C  stw r29, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[29].u32 ) };
	// 825B08B8: 386100C4  addi r3, r1, 0xc4
	ctx.r[3].s64 = ctx.r[1].s64 + 196;
	// 825B08BC: 4BC6451D  bl 0x82214dd8
	ctx.lr = 0x825B08C0;
	sub_82214DD8(ctx, base);
	// 825B08C0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B08C4: 4BBFC26D  bl 0x821acb30
	ctx.lr = 0x825B08C8;
	sub_821ACB30(ctx, base);
            }
            0x825B08C8 => {
    //   block [0x825B08C8..0x825B08D0)
	// 825B08C8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 825B08CC: 486F8B90  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B08D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B08D0 size=364
    let mut pc: u32 = 0x825B08D0;
    'dispatch: loop {
        match pc {
            0x825B08D0 => {
    //   block [0x825B08D0..0x825B0938)
	// 825B08D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B08D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B08D8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B08DC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B08E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B08E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B08E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B08EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B08F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B08F4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B08F8: 995E007C  stb r10, 0x7c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[10].u8 ) };
	// 825B08FC: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B0900: 55285FFE  rlwinm r8, r9, 0xb, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x001FFFFFu64;
	// 825B0904: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0908: 419A00F4  beq cr6, 0x825b09fc
	if ctx.cr[6].eq {
	pc = 0x825B09FC; continue 'dispatch;
	}
	// 825B090C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0910: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0914: 419A0024  beq cr6, 0x825b0938
	if ctx.cr[6].eq {
	pc = 0x825B0938; continue 'dispatch;
	}
	// 825B0918: 892A0015  lbz r9, 0x15(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(21 as u32) ) } as u64;
	// 825B091C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0920: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B0924: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B0928: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B092C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B0930: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0934: 480000CC  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
            }
            0x825B0938 => {
    //   block [0x825B0938..0x825B0954)
	// 825B0938: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B093C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0940: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B0944: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0948: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B094C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0950: 40810054  ble 0x825b09a4
	if !ctx.cr[0].gt {
	pc = 0x825B09A4; continue 'dispatch;
	}
	pc = 0x825B0954; continue 'dispatch;
            }
            0x825B0954 => {
    //   block [0x825B0954..0x825B0974)
	// 825B0954: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0958: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B095C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0960: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0964: 2F070015  cmpwi cr6, r7, 0x15
	ctx.cr[6].compare_i32(ctx.r[7].s32, 21, &mut ctx.xer);
	// 825B0968: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B096C: 41980008  blt cr6, 0x825b0974
	if ctx.cr[6].lt {
	pc = 0x825B0974; continue 'dispatch;
	}
	// 825B0970: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B0974; continue 'dispatch;
            }
            0x825B0974 => {
    //   block [0x825B0974..0x825B0990)
	// 825B0974: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0978: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B097C: 419A0014  beq cr6, 0x825b0990
	if ctx.cr[6].eq {
	pc = 0x825B0990; continue 'dispatch;
	}
	// 825B0980: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0984: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0988: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B098C: 4800000C  b 0x825b0998
	pc = 0x825B0998; continue 'dispatch;
            }
            0x825B0990 => {
    //   block [0x825B0990..0x825B0998)
	// 825B0990: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B0994: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B0998; continue 'dispatch;
            }
            0x825B0998 => {
    //   block [0x825B0998..0x825B09A4)
	// 825B0998: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B099C: 4199FFB8  bgt cr6, 0x825b0954
	if ctx.cr[6].gt {
	pc = 0x825B0954; continue 'dispatch;
	}
	// 825B09A0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B09A4; continue 'dispatch;
            }
            0x825B09A4 => {
    //   block [0x825B09A4..0x825B09C0)
	// 825B09A4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B09A8: 419A0040  beq cr6, 0x825b09e8
	if ctx.cr[6].eq {
	pc = 0x825B09E8; continue 'dispatch;
	}
	// 825B09AC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B09B0: 2F0B0015  cmpwi cr6, r11, 0x15
	ctx.cr[6].compare_i32(ctx.r[11].s32, 21, &mut ctx.xer);
	// 825B09B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09B8: 41990008  bgt cr6, 0x825b09c0
	if ctx.cr[6].gt {
	pc = 0x825B09C0; continue 'dispatch;
	}
	// 825B09BC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B09C0; continue 'dispatch;
            }
            0x825B09C0 => {
    //   block [0x825B09C0..0x825B09E8)
	// 825B09C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B09C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B09C8: 409A0020  bne cr6, 0x825b09e8
	if !ctx.cr[6].eq {
	pc = 0x825B09E8; continue 'dispatch;
	}
	// 825B09CC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B09D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B09D4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B09D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B09DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B09E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09E4: 4800001C  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
            }
            0x825B09E8 => {
    //   block [0x825B09E8..0x825B09FC)
	// 825B09E8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B09EC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B09F0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B09F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B09F8: 48000008  b 0x825b0a00
	pc = 0x825B0A00; continue 'dispatch;
            }
            0x825B09FC => {
    //   block [0x825B09FC..0x825B0A00)
	// 825B09FC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B0A00; continue 'dispatch;
            }
            0x825B0A00 => {
    //   block [0x825B0A00..0x825B0A24)
	// 825B0A00: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0A04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A08: 419A001C  beq cr6, 0x825b0a24
	if ctx.cr[6].eq {
	pc = 0x825B0A24; continue 'dispatch;
	}
	// 825B0A0C: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 825B0A10: 4BC4EBB9  bl 0x821ff5c8
	ctx.lr = 0x825B0A14;
	sub_821FF5C8(ctx, base);
	// 825B0A14: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A1C: 419A0008  beq cr6, 0x825b0a24
	if ctx.cr[6].eq {
	pc = 0x825B0A24; continue 'dispatch;
	}
	// 825B0A20: 9BFE007C  stb r31, 0x7c(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[31].u8 ) };
	pc = 0x825B0A24; continue 'dispatch;
            }
            0x825B0A24 => {
    //   block [0x825B0A24..0x825B0A3C)
	// 825B0A24: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B0A28: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0A2C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0A30: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B0A34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0A38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0A40 size=212
    let mut pc: u32 = 0x825B0A40;
    'dispatch: loop {
        match pc {
            0x825B0A40 => {
    //   block [0x825B0A40..0x825B0A88)
	// 825B0A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0A44: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B0A48: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B0A4C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B0A50: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0A54: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B0A58: 480000C1  bl 0x825b0b18
	ctx.lr = 0x825B0A5C;
	sub_825B0B18(ctx, base);
	// 825B0A5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B0A60: 419A0098  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0A64: 81630010  lwz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B0A68: 3BE30008  addi r31, r3, 8
	ctx.r[31].s64 = ctx.r[3].s64 + 8;
	// 825B0A6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0A70: 41980018  blt cr6, 0x825b0a88
	if ctx.cr[6].lt {
	pc = 0x825B0A88; continue 'dispatch;
	}
	// 825B0A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0A78: 4BCE7CC1  bl 0x82298738
	ctx.lr = 0x825B0A7C;
	sub_82298738(ctx, base);
	// 825B0A7C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B0A80: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0A84: 409A0008  bne cr6, 0x825b0a8c
	if !ctx.cr[6].eq {
	pc = 0x825B0A8C; continue 'dispatch;
	}
	pc = 0x825B0A88; continue 'dispatch;
            }
            0x825B0A88 => {
    //   block [0x825B0A88..0x825B0A8C)
	// 825B0A88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B0A8C; continue 'dispatch;
            }
            0x825B0A8C => {
    //   block [0x825B0A8C..0x825B0AF8)
	// 825B0A8C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0A90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0A94: 419A0064  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B0A9C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0AA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B0AA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0AA8: 4BD08F71  bl 0x822b9a18
	ctx.lr = 0x825B0AAC;
	sub_822B9A18(ctx, base);
	// 825B0AAC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B0AB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0AB4: 419A0044  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AB8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B0ABC: 83FE0004  lwz r31, 4(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0AC0: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825B0AC4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0AC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0ACC: 419A002C  beq cr6, 0x825b0af8
	if ctx.cr[6].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AD0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B0AD4: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 825B0AD8: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B0ADC: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B0AE0: 41820018  beq 0x825b0af8
	if ctx.cr[0].eq {
	pc = 0x825B0AF8; continue 'dispatch;
	}
	// 825B0AE4: 480D75E5  bl 0x826880c8
	ctx.lr = 0x825B0AE8;
	sub_826880C8(ctx, base);
	// 825B0AE8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0AEC: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0AF0: 480D47B9  bl 0x826852a8
	ctx.lr = 0x825B0AF4;
	sub_826852A8(ctx, base);
	// 825B0AF4: 48000008  b 0x825b0afc
	pc = 0x825B0AFC; continue 'dispatch;
            }
            0x825B0AF8 => {
    //   block [0x825B0AF8..0x825B0AFC)
	// 825B0AF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x825B0AFC; continue 'dispatch;
            }
            0x825B0AFC => {
    //   block [0x825B0AFC..0x825B0B14)
	// 825B0AFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B0B00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B0B04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B0B08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B0B0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0B10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0B18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0B18 size=172
    let mut pc: u32 = 0x825B0B18;
    'dispatch: loop {
        match pc {
            0x825B0B18 => {
    //   block [0x825B0B18..0x825B0B34)
	// 825B0B18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0B1C: 486F88ED  bl 0x82ca9408
	ctx.lr = 0x825B0B20;
	sub_82CA93D0(ctx, base);
	// 825B0B20: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0B24: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B0B28: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B0B2C: 3BA30014  addi r29, r3, 0x14
	ctx.r[29].s64 = ctx.r[3].s64 + 20;
	// 825B0B30: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B0B34; continue 'dispatch;
            }
            0x825B0B34 => {
    //   block [0x825B0B34..0x825B0B44)
	// 825B0B34: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B38: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B0B3C: 419A0008  beq cr6, 0x825b0b44
	if ctx.cr[6].eq {
	pc = 0x825B0B44; continue 'dispatch;
	}
	// 825B0B40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0B44; continue 'dispatch;
            }
            0x825B0B44 => {
    //   block [0x825B0B44..0x825B0B5C)
	// 825B0B44: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B48: 419A0070  beq cr6, 0x825b0bb8
	if ctx.cr[6].eq {
	pc = 0x825B0BB8; continue 'dispatch;
	}
	// 825B0B4C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B50: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B54: 409A0008  bne cr6, 0x825b0b5c
	if !ctx.cr[6].eq {
	pc = 0x825B0B5C; continue 'dispatch;
	}
	// 825B0B58: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0B5C; continue 'dispatch;
            }
            0x825B0B5C => {
    //   block [0x825B0B5C..0x825B0B80)
	// 825B0B5C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B0B60: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825B0B64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0B68: 419A0020  beq cr6, 0x825b0b88
	if ctx.cr[6].eq {
	pc = 0x825B0B88; continue 'dispatch;
	}
	// 825B0B6C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0B70: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0B74: 419A000C  beq cr6, 0x825b0b80
	if ctx.cr[6].eq {
	pc = 0x825B0B80; continue 'dispatch;
	}
	// 825B0B78: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0B7C: 48000010  b 0x825b0b8c
	pc = 0x825B0B8C; continue 'dispatch;
            }
            0x825B0B80 => {
    //   block [0x825B0B80..0x825B0B88)
	// 825B0B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0B84: 4BBE32B5  bl 0x82193e38
	ctx.lr = 0x825B0B88;
	sub_82193E38(ctx, base);
	pc = 0x825B0B88; continue 'dispatch;
            }
            0x825B0B88 => {
    //   block [0x825B0B88..0x825B0B8C)
	// 825B0B88: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B0B8C; continue 'dispatch;
            }
            0x825B0B8C => {
    //   block [0x825B0B8C..0x825B0BA4)
	// 825B0B8C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B0B90: 419A001C  beq cr6, 0x825b0bac
	if ctx.cr[6].eq {
	pc = 0x825B0BAC; continue 'dispatch;
	}
	// 825B0B94: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0B98: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0B9C: 409A0008  bne cr6, 0x825b0ba4
	if !ctx.cr[6].eq {
	pc = 0x825B0BA4; continue 'dispatch;
	}
	// 825B0BA0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0BA4; continue 'dispatch;
            }
            0x825B0BA4 => {
    //   block [0x825B0BA4..0x825B0BAC)
	// 825B0BA4: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0BA8: 4BFFFF8C  b 0x825b0b34
	pc = 0x825B0B34; continue 'dispatch;
            }
            0x825B0BAC => {
    //   block [0x825B0BAC..0x825B0BB8)
	// 825B0BAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0BB0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B0BB4: 486F88A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B0BB8 => {
    //   block [0x825B0BB8..0x825B0BC4)
	// 825B0BB8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B0BBC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B0BC0: 486F8898  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0BC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0BC8 size=268
    let mut pc: u32 = 0x825B0BC8;
    'dispatch: loop {
        match pc {
            0x825B0BC8 => {
    //   block [0x825B0BC8..0x825B0BF4)
	// 825B0BC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0BCC: 486F8839  bl 0x82ca9404
	ctx.lr = 0x825B0BD0;
	sub_82CA93D0(ctx, base);
	// 825B0BD0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0BD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B0BD8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B0BDC: 3BA40014  addi r29, r4, 0x14
	ctx.r[29].s64 = ctx.r[4].s64 + 20;
	// 825B0BE0: 937C0004  stw r27, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825B0BE4: 937C0008  stw r27, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825B0BE8: 937C000C  stw r27, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 825B0BEC: 81640018  lwz r11, 0x18(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B0BF0: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B0BF4; continue 'dispatch;
            }
            0x825B0BF4 => {
    //   block [0x825B0BF4..0x825B0C04)
	// 825B0BF4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0BF8: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B0BFC: 419A0008  beq cr6, 0x825b0c04
	if ctx.cr[6].eq {
	pc = 0x825B0C04; continue 'dispatch;
	}
	// 825B0C00: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0C04; continue 'dispatch;
            }
            0x825B0C04 => {
    //   block [0x825B0C04..0x825B0C1C)
	// 825B0C04: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0C08: 419A00C0  beq cr6, 0x825b0cc8
	if ctx.cr[6].eq {
	pc = 0x825B0CC8; continue 'dispatch;
	}
	// 825B0C0C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0C10: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0C14: 409A0008  bne cr6, 0x825b0c1c
	if !ctx.cr[6].eq {
	pc = 0x825B0C1C; continue 'dispatch;
	}
	// 825B0C18: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0C1C; continue 'dispatch;
            }
            0x825B0C1C => {
    //   block [0x825B0C1C..0x825B0C58)
	// 825B0C1C: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B0C20: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825B0C24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C28: 419A0030  beq cr6, 0x825b0c58
	if ctx.cr[6].eq {
	pc = 0x825B0C58; continue 'dispatch;
	}
	// 825B0C2C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0C30: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C34: 419A0054  beq cr6, 0x825b0c88
	if ctx.cr[6].eq {
	pc = 0x825B0C88; continue 'dispatch;
	}
	// 825B0C38: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0C3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C40: 419A0018  beq cr6, 0x825b0c58
	if ctx.cr[6].eq {
	pc = 0x825B0C58; continue 'dispatch;
	}
	// 825B0C44: 896B0090  lbz r11, 0x90(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B0C48: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B0C4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0C50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C54: 409A0008  bne cr6, 0x825b0c5c
	if !ctx.cr[6].eq {
	pc = 0x825B0C5C; continue 'dispatch;
	}
	pc = 0x825B0C58; continue 'dispatch;
            }
            0x825B0C58 => {
    //   block [0x825B0C58..0x825B0C5C)
	// 825B0C58: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B0C5C; continue 'dispatch;
            }
            0x825B0C5C => {
    //   block [0x825B0C5C..0x825B0C88)
	// 825B0C5C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C64: 419A004C  beq cr6, 0x825b0cb0
	if ctx.cr[6].eq {
	pc = 0x825B0CB0; continue 'dispatch;
	}
	// 825B0C68: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0C70: 419A002C  beq cr6, 0x825b0c9c
	if ctx.cr[6].eq {
	pc = 0x825B0C9C; continue 'dispatch;
	}
	// 825B0C74: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0C78: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0C7C: 419A0018  beq cr6, 0x825b0c94
	if ctx.cr[6].eq {
	pc = 0x825B0C94; continue 'dispatch;
	}
	// 825B0C80: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B0C84: 4800001C  b 0x825b0ca0
	pc = 0x825B0CA0; continue 'dispatch;
            }
            0x825B0C88 => {
    //   block [0x825B0C88..0x825B0C94)
	// 825B0C88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0C8C: 4BBE31AD  bl 0x82193e38
	ctx.lr = 0x825B0C90;
	sub_82193E38(ctx, base);
	// 825B0C90: 4BFFFFC8  b 0x825b0c58
	pc = 0x825B0C58; continue 'dispatch;
            }
            0x825B0C94 => {
    //   block [0x825B0C94..0x825B0C9C)
	// 825B0C94: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B0C98: 4BBE31A1  bl 0x82193e38
	ctx.lr = 0x825B0C9C;
	sub_82193E38(ctx, base);
	pc = 0x825B0C9C; continue 'dispatch;
            }
            0x825B0C9C => {
    //   block [0x825B0C9C..0x825B0CA0)
	// 825B0C9C: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B0CA0; continue 'dispatch;
            }
            0x825B0CA0 => {
    //   block [0x825B0CA0..0x825B0CB0)
	// 825B0CA0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B0CA4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0CA8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B0CAC: 48598AA5  bl 0x82b49750
	ctx.lr = 0x825B0CB0;
	sub_82B49750(ctx, base);
	pc = 0x825B0CB0; continue 'dispatch;
            }
            0x825B0CB0 => {
    //   block [0x825B0CB0..0x825B0CC0)
	// 825B0CB0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0CB4: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B0CB8: 409A0008  bne cr6, 0x825b0cc0
	if !ctx.cr[6].eq {
	pc = 0x825B0CC0; continue 'dispatch;
	}
	// 825B0CBC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B0CC0; continue 'dispatch;
            }
            0x825B0CC0 => {
    //   block [0x825B0CC0..0x825B0CC8)
	// 825B0CC0: 83DE0000  lwz r30, 0(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0CC4: 4BFFFF30  b 0x825b0bf4
	pc = 0x825B0BF4; continue 'dispatch;
            }
            0x825B0CC8 => {
    //   block [0x825B0CC8..0x825B0CD4)
	// 825B0CC8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B0CCC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B0CD0: 486F8784  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0CD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B0CD8 size=284
    let mut pc: u32 = 0x825B0CD8;
    'dispatch: loop {
        match pc {
            0x825B0CD8 => {
    //   block [0x825B0CD8..0x825B0D00)
	// 825B0CD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B0CDC: 486F871D  bl 0x82ca93f8
	ctx.lr = 0x825B0CE0;
	sub_82CA93D0(ctx, base);
	// 825B0CE0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B0CE4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B0CE8: 54B8063E  clrlwi r24, r5, 0x18
	ctx.r[24].u64 = ctx.r[5].u32 as u64 & 0x000000FFu64;
	// 825B0CEC: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825B0CF0: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B0CF4: 387A0090  addi r3, r26, 0x90
	ctx.r[3].s64 = ctx.r[26].s64 + 144;
	// 825B0CF8: 409A0008  bne cr6, 0x825b0d00
	if !ctx.cr[6].eq {
	pc = 0x825B0D00; continue 'dispatch;
	}
	// 825B0CFC: 387A0080  addi r3, r26, 0x80
	ctx.r[3].s64 = ctx.r[26].s64 + 128;
	pc = 0x825B0D00; continue 'dispatch;
            }
            0x825B0D00 => {
    //   block [0x825B0D00..0x825B0D30)
	// 825B0D00: 4BD69ED9  bl 0x8231abd8
	ctx.lr = 0x825B0D04;
	sub_8231ABD8(ctx, base);
	// 825B0D04: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B0D08: 4BEA76B9  bl 0x824583c0
	ctx.lr = 0x825B0D0C;
	sub_824583C0(ctx, base);
	// 825B0D0C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B0D10: 3BE00001  li r31, 1
	ctx.r[31].s64 = 1;
	// 825B0D14: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 825B0D18: 419800D4  blt cr6, 0x825b0dec
	if ctx.cr[6].lt {
	pc = 0x825B0DEC; continue 'dispatch;
	}
	// 825B0D1C: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B0D20: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B0D24: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825B0D28: 3BCA7088  addi r30, r10, 0x7088
	ctx.r[30].s64 = ctx.r[10].s64 + 28808;
	// 825B0D2C: 3BAB0CA0  addi r29, r11, 0xca0
	ctx.r[29].s64 = ctx.r[11].s64 + 3232;
	pc = 0x825B0D30; continue 'dispatch;
            }
            0x825B0D30 => {
    //   block [0x825B0D30..0x825B0D70)
	// 825B0D30: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B0D34: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825B0D38: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B0D3C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B0D40: 419A0054  beq cr6, 0x825b0d94
	if ctx.cr[6].eq {
	pc = 0x825B0D94; continue 'dispatch;
	}
	// 825B0D44: 48001D55  bl 0x825b2a98
	ctx.lr = 0x825B0D48;
	sub_825B2A98(ctx, base);
	// 825B0D48: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B0D4C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0D50: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0D54: 4BC7C17D  bl 0x8222ced0
	ctx.lr = 0x825B0D58;
	sub_8222CED0(ctx, base);
	// 825B0D58: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B0D5C: 387A0090  addi r3, r26, 0x90
	ctx.r[3].s64 = ctx.r[26].s64 + 144;
	// 825B0D60: 4BBC44F9  bl 0x82175258
	ctx.lr = 0x825B0D64;
	sub_82175258(ctx, base);
	// 825B0D64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B0D68: 4BC15A01  bl 0x821c6768
	ctx.lr = 0x825B0D6C;
	sub_821C6768(ctx, base);
	// 825B0D6C: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x825B0D70; continue 'dispatch;
            }
            0x825B0D70 => {
    //   block [0x825B0D70..0x825B0D94)
	// 825B0D70: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B0D74: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0D78: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B0D7C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0D80: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B0D84: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0D88: 4082FFE8  bne 0x825b0d70
	if !ctx.cr[0].eq {
	pc = 0x825B0D70; continue 'dispatch;
	}
	// 825B0D8C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B0D90: 48000050  b 0x825b0de0
	pc = 0x825B0DE0; continue 'dispatch;
            }
            0x825B0D94 => {
    //   block [0x825B0D94..0x825B0DC0)
	// 825B0D94: 48001D05  bl 0x825b2a98
	ctx.lr = 0x825B0D98;
	sub_825B2A98(ctx, base);
	// 825B0D98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B0D9C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B0DA0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B0DA4: 4BC7C12D  bl 0x8222ced0
	ctx.lr = 0x825B0DA8;
	sub_8222CED0(ctx, base);
	// 825B0DA8: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825B0DAC: 387A0080  addi r3, r26, 0x80
	ctx.r[3].s64 = ctx.r[26].s64 + 128;
	// 825B0DB0: 4BBC44A9  bl 0x82175258
	ctx.lr = 0x825B0DB4;
	sub_82175258(ctx, base);
	// 825B0DB4: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B0DB8: 4BC159B1  bl 0x821c6768
	ctx.lr = 0x825B0DBC;
	sub_821C6768(ctx, base);
	// 825B0DBC: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x825B0DC0; continue 'dispatch;
            }
            0x825B0DC0 => {
    //   block [0x825B0DC0..0x825B0DE0)
	// 825B0DC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B0DC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0DC8: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B0DCC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0DD0: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B0DD4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B0DD8: 4082FFE8  bne 0x825b0dc0
	if !ctx.cr[0].eq {
	pc = 0x825B0DC0; continue 'dispatch;
	}
	// 825B0DDC: 93810054  stw r28, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[28].u32 ) };
	pc = 0x825B0DE0; continue 'dispatch;
            }
            0x825B0DE0 => {
    //   block [0x825B0DE0..0x825B0DEC)
	// 825B0DE0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B0DE4: 7F1FC800  cmpw cr6, r31, r25
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[25].s32, &mut ctx.xer);
	// 825B0DE8: 4099FF48  ble cr6, 0x825b0d30
	if !ctx.cr[6].gt {
	pc = 0x825B0D30; continue 'dispatch;
	}
	pc = 0x825B0DEC; continue 'dispatch;
            }
            0x825B0DEC => {
    //   block [0x825B0DEC..0x825B0DF4)
	// 825B0DEC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B0DF0: 486F8658  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0DF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0DF8 size=8
    let mut pc: u32 = 0x825B0DF8;
    'dispatch: loop {
        match pc {
            0x825B0DF8 => {
    //   block [0x825B0DF8..0x825B0E00)
	// 825B0DF8: 806300A0  lwz r3, 0xa0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 825B0DFC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E00 size=8
    let mut pc: u32 = 0x825B0E00;
    'dispatch: loop {
        match pc {
            0x825B0E00 => {
    //   block [0x825B0E00..0x825B0E08)
	// 825B0E00: 806300A4  lwz r3, 0xa4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 825B0E04: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E08 size=20
    let mut pc: u32 = 0x825B0E08;
    'dispatch: loop {
        match pc {
            0x825B0E08 => {
    //   block [0x825B0E08..0x825B0E1C)
	// 825B0E08: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0E0C: 908300A0  stw r4, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[4].u32 ) };
	// 825B0E10: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0E14: 916300A4  stw r11, 0xa4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 825B0E18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0E20 size=312
    let mut pc: u32 = 0x825B0E20;
    'dispatch: loop {
        match pc {
            0x825B0E20 => {
    //   block [0x825B0E20..0x825B0E70)
	// 825B0E20: 908300A8  stw r4, 0xa8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), ctx.r[4].u32 ) };
	// 825B0E24: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825B0E28: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B0E2C: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0E30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0E34: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0E38: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825B0E3C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0E40: 419A00F8  beq cr6, 0x825b0f38
	if ctx.cr[6].eq {
	pc = 0x825B0F38; continue 'dispatch;
	}
	// 825B0E44: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0E48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0E4C: 419A0024  beq cr6, 0x825b0e70
	if ctx.cr[6].eq {
	pc = 0x825B0E70; continue 'dispatch;
	}
	// 825B0E50: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 825B0E54: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0E58: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0E5C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0E60: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0E64: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0E68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0E6C: 480000D0  b 0x825b0f3c
	pc = 0x825B0F3C; continue 'dispatch;
            }
            0x825B0E70 => {
    //   block [0x825B0E70..0x825B0E90)
	// 825B0E70: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0E74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B0E78: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0E7C: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 825B0E80: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0E84: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 825B0E88: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0E8C: 40810054  ble 0x825b0ee0
	if !ctx.cr[0].gt {
	pc = 0x825B0EE0; continue 'dispatch;
	}
	pc = 0x825B0E90; continue 'dispatch;
            }
            0x825B0E90 => {
    //   block [0x825B0E90..0x825B0EB0)
	// 825B0E90: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0E94: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B0E98: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0E9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0EA0: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 825B0EA4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B0EA8: 41980008  blt cr6, 0x825b0eb0
	if ctx.cr[6].lt {
	pc = 0x825B0EB0; continue 'dispatch;
	}
	// 825B0EAC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B0EB0; continue 'dispatch;
            }
            0x825B0EB0 => {
    //   block [0x825B0EB0..0x825B0ECC)
	// 825B0EB0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0EB4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0EB8: 419A0014  beq cr6, 0x825b0ecc
	if ctx.cr[6].eq {
	pc = 0x825B0ECC; continue 'dispatch;
	}
	// 825B0EBC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0EC0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0EC4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B0EC8: 4800000C  b 0x825b0ed4
	pc = 0x825B0ED4; continue 'dispatch;
            }
            0x825B0ECC => {
    //   block [0x825B0ECC..0x825B0ED4)
	// 825B0ECC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B0ED0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B0ED4; continue 'dispatch;
            }
            0x825B0ED4 => {
    //   block [0x825B0ED4..0x825B0EE0)
	// 825B0ED4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0ED8: 4199FFB8  bgt cr6, 0x825b0e90
	if ctx.cr[6].gt {
	pc = 0x825B0E90; continue 'dispatch;
	}
	// 825B0EDC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x825B0EE0; continue 'dispatch;
            }
            0x825B0EE0 => {
    //   block [0x825B0EE0..0x825B0EFC)
	// 825B0EE0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B0EE4: 419A0040  beq cr6, 0x825b0f24
	if ctx.cr[6].eq {
	pc = 0x825B0F24; continue 'dispatch;
	}
	// 825B0EE8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0EEC: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 825B0EF0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0EF4: 41990008  bgt cr6, 0x825b0efc
	if ctx.cr[6].gt {
	pc = 0x825B0EFC; continue 'dispatch;
	}
	// 825B0EF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B0EFC; continue 'dispatch;
            }
            0x825B0EFC => {
    //   block [0x825B0EFC..0x825B0F24)
	// 825B0EFC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0F00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0F04: 409A0020  bne cr6, 0x825b0f24
	if !ctx.cr[6].eq {
	pc = 0x825B0F24; continue 'dispatch;
	}
	// 825B0F08: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B0F0C: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825B0F10: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B0F14: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F18: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0F1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0F20: 4800001C  b 0x825b0f3c
	pc = 0x825B0F3C; continue 'dispatch;
            }
            0x825B0F24 => {
    //   block [0x825B0F24..0x825B0F38)
	// 825B0F24: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B0F28: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F2C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0F30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0F34: 48000008  b 0x825b0f3c
	pc = 0x825B0F3C; continue 'dispatch;
            }
            0x825B0F38 => {
    //   block [0x825B0F38..0x825B0F3C)
	// 825B0F38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B0F3C; continue 'dispatch;
            }
            0x825B0F3C => {
    //   block [0x825B0F3C..0x825B0F58)
	// 825B0F3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B0F40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B0F44: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B0F48: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B0F4C: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B0F50: 916A0110  stw r11, 0x110(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825B0F54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B0F58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B0F58 size=312
    let mut pc: u32 = 0x825B0F58;
    'dispatch: loop {
        match pc {
            0x825B0F58 => {
    //   block [0x825B0F58..0x825B0FA8)
	// 825B0F58: 908300AC  stw r4, 0xac(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 825B0F5C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825B0F60: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 825B0F64: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F68: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B0F6C: 812B0028  lwz r9, 0x28(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B0F70: 5528F7FE  rlwinm r8, r9, 0x1e, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000003u64;
	// 825B0F74: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B0F78: 419A00F8  beq cr6, 0x825b1070
	if ctx.cr[6].eq {
	pc = 0x825B1070; continue 'dispatch;
	}
	// 825B0F7C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B0F80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B0F84: 419A0024  beq cr6, 0x825b0fa8
	if ctx.cr[6].eq {
	pc = 0x825B0FA8; continue 'dispatch;
	}
	// 825B0F88: 894A0022  lbz r10, 0x22(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(34 as u32) ) } as u64;
	// 825B0F8C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0F90: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B0F94: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B0F98: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B0F9C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B0FA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B0FA4: 480000D0  b 0x825b1074
	pc = 0x825B1074; continue 'dispatch;
            }
            0x825B0FA8 => {
    //   block [0x825B0FA8..0x825B0FC8)
	// 825B0FA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B0FAC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B0FB0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B0FB4: 9121FFF0  stw r9, -0x10(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[9].u32 ) };
	// 825B0FB8: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B0FBC: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	// 825B0FC0: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B0FC4: 40810054  ble 0x825b1018
	if !ctx.cr[0].gt {
	pc = 0x825B1018; continue 'dispatch;
	}
	pc = 0x825B0FC8; continue 'dispatch;
            }
            0x825B0FC8 => {
    //   block [0x825B0FC8..0x825B0FE8)
	// 825B0FC8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B0FCC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B0FD0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B0FD4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B0FD8: 2F070022  cmpwi cr6, r7, 0x22
	ctx.cr[6].compare_i32(ctx.r[7].s32, 34, &mut ctx.xer);
	// 825B0FDC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B0FE0: 41980008  blt cr6, 0x825b0fe8
	if ctx.cr[6].lt {
	pc = 0x825B0FE8; continue 'dispatch;
	}
	// 825B0FE4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B0FE8; continue 'dispatch;
            }
            0x825B0FE8 => {
    //   block [0x825B0FE8..0x825B1004)
	// 825B0FE8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B0FEC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B0FF0: 419A0014  beq cr6, 0x825b1004
	if ctx.cr[6].eq {
	pc = 0x825B1004; continue 'dispatch;
	}
	// 825B0FF4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B0FF8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B0FFC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B1000: 4800000C  b 0x825b100c
	pc = 0x825B100C; continue 'dispatch;
            }
            0x825B1004 => {
    //   block [0x825B1004..0x825B100C)
	// 825B1004: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B1008: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B100C; continue 'dispatch;
            }
            0x825B100C => {
    //   block [0x825B100C..0x825B1018)
	// 825B100C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B1010: 4199FFB8  bgt cr6, 0x825b0fc8
	if ctx.cr[6].gt {
	pc = 0x825B0FC8; continue 'dispatch;
	}
	// 825B1014: 9141FFF4  stw r10, -0xc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), ctx.r[10].u32 ) };
	pc = 0x825B1018; continue 'dispatch;
            }
            0x825B1018 => {
    //   block [0x825B1018..0x825B1034)
	// 825B1018: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B101C: 419A0040  beq cr6, 0x825b105c
	if ctx.cr[6].eq {
	pc = 0x825B105C; continue 'dispatch;
	}
	// 825B1020: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1024: 2F0B0022  cmpwi cr6, r11, 0x22
	ctx.cr[6].compare_i32(ctx.r[11].s32, 34, &mut ctx.xer);
	// 825B1028: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B102C: 41990008  bgt cr6, 0x825b1034
	if ctx.cr[6].gt {
	pc = 0x825B1034; continue 'dispatch;
	}
	// 825B1030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B1034; continue 'dispatch;
            }
            0x825B1034 => {
    //   block [0x825B1034..0x825B105C)
	// 825B1034: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B1038: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B103C: 409A0020  bne cr6, 0x825b105c
	if !ctx.cr[6].eq {
	pc = 0x825B105C; continue 'dispatch;
	}
	// 825B1040: E961FFF0  ld r11, -0x10(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B1044: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 825B1048: 8161FFF4  lwz r11, -0xc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825B104C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1050: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B1054: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B1058: 4800001C  b 0x825b1074
	pc = 0x825B1074; continue 'dispatch;
            }
            0x825B105C => {
    //   block [0x825B105C..0x825B1070)
	// 825B105C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B1060: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1064: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B1068: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B106C: 48000008  b 0x825b1074
	pc = 0x825B1074; continue 'dispatch;
            }
            0x825B1070 => {
    //   block [0x825B1070..0x825B1074)
	// 825B1070: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B1074; continue 'dispatch;
            }
            0x825B1074 => {
    //   block [0x825B1074..0x825B1090)
	// 825B1074: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B1078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B107C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825B1080: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B1084: 816B9650  lwz r11, -0x69b0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27056 as u32) ) } as u64;
	// 825B1088: 916A0110  stw r11, 0x110(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(272 as u32), ctx.r[11].u32 ) };
	// 825B108C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1090(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B1090 size=708
    let mut pc: u32 = 0x825B1090;
    'dispatch: loop {
        match pc {
            0x825B1090 => {
    //   block [0x825B1090..0x825B10F8)
	// 825B1090: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1094: 486F8379  bl 0x82ca940c
	ctx.lr = 0x825B1098;
	sub_82CA93D0(ctx, base);
	// 825B1098: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B109C: 896300B0  lbz r11, 0xb0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 825B10A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B10A4: 409A02A4  bne cr6, 0x825b1348
	if !ctx.cr[6].eq {
	pc = 0x825B1348; continue 'dispatch;
	}
	// 825B10A8: 80A300A8  lwz r5, 0xa8(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) } as u64;
	// 825B10AC: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825B10B0: 419A0298  beq cr6, 0x825b1348
	if ctx.cr[6].eq {
	pc = 0x825B1348; continue 'dispatch;
	}
	// 825B10B4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B10B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B10BC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825B10C0: 814B0028  lwz r10, 0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B10C4: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 825B10C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B10CC: 419A00E8  beq cr6, 0x825b11b4
	if ctx.cr[6].eq {
	pc = 0x825B11B4; continue 'dispatch;
	}
	// 825B10D0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B10D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B10D8: 419A0020  beq cr6, 0x825b10f8
	if ctx.cr[6].eq {
	pc = 0x825B10F8; continue 'dispatch;
	}
	// 825B10DC: 894A0031  lbz r10, 0x31(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(49 as u32) ) } as u64;
	// 825B10E0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B10E4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B10E8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B10EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B10F0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B10F4: 480000C4  b 0x825b11b8
	pc = 0x825B11B8; continue 'dispatch;
            }
            0x825B10F8 => {
    //   block [0x825B10F8..0x825B1114)
	// 825B10F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B10FC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B1100: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B1104: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B1108: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B110C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B1110: 40810054  ble 0x825b1164
	if !ctx.cr[0].gt {
	pc = 0x825B1164; continue 'dispatch;
	}
	pc = 0x825B1114; continue 'dispatch;
            }
            0x825B1114 => {
    //   block [0x825B1114..0x825B1134)
	// 825B1114: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B1118: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B111C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B1120: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1124: 2F070031  cmpwi cr6, r7, 0x31
	ctx.cr[6].compare_i32(ctx.r[7].s32, 49, &mut ctx.xer);
	// 825B1128: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B112C: 41980008  blt cr6, 0x825b1134
	if ctx.cr[6].lt {
	pc = 0x825B1134; continue 'dispatch;
	}
	// 825B1130: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x825B1134; continue 'dispatch;
            }
            0x825B1134 => {
    //   block [0x825B1134..0x825B1150)
	// 825B1134: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B1138: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B113C: 419A0014  beq cr6, 0x825b1150
	if ctx.cr[6].eq {
	pc = 0x825B1150; continue 'dispatch;
	}
	// 825B1140: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B1144: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B1148: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B114C: 4800000C  b 0x825b1158
	pc = 0x825B1158; continue 'dispatch;
            }
            0x825B1150 => {
    //   block [0x825B1150..0x825B1158)
	// 825B1150: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B1154: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B1158; continue 'dispatch;
            }
            0x825B1158 => {
    //   block [0x825B1158..0x825B1164)
	// 825B1158: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B115C: 4199FFB8  bgt cr6, 0x825b1114
	if ctx.cr[6].gt {
	pc = 0x825B1114; continue 'dispatch;
	}
	// 825B1160: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B1164; continue 'dispatch;
            }
            0x825B1164 => {
    //   block [0x825B1164..0x825B1180)
	// 825B1164: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B1168: 419A003C  beq cr6, 0x825b11a4
	if ctx.cr[6].eq {
	pc = 0x825B11A4; continue 'dispatch;
	}
	// 825B116C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1170: 2F0B0031  cmpwi cr6, r11, 0x31
	ctx.cr[6].compare_i32(ctx.r[11].s32, 49, &mut ctx.xer);
	// 825B1174: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B1178: 41990008  bgt cr6, 0x825b1180
	if ctx.cr[6].gt {
	pc = 0x825B1180; continue 'dispatch;
	}
	// 825B117C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B1180; continue 'dispatch;
            }
            0x825B1180 => {
    //   block [0x825B1180..0x825B11A4)
	// 825B1180: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B1184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1188: 409A001C  bne cr6, 0x825b11a4
	if !ctx.cr[6].eq {
	pc = 0x825B11A4; continue 'dispatch;
	}
	// 825B118C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B1190: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B1194: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B1198: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B119C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B11A0: 48000018  b 0x825b11b8
	pc = 0x825B11B8; continue 'dispatch;
            }
            0x825B11A4 => {
    //   block [0x825B11A4..0x825B11B4)
	// 825B11A4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B11A8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B11AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B11B0: 48000008  b 0x825b11b8
	pc = 0x825B11B8; continue 'dispatch;
            }
            0x825B11B4 => {
    //   block [0x825B11B4..0x825B11B8)
	// 825B11B4: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B11B8; continue 'dispatch;
            }
            0x825B11B8 => {
    //   block [0x825B11B8..0x825B11E0)
	// 825B11B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B11BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B11C0: 419A0188  beq cr6, 0x825b1348
	if ctx.cr[6].eq {
	pc = 0x825B1348; continue 'dispatch;
	}
	// 825B11C4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B11C8: 419A0018  beq cr6, 0x825b11e0
	if ctx.cr[6].eq {
	pc = 0x825B11E0; continue 'dispatch;
	}
	// 825B11CC: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B11D0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B11D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B11D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B11DC: 409A0008  bne cr6, 0x825b11e4
	if !ctx.cr[6].eq {
	pc = 0x825B11E4; continue 'dispatch;
	}
	pc = 0x825B11E0; continue 'dispatch;
            }
            0x825B11E0 => {
    //   block [0x825B11E0..0x825B11E4)
	// 825B11E0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B11E4; continue 'dispatch;
            }
            0x825B11E4 => {
    //   block [0x825B11E4..0x825B12A0)
	// 825B11E4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B11E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B11EC: 419A015C  beq cr6, 0x825b1348
	if ctx.cr[6].eq {
	pc = 0x825B1348; continue 'dispatch;
	}
	// 825B11F0: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B11F4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B11F8: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B11FC: 392B0B7C  addi r9, r11, 0xb7c
	ctx.r[9].s64 = ctx.r[11].s64 + 2940;
	// 825B1200: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B1204: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825B1208: 2F050005  cmpwi cr6, r5, 5
	ctx.cr[6].compare_i32(ctx.r[5].s32, 5, &mut ctx.xer);
	// 825B120C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B1210: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B1214: 409A008C  bne cr6, 0x825b12a0
	if !ctx.cr[6].eq {
	pc = 0x825B12A0; continue 'dispatch;
	}
	// 825B1218: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B121C: 48168BCD  bl 0x82719de8
	ctx.lr = 0x825B1220;
	sub_82719DE8(ctx, base);
	// 825B1220: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 825B1224: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825B1228: 390A1F30  addi r8, r10, 0x1f30
	ctx.r[8].s64 = ctx.r[10].s64 + 7984;
	// 825B122C: 992100EC  stb r9, 0xec(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(236 as u32), ctx.r[9].u8 ) };
	// 825B1230: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825B1234: 91010080  stw r8, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 825B1238: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 825B123C: 80FF0000  lwz r7, 0(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1240: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B1244: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B1248: 81670040  lwz r11, 0x40(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B124C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1250: 4E800421  bctrl
	ctx.lr = 0x825B1254;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1254: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B1258: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B125C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1260: 4BF20C69  bl 0x824d1ec8
	ctx.lr = 0x825B1264;
	sub_824D1EC8(ctx, base);
	// 825B1264: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B1268: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B126C: 3BEB0B7C  addi r31, r11, 0xb7c
	ctx.r[31].s64 = ctx.r[11].s64 + 2940;
	// 825B1270: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1274: 93E10070  stw r31, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[31].u32 ) };
	// 825B1278: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825B127C: 4BBE2BBD  bl 0x82193e38
	ctx.lr = 0x825B1280;
	sub_82193E38(ctx, base);
	// 825B1280: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 825B1284: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 825B1288: 4BC06891  bl 0x821b7b18
	ctx.lr = 0x825B128C;
	sub_821B7B18(ctx, base);
	// 825B128C: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 825B1290: 4BC63B49  bl 0x82214dd8
	ctx.lr = 0x825B1294;
	sub_82214DD8(ctx, base);
	// 825B1294: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B1298: 4BBFB899  bl 0x821acb30
	ctx.lr = 0x825B129C;
	sub_821ACB30(ctx, base);
	// 825B129C: 48000064  b 0x825b1300
	pc = 0x825B1300; continue 'dispatch;
            }
            0x825B12A0 => {
    //   block [0x825B12A0..0x825B1300)
	// 825B12A0: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825B12A4: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B12A8: 4815BD91  bl 0x8270d038
	ctx.lr = 0x825B12AC;
	sub_8270D038(ctx, base);
	// 825B12AC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B12B0: 815E0040  lwz r10, 0x40(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B12B4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B12B8: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B12BC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825B12C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B12C4: 4E800421  bctrl
	ctx.lr = 0x825B12C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B12C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B12CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B12D0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B12D4: 4BF20BF5  bl 0x824d1ec8
	ctx.lr = 0x825B12D8;
	sub_824D1EC8(ctx, base);
	// 825B12D8: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B12DC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B12E0: 3BEB0B7C  addi r31, r11, 0xb7c
	ctx.r[31].s64 = ctx.r[11].s64 + 2940;
	// 825B12E4: 83DE0008  lwz r30, 8(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B12E8: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 825B12EC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825B12F0: 4BBE2B49  bl 0x82193e38
	ctx.lr = 0x825B12F4;
	sub_82193E38(ctx, base);
	// 825B12F4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825B12F8: 38610100  addi r3, r1, 0x100
	ctx.r[3].s64 = ctx.r[1].s64 + 256;
	// 825B12FC: 4BDE038D  bl 0x82391688
	ctx.lr = 0x825B1300;
	sub_82391688(ctx, base);
            }
            0x825B1300 => {
    //   block [0x825B1300..0x825B131C)
	// 825B1300: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825B1304: 41980018  blt cr6, 0x825b131c
	if ctx.cr[6].lt {
	pc = 0x825B131C; continue 'dispatch;
	}
	// 825B1308: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B130C: 4BCE742D  bl 0x82298738
	ctx.lr = 0x825B1310;
	sub_82298738(ctx, base);
	// 825B1310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B1314: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B1318: 409A0008  bne cr6, 0x825b1320
	if !ctx.cr[6].eq {
	pc = 0x825B1320; continue 'dispatch;
	}
	pc = 0x825B131C; continue 'dispatch;
            }
            0x825B131C => {
    //   block [0x825B131C..0x825B1320)
	// 825B131C: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B1320; continue 'dispatch;
            }
            0x825B1320 => {
    //   block [0x825B1320..0x825B1344)
	// 825B1320: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B1324: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B1328: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B132C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1330: 419A0014  beq cr6, 0x825b1344
	if ctx.cr[6].eq {
	pc = 0x825B1344; continue 'dispatch;
	}
	// 825B1334: 4BBE2B05  bl 0x82193e38
	ctx.lr = 0x825B1338;
	sub_82193E38(ctx, base);
	// 825B1338: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B133C: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 825B1340: 486F811C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B1344 => {
    //   block [0x825B1344..0x825B1348)
	// 825B1344: 4BBE2AF5  bl 0x82193e38
	ctx.lr = 0x825B1348;
	sub_82193E38(ctx, base);
	pc = 0x825B1348; continue 'dispatch;
            }
            0x825B1348 => {
    //   block [0x825B1348..0x825B1354)
	// 825B1348: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B134C: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 825B1350: 486F810C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1358 size=392
    let mut pc: u32 = 0x825B1358;
    'dispatch: loop {
        match pc {
            0x825B1358 => {
    //   block [0x825B1358..0x825B13AC)
	// 825B1358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B135C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B1360: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B1364: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1368: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B136C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B1370: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1374: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B1378: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 825B137C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B1380: 419A00EC  beq cr6, 0x825b146c
	if ctx.cr[6].eq {
	pc = 0x825B146C; continue 'dispatch;
	}
	// 825B1384: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B1388: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B138C: 419A0020  beq cr6, 0x825b13ac
	if ctx.cr[6].eq {
	pc = 0x825B13AC; continue 'dispatch;
	}
	// 825B1390: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 825B1394: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B1398: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B139C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B13A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B13A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B13A8: 480000C8  b 0x825b1470
	pc = 0x825B1470; continue 'dispatch;
            }
            0x825B13AC => {
    //   block [0x825B13AC..0x825B13CC)
	// 825B13AC: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B13B0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B13B4: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B13B8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B13BC: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B13C0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B13C4: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B13C8: 40810054  ble 0x825b141c
	if !ctx.cr[0].gt {
	pc = 0x825B141C; continue 'dispatch;
	}
	pc = 0x825B13CC; continue 'dispatch;
            }
            0x825B13CC => {
    //   block [0x825B13CC..0x825B13EC)
	// 825B13CC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B13D0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B13D4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B13D8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B13DC: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 825B13E0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B13E4: 41980008  blt cr6, 0x825b13ec
	if ctx.cr[6].lt {
	pc = 0x825B13EC; continue 'dispatch;
	}
	// 825B13E8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B13EC; continue 'dispatch;
            }
            0x825B13EC => {
    //   block [0x825B13EC..0x825B1408)
	// 825B13EC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B13F0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B13F4: 419A0014  beq cr6, 0x825b1408
	if ctx.cr[6].eq {
	pc = 0x825B1408; continue 'dispatch;
	}
	// 825B13F8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B13FC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B1400: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B1404: 4800000C  b 0x825b1410
	pc = 0x825B1410; continue 'dispatch;
            }
            0x825B1408 => {
    //   block [0x825B1408..0x825B1410)
	// 825B1408: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B140C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B1410; continue 'dispatch;
            }
            0x825B1410 => {
    //   block [0x825B1410..0x825B141C)
	// 825B1410: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B1414: 4199FFB8  bgt cr6, 0x825b13cc
	if ctx.cr[6].gt {
	pc = 0x825B13CC; continue 'dispatch;
	}
	// 825B1418: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B141C; continue 'dispatch;
            }
            0x825B141C => {
    //   block [0x825B141C..0x825B1438)
	// 825B141C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B1420: 419A003C  beq cr6, 0x825b145c
	if ctx.cr[6].eq {
	pc = 0x825B145C; continue 'dispatch;
	}
	// 825B1424: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1428: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 825B142C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B1430: 41990008  bgt cr6, 0x825b1438
	if ctx.cr[6].gt {
	pc = 0x825B1438; continue 'dispatch;
	}
	// 825B1434: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B1438; continue 'dispatch;
            }
            0x825B1438 => {
    //   block [0x825B1438..0x825B145C)
	// 825B1438: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B143C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1440: 409A001C  bne cr6, 0x825b145c
	if !ctx.cr[6].eq {
	pc = 0x825B145C; continue 'dispatch;
	}
	// 825B1444: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B1448: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B144C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B1450: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B1454: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1458: 48000018  b 0x825b1470
	pc = 0x825B1470; continue 'dispatch;
            }
            0x825B145C => {
    //   block [0x825B145C..0x825B146C)
	// 825B145C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B1460: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B1464: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1468: 48000008  b 0x825b1470
	pc = 0x825B1470; continue 'dispatch;
            }
            0x825B146C => {
    //   block [0x825B146C..0x825B1470)
	// 825B146C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B1470; continue 'dispatch;
            }
            0x825B1470 => {
    //   block [0x825B1470..0x825B14CC)
	// 825B1470: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B1474: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B1478: 419A0054  beq cr6, 0x825b14cc
	if ctx.cr[6].eq {
	pc = 0x825B14CC; continue 'dispatch;
	}
	// 825B147C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B1480: 4BC63679  bl 0x82214af8
	ctx.lr = 0x825B1484;
	sub_82214AF8(ctx, base);
	// 825B1484: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B1488: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B148C: 419A0040  beq cr6, 0x825b14cc
	if ctx.cr[6].eq {
	pc = 0x825B14CC; continue 'dispatch;
	}
	// 825B1490: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B1494: 81440060  lwz r10, 0x60(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B1498: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B149C: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825B14A0: 38E95C94  addi r7, r9, 0x5c94
	ctx.r[7].s64 = ctx.r[9].s64 + 23700;
	// 825B14A4: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B14A8: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 825B14AC: 90E10050  stw r7, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u32 ) };
	// 825B14B0: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B14B4: 83E6008C  lwz r31, 0x8c(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B14B8: 4BC00ED9  bl 0x821b2390
	ctx.lr = 0x825B14BC;
	sub_821B2390(ctx, base);
	// 825B14BC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B14C0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B14C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B14C8: 48001691  bl 0x825b2b58
	ctx.lr = 0x825B14CC;
	sub_825B2B58(ctx, base);
	pc = 0x825B14CC; continue 'dispatch;
            }
            0x825B14CC => {
    //   block [0x825B14CC..0x825B14E0)
	// 825B14CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B14D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B14D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B14D8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B14DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B14E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B14E0 size=220
    let mut pc: u32 = 0x825B14E0;
    'dispatch: loop {
        match pc {
            0x825B14E0 => {
    //   block [0x825B14E0..0x825B150C)
	// 825B14E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B14E4: 486F7F1D  bl 0x82ca9400
	ctx.lr = 0x825B14E8;
	sub_82CA93D0(ctx, base);
	// 825B14E8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B14EC: F8A100B0  std r5, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[5].u64 ) };
	// 825B14F0: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B14F4: 816100B0  lwz r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 825B14F8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B14FC: F8A10050  std r5, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[5].u64 ) };
	// 825B1500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1504: 409A0008  bne cr6, 0x825b150c
	if !ctx.cr[6].eq {
	pc = 0x825B150C; continue 'dispatch;
	}
	// 825B1508: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B150C; continue 'dispatch;
            }
            0x825B150C => {
    //   block [0x825B150C..0x825B1520)
	// 825B150C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1510: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B1514: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B1518: 409A0008  bne cr6, 0x825b1520
	if !ctx.cr[6].eq {
	pc = 0x825B1520; continue 'dispatch;
	}
	// 825B151C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B1520; continue 'dispatch;
            }
            0x825B1520 => {
    //   block [0x825B1520..0x825B15A8)
	// 825B1520: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1524: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B1528: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B152C: 7F1F5040  cmplw cr6, r31, r10
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B1530: 916100B4  stw r11, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 825B1534: 419A0074  beq cr6, 0x825b15a8
	if ctx.cr[6].eq {
	pc = 0x825B15A8; continue 'dispatch;
	}
	// 825B1538: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B153C: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B1540: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1544: 3BBF0008  addi r29, r31, 8
	ctx.r[29].s64 = ctx.r[31].s64 + 8;
	// 825B1548: 3B4A0B7C  addi r26, r10, 0xb7c
	ctx.r[26].s64 = ctx.r[10].s64 + 2940;
	// 825B154C: 387D0008  addi r3, r29, 8
	ctx.r[3].s64 = ctx.r[29].s64 + 8;
	// 825B1550: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B1554: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1558: 80FF0004  lwz r7, 4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B155C: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825B1560: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 825B1564: 4BBE28D5  bl 0x82193e38
	ctx.lr = 0x825B1568;
	sub_82193E38(ctx, base);
	// 825B1568: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B156C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B1570: 937F0014  stw r27, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 825B1574: 935F0008  stw r26, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825B1578: 4BBE28C1  bl 0x82193e38
	ctx.lr = 0x825B157C;
	sub_82193E38(ctx, base);
	// 825B157C: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 825B1580: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B1584: 4BC6A7B5  bl 0x8221bd38
	ctx.lr = 0x825B1588;
	sub_8221BD38(ctx, base);
	// 825B1588: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B158C: E8C100B0  ld r6, 0xb0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 825B1590: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B1594: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 825B1598: 90BE0008  stw r5, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825B159C: F8DC0000  std r6, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 825B15A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B15A4: 486F7EAC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B15A8 => {
    //   block [0x825B15A8..0x825B15BC)
	// 825B15A8: E96100B0  ld r11, 0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) };
	// 825B15AC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B15B0: F97C0000  std r11, 0(r28)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825B15B4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B15B8: 486F7E98  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B15C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B15C0 size=584
    let mut pc: u32 = 0x825B15C0;
    'dispatch: loop {
        match pc {
            0x825B15C0 => {
    //   block [0x825B15C0..0x825B15E8)
	// 825B15C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B15C4: 486F7E3D  bl 0x82ca9400
	ctx.lr = 0x825B15C8;
	sub_82CA93D0(ctx, base);
	// 825B15C8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B15CC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B15D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B15D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B15D8: 409A0010  bne cr6, 0x825b15e8
	if !ctx.cr[6].eq {
	pc = 0x825B15E8; continue 'dispatch;
	}
	// 825B15DC: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825B15E0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 825B15E4: 48000008  b 0x825b15ec
	pc = 0x825B15EC; continue 'dispatch;
            }
            0x825B15E8 => {
    //   block [0x825B15E8..0x825B15EC)
	// 825B15E8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B15EC; continue 'dispatch;
            }
            0x825B15EC => {
    //   block [0x825B15EC..0x825B1664)
	// 825B15EC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B15F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B15F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B15F8: 4BE1CFC9  bl 0x823ce5c0
	ctx.lr = 0x825B15FC;
	sub_823CE5C0(ctx, base);
	// 825B15FC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B1600: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B1604: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1608: 4BE1CBF9  bl 0x823ce200
	ctx.lr = 0x825B160C;
	sub_823CE200(ctx, base);
	// 825B160C: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1610: 4BC06509  bl 0x821b7b18
	ctx.lr = 0x825B1614;
	sub_821B7B18(ctx, base);
	// 825B1614: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825B1618: 4BC6DC41  bl 0x8221f258
	ctx.lr = 0x825B161C;
	sub_8221F258(ctx, base);
	// 825B161C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B1620: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1624: 419A0040  beq cr6, 0x825b1664
	if ctx.cr[6].eq {
	pc = 0x825B1664; continue 'dispatch;
	}
	// 825B1628: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 825B162C: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B1630: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 825B1634: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B1638: 4BC6DC21  bl 0x8221f258
	ctx.lr = 0x825B163C;
	sub_8221F258(ctx, base);
	// 825B163C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B1640: 419A0028  beq cr6, 0x825b1668
	if ctx.cr[6].eq {
	pc = 0x825B1668; continue 'dispatch;
	}
	// 825B1644: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B1648: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825B164C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B1650: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B1654: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B1658: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B165C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1660: 4800000C  b 0x825b166c
	pc = 0x825B166C; continue 'dispatch;
            }
            0x825B1664 => {
    //   block [0x825B1664..0x825B1668)
	// 825B1664: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B1668; continue 'dispatch;
            }
            0x825B1668 => {
    //   block [0x825B1668..0x825B166C)
	// 825B1668: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B166C; continue 'dispatch;
            }
            0x825B166C => {
    //   block [0x825B166C..0x825B1770)
	// 825B166C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B1670: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B1674: 419A00FC  beq cr6, 0x825b1770
	if ctx.cr[6].eq {
	pc = 0x825B1770; continue 'dispatch;
	}
	// 825B1678: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B167C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B1680: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1684: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B1688: 4BC77A81  bl 0x82229108
	ctx.lr = 0x825B168C;
	sub_82229108(ctx, base);
	// 825B168C: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B1690: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1694: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B1698: 3BCB2C48  addi r30, r11, 0x2c48
	ctx.r[30].s64 = ctx.r[11].s64 + 11336;
	// 825B169C: 4BC761E5  bl 0x82227880
	ctx.lr = 0x825B16A0;
	sub_82227880(ctx, base);
	// 825B16A0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B16A4: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 825B16A8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B16AC: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 825B16B0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B16B4: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825B16B8: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B16BC: 4BBE93C5  bl 0x8219aa80
	ctx.lr = 0x825B16C0;
	sub_8219AA80(ctx, base);
	// 825B16C0: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825B16C4: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B16C8: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 825B16CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B16D0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B16D4: 4BE1CD4D  bl 0x823ce420
	ctx.lr = 0x825B16D8;
	sub_823CE420(ctx, base);
	// 825B16D8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B16DC: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B16E0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B16E4: 48472FE5  bl 0x82a246c8
	ctx.lr = 0x825B16E8;
	sub_82A246C8(ctx, base);
	// 825B16E8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B16EC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B16F0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825B16F4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B16F8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B16FC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1700: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1704: 4BC77A05  bl 0x82229108
	ctx.lr = 0x825B1708;
	sub_82229108(ctx, base);
	// 825B1708: 3D608232  lis r11, -0x7dce
	ctx.r[11].s64 = -2110652416;
	// 825B170C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1710: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1714: 3BEB6B90  addi r31, r11, 0x6b90
	ctx.r[31].s64 = ctx.r[11].s64 + 27536;
	// 825B1718: 4BC76169  bl 0x82227880
	ctx.lr = 0x825B171C;
	sub_82227880(ctx, base);
	// 825B171C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825B1720: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 825B1724: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1728: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 825B172C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1730: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825B1734: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B1738: 4BBE9349  bl 0x8219aa80
	ctx.lr = 0x825B173C;
	sub_8219AA80(ctx, base);
	// 825B173C: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 825B1740: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1744: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 825B1748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B174C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1750: 4BE1CCD1  bl 0x823ce420
	ctx.lr = 0x825B1754;
	sub_823CE420(ctx, base);
	// 825B1754: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1758: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B175C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B1760: 48472F69  bl 0x82a246c8
	ctx.lr = 0x825B1764;
	sub_82A246C8(ctx, base);
	// 825B1764: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1768: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 825B176C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x825B1770; continue 'dispatch;
            }
            0x825B1770 => {
    //   block [0x825B1770..0x825B1780)
	// 825B1770: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B1774: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825B1778: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825B177C: 419A0020  beq cr6, 0x825b179c
	if ctx.cr[6].eq {
	pc = 0x825B179C; continue 'dispatch;
	}
	pc = 0x825B1780; continue 'dispatch;
            }
            0x825B1780 => {
    //   block [0x825B1780..0x825B179C)
	// 825B1780: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1784: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1788: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B178C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B1790: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1794: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1798: 4082FFE8  bne 0x825b1780
	if !ctx.cr[0].eq {
	pc = 0x825B1780; continue 'dispatch;
	}
	pc = 0x825B179C; continue 'dispatch;
            }
            0x825B179C => {
    //   block [0x825B179C..0x825B17BC)
	// 825B179C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B17A0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825B17A4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B17A8: 4BD441A1  bl 0x822f5948
	ctx.lr = 0x825B17AC;
	sub_822F5948(ctx, base);
	// 825B17AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B17B0: 4BC06369  bl 0x821b7b18
	ctx.lr = 0x825B17B4;
	sub_821B7B18(ctx, base);
	// 825B17B4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825B17B8: 419A0040  beq cr6, 0x825b17f8
	if ctx.cr[6].eq {
	pc = 0x825B17F8; continue 'dispatch;
	}
	pc = 0x825B17BC; continue 'dispatch;
            }
            0x825B17BC => {
    //   block [0x825B17BC..0x825B17F8)
	// 825B17BC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B17C0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B17C4: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B17C8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B17CC: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B17D0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B17D4: 4082FFE8  bne 0x825b17bc
	if !ctx.cr[0].eq {
	pc = 0x825B17BC; continue 'dispatch;
	}
	// 825B17D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B17DC: 409A001C  bne cr6, 0x825b17f8
	if !ctx.cr[6].eq {
	pc = 0x825B17F8; continue 'dispatch;
	}
	// 825B17E0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B17E4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B17E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B17EC: 4E800421  bctrl
	ctx.lr = 0x825B17F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B17F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B17F4: 4BC6A545  bl 0x8221bd38
	ctx.lr = 0x825B17F8;
	sub_8221BD38(ctx, base);
            }
            0x825B17F8 => {
    //   block [0x825B17F8..0x825B1808)
	// 825B17F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B17FC: 4BC0631D  bl 0x821b7b18
	ctx.lr = 0x825B1800;
	sub_821B7B18(ctx, base);
	// 825B1800: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B1804: 486F7C4C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1808 size=528
    let mut pc: u32 = 0x825B1808;
    'dispatch: loop {
        match pc {
            0x825B1808 => {
    //   block [0x825B1808..0x825B1840)
	// 825B1808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B180C: 486F7BF1  bl 0x82ca93fc
	ctx.lr = 0x825B1810;
	sub_82CA93D0(ctx, base);
	// 825B1810: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1814: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1818: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B181C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B1820: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B1824: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B1828: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B182C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B1830: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1834: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1838: 419A0008  beq cr6, 0x825b1840
	if ctx.cr[6].eq {
	pc = 0x825B1840; continue 'dispatch;
	}
	// 825B183C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1840; continue 'dispatch;
            }
            0x825B1840 => {
    //   block [0x825B1840..0x825B18E4)
	// 825B1840: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1848: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B184C: 4BE1CD75  bl 0x823ce5c0
	ctx.lr = 0x825B1850;
	sub_823CE5C0(ctx, base);
	// 825B1850: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B1854: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1858: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B185C: 4BE1C8B5  bl 0x823ce110
	ctx.lr = 0x825B1860;
	sub_823CE110(ctx, base);
	// 825B1860: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1864: 4BC062B5  bl 0x821b7b18
	ctx.lr = 0x825B1868;
	sub_821B7B18(ctx, base);
	// 825B1868: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B186C: 4BC6D9ED  bl 0x8221f258
	ctx.lr = 0x825B1870;
	sub_8221F258(ctx, base);
	// 825B1870: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B1874: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B1878: 419A006C  beq cr6, 0x825b18e4
	if ctx.cr[6].eq {
	pc = 0x825B18E4; continue 'dispatch;
	}
	// 825B187C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B1880: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B1884: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B1888: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B188C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B1890: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B1894: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B1898: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B189C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B18A0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B18A4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B18A8: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B18AC: 4BC3E995  bl 0x821f0240
	ctx.lr = 0x825B18B0;
	sub_821F0240(ctx, base);
	// 825B18B0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B18B4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B18B8: 4BC6D9A1  bl 0x8221f258
	ctx.lr = 0x825B18BC;
	sub_8221F258(ctx, base);
	// 825B18BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B18C0: 419A0028  beq cr6, 0x825b18e8
	if ctx.cr[6].eq {
	pc = 0x825B18E8; continue 'dispatch;
	}
	// 825B18C4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B18C8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B18CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B18D0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B18D4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B18D8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B18DC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B18E0: 4800000C  b 0x825b18ec
	pc = 0x825B18EC; continue 'dispatch;
            }
            0x825B18E4 => {
    //   block [0x825B18E4..0x825B18E8)
	// 825B18E4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B18E8; continue 'dispatch;
            }
            0x825B18E8 => {
    //   block [0x825B18E8..0x825B18EC)
	// 825B18E8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B18EC; continue 'dispatch;
            }
            0x825B18EC => {
    //   block [0x825B18EC..0x825B1900)
	// 825B18EC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B18F0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B18F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B18F8: 419A0008  beq cr6, 0x825b1900
	if ctx.cr[6].eq {
	pc = 0x825B1900; continue 'dispatch;
	}
	// 825B18FC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1900; continue 'dispatch;
            }
            0x825B1900 => {
    //   block [0x825B1900..0x825B1980)
	// 825B1900: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B1904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1908: 419A0078  beq cr6, 0x825b1980
	if ctx.cr[6].eq {
	pc = 0x825B1980; continue 'dispatch;
	}
	// 825B190C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1910: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B1914: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1918: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B191C: 4BC777ED  bl 0x82229108
	ctx.lr = 0x825B1920;
	sub_82229108(ctx, base);
	// 825B1920: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B1924: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1928: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B192C: 3BCB3418  addi r30, r11, 0x3418
	ctx.r[30].s64 = ctx.r[11].s64 + 13336;
	// 825B1930: 4BC75F51  bl 0x82227880
	ctx.lr = 0x825B1934;
	sub_82227880(ctx, base);
	// 825B1934: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B1938: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 825B193C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1940: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 825B1944: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1948: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B194C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B1950: 4BBE9131  bl 0x8219aa80
	ctx.lr = 0x825B1954;
	sub_8219AA80(ctx, base);
	// 825B1954: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1958: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B195C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1960: 4BE1CAC1  bl 0x823ce420
	ctx.lr = 0x825B1964;
	sub_823CE420(ctx, base);
	// 825B1964: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1968: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B196C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1970: 48472D59  bl 0x82a246c8
	ctx.lr = 0x825B1974;
	sub_82A246C8(ctx, base);
	// 825B1974: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1978: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B197C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B1980; continue 'dispatch;
            }
            0x825B1980 => {
    //   block [0x825B1980..0x825B1990)
	// 825B1980: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B1984: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1988: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B198C: 419A0020  beq cr6, 0x825b19ac
	if ctx.cr[6].eq {
	pc = 0x825B19AC; continue 'dispatch;
	}
	pc = 0x825B1990; continue 'dispatch;
            }
            0x825B1990 => {
    //   block [0x825B1990..0x825B19AC)
	// 825B1990: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1994: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1998: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B199C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B19A0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B19A4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B19A8: 4082FFE8  bne 0x825b1990
	if !ctx.cr[0].eq {
	pc = 0x825B1990; continue 'dispatch;
	}
	pc = 0x825B19AC; continue 'dispatch;
            }
            0x825B19AC => {
    //   block [0x825B19AC..0x825B19CC)
	// 825B19AC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B19B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B19B4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B19B8: 4BD43F91  bl 0x822f5948
	ctx.lr = 0x825B19BC;
	sub_822F5948(ctx, base);
	// 825B19BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B19C0: 4BC06159  bl 0x821b7b18
	ctx.lr = 0x825B19C4;
	sub_821B7B18(ctx, base);
	// 825B19C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B19C8: 419A0040  beq cr6, 0x825b1a08
	if ctx.cr[6].eq {
	pc = 0x825B1A08; continue 'dispatch;
	}
	pc = 0x825B19CC; continue 'dispatch;
            }
            0x825B19CC => {
    //   block [0x825B19CC..0x825B1A08)
	// 825B19CC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B19D0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B19D4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B19D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B19DC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B19E0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B19E4: 4082FFE8  bne 0x825b19cc
	if !ctx.cr[0].eq {
	pc = 0x825B19CC; continue 'dispatch;
	}
	// 825B19E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B19EC: 409A001C  bne cr6, 0x825b1a08
	if !ctx.cr[6].eq {
	pc = 0x825B1A08; continue 'dispatch;
	}
	// 825B19F0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B19F4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B19F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B19FC: 4E800421  bctrl
	ctx.lr = 0x825B1A00;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1A00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B1A04: 4BC6A335  bl 0x8221bd38
	ctx.lr = 0x825B1A08;
	sub_8221BD38(ctx, base);
            }
            0x825B1A08 => {
    //   block [0x825B1A08..0x825B1A18)
	// 825B1A08: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1A0C: 4BC0610D  bl 0x821b7b18
	ctx.lr = 0x825B1A10;
	sub_821B7B18(ctx, base);
	// 825B1A10: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B1A14: 486F7A38  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1A18 size=528
    let mut pc: u32 = 0x825B1A18;
    'dispatch: loop {
        match pc {
            0x825B1A18 => {
    //   block [0x825B1A18..0x825B1A50)
	// 825B1A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1A1C: 486F79E1  bl 0x82ca93fc
	ctx.lr = 0x825B1A20;
	sub_82CA93D0(ctx, base);
	// 825B1A20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1A24: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1A28: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B1A2C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B1A30: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B1A34: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B1A38: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B1A40: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1A44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1A48: 419A0008  beq cr6, 0x825b1a50
	if ctx.cr[6].eq {
	pc = 0x825B1A50; continue 'dispatch;
	}
	// 825B1A4C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1A50; continue 'dispatch;
            }
            0x825B1A50 => {
    //   block [0x825B1A50..0x825B1AF4)
	// 825B1A50: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1A54: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1A58: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1A5C: 4BE1CB65  bl 0x823ce5c0
	ctx.lr = 0x825B1A60;
	sub_823CE5C0(ctx, base);
	// 825B1A60: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B1A64: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1A68: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1A6C: 4BE1C6A5  bl 0x823ce110
	ctx.lr = 0x825B1A70;
	sub_823CE110(ctx, base);
	// 825B1A70: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1A74: 4BC060A5  bl 0x821b7b18
	ctx.lr = 0x825B1A78;
	sub_821B7B18(ctx, base);
	// 825B1A78: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B1A7C: 4BC6D7DD  bl 0x8221f258
	ctx.lr = 0x825B1A80;
	sub_8221F258(ctx, base);
	// 825B1A80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B1A84: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B1A88: 419A006C  beq cr6, 0x825b1af4
	if ctx.cr[6].eq {
	pc = 0x825B1AF4; continue 'dispatch;
	}
	// 825B1A8C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B1A90: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825B1A94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B1A98: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B1A9C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B1AA0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B1AA4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B1AA8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1AAC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B1AB0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B1AB4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B1AB8: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 825B1ABC: 4BC3E785  bl 0x821f0240
	ctx.lr = 0x825B1AC0;
	sub_821F0240(ctx, base);
	// 825B1AC0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B1AC4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B1AC8: 4BC6D791  bl 0x8221f258
	ctx.lr = 0x825B1ACC;
	sub_8221F258(ctx, base);
	// 825B1ACC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B1AD0: 419A0028  beq cr6, 0x825b1af8
	if ctx.cr[6].eq {
	pc = 0x825B1AF8; continue 'dispatch;
	}
	// 825B1AD4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B1AD8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B1ADC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B1AE0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B1AE4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B1AE8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B1AEC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1AF0: 4800000C  b 0x825b1afc
	pc = 0x825B1AFC; continue 'dispatch;
            }
            0x825B1AF4 => {
    //   block [0x825B1AF4..0x825B1AF8)
	// 825B1AF4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B1AF8; continue 'dispatch;
            }
            0x825B1AF8 => {
    //   block [0x825B1AF8..0x825B1AFC)
	// 825B1AF8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B1AFC; continue 'dispatch;
            }
            0x825B1AFC => {
    //   block [0x825B1AFC..0x825B1B10)
	// 825B1AFC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1B00: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1B04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1B08: 419A0008  beq cr6, 0x825b1b10
	if ctx.cr[6].eq {
	pc = 0x825B1B10; continue 'dispatch;
	}
	// 825B1B0C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1B10; continue 'dispatch;
            }
            0x825B1B10 => {
    //   block [0x825B1B10..0x825B1B90)
	// 825B1B10: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B1B14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1B18: 419A0078  beq cr6, 0x825b1b90
	if ctx.cr[6].eq {
	pc = 0x825B1B90; continue 'dispatch;
	}
	// 825B1B1C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1B20: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B1B24: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1B28: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1B2C: 4BC775DD  bl 0x82229108
	ctx.lr = 0x825B1B30;
	sub_82229108(ctx, base);
	// 825B1B30: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B1B34: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1B38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1B3C: 3BCB2C88  addi r30, r11, 0x2c88
	ctx.r[30].s64 = ctx.r[11].s64 + 11400;
	// 825B1B40: 4BC75D41  bl 0x82227880
	ctx.lr = 0x825B1B44;
	sub_82227880(ctx, base);
	// 825B1B44: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B1B48: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 825B1B4C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1B50: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 825B1B54: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1B58: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B1B5C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B1B60: 4BBE8F21  bl 0x8219aa80
	ctx.lr = 0x825B1B64;
	sub_8219AA80(ctx, base);
	// 825B1B64: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1B68: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B1B6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1B70: 4BE1C8B1  bl 0x823ce420
	ctx.lr = 0x825B1B74;
	sub_823CE420(ctx, base);
	// 825B1B74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1B78: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B1B7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1B80: 48472B49  bl 0x82a246c8
	ctx.lr = 0x825B1B84;
	sub_82A246C8(ctx, base);
	// 825B1B84: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1B88: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B1B8C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B1B90; continue 'dispatch;
            }
            0x825B1B90 => {
    //   block [0x825B1B90..0x825B1BA0)
	// 825B1B90: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B1B94: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1B98: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B1B9C: 419A0020  beq cr6, 0x825b1bbc
	if ctx.cr[6].eq {
	pc = 0x825B1BBC; continue 'dispatch;
	}
	pc = 0x825B1BA0; continue 'dispatch;
            }
            0x825B1BA0 => {
    //   block [0x825B1BA0..0x825B1BBC)
	// 825B1BA0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1BA4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1BA8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B1BAC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B1BB0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1BB4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1BB8: 4082FFE8  bne 0x825b1ba0
	if !ctx.cr[0].eq {
	pc = 0x825B1BA0; continue 'dispatch;
	}
	pc = 0x825B1BBC; continue 'dispatch;
            }
            0x825B1BBC => {
    //   block [0x825B1BBC..0x825B1BDC)
	// 825B1BBC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1BC0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B1BC4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B1BC8: 4BD43D81  bl 0x822f5948
	ctx.lr = 0x825B1BCC;
	sub_822F5948(ctx, base);
	// 825B1BCC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B1BD0: 4BC05F49  bl 0x821b7b18
	ctx.lr = 0x825B1BD4;
	sub_821B7B18(ctx, base);
	// 825B1BD4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1BD8: 419A0040  beq cr6, 0x825b1c18
	if ctx.cr[6].eq {
	pc = 0x825B1C18; continue 'dispatch;
	}
	pc = 0x825B1BDC; continue 'dispatch;
            }
            0x825B1BDC => {
    //   block [0x825B1BDC..0x825B1C18)
	// 825B1BDC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1BE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1BE4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B1BE8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B1BEC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1BF0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1BF4: 4082FFE8  bne 0x825b1bdc
	if !ctx.cr[0].eq {
	pc = 0x825B1BDC; continue 'dispatch;
	}
	// 825B1BF8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B1BFC: 409A001C  bne cr6, 0x825b1c18
	if !ctx.cr[6].eq {
	pc = 0x825B1C18; continue 'dispatch;
	}
	// 825B1C00: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1C04: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1C08: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1C0C: 4E800421  bctrl
	ctx.lr = 0x825B1C10;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B1C14: 4BC6A125  bl 0x8221bd38
	ctx.lr = 0x825B1C18;
	sub_8221BD38(ctx, base);
            }
            0x825B1C18 => {
    //   block [0x825B1C18..0x825B1C28)
	// 825B1C18: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1C1C: 4BC05EFD  bl 0x821b7b18
	ctx.lr = 0x825B1C20;
	sub_821B7B18(ctx, base);
	// 825B1C20: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B1C24: 486F7828  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1C28 size=528
    let mut pc: u32 = 0x825B1C28;
    'dispatch: loop {
        match pc {
            0x825B1C28 => {
    //   block [0x825B1C28..0x825B1C60)
	// 825B1C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1C2C: 486F77D1  bl 0x82ca93fc
	ctx.lr = 0x825B1C30;
	sub_82CA93D0(ctx, base);
	// 825B1C30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1C34: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1C38: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B1C3C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B1C40: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B1C44: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B1C48: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1C4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B1C50: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1C54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1C58: 419A0008  beq cr6, 0x825b1c60
	if ctx.cr[6].eq {
	pc = 0x825B1C60; continue 'dispatch;
	}
	// 825B1C5C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1C60; continue 'dispatch;
            }
            0x825B1C60 => {
    //   block [0x825B1C60..0x825B1D04)
	// 825B1C60: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1C64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1C68: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1C6C: 4BE1C955  bl 0x823ce5c0
	ctx.lr = 0x825B1C70;
	sub_823CE5C0(ctx, base);
	// 825B1C70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B1C74: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1C78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1C7C: 4BE1C495  bl 0x823ce110
	ctx.lr = 0x825B1C80;
	sub_823CE110(ctx, base);
	// 825B1C80: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1C84: 4BC05E95  bl 0x821b7b18
	ctx.lr = 0x825B1C88;
	sub_821B7B18(ctx, base);
	// 825B1C88: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B1C8C: 4BC6D5CD  bl 0x8221f258
	ctx.lr = 0x825B1C90;
	sub_8221F258(ctx, base);
	// 825B1C90: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B1C94: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B1C98: 419A006C  beq cr6, 0x825b1d04
	if ctx.cr[6].eq {
	pc = 0x825B1D04; continue 'dispatch;
	}
	// 825B1C9C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B1CA0: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825B1CA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B1CA8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B1CAC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B1CB0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B1CB4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B1CB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1CBC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B1CC0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B1CC4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B1CC8: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 825B1CCC: 4BC3E575  bl 0x821f0240
	ctx.lr = 0x825B1CD0;
	sub_821F0240(ctx, base);
	// 825B1CD0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B1CD4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B1CD8: 4BC6D581  bl 0x8221f258
	ctx.lr = 0x825B1CDC;
	sub_8221F258(ctx, base);
	// 825B1CDC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B1CE0: 419A0028  beq cr6, 0x825b1d08
	if ctx.cr[6].eq {
	pc = 0x825B1D08; continue 'dispatch;
	}
	// 825B1CE4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B1CE8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B1CEC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B1CF0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B1CF4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B1CF8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B1CFC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1D00: 4800000C  b 0x825b1d0c
	pc = 0x825B1D0C; continue 'dispatch;
            }
            0x825B1D04 => {
    //   block [0x825B1D04..0x825B1D08)
	// 825B1D04: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B1D08; continue 'dispatch;
            }
            0x825B1D08 => {
    //   block [0x825B1D08..0x825B1D0C)
	// 825B1D08: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B1D0C; continue 'dispatch;
            }
            0x825B1D0C => {
    //   block [0x825B1D0C..0x825B1D20)
	// 825B1D0C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1D10: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1D14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1D18: 419A0008  beq cr6, 0x825b1d20
	if ctx.cr[6].eq {
	pc = 0x825B1D20; continue 'dispatch;
	}
	// 825B1D1C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1D20; continue 'dispatch;
            }
            0x825B1D20 => {
    //   block [0x825B1D20..0x825B1DA0)
	// 825B1D20: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B1D24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1D28: 419A0078  beq cr6, 0x825b1da0
	if ctx.cr[6].eq {
	pc = 0x825B1DA0; continue 'dispatch;
	}
	// 825B1D2C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1D30: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B1D34: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1D38: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1D3C: 4BC773CD  bl 0x82229108
	ctx.lr = 0x825B1D40;
	sub_82229108(ctx, base);
	// 825B1D40: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B1D44: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1D48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1D4C: 3BCB2DF0  addi r30, r11, 0x2df0
	ctx.r[30].s64 = ctx.r[11].s64 + 11760;
	// 825B1D50: 4BC75B31  bl 0x82227880
	ctx.lr = 0x825B1D54;
	sub_82227880(ctx, base);
	// 825B1D54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B1D58: 3D408282  lis r10, -0x7d7e
	ctx.r[10].s64 = -2105409536;
	// 825B1D5C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1D60: 388AE050  addi r4, r10, -0x1fb0
	ctx.r[4].s64 = ctx.r[10].s64 + -8112;
	// 825B1D64: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1D68: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B1D6C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B1D70: 4BBE8D11  bl 0x8219aa80
	ctx.lr = 0x825B1D74;
	sub_8219AA80(ctx, base);
	// 825B1D74: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1D78: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B1D7C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1D80: 4BE1C6A1  bl 0x823ce420
	ctx.lr = 0x825B1D84;
	sub_823CE420(ctx, base);
	// 825B1D84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1D88: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B1D8C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1D90: 48472939  bl 0x82a246c8
	ctx.lr = 0x825B1D94;
	sub_82A246C8(ctx, base);
	// 825B1D94: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1D98: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B1D9C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B1DA0; continue 'dispatch;
            }
            0x825B1DA0 => {
    //   block [0x825B1DA0..0x825B1DB0)
	// 825B1DA0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B1DA4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1DA8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B1DAC: 419A0020  beq cr6, 0x825b1dcc
	if ctx.cr[6].eq {
	pc = 0x825B1DCC; continue 'dispatch;
	}
	pc = 0x825B1DB0; continue 'dispatch;
            }
            0x825B1DB0 => {
    //   block [0x825B1DB0..0x825B1DCC)
	// 825B1DB0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1DB4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1DB8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B1DBC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B1DC0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1DC4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1DC8: 4082FFE8  bne 0x825b1db0
	if !ctx.cr[0].eq {
	pc = 0x825B1DB0; continue 'dispatch;
	}
	pc = 0x825B1DCC; continue 'dispatch;
            }
            0x825B1DCC => {
    //   block [0x825B1DCC..0x825B1DEC)
	// 825B1DCC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1DD0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B1DD4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B1DD8: 4BD43B71  bl 0x822f5948
	ctx.lr = 0x825B1DDC;
	sub_822F5948(ctx, base);
	// 825B1DDC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B1DE0: 4BC05D39  bl 0x821b7b18
	ctx.lr = 0x825B1DE4;
	sub_821B7B18(ctx, base);
	// 825B1DE4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1DE8: 419A0040  beq cr6, 0x825b1e28
	if ctx.cr[6].eq {
	pc = 0x825B1E28; continue 'dispatch;
	}
	pc = 0x825B1DEC; continue 'dispatch;
            }
            0x825B1DEC => {
    //   block [0x825B1DEC..0x825B1E28)
	// 825B1DEC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1DF0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1DF4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B1DF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B1DFC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1E00: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1E04: 4082FFE8  bne 0x825b1dec
	if !ctx.cr[0].eq {
	pc = 0x825B1DEC; continue 'dispatch;
	}
	// 825B1E08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B1E0C: 409A001C  bne cr6, 0x825b1e28
	if !ctx.cr[6].eq {
	pc = 0x825B1E28; continue 'dispatch;
	}
	// 825B1E10: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1E14: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1E18: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B1E1C: 4E800421  bctrl
	ctx.lr = 0x825B1E20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B1E20: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B1E24: 4BC69F15  bl 0x8221bd38
	ctx.lr = 0x825B1E28;
	sub_8221BD38(ctx, base);
            }
            0x825B1E28 => {
    //   block [0x825B1E28..0x825B1E38)
	// 825B1E28: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1E2C: 4BC05CED  bl 0x821b7b18
	ctx.lr = 0x825B1E30;
	sub_821B7B18(ctx, base);
	// 825B1E30: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B1E34: 486F7618  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B1E38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B1E38 size=528
    let mut pc: u32 = 0x825B1E38;
    'dispatch: loop {
        match pc {
            0x825B1E38 => {
    //   block [0x825B1E38..0x825B1E70)
	// 825B1E38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B1E3C: 486F75C1  bl 0x82ca93fc
	ctx.lr = 0x825B1E40;
	sub_82CA93D0(ctx, base);
	// 825B1E40: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B1E44: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B1E48: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B1E4C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B1E50: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B1E54: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B1E58: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1E5C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B1E60: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1E64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1E68: 419A0008  beq cr6, 0x825b1e70
	if ctx.cr[6].eq {
	pc = 0x825B1E70; continue 'dispatch;
	}
	// 825B1E6C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1E70; continue 'dispatch;
            }
            0x825B1E70 => {
    //   block [0x825B1E70..0x825B1F14)
	// 825B1E70: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1E74: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1E78: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1E7C: 4BE1C745  bl 0x823ce5c0
	ctx.lr = 0x825B1E80;
	sub_823CE5C0(ctx, base);
	// 825B1E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B1E84: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1E88: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1E8C: 4BE1C285  bl 0x823ce110
	ctx.lr = 0x825B1E90;
	sub_823CE110(ctx, base);
	// 825B1E90: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B1E94: 4BC05C85  bl 0x821b7b18
	ctx.lr = 0x825B1E98;
	sub_821B7B18(ctx, base);
	// 825B1E98: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B1E9C: 4BC6D3BD  bl 0x8221f258
	ctx.lr = 0x825B1EA0;
	sub_8221F258(ctx, base);
	// 825B1EA0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B1EA4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B1EA8: 419A006C  beq cr6, 0x825b1f14
	if ctx.cr[6].eq {
	pc = 0x825B1F14; continue 'dispatch;
	}
	// 825B1EAC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B1EB0: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B1EB4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B1EB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B1EBC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B1EC0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B1EC4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B1EC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B1ECC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B1ED0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B1ED4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B1ED8: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B1EDC: 4BC3E365  bl 0x821f0240
	ctx.lr = 0x825B1EE0;
	sub_821F0240(ctx, base);
	// 825B1EE0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B1EE4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B1EE8: 4BC6D371  bl 0x8221f258
	ctx.lr = 0x825B1EEC;
	sub_8221F258(ctx, base);
	// 825B1EEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B1EF0: 419A0028  beq cr6, 0x825b1f18
	if ctx.cr[6].eq {
	pc = 0x825B1F18; continue 'dispatch;
	}
	// 825B1EF4: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B1EF8: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B1EFC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B1F00: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B1F04: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B1F08: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B1F0C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B1F10: 4800000C  b 0x825b1f1c
	pc = 0x825B1F1C; continue 'dispatch;
            }
            0x825B1F14 => {
    //   block [0x825B1F14..0x825B1F18)
	// 825B1F14: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B1F18; continue 'dispatch;
            }
            0x825B1F18 => {
    //   block [0x825B1F18..0x825B1F1C)
	// 825B1F18: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B1F1C; continue 'dispatch;
            }
            0x825B1F1C => {
    //   block [0x825B1F1C..0x825B1F30)
	// 825B1F1C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1F20: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B1F24: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1F28: 419A0008  beq cr6, 0x825b1f30
	if ctx.cr[6].eq {
	pc = 0x825B1F30; continue 'dispatch;
	}
	// 825B1F2C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B1F30; continue 'dispatch;
            }
            0x825B1F30 => {
    //   block [0x825B1F30..0x825B1FB0)
	// 825B1F30: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B1F34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B1F38: 419A0078  beq cr6, 0x825b1fb0
	if ctx.cr[6].eq {
	pc = 0x825B1FB0; continue 'dispatch;
	}
	// 825B1F3C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B1F40: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B1F44: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1F48: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1F4C: 4BC771BD  bl 0x82229108
	ctx.lr = 0x825B1F50;
	sub_82229108(ctx, base);
	// 825B1F50: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B1F54: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B1F58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1F5C: 3BCB2F70  addi r30, r11, 0x2f70
	ctx.r[30].s64 = ctx.r[11].s64 + 12144;
	// 825B1F60: 4BC75921  bl 0x82227880
	ctx.lr = 0x825B1F64;
	sub_82227880(ctx, base);
	// 825B1F64: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B1F68: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B1F6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B1F70: 388A3590  addi r4, r10, 0x3590
	ctx.r[4].s64 = ctx.r[10].s64 + 13712;
	// 825B1F74: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1F78: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B1F7C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B1F80: 4BBE8B01  bl 0x8219aa80
	ctx.lr = 0x825B1F84;
	sub_8219AA80(ctx, base);
	// 825B1F84: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1F88: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B1F8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B1F90: 4BE1C491  bl 0x823ce420
	ctx.lr = 0x825B1F94;
	sub_823CE420(ctx, base);
	// 825B1F94: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B1F98: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B1F9C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B1FA0: 48472729  bl 0x82a246c8
	ctx.lr = 0x825B1FA4;
	sub_82A246C8(ctx, base);
	// 825B1FA4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B1FA8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B1FAC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B1FB0; continue 'dispatch;
            }
            0x825B1FB0 => {
    //   block [0x825B1FB0..0x825B1FC0)
	// 825B1FB0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B1FB4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1FB8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B1FBC: 419A0020  beq cr6, 0x825b1fdc
	if ctx.cr[6].eq {
	pc = 0x825B1FDC; continue 'dispatch;
	}
	pc = 0x825B1FC0; continue 'dispatch;
            }
            0x825B1FC0 => {
    //   block [0x825B1FC0..0x825B1FDC)
	// 825B1FC0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B1FC4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1FC8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B1FCC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B1FD0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B1FD4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B1FD8: 4082FFE8  bne 0x825b1fc0
	if !ctx.cr[0].eq {
	pc = 0x825B1FC0; continue 'dispatch;
	}
	pc = 0x825B1FDC; continue 'dispatch;
            }
            0x825B1FDC => {
    //   block [0x825B1FDC..0x825B1FFC)
	// 825B1FDC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B1FE0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B1FE4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B1FE8: 4BD43961  bl 0x822f5948
	ctx.lr = 0x825B1FEC;
	sub_822F5948(ctx, base);
	// 825B1FEC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B1FF0: 4BC05B29  bl 0x821b7b18
	ctx.lr = 0x825B1FF4;
	sub_821B7B18(ctx, base);
	// 825B1FF4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B1FF8: 419A0040  beq cr6, 0x825b2038
	if ctx.cr[6].eq {
	pc = 0x825B2038; continue 'dispatch;
	}
	pc = 0x825B1FFC; continue 'dispatch;
            }
            0x825B1FFC => {
    //   block [0x825B1FFC..0x825B2038)
	// 825B1FFC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2000: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2004: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2008: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B200C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2010: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2014: 4082FFE8  bne 0x825b1ffc
	if !ctx.cr[0].eq {
	pc = 0x825B1FFC; continue 'dispatch;
	}
	// 825B2018: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B201C: 409A001C  bne cr6, 0x825b2038
	if !ctx.cr[6].eq {
	pc = 0x825B2038; continue 'dispatch;
	}
	// 825B2020: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2024: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2028: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B202C: 4E800421  bctrl
	ctx.lr = 0x825B2030;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2030: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2034: 4BC69D05  bl 0x8221bd38
	ctx.lr = 0x825B2038;
	sub_8221BD38(ctx, base);
            }
            0x825B2038 => {
    //   block [0x825B2038..0x825B2048)
	// 825B2038: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B203C: 4BC05ADD  bl 0x821b7b18
	ctx.lr = 0x825B2040;
	sub_821B7B18(ctx, base);
	// 825B2040: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2044: 486F7408  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2048 size=528
    let mut pc: u32 = 0x825B2048;
    'dispatch: loop {
        match pc {
            0x825B2048 => {
    //   block [0x825B2048..0x825B2080)
	// 825B2048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B204C: 486F73B1  bl 0x82ca93fc
	ctx.lr = 0x825B2050;
	sub_82CA93D0(ctx, base);
	// 825B2050: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2054: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2058: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B205C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B2060: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B2064: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B2068: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B206C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B2070: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2078: 419A0008  beq cr6, 0x825b2080
	if ctx.cr[6].eq {
	pc = 0x825B2080; continue 'dispatch;
	}
	// 825B207C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2080; continue 'dispatch;
            }
            0x825B2080 => {
    //   block [0x825B2080..0x825B2124)
	// 825B2080: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2084: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B2088: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B208C: 4BE1C535  bl 0x823ce5c0
	ctx.lr = 0x825B2090;
	sub_823CE5C0(ctx, base);
	// 825B2090: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B2094: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B2098: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B209C: 4BE1C075  bl 0x823ce110
	ctx.lr = 0x825B20A0;
	sub_823CE110(ctx, base);
	// 825B20A0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B20A4: 4BC05A75  bl 0x821b7b18
	ctx.lr = 0x825B20A8;
	sub_821B7B18(ctx, base);
	// 825B20A8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B20AC: 4BC6D1AD  bl 0x8221f258
	ctx.lr = 0x825B20B0;
	sub_8221F258(ctx, base);
	// 825B20B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B20B4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B20B8: 419A006C  beq cr6, 0x825b2124
	if ctx.cr[6].eq {
	pc = 0x825B2124; continue 'dispatch;
	}
	// 825B20BC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B20C0: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B20C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B20C8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B20CC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B20D0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B20D4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B20D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B20DC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B20E0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B20E4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B20E8: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B20EC: 4BC3E155  bl 0x821f0240
	ctx.lr = 0x825B20F0;
	sub_821F0240(ctx, base);
	// 825B20F0: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B20F4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B20F8: 4BC6D161  bl 0x8221f258
	ctx.lr = 0x825B20FC;
	sub_8221F258(ctx, base);
	// 825B20FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B2100: 419A0028  beq cr6, 0x825b2128
	if ctx.cr[6].eq {
	pc = 0x825B2128; continue 'dispatch;
	}
	// 825B2104: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B2108: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B210C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2110: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B2114: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B2118: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B211C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2120: 4800000C  b 0x825b212c
	pc = 0x825B212C; continue 'dispatch;
            }
            0x825B2124 => {
    //   block [0x825B2124..0x825B2128)
	// 825B2124: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B2128; continue 'dispatch;
            }
            0x825B2128 => {
    //   block [0x825B2128..0x825B212C)
	// 825B2128: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B212C; continue 'dispatch;
            }
            0x825B212C => {
    //   block [0x825B212C..0x825B2140)
	// 825B212C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2130: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2134: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2138: 419A0008  beq cr6, 0x825b2140
	if ctx.cr[6].eq {
	pc = 0x825B2140; continue 'dispatch;
	}
	// 825B213C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2140; continue 'dispatch;
            }
            0x825B2140 => {
    //   block [0x825B2140..0x825B21C0)
	// 825B2140: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2148: 419A0078  beq cr6, 0x825b21c0
	if ctx.cr[6].eq {
	pc = 0x825B21C0; continue 'dispatch;
	}
	// 825B214C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2150: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2154: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2158: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B215C: 4BC76FAD  bl 0x82229108
	ctx.lr = 0x825B2160;
	sub_82229108(ctx, base);
	// 825B2160: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B2164: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B2168: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B216C: 3BCB3110  addi r30, r11, 0x3110
	ctx.r[30].s64 = ctx.r[11].s64 + 12560;
	// 825B2170: 4BC75711  bl 0x82227880
	ctx.lr = 0x825B2174;
	sub_82227880(ctx, base);
	// 825B2174: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B2178: 3D40828E  lis r10, -0x7d72
	ctx.r[10].s64 = -2104623104;
	// 825B217C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B2180: 388A8370  addi r4, r10, -0x7c90
	ctx.r[4].s64 = ctx.r[10].s64 + -31888;
	// 825B2184: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B2188: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B218C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B2190: 4BBE88F1  bl 0x8219aa80
	ctx.lr = 0x825B2194;
	sub_8219AA80(ctx, base);
	// 825B2194: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B2198: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B219C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B21A0: 4BE1C281  bl 0x823ce420
	ctx.lr = 0x825B21A4;
	sub_823CE420(ctx, base);
	// 825B21A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B21A8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B21AC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B21B0: 48472519  bl 0x82a246c8
	ctx.lr = 0x825B21B4;
	sub_82A246C8(ctx, base);
	// 825B21B4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B21B8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B21BC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B21C0; continue 'dispatch;
            }
            0x825B21C0 => {
    //   block [0x825B21C0..0x825B21D0)
	// 825B21C0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B21C4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B21C8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B21CC: 419A0020  beq cr6, 0x825b21ec
	if ctx.cr[6].eq {
	pc = 0x825B21EC; continue 'dispatch;
	}
	pc = 0x825B21D0; continue 'dispatch;
            }
            0x825B21D0 => {
    //   block [0x825B21D0..0x825B21EC)
	// 825B21D0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B21D4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B21D8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B21DC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B21E0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B21E4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B21E8: 4082FFE8  bne 0x825b21d0
	if !ctx.cr[0].eq {
	pc = 0x825B21D0; continue 'dispatch;
	}
	pc = 0x825B21EC; continue 'dispatch;
            }
            0x825B21EC => {
    //   block [0x825B21EC..0x825B220C)
	// 825B21EC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B21F0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B21F4: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B21F8: 4BD43751  bl 0x822f5948
	ctx.lr = 0x825B21FC;
	sub_822F5948(ctx, base);
	// 825B21FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B2200: 4BC05919  bl 0x821b7b18
	ctx.lr = 0x825B2204;
	sub_821B7B18(ctx, base);
	// 825B2204: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2208: 419A0040  beq cr6, 0x825b2248
	if ctx.cr[6].eq {
	pc = 0x825B2248; continue 'dispatch;
	}
	pc = 0x825B220C; continue 'dispatch;
            }
            0x825B220C => {
    //   block [0x825B220C..0x825B2248)
	// 825B220C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2210: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2214: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2218: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B221C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2220: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2224: 4082FFE8  bne 0x825b220c
	if !ctx.cr[0].eq {
	pc = 0x825B220C; continue 'dispatch;
	}
	// 825B2228: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B222C: 409A001C  bne cr6, 0x825b2248
	if !ctx.cr[6].eq {
	pc = 0x825B2248; continue 'dispatch;
	}
	// 825B2230: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2234: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B223C: 4E800421  bctrl
	ctx.lr = 0x825B2240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2240: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2244: 4BC69AF5  bl 0x8221bd38
	ctx.lr = 0x825B2248;
	sub_8221BD38(ctx, base);
            }
            0x825B2248 => {
    //   block [0x825B2248..0x825B2258)
	// 825B2248: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B224C: 4BC058CD  bl 0x821b7b18
	ctx.lr = 0x825B2250;
	sub_821B7B18(ctx, base);
	// 825B2250: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2254: 486F71F8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2258 size=528
    let mut pc: u32 = 0x825B2258;
    'dispatch: loop {
        match pc {
            0x825B2258 => {
    //   block [0x825B2258..0x825B2290)
	// 825B2258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B225C: 486F71A1  bl 0x82ca93fc
	ctx.lr = 0x825B2260;
	sub_82CA93D0(ctx, base);
	// 825B2260: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2264: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2268: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B226C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B2270: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B2274: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B2278: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B227C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B2280: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2284: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2288: 419A0008  beq cr6, 0x825b2290
	if ctx.cr[6].eq {
	pc = 0x825B2290; continue 'dispatch;
	}
	// 825B228C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2290; continue 'dispatch;
            }
            0x825B2290 => {
    //   block [0x825B2290..0x825B2334)
	// 825B2290: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2294: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B2298: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B229C: 4BE1C325  bl 0x823ce5c0
	ctx.lr = 0x825B22A0;
	sub_823CE5C0(ctx, base);
	// 825B22A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B22A4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B22A8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B22AC: 4BE1BE65  bl 0x823ce110
	ctx.lr = 0x825B22B0;
	sub_823CE110(ctx, base);
	// 825B22B0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B22B4: 4BC05865  bl 0x821b7b18
	ctx.lr = 0x825B22B8;
	sub_821B7B18(ctx, base);
	// 825B22B8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B22BC: 4BC6CF9D  bl 0x8221f258
	ctx.lr = 0x825B22C0;
	sub_8221F258(ctx, base);
	// 825B22C0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B22C4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B22C8: 419A006C  beq cr6, 0x825b2334
	if ctx.cr[6].eq {
	pc = 0x825B2334; continue 'dispatch;
	}
	// 825B22CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B22D0: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B22D4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B22D8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B22DC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B22E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B22E4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B22E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B22EC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B22F0: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B22F4: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B22F8: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B22FC: 4BC3DF45  bl 0x821f0240
	ctx.lr = 0x825B2300;
	sub_821F0240(ctx, base);
	// 825B2300: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B2304: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B2308: 4BC6CF51  bl 0x8221f258
	ctx.lr = 0x825B230C;
	sub_8221F258(ctx, base);
	// 825B230C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B2310: 419A0028  beq cr6, 0x825b2338
	if ctx.cr[6].eq {
	pc = 0x825B2338; continue 'dispatch;
	}
	// 825B2314: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B2318: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B231C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2320: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B2324: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B2328: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B232C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2330: 4800000C  b 0x825b233c
	pc = 0x825B233C; continue 'dispatch;
            }
            0x825B2334 => {
    //   block [0x825B2334..0x825B2338)
	// 825B2334: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B2338; continue 'dispatch;
            }
            0x825B2338 => {
    //   block [0x825B2338..0x825B233C)
	// 825B2338: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B233C; continue 'dispatch;
            }
            0x825B233C => {
    //   block [0x825B233C..0x825B2350)
	// 825B233C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2340: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2344: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2348: 419A0008  beq cr6, 0x825b2350
	if ctx.cr[6].eq {
	pc = 0x825B2350; continue 'dispatch;
	}
	// 825B234C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2350; continue 'dispatch;
            }
            0x825B2350 => {
    //   block [0x825B2350..0x825B23D0)
	// 825B2350: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2354: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2358: 419A0078  beq cr6, 0x825b23d0
	if ctx.cr[6].eq {
	pc = 0x825B23D0; continue 'dispatch;
	}
	// 825B235C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2360: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2364: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2368: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B236C: 4BC76D9D  bl 0x82229108
	ctx.lr = 0x825B2370;
	sub_82229108(ctx, base);
	// 825B2370: 3D60822A  lis r11, -0x7dd6
	ctx.r[11].s64 = -2111176704;
	// 825B2374: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B2378: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B237C: 3BCBD6F0  addi r30, r11, -0x2910
	ctx.r[30].s64 = ctx.r[11].s64 + -10512;
	// 825B2380: 4BC75501  bl 0x82227880
	ctx.lr = 0x825B2384;
	sub_82227880(ctx, base);
	// 825B2384: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B2388: 3D408229  lis r10, -0x7dd7
	ctx.r[10].s64 = -2111242240;
	// 825B238C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B2390: 388ACE68  addi r4, r10, -0x3198
	ctx.r[4].s64 = ctx.r[10].s64 + -12696;
	// 825B2394: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B2398: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B239C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B23A0: 4BBE86E1  bl 0x8219aa80
	ctx.lr = 0x825B23A4;
	sub_8219AA80(ctx, base);
	// 825B23A4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B23A8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B23AC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B23B0: 4BE1C071  bl 0x823ce420
	ctx.lr = 0x825B23B4;
	sub_823CE420(ctx, base);
	// 825B23B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B23B8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B23BC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B23C0: 48472309  bl 0x82a246c8
	ctx.lr = 0x825B23C4;
	sub_82A246C8(ctx, base);
	// 825B23C4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B23C8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B23CC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B23D0; continue 'dispatch;
            }
            0x825B23D0 => {
    //   block [0x825B23D0..0x825B23E0)
	// 825B23D0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B23D4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B23D8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B23DC: 419A0020  beq cr6, 0x825b23fc
	if ctx.cr[6].eq {
	pc = 0x825B23FC; continue 'dispatch;
	}
	pc = 0x825B23E0; continue 'dispatch;
            }
            0x825B23E0 => {
    //   block [0x825B23E0..0x825B23FC)
	// 825B23E0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B23E4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B23E8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B23EC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B23F0: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B23F4: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B23F8: 4082FFE8  bne 0x825b23e0
	if !ctx.cr[0].eq {
	pc = 0x825B23E0; continue 'dispatch;
	}
	pc = 0x825B23FC; continue 'dispatch;
            }
            0x825B23FC => {
    //   block [0x825B23FC..0x825B241C)
	// 825B23FC: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2400: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2404: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B2408: 4BD43541  bl 0x822f5948
	ctx.lr = 0x825B240C;
	sub_822F5948(ctx, base);
	// 825B240C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B2410: 4BC05709  bl 0x821b7b18
	ctx.lr = 0x825B2414;
	sub_821B7B18(ctx, base);
	// 825B2414: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2418: 419A0040  beq cr6, 0x825b2458
	if ctx.cr[6].eq {
	pc = 0x825B2458; continue 'dispatch;
	}
	pc = 0x825B241C; continue 'dispatch;
            }
            0x825B241C => {
    //   block [0x825B241C..0x825B2458)
	// 825B241C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2420: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2424: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2428: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B242C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2430: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2434: 4082FFE8  bne 0x825b241c
	if !ctx.cr[0].eq {
	pc = 0x825B241C; continue 'dispatch;
	}
	// 825B2438: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B243C: 409A001C  bne cr6, 0x825b2458
	if !ctx.cr[6].eq {
	pc = 0x825B2458; continue 'dispatch;
	}
	// 825B2440: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2444: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2448: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B244C: 4E800421  bctrl
	ctx.lr = 0x825B2450;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2450: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2454: 4BC698E5  bl 0x8221bd38
	ctx.lr = 0x825B2458;
	sub_8221BD38(ctx, base);
            }
            0x825B2458 => {
    //   block [0x825B2458..0x825B2468)
	// 825B2458: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B245C: 4BC056BD  bl 0x821b7b18
	ctx.lr = 0x825B2460;
	sub_821B7B18(ctx, base);
	// 825B2460: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2464: 486F6FE8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2468(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2468 size=528
    let mut pc: u32 = 0x825B2468;
    'dispatch: loop {
        match pc {
            0x825B2468 => {
    //   block [0x825B2468..0x825B24A0)
	// 825B2468: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B246C: 486F6F91  bl 0x82ca93fc
	ctx.lr = 0x825B2470;
	sub_82CA93D0(ctx, base);
	// 825B2470: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2474: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2478: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B247C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B2480: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B2484: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B2488: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B248C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B2490: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2498: 419A0008  beq cr6, 0x825b24a0
	if ctx.cr[6].eq {
	pc = 0x825B24A0; continue 'dispatch;
	}
	// 825B249C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B24A0; continue 'dispatch;
            }
            0x825B24A0 => {
    //   block [0x825B24A0..0x825B2544)
	// 825B24A0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B24A4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B24A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B24AC: 4BE1C115  bl 0x823ce5c0
	ctx.lr = 0x825B24B0;
	sub_823CE5C0(ctx, base);
	// 825B24B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B24B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B24B8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B24BC: 4BE1BC55  bl 0x823ce110
	ctx.lr = 0x825B24C0;
	sub_823CE110(ctx, base);
	// 825B24C0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B24C4: 4BC05655  bl 0x821b7b18
	ctx.lr = 0x825B24C8;
	sub_821B7B18(ctx, base);
	// 825B24C8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B24CC: 4BC6CD8D  bl 0x8221f258
	ctx.lr = 0x825B24D0;
	sub_8221F258(ctx, base);
	// 825B24D0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B24D4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B24D8: 419A006C  beq cr6, 0x825b2544
	if ctx.cr[6].eq {
	pc = 0x825B2544; continue 'dispatch;
	}
	// 825B24DC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B24E0: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B24E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B24E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B24EC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B24F0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B24F4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B24F8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B24FC: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B2500: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B2504: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B2508: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B250C: 4BC3DD35  bl 0x821f0240
	ctx.lr = 0x825B2510;
	sub_821F0240(ctx, base);
	// 825B2510: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B2514: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B2518: 4BC6CD41  bl 0x8221f258
	ctx.lr = 0x825B251C;
	sub_8221F258(ctx, base);
	// 825B251C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B2520: 419A0028  beq cr6, 0x825b2548
	if ctx.cr[6].eq {
	pc = 0x825B2548; continue 'dispatch;
	}
	// 825B2524: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B2528: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B252C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2530: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B2534: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B2538: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B253C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2540: 4800000C  b 0x825b254c
	pc = 0x825B254C; continue 'dispatch;
            }
            0x825B2544 => {
    //   block [0x825B2544..0x825B2548)
	// 825B2544: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B2548; continue 'dispatch;
            }
            0x825B2548 => {
    //   block [0x825B2548..0x825B254C)
	// 825B2548: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B254C; continue 'dispatch;
            }
            0x825B254C => {
    //   block [0x825B254C..0x825B2560)
	// 825B254C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2550: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2558: 419A0008  beq cr6, 0x825b2560
	if ctx.cr[6].eq {
	pc = 0x825B2560; continue 'dispatch;
	}
	// 825B255C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2560; continue 'dispatch;
            }
            0x825B2560 => {
    //   block [0x825B2560..0x825B25E0)
	// 825B2560: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2568: 419A0078  beq cr6, 0x825b25e0
	if ctx.cr[6].eq {
	pc = 0x825B25E0; continue 'dispatch;
	}
	// 825B256C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2570: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2574: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2578: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B257C: 4BC76B8D  bl 0x82229108
	ctx.lr = 0x825B2580;
	sub_82229108(ctx, base);
	// 825B2580: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B2584: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B2588: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B258C: 3BCB3418  addi r30, r11, 0x3418
	ctx.r[30].s64 = ctx.r[11].s64 + 13336;
	// 825B2590: 4BC752F1  bl 0x82227880
	ctx.lr = 0x825B2594;
	sub_82227880(ctx, base);
	// 825B2594: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B2598: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B259C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B25A0: 388A35C8  addi r4, r10, 0x35c8
	ctx.r[4].s64 = ctx.r[10].s64 + 13768;
	// 825B25A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B25A8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B25AC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B25B0: 4BBE84D1  bl 0x8219aa80
	ctx.lr = 0x825B25B4;
	sub_8219AA80(ctx, base);
	// 825B25B4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B25B8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B25BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B25C0: 4BE1BE61  bl 0x823ce420
	ctx.lr = 0x825B25C4;
	sub_823CE420(ctx, base);
	// 825B25C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B25C8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B25CC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B25D0: 484720F9  bl 0x82a246c8
	ctx.lr = 0x825B25D4;
	sub_82A246C8(ctx, base);
	// 825B25D4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B25D8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B25DC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B25E0; continue 'dispatch;
            }
            0x825B25E0 => {
    //   block [0x825B25E0..0x825B25F0)
	// 825B25E0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B25E4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B25E8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B25EC: 419A0020  beq cr6, 0x825b260c
	if ctx.cr[6].eq {
	pc = 0x825B260C; continue 'dispatch;
	}
	pc = 0x825B25F0; continue 'dispatch;
            }
            0x825B25F0 => {
    //   block [0x825B25F0..0x825B260C)
	// 825B25F0: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B25F4: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B25F8: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B25FC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B2600: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2604: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2608: 4082FFE8  bne 0x825b25f0
	if !ctx.cr[0].eq {
	pc = 0x825B25F0; continue 'dispatch;
	}
	pc = 0x825B260C; continue 'dispatch;
            }
            0x825B260C => {
    //   block [0x825B260C..0x825B262C)
	// 825B260C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2610: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2614: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B2618: 4BD43331  bl 0x822f5948
	ctx.lr = 0x825B261C;
	sub_822F5948(ctx, base);
	// 825B261C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B2620: 4BC054F9  bl 0x821b7b18
	ctx.lr = 0x825B2624;
	sub_821B7B18(ctx, base);
	// 825B2624: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2628: 419A0040  beq cr6, 0x825b2668
	if ctx.cr[6].eq {
	pc = 0x825B2668; continue 'dispatch;
	}
	pc = 0x825B262C; continue 'dispatch;
            }
            0x825B262C => {
    //   block [0x825B262C..0x825B2668)
	// 825B262C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2630: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2634: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2638: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B263C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2640: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2644: 4082FFE8  bne 0x825b262c
	if !ctx.cr[0].eq {
	pc = 0x825B262C; continue 'dispatch;
	}
	// 825B2648: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B264C: 409A001C  bne cr6, 0x825b2668
	if !ctx.cr[6].eq {
	pc = 0x825B2668; continue 'dispatch;
	}
	// 825B2650: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2654: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B265C: 4E800421  bctrl
	ctx.lr = 0x825B2660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2660: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2664: 4BC696D5  bl 0x8221bd38
	ctx.lr = 0x825B2668;
	sub_8221BD38(ctx, base);
            }
            0x825B2668 => {
    //   block [0x825B2668..0x825B2678)
	// 825B2668: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B266C: 4BC054AD  bl 0x821b7b18
	ctx.lr = 0x825B2670;
	sub_821B7B18(ctx, base);
	// 825B2670: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2674: 486F6DD8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2678 size=528
    let mut pc: u32 = 0x825B2678;
    'dispatch: loop {
        match pc {
            0x825B2678 => {
    //   block [0x825B2678..0x825B26B0)
	// 825B2678: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B267C: 486F6D81  bl 0x82ca93fc
	ctx.lr = 0x825B2680;
	sub_82CA93D0(ctx, base);
	// 825B2680: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2684: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2688: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B268C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B2690: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B2694: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B2698: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B269C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B26A0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B26A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B26A8: 419A0008  beq cr6, 0x825b26b0
	if ctx.cr[6].eq {
	pc = 0x825B26B0; continue 'dispatch;
	}
	// 825B26AC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B26B0; continue 'dispatch;
            }
            0x825B26B0 => {
    //   block [0x825B26B0..0x825B2754)
	// 825B26B0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B26B4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B26B8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B26BC: 4BE1BF05  bl 0x823ce5c0
	ctx.lr = 0x825B26C0;
	sub_823CE5C0(ctx, base);
	// 825B26C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B26C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B26C8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B26CC: 4BE1BA45  bl 0x823ce110
	ctx.lr = 0x825B26D0;
	sub_823CE110(ctx, base);
	// 825B26D0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B26D4: 4BC05445  bl 0x821b7b18
	ctx.lr = 0x825B26D8;
	sub_821B7B18(ctx, base);
	// 825B26D8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B26DC: 4BC6CB7D  bl 0x8221f258
	ctx.lr = 0x825B26E0;
	sub_8221F258(ctx, base);
	// 825B26E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B26E4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B26E8: 419A006C  beq cr6, 0x825b2754
	if ctx.cr[6].eq {
	pc = 0x825B2754; continue 'dispatch;
	}
	// 825B26EC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B26F0: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825B26F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B26F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B26FC: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B2700: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B2704: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B2708: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B270C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B2710: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B2714: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B2718: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 825B271C: 4BC3DB25  bl 0x821f0240
	ctx.lr = 0x825B2720;
	sub_821F0240(ctx, base);
	// 825B2720: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B2724: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B2728: 4BC6CB31  bl 0x8221f258
	ctx.lr = 0x825B272C;
	sub_8221F258(ctx, base);
	// 825B272C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B2730: 419A0028  beq cr6, 0x825b2758
	if ctx.cr[6].eq {
	pc = 0x825B2758; continue 'dispatch;
	}
	// 825B2734: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B2738: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B273C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2740: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B2744: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B2748: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B274C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2750: 4800000C  b 0x825b275c
	pc = 0x825B275C; continue 'dispatch;
            }
            0x825B2754 => {
    //   block [0x825B2754..0x825B2758)
	// 825B2754: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B2758; continue 'dispatch;
            }
            0x825B2758 => {
    //   block [0x825B2758..0x825B275C)
	// 825B2758: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B275C; continue 'dispatch;
            }
            0x825B275C => {
    //   block [0x825B275C..0x825B2770)
	// 825B275C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2760: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2764: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2768: 419A0008  beq cr6, 0x825b2770
	if ctx.cr[6].eq {
	pc = 0x825B2770; continue 'dispatch;
	}
	// 825B276C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2770; continue 'dispatch;
            }
            0x825B2770 => {
    //   block [0x825B2770..0x825B27F0)
	// 825B2770: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2774: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2778: 419A0078  beq cr6, 0x825b27f0
	if ctx.cr[6].eq {
	pc = 0x825B27F0; continue 'dispatch;
	}
	// 825B277C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2780: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2784: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2788: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B278C: 4BC7697D  bl 0x82229108
	ctx.lr = 0x825B2790;
	sub_82229108(ctx, base);
	// 825B2790: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B2794: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B2798: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B279C: 3BCB3290  addi r30, r11, 0x3290
	ctx.r[30].s64 = ctx.r[11].s64 + 12944;
	// 825B27A0: 4BC750E1  bl 0x82227880
	ctx.lr = 0x825B27A4;
	sub_82227880(ctx, base);
	// 825B27A4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B27A8: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B27AC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B27B0: 388A3670  addi r4, r10, 0x3670
	ctx.r[4].s64 = ctx.r[10].s64 + 13936;
	// 825B27B4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B27B8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B27BC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B27C0: 4BBE82C1  bl 0x8219aa80
	ctx.lr = 0x825B27C4;
	sub_8219AA80(ctx, base);
	// 825B27C4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B27C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B27CC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B27D0: 4BE1BC51  bl 0x823ce420
	ctx.lr = 0x825B27D4;
	sub_823CE420(ctx, base);
	// 825B27D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B27D8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B27DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B27E0: 48471EE9  bl 0x82a246c8
	ctx.lr = 0x825B27E4;
	sub_82A246C8(ctx, base);
	// 825B27E4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B27E8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B27EC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B27F0; continue 'dispatch;
            }
            0x825B27F0 => {
    //   block [0x825B27F0..0x825B2800)
	// 825B27F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B27F4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B27F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B27FC: 419A0020  beq cr6, 0x825b281c
	if ctx.cr[6].eq {
	pc = 0x825B281C; continue 'dispatch;
	}
	pc = 0x825B2800; continue 'dispatch;
            }
            0x825B2800 => {
    //   block [0x825B2800..0x825B281C)
	// 825B2800: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2804: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2808: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B280C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B2810: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2814: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2818: 4082FFE8  bne 0x825b2800
	if !ctx.cr[0].eq {
	pc = 0x825B2800; continue 'dispatch;
	}
	pc = 0x825B281C; continue 'dispatch;
            }
            0x825B281C => {
    //   block [0x825B281C..0x825B283C)
	// 825B281C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2820: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2824: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B2828: 4BD43121  bl 0x822f5948
	ctx.lr = 0x825B282C;
	sub_822F5948(ctx, base);
	// 825B282C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B2830: 4BC052E9  bl 0x821b7b18
	ctx.lr = 0x825B2834;
	sub_821B7B18(ctx, base);
	// 825B2834: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2838: 419A0040  beq cr6, 0x825b2878
	if ctx.cr[6].eq {
	pc = 0x825B2878; continue 'dispatch;
	}
	pc = 0x825B283C; continue 'dispatch;
            }
            0x825B283C => {
    //   block [0x825B283C..0x825B2878)
	// 825B283C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2840: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2844: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2848: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B284C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2850: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2854: 4082FFE8  bne 0x825b283c
	if !ctx.cr[0].eq {
	pc = 0x825B283C; continue 'dispatch;
	}
	// 825B2858: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B285C: 409A001C  bne cr6, 0x825b2878
	if !ctx.cr[6].eq {
	pc = 0x825B2878; continue 'dispatch;
	}
	// 825B2860: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2864: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2868: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B286C: 4E800421  bctrl
	ctx.lr = 0x825B2870;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2870: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2874: 4BC694C5  bl 0x8221bd38
	ctx.lr = 0x825B2878;
	sub_8221BD38(ctx, base);
            }
            0x825B2878 => {
    //   block [0x825B2878..0x825B2888)
	// 825B2878: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B287C: 4BC0529D  bl 0x821b7b18
	ctx.lr = 0x825B2880;
	sub_821B7B18(ctx, base);
	// 825B2880: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2884: 486F6BC8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2888 size=528
    let mut pc: u32 = 0x825B2888;
    'dispatch: loop {
        match pc {
            0x825B2888 => {
    //   block [0x825B2888..0x825B28C0)
	// 825B2888: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B288C: 486F6B71  bl 0x82ca93fc
	ctx.lr = 0x825B2890;
	sub_82CA93D0(ctx, base);
	// 825B2890: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2894: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2898: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825B289C: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B28A0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825B28A4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825B28A8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B28AC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B28B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B28B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B28B8: 419A0008  beq cr6, 0x825b28c0
	if ctx.cr[6].eq {
	pc = 0x825B28C0; continue 'dispatch;
	}
	// 825B28BC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B28C0; continue 'dispatch;
            }
            0x825B28C0 => {
    //   block [0x825B28C0..0x825B2964)
	// 825B28C0: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B28C4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B28C8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B28CC: 4BE1BCF5  bl 0x823ce5c0
	ctx.lr = 0x825B28D0;
	sub_823CE5C0(ctx, base);
	// 825B28D0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B28D4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B28D8: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B28DC: 4BE1B835  bl 0x823ce110
	ctx.lr = 0x825B28E0;
	sub_823CE110(ctx, base);
	// 825B28E0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B28E4: 4BC05235  bl 0x821b7b18
	ctx.lr = 0x825B28E8;
	sub_821B7B18(ctx, base);
	// 825B28E8: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825B28EC: 4BC6C96D  bl 0x8221f258
	ctx.lr = 0x825B28F0;
	sub_8221F258(ctx, base);
	// 825B28F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B28F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B28F8: 419A006C  beq cr6, 0x825b2964
	if ctx.cr[6].eq {
	pc = 0x825B2964; continue 'dispatch;
	}
	// 825B28FC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B2900: FBBF0010  std r29, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[29].u64 ) };
	// 825B2904: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B2908: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B290C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825B2910: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B2914: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825B2918: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B291C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B2920: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825B2924: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B2928: F8FF0008  std r7, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 825B292C: 4BC3D915  bl 0x821f0240
	ctx.lr = 0x825B2930;
	sub_821F0240(ctx, base);
	// 825B2930: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825B2934: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825B2938: 4BC6C921  bl 0x8221f258
	ctx.lr = 0x825B293C;
	sub_8221F258(ctx, base);
	// 825B293C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B2940: 419A0028  beq cr6, 0x825b2968
	if ctx.cr[6].eq {
	pc = 0x825B2968; continue 'dispatch;
	}
	// 825B2944: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825B2948: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B294C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2950: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825B2954: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B2958: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B295C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B2960: 4800000C  b 0x825b296c
	pc = 0x825B296C; continue 'dispatch;
            }
            0x825B2964 => {
    //   block [0x825B2964..0x825B2968)
	// 825B2964: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B2968; continue 'dispatch;
            }
            0x825B2968 => {
    //   block [0x825B2968..0x825B296C)
	// 825B2968: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B296C; continue 'dispatch;
            }
            0x825B296C => {
    //   block [0x825B296C..0x825B2980)
	// 825B296C: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2970: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B2974: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2978: 419A0008  beq cr6, 0x825b2980
	if ctx.cr[6].eq {
	pc = 0x825B2980; continue 'dispatch;
	}
	// 825B297C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B2980; continue 'dispatch;
            }
            0x825B2980 => {
    //   block [0x825B2980..0x825B2A00)
	// 825B2980: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B2984: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2988: 419A0078  beq cr6, 0x825b2a00
	if ctx.cr[6].eq {
	pc = 0x825B2A00; continue 'dispatch;
	}
	// 825B298C: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2990: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2994: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2998: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B299C: 4BC7676D  bl 0x82229108
	ctx.lr = 0x825B29A0;
	sub_82229108(ctx, base);
	// 825B29A0: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B29A4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825B29A8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B29AC: 3BCB3418  addi r30, r11, 0x3418
	ctx.r[30].s64 = ctx.r[11].s64 + 13336;
	// 825B29B0: 4BC74ED1  bl 0x82227880
	ctx.lr = 0x825B29B4;
	sub_82227880(ctx, base);
	// 825B29B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B29B8: 3D408295  lis r10, -0x7d6b
	ctx.r[10].s64 = -2104164352;
	// 825B29BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B29C0: 388AC430  addi r4, r10, -0x3bd0
	ctx.r[4].s64 = ctx.r[10].s64 + -15312;
	// 825B29C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B29C8: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825B29CC: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B29D0: 4BBE80B1  bl 0x8219aa80
	ctx.lr = 0x825B29D4;
	sub_8219AA80(ctx, base);
	// 825B29D4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B29D8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B29DC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B29E0: 4BE1BA41  bl 0x823ce420
	ctx.lr = 0x825B29E4;
	sub_823CE420(ctx, base);
	// 825B29E4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B29E8: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825B29EC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B29F0: 48471CD9  bl 0x82a246c8
	ctx.lr = 0x825B29F4;
	sub_82A246C8(ctx, base);
	// 825B29F4: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B29F8: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825B29FC: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825B2A00; continue 'dispatch;
            }
            0x825B2A00 => {
    //   block [0x825B2A00..0x825B2A10)
	// 825B2A00: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B2A04: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2A08: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B2A0C: 419A0020  beq cr6, 0x825b2a2c
	if ctx.cr[6].eq {
	pc = 0x825B2A2C; continue 'dispatch;
	}
	pc = 0x825B2A10; continue 'dispatch;
            }
            0x825B2A10 => {
    //   block [0x825B2A10..0x825B2A2C)
	// 825B2A10: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2A14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2A18: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2A1C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B2A20: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2A24: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2A28: 4082FFE8  bne 0x825b2a10
	if !ctx.cr[0].eq {
	pc = 0x825B2A10; continue 'dispatch;
	}
	pc = 0x825B2A2C; continue 'dispatch;
            }
            0x825B2A2C => {
    //   block [0x825B2A2C..0x825B2A4C)
	// 825B2A2C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2A30: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2A34: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B2A38: 4BD42F11  bl 0x822f5948
	ctx.lr = 0x825B2A3C;
	sub_822F5948(ctx, base);
	// 825B2A3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B2A40: 4BC050D9  bl 0x821b7b18
	ctx.lr = 0x825B2A44;
	sub_821B7B18(ctx, base);
	// 825B2A44: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B2A48: 419A0040  beq cr6, 0x825b2a88
	if ctx.cr[6].eq {
	pc = 0x825B2A88; continue 'dispatch;
	}
	pc = 0x825B2A4C; continue 'dispatch;
            }
            0x825B2A4C => {
    //   block [0x825B2A4C..0x825B2A88)
	// 825B2A4C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B2A50: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2A54: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B2A58: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B2A5C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B2A60: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B2A64: 4082FFE8  bne 0x825b2a4c
	if !ctx.cr[0].eq {
	pc = 0x825B2A4C; continue 'dispatch;
	}
	// 825B2A68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B2A6C: 409A001C  bne cr6, 0x825b2a88
	if !ctx.cr[6].eq {
	pc = 0x825B2A88; continue 'dispatch;
	}
	// 825B2A70: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2A74: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2A78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825B2A7C: 4E800421  bctrl
	ctx.lr = 0x825B2A80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2A80: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2A84: 4BC692B5  bl 0x8221bd38
	ctx.lr = 0x825B2A88;
	sub_8221BD38(ctx, base);
            }
            0x825B2A88 => {
    //   block [0x825B2A88..0x825B2A98)
	// 825B2A88: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B2A8C: 4BC0508D  bl 0x821b7b18
	ctx.lr = 0x825B2A90;
	sub_821B7B18(ctx, base);
	// 825B2A90: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B2A94: 486F69B8  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2A98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2A98 size=192
    let mut pc: u32 = 0x825B2A98;
    'dispatch: loop {
        match pc {
            0x825B2A98 => {
    //   block [0x825B2A98..0x825B2B30)
	// 825B2A98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B2A9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B2AA0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B2AA4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B2AA8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2AAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2AB0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B2AB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2AB8: 419A0080  beq cr6, 0x825b2b38
	if ctx.cr[6].eq {
	pc = 0x825B2B38; continue 'dispatch;
	}
	// 825B2ABC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2AC0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825B2AC4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2AC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B2ACC: 4BC7663D  bl 0x82229108
	ctx.lr = 0x825B2AD0;
	sub_82229108(ctx, base);
	// 825B2AD0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B2AD4: 3880FFFF  li r4, -1
	ctx.r[4].s64 = -1;
	// 825B2AD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B2ADC: 4BC7662D  bl 0x82229108
	ctx.lr = 0x825B2AE0;
	sub_82229108(ctx, base);
	// 825B2AE0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2AE4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2AE8: 394BFFF8  addi r10, r11, -8
	ctx.r[10].s64 = ctx.r[11].s64 + -8;
	// 825B2AEC: 39099700  addi r8, r9, -0x6900
	ctx.r[8].s64 = ctx.r[9].s64 + -26880;
	// 825B2AF0: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B2AF4: 419A003C  beq cr6, 0x825b2b30
	if ctx.cr[6].eq {
	pc = 0x825B2B30; continue 'dispatch;
	}
	// 825B2AF8: 814A0004  lwz r10, 4(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2AFC: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 825B2B00: 409A0030  bne cr6, 0x825b2b30
	if !ctx.cr[6].eq {
	pc = 0x825B2B30; continue 'dispatch;
	}
	// 825B2B04: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B2B08: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B2B0C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B2B10: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B2B14: 994B0000  stb r10, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u8 ) };
	// 825B2B18: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B2B1C: 4BD4F43D  bl 0x82301f58
	ctx.lr = 0x825B2B20;
	sub_82301F58(ctx, base);
	// 825B2B20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2B24: 392BFFF0  addi r9, r11, -0x10
	ctx.r[9].s64 = ctx.r[11].s64 + -16;
	// 825B2B28: 913F0008  stw r9, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825B2B2C: 48000014  b 0x825b2b40
	pc = 0x825B2B40; continue 'dispatch;
            }
            0x825B2B30 => {
    //   block [0x825B2B30..0x825B2B38)
	// 825B2B30: 396BFFF0  addi r11, r11, -0x10
	ctx.r[11].s64 = ctx.r[11].s64 + -16;
	// 825B2B34: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825B2B38; continue 'dispatch;
            }
            0x825B2B38 => {
    //   block [0x825B2B38..0x825B2B40)
	// 825B2B38: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B2B3C: 386B0CA0  addi r3, r11, 0xca0
	ctx.r[3].s64 = ctx.r[11].s64 + 3232;
	pc = 0x825B2B40; continue 'dispatch;
            }
            0x825B2B40 => {
    //   block [0x825B2B40..0x825B2B58)
	// 825B2B40: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B2B44: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B2B48: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B2B4C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B2B50: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B2B54: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2B58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2B58 size=240
    let mut pc: u32 = 0x825B2B58;
    'dispatch: loop {
        match pc {
            0x825B2B58 => {
    //   block [0x825B2B58..0x825B2BAC)
	// 825B2B58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B2B5C: 486F68B1  bl 0x82ca940c
	ctx.lr = 0x825B2B60;
	sub_82CA93D0(ctx, base);
	// 825B2B60: 9421F750  stwu r1, -0x8b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-2224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2B64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B2B68: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B2B6C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825B2B70: 817D0064  lwz r11, 0x64(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B2B74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2B78: 409900C8  ble cr6, 0x825b2c40
	if !ctx.cr[6].gt {
	pc = 0x825B2C40; continue 'dispatch;
	}
	// 825B2B7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2B80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B2B84: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2B88: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B2B8C: 4E800421  bctrl
	ctx.lr = 0x825B2B90;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2B90: 7BC90020  clrldi r9, r30, 0x20
	ctx.r[9].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825B2B94: B0610050  sth r3, 0x50(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u16 ) };
	// 825B2B98: 2B290000  cmpldi cr6, r9, 0
	ctx.cr[6].compare_u64(ctx.r[9].u64, 0, &mut ctx.xer);
	// 825B2B9C: 419A0010  beq cr6, 0x825b2bac
	if ctx.cr[6].eq {
	pc = 0x825B2BAC; continue 'dispatch;
	}
	// 825B2BA0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B2BA4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825B2BA8: 48000010  b 0x825b2bb8
	pc = 0x825B2BB8; continue 'dispatch;
            }
            0x825B2BAC => {
    //   block [0x825B2BAC..0x825B2BB8)
	// 825B2BAC: 7BCB0022  rldicl r11, r30, 0x20, 0x20
	ctx.r[11].u64 = ctx.r[30].u64 & 0x00000000FFFFFFFFu64;
	// 825B2BB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2BB4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x825B2BB8; continue 'dispatch;
            }
            0x825B2BB8 => {
    //   block [0x825B2BB8..0x825B2C40)
	// 825B2BB8: 38A00800  li r5, 0x800
	ctx.r[5].s64 = 2048;
	// 825B2BBC: 99410058  stb r10, 0x58(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u8 ) };
	// 825B2BC0: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825B2BC4: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825B2BC8: 486D5419  bl 0x82c87fe0
	ctx.lr = 0x825B2BCC;
	sub_82C87FE0(ctx, base);
	// 825B2BCC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B2BD0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B2BD4: 394B3D70  addi r10, r11, 0x3d70
	ctx.r[10].s64 = ctx.r[11].s64 + 15728;
	// 825B2BD8: 38810084  addi r4, r1, 0x84
	ctx.r[4].s64 = ctx.r[1].s64 + 132;
	// 825B2BDC: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825B2BE0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B2BE4: 486D53BD  bl 0x82c87fa0
	ctx.lr = 0x825B2BE8;
	sub_82C87FA0(ctx, base);
	// 825B2BE8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B2BEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825B2BF0: 39093C90  addi r8, r9, 0x3c90
	ctx.r[8].s64 = ctx.r[9].s64 + 15504;
	// 825B2BF4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2BF8: 91010060  stw r8, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 825B2BFC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B2C00: 4BD56F39  bl 0x82309b38
	ctx.lr = 0x825B2C04;
	sub_82309B38(ctx, base);
	// 825B2C04: 80E10060  lwz r7, 0x60(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B2C08: 889F0004  lbz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2C0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825B2C10: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B2C14: 80C70080  lwz r6, 0x80(r7)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B2C18: 7CC903A6  mtctr r6
	ctx.ctr.u64 = ctx.r[6].u64;
	// 825B2C1C: 4E800421  bctrl
	ctx.lr = 0x825B2C20;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B2C20: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 825B2C24: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B2C28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B2C2C: 4BD8284D  bl 0x82335478
	ctx.lr = 0x825B2C30;
	sub_82335478(ctx, base);
	// 825B2C30: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825B2C34: 485E4245  bl 0x82b96e78
	ctx.lr = 0x825B2C38;
	sub_82B96E78(ctx, base);
	// 825B2C38: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825B2C3C: 485E423D  bl 0x82b96e78
	ctx.lr = 0x825B2C40;
	sub_82B96E78(ctx, base);
            }
            0x825B2C40 => {
    //   block [0x825B2C40..0x825B2C48)
	// 825B2C40: 382108B0  addi r1, r1, 0x8b0
	ctx.r[1].s64 = ctx.r[1].s64 + 2224;
	// 825B2C44: 486F6818  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B2C48 size=56
    let mut pc: u32 = 0x825B2C48;
    'dispatch: loop {
        match pc {
            0x825B2C48 => {
    //   block [0x825B2C48..0x825B2C64)
	// 825B2C48: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B2C4C: 419A0018  beq cr6, 0x825b2c64
	if ctx.cr[6].eq {
	pc = 0x825B2C64; continue 'dispatch;
	}
	// 825B2C50: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B2C54: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2C58: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2C5C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2C60: 409A0008  bne cr6, 0x825b2c68
	if !ctx.cr[6].eq {
	pc = 0x825B2C68; continue 'dispatch;
	}
	pc = 0x825B2C64; continue 'dispatch;
            }
            0x825B2C64 => {
    //   block [0x825B2C64..0x825B2C68)
	// 825B2C64: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2C68; continue 'dispatch;
            }
            0x825B2C68 => {
    //   block [0x825B2C68..0x825B2C80)
	// 825B2C68: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2C70: 419A0010  beq cr6, 0x825b2c80
	if ctx.cr[6].eq {
		sub_825B2C80(ctx, base);
		return;
	}
	// 825B2C74: 81640030  lwz r11, 0x30(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B2C78: 55634FFE  rlwinm r3, r11, 9, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x007FFFFFu64;
	// 825B2C7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B2C80 size=8
    let mut pc: u32 = 0x825B2C80;
    'dispatch: loop {
        match pc {
            0x825B2C80 => {
    //   block [0x825B2C80..0x825B2C88)
	// 825B2C80: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B2C84: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2C88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2C88 size=356
    let mut pc: u32 = 0x825B2C88;
    'dispatch: loop {
        match pc {
            0x825B2C88 => {
    //   block [0x825B2C88..0x825B2CB0)
	// 825B2C88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B2C8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B2C90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2C94: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B2C98: 419A0018  beq cr6, 0x825b2cb0
	if ctx.cr[6].eq {
	pc = 0x825B2CB0; continue 'dispatch;
	}
	// 825B2C9C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B2CA0: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2CA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2CA8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2CAC: 409A0008  bne cr6, 0x825b2cb4
	if !ctx.cr[6].eq {
	pc = 0x825B2CB4; continue 'dispatch;
	}
	pc = 0x825B2CB0; continue 'dispatch;
            }
            0x825B2CB0 => {
    //   block [0x825B2CB0..0x825B2CB4)
	// 825B2CB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2CB4; continue 'dispatch;
            }
            0x825B2CB4 => {
    //   block [0x825B2CB4..0x825B2CFC)
	// 825B2CB4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2CB8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2CBC: 419A0120  beq cr6, 0x825b2ddc
	if ctx.cr[6].eq {
	pc = 0x825B2DDC; continue 'dispatch;
	}
	// 825B2CC0: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B2CC4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B2CC8: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 825B2CCC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B2CD0: 419A00E8  beq cr6, 0x825b2db8
	if ctx.cr[6].eq {
	pc = 0x825B2DB8; continue 'dispatch;
	}
	// 825B2CD4: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B2CD8: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B2CDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2CE0: 419A001C  beq cr6, 0x825b2cfc
	if ctx.cr[6].eq {
	pc = 0x825B2CFC; continue 'dispatch;
	}
	// 825B2CE4: 896B0077  lbz r11, 0x77(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B2CE8: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825B2CEC: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B2CF0: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2CF4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2CF8: 480000C4  b 0x825b2dbc
	pc = 0x825B2DBC; continue 'dispatch;
            }
            0x825B2CFC => {
    //   block [0x825B2CFC..0x825B2D18)
	// 825B2CFC: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B2D00: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B2D04: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B2D08: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B2D0C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B2D10: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B2D14: 40810054  ble 0x825b2d68
	if !ctx.cr[0].gt {
	pc = 0x825B2D68; continue 'dispatch;
	}
	pc = 0x825B2D18; continue 'dispatch;
            }
            0x825B2D18 => {
    //   block [0x825B2D18..0x825B2D38)
	// 825B2D18: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B2D1C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B2D20: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B2D24: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2D28: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B2D2C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B2D30: 41980008  blt cr6, 0x825b2d38
	if ctx.cr[6].lt {
	pc = 0x825B2D38; continue 'dispatch;
	}
	// 825B2D34: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B2D38; continue 'dispatch;
            }
            0x825B2D38 => {
    //   block [0x825B2D38..0x825B2D54)
	// 825B2D38: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B2D3C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B2D40: 419A0014  beq cr6, 0x825b2d54
	if ctx.cr[6].eq {
	pc = 0x825B2D54; continue 'dispatch;
	}
	// 825B2D44: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B2D48: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B2D4C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B2D50: 4800000C  b 0x825b2d5c
	pc = 0x825B2D5C; continue 'dispatch;
            }
            0x825B2D54 => {
    //   block [0x825B2D54..0x825B2D5C)
	// 825B2D54: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B2D58: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B2D5C; continue 'dispatch;
            }
            0x825B2D5C => {
    //   block [0x825B2D5C..0x825B2D68)
	// 825B2D5C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B2D60: 4199FFB8  bgt cr6, 0x825b2d18
	if ctx.cr[6].gt {
	pc = 0x825B2D18; continue 'dispatch;
	}
	// 825B2D64: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B2D68; continue 'dispatch;
            }
            0x825B2D68 => {
    //   block [0x825B2D68..0x825B2D84)
	// 825B2D68: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B2D6C: 419A003C  beq cr6, 0x825b2da8
	if ctx.cr[6].eq {
	pc = 0x825B2DA8; continue 'dispatch;
	}
	// 825B2D70: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2D74: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B2D78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2D7C: 41990008  bgt cr6, 0x825b2d84
	if ctx.cr[6].gt {
	pc = 0x825B2D84; continue 'dispatch;
	}
	// 825B2D80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2D84; continue 'dispatch;
            }
            0x825B2D84 => {
    //   block [0x825B2D84..0x825B2DA8)
	// 825B2D84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2D88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2D8C: 409A001C  bne cr6, 0x825b2da8
	if !ctx.cr[6].eq {
	pc = 0x825B2DA8; continue 'dispatch;
	}
	// 825B2D90: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B2D94: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2D98: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B2D9C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B2DA0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2DA4: 48000018  b 0x825b2dbc
	pc = 0x825B2DBC; continue 'dispatch;
            }
            0x825B2DA8 => {
    //   block [0x825B2DA8..0x825B2DB8)
	// 825B2DA8: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B2DAC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2DB0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2DB4: 48000008  b 0x825b2dbc
	pc = 0x825B2DBC; continue 'dispatch;
            }
            0x825B2DB8 => {
    //   block [0x825B2DB8..0x825B2DBC)
	// 825B2DB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B2DBC; continue 'dispatch;
            }
            0x825B2DBC => {
    //   block [0x825B2DBC..0x825B2DDC)
	// 825B2DBC: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2DC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2DC4: 419A0018  beq cr6, 0x825b2ddc
	if ctx.cr[6].eq {
	pc = 0x825B2DDC; continue 'dispatch;
	}
	// 825B2DC8: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2DCC: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2DD0: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B2DD4: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B2DD8: 4E800421  bctrl
	ctx.lr = 0x825B2DDC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B2DDC => {
    //   block [0x825B2DDC..0x825B2DEC)
	// 825B2DDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B2DE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B2DE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B2DE8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2DF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2DF0 size=380
    let mut pc: u32 = 0x825B2DF0;
    'dispatch: loop {
        match pc {
            0x825B2DF0 => {
    //   block [0x825B2DF0..0x825B2E1C)
	// 825B2DF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B2DF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B2DF8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2DFC: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B2E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2E04: 419A0018  beq cr6, 0x825b2e1c
	if ctx.cr[6].eq {
	pc = 0x825B2E1C; continue 'dispatch;
	}
	// 825B2E08: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B2E0C: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2E10: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2E14: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B2E18: 409A0008  bne cr6, 0x825b2e20
	if !ctx.cr[6].eq {
	pc = 0x825B2E20; continue 'dispatch;
	}
	pc = 0x825B2E1C; continue 'dispatch;
            }
            0x825B2E1C => {
    //   block [0x825B2E1C..0x825B2E20)
	// 825B2E1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B2E20; continue 'dispatch;
            }
            0x825B2E20 => {
    //   block [0x825B2E20..0x825B2E6C)
	// 825B2E20: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2E24: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2E28: 419A0134  beq cr6, 0x825b2f5c
	if ctx.cr[6].eq {
	pc = 0x825B2F5C; continue 'dispatch;
	}
	// 825B2E2C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B2E30: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B2E34: 55284FFE  rlwinm r8, r9, 9, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x007FFFFFu64;
	// 825B2E38: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B2E3C: 419A00F8  beq cr6, 0x825b2f34
	if ctx.cr[6].eq {
	pc = 0x825B2F34; continue 'dispatch;
	}
	// 825B2E40: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B2E44: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2E48: 419A0024  beq cr6, 0x825b2e6c
	if ctx.cr[6].eq {
	pc = 0x825B2E6C; continue 'dispatch;
	}
	// 825B2E4C: 892A0077  lbz r9, 0x77(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B2E50: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B2E54: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B2E58: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B2E5C: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2E60: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B2E64: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2E68: 480000D0  b 0x825b2f38
	pc = 0x825B2F38; continue 'dispatch;
            }
            0x825B2E6C => {
    //   block [0x825B2E6C..0x825B2E8C)
	// 825B2E6C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B2E70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B2E74: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B2E78: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B2E7C: 7D0A3050  subf r8, r10, r6
	ctx.r[8].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B2E80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B2E84: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B2E88: 40810054  ble 0x825b2edc
	if !ctx.cr[0].gt {
	pc = 0x825B2EDC; continue 'dispatch;
	}
	pc = 0x825B2E8C; continue 'dispatch;
            }
            0x825B2E8C => {
    //   block [0x825B2E8C..0x825B2EAC)
	// 825B2E8C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B2E90: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B2E94: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B2E98: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2E9C: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B2EA0: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B2EA4: 41980008  blt cr6, 0x825b2eac
	if ctx.cr[6].lt {
	pc = 0x825B2EAC; continue 'dispatch;
	}
	// 825B2EA8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B2EAC; continue 'dispatch;
            }
            0x825B2EAC => {
    //   block [0x825B2EAC..0x825B2EC8)
	// 825B2EAC: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B2EB0: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B2EB4: 419A0014  beq cr6, 0x825b2ec8
	if ctx.cr[6].eq {
	pc = 0x825B2EC8; continue 'dispatch;
	}
	// 825B2EB8: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B2EBC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B2EC0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B2EC4: 4800000C  b 0x825b2ed0
	pc = 0x825B2ED0; continue 'dispatch;
            }
            0x825B2EC8 => {
    //   block [0x825B2EC8..0x825B2ED0)
	// 825B2EC8: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B2ECC: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B2ED0; continue 'dispatch;
            }
            0x825B2ED0 => {
    //   block [0x825B2ED0..0x825B2EDC)
	// 825B2ED0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B2ED4: 4199FFB8  bgt cr6, 0x825b2e8c
	if ctx.cr[6].gt {
	pc = 0x825B2E8C; continue 'dispatch;
	}
	// 825B2ED8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B2EDC; continue 'dispatch;
            }
            0x825B2EDC => {
    //   block [0x825B2EDC..0x825B2EF8)
	// 825B2EDC: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B2EE0: 419A0040  beq cr6, 0x825b2f20
	if ctx.cr[6].eq {
	pc = 0x825B2F20; continue 'dispatch;
	}
	// 825B2EE4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B2EE8: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B2EEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2EF0: 41990008  bgt cr6, 0x825b2ef8
	if ctx.cr[6].gt {
	pc = 0x825B2EF8; continue 'dispatch;
	}
	// 825B2EF4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2EF8; continue 'dispatch;
            }
            0x825B2EF8 => {
    //   block [0x825B2EF8..0x825B2F20)
	// 825B2EF8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2EFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2F00: 409A0020  bne cr6, 0x825b2f20
	if !ctx.cr[6].eq {
	pc = 0x825B2F20; continue 'dispatch;
	}
	// 825B2F04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B2F08: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B2F0C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B2F10: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2F14: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B2F18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2F1C: 4800001C  b 0x825b2f38
	pc = 0x825B2F38; continue 'dispatch;
            }
            0x825B2F20 => {
    //   block [0x825B2F20..0x825B2F34)
	// 825B2F20: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B2F24: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2F28: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B2F2C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2F30: 48000008  b 0x825b2f38
	pc = 0x825B2F38; continue 'dispatch;
            }
            0x825B2F34 => {
    //   block [0x825B2F34..0x825B2F38)
	// 825B2F34: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B2F38; continue 'dispatch;
            }
            0x825B2F38 => {
    //   block [0x825B2F38..0x825B2F5C)
	// 825B2F38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B2F3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2F40: 419A001C  beq cr6, 0x825b2f5c
	if ctx.cr[6].eq {
	pc = 0x825B2F5C; continue 'dispatch;
	}
	// 825B2F44: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B2F48: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B2F4C: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B2F50: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B2F54: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B2F58: 4E800421  bctrl
	ctx.lr = 0x825B2F5C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B2F5C => {
    //   block [0x825B2F5C..0x825B2F6C)
	// 825B2F5C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B2F60: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B2F64: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B2F68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B2F70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B2F70 size=416
    let mut pc: u32 = 0x825B2F70;
    'dispatch: loop {
        match pc {
            0x825B2F70 => {
    //   block [0x825B2F70..0x825B2FA4)
	// 825B2F70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B2F74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B2F78: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B2F7C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B2F80: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B2F84: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B2F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B2F8C: 419A0018  beq cr6, 0x825b2fa4
	if ctx.cr[6].eq {
	pc = 0x825B2FA4; continue 'dispatch;
	}
	// 825B2F90: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B2F94: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B2F98: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B2F9C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B2FA0: 409A0008  bne cr6, 0x825b2fa8
	if !ctx.cr[6].eq {
	pc = 0x825B2FA8; continue 'dispatch;
	}
	pc = 0x825B2FA4; continue 'dispatch;
            }
            0x825B2FA4 => {
    //   block [0x825B2FA4..0x825B2FA8)
	// 825B2FA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B2FA8; continue 'dispatch;
            }
            0x825B2FA8 => {
    //   block [0x825B2FA8..0x825B2FF4)
	// 825B2FA8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B2FAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2FB0: 419A0148  beq cr6, 0x825b30f8
	if ctx.cr[6].eq {
	pc = 0x825B30F8; continue 'dispatch;
	}
	// 825B2FB4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B2FB8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B2FBC: 55284FFE  rlwinm r8, r9, 9, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x007FFFFFu64;
	// 825B2FC0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B2FC4: 419A00F8  beq cr6, 0x825b30bc
	if ctx.cr[6].eq {
	pc = 0x825B30BC; continue 'dispatch;
	}
	// 825B2FC8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B2FCC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B2FD0: 419A0024  beq cr6, 0x825b2ff4
	if ctx.cr[6].eq {
	pc = 0x825B2FF4; continue 'dispatch;
	}
	// 825B2FD4: 892A0077  lbz r9, 0x77(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B2FD8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B2FDC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B2FE0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B2FE4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B2FE8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B2FEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B2FF0: 480000D0  b 0x825b30c0
	pc = 0x825B30C0; continue 'dispatch;
            }
            0x825B2FF4 => {
    //   block [0x825B2FF4..0x825B3014)
	// 825B2FF4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B2FF8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B2FFC: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B3000: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B3004: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 825B3008: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B300C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B3010: 40810054  ble 0x825b3064
	if !ctx.cr[0].gt {
	pc = 0x825B3064; continue 'dispatch;
	}
	pc = 0x825B3014; continue 'dispatch;
            }
            0x825B3014 => {
    //   block [0x825B3014..0x825B3034)
	// 825B3014: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B3018: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B301C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B3020: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3024: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B3028: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B302C: 41980008  blt cr6, 0x825b3034
	if ctx.cr[6].lt {
	pc = 0x825B3034; continue 'dispatch;
	}
	// 825B3030: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B3034; continue 'dispatch;
            }
            0x825B3034 => {
    //   block [0x825B3034..0x825B3050)
	// 825B3034: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B3038: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B303C: 419A0014  beq cr6, 0x825b3050
	if ctx.cr[6].eq {
	pc = 0x825B3050; continue 'dispatch;
	}
	// 825B3040: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B3044: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B3048: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B304C: 4800000C  b 0x825b3058
	pc = 0x825B3058; continue 'dispatch;
            }
            0x825B3050 => {
    //   block [0x825B3050..0x825B3058)
	// 825B3050: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B3054: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B3058; continue 'dispatch;
            }
            0x825B3058 => {
    //   block [0x825B3058..0x825B3064)
	// 825B3058: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B305C: 4199FFB8  bgt cr6, 0x825b3014
	if ctx.cr[6].gt {
	pc = 0x825B3014; continue 'dispatch;
	}
	// 825B3060: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B3064; continue 'dispatch;
            }
            0x825B3064 => {
    //   block [0x825B3064..0x825B3080)
	// 825B3064: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825B3068: 419A0040  beq cr6, 0x825b30a8
	if ctx.cr[6].eq {
	pc = 0x825B30A8; continue 'dispatch;
	}
	// 825B306C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3070: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B3074: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3078: 41990008  bgt cr6, 0x825b3080
	if ctx.cr[6].gt {
	pc = 0x825B3080; continue 'dispatch;
	}
	// 825B307C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B3080; continue 'dispatch;
            }
            0x825B3080 => {
    //   block [0x825B3080..0x825B30A8)
	// 825B3080: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B3084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3088: 409A0020  bne cr6, 0x825b30a8
	if !ctx.cr[6].eq {
	pc = 0x825B30A8; continue 'dispatch;
	}
	// 825B308C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B3090: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B3094: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3098: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B309C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B30A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B30A4: 4800001C  b 0x825b30c0
	pc = 0x825B30C0; continue 'dispatch;
            }
            0x825B30A8 => {
    //   block [0x825B30A8..0x825B30BC)
	// 825B30A8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B30AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B30B0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B30B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B30B8: 48000008  b 0x825b30c0
	pc = 0x825B30C0; continue 'dispatch;
            }
            0x825B30BC => {
    //   block [0x825B30BC..0x825B30C0)
	// 825B30BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B30C0; continue 'dispatch;
            }
            0x825B30C0 => {
    //   block [0x825B30C0..0x825B30F8)
	// 825B30C0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B30C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B30C8: 419A0030  beq cr6, 0x825b30f8
	if ctx.cr[6].eq {
	pc = 0x825B30F8; continue 'dispatch;
	}
	// 825B30CC: 81630014  lwz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B30D0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B30D4: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B30D8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B30DC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B30E0: 4E800421  bctrl
	ctx.lr = 0x825B30E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B30E4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B30E8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B30EC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B30F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B30F4: 4E800020  blr
	return;
            }
            0x825B30F8 => {
    //   block [0x825B30F8..0x825B3110)
	// 825B30F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B30FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3100: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3104: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3108: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B310C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B3110 size=384
    let mut pc: u32 = 0x825B3110;
    'dispatch: loop {
        match pc {
            0x825B3110 => {
    //   block [0x825B3110..0x825B3138)
	// 825B3110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3114: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3118: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B311C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B3120: 419A0018  beq cr6, 0x825b3138
	if ctx.cr[6].eq {
	pc = 0x825B3138; continue 'dispatch;
	}
	// 825B3124: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B3128: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B312C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3130: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B3134: 409A0008  bne cr6, 0x825b313c
	if !ctx.cr[6].eq {
	pc = 0x825B313C; continue 'dispatch;
	}
	pc = 0x825B3138; continue 'dispatch;
            }
            0x825B3138 => {
    //   block [0x825B3138..0x825B313C)
	// 825B3138: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B313C; continue 'dispatch;
            }
            0x825B313C => {
    //   block [0x825B313C..0x825B3184)
	// 825B313C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B3140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3144: 419A0134  beq cr6, 0x825b3278
	if ctx.cr[6].eq {
	pc = 0x825B3278; continue 'dispatch;
	}
	// 825B3148: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B314C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3150: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 825B3154: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B3158: 419A00EC  beq cr6, 0x825b3244
	if ctx.cr[6].eq {
	pc = 0x825B3244; continue 'dispatch;
	}
	// 825B315C: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B3160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3164: 419A0020  beq cr6, 0x825b3184
	if ctx.cr[6].eq {
	pc = 0x825B3184; continue 'dispatch;
	}
	// 825B3168: 894B0077  lbz r10, 0x77(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B316C: 81640048  lwz r11, 0x48(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B3170: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B3174: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B3178: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B317C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3180: 480000C8  b 0x825b3248
	pc = 0x825B3248; continue 'dispatch;
            }
            0x825B3184 => {
    //   block [0x825B3184..0x825B31A4)
	// 825B3184: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B3188: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B318C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B3190: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B3194: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B3198: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B319C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B31A0: 40810054  ble 0x825b31f4
	if !ctx.cr[0].gt {
	pc = 0x825B31F4; continue 'dispatch;
	}
	pc = 0x825B31A4; continue 'dispatch;
            }
            0x825B31A4 => {
    //   block [0x825B31A4..0x825B31C4)
	// 825B31A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B31A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B31AC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B31B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B31B4: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B31B8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B31BC: 41980008  blt cr6, 0x825b31c4
	if ctx.cr[6].lt {
	pc = 0x825B31C4; continue 'dispatch;
	}
	// 825B31C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B31C4; continue 'dispatch;
            }
            0x825B31C4 => {
    //   block [0x825B31C4..0x825B31E0)
	// 825B31C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B31C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B31CC: 419A0014  beq cr6, 0x825b31e0
	if ctx.cr[6].eq {
	pc = 0x825B31E0; continue 'dispatch;
	}
	// 825B31D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B31D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B31D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B31DC: 4800000C  b 0x825b31e8
	pc = 0x825B31E8; continue 'dispatch;
            }
            0x825B31E0 => {
    //   block [0x825B31E0..0x825B31E8)
	// 825B31E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B31E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B31E8; continue 'dispatch;
            }
            0x825B31E8 => {
    //   block [0x825B31E8..0x825B31F4)
	// 825B31E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B31EC: 4199FFB8  bgt cr6, 0x825b31a4
	if ctx.cr[6].gt {
	pc = 0x825B31A4; continue 'dispatch;
	}
	// 825B31F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B31F4; continue 'dispatch;
            }
            0x825B31F4 => {
    //   block [0x825B31F4..0x825B3210)
	// 825B31F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B31F8: 419A003C  beq cr6, 0x825b3234
	if ctx.cr[6].eq {
	pc = 0x825B3234; continue 'dispatch;
	}
	// 825B31FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3200: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B3204: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3208: 41990008  bgt cr6, 0x825b3210
	if ctx.cr[6].gt {
	pc = 0x825B3210; continue 'dispatch;
	}
	// 825B320C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B3210; continue 'dispatch;
            }
            0x825B3210 => {
    //   block [0x825B3210..0x825B3234)
	// 825B3210: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B3214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3218: 409A001C  bne cr6, 0x825b3234
	if !ctx.cr[6].eq {
	pc = 0x825B3234; continue 'dispatch;
	}
	// 825B321C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B3220: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B3224: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B3228: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B322C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3230: 48000018  b 0x825b3248
	pc = 0x825B3248; continue 'dispatch;
            }
            0x825B3234 => {
    //   block [0x825B3234..0x825B3244)
	// 825B3234: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B3238: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B323C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3240: 48000008  b 0x825b3248
	pc = 0x825B3248; continue 'dispatch;
            }
            0x825B3244 => {
    //   block [0x825B3244..0x825B3248)
	// 825B3244: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B3248; continue 'dispatch;
            }
            0x825B3248 => {
    //   block [0x825B3248..0x825B3278)
	// 825B3248: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B324C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B3250: 419A0028  beq cr6, 0x825b3278
	if ctx.cr[6].eq {
	pc = 0x825B3278; continue 'dispatch;
	}
	// 825B3254: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3258: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B325C: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B3260: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B3264: 4E800421  bctrl
	ctx.lr = 0x825B3268;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3268: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B326C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3270: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3274: 4E800020  blr
	return;
            }
            0x825B3278 => {
    //   block [0x825B3278..0x825B3290)
	// 825B3278: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B327C: C02B9484  lfs f1, -0x6b7c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 825B3280: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3284: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3288: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B328C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3290(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3290 size=392
    let mut pc: u32 = 0x825B3290;
    'dispatch: loop {
        match pc {
            0x825B3290 => {
    //   block [0x825B3290..0x825B32C4)
	// 825B3290: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3294: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3298: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B329C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B32A0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B32A4: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B32A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B32AC: 419A0018  beq cr6, 0x825b32c4
	if ctx.cr[6].eq {
	pc = 0x825B32C4; continue 'dispatch;
	}
	// 825B32B0: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B32B4: 55490672  rlwinm r9, r10, 0, 0x19, 0x19
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 825B32B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B32BC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B32C0: 409A0008  bne cr6, 0x825b32c8
	if !ctx.cr[6].eq {
	pc = 0x825B32C8; continue 'dispatch;
	}
	pc = 0x825B32C4; continue 'dispatch;
            }
            0x825B32C4 => {
    //   block [0x825B32C4..0x825B32C8)
	// 825B32C4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B32C8; continue 'dispatch;
            }
            0x825B32C8 => {
    //   block [0x825B32C8..0x825B3314)
	// 825B32C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B32CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B32D0: 419A0134  beq cr6, 0x825b3404
	if ctx.cr[6].eq {
	pc = 0x825B3404; continue 'dispatch;
	}
	// 825B32D4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B32D8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B32DC: 55284FFE  rlwinm r8, r9, 9, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x007FFFFFu64;
	// 825B32E0: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B32E4: 419A00F8  beq cr6, 0x825b33dc
	if ctx.cr[6].eq {
	pc = 0x825B33DC; continue 'dispatch;
	}
	// 825B32E8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B32EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B32F0: 419A0024  beq cr6, 0x825b3314
	if ctx.cr[6].eq {
	pc = 0x825B3314; continue 'dispatch;
	}
	// 825B32F4: 892A0077  lbz r9, 0x77(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B32F8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B32FC: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B3300: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B3304: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3308: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B330C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3310: 480000D0  b 0x825b33e0
	pc = 0x825B33E0; continue 'dispatch;
            }
            0x825B3314 => {
    //   block [0x825B3314..0x825B3334)
	// 825B3314: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B3318: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B331C: 83EB004C  lwz r31, 0x4c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B3320: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B3324: 7D0AF850  subf r8, r10, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[10].s64;
	// 825B3328: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B332C: 7D0B1E71  srawi. r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B3330: 40810054  ble 0x825b3384
	if !ctx.cr[0].gt {
	pc = 0x825B3384; continue 'dispatch;
	}
	pc = 0x825B3334; continue 'dispatch;
            }
            0x825B3334 => {
    //   block [0x825B3334..0x825B3354)
	// 825B3334: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B3338: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B333C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B3340: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3344: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B3348: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B334C: 41980008  blt cr6, 0x825b3354
	if ctx.cr[6].lt {
	pc = 0x825B3354; continue 'dispatch;
	}
	// 825B3350: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B3354; continue 'dispatch;
            }
            0x825B3354 => {
    //   block [0x825B3354..0x825B3370)
	// 825B3354: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B3358: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B335C: 419A0014  beq cr6, 0x825b3370
	if ctx.cr[6].eq {
	pc = 0x825B3370; continue 'dispatch;
	}
	// 825B3360: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B3364: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B3368: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B336C: 4800000C  b 0x825b3378
	pc = 0x825B3378; continue 'dispatch;
            }
            0x825B3370 => {
    //   block [0x825B3370..0x825B3378)
	// 825B3370: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B3374: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B3378; continue 'dispatch;
            }
            0x825B3378 => {
    //   block [0x825B3378..0x825B3384)
	// 825B3378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B337C: 4199FFB8  bgt cr6, 0x825b3334
	if ctx.cr[6].gt {
	pc = 0x825B3334; continue 'dispatch;
	}
	// 825B3380: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B3384; continue 'dispatch;
            }
            0x825B3384 => {
    //   block [0x825B3384..0x825B33A0)
	// 825B3384: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825B3388: 419A0040  beq cr6, 0x825b33c8
	if ctx.cr[6].eq {
	pc = 0x825B33C8; continue 'dispatch;
	}
	// 825B338C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3390: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B3394: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3398: 41990008  bgt cr6, 0x825b33a0
	if ctx.cr[6].gt {
	pc = 0x825B33A0; continue 'dispatch;
	}
	// 825B339C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B33A0; continue 'dispatch;
            }
            0x825B33A0 => {
    //   block [0x825B33A0..0x825B33C8)
	// 825B33A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B33A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B33A8: 409A0020  bne cr6, 0x825b33c8
	if !ctx.cr[6].eq {
	pc = 0x825B33C8; continue 'dispatch;
	}
	// 825B33AC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B33B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B33B4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B33B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B33BC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B33C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B33C4: 4800001C  b 0x825b33e0
	pc = 0x825B33E0; continue 'dispatch;
            }
            0x825B33C8 => {
    //   block [0x825B33C8..0x825B33DC)
	// 825B33C8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B33CC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B33D0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B33D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B33D8: 48000008  b 0x825b33e0
	pc = 0x825B33E0; continue 'dispatch;
            }
            0x825B33DC => {
    //   block [0x825B33DC..0x825B33E0)
	// 825B33DC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B33E0; continue 'dispatch;
            }
            0x825B33E0 => {
    //   block [0x825B33E0..0x825B3404)
	// 825B33E0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B33E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B33E8: 419A001C  beq cr6, 0x825b3404
	if ctx.cr[6].eq {
	pc = 0x825B3404; continue 'dispatch;
	}
	// 825B33EC: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B33F0: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B33F4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B33F8: 7C6B5214  add r3, r11, r10
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B33FC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B3400: 4E800421  bctrl
	ctx.lr = 0x825B3404;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B3404 => {
    //   block [0x825B3404..0x825B3418)
	// 825B3404: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3408: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B340C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3418 size=376
    let mut pc: u32 = 0x825B3418;
    'dispatch: loop {
        match pc {
            0x825B3418 => {
    //   block [0x825B3418..0x825B3440)
	// 825B3418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B341C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3420: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3424: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B3428: 419A0018  beq cr6, 0x825b3440
	if ctx.cr[6].eq {
	pc = 0x825B3440; continue 'dispatch;
	}
	// 825B342C: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B3430: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825B3434: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B3438: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B343C: 409A0008  bne cr6, 0x825b3444
	if !ctx.cr[6].eq {
	pc = 0x825B3444; continue 'dispatch;
	}
	pc = 0x825B3440; continue 'dispatch;
            }
            0x825B3440 => {
    //   block [0x825B3440..0x825B3444)
	// 825B3440: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B3444; continue 'dispatch;
            }
            0x825B3444 => {
    //   block [0x825B3444..0x825B348C)
	// 825B3444: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B3448: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B344C: 419A0130  beq cr6, 0x825b357c
	if ctx.cr[6].eq {
	pc = 0x825B357C; continue 'dispatch;
	}
	// 825B3450: 81440030  lwz r10, 0x30(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B3454: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3458: 55494FFE  rlwinm r9, r10, 9, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x007FFFFFu64;
	// 825B345C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B3460: 419A00E8  beq cr6, 0x825b3548
	if ctx.cr[6].eq {
	pc = 0x825B3548; continue 'dispatch;
	}
	// 825B3464: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B3468: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B346C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3470: 419A001C  beq cr6, 0x825b348c
	if ctx.cr[6].eq {
	pc = 0x825B348C; continue 'dispatch;
	}
	// 825B3474: 896B0077  lbz r11, 0x77(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(119 as u32) ) } as u64;
	// 825B3478: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825B347C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B3480: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3484: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B3488: 480000C4  b 0x825b354c
	pc = 0x825B354C; continue 'dispatch;
            }
            0x825B348C => {
    //   block [0x825B348C..0x825B34A8)
	// 825B348C: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B3490: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3494: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B3498: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B349C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B34A0: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B34A4: 40810054  ble 0x825b34f8
	if !ctx.cr[0].gt {
	pc = 0x825B34F8; continue 'dispatch;
	}
	pc = 0x825B34A8; continue 'dispatch;
            }
            0x825B34A8 => {
    //   block [0x825B34A8..0x825B34C8)
	// 825B34A8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B34AC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B34B0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B34B4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B34B8: 2F070077  cmpwi cr6, r7, 0x77
	ctx.cr[6].compare_i32(ctx.r[7].s32, 119, &mut ctx.xer);
	// 825B34BC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B34C0: 41980008  blt cr6, 0x825b34c8
	if ctx.cr[6].lt {
	pc = 0x825B34C8; continue 'dispatch;
	}
	// 825B34C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B34C8; continue 'dispatch;
            }
            0x825B34C8 => {
    //   block [0x825B34C8..0x825B34E4)
	// 825B34C8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B34CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B34D0: 419A0014  beq cr6, 0x825b34e4
	if ctx.cr[6].eq {
	pc = 0x825B34E4; continue 'dispatch;
	}
	// 825B34D4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B34D8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B34DC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B34E0: 4800000C  b 0x825b34ec
	pc = 0x825B34EC; continue 'dispatch;
            }
            0x825B34E4 => {
    //   block [0x825B34E4..0x825B34EC)
	// 825B34E4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B34E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B34EC; continue 'dispatch;
            }
            0x825B34EC => {
    //   block [0x825B34EC..0x825B34F8)
	// 825B34EC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B34F0: 4199FFB8  bgt cr6, 0x825b34a8
	if ctx.cr[6].gt {
	pc = 0x825B34A8; continue 'dispatch;
	}
	// 825B34F4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B34F8; continue 'dispatch;
            }
            0x825B34F8 => {
    //   block [0x825B34F8..0x825B3514)
	// 825B34F8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B34FC: 419A003C  beq cr6, 0x825b3538
	if ctx.cr[6].eq {
	pc = 0x825B3538; continue 'dispatch;
	}
	// 825B3500: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3504: 2F0B0077  cmpwi cr6, r11, 0x77
	ctx.cr[6].compare_i32(ctx.r[11].s32, 119, &mut ctx.xer);
	// 825B3508: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B350C: 41990008  bgt cr6, 0x825b3514
	if ctx.cr[6].gt {
	pc = 0x825B3514; continue 'dispatch;
	}
	// 825B3510: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B3514; continue 'dispatch;
            }
            0x825B3514 => {
    //   block [0x825B3514..0x825B3538)
	// 825B3514: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B3518: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B351C: 409A001C  bne cr6, 0x825b3538
	if !ctx.cr[6].eq {
	pc = 0x825B3538; continue 'dispatch;
	}
	// 825B3520: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B3524: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B3528: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B352C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3530: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3534: 48000018  b 0x825b354c
	pc = 0x825B354C; continue 'dispatch;
            }
            0x825B3538 => {
    //   block [0x825B3538..0x825B3548)
	// 825B3538: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B353C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B3540: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B3544: 48000008  b 0x825b354c
	pc = 0x825B354C; continue 'dispatch;
            }
            0x825B3548 => {
    //   block [0x825B3548..0x825B354C)
	// 825B3548: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B354C; continue 'dispatch;
            }
            0x825B354C => {
    //   block [0x825B354C..0x825B357C)
	// 825B354C: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B3550: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B3554: 419A0028  beq cr6, 0x825b357c
	if ctx.cr[6].eq {
	pc = 0x825B357C; continue 'dispatch;
	}
	// 825B3558: 81430014  lwz r10, 0x14(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B355C: 81230010  lwz r9, 0x10(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B3560: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B3564: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825B3568: 4E800421  bctrl
	ctx.lr = 0x825B356C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B356C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3570: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3574: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3578: 4E800020  blr
	return;
            }
            0x825B357C => {
    //   block [0x825B357C..0x825B3590)
	// 825B357C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B3580: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3584: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3588: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B358C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3590 size=56
    let mut pc: u32 = 0x825B3590;
    'dispatch: loop {
        match pc {
            0x825B3590 => {
    //   block [0x825B3590..0x825B35C8)
	// 825B3590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3598: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B359C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 825B35A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B35A4: 4BC74B55  bl 0x822280f8
	ctx.lr = 0x825B35A8;
	sub_822280F8(ctx, base);
	// 825B35A8: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 825B35AC: 80830004  lwz r4, 4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B35B0: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B35B4: 48000165  bl 0x825b3718
	ctx.lr = 0x825B35B8;
	sub_825B3718(ctx, base);
	// 825B35B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B35BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B35C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B35C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B35C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B35C8 size=164
    let mut pc: u32 = 0x825B35C8;
    'dispatch: loop {
        match pc {
            0x825B35C8 => {
    //   block [0x825B35C8..0x825B366C)
	// 825B35C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B35CC: 486F5E3D  bl 0x82ca9408
	ctx.lr = 0x825B35D0;
	sub_82CA93D0(ctx, base);
	// 825B35D0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B35D4: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 825B35D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B35DC: 4BC74B1D  bl 0x822280f8
	ctx.lr = 0x825B35E0;
	sub_822280F8(ctx, base);
	// 825B35E0: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 825B35E4: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 825B35E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B35EC: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B35F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B35F4: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 825B35F8: 83CA0004  lwz r30, 4(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B35FC: 83AA0000  lwz r29, 0(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3600: 4BC74AF9  bl 0x822280f8
	ctx.lr = 0x825B3604;
	sub_822280F8(ctx, base);
	// 825B3604: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3608: 4BC73F59  bl 0x82227560
	ctx.lr = 0x825B360C;
	sub_82227560(ctx, base);
	// 825B360C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825B3610: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B3614: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B3618: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B361C: 4BD4E8DD  bl 0x82301ef8
	ctx.lr = 0x825B3620;
	sub_82301EF8(ctx, base);
	// 825B3620: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B3624: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B3628: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 825B362C: 4E800421  bctrl
	ctx.lr = 0x825B3630;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3630: 78680020  clrldi r8, r3, 0x20
	ctx.r[8].u64 = ctx.r[3].u64 & 0x00000000FFFFFFFFu64;
	// 825B3634: 80FF0008  lwz r7, 8(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B3638: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825B363C: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 825B3640: C8010058  lfd f0, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B3644: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825B3648: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B364C: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825B3650: D1870000  stfs f12, 0(r7)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B3654: 90C70004  stw r6, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825B3658: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B365C: 38AB0008  addi r5, r11, 8
	ctx.r[5].s64 = ctx.r[11].s64 + 8;
	// 825B3660: 90BF0008  stw r5, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825B3664: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B3668: 486F5DF0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3670(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3670 size=164
    let mut pc: u32 = 0x825B3670;
    'dispatch: loop {
        match pc {
            0x825B3670 => {
    //   block [0x825B3670..0x825B3714)
	// 825B3670: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3674: 486F5D91  bl 0x82ca9404
	ctx.lr = 0x825B3678;
	sub_82CA93D0(ctx, base);
	// 825B3678: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B367C: 3880D8ED  li r4, -0x2713
	ctx.r[4].s64 = -10003;
	// 825B3680: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3684: 4BC74A75  bl 0x822280f8
	ctx.lr = 0x825B3688;
	sub_822280F8(ctx, base);
	// 825B3688: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B368C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 825B3690: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 825B3694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3698: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B369C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B36A0: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825B36A4: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825B36A8: 83C80004  lwz r30, 4(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B36AC: 83A80000  lwz r29, 0(r8)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B36B0: 4BC74A49  bl 0x822280f8
	ctx.lr = 0x825B36B4;
	sub_822280F8(ctx, base);
	// 825B36B4: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B36B8: 4BC73EA9  bl 0x82227560
	ctx.lr = 0x825B36BC;
	sub_82227560(ctx, base);
	// 825B36BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B36C0: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825B36C4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B36C8: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B36CC: 4BD4E7CD  bl 0x82301e98
	ctx.lr = 0x825B36D0;
	sub_82301E98(ctx, base);
	// 825B36D0: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B36D4: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 825B36D8: 88810051  lbz r4, 0x51(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825B36DC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825B36E0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B36E4: 4BD4E99D  bl 0x82302080
	ctx.lr = 0x825B36E8;
	sub_82302080(ctx, base);
	// 825B36E8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B36EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B36F0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B36F4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B36F8: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 825B36FC: 4E800421  bctrl
	ctx.lr = 0x825B3700;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B3700: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B3704: 4BC04415  bl 0x821b7b18
	ctx.lr = 0x825B3708;
	sub_821B7B18(ctx, base);
	// 825B3708: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B370C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B3710: 486F5D44  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3718 size=224
    let mut pc: u32 = 0x825B3718;
    'dispatch: loop {
        match pc {
            0x825B3718 => {
    //   block [0x825B3718..0x825B37F8)
	// 825B3718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B371C: 486F5CE9  bl 0x82ca9404
	ctx.lr = 0x825B3720;
	sub_82CA93D0(ctx, base);
	// 825B3720: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 825B3724: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3728: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 825B372C: 39210051  addi r9, r1, 0x51
	ctx.r[9].s64 = ctx.r[1].s64 + 81;
	// 825B3730: 39010052  addi r8, r1, 0x52
	ctx.r[8].s64 = ctx.r[1].s64 + 82;
	// 825B3734: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B3738: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B373C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3740: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3744: 996A0000  stb r11, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825B3748: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B374C: 99690000  stb r11, 0(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825B3750: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B3754: 99680000  stb r11, 0(r8)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u8 ) };
	// 825B3758: 4BC749A1  bl 0x822280f8
	ctx.lr = 0x825B375C;
	sub_822280F8(ctx, base);
	// 825B375C: 80630000  lwz r3, 0(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3760: 4BC73E01  bl 0x82227560
	ctx.lr = 0x825B3764;
	sub_82227560(ctx, base);
	// 825B3764: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 825B3768: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B376C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B3770: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B3774: 4BD4E785  bl 0x82301ef8
	ctx.lr = 0x825B3778;
	sub_82301EF8(ctx, base);
	// 825B3778: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 825B377C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B3780: 88610051  lbz r3, 0x51(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(81 as u32) ) } as u64;
	// 825B3784: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 825B3788: 4BD72F01  bl 0x82326688
	ctx.lr = 0x825B378C;
	sub_82326688(ctx, base);
	// 825B378C: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825B3790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B3794: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B3798: 88610052  lbz r3, 0x52(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(82 as u32) ) } as u64;
	// 825B379C: 4BD72EED  bl 0x82326688
	ctx.lr = 0x825B37A0;
	sub_82326688(ctx, base);
	// 825B37A0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B37A4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B37A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825B37AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B37B0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825B37B4: 7FC903A6  mtctr r30
	ctx.ctr.u64 = ctx.r[30].u64;
	// 825B37B8: 4E800421  bctrl
	ctx.lr = 0x825B37BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825B37BC: 5467063E  clrlwi r7, r3, 0x18
	ctx.r[7].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B37C0: 80DD0008  lwz r6, 8(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B37C4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B37C8: 7CE40034  cntlzw r4, r7
	ctx.r[4].u64 = if ctx.r[7].u32 == 0 { 32 } else { ctx.r[7].u32.leading_zeros() as u64 };
	// 825B37CC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B37D0: 548BDFFE  rlwinm r11, r4, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x0000001Fu64;
	// 825B37D4: 696A0001  xori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 ^ 1;
	// 825B37D8: 90A60004  stw r5, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825B37DC: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B37E0: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B37E4: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 825B37E8: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825B37EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B37F0: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 825B37F4: 486F5C60  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B37F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B37F8 size=60
    let mut pc: u32 = 0x825B37F8;
    'dispatch: loop {
        match pc {
            0x825B37F8 => {
    //   block [0x825B37F8..0x825B3834)
	// 825B37F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B37FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3800: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3804: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3808: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B380C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B3810: 388B86F8  addi r4, r11, -0x7908
	ctx.r[4].s64 = ctx.r[11].s64 + -30984;
	// 825B3814: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3818: 4BC796B9  bl 0x8222ced0
	ctx.lr = 0x825B381C;
	sub_8222CED0(ctx, base);
	// 825B381C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3820: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3824: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3828: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B382C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3830: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3838(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825B3838 size=116
    let mut pc: u32 = 0x825B3838;
    'dispatch: loop {
        match pc {
            0x825B3838 => {
    //   block [0x825B3838..0x825B38AC)
	// 825B3838: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B383C: D0230008  stfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825B3840: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825B3844: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825B3848: 90A30004  stw r5, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825B384C: 80E10054  lwz r7, 0x54(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B3850: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B3854: 88C80003  lbz r6, 3(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B3858: C00A9490  lfs f0, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B385C: 88A80000  lbz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3860: 88880001  lbz r4, 1(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B3864: 89680002  lbz r11, 2(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B3868: 99630012  stb r11, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[11].u8 ) };
	// 825B386C: 98830011  stb r4, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[4].u8 ) };
	// 825B3870: 98A30010  stb r5, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[5].u8 ) };
	// 825B3874: 98C30013  stb r6, 0x13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(19 as u32), ctx.r[6].u8 ) };
	// 825B3878: 89490003  lbz r10, 3(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B387C: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B3880: 88C90001  lbz r6, 1(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B3884: 88A90002  lbz r5, 2(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B3888: 98A30016  stb r5, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[5].u8 ) };
	// 825B388C: 98C30015  stb r6, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[6].u8 ) };
	// 825B3890: 99030014  stb r8, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825B3894: 99430017  stb r10, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[10].u8 ) };
	// 825B3898: D0430018  stfs f2, 0x18(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825B389C: 80870000  lwz r4, 0(r7)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B38A0: 9083001C  stw r4, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[4].u32 ) };
	// 825B38A4: D0030020  stfs f0, 0x20(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825B38A8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B38B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B38B0 size=104
    let mut pc: u32 = 0x825B38B0;
    'dispatch: loop {
        match pc {
            0x825B38B0 => {
    //   block [0x825B38B0..0x825B3918)
	// 825B38B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B38B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B38B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B38BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B38C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B38C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B38C8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B38CC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B38D0: 392B5790  addi r9, r11, 0x5790
	ctx.r[9].s64 = ctx.r[11].s64 + 22416;
	// 825B38D4: 387F0010  addi r3, r31, 0x10
	ctx.r[3].s64 = ctx.r[31].s64 + 16;
	// 825B38D8: 909F0008  stw r4, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825B38DC: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 825B38E0: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B38E4: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 825B38E8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B38EC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B38F0: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B38F4: 48006465  bl 0x825b9d58
	ctx.lr = 0x825B38F8;
	sub_825B9D58(ctx, base);
	// 825B38F8: 9BDF0020  stb r30, 0x20(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u8 ) };
	// 825B38FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3900: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3904: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3908: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B390C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B3910: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3914: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3918(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3918 size=80
    let mut pc: u32 = 0x825B3918;
    'dispatch: loop {
        match pc {
            0x825B3918 => {
    //   block [0x825B3918..0x825B3950)
	// 825B3918: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B391C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3920: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B3924: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B392C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3930: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3934: 48000035  bl 0x825b3968
	ctx.lr = 0x825B3938;
	sub_825B3968(ctx, base);
	// 825B3938: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825B393C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3944: 419A000C  beq cr6, 0x825b3950
	if ctx.cr[6].eq {
	pc = 0x825B3950; continue 'dispatch;
	}
	// 825B3948: 4BC683F1  bl 0x8221bd38
	ctx.lr = 0x825B394C;
	sub_8221BD38(ctx, base);
	// 825B394C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825B3950; continue 'dispatch;
            }
            0x825B3950 => {
    //   block [0x825B3950..0x825B3968)
	// 825B3950: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3954: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3958: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B395C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B3960: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3964: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3968(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3968 size=96
    let mut pc: u32 = 0x825B3968;
    'dispatch: loop {
        match pc {
            0x825B3968 => {
    //   block [0x825B3968..0x825B3994)
	// 825B3968: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B396C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3970: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B3974: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3978: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B397C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B3980: 3BFE0010  addi r31, r30, 0x10
	ctx.r[31].s64 = ctx.r[30].s64 + 16;
	// 825B3984: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B3988: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B398C: 419A0008  beq cr6, 0x825b3994
	if ctx.cr[6].eq {
	pc = 0x825B3994; continue 'dispatch;
	}
	// 825B3990: 4BC683A9  bl 0x8221bd38
	ctx.lr = 0x825B3994;
	sub_8221BD38(ctx, base);
	pc = 0x825B3994; continue 'dispatch;
            }
            0x825B3994 => {
    //   block [0x825B3994..0x825B39C8)
	// 825B3994: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825B3998: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B399C: 392A6A70  addi r9, r10, 0x6a70
	ctx.r[9].s64 = ctx.r[10].s64 + 27248;
	// 825B39A0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B39A4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B39A8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B39AC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B39B0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B39B4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B39B8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B39BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B39C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B39C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B39C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B39C8 size=80
    let mut pc: u32 = 0x825B39C8;
    'dispatch: loop {
        match pc {
            0x825B39C8 => {
    //   block [0x825B39C8..0x825B3A18)
	// 825B39C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B39CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B39D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B39D4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B39D8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B39DC: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B39E0: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825B39E4: 392A57A4  addi r9, r10, 0x57a4
	ctx.r[9].s64 = ctx.r[10].s64 + 22436;
	// 825B39E8: 387F0008  addi r3, r31, 8
	ctx.r[3].s64 = ctx.r[31].s64 + 8;
	// 825B39EC: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B39F0: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B39F4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B39F8: 911F0004  stw r8, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B39FC: 48006B75  bl 0x825ba570
	ctx.lr = 0x825B3A00;
	sub_825BA570(ctx, base);
	// 825B3A00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3A04: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B3A08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3A0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3A10: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3A14: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3A18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3A18 size=80
    let mut pc: u32 = 0x825B3A18;
    'dispatch: loop {
        match pc {
            0x825B3A18 => {
    //   block [0x825B3A18..0x825B3A50)
	// 825B3A18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3A1C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3A20: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B3A24: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3A28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3A2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B3A30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B3A34: 48000035  bl 0x825b3a68
	ctx.lr = 0x825B3A38;
	sub_825B3A68(ctx, base);
	// 825B3A38: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825B3A3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B3A40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B3A44: 419A000C  beq cr6, 0x825b3a50
	if ctx.cr[6].eq {
	pc = 0x825B3A50; continue 'dispatch;
	}
	// 825B3A48: 4BC682F1  bl 0x8221bd38
	ctx.lr = 0x825B3A4C;
	sub_8221BD38(ctx, base);
	// 825B3A4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825B3A50; continue 'dispatch;
            }
            0x825B3A50 => {
    //   block [0x825B3A50..0x825B3A68)
	// 825B3A50: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3A54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3A58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3A5C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B3A60: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3A64: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3A68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B3A68 size=96
    let mut pc: u32 = 0x825B3A68;
    'dispatch: loop {
        match pc {
            0x825B3A68 => {
    //   block [0x825B3A68..0x825B3A94)
	// 825B3A68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3A6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B3A70: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B3A74: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B3A78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B3A7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B3A80: 3BFE0008  addi r31, r30, 8
	ctx.r[31].s64 = ctx.r[30].s64 + 8;
	// 825B3A84: 807E000C  lwz r3, 0xc(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B3A88: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B3A8C: 419A0008  beq cr6, 0x825b3a94
	if ctx.cr[6].eq {
	pc = 0x825B3A94; continue 'dispatch;
	}
	// 825B3A90: 4BC682A9  bl 0x8221bd38
	ctx.lr = 0x825B3A94;
	sub_8221BD38(ctx, base);
	pc = 0x825B3A94; continue 'dispatch;
            }
            0x825B3A94 => {
    //   block [0x825B3A94..0x825B3AC8)
	// 825B3A94: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 825B3A98: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B3A9C: 392A44B0  addi r9, r10, 0x44b0
	ctx.r[9].s64 = ctx.r[10].s64 + 17584;
	// 825B3AA0: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B3AA4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B3AA8: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B3AAC: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B3AB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B3AB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B3AB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B3ABC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B3AC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B3AC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B3AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825B3AC8 size=1356
    let mut pc: u32 = 0x825B3AC8;
    'dispatch: loop {
        match pc {
            0x825B3AC8 => {
    //   block [0x825B3AC8..0x825B4014)
	// 825B3AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B3ACC: 486F5935  bl 0x82ca9400
	ctx.lr = 0x825B3AD0;
	sub_82CA93D0(ctx, base);
	// 825B3AD0: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825B3AD4: 3980FFA0  li r12, -0x60
	ctx.r[12].s64 = -96;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4018 size=256
    let mut pc: u32 = 0x825B4018;
    'dispatch: loop {
        match pc {
            0x825B4018 => {
    //   block [0x825B4018..0x825B4118)
	// 825B4018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B401C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B4024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B4028: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B402C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4030: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4034: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 825B4038: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825B403C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B4040: 390B388C  addi r8, r11, 0x388c
	ctx.r[8].s64 = ctx.r[11].s64 + 14476;
	// 825B4044: 909F0004  stw r4, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825B4048: 38EA41F8  addi r7, r10, 0x41f8
	ctx.r[7].s64 = ctx.r[10].s64 + 16888;
	// 825B404C: 9BDF0008  stb r30, 8(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[30].u8 ) };
	// 825B4050: 38C92A54  addi r6, r9, 0x2a54
	ctx.r[6].s64 = ctx.r[9].s64 + 10836;
	// 825B4054: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B4058: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825B405C: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 825B4060: 90DF000C  stw r6, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 825B4064: 93DF0014  stw r30, 0x14(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 825B4068: 93DF0018  stw r30, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[30].u32 ) };
	// 825B406C: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	// 825B4070: 93DF0020  stw r30, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[30].u32 ) };
	// 825B4074: 93DF0028  stw r30, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[30].u32 ) };
	// 825B4078: 93DF002C  stw r30, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[30].u32 ) };
	// 825B407C: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 825B4080: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 825B4084: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 825B4088: 93DF0040  stw r30, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[30].u32 ) };
	// 825B408C: 93DF0048  stw r30, 0x48(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), ctx.r[30].u32 ) };
	// 825B4090: 93DF004C  stw r30, 0x4c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), ctx.r[30].u32 ) };
	// 825B4094: 93DF0050  stw r30, 0x50(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B4098: 93DF0058  stw r30, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825B409C: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 825B40A0: 93DF0060  stw r30, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825B40A4: 93DF0068  stw r30, 0x68(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 825B40A8: 93DF006C  stw r30, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[30].u32 ) };
	// 825B40AC: 93DF0070  stw r30, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	// 825B40B0: 93DF0074  stw r30, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[30].u32 ) };
	// 825B40B4: 93DF0078  stw r30, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	// 825B40B8: 93DF0080  stw r30, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[30].u32 ) };
	// 825B40BC: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 825B40C0: 93DF0088  stw r30, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 825B40C4: 9BDF008D  stb r30, 0x8d(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(141 as u32), ctx.r[30].u8 ) };
	// 825B40C8: 93DF0094  stw r30, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 825B40CC: 93DF0098  stw r30, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 825B40D0: 93DF009C  stw r30, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[30].u32 ) };
	// 825B40D4: 9BDF00A1  stb r30, 0xa1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(161 as u32), ctx.r[30].u8 ) };
	// 825B40D8: 484564D9  bl 0x82a0a5b0
	ctx.lr = 0x825B40DC;
	sub_82A0A5B0(ctx, base);
	// 825B40DC: 9BDF00B0  stb r30, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[30].u8 ) };
	// 825B40E0: 9BDF00B1  stb r30, 0xb1(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(177 as u32), ctx.r[30].u8 ) };
	// 825B40E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B40E8: 9BDF00B2  stb r30, 0xb2(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(178 as u32), ctx.r[30].u8 ) };
	// 825B40EC: 9BDF00B3  stb r30, 0xb3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(179 as u32), ctx.r[30].u8 ) };
	// 825B40F0: 93DF00B4  stw r30, 0xb4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), ctx.r[30].u32 ) };
	// 825B40F4: 93DF00B8  stw r30, 0xb8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[30].u32 ) };
	// 825B40F8: 93DF00BC  stw r30, 0xbc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), ctx.r[30].u32 ) };
	// 825B40FC: 93DF00C0  stw r30, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 825B4100: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4104: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4108: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B410C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B4110: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4114: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4118(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4118 size=80
    let mut pc: u32 = 0x825B4118;
    'dispatch: loop {
        match pc {
            0x825B4118 => {
    //   block [0x825B4118..0x825B4150)
	// 825B4118: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B411C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4120: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B4124: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B4128: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B412C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4130: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B4134: 48000035  bl 0x825b4168
	ctx.lr = 0x825B4138;
	sub_825B4168(ctx, base);
	// 825B4138: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 825B413C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4144: 419A000C  beq cr6, 0x825b4150
	if ctx.cr[6].eq {
	pc = 0x825B4150; continue 'dispatch;
	}
	// 825B4148: 4BC67BF1  bl 0x8221bd38
	ctx.lr = 0x825B414C;
	sub_8221BD38(ctx, base);
	// 825B414C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825B4150; continue 'dispatch;
            }
            0x825B4150 => {
    //   block [0x825B4150..0x825B4168)
	// 825B4150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B415C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B4160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4168 size=336
    let mut pc: u32 = 0x825B4168;
    'dispatch: loop {
        match pc {
            0x825B4168 => {
    //   block [0x825B4168..0x825B419C)
	// 825B4168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B416C: 486F529D  bl 0x82ca9408
	ctx.lr = 0x825B4170;
	sub_82CA93D0(ctx, base);
	// 825B4170: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4174: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B4178: 387E00BC  addi r3, r30, 0xbc
	ctx.r[3].s64 = ctx.r[30].s64 + 188;
	// 825B417C: 4BC0399D  bl 0x821b7b18
	ctx.lr = 0x825B4180;
	sub_821B7B18(ctx, base);
	// 825B4180: 387E00A4  addi r3, r30, 0xa4
	ctx.r[3].s64 = ctx.r[30].s64 + 164;
	// 825B4184: 4BD5F61D  bl 0x823137a0
	ctx.lr = 0x825B4188;
	sub_823137A0(ctx, base);
	// 825B4188: 807E0094  lwz r3, 0x94(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B418C: 3B9E0090  addi r28, r30, 0x90
	ctx.r[28].s64 = ctx.r[30].s64 + 144;
	// 825B4190: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4194: 419A0008  beq cr6, 0x825b419c
	if ctx.cr[6].eq {
	pc = 0x825B419C; continue 'dispatch;
	}
	// 825B4198: 4BC67BA1  bl 0x8221bd38
	ctx.lr = 0x825B419C;
	sub_8221BD38(ctx, base);
	pc = 0x825B419C; continue 'dispatch;
            }
            0x825B419C => {
    //   block [0x825B419C..0x825B41C0)
	// 825B419C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B41A0: 3BBE007C  addi r29, r30, 0x7c
	ctx.r[29].s64 = ctx.r[30].s64 + 124;
	// 825B41A4: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B41A8: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B41AC: 93FC000C  stw r31, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B41B0: 807E0080  lwz r3, 0x80(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B41B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B41B8: 419A0008  beq cr6, 0x825b41c0
	if ctx.cr[6].eq {
	pc = 0x825B41C0; continue 'dispatch;
	}
	// 825B41BC: 4BC67B7D  bl 0x8221bd38
	ctx.lr = 0x825B41C0;
	sub_8221BD38(ctx, base);
	pc = 0x825B41C0; continue 'dispatch;
            }
            0x825B41C0 => {
    //   block [0x825B41C0..0x825B41F0)
	// 825B41C0: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B41C4: 387E0074  addi r3, r30, 0x74
	ctx.r[3].s64 = ctx.r[30].s64 + 116;
	// 825B41C8: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B41CC: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B41D0: 4BC03949  bl 0x821b7b18
	ctx.lr = 0x825B41D4;
	sub_821B7B18(ctx, base);
	// 825B41D4: 387E0064  addi r3, r30, 0x64
	ctx.r[3].s64 = ctx.r[30].s64 + 100;
	// 825B41D8: 4BD63C71  bl 0x82317e48
	ctx.lr = 0x825B41DC;
	sub_82317E48(ctx, base);
	// 825B41DC: 807E0058  lwz r3, 0x58(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B41E0: 3BBE0054  addi r29, r30, 0x54
	ctx.r[29].s64 = ctx.r[30].s64 + 84;
	// 825B41E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B41E8: 419A0008  beq cr6, 0x825b41f0
	if ctx.cr[6].eq {
	pc = 0x825B41F0; continue 'dispatch;
	}
	// 825B41EC: 4BC67B4D  bl 0x8221bd38
	ctx.lr = 0x825B41F0;
	sub_8221BD38(ctx, base);
	pc = 0x825B41F0; continue 'dispatch;
            }
            0x825B41F0 => {
    //   block [0x825B41F0..0x825B4210)
	// 825B41F0: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B41F4: 3B9E0044  addi r28, r30, 0x44
	ctx.r[28].s64 = ctx.r[30].s64 + 68;
	// 825B41F8: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B41FC: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B4200: 807E0048  lwz r3, 0x48(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4204: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4208: 419A0008  beq cr6, 0x825b4210
	if ctx.cr[6].eq {
	pc = 0x825B4210; continue 'dispatch;
	}
	// 825B420C: 4BC67B2D  bl 0x8221bd38
	ctx.lr = 0x825B4210;
	sub_8221BD38(ctx, base);
	pc = 0x825B4210; continue 'dispatch;
            }
            0x825B4210 => {
    //   block [0x825B4210..0x825B4240)
	// 825B4210: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B4214: 3BBE0034  addi r29, r30, 0x34
	ctx.r[29].s64 = ctx.r[30].s64 + 52;
	// 825B4218: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B421C: 93FC000C  stw r31, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B4220: 809E0038  lwz r4, 0x38(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) } as u64;
	// 825B4224: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4228: 419A0018  beq cr6, 0x825b4240
	if ctx.cr[6].eq {
	pc = 0x825B4240; continue 'dispatch;
	}
	// 825B422C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B4230: 80BD0008  lwz r5, 8(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4234: 4BF12E7D  bl 0x824c70b0
	ctx.lr = 0x825B4238;
	sub_824C70B0(ctx, base);
	// 825B4238: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B423C: 4BC67AFD  bl 0x8221bd38
	ctx.lr = 0x825B4240;
	sub_8221BD38(ctx, base);
	pc = 0x825B4240; continue 'dispatch;
            }
            0x825B4240 => {
    //   block [0x825B4240..0x825B4260)
	// 825B4240: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B4244: 3B9E0024  addi r28, r30, 0x24
	ctx.r[28].s64 = ctx.r[30].s64 + 36;
	// 825B4248: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B424C: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B4250: 807E0028  lwz r3, 0x28(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B4254: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4258: 419A0008  beq cr6, 0x825b4260
	if ctx.cr[6].eq {
	pc = 0x825B4260; continue 'dispatch;
	}
	// 825B425C: 4BC67ADD  bl 0x8221bd38
	ctx.lr = 0x825B4260;
	sub_8221BD38(ctx, base);
	pc = 0x825B4260; continue 'dispatch;
            }
            0x825B4260 => {
    //   block [0x825B4260..0x825B4280)
	// 825B4260: 93FC0004  stw r31, 4(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B4264: 3BBE0010  addi r29, r30, 0x10
	ctx.r[29].s64 = ctx.r[30].s64 + 16;
	// 825B4268: 93FC0008  stw r31, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B426C: 93FC000C  stw r31, 0xc(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B4270: 807E0014  lwz r3, 0x14(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B4274: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4278: 419A0008  beq cr6, 0x825b4280
	if ctx.cr[6].eq {
	pc = 0x825B4280; continue 'dispatch;
	}
	// 825B427C: 4BC67ABD  bl 0x8221bd38
	ctx.lr = 0x825B4280;
	sub_8221BD38(ctx, base);
	pc = 0x825B4280; continue 'dispatch;
            }
            0x825B4280 => {
    //   block [0x825B4280..0x825B4298)
	// 825B4280: 93FD0004  stw r31, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825B4284: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4288: 93FD0008  stw r31, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825B428C: 93FD000C  stw r31, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
	// 825B4290: 419A0008  beq cr6, 0x825b4298
	if ctx.cr[6].eq {
	pc = 0x825B4298; continue 'dispatch;
	}
	// 825B4294: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	pc = 0x825B4298; continue 'dispatch;
            }
            0x825B4298 => {
    //   block [0x825B4298..0x825B42B8)
	// 825B4298: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B429C: 3D40820B  lis r10, -0x7df5
	ctx.r[10].s64 = -2113208320;
	// 825B42A0: 392B388C  addi r9, r11, 0x388c
	ctx.r[9].s64 = ctx.r[11].s64 + 14476;
	// 825B42A4: 390A2850  addi r8, r10, 0x2850
	ctx.r[8].s64 = ctx.r[10].s64 + 10320;
	// 825B42A8: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B42AC: 911E0000  stw r8, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B42B0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B42B4: 486F51A4  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B42B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B42B8 size=468
    let mut pc: u32 = 0x825B42B8;
    'dispatch: loop {
        match pc {
            0x825B42B8 => {
    //   block [0x825B42B8..0x825B4310)
	// 825B42B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B42BC: 486F5149  bl 0x82ca9404
	ctx.lr = 0x825B42C0;
	sub_82CA93D0(ctx, base);
	// 825B42C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B42C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B42C8: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B42CC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B42D0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825B42D4: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825B42D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B42DC: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B42E0: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825B42E4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B42E8: 419A00D8  beq cr6, 0x825b43c0
	if ctx.cr[6].eq {
	pc = 0x825B43C0; continue 'dispatch;
	}
	// 825B42EC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B42F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B42F4: 419A001C  beq cr6, 0x825b4310
	if ctx.cr[6].eq {
	pc = 0x825B4310; continue 'dispatch;
	}
	// 825B42F8: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B42FC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4300: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B4304: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B4308: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B430C: 480000B0  b 0x825b43bc
	pc = 0x825B43BC; continue 'dispatch;
            }
            0x825B4310 => {
    //   block [0x825B4310..0x825B432C)
	// 825B4310: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4314: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B4318: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B431C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B4320: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B4324: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4328: 40810054  ble 0x825b437c
	if !ctx.cr[0].gt {
	pc = 0x825B437C; continue 'dispatch;
	}
	pc = 0x825B432C; continue 'dispatch;
            }
            0x825B432C => {
    //   block [0x825B432C..0x825B434C)
	// 825B432C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B4330: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B4334: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B4338: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B433C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825B4340: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B4344: 41980008  blt cr6, 0x825b434c
	if ctx.cr[6].lt {
	pc = 0x825B434C; continue 'dispatch;
	}
	// 825B4348: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x825B434C; continue 'dispatch;
            }
            0x825B434C => {
    //   block [0x825B434C..0x825B4368)
	// 825B434C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B4350: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B4354: 419A0014  beq cr6, 0x825b4368
	if ctx.cr[6].eq {
	pc = 0x825B4368; continue 'dispatch;
	}
	// 825B4358: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B435C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B4360: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B4364: 4800000C  b 0x825b4370
	pc = 0x825B4370; continue 'dispatch;
            }
            0x825B4368 => {
    //   block [0x825B4368..0x825B4370)
	// 825B4368: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B436C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B4370; continue 'dispatch;
            }
            0x825B4370 => {
    //   block [0x825B4370..0x825B437C)
	// 825B4370: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4374: 4199FFB8  bgt cr6, 0x825b432c
	if ctx.cr[6].gt {
	pc = 0x825B432C; continue 'dispatch;
	}
	// 825B4378: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B437C; continue 'dispatch;
            }
            0x825B437C => {
    //   block [0x825B437C..0x825B4398)
	// 825B437C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B4380: 419A0034  beq cr6, 0x825b43b4
	if ctx.cr[6].eq {
	pc = 0x825B43B4; continue 'dispatch;
	}
	// 825B4384: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4388: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B438C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4390: 41990008  bgt cr6, 0x825b4398
	if ctx.cr[6].gt {
	pc = 0x825B4398; continue 'dispatch;
	}
	// 825B4394: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B4398; continue 'dispatch;
            }
            0x825B4398 => {
    //   block [0x825B4398..0x825B43B4)
	// 825B4398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B439C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B43A0: 409A0014  bne cr6, 0x825b43b4
	if !ctx.cr[6].eq {
	pc = 0x825B43B4; continue 'dispatch;
	}
	// 825B43A4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B43A8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825B43AC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B43B0: 48000008  b 0x825b43b8
	pc = 0x825B43B8; continue 'dispatch;
            }
            0x825B43B4 => {
    //   block [0x825B43B4..0x825B43B8)
	// 825B43B4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825B43B8; continue 'dispatch;
            }
            0x825B43B8 => {
    //   block [0x825B43B8..0x825B43BC)
	// 825B43B8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B43BC; continue 'dispatch;
            }
            0x825B43BC => {
    //   block [0x825B43BC..0x825B43C0)
	// 825B43BC: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	pc = 0x825B43C0; continue 'dispatch;
            }
            0x825B43C0 => {
    //   block [0x825B43C0..0x825B43F8)
	// 825B43C0: 397E000C  addi r11, r30, 0xc
	ctx.r[11].s64 = ctx.r[30].s64 + 12;
	// 825B43C4: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B43C8: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825B43CC: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B43D0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B43D4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825B43D8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B43DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B43E0: 484E2F89  bl 0x82a97368
	ctx.lr = 0x825B43E4;
	sub_82A97368(ctx, base);
	// 825B43E4: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825B43E8: 409A0010  bne cr6, 0x825b43f8
	if !ctx.cr[6].eq {
	pc = 0x825B43F8; continue 'dispatch;
	}
	// 825B43EC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B43F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B43F4: 48000485  bl 0x825b4878
	ctx.lr = 0x825B43F8;
	sub_825B4878(ctx, base);
	pc = 0x825B43F8; continue 'dispatch;
            }
            0x825B43F8 => {
    //   block [0x825B43F8..0x825B4414)
	// 825B43F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B43FC: 480038C5  bl 0x825b7cc0
	ctx.lr = 0x825B4400;
	sub_825B7CC0(ctx, base);
	// 825B4400: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B4404: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4408: 419A000C  beq cr6, 0x825b4414
	if ctx.cr[6].eq {
	pc = 0x825B4414; continue 'dispatch;
	}
	// 825B440C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B4410: 48004C51  bl 0x825b9060
	ctx.lr = 0x825B4414;
	sub_825B9060(ctx, base);
	pc = 0x825B4414; continue 'dispatch;
            }
            0x825B4414 => {
    //   block [0x825B4414..0x825B4454)
	// 825B4414: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B4418: 83DE0004  lwz r30, 4(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B441C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B4420: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4424: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B4428: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B442C: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4430: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B4434: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B4438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B443C: 419A001C  beq cr6, 0x825b4458
	if ctx.cr[6].eq {
	pc = 0x825B4458; continue 'dispatch;
	}
	// 825B4440: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4448: 419A000C  beq cr6, 0x825b4454
	if ctx.cr[6].eq {
	pc = 0x825B4454; continue 'dispatch;
	}
	// 825B444C: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4450: 4800000C  b 0x825b445c
	pc = 0x825B445C; continue 'dispatch;
            }
            0x825B4454 => {
    //   block [0x825B4454..0x825B4458)
	// 825B4454: 4BBDF9E5  bl 0x82193e38
	ctx.lr = 0x825B4458;
	sub_82193E38(ctx, base);
	pc = 0x825B4458; continue 'dispatch;
            }
            0x825B4458 => {
    //   block [0x825B4458..0x825B445C)
	// 825B4458: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B445C; continue 'dispatch;
            }
            0x825B445C => {
    //   block [0x825B445C..0x825B4470)
	// 825B445C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B4460: 409A0010  bne cr6, 0x825b4470
	if !ctx.cr[6].eq {
	pc = 0x825B4470; continue 'dispatch;
	}
	// 825B4464: 937F00D4  stw r27, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[27].u32 ) };
	// 825B4468: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B446C: 486F4FE8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B4470 => {
    //   block [0x825B4470..0x825B448C)
	// 825B4470: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825B4474: 816A9140  lwz r11, -0x6ec0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-28352 as u32) ) } as u64;
	// 825B4478: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 825B447C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B4480: 916A9140  stw r11, -0x6ec0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-28352 as u32), ctx.r[11].u32 ) };
	// 825B4484: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B4488: 486F4FCC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4498 size=56
    let mut pc: u32 = 0x825B4498;
    'dispatch: loop {
        match pc {
            0x825B4498 => {
    //   block [0x825B4498..0x825B44D0)
	// 825B4498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B449C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B44A0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B44A4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B44A8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B44AC: 480000DD  bl 0x825b4588
	ctx.lr = 0x825B44B0;
	sub_825B4588(ctx, base);
	// 825B44B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B44B4: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B44B8: 4BDD9189  bl 0x8238d640
	ctx.lr = 0x825B44BC;
	sub_8238D640(ctx, base);
	// 825B44BC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B44C0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B44C4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B44C8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B44CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B44D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B44D0 size=184
    let mut pc: u32 = 0x825B44D0;
    'dispatch: loop {
        match pc {
            0x825B44D0 => {
    //   block [0x825B44D0..0x825B4514)
	// 825B44D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B44D4: 486F4F39  bl 0x82ca940c
	ctx.lr = 0x825B44D8;
	sub_82CA93D0(ctx, base);
	// 825B44D8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B44DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B44E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B44E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B44E8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B44EC: 388B5320  addi r4, r11, 0x5320
	ctx.r[4].s64 = ctx.r[11].s64 + 21280;
	// 825B44F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B44F4: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825B44F8: 4BC789D9  bl 0x8222ced0
	ctx.lr = 0x825B44FC;
	sub_8222CED0(ctx, base);
	// 825B44FC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B4500: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4504: 409A0010  bne cr6, 0x825b4514
	if !ctx.cr[6].eq {
	pc = 0x825B4514; continue 'dispatch;
	}
	// 825B4508: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825B450C: 388BFFDF  addi r4, r11, -0x21
	ctx.r[4].s64 = ctx.r[11].s64 + -33;
	// 825B4510: 48000008  b 0x825b4518
	pc = 0x825B4518; continue 'dispatch;
            }
            0x825B4514 => {
    //   block [0x825B4514..0x825B4518)
	// 825B4514: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B4518; continue 'dispatch;
            }
            0x825B4518 => {
    //   block [0x825B4518..0x825B4580)
	// 825B4518: 38BF00B4  addi r5, r31, 0xb4
	ctx.r[5].s64 = ctx.r[31].s64 + 180;
	// 825B451C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B4520: 4BDDBB69  bl 0x82390088
	ctx.lr = 0x825B4524;
	sub_82390088(ctx, base);
	// 825B4524: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B4528: 4BC608B1  bl 0x82214dd8
	ctx.lr = 0x825B452C;
	sub_82214DD8(ctx, base);
	// 825B452C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4530: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B4534: 388B5330  addi r4, r11, 0x5330
	ctx.r[4].s64 = ctx.r[11].s64 + 21296;
	// 825B4538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B453C: 4BC78995  bl 0x8222ced0
	ctx.lr = 0x825B4540;
	sub_8222CED0(ctx, base);
	// 825B4540: 38BF00B2  addi r5, r31, 0xb2
	ctx.r[5].s64 = ctx.r[31].s64 + 178;
	// 825B4544: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B4548: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B454C: 484688FD  bl 0x82a1ce48
	ctx.lr = 0x825B4550;
	sub_82A1CE48(ctx, base);
	// 825B4550: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B4554: 4BC60885  bl 0x82214dd8
	ctx.lr = 0x825B4558;
	sub_82214DD8(ctx, base);
	// 825B4558: 57AA063E  clrlwi r10, r29, 0x18
	ctx.r[10].u64 = ctx.r[29].u32 as u64 & 0x000000FFu64;
	// 825B455C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4560: 409A0020  bne cr6, 0x825b4580
	if !ctx.cr[6].eq {
	pc = 0x825B4580; continue 'dispatch;
	}
	// 825B4564: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4568: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B456C: 4BC25E45  bl 0x821da3b0
	ctx.lr = 0x825B4570;
	sub_821DA3B0(ctx, base);
	// 825B4570: 4BBFDF89  bl 0x821b24f8
	ctx.lr = 0x825B4574;
	sub_821B24F8(ctx, base);
	// 825B4574: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4578: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B457C: 480002FD  bl 0x825b4878
	ctx.lr = 0x825B4580;
	sub_825B4878(ctx, base);
	pc = 0x825B4580; continue 'dispatch;
            }
            0x825B4580 => {
    //   block [0x825B4580..0x825B4588)
	// 825B4580: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B4584: 486F4ED8  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4588(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4588 size=384
    let mut pc: u32 = 0x825B4588;
    'dispatch: loop {
        match pc {
            0x825B4588 => {
    //   block [0x825B4588..0x825B45F0)
	// 825B4588: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B458C: 486F4E7D  bl 0x82ca9408
	ctx.lr = 0x825B4590;
	sub_82CA93D0(ctx, base);
	// 825B4590: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4594: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B4598: 817D00B8  lwz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 825B459C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B45A0: 40990160  ble cr6, 0x825b4700
	if !ctx.cr[6].gt {
	pc = 0x825B4700; continue 'dispatch;
	}
	// 825B45A4: 817D00BC  lwz r11, 0xbc(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(188 as u32) ) } as u64;
	// 825B45A8: 3B9D00BC  addi r28, r29, 0xbc
	ctx.r[28].s64 = ctx.r[29].s64 + 188;
	// 825B45AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B45B0: 409A0150  bne cr6, 0x825b4700
	if !ctx.cr[6].eq {
	pc = 0x825B4700; continue 'dispatch;
	}
	// 825B45B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B45B8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B45BC: 554997FE  rlwinm r9, r10, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 825B45C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B45C4: 419A013C  beq cr6, 0x825b4700
	if ctx.cr[6].eq {
	pc = 0x825B4700; continue 'dispatch;
	}
	// 825B45C8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B45CC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B45D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B45D4: 419A001C  beq cr6, 0x825b45f0
	if ctx.cr[6].eq {
	pc = 0x825B45F0; continue 'dispatch;
	}
	// 825B45D8: 894A000E  lbz r10, 0xe(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(14 as u32) ) } as u64;
	// 825B45DC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B45E0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B45E4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B45E8: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B45EC: 480000B0  b 0x825b469c
	pc = 0x825B469C; continue 'dispatch;
            }
            0x825B45F0 => {
    //   block [0x825B45F0..0x825B460C)
	// 825B45F0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B45F4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B45F8: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B45FC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B4600: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B4604: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4608: 40810054  ble 0x825b465c
	if !ctx.cr[0].gt {
	pc = 0x825B465C; continue 'dispatch;
	}
	pc = 0x825B460C; continue 'dispatch;
            }
            0x825B460C => {
    //   block [0x825B460C..0x825B462C)
	// 825B460C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B4610: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B4614: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B4618: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B461C: 2F07000E  cmpwi cr6, r7, 0xe
	ctx.cr[6].compare_i32(ctx.r[7].s32, 14, &mut ctx.xer);
	// 825B4620: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B4624: 41980008  blt cr6, 0x825b462c
	if ctx.cr[6].lt {
	pc = 0x825B462C; continue 'dispatch;
	}
	// 825B4628: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x825B462C; continue 'dispatch;
            }
            0x825B462C => {
    //   block [0x825B462C..0x825B4648)
	// 825B462C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B4630: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B4634: 419A0014  beq cr6, 0x825b4648
	if ctx.cr[6].eq {
	pc = 0x825B4648; continue 'dispatch;
	}
	// 825B4638: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B463C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B4640: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B4644: 4800000C  b 0x825b4650
	pc = 0x825B4650; continue 'dispatch;
            }
            0x825B4648 => {
    //   block [0x825B4648..0x825B4650)
	// 825B4648: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B464C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B4650; continue 'dispatch;
            }
            0x825B4650 => {
    //   block [0x825B4650..0x825B465C)
	// 825B4650: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4654: 4199FFB8  bgt cr6, 0x825b460c
	if ctx.cr[6].gt {
	pc = 0x825B460C; continue 'dispatch;
	}
	// 825B4658: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B465C; continue 'dispatch;
            }
            0x825B465C => {
    //   block [0x825B465C..0x825B4678)
	// 825B465C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B4660: 419A0034  beq cr6, 0x825b4694
	if ctx.cr[6].eq {
	pc = 0x825B4694; continue 'dispatch;
	}
	// 825B4664: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4668: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 825B466C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4670: 41990008  bgt cr6, 0x825b4678
	if ctx.cr[6].gt {
	pc = 0x825B4678; continue 'dispatch;
	}
	// 825B4674: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825B4678; continue 'dispatch;
            }
            0x825B4678 => {
    //   block [0x825B4678..0x825B4694)
	// 825B4678: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B467C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4680: 409A0014  bne cr6, 0x825b4694
	if !ctx.cr[6].eq {
	pc = 0x825B4694; continue 'dispatch;
	}
	// 825B4684: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B4688: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B468C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B4690: 48000008  b 0x825b4698
	pc = 0x825B4698; continue 'dispatch;
            }
            0x825B4694 => {
    //   block [0x825B4694..0x825B4698)
	// 825B4694: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825B4698; continue 'dispatch;
            }
            0x825B4698 => {
    //   block [0x825B4698..0x825B469C)
	// 825B4698: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B469C; continue 'dispatch;
            }
            0x825B469C => {
    //   block [0x825B469C..0x825B46CC)
	// 825B469C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B46A0: 419A0060  beq cr6, 0x825b4700
	if ctx.cr[6].eq {
	pc = 0x825B4700; continue 'dispatch;
	}
	// 825B46A4: 38600008  li r3, 8
	ctx.r[3].s64 = 8;
	// 825B46A8: 4BC6ABB1  bl 0x8221f258
	ctx.lr = 0x825B46AC;
	sub_8221F258(ctx, base);
	// 825B46AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B46B0: 419A001C  beq cr6, 0x825b46cc
	if ctx.cr[6].eq {
	pc = 0x825B46CC; continue 'dispatch;
	}
	// 825B46B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B46B8: 93C30004  stw r30, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825B46BC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B46C0: 394B0E0C  addi r10, r11, 0xe0c
	ctx.r[10].s64 = ctx.r[11].s64 + 3596;
	// 825B46C4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B46C8: 48000008  b 0x825b46d0
	pc = 0x825B46D0; continue 'dispatch;
            }
            0x825B46CC => {
    //   block [0x825B46CC..0x825B46D0)
	// 825B46CC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	pc = 0x825B46D0; continue 'dispatch;
            }
            0x825B46D0 => {
    //   block [0x825B46D0..0x825B4700)
	// 825B46D0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B46D4: 4BCBE985  bl 0x82273058
	ctx.lr = 0x825B46D8;
	sub_82273058(ctx, base);
	// 825B46D8: 817D00B8  lwz r11, 0xb8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(184 as u32) ) } as u64;
	// 825B46DC: 815F002C  lwz r10, 0x2c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B46E0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825B46E4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B46E8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B46EC: 419A0014  beq cr6, 0x825b4700
	if ctx.cr[6].eq {
	pc = 0x825B4700; continue 'dispatch;
	}
	// 825B46F0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B46F4: 809C0000  lwz r4, 0(r28)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B46F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B46FC: 4805D2FD  bl 0x826119f8
	ctx.lr = 0x825B4700;
	sub_826119F8(ctx, base);
	pc = 0x825B4700; continue 'dispatch;
            }
            0x825B4700 => {
    //   block [0x825B4700..0x825B4708)
	// 825B4700: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B4704: 486F4D54  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4710 size=356
    let mut pc: u32 = 0x825B4710;
    'dispatch: loop {
        match pc {
            0x825B4710 => {
    //   block [0x825B4710..0x825B4774)
	// 825B4710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B4714: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B4718: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B471C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B4720: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4724: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B4728: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B472C: 997E00B3  stb r11, 0xb3(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(179 as u32), ctx.r[11].u8 ) };
	// 825B4730: 48004541  bl 0x825b8c70
	ctx.lr = 0x825B4734;
	sub_825B8C70(ctx, base);
	// 825B4734: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4738: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B473C: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B4740: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825B4744: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B4748: 419A00E8  beq cr6, 0x825b4830
	if ctx.cr[6].eq {
	pc = 0x825B4830; continue 'dispatch;
	}
	// 825B474C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B4750: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4754: 419A0020  beq cr6, 0x825b4774
	if ctx.cr[6].eq {
	pc = 0x825B4774; continue 'dispatch;
	}
	// 825B4758: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B475C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4760: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B4764: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B4768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B476C: 83E80004  lwz r31, 4(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4770: 480000C4  b 0x825b4834
	pc = 0x825B4834; continue 'dispatch;
            }
            0x825B4774 => {
    //   block [0x825B4774..0x825B4790)
	// 825B4774: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4778: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B477C: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B4780: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B4784: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B4788: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B478C: 40810054  ble 0x825b47e0
	if !ctx.cr[0].gt {
	pc = 0x825B47E0; continue 'dispatch;
	}
	pc = 0x825B4790; continue 'dispatch;
            }
            0x825B4790 => {
    //   block [0x825B4790..0x825B47B0)
	// 825B4790: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B4794: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B4798: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B479C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B47A0: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825B47A4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B47A8: 41980008  blt cr6, 0x825b47b0
	if ctx.cr[6].lt {
	pc = 0x825B47B0; continue 'dispatch;
	}
	// 825B47AC: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B47B0; continue 'dispatch;
            }
            0x825B47B0 => {
    //   block [0x825B47B0..0x825B47CC)
	// 825B47B0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B47B4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B47B8: 419A0014  beq cr6, 0x825b47cc
	if ctx.cr[6].eq {
	pc = 0x825B47CC; continue 'dispatch;
	}
	// 825B47BC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B47C0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B47C4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B47C8: 4800000C  b 0x825b47d4
	pc = 0x825B47D4; continue 'dispatch;
            }
            0x825B47CC => {
    //   block [0x825B47CC..0x825B47D4)
	// 825B47CC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B47D0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B47D4; continue 'dispatch;
            }
            0x825B47D4 => {
    //   block [0x825B47D4..0x825B47E0)
	// 825B47D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B47D8: 4199FFB8  bgt cr6, 0x825b4790
	if ctx.cr[6].gt {
	pc = 0x825B4790; continue 'dispatch;
	}
	// 825B47DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B47E0; continue 'dispatch;
            }
            0x825B47E0 => {
    //   block [0x825B47E0..0x825B47FC)
	// 825B47E0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B47E4: 419A003C  beq cr6, 0x825b4820
	if ctx.cr[6].eq {
	pc = 0x825B4820; continue 'dispatch;
	}
	// 825B47E8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B47EC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B47F0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B47F4: 41990008  bgt cr6, 0x825b47fc
	if ctx.cr[6].gt {
	pc = 0x825B47FC; continue 'dispatch;
	}
	// 825B47F8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B47FC; continue 'dispatch;
            }
            0x825B47FC => {
    //   block [0x825B47FC..0x825B4820)
	// 825B47FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B4800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4804: 409A001C  bne cr6, 0x825b4820
	if !ctx.cr[6].eq {
	pc = 0x825B4820; continue 'dispatch;
	}
	// 825B4808: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B480C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B4810: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B4814: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4818: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B481C: 48000018  b 0x825b4834
	pc = 0x825B4834; continue 'dispatch;
            }
            0x825B4820 => {
    //   block [0x825B4820..0x825B4830)
	// 825B4820: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B4824: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4828: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B482C: 48000008  b 0x825b4834
	pc = 0x825B4834; continue 'dispatch;
            }
            0x825B4830 => {
    //   block [0x825B4830..0x825B4834)
	// 825B4830: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B4834; continue 'dispatch;
            }
            0x825B4834 => {
    //   block [0x825B4834..0x825B485C)
	// 825B4834: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B4838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B483C: 419A0020  beq cr6, 0x825b485c
	if ctx.cr[6].eq {
	pc = 0x825B485C; continue 'dispatch;
	}
	// 825B4840: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4844: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 825B4848: 4BFBE0A1  bl 0x825728e8
	ctx.lr = 0x825B484C;
	sub_825728E8(ctx, base);
	// 825B484C: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B4850: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B4854: 387F000C  addi r3, r31, 0xc
	ctx.r[3].s64 = ctx.r[31].s64 + 12;
	// 825B4858: 4BFC1339  bl 0x82575b90
	ctx.lr = 0x825B485C;
	sub_82575B90(ctx, base);
	pc = 0x825B485C; continue 'dispatch;
            }
            0x825B485C => {
    //   block [0x825B485C..0x825B4874)
	// 825B485C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B4860: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B4864: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B4868: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B486C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B4870: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B4878(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B4878 size=2280
    let mut pc: u32 = 0x825B4878;
    'dispatch: loop {
        match pc {
            0x825B4878 => {
    //   block [0x825B4878..0x825B48D8)
	// 825B4878: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B487C: 486F4B55  bl 0x82ca93d0
	ctx.lr = 0x825B4880;
	sub_82CA93D0(ctx, base);
	// 825B4880: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B4884: 7C6E1B78  mr r14, r3
	ctx.r[14].u64 = ctx.r[3].u64;
	// 825B4888: 39E00000  li r15, 0
	ctx.r[15].s64 = 0;
	// 825B488C: 91C10144  stw r14, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[14].u32 ) };
	// 825B4890: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 825B4894: 7DEA7B78  mr r10, r15
	ctx.r[10].u64 = ctx.r[15].u64;
	// 825B4898: 816E0004  lwz r11, 4(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B489C: A12B0024  lhz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B48A0: 552807FE  clrlwi r8, r9, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000001u64;
	// 825B48A4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B48A8: 419A00F4  beq cr6, 0x825b499c
	if ctx.cr[6].eq {
	pc = 0x825B499C; continue 'dispatch;
	}
	// 825B48AC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B48B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B48B4: 419A0024  beq cr6, 0x825b48d8
	if ctx.cr[6].eq {
	pc = 0x825B48D8; continue 'dispatch;
	}
	// 825B48B8: 894A0010  lbz r10, 0x10(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B48BC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B48C0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B48C4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B48C8: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B48CC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B48D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B48D4: 480000CC  b 0x825b49a0
	pc = 0x825B49A0; continue 'dispatch;
            }
            0x825B48D8 => {
    //   block [0x825B48D8..0x825B48F4)
	// 825B48D8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B48DC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B48E0: 91E10058  stw r15, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[15].u32 ) };
	// 825B48E4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B48E8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B48EC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B48F0: 40810054  ble 0x825b4944
	if !ctx.cr[0].gt {
	pc = 0x825B4944; continue 'dispatch;
	}
	pc = 0x825B48F4; continue 'dispatch;
            }
            0x825B48F4 => {
    //   block [0x825B48F4..0x825B4914)
	// 825B48F4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B48F8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B48FC: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B4900: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4904: 2F070010  cmpwi cr6, r7, 0x10
	ctx.cr[6].compare_i32(ctx.r[7].s32, 16, &mut ctx.xer);
	// 825B4908: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B490C: 41980008  blt cr6, 0x825b4914
	if ctx.cr[6].lt {
	pc = 0x825B4914; continue 'dispatch;
	}
	// 825B4910: 7DE77B78  mr r7, r15
	ctx.r[7].u64 = ctx.r[15].u64;
	pc = 0x825B4914; continue 'dispatch;
            }
            0x825B4914 => {
    //   block [0x825B4914..0x825B4930)
	// 825B4914: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B4918: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B491C: 419A0014  beq cr6, 0x825b4930
	if ctx.cr[6].eq {
	pc = 0x825B4930; continue 'dispatch;
	}
	// 825B4920: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B4924: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B4928: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B492C: 4800000C  b 0x825b4938
	pc = 0x825B4938; continue 'dispatch;
            }
            0x825B4930 => {
    //   block [0x825B4930..0x825B4938)
	// 825B4930: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B4934: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B4938; continue 'dispatch;
            }
            0x825B4938 => {
    //   block [0x825B4938..0x825B4944)
	// 825B4938: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B493C: 4199FFB8  bgt cr6, 0x825b48f4
	if ctx.cr[6].gt {
	pc = 0x825B48F4; continue 'dispatch;
	}
	// 825B4940: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x825B4944; continue 'dispatch;
            }
            0x825B4944 => {
    //   block [0x825B4944..0x825B4960)
	// 825B4944: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B4948: 419A0040  beq cr6, 0x825b4988
	if ctx.cr[6].eq {
	pc = 0x825B4988; continue 'dispatch;
	}
	// 825B494C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4950: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 825B4954: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4958: 41990008  bgt cr6, 0x825b4960
	if ctx.cr[6].gt {
	pc = 0x825B4960; continue 'dispatch;
	}
	// 825B495C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	pc = 0x825B4960; continue 'dispatch;
            }
            0x825B4960 => {
    //   block [0x825B4960..0x825B4988)
	// 825B4960: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B4964: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4968: 409A0020  bne cr6, 0x825b4988
	if !ctx.cr[6].eq {
	pc = 0x825B4988; continue 'dispatch;
	}
	// 825B496C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B4970: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825B4974: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B4978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B497C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B4980: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4984: 4800001C  b 0x825b49a0
	pc = 0x825B49A0; continue 'dispatch;
            }
            0x825B4988 => {
    //   block [0x825B4988..0x825B499C)
	// 825B4988: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B498C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4990: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B4994: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4998: 48000008  b 0x825b49a0
	pc = 0x825B49A0; continue 'dispatch;
            }
            0x825B499C => {
    //   block [0x825B499C..0x825B49A0)
	// 825B499C: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	pc = 0x825B49A0; continue 'dispatch;
            }
            0x825B49A0 => {
    //   block [0x825B49A0..0x825B49B4)
	// 825B49A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B49A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B49A8: 419A000C  beq cr6, 0x825b49b4
	if ctx.cr[6].eq {
	pc = 0x825B49B4; continue 'dispatch;
	}
	// 825B49AC: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B49B0: 916E00B4  stw r11, 0xb4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	pc = 0x825B49B4; continue 'dispatch;
            }
            0x825B49B4 => {
    //   block [0x825B49B4..0x825B4A20)
	// 825B49B4: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 825B49B8: 419A07A0  beq cr6, 0x825b5158
	if ctx.cr[6].eq {
	pc = 0x825B5158; continue 'dispatch;
	}
	// 825B49BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B49C0: 91E10050  stw r15, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[15].u32 ) };
	// 825B49C4: 3D40811C  lis r10, -0x7ee4
	ctx.r[10].s64 = -2128871424;
	// 825B49C8: 3BEB5348  addi r31, r11, 0x5348
	ctx.r[31].s64 = ctx.r[11].s64 + 21320;
	// 825B49CC: 61539DC5  ori r19, r10, 0x9dc5
	ctx.r[19].u64 = ctx.r[10].u64 | 40389;
	// 825B49D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B49D4: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B49D8: 7DF57B78  mr r21, r15
	ctx.r[21].u64 = ctx.r[15].u64;
	// 825B49DC: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 825B49E0: 4BC3F379  bl 0x821f3d58
	ctx.lr = 0x825B49E4;
	sub_821F3D58(ctx, base);
	// 825B49E4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B49E8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B49EC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B49F0: 4BCC6E31  bl 0x8227b820
	ctx.lr = 0x825B49F4;
	sub_8227B820(ctx, base);
	// 825B49F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B49F8: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B49FC: 4BC3F35D  bl 0x821f3d58
	ctx.lr = 0x825B4A00;
	sub_821F3D58(ctx, base);
	// 825B4A00: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4A04: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4A08: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B4A0C: 4844BCBD  bl 0x82a006c8
	ctx.lr = 0x825B4A10;
	sub_82A006C8(ctx, base);
	// 825B4A10: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4A14: 419A000C  beq cr6, 0x825b4a20
	if ctx.cr[6].eq {
	pc = 0x825B4A20; continue 'dispatch;
	}
	// 825B4A18: 80830000  lwz r4, 0(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4A1C: 48000008  b 0x825b4a24
	pc = 0x825B4A24; continue 'dispatch;
            }
            0x825B4A20 => {
    //   block [0x825B4A20..0x825B4A24)
	// 825B4A20: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	pc = 0x825B4A24; continue 'dispatch;
            }
            0x825B4A24 => {
    //   block [0x825B4A24..0x825B4A60)
	// 825B4A24: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B4A28: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 825B4A2C: 3E408349  lis r18, -0x7cb7
	ctx.r[18].s64 = -2092367872;
	// 825B4A30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4A34: 419A0058  beq cr6, 0x825b4a8c
	if ctx.cr[6].eq {
	pc = 0x825B4A8C; continue 'dispatch;
	}
	// 825B4A38: 816E00B4  lwz r11, 0xb4(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B4A3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4A40: 409A0020  bne cr6, 0x825b4a60
	if !ctx.cr[6].eq {
	pc = 0x825B4A60; continue 'dispatch;
	}
	// 825B4A44: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B4A48: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4A4C: 814B0058  lwz r10, 0x58(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B4A50: 812A0004  lwz r9, 4(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4A54: 8069006C  lwz r3, 0x6c(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B4A58: 48332339  bl 0x828e6d90
	ctx.lr = 0x825B4A5C;
	sub_828E6D90(ctx, base);
	// 825B4A5C: 906E00B4  stw r3, 0xb4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(180 as u32), ctx.r[3].u32 ) };
	pc = 0x825B4A60; continue 'dispatch;
            }
            0x825B4A60 => {
    //   block [0x825B4A60..0x825B4A8C)
	// 825B4A60: 808E00B4  lwz r4, 0xb4(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B4A64: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4A68: 419A0024  beq cr6, 0x825b4a8c
	if ctx.cr[6].eq {
	pc = 0x825B4A8C; continue 'dispatch;
	}
	// 825B4A6C: 80726DA0  lwz r3, 0x6da0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B4A70: 4BC2F7E1  bl 0x821e4250
	ctx.lr = 0x825B4A74;
	sub_821E4250(ctx, base);
	// 825B4A74: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4A78: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4A7C: 419A0010  beq cr6, 0x825b4a8c
	if ctx.cr[6].eq {
	pc = 0x825B4A8C; continue 'dispatch;
	}
	// 825B4A80: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 825B4A84: 480006DD  bl 0x825b5160
	ctx.lr = 0x825B4A88;
	sub_825B5160(ctx, base);
	// 825B4A88: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	pc = 0x825B4A8C; continue 'dispatch;
            }
            0x825B4A8C => {
    //   block [0x825B4A8C..0x825B4B20)
	// 825B4A8C: 56AA063E  clrlwi r10, r21, 0x18
	ctx.r[10].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	// 825B4A90: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B4A94: 3E20834A  lis r17, -0x7cb6
	ctx.r[17].s64 = -2092302336;
	// 825B4A98: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4A9C: 3A0BE460  addi r16, r11, -0x1ba0
	ctx.r[16].s64 = ctx.r[11].s64 + -7072;
	// 825B4AA0: 409A035C  bne cr6, 0x825b4dfc
	if !ctx.cr[6].eq {
	pc = 0x825B4DFC; continue 'dispatch;
	}
	// 825B4AA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4AA8: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4AAC: 3BEB5358  addi r31, r11, 0x5358
	ctx.r[31].s64 = ctx.r[11].s64 + 21336;
	// 825B4AB0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4AB4: 4BCF4F35  bl 0x822a99e8
	ctx.lr = 0x825B4AB8;
	sub_822A99E8(ctx, base);
	// 825B4AB8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B4ABC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4AC0: 419A033C  beq cr6, 0x825b4dfc
	if ctx.cr[6].eq {
	pc = 0x825B4DFC; continue 'dispatch;
	}
	// 825B4AC4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B4AC8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B4ACC: 4844BEC5  bl 0x82a00990
	ctx.lr = 0x825B4AD0;
	sub_82A00990(ctx, base);
	// 825B4AD0: 81610084  lwz r11, 0x84(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825B4AD4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4AD8: 409A01A0  bne cr6, 0x825b4c78
	if !ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4ADC: 816E0004  lwz r11, 4(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4AE0: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 825B4AE4: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B4AE8: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 825B4AEC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B4AF0: 419A00F4  beq cr6, 0x825b4be4
	if ctx.cr[6].eq {
	pc = 0x825B4BE4; continue 'dispatch;
	}
	// 825B4AF4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B4AF8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B4AFC: 419A0024  beq cr6, 0x825b4b20
	if ctx.cr[6].eq {
	pc = 0x825B4B20; continue 'dispatch;
	}
	// 825B4B00: 894A0014  lbz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B4B04: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4B08: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B4B0C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B4B10: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4B14: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825B4B18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4B1C: 480000CC  b 0x825b4be8
	pc = 0x825B4BE8; continue 'dispatch;
            }
            0x825B4B20 => {
    //   block [0x825B4B20..0x825B4B3C)
	// 825B4B20: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B4B24: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B4B28: 91E10058  stw r15, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[15].u32 ) };
	// 825B4B2C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B4B30: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B4B34: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4B38: 40810054  ble 0x825b4b8c
	if !ctx.cr[0].gt {
	pc = 0x825B4B8C; continue 'dispatch;
	}
	pc = 0x825B4B3C; continue 'dispatch;
            }
            0x825B4B3C => {
    //   block [0x825B4B3C..0x825B4B5C)
	// 825B4B3C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B4B40: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B4B44: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B4B48: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B4C: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 825B4B50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B4B54: 41980008  blt cr6, 0x825b4b5c
	if ctx.cr[6].lt {
	pc = 0x825B4B5C; continue 'dispatch;
	}
	// 825B4B58: 7DE77B78  mr r7, r15
	ctx.r[7].u64 = ctx.r[15].u64;
	pc = 0x825B4B5C; continue 'dispatch;
            }
            0x825B4B5C => {
    //   block [0x825B4B5C..0x825B4B78)
	// 825B4B5C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B4B60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B4B64: 419A0014  beq cr6, 0x825b4b78
	if ctx.cr[6].eq {
	pc = 0x825B4B78; continue 'dispatch;
	}
	// 825B4B68: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B4B6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B4B70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B4B74: 4800000C  b 0x825b4b80
	pc = 0x825B4B80; continue 'dispatch;
            }
            0x825B4B78 => {
    //   block [0x825B4B78..0x825B4B80)
	// 825B4B78: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B4B7C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B4B80; continue 'dispatch;
            }
            0x825B4B80 => {
    //   block [0x825B4B80..0x825B4B8C)
	// 825B4B80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B4B84: 4199FFB8  bgt cr6, 0x825b4b3c
	if ctx.cr[6].gt {
	pc = 0x825B4B3C; continue 'dispatch;
	}
	// 825B4B88: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x825B4B8C; continue 'dispatch;
            }
            0x825B4B8C => {
    //   block [0x825B4B8C..0x825B4BA8)
	// 825B4B8C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B4B90: 419A0040  beq cr6, 0x825b4bd0
	if ctx.cr[6].eq {
	pc = 0x825B4BD0; continue 'dispatch;
	}
	// 825B4B94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4B98: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 825B4B9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4BA0: 41990008  bgt cr6, 0x825b4ba8
	if ctx.cr[6].gt {
	pc = 0x825B4BA8; continue 'dispatch;
	}
	// 825B4BA4: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	pc = 0x825B4BA8; continue 'dispatch;
            }
            0x825B4BA8 => {
    //   block [0x825B4BA8..0x825B4BD0)
	// 825B4BA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B4BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4BB0: 409A0020  bne cr6, 0x825b4bd0
	if !ctx.cr[6].eq {
	pc = 0x825B4BD0; continue 'dispatch;
	}
	// 825B4BB4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B4BB8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825B4BBC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B4BC0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4BC4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825B4BC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4BCC: 4800001C  b 0x825b4be8
	pc = 0x825B4BE8; continue 'dispatch;
            }
            0x825B4BD0 => {
    //   block [0x825B4BD0..0x825B4BE4)
	// 825B4BD0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B4BD4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4BD8: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825B4BDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B4BE0: 48000008  b 0x825b4be8
	pc = 0x825B4BE8; continue 'dispatch;
            }
            0x825B4BE4 => {
    //   block [0x825B4BE4..0x825B4BE8)
	// 825B4BE4: 7DEB7B78  mr r11, r15
	ctx.r[11].u64 = ctx.r[15].u64;
	pc = 0x825B4BE8; continue 'dispatch;
            }
            0x825B4BE8 => {
    //   block [0x825B4BE8..0x825B4C70)
	// 825B4BE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B4BEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4BF0: 419A0088  beq cr6, 0x825b4c78
	if ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4BF4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B4BF8: 4BC257B9  bl 0x821da3b0
	ctx.lr = 0x825B4BFC;
	sub_821DA3B0(ctx, base);
	// 825B4BFC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B4C00: 38EBA440  addi r7, r11, -0x5bc0
	ctx.r[7].s64 = ctx.r[11].s64 + -23488;
	// 825B4C04: 4BBFD8F5  bl 0x821b24f8
	ctx.lr = 0x825B4C08;
	sub_821B24F8(ctx, base);
	// 825B4C08: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B4C0C: 4BD9F42D  bl 0x82354038
	ctx.lr = 0x825B4C10;
	sub_82354038(ctx, base);
	// 825B4C10: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4C14: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4C18: 419A0060  beq cr6, 0x825b4c78
	if ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4C1C: 80726DA0  lwz r3, 0x6da0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B4C20: 4BC2F631  bl 0x821e4250
	ctx.lr = 0x825B4C24;
	sub_821E4250(ctx, base);
	// 825B4C24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4C28: 419A0050  beq cr6, 0x825b4c78
	if ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4C2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4C30: 388B5374  addi r4, r11, 0x5374
	ctx.r[4].s64 = ctx.r[11].s64 + 21364;
	// 825B4C34: 4BCF4DB5  bl 0x822a99e8
	ctx.lr = 0x825B4C38;
	sub_822A99E8(ctx, base);
	// 825B4C38: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4C3C: 419A003C  beq cr6, 0x825b4c78
	if ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4C40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4C44: 4BCF4DA5  bl 0x822a99e8
	ctx.lr = 0x825B4C48;
	sub_822A99E8(ctx, base);
	// 825B4C48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4C4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B4C50: 419A0028  beq cr6, 0x825b4c78
	if ctx.cr[6].eq {
	pc = 0x825B4C78; continue 'dispatch;
	}
	// 825B4C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4C58: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B4C5C: 4844BD35  bl 0x82a00990
	ctx.lr = 0x825B4C60;
	sub_82A00990(ctx, base);
	// 825B4C60: 81610074  lwz r11, 0x74(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B4C64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4C68: 419A0008  beq cr6, 0x825b4c70
	if ctx.cr[6].eq {
	pc = 0x825B4C70; continue 'dispatch;
	}
	// 825B4C6C: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x825B4C70; continue 'dispatch;
            }
            0x825B4C70 => {
    //   block [0x825B4C70..0x825B4C78)
	// 825B4C70: 80610070  lwz r3, 0x70(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B4C74: 4BC670C5  bl 0x8221bd38
	ctx.lr = 0x825B4C78;
	sub_8221BD38(ctx, base);
	pc = 0x825B4C78; continue 'dispatch;
            }
            0x825B4C78 => {
    //   block [0x825B4C78..0x825B4D04)
	// 825B4C78: 80610080  lwz r3, 0x80(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B4C7C: 4BC670BD  bl 0x8221bd38
	ctx.lr = 0x825B4C80;
	sub_8221BD38(ctx, base);
	// 825B4C80: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4C84: 419A0178  beq cr6, 0x825b4dfc
	if ctx.cr[6].eq {
	pc = 0x825B4DFC; continue 'dispatch;
	}
	// 825B4C88: 817D6AB8  lwz r11, 0x6ab8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B4C8C: 3D4051EB  lis r10, 0x51eb
	ctx.r[10].s64 = 1374355456;
	// 825B4C90: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B4C94: 6149851F  ori r9, r10, 0x851f
	ctx.r[9].u64 = ctx.r[10].u64 | 34079;
	// 825B4C98: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B4C9C: 7DFC7B78  mr r28, r15
	ctx.r[28].u64 = ctx.r[15].u64;
	// 825B4CA0: 810B000C  lwz r8, 0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B4CA4: 80E80058  lwz r7, 0x58(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B4CA8: 81670004  lwz r11, 4(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B4CAC: 80CB0078  lwz r6, 0x78(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B4CB0: 1D4624A1  mulli r10, r6, 0x24a1
	ctx.r[10].s32 = ((ctx.r[6].s32 as i64 * 9377 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 825B4CB4: 38AA24DF  addi r5, r10, 0x24df
	ctx.r[5].s64 = ctx.r[10].s64 + 9439;
	// 825B4CB8: 54AA983E  rotlwi r10, r5, 0x13
	ctx.r[10].u64 = ((ctx.r[5].u32).rotate_left(19)) as u64;
	// 825B4CBC: 914B0078  stw r10, 0x78(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825B4CC0: 7D2A4816  mulhwu r9, r10, r9
	ctx.r[9].u64 = ((ctx.r[10].u32 as u64 * ctx.r[9].u32 as u64) >> 32);
	// 825B4CC4: 5528D97E  srwi r8, r9, 5
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shr(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B4CC8: 1CE80064  mulli r7, r8, 0x64
	ctx.r[7].s32 = ((ctx.r[8].s32 as i64 * 100 as i64) as i32);
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 825B4CCC: 7D675050  subf r11, r7, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[7].s64;
	// 825B4CD0: 3AEB0001  addi r23, r11, 1
	ctx.r[23].s64 = ctx.r[11].s64 + 1;
	// 825B4CD4: 4844BCBD  bl 0x82a00990
	ctx.lr = 0x825B4CD8;
	sub_82A00990(ctx, base);
	// 825B4CD8: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B4CDC: 82C10064  lwz r22, 0x64(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B4CE0: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B4CE4: 7F1EB040  cmplw cr6, r30, r22
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825B4CE8: 419A010C  beq cr6, 0x825b4df4
	if ctx.cr[6].eq {
	pc = 0x825B4DF4; continue 'dispatch;
	}
	// 825B4CEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4CF0: 83526DA0  lwz r26, 0x6da0(r18)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B4CF4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B4CF8: 8311E454  lwz r24, -0x1bac(r17)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B4CFC: 3BAB53A8  addi r29, r11, 0x53a8
	ctx.r[29].s64 = ctx.r[11].s64 + 21416;
	// 825B4D00: 3B6A5394  addi r27, r10, 0x5394
	ctx.r[27].s64 = ctx.r[10].s64 + 21396;
	pc = 0x825B4D04; continue 'dispatch;
            }
            0x825B4D04 => {
    //   block [0x825B4D04..0x825B4D3C)
	// 825B4D04: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4D08: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825B4D0C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4D10: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825B4D14: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4D18: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4D1C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B4D20: 419A001C  beq cr6, 0x825b4d3c
	if ctx.cr[6].eq {
	pc = 0x825B4D3C; continue 'dispatch;
	}
	// 825B4D24: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B4D28: 409A0014  bne cr6, 0x825b4d3c
	if !ctx.cr[6].eq {
	pc = 0x825B4D3C; continue 'dispatch;
	}
	// 825B4D2C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4D30: 7F0BC040  cmplw cr6, r11, r24
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825B4D34: 409A0008  bne cr6, 0x825b4d3c
	if !ctx.cr[6].eq {
	pc = 0x825B4D3C; continue 'dispatch;
	}
	// 825B4D38: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	pc = 0x825B4D3C; continue 'dispatch;
            }
            0x825B4D3C => {
    //   block [0x825B4D3C..0x825B4DC0)
	// 825B4D3C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B4D40: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4D44: 4BC2F50D  bl 0x821e4250
	ctx.lr = 0x825B4D48;
	sub_821E4250(ctx, base);
	// 825B4D48: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B4D4C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B4D50: 419A0084  beq cr6, 0x825b4dd4
	if ctx.cr[6].eq {
	pc = 0x825B4DD4; continue 'dispatch;
	}
	// 825B4D54: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B4D58: 4BE0AAC9  bl 0x823bf820
	ctx.lr = 0x825B4D5C;
	sub_823BF820(ctx, base);
	// 825B4D5C: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 825B4D60: 40990074  ble cr6, 0x825b4dd4
	if !ctx.cr[6].gt {
	pc = 0x825B4DD4; continue 'dispatch;
	}
	// 825B4D64: 7F83E214  add r28, r3, r28
	ctx.r[28].u64 = ctx.r[3].u64 + ctx.r[28].u64;
	// 825B4D68: 7F1CB800  cmpw cr6, r28, r23
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[23].s32, &mut ctx.xer);
	// 825B4D6C: 41980068  blt cr6, 0x825b4dd4
	if ctx.cr[6].lt {
	pc = 0x825B4DD4; continue 'dispatch;
	}
	// 825B4D70: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B4D74: 91E10050  stw r15, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[15].u32 ) };
	// 825B4D78: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B4D7C: 39C10050  addi r14, r1, 0x50
	ctx.r[14].s64 = ctx.r[1].s64 + 80;
	// 825B4D80: 4BC3EFD9  bl 0x821f3d58
	ctx.lr = 0x825B4D84;
	sub_821F3D58(ctx, base);
	// 825B4D84: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4D88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4D8C: 7DC57378  mr r5, r14
	ctx.r[5].u64 = ctx.r[14].u64;
	// 825B4D90: 4BCC6A91  bl 0x8227b820
	ctx.lr = 0x825B4D94;
	sub_8227B820(ctx, base);
	// 825B4D94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B4D98: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B4D9C: 4BC3EFBD  bl 0x821f3d58
	ctx.lr = 0x825B4DA0;
	sub_821F3D58(ctx, base);
	// 825B4DA0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4DA4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4DA8: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B4DAC: 4844B91D  bl 0x82a006c8
	ctx.lr = 0x825B4DB0;
	sub_82A006C8(ctx, base);
	// 825B4DB0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4DB4: 419A000C  beq cr6, 0x825b4dc0
	if ctx.cr[6].eq {
	pc = 0x825B4DC0; continue 'dispatch;
	}
	// 825B4DB8: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4DBC: 48000008  b 0x825b4dc4
	pc = 0x825B4DC4; continue 'dispatch;
            }
            0x825B4DC0 => {
    //   block [0x825B4DC0..0x825B4DC4)
	// 825B4DC0: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	pc = 0x825B4DC4; continue 'dispatch;
            }
            0x825B4DC4 => {
    //   block [0x825B4DC4..0x825B4DD4)
	// 825B4DC4: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B4DC8: 81C10144  lwz r14, 0x144(r1)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 825B4DCC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4DD0: 409A0014  bne cr6, 0x825b4de4
	if !ctx.cr[6].eq {
	pc = 0x825B4DE4; continue 'dispatch;
	}
	pc = 0x825B4DD4; continue 'dispatch;
            }
            0x825B4DD4 => {
    //   block [0x825B4DD4..0x825B4DE4)
	// 825B4DD4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B4DD8: 7F1EB040  cmplw cr6, r30, r22
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825B4DDC: 409AFF28  bne cr6, 0x825b4d04
	if !ctx.cr[6].eq {
	pc = 0x825B4D04; continue 'dispatch;
	}
	// 825B4DE0: 48000014  b 0x825b4df4
	pc = 0x825B4DF4; continue 'dispatch;
            }
            0x825B4DE4 => {
    //   block [0x825B4DE4..0x825B4DF4)
	// 825B4DE4: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 825B4DE8: 48000379  bl 0x825b5160
	ctx.lr = 0x825B4DEC;
	sub_825B5160(ctx, base);
	// 825B4DEC: 93EE00B4  stw r31, 0xb4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 825B4DF0: 3AA00001  li r21, 1
	ctx.r[21].s64 = 1;
	pc = 0x825B4DF4; continue 'dispatch;
            }
            0x825B4DF4 => {
    //   block [0x825B4DF4..0x825B4DFC)
	// 825B4DF4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B4DF8: 4BC66F41  bl 0x8221bd38
	ctx.lr = 0x825B4DFC;
	sub_8221BD38(ctx, base);
	pc = 0x825B4DFC; continue 'dispatch;
            }
            0x825B4DFC => {
    //   block [0x825B4DFC..0x825B4E34)
	// 825B4DFC: 56AB063E  clrlwi r11, r21, 0x18
	ctx.r[11].u64 = ctx.r[21].u32 as u64 & 0x000000FFu64;
	// 825B4E00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4E04: 409A0104  bne cr6, 0x825b4f08
	if !ctx.cr[6].eq {
	pc = 0x825B4F08; continue 'dispatch;
	}
	// 825B4E08: 808E00B4  lwz r4, 0xb4(r14)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B4E0C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4E10: 419A0024  beq cr6, 0x825b4e34
	if ctx.cr[6].eq {
	pc = 0x825B4E34; continue 'dispatch;
	}
	// 825B4E14: 80726DA0  lwz r3, 0x6da0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B4E18: 4BC2F439  bl 0x821e4250
	ctx.lr = 0x825B4E1C;
	sub_821E4250(ctx, base);
	// 825B4E1C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4E20: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4E24: 419A00E4  beq cr6, 0x825b4f08
	if ctx.cr[6].eq {
	pc = 0x825B4F08; continue 'dispatch;
	}
	// 825B4E28: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 825B4E2C: 48000335  bl 0x825b5160
	ctx.lr = 0x825B4E30;
	sub_825B5160(ctx, base);
	// 825B4E30: 480000D8  b 0x825b4f08
	pc = 0x825B4F08; continue 'dispatch;
            }
            0x825B4E34 => {
    //   block [0x825B4E34..0x825B4E78)
	// 825B4E34: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4E38: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4E3C: 3BEB53C0  addi r31, r11, 0x53c0
	ctx.r[31].s64 = ctx.r[11].s64 + 21440;
	// 825B4E40: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B4E44: 4BCF4BA5  bl 0x822a99e8
	ctx.lr = 0x825B4E48;
	sub_822A99E8(ctx, base);
	// 825B4E48: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B4E4C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B4E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B4E54: 4BC3EF05  bl 0x821f3d58
	ctx.lr = 0x825B4E58;
	sub_821F3D58(ctx, base);
	// 825B4E58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4E5C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4E60: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B4E64: 4844B865  bl 0x82a006c8
	ctx.lr = 0x825B4E68;
	sub_82A006C8(ctx, base);
	// 825B4E68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B4E6C: 419A000C  beq cr6, 0x825b4e78
	if ctx.cr[6].eq {
	pc = 0x825B4E78; continue 'dispatch;
	}
	// 825B4E70: 83E30000  lwz r31, 0(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4E74: 48000008  b 0x825b4e7c
	pc = 0x825B4E7C; continue 'dispatch;
            }
            0x825B4E78 => {
    //   block [0x825B4E78..0x825B4E7C)
	// 825B4E78: 7DFF7B78  mr r31, r15
	ctx.r[31].u64 = ctx.r[15].u64;
	pc = 0x825B4E7C; continue 'dispatch;
            }
            0x825B4E7C => {
    //   block [0x825B4E7C..0x825B4E98)
	// 825B4E7C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B4E80: 419A0018  beq cr6, 0x825b4e98
	if ctx.cr[6].eq {
	pc = 0x825B4E98; continue 'dispatch;
	}
	// 825B4E84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B4E88: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 825B4E8C: 480002D5  bl 0x825b5160
	ctx.lr = 0x825B4E90;
	sub_825B5160(ctx, base);
	// 825B4E90: 93EE00B4  stw r31, 0xb4(r14)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[14].u32.wrapping_add(180 as u32), ctx.r[31].u32 ) };
	// 825B4E94: 48000074  b 0x825b4f08
	pc = 0x825B4F08; continue 'dispatch;
            }
            0x825B4E98 => {
    //   block [0x825B4E98..0x825B4ECC)
	// 825B4E98: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4E9C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4EA0: 388B53D8  addi r4, r11, 0x53d8
	ctx.r[4].s64 = ctx.r[11].s64 + 21464;
	// 825B4EA4: 4BCF4B45  bl 0x822a99e8
	ctx.lr = 0x825B4EA8;
	sub_822A99E8(ctx, base);
	// 825B4EA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4EAC: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4EB0: 419A0058  beq cr6, 0x825b4f08
	if ctx.cr[6].eq {
	pc = 0x825B4F08; continue 'dispatch;
	}
	// 825B4EB4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B4EB8: 4844BAD9  bl 0x82a00990
	ctx.lr = 0x825B4EBC;
	sub_82A00990(ctx, base);
	// 825B4EBC: 83E10068  lwz r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B4EC0: 83C10064  lwz r30, 0x64(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B4EC4: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B4EC8: 419A0038  beq cr6, 0x825b4f00
	if ctx.cr[6].eq {
	pc = 0x825B4F00; continue 'dispatch;
	}
	pc = 0x825B4ECC; continue 'dispatch;
            }
            0x825B4ECC => {
    //   block [0x825B4ECC..0x825B4EF0)
	// 825B4ECC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B4ED0: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B4ED4: 481CE655  bl 0x82783528
	ctx.lr = 0x825B4ED8;
	sub_82783528(ctx, base);
	// 825B4ED8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4EDC: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4EE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B4EE4: 4099000C  ble cr6, 0x825b4ef0
	if !ctx.cr[6].gt {
	pc = 0x825B4EF0; continue 'dispatch;
	}
	// 825B4EE8: 386E0024  addi r3, r14, 0x24
	ctx.r[3].s64 = ctx.r[14].s64 + 36;
	// 825B4EEC: 480049D5  bl 0x825b98c0
	ctx.lr = 0x825B4EF0;
	sub_825B98C0(ctx, base);
	pc = 0x825B4EF0; continue 'dispatch;
            }
            0x825B4EF0 => {
    //   block [0x825B4EF0..0x825B4F00)
	// 825B4EF0: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B4EF4: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825B4EF8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B4EFC: 409AFFD0  bne cr6, 0x825b4ecc
	if !ctx.cr[6].eq {
	pc = 0x825B4ECC; continue 'dispatch;
	}
	pc = 0x825B4F00; continue 'dispatch;
            }
            0x825B4F00 => {
    //   block [0x825B4F00..0x825B4F08)
	// 825B4F00: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B4F04: 4BC66E35  bl 0x8221bd38
	ctx.lr = 0x825B4F08;
	sub_8221BD38(ctx, base);
	pc = 0x825B4F08; continue 'dispatch;
            }
            0x825B4F08 => {
    //   block [0x825B4F08..0x825B4F4C)
	// 825B4F08: 810E0080  lwz r8, 0x80(r14)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(128 as u32) ) } as u64;
	// 825B4F0C: 3BEE007C  addi r31, r14, 0x7c
	ctx.r[31].s64 = ctx.r[14].s64 + 124;
	// 825B4F10: 816E0084  lwz r11, 0x84(r14)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[14].u32.wrapping_add(132 as u32) ) } as u64;
	// 825B4F14: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 825B4F18: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B4F1C: 419A005C  beq cr6, 0x825b4f78
	if ctx.cr[6].eq {
	pc = 0x825B4F78; continue 'dispatch;
	}
	// 825B4F20: 7D4B5850  subf r10, r11, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B4F24: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825B4F28: 7D4AD3D6  divw r10, r10, r26
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 825B4F2C: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B4F30: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825B4F34: 7CEA3A14  add r7, r10, r7
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825B4F38: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B4F3C: 7CEA4214  add r7, r10, r8
	ctx.r[7].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B4F40: 419A0034  beq cr6, 0x825b4f74
	if ctx.cr[6].eq {
	pc = 0x825B4F74; continue 'dispatch;
	}
	// 825B4F44: 39480004  addi r10, r8, 4
	ctx.r[10].s64 = ctx.r[8].s64 + 4;
	// 825B4F48: 7D085850  subf r8, r8, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	pc = 0x825B4F4C; continue 'dispatch;
            }
            0x825B4F4C => {
    //   block [0x825B4F4C..0x825B4F74)
	// 825B4F4C: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4F50: 90CAFFFC  stw r6, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825B4F54: 7CA8502E  lwzx r5, r8, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B4F58: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825B4F5C: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4F60: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825B4F64: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825B4F68: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825B4F6C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B4F70: 409AFFDC  bne cr6, 0x825b4f4c
	if !ctx.cr[6].eq {
	pc = 0x825B4F4C; continue 'dispatch;
	}
	pc = 0x825B4F74; continue 'dispatch;
            }
            0x825B4F74 => {
    //   block [0x825B4F74..0x825B4F78)
	// 825B4F74: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	pc = 0x825B4F78; continue 'dispatch;
            }
            0x825B4F78 => {
    //   block [0x825B4F78..0x825B4FCC)
	// 825B4F78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4F7C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B4F80: 388B53F0  addi r4, r11, 0x53f0
	ctx.r[4].s64 = ctx.r[11].s64 + 21488;
	// 825B4F84: 4BCF4A65  bl 0x822a99e8
	ctx.lr = 0x825B4F88;
	sub_822A99E8(ctx, base);
	// 825B4F88: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B4F8C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B4F90: 419A01BC  beq cr6, 0x825b514c
	if ctx.cr[6].eq {
	pc = 0x825B514C; continue 'dispatch;
	}
	// 825B4F94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B4F98: 4844B9F9  bl 0x82a00990
	ctx.lr = 0x825B4F9C;
	sub_82A00990(ctx, base);
	// 825B4F9C: 83C10068  lwz r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B4FA0: 83010064  lwz r24, 0x64(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B4FA4: 83210060  lwz r25, 0x60(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B4FA8: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825B4FAC: 419A0158  beq cr6, 0x825b5104
	if ctx.cr[6].eq {
	pc = 0x825B5104; continue 'dispatch;
	}
	// 825B4FB0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B4FB4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B4FB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B4FBC: 3AE0FFFF  li r23, -1
	ctx.r[23].s64 = -1;
	// 825B4FC0: 3BA9541C  addi r29, r9, 0x541c
	ctx.r[29].s64 = ctx.r[9].s64 + 21532;
	// 825B4FC4: 3B8A5410  addi r28, r10, 0x5410
	ctx.r[28].s64 = ctx.r[10].s64 + 21520;
	// 825B4FC8: 3B6B5400  addi r27, r11, 0x5400
	ctx.r[27].s64 = ctx.r[11].s64 + 21504;
	pc = 0x825B4FCC; continue 'dispatch;
            }
            0x825B4FCC => {
    //   block [0x825B4FCC..0x825B5008)
	// 825B4FCC: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4FD0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825B4FD4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B4FD8: 7D6BCA14  add r11, r11, r25
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825B4FDC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B4FE0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4FE4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B4FE8: 419A0020  beq cr6, 0x825b5008
	if ctx.cr[6].eq {
	pc = 0x825B5008; continue 'dispatch;
	}
	// 825B4FEC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B4FF0: 409A0018  bne cr6, 0x825b5008
	if !ctx.cr[6].eq {
	pc = 0x825B5008; continue 'dispatch;
	}
	// 825B4FF4: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B4FF8: 8171E454  lwz r11, -0x1bac(r17)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B4FFC: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B5000: 409A0008  bne cr6, 0x825b5008
	if !ctx.cr[6].eq {
	pc = 0x825B5008; continue 'dispatch;
	}
	// 825B5004: 7E0A8378  mr r10, r16
	ctx.r[10].u64 = ctx.r[16].u64;
	pc = 0x825B5008; continue 'dispatch;
            }
            0x825B5008 => {
    //   block [0x825B5008..0x825B5068)
	// 825B5008: 80726DA0  lwz r3, 0x6da0(r18)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B500C: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5010: 4BC2F241  bl 0x821e4250
	ctx.lr = 0x825B5014;
	sub_821E4250(ctx, base);
	// 825B5014: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825B5018: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825B501C: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B5020: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5024: 481CE3F5  bl 0x82783418
	ctx.lr = 0x825B5028;
	sub_82783418(ctx, base);
	// 825B5028: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B502C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B5030: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B5034: 481CE3E5  bl 0x82783418
	ctx.lr = 0x825B5038;
	sub_82783418(ctx, base);
	// 825B5038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B503C: 7E649B78  mr r4, r19
	ctx.r[4].u64 = ctx.r[19].u64;
	// 825B5040: 3AA10058  addi r21, r1, 0x58
	ctx.r[21].s64 = ctx.r[1].s64 + 88;
	// 825B5044: 4BC3ED15  bl 0x821f3d58
	ctx.lr = 0x825B5048;
	sub_821F3D58(ctx, base);
	// 825B5048: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B504C: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B5050: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825B5054: 4BC309B5  bl 0x821e5a08
	ctx.lr = 0x825B5058;
	sub_821E5A08(ctx, base);
	// 825B5058: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B505C: 419A000C  beq cr6, 0x825b5068
	if ctx.cr[6].eq {
	pc = 0x825B5068; continue 'dispatch;
	}
	// 825B5060: 81030000  lwz r8, 0(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5064: 48000008  b 0x825b506c
	pc = 0x825B506C; continue 'dispatch;
            }
            0x825B5068 => {
    //   block [0x825B5068..0x825B506C)
	// 825B5068: 7EE8BB78  mr r8, r23
	ctx.r[8].u64 = ctx.r[23].u64;
	pc = 0x825B506C; continue 'dispatch;
            }
            0x825B506C => {
    //   block [0x825B506C..0x825B5094)
	// 825B506C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B5070: 80C10054  lwz r6, 0x54(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B5074: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5078: 91010074  stw r8, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[8].u32 ) };
	// 825B507C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5080: 90E10070  stw r7, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[7].u32 ) };
	// 825B5084: 90C10078  stw r6, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[6].u32 ) };
	// 825B5088: 409A000C  bne cr6, 0x825b5094
	if !ctx.cr[6].eq {
	pc = 0x825B5094; continue 'dispatch;
	}
	// 825B508C: 7DE97B78  mr r9, r15
	ctx.r[9].u64 = ctx.r[15].u64;
	// 825B5090: 48000010  b 0x825b50a0
	pc = 0x825B50A0; continue 'dispatch;
            }
            0x825B5094 => {
    //   block [0x825B5094..0x825B50A0)
	// 825B5094: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5098: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B509C: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	pc = 0x825B50A0; continue 'dispatch;
            }
            0x825B50A0 => {
    //   block [0x825B50A0..0x825B50C8)
	// 825B50A0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B50A4: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B50A8: 7CAAD3D6  divw r5, r10, r26
	ctx.r[5].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	// 825B50AC: 7F054840  cmplw cr6, r5, r9
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B50B0: 40980024  bge cr6, 0x825b50d4
	if !ctx.cr[6].lt {
	pc = 0x825B50D4; continue 'dispatch;
	}
	// 825B50B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B50B8: 419A0010  beq cr6, 0x825b50c8
	if ctx.cr[6].eq {
	pc = 0x825B50C8; continue 'dispatch;
	}
	// 825B50BC: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825B50C0: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825B50C4: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x825B50C8; continue 'dispatch;
            }
            0x825B50C8 => {
    //   block [0x825B50C8..0x825B50D4)
	// 825B50C8: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825B50CC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B50D0: 48000020  b 0x825b50f0
	pc = 0x825B50F0; continue 'dispatch;
            }
            0x825B50D4 => {
    //   block [0x825B50D4..0x825B50F0)
	// 825B50D4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B50D8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825B50DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B50E0: 91E10060  stw r15, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[15].u32 ) };
	// 825B50E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B50E8: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825B50EC: 480065CD  bl 0x825bb6b8
	ctx.lr = 0x825B50F0;
	sub_825BB6B8(ctx, base);
	pc = 0x825B50F0; continue 'dispatch;
            }
            0x825B50F0 => {
    //   block [0x825B50F0..0x825B5104)
	// 825B50F0: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B50F4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B50F8: 7F1EC040  cmplw cr6, r30, r24
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825B50FC: 997F0011  stb r11, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[11].u8 ) };
	// 825B5100: 409AFECC  bne cr6, 0x825b4fcc
	if !ctx.cr[6].eq {
	pc = 0x825B4FCC; continue 'dispatch;
	}
	pc = 0x825B5104; continue 'dispatch;
            }
            0x825B5104 => {
    //   block [0x825B5104..0x825B5144)
	// 825B5104: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 825B5108: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B510C: 419A0038  beq cr6, 0x825b5144
	if ctx.cr[6].eq {
	pc = 0x825B5144; continue 'dispatch;
	}
	// 825B5110: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5114: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5118: 91E10058  stw r15, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[15].u32 ) };
	// 825B511C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B5120: 91E10060  stw r15, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[15].u32 ) };
	// 825B5124: 88DF0010  lbz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B5128: 7CA9D3D6  divw r5, r9, r26
	ctx.r[5].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825B512C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825B5130: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B5134: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825B5138: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B513C: 48007BF5  bl 0x825bcd30
	ctx.lr = 0x825B5140;
	sub_825BCD30(ctx, base);
	// 825B5140: 99FF0011  stb r15, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[15].u8 ) };
	pc = 0x825B5144; continue 'dispatch;
            }
            0x825B5144 => {
    //   block [0x825B5144..0x825B514C)
	// 825B5144: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5148: 4BC66BF1  bl 0x8221bd38
	ctx.lr = 0x825B514C;
	sub_8221BD38(ctx, base);
	pc = 0x825B514C; continue 'dispatch;
            }
            0x825B514C => {
    //   block [0x825B514C..0x825B5158)
	// 825B514C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B5150: 7DC37378  mr r3, r14
	ctx.r[3].u64 = ctx.r[14].u64;
	// 825B5154: 48003D75  bl 0x825b8ec8
	ctx.lr = 0x825B5158;
	sub_825B8EC8(ctx, base);
	pc = 0x825B5158; continue 'dispatch;
            }
            0x825B5158 => {
    //   block [0x825B5158..0x825B5160)
	// 825B5158: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 825B515C: 486F42C4  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5160 size=1520
    let mut pc: u32 = 0x825B5160;
    'dispatch: loop {
        match pc {
            0x825B5160 => {
    //   block [0x825B5160..0x825B51C4)
	// 825B5160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5164: 486F4295  bl 0x82ca93f8
	ctx.lr = 0x825B5168;
	sub_82CA93D0(ctx, base);
	// 825B5168: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B516C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825B5170: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825B5174: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B5178: 419A05D0  beq cr6, 0x825b5748
	if ctx.cr[6].eq {
	pc = 0x825B5748; continue 'dispatch;
	}
	// 825B517C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5180: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5184: 388B5428  addi r4, r11, 0x5428
	ctx.r[4].s64 = ctx.r[11].s64 + 21544;
	// 825B5188: 4BCF4861  bl 0x822a99e8
	ctx.lr = 0x825B518C;
	sub_822A99E8(ctx, base);
	// 825B518C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5190: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5194: 419A0098  beq cr6, 0x825b522c
	if ctx.cr[6].eq {
	pc = 0x825B522C; continue 'dispatch;
	}
	// 825B5198: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B519C: 4844B7F5  bl 0x82a00990
	ctx.lr = 0x825B51A0;
	sub_82A00990(ctx, base);
	// 825B51A0: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B51A4: 8381005C  lwz r28, 0x5c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B51A8: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B51AC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B51B0: 419A0074  beq cr6, 0x825b5224
	if ctx.cr[6].eq {
	pc = 0x825B5224; continue 'dispatch;
	}
	// 825B51B4: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B51B8: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 825B51BC: 3F60834A  lis r27, -0x7cb6
	ctx.r[27].s64 = -2092302336;
	// 825B51C0: 3B4BE460  addi r26, r11, -0x1ba0
	ctx.r[26].s64 = ctx.r[11].s64 + -7072;
	pc = 0x825B51C4; continue 'dispatch;
            }
            0x825B51C4 => {
    //   block [0x825B51C4..0x825B5200)
	// 825B51C4: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B51C8: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825B51CC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B51D0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B51D4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B51D8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B51DC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B51E0: 419A0020  beq cr6, 0x825b5200
	if ctx.cr[6].eq {
	pc = 0x825B5200; continue 'dispatch;
	}
	// 825B51E4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B51E8: 409A0018  bne cr6, 0x825b5200
	if !ctx.cr[6].eq {
	pc = 0x825B5200; continue 'dispatch;
	}
	// 825B51EC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B51F0: 817BE454  lwz r11, -0x1bac(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B51F4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B51F8: 409A0008  bne cr6, 0x825b5200
	if !ctx.cr[6].eq {
	pc = 0x825B5200; continue 'dispatch;
	}
	// 825B51FC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x825B5200; continue 'dispatch;
            }
            0x825B5200 => {
    //   block [0x825B5200..0x825B5224)
	// 825B5200: 807D6DA0  lwz r3, 0x6da0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B5204: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5208: 4BC2F049  bl 0x821e4250
	ctx.lr = 0x825B520C;
	sub_821E4250(ctx, base);
	// 825B520C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5210: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5214: 480005F5  bl 0x825b5808
	ctx.lr = 0x825B5218;
	sub_825B5808(ctx, base);
	// 825B5218: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B521C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B5220: 409AFFA4  bne cr6, 0x825b51c4
	if !ctx.cr[6].eq {
	pc = 0x825B51C4; continue 'dispatch;
	}
	pc = 0x825B5224; continue 'dispatch;
            }
            0x825B5224 => {
    //   block [0x825B5224..0x825B522C)
	// 825B5224: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B5228: 4BC66B11  bl 0x8221bd38
	ctx.lr = 0x825B522C;
	sub_8221BD38(ctx, base);
	pc = 0x825B522C; continue 'dispatch;
            }
            0x825B522C => {
    //   block [0x825B522C..0x825B526C)
	// 825B522C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5230: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B5234: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	// 825B5238: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B523C: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 825B5240: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B5244: 419A00D4  beq cr6, 0x825b5318
	if ctx.cr[6].eq {
	pc = 0x825B5318; continue 'dispatch;
	}
	// 825B5248: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B524C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5250: 419A001C  beq cr6, 0x825b526c
	if ctx.cr[6].eq {
	pc = 0x825B526C; continue 'dispatch;
	}
	// 825B5254: 894A00DB  lbz r10, 0xdb(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(219 as u32) ) } as u64;
	// 825B5258: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B525C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B5260: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B5264: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5268: 480000B0  b 0x825b5318
	pc = 0x825B5318; continue 'dispatch;
            }
            0x825B526C => {
    //   block [0x825B526C..0x825B5288)
	// 825B526C: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B5270: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B5274: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B5278: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B527C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B5280: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5284: 40810054  ble 0x825b52d8
	if !ctx.cr[0].gt {
	pc = 0x825B52D8; continue 'dispatch;
	}
	pc = 0x825B5288; continue 'dispatch;
            }
            0x825B5288 => {
    //   block [0x825B5288..0x825B52A8)
	// 825B5288: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B528C: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B5290: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B5294: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5298: 2F0700DB  cmpwi cr6, r7, 0xdb
	ctx.cr[6].compare_i32(ctx.r[7].s32, 219, &mut ctx.xer);
	// 825B529C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B52A0: 41980008  blt cr6, 0x825b52a8
	if ctx.cr[6].lt {
	pc = 0x825B52A8; continue 'dispatch;
	}
	// 825B52A4: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B52A8; continue 'dispatch;
            }
            0x825B52A8 => {
    //   block [0x825B52A8..0x825B52C4)
	// 825B52A8: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B52AC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B52B0: 419A0014  beq cr6, 0x825b52c4
	if ctx.cr[6].eq {
	pc = 0x825B52C4; continue 'dispatch;
	}
	// 825B52B4: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B52B8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B52BC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B52C0: 4800000C  b 0x825b52cc
	pc = 0x825B52CC; continue 'dispatch;
            }
            0x825B52C4 => {
    //   block [0x825B52C4..0x825B52CC)
	// 825B52C4: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B52C8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B52CC; continue 'dispatch;
            }
            0x825B52CC => {
    //   block [0x825B52CC..0x825B52D8)
	// 825B52CC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B52D0: 4199FFB8  bgt cr6, 0x825b5288
	if ctx.cr[6].gt {
	pc = 0x825B5288; continue 'dispatch;
	}
	// 825B52D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B52D8; continue 'dispatch;
            }
            0x825B52D8 => {
    //   block [0x825B52D8..0x825B52F4)
	// 825B52D8: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B52DC: 419A0034  beq cr6, 0x825b5310
	if ctx.cr[6].eq {
	pc = 0x825B5310; continue 'dispatch;
	}
	// 825B52E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B52E4: 2F0B00DB  cmpwi cr6, r11, 0xdb
	ctx.cr[6].compare_i32(ctx.r[11].s32, 219, &mut ctx.xer);
	// 825B52E8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B52EC: 41990008  bgt cr6, 0x825b52f4
	if ctx.cr[6].gt {
	pc = 0x825B52F4; continue 'dispatch;
	}
	// 825B52F0: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B52F4; continue 'dispatch;
            }
            0x825B52F4 => {
    //   block [0x825B52F4..0x825B5310)
	// 825B52F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B52F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B52FC: 409A0014  bne cr6, 0x825b5310
	if !ctx.cr[6].eq {
	pc = 0x825B5310; continue 'dispatch;
	}
	// 825B5300: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B5304: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825B5308: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B530C: 48000008  b 0x825b5314
	pc = 0x825B5314; continue 'dispatch;
            }
            0x825B5310 => {
    //   block [0x825B5310..0x825B5314)
	// 825B5310: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825B5314; continue 'dispatch;
            }
            0x825B5314 => {
    //   block [0x825B5314..0x825B5318)
	// 825B5314: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B5318; continue 'dispatch;
            }
            0x825B5318 => {
    //   block [0x825B5318..0x825B5348)
	// 825B5318: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B531C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5320: 388B5438  addi r4, r11, 0x5438
	ctx.r[4].s64 = ctx.r[11].s64 + 21560;
	// 825B5324: 4BCF46C5  bl 0x822a99e8
	ctx.lr = 0x825B5328;
	sub_822A99E8(ctx, base);
	// 825B5328: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B532C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B5330: 419A0040  beq cr6, 0x825b5370
	if ctx.cr[6].eq {
	pc = 0x825B5370; continue 'dispatch;
	}
	// 825B5334: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B5338: 419A0010  beq cr6, 0x825b5348
	if ctx.cr[6].eq {
	pc = 0x825B5348; continue 'dispatch;
	}
	// 825B533C: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5340: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5344: 409A002C  bne cr6, 0x825b5370
	if !ctx.cr[6].eq {
	pc = 0x825B5370; continue 'dispatch;
	}
	pc = 0x825B5348; continue 'dispatch;
            }
            0x825B5348 => {
    //   block [0x825B5348..0x825B5370)
	// 825B5348: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B534C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5350: 480006D9  bl 0x825b5a28
	ctx.lr = 0x825B5354;
	sub_825B5A28(ctx, base);
	// 825B5354: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5358: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B535C: 38AB5444  addi r5, r11, 0x5444
	ctx.r[5].s64 = ctx.r[11].s64 + 21572;
	// 825B5360: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5364: 481CE0B5  bl 0x82783418
	ctx.lr = 0x825B5368;
	sub_82783418(ctx, base);
	// 825B5368: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B536C: 91590020  stw r10, 0x20(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(32 as u32), ctx.r[10].u32 ) };
	pc = 0x825B5370; continue 'dispatch;
            }
            0x825B5370 => {
    //   block [0x825B5370..0x825B53C0)
	// 825B5370: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5374: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5378: 388B544C  addi r4, r11, 0x544c
	ctx.r[4].s64 = ctx.r[11].s64 + 21580;
	// 825B537C: 4BCF466D  bl 0x822a99e8
	ctx.lr = 0x825B5380;
	sub_822A99E8(ctx, base);
	// 825B5380: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5384: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5388: 480006A1  bl 0x825b5a28
	ctx.lr = 0x825B538C;
	sub_825B5A28(ctx, base);
	// 825B538C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B5390: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5394: 388A5458  addi r4, r10, 0x5458
	ctx.r[4].s64 = ctx.r[10].s64 + 21592;
	// 825B5398: 4BCF4651  bl 0x822a99e8
	ctx.lr = 0x825B539C;
	sub_822A99E8(ctx, base);
	// 825B539C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B53A0: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B53A4: 48000685  bl 0x825b5a28
	ctx.lr = 0x825B53A8;
	sub_825B5A28(ctx, base);
	// 825B53A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B53AC: 419A0014  beq cr6, 0x825b53c0
	if ctx.cr[6].eq {
	pc = 0x825B53C0; continue 'dispatch;
	}
	// 825B53B0: 897E000C  lbz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B53B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B53B8: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B53BC: 409A0008  bne cr6, 0x825b53c4
	if !ctx.cr[6].eq {
	pc = 0x825B53C4; continue 'dispatch;
	}
	pc = 0x825B53C0; continue 'dispatch;
            }
            0x825B53C0 => {
    //   block [0x825B53C0..0x825B53C4)
	// 825B53C0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825B53C4; continue 'dispatch;
            }
            0x825B53C4 => {
    //   block [0x825B53C4..0x825B5408)
	// 825B53C4: 80D90004  lwz r6, 4(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B53C8: 5564063E  clrlwi r4, r11, 0x18
	ctx.r[4].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B53CC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 825B53D0: 81460024  lwz r10, 0x24(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B53D4: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 825B53D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B53DC: 419A00E8  beq cr6, 0x825b54c4
	if ctx.cr[6].eq {
	pc = 0x825B54C4; continue 'dispatch;
	}
	// 825B53E0: 8166008C  lwz r11, 0x8c(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B53E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B53E8: 419A0020  beq cr6, 0x825b5408
	if ctx.cr[6].eq {
	pc = 0x825B5408; continue 'dispatch;
	}
	// 825B53EC: 894B0014  lbz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B53F0: 81660048  lwz r11, 0x48(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B53F4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B53F8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B53FC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B5400: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5404: 480000C4  b 0x825b54c8
	pc = 0x825B54C8; continue 'dispatch;
            }
            0x825B5408 => {
    //   block [0x825B5408..0x825B5424)
	// 825B5408: 81460048  lwz r10, 0x48(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B540C: 80A6004C  lwz r5, 0x4c(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B5410: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B5414: 7D6A2850  subf r11, r10, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[10].s64;
	// 825B5418: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B541C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5420: 40810054  ble 0x825b5474
	if !ctx.cr[0].gt {
	pc = 0x825B5474; continue 'dispatch;
	}
	pc = 0x825B5424; continue 'dispatch;
            }
            0x825B5424 => {
    //   block [0x825B5424..0x825B5444)
	// 825B5424: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B5428: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B542C: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B5430: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5434: 2F070014  cmpwi cr6, r7, 0x14
	ctx.cr[6].compare_i32(ctx.r[7].s32, 20, &mut ctx.xer);
	// 825B5438: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B543C: 41980008  blt cr6, 0x825b5444
	if ctx.cr[6].lt {
	pc = 0x825B5444; continue 'dispatch;
	}
	// 825B5440: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B5444; continue 'dispatch;
            }
            0x825B5444 => {
    //   block [0x825B5444..0x825B5460)
	// 825B5444: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B5448: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B544C: 419A0014  beq cr6, 0x825b5460
	if ctx.cr[6].eq {
	pc = 0x825B5460; continue 'dispatch;
	}
	// 825B5450: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B5454: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B5458: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B545C: 4800000C  b 0x825b5468
	pc = 0x825B5468; continue 'dispatch;
            }
            0x825B5460 => {
    //   block [0x825B5460..0x825B5468)
	// 825B5460: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B5464: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B5468; continue 'dispatch;
            }
            0x825B5468 => {
    //   block [0x825B5468..0x825B5474)
	// 825B5468: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B546C: 4199FFB8  bgt cr6, 0x825b5424
	if ctx.cr[6].gt {
	pc = 0x825B5424; continue 'dispatch;
	}
	// 825B5470: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B5474; continue 'dispatch;
            }
            0x825B5474 => {
    //   block [0x825B5474..0x825B5490)
	// 825B5474: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825B5478: 419A003C  beq cr6, 0x825b54b4
	if ctx.cr[6].eq {
	pc = 0x825B54B4; continue 'dispatch;
	}
	// 825B547C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5480: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 825B5484: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B5488: 41990008  bgt cr6, 0x825b5490
	if ctx.cr[6].gt {
	pc = 0x825B5490; continue 'dispatch;
	}
	// 825B548C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B5490; continue 'dispatch;
            }
            0x825B5490 => {
    //   block [0x825B5490..0x825B54B4)
	// 825B5490: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B5494: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5498: 409A001C  bne cr6, 0x825b54b4
	if !ctx.cr[6].eq {
	pc = 0x825B54B4; continue 'dispatch;
	}
	// 825B549C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B54A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B54A4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825B54A8: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B54AC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B54B0: 48000018  b 0x825b54c8
	pc = 0x825B54C8; continue 'dispatch;
            }
            0x825B54B4 => {
    //   block [0x825B54B4..0x825B54C4)
	// 825B54B4: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B54B8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B54BC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B54C0: 48000008  b 0x825b54c8
	pc = 0x825B54C8; continue 'dispatch;
            }
            0x825B54C4 => {
    //   block [0x825B54C4..0x825B54C8)
	// 825B54C4: 7FEAFB78  mr r10, r31
	ctx.r[10].u64 = ctx.r[31].u64;
	pc = 0x825B54C8; continue 'dispatch;
            }
            0x825B54C8 => {
    //   block [0x825B54C8..0x825B54F4)
	// 825B54C8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B54CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B54D0: 419A0024  beq cr6, 0x825b54f4
	if ctx.cr[6].eq {
	pc = 0x825B54F4; continue 'dispatch;
	}
	// 825B54D4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B54D8: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 825B54DC: 409A0018  bne cr6, 0x825b54f4
	if !ctx.cr[6].eq {
	pc = 0x825B54F4; continue 'dispatch;
	}
	// 825B54E0: 81660028  lwz r11, 0x28(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B54E4: 556A1FFE  rlwinm r10, r11, 3, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x1FFFFFFFu64;
	// 825B54E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B54EC: 409A0008  bne cr6, 0x825b54f4
	if !ctx.cr[6].eq {
	pc = 0x825B54F4; continue 'dispatch;
	}
	// 825B54F0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	pc = 0x825B54F4; continue 'dispatch;
            }
            0x825B54F4 => {
    //   block [0x825B54F4..0x825B551C)
	// 825B54F4: 548B063E  clrlwi r11, r4, 0x18
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 825B54F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B54FC: 419A0020  beq cr6, 0x825b551c
	if ctx.cr[6].eq {
	pc = 0x825B551C; continue 'dispatch;
	}
	// 825B5500: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5504: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5508: 388B5464  addi r4, r11, 0x5464
	ctx.r[4].s64 = ctx.r[11].s64 + 21604;
	// 825B550C: 4BCF44DD  bl 0x822a99e8
	ctx.lr = 0x825B5510;
	sub_822A99E8(ctx, base);
	// 825B5510: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5514: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5518: 48000239  bl 0x825b5750
	ctx.lr = 0x825B551C;
	sub_825B5750(ctx, base);
	pc = 0x825B551C; continue 'dispatch;
            }
            0x825B551C => {
    //   block [0x825B551C..0x825B55D0)
	// 825B551C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5520: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5524: 388B5474  addi r4, r11, 0x5474
	ctx.r[4].s64 = ctx.r[11].s64 + 21620;
	// 825B5528: 4BCF44C1  bl 0x822a99e8
	ctx.lr = 0x825B552C;
	sub_822A99E8(ctx, base);
	// 825B552C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5530: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5534: 4800021D  bl 0x825b5750
	ctx.lr = 0x825B5538;
	sub_825B5750(ctx, base);
	// 825B5538: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B553C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5540: 388A5488  addi r4, r10, 0x5488
	ctx.r[4].s64 = ctx.r[10].s64 + 21640;
	// 825B5544: 4BCF44A5  bl 0x822a99e8
	ctx.lr = 0x825B5548;
	sub_822A99E8(ctx, base);
	// 825B5548: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B554C: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5550: 48000201  bl 0x825b5750
	ctx.lr = 0x825B5554;
	sub_825B5750(ctx, base);
	// 825B5554: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B5558: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B555C: 38895498  addi r4, r9, 0x5498
	ctx.r[4].s64 = ctx.r[9].s64 + 21656;
	// 825B5560: 4BCF4489  bl 0x822a99e8
	ctx.lr = 0x825B5564;
	sub_822A99E8(ctx, base);
	// 825B5564: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B5568: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B556C: 419A018C  beq cr6, 0x825b56f8
	if ctx.cr[6].eq {
	pc = 0x825B56F8; continue 'dispatch;
	}
	// 825B5570: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5574: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B5578: 38AB54A4  addi r5, r11, 0x54a4
	ctx.r[5].s64 = ctx.r[11].s64 + 21668;
	// 825B557C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5580: 481CDE99  bl 0x82783418
	ctx.lr = 0x825B5584;
	sub_82783418(ctx, base);
	// 825B5584: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B5588: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B558C: 419A016C  beq cr6, 0x825b56f8
	if ctx.cr[6].eq {
	pc = 0x825B56F8; continue 'dispatch;
	}
	// 825B5590: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5594: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B5598: 5549CFFE  rlwinm r9, r10, 0x19, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000007Fu64;
	// 825B559C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B55A0: 419A00F4  beq cr6, 0x825b5694
	if ctx.cr[6].eq {
	pc = 0x825B5694; continue 'dispatch;
	}
	// 825B55A4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B55A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B55AC: 419A0024  beq cr6, 0x825b55d0
	if ctx.cr[6].eq {
	pc = 0x825B55D0; continue 'dispatch;
	}
	// 825B55B0: 894A0007  lbz r10, 7(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(7 as u32) ) } as u64;
	// 825B55B4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B55B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B55BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B55C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B55C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B55C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B55CC: 480000CC  b 0x825b5698
	pc = 0x825B5698; continue 'dispatch;
            }
            0x825B55D0 => {
    //   block [0x825B55D0..0x825B55EC)
	// 825B55D0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B55D4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B55D8: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825B55DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B55E0: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B55E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B55E8: 40810054  ble 0x825b563c
	if !ctx.cr[0].gt {
	pc = 0x825B563C; continue 'dispatch;
	}
	pc = 0x825B55EC; continue 'dispatch;
            }
            0x825B55EC => {
    //   block [0x825B55EC..0x825B560C)
	// 825B55EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B55F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B55F4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825B55F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B55FC: 2F070007  cmpwi cr6, r7, 7
	ctx.cr[6].compare_i32(ctx.r[7].s32, 7, &mut ctx.xer);
	// 825B5600: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B5604: 41980008  blt cr6, 0x825b560c
	if ctx.cr[6].lt {
	pc = 0x825B560C; continue 'dispatch;
	}
	// 825B5608: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B560C; continue 'dispatch;
            }
            0x825B560C => {
    //   block [0x825B560C..0x825B5628)
	// 825B560C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B5610: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B5614: 419A0014  beq cr6, 0x825b5628
	if ctx.cr[6].eq {
	pc = 0x825B5628; continue 'dispatch;
	}
	// 825B5618: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B561C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B5620: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B5624: 4800000C  b 0x825b5630
	pc = 0x825B5630; continue 'dispatch;
            }
            0x825B5628 => {
    //   block [0x825B5628..0x825B5630)
	// 825B5628: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B562C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B5630; continue 'dispatch;
            }
            0x825B5630 => {
    //   block [0x825B5630..0x825B563C)
	// 825B5630: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5634: 4199FFB8  bgt cr6, 0x825b55ec
	if ctx.cr[6].gt {
	pc = 0x825B55EC; continue 'dispatch;
	}
	// 825B5638: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	pc = 0x825B563C; continue 'dispatch;
            }
            0x825B563C => {
    //   block [0x825B563C..0x825B5658)
	// 825B563C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B5640: 419A0040  beq cr6, 0x825b5680
	if ctx.cr[6].eq {
	pc = 0x825B5680; continue 'dispatch;
	}
	// 825B5644: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5648: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 825B564C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B5650: 41990008  bgt cr6, 0x825b5658
	if ctx.cr[6].gt {
	pc = 0x825B5658; continue 'dispatch;
	}
	// 825B5654: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B5658; continue 'dispatch;
            }
            0x825B5658 => {
    //   block [0x825B5658..0x825B5680)
	// 825B5658: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B565C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5660: 409A0020  bne cr6, 0x825b5680
	if !ctx.cr[6].eq {
	pc = 0x825B5680; continue 'dispatch;
	}
	// 825B5664: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B5668: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825B566C: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B5670: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5674: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B5678: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B567C: 4800001C  b 0x825b5698
	pc = 0x825B5698; continue 'dispatch;
            }
            0x825B5680 => {
    //   block [0x825B5680..0x825B5694)
	// 825B5680: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B5684: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5688: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B568C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B5690: 48000008  b 0x825b5698
	pc = 0x825B5698; continue 'dispatch;
            }
            0x825B5694 => {
    //   block [0x825B5694..0x825B5698)
	// 825B5694: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B5698; continue 'dispatch;
            }
            0x825B5698 => {
    //   block [0x825B5698..0x825B56F8)
	// 825B5698: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B569C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B56A0: 419A0058  beq cr6, 0x825b56f8
	if ctx.cr[6].eq {
	pc = 0x825B56F8; continue 'dispatch;
	}
	// 825B56A4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B56A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B56AC: 4BFE7CD5  bl 0x8259d380
	ctx.lr = 0x825B56B0;
	sub_8259D380(ctx, base);
	// 825B56B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B56B4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B56B8: 38AB54B4  addi r5, r11, 0x54b4
	ctx.r[5].s64 = ctx.r[11].s64 + 21684;
	// 825B56BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B56C0: 481CDD59  bl 0x82783418
	ctx.lr = 0x825B56C4;
	sub_82783418(ctx, base);
	// 825B56C4: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B56C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B56CC: 4BFE7D2D  bl 0x8259d3f8
	ctx.lr = 0x825B56D0;
	sub_8259D3F8(ctx, base);
	// 825B56D0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B56D4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B56D8: 38AA54C4  addi r5, r10, 0x54c4
	ctx.r[5].s64 = ctx.r[10].s64 + 21700;
	// 825B56DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B56E0: 481CDD39  bl 0x82783418
	ctx.lr = 0x825B56E4;
	sub_82783418(ctx, base);
	// 825B56E4: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B56E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B56EC: 38A954D8  addi r5, r9, 0x54d8
	ctx.r[5].s64 = ctx.r[9].s64 + 21720;
	// 825B56F0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B56F4: 481CDD25  bl 0x82783418
	ctx.lr = 0x825B56F8;
	sub_82783418(ctx, base);
	pc = 0x825B56F8; continue 'dispatch;
            }
            0x825B56F8 => {
    //   block [0x825B56F8..0x825B5748)
	// 825B56F8: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B56FC: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825B5700: 48003D01  bl 0x825b9400
	ctx.lr = 0x825B5704;
	sub_825B9400(ctx, base);
	// 825B5704: 3D60834C  lis r11, -0x7cb4
	ctx.r[11].s64 = -2092171264;
	// 825B5708: 894BEAEC  lbz r10, -0x1514(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-5396 as u32) ) } as u64;
	// 825B570C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5710: 419A0038  beq cr6, 0x825b5748
	if ctx.cr[6].eq {
	pc = 0x825B5748; continue 'dispatch;
	}
	// 825B5714: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5718: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B571C: 38AB54EC  addi r5, r11, 0x54ec
	ctx.r[5].s64 = ctx.r[11].s64 + 21740;
	// 825B5720: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5724: 481CDCF5  bl 0x82783418
	ctx.lr = 0x825B5728;
	sub_82783418(ctx, base);
	// 825B5728: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B572C: 5549003E  slwi r9, r10, 0
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B5730: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B5734: 915900B8  stw r10, 0xb8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(184 as u32), ctx.r[10].u32 ) };
	// 825B5738: 40990010  ble cr6, 0x825b5748
	if !ctx.cr[6].gt {
	pc = 0x825B5748; continue 'dispatch;
	}
	// 825B573C: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825B5740: 80790004  lwz r3, 4(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5744: 4BDD7D75  bl 0x8238d4b8
	ctx.lr = 0x825B5748;
	sub_8238D4B8(ctx, base);
	pc = 0x825B5748; continue 'dispatch;
            }
            0x825B5748 => {
    //   block [0x825B5748..0x825B5750)
	// 825B5748: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B574C: 486F3CFC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5750 size=180
    let mut pc: u32 = 0x825B5750;
    'dispatch: loop {
        match pc {
            0x825B5750 => {
    //   block [0x825B5750..0x825B5794)
	// 825B5750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5754: 486F3CA9  bl 0x82ca93fc
	ctx.lr = 0x825B5758;
	sub_82CA93D0(ctx, base);
	// 825B5758: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B575C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B5760: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5764: 419A0098  beq cr6, 0x825b57fc
	if ctx.cr[6].eq {
	pc = 0x825B57FC; continue 'dispatch;
	}
	// 825B5768: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B576C: 4844B225  bl 0x82a00990
	ctx.lr = 0x825B5770;
	sub_82A00990(ctx, base);
	// 825B5770: 83E10058  lwz r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B5774: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B5778: 83C10050  lwz r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B577C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B5780: 419A0074  beq cr6, 0x825b57f4
	if ctx.cr[6].eq {
	pc = 0x825B57F4; continue 'dispatch;
	}
	// 825B5784: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B5788: 3FA08349  lis r29, -0x7cb7
	ctx.r[29].s64 = -2092367872;
	// 825B578C: 3F40834A  lis r26, -0x7cb6
	ctx.r[26].s64 = -2092302336;
	// 825B5790: 3B2BE460  addi r25, r11, -0x1ba0
	ctx.r[25].s64 = ctx.r[11].s64 + -7072;
	pc = 0x825B5794; continue 'dispatch;
            }
            0x825B5794 => {
    //   block [0x825B5794..0x825B57D0)
	// 825B5794: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5798: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825B579C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B57A0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B57A4: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B57A8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B57AC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B57B0: 419A0020  beq cr6, 0x825b57d0
	if ctx.cr[6].eq {
	pc = 0x825B57D0; continue 'dispatch;
	}
	// 825B57B4: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B57B8: 409A0018  bne cr6, 0x825b57d0
	if !ctx.cr[6].eq {
	pc = 0x825B57D0; continue 'dispatch;
	}
	// 825B57BC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B57C0: 817AE454  lwz r11, -0x1bac(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B57C4: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B57C8: 409A0008  bne cr6, 0x825b57d0
	if !ctx.cr[6].eq {
	pc = 0x825B57D0; continue 'dispatch;
	}
	// 825B57CC: 7F2ACB78  mr r10, r25
	ctx.r[10].u64 = ctx.r[25].u64;
	pc = 0x825B57D0; continue 'dispatch;
            }
            0x825B57D0 => {
    //   block [0x825B57D0..0x825B57F4)
	// 825B57D0: 807D6DA0  lwz r3, 0x6da0(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B57D4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B57D8: 4BC2EA79  bl 0x821e4250
	ctx.lr = 0x825B57DC;
	sub_821E4250(ctx, base);
	// 825B57DC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B57E0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B57E4: 48000245  bl 0x825b5a28
	ctx.lr = 0x825B57E8;
	sub_825B5A28(ctx, base);
	// 825B57E8: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B57EC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B57F0: 409AFFA4  bne cr6, 0x825b5794
	if !ctx.cr[6].eq {
	pc = 0x825B5794; continue 'dispatch;
	}
	pc = 0x825B57F4; continue 'dispatch;
            }
            0x825B57F4 => {
    //   block [0x825B57F4..0x825B57FC)
	// 825B57F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B57F8: 4BC66541  bl 0x8221bd38
	ctx.lr = 0x825B57FC;
	sub_8221BD38(ctx, base);
	pc = 0x825B57FC; continue 'dispatch;
            }
            0x825B57FC => {
    //   block [0x825B57FC..0x825B5804)
	// 825B57FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B5800: 486F3C4C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B5808 size=540
    let mut pc: u32 = 0x825B5808;
    'dispatch: loop {
        match pc {
            0x825B5808 => {
    //   block [0x825B5808..0x825B589C)
	// 825B5808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B580C: 486F3BCD  bl 0x82ca93d8
	ctx.lr = 0x825B5810;
	sub_82CA93D0(ctx, base);
	// 825B5810: DBC1FF68  stfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.f[30].u64 ) };
	// 825B5814: DBE1FF70  stfd f31, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[31].u64 ) };
	// 825B5818: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B581C: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825B5820: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5824: 419A01F0  beq cr6, 0x825b5a14
	if ctx.cr[6].eq {
	pc = 0x825B5A14; continue 'dispatch;
	}
	// 825B5828: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B582C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B5830: 388B5508  addi r4, r11, 0x5508
	ctx.r[4].s64 = ctx.r[11].s64 + 21768;
	// 825B5834: 4BCF41B5  bl 0x822a99e8
	ctx.lr = 0x825B5838;
	sub_822A99E8(ctx, base);
	// 825B5838: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B583C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5840: 419A01D4  beq cr6, 0x825b5a14
	if ctx.cr[6].eq {
	pc = 0x825B5A14; continue 'dispatch;
	}
	// 825B5844: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B5848: 4844B149  bl 0x82a00990
	ctx.lr = 0x825B584C;
	sub_82A00990(ctx, base);
	// 825B584C: 83010068  lwz r24, 0x68(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B5850: 82010064  lwz r16, 0x64(r1)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B5854: 82810060  lwz r20, 0x60(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B5858: 7F188040  cmplw cr6, r24, r16
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[16].u32, &mut ctx.xer);
	// 825B585C: 419A01A8  beq cr6, 0x825b5a04
	if ctx.cr[6].eq {
	pc = 0x825B5A04; continue 'dispatch;
	}
	// 825B5860: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825B5864: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 825B5868: 38E89484  addi r7, r8, -0x6b7c
	ctx.r[7].s64 = ctx.r[8].s64 + -27516;
	// 825B586C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B5870: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5874: C3C89484  lfs f30, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B5878: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 825B587C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B5880: C3E7000C  lfs f31, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B5884: 3E608349  lis r19, -0x7cb7
	ctx.r[19].s64 = -2092367872;
	// 825B5888: 3B2000FF  li r25, 0xff
	ctx.r[25].s64 = 255;
	// 825B588C: 3E20834A  lis r17, -0x7cb6
	ctx.r[17].s64 = -2092302336;
	// 825B5890: 3A4AE460  addi r18, r10, -0x1ba0
	ctx.r[18].s64 = ctx.r[10].s64 + -7072;
	// 825B5894: 3AC95530  addi r22, r9, 0x5530
	ctx.r[22].s64 = ctx.r[9].s64 + 21808;
	// 825B5898: 3AAB5518  addi r21, r11, 0x5518
	ctx.r[21].s64 = ctx.r[11].s64 + 21784;
	pc = 0x825B589C; continue 'dispatch;
            }
            0x825B589C => {
    //   block [0x825B589C..0x825B58D8)
	// 825B589C: 570B083C  slwi r11, r24, 1
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B58A0: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 825B58A4: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B58A8: 7D6BA214  add r11, r11, r20
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 825B58AC: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B58B0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B58B4: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B58B8: 419A0020  beq cr6, 0x825b58d8
	if ctx.cr[6].eq {
	pc = 0x825B58D8; continue 'dispatch;
	}
	// 825B58BC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B58C0: 409A0018  bne cr6, 0x825b58d8
	if !ctx.cr[6].eq {
	pc = 0x825B58D8; continue 'dispatch;
	}
	// 825B58C4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B58C8: 8131E454  lwz r9, -0x1bac(r17)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[17].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B58CC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B58D0: 409A0008  bne cr6, 0x825b58d8
	if !ctx.cr[6].eq {
	pc = 0x825B58D8; continue 'dispatch;
	}
	// 825B58D4: 7E4A9378  mr r10, r18
	ctx.r[10].u64 = ctx.r[18].u64;
	pc = 0x825B58D8; continue 'dispatch;
            }
            0x825B58D8 => {
    //   block [0x825B58D8..0x825B5934)
	// 825B58D8: 80736DA0  lwz r3, 0x6da0(r19)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B58DC: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B58E0: 4BC2E971  bl 0x821e4250
	ctx.lr = 0x825B58E4;
	sub_821E4250(ctx, base);
	// 825B58E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B58E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B58EC: 419A010C  beq cr6, 0x825b59f8
	if ctx.cr[6].eq {
	pc = 0x825B59F8; continue 'dispatch;
	}
	// 825B58F0: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825B58F4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B58F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B58FC: 481CDB1D  bl 0x82783418
	ctx.lr = 0x825B5900;
	sub_82783418(ctx, base);
	// 825B5900: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B5904: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5908: 4BCF40E1  bl 0x822a99e8
	ctx.lr = 0x825B590C;
	sub_822A99E8(ctx, base);
	// 825B590C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5910: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5914: 419A00E4  beq cr6, 0x825b59f8
	if ctx.cr[6].eq {
	pc = 0x825B59F8; continue 'dispatch;
	}
	// 825B5918: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B591C: 4844B075  bl 0x82a00990
	ctx.lr = 0x825B5920;
	sub_82A00990(ctx, base);
	// 825B5920: 83610068  lwz r27, 0x68(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B5924: 83410064  lwz r26, 0x64(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B5928: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825B592C: 419A00C0  beq cr6, 0x825b59ec
	if ctx.cr[6].eq {
	pc = 0x825B59EC; continue 'dispatch;
	}
	// 825B5930: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x825B5934; continue 'dispatch;
            }
            0x825B5934 => {
    //   block [0x825B5934..0x825B5990)
	// 825B5934: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B5938: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B593C: 481CDBED  bl 0x82783528
	ctx.lr = 0x825B5940;
	sub_82783528(ctx, base);
	// 825B5940: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B5944: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B5948: 419A0094  beq cr6, 0x825b59dc
	if ctx.cr[6].eq {
	pc = 0x825B59DC; continue 'dispatch;
	}
	// 825B594C: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B5950: D3E1007C  stfs f31, 0x7c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 825B5954: 81770094  lwz r11, 0x94(r23)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B5958: D3C10084  stfs f30, 0x84(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 825B595C: 3BF70090  addi r31, r23, 0x90
	ctx.r[31].s64 = ctx.r[23].s64 + 144;
	// 825B5960: 93A10074  stw r29, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[29].u32 ) };
	// 825B5964: 93810078  stw r28, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 825B5968: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B596C: 9BC10082  stb r30, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[30].u8 ) };
	// 825B5970: 9BC10081  stb r30, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[30].u8 ) };
	// 825B5974: 9BC10080  stb r30, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[30].u8 ) };
	// 825B5978: 9B210083  stb r25, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[25].u8 ) };
	// 825B597C: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 825B5980: 9B81008C  stb r28, 0x8c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[28].u8 ) };
	// 825B5984: 409A000C  bne cr6, 0x825b5990
	if !ctx.cr[6].eq {
	pc = 0x825B5990; continue 'dispatch;
	}
	// 825B5988: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825B598C: 48000010  b 0x825b599c
	pc = 0x825B599C; continue 'dispatch;
            }
            0x825B5990 => {
    //   block [0x825B5990..0x825B599C)
	// 825B5990: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5994: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B5998: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B599C; continue 'dispatch;
            }
            0x825B599C => {
    //   block [0x825B599C..0x825B59C8)
	// 825B599C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B59A0: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825B59A4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B59A8: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B59AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B59B0: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B59B4: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B59B8: 40980010  bge cr6, 0x825b59c8
	if !ctx.cr[6].lt {
	pc = 0x825B59C8; continue 'dispatch;
	}
	// 825B59BC: 4800535D  bl 0x825bad18
	ctx.lr = 0x825B59C0;
	sub_825BAD18(ctx, base);
	// 825B59C0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B59C4: 48000014  b 0x825b59d8
	pc = 0x825B59D8; continue 'dispatch;
            }
            0x825B59C8 => {
    //   block [0x825B59C8..0x825B59D8)
	// 825B59C8: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825B59CC: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825B59D0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B59D4: 48006005  bl 0x825bb9d8
	ctx.lr = 0x825B59D8;
	sub_825BB9D8(ctx, base);
	pc = 0x825B59D8; continue 'dispatch;
            }
            0x825B59D8 => {
    //   block [0x825B59D8..0x825B59DC)
	// 825B59D8: 9B9F0011  stb r28, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[28].u8 ) };
	pc = 0x825B59DC; continue 'dispatch;
            }
            0x825B59DC => {
    //   block [0x825B59DC..0x825B59EC)
	// 825B59DC: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825B59E0: 93610068  stw r27, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[27].u32 ) };
	// 825B59E4: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825B59E8: 409AFF4C  bne cr6, 0x825b5934
	if !ctx.cr[6].eq {
	pc = 0x825B5934; continue 'dispatch;
	}
	pc = 0x825B59EC; continue 'dispatch;
            }
            0x825B59EC => {
    //   block [0x825B59EC..0x825B59F8)
	// 825B59EC: 80610060  lwz r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B59F0: 4BC66349  bl 0x8221bd38
	ctx.lr = 0x825B59F4;
	sub_8221BD38(ctx, base);
	// 825B59F4: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	pc = 0x825B59F8; continue 'dispatch;
            }
            0x825B59F8 => {
    //   block [0x825B59F8..0x825B5A04)
	// 825B59F8: 3B180001  addi r24, r24, 1
	ctx.r[24].s64 = ctx.r[24].s64 + 1;
	// 825B59FC: 7F188040  cmplw cr6, r24, r16
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[16].u32, &mut ctx.xer);
	// 825B5A00: 409AFE9C  bne cr6, 0x825b589c
	if !ctx.cr[6].eq {
	pc = 0x825B589C; continue 'dispatch;
	}
	pc = 0x825B5A04; continue 'dispatch;
            }
            0x825B5A04 => {
    //   block [0x825B5A04..0x825B5A14)
	// 825B5A04: 38770090  addi r3, r23, 0x90
	ctx.r[3].s64 = ctx.r[23].s64 + 144;
	// 825B5A08: 480041A9  bl 0x825b9bb0
	ctx.lr = 0x825B5A0C;
	sub_825B9BB0(ctx, base);
	// 825B5A0C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B5A10: 4BC66329  bl 0x8221bd38
	ctx.lr = 0x825B5A14;
	sub_8221BD38(ctx, base);
	pc = 0x825B5A14; continue 'dispatch;
            }
            0x825B5A14 => {
    //   block [0x825B5A14..0x825B5A24)
	// 825B5A14: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 825B5A18: CBC1FF68  lfd f30, -0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-152 as u32) ) };
	// 825B5A1C: CBE1FF70  lfd f31, -0x90(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 825B5A20: 486F3A08  b 0x82ca9428
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5A28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B5A28 size=1212
    let mut pc: u32 = 0x825B5A28;
    'dispatch: loop {
        match pc {
            0x825B5A28 => {
    //   block [0x825B5A28..0x825B5A74)
	// 825B5A28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5A2C: 486F39BD  bl 0x82ca93e8
	ctx.lr = 0x825B5A30;
	sub_82CA93D0(ctx, base);
	// 825B5A30: DBC1FF88  stfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[30].u64 ) };
	// 825B5A34: DBE1FF90  stfd f31, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.f[31].u64 ) };
	// 825B5A38: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5A3C: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825B5A40: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825B5A44: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 825B5A48: 419A048C  beq cr6, 0x825b5ed4
	if ctx.cr[6].eq {
	pc = 0x825B5ED4; continue 'dispatch;
	}
	// 825B5A4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5A50: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825B5A54: 38AB5444  addi r5, r11, 0x5444
	ctx.r[5].s64 = ctx.r[11].s64 + 21572;
	// 825B5A58: 481CD9C1  bl 0x82783418
	ctx.lr = 0x825B5A5C;
	sub_82783418(ctx, base);
	// 825B5A5C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5A60: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5A64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B5A68: 4099000C  ble cr6, 0x825b5a74
	if !ctx.cr[6].gt {
	pc = 0x825B5A74; continue 'dispatch;
	}
	// 825B5A6C: 38740024  addi r3, r20, 0x24
	ctx.r[3].s64 = ctx.r[20].s64 + 36;
	// 825B5A70: 48003E51  bl 0x825b98c0
	ctx.lr = 0x825B5A74;
	sub_825B98C0(ctx, base);
	pc = 0x825B5A74; continue 'dispatch;
            }
            0x825B5A74 => {
    //   block [0x825B5A74..0x825B5AD4)
	// 825B5A74: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5A78: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 825B5A7C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B5A80: 388B5548  addi r4, r11, 0x5548
	ctx.r[4].s64 = ctx.r[11].s64 + 21832;
	// 825B5A84: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B5A88: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	// 825B5A8C: 4BC77445  bl 0x8222ced0
	ctx.lr = 0x825B5A90;
	sub_8222CED0(ctx, base);
	// 825B5A90: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B5A94: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B5A98: 388A5558  addi r4, r10, 0x5558
	ctx.r[4].s64 = ctx.r[10].s64 + 21848;
	// 825B5A9C: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 825B5AA0: 4BC77431  bl 0x8222ced0
	ctx.lr = 0x825B5AA4;
	sub_8222CED0(ctx, base);
	// 825B5AA4: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825B5AA8: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825B5AAC: 38E89484  addi r7, r8, -0x6b7c
	ctx.r[7].s64 = ctx.r[8].s64 + -27516;
	// 825B5AB0: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B5AB4: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 825B5AB8: C3C89484  lfs f30, -0x6b7c(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B5ABC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B5AC0: 3AA000FF  li r21, 0xff
	ctx.r[21].s64 = 255;
	// 825B5AC4: C3E7000C  lfs f31, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B5AC8: 3ACBFFDF  addi r22, r11, -0x21
	ctx.r[22].s64 = ctx.r[11].s64 + -33;
	// 825B5ACC: 3B8A7088  addi r28, r10, 0x7088
	ctx.r[28].s64 = ctx.r[10].s64 + 28808;
	// 825B5AD0: 3B490B34  addi r26, r9, 0xb34
	ctx.r[26].s64 = ctx.r[9].s64 + 2868;
	pc = 0x825B5AD4; continue 'dispatch;
            }
            0x825B5AD4 => {
    //   block [0x825B5AD4..0x825B5ADC)
	// 825B5AD4: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 825B5AD8: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	pc = 0x825B5ADC; continue 'dispatch;
            }
            0x825B5ADC => {
    //   block [0x825B5ADC..0x825B5B10)
	// 825B5ADC: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B5AE0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5AE4: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B5AE8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B5AEC: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5AF0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5AF4: 4082FFE8  bne 0x825b5adc
	if !ctx.cr[0].eq {
	pc = 0x825B5ADC; continue 'dispatch;
	}
	// 825B5AF8: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B5AFC: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825B5B00: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B5B04: 4BC2E34D  bl 0x821e3e50
	ctx.lr = 0x825B5B08;
	sub_821E3E50(ctx, base);
	// 825B5B08: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825B5B0C: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	pc = 0x825B5B10; continue 'dispatch;
            }
            0x825B5B10 => {
    //   block [0x825B5B10..0x825B5B58)
	// 825B5B10: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825B5B14: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5B18: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 825B5B1C: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825B5B20: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5B24: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5B28: 4082FFE8  bne 0x825b5b10
	if !ctx.cr[0].eq {
	pc = 0x825B5B10; continue 'dispatch;
	}
	// 825B5B2C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825B5B30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5B34: 4BCAF66D  bl 0x822651a0
	ctx.lr = 0x825B5B38;
	sub_822651A0(ctx, base);
	// 825B5B38: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825B5B3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5B40: 4BC36CB9  bl 0x821ec7f8
	ctx.lr = 0x825B5B44;
	sub_821EC7F8(ctx, base);
	// 825B5B44: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B5B48: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B5B4C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5B50: 419A0008  beq cr6, 0x825b5b58
	if ctx.cr[6].eq {
	pc = 0x825B5B58; continue 'dispatch;
	}
	// 825B5B54: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B5B58; continue 'dispatch;
            }
            0x825B5B58 => {
    //   block [0x825B5B58..0x825B5B90)
	// 825B5B58: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825B5B5C: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825B5B60: 4BC3E1F9  bl 0x821f3d58
	ctx.lr = 0x825B5B64;
	sub_821F3D58(ctx, base);
	// 825B5B64: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5B68: 38A10098  addi r5, r1, 0x98
	ctx.r[5].s64 = ctx.r[1].s64 + 152;
	// 825B5B6C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B5B70: 4BC2FE99  bl 0x821e5a08
	ctx.lr = 0x825B5B74;
	sub_821E5A08(ctx, base);
	// 825B5B74: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B5B78: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5B7C: 7D6A0034  cntlzw r10, r11
	ctx.r[10].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 825B5B80: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825B5B84: 693F0001  xori r31, r9, 1
	ctx.r[31].u64 = ctx.r[9].u64 ^ 1;
	// 825B5B88: 4BC10BE1  bl 0x821c6768
	ctx.lr = 0x825B5B8C;
	sub_821C6768(ctx, base);
	// 825B5B8C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x825B5B90; continue 'dispatch;
            }
            0x825B5B90 => {
    //   block [0x825B5B90..0x825B5BB8)
	// 825B5B90: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825B5B94: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5B98: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 825B5B9C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825B5BA0: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5BA4: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5BA8: 4082FFE8  bne 0x825b5b90
	if !ctx.cr[0].eq {
	pc = 0x825B5B90; continue 'dispatch;
	}
	// 825B5BAC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B5BB0: 4BC10BB9  bl 0x821c6768
	ctx.lr = 0x825B5BB4;
	sub_821C6768(ctx, base);
	// 825B5BB4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	pc = 0x825B5BB8; continue 'dispatch;
            }
            0x825B5BB8 => {
    //   block [0x825B5BB8..0x825B5BE8)
	// 825B5BB8: 7C8000A6  mfmsr r4
	ctx.r[4].u64 = ctx.msr;
	// 825B5BBC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5BC0: 7CA01828  lwarx r5, 0, r3
	// lwarx
	let ea = ctx.r[3].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[5].u64 = ctx.reserved.u32 as u64;
	// 825B5BC4: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 825B5BC8: 7CA0192D  stwcx. r5, 0, r3
	// stwcx.
	let addr = ctx.r[3].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[5].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5BCC: 7C810164  mtmsrd r4, 1
	ctx.msr = (ctx.r[4].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5BD0: 4082FFE8  bne 0x825b5bb8
	if !ctx.cr[0].eq {
	pc = 0x825B5BB8; continue 'dispatch;
	}
	// 825B5BD4: 57EB063E  clrlwi r11, r31, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 825B5BD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5BDC: 419A02E8  beq cr6, 0x825b5ec4
	if ctx.cr[6].eq {
	pc = 0x825B5EC4; continue 'dispatch;
	}
	// 825B5BE0: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 825B5BE4: 93C10078  stw r30, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[30].u32 ) };
	pc = 0x825B5BE8; continue 'dispatch;
            }
            0x825B5BE8 => {
    //   block [0x825B5BE8..0x825B5C1C)
	// 825B5BE8: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B5BEC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5BF0: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B5BF4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825B5BF8: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5BFC: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5C00: 4082FFE8  bne 0x825b5be8
	if !ctx.cr[0].eq {
	pc = 0x825B5BE8; continue 'dispatch;
	}
	// 825B5C04: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B5C08: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825B5C0C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B5C10: 4BC2E241  bl 0x821e3e50
	ctx.lr = 0x825B5C14;
	sub_821E3E50(ctx, base);
	// 825B5C14: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 825B5C18: 93C10070  stw r30, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[30].u32 ) };
	pc = 0x825B5C1C; continue 'dispatch;
            }
            0x825B5C1C => {
    //   block [0x825B5C1C..0x825B5C64)
	// 825B5C1C: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825B5C20: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5C24: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 825B5C28: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 825B5C2C: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5C30: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5C34: 4082FFE8  bne 0x825b5c1c
	if !ctx.cr[0].eq {
	pc = 0x825B5C1C; continue 'dispatch;
	}
	// 825B5C38: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825B5C3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5C40: 4BCAF561  bl 0x822651a0
	ctx.lr = 0x825B5C44;
	sub_822651A0(ctx, base);
	// 825B5C44: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825B5C48: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5C4C: 4BC36BAD  bl 0x821ec7f8
	ctx.lr = 0x825B5C50;
	sub_821EC7F8(ctx, base);
	// 825B5C50: 81610070  lwz r11, 0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B5C54: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825B5C58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5C5C: 419A0008  beq cr6, 0x825b5c64
	if ctx.cr[6].eq {
	pc = 0x825B5C64; continue 'dispatch;
	}
	// 825B5C60: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B5C64; continue 'dispatch;
            }
            0x825B5C64 => {
    //   block [0x825B5C64..0x825B5C7C)
	// 825B5C64: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B5C68: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B5C6C: 481CD7AD  bl 0x82783418
	ctx.lr = 0x825B5C70;
	sub_82783418(ctx, base);
	// 825B5C70: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B5C74: 4BC10AF5  bl 0x821c6768
	ctx.lr = 0x825B5C78;
	sub_821C6768(ctx, base);
	// 825B5C78: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x825B5C7C; continue 'dispatch;
            }
            0x825B5C7C => {
    //   block [0x825B5C7C..0x825B5CA4)
	// 825B5C7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B5C80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5C84: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B5C88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B5C8C: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5C90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5C94: 4082FFE8  bne 0x825b5c7c
	if !ctx.cr[0].eq {
	pc = 0x825B5C7C; continue 'dispatch;
	}
	// 825B5C98: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B5C9C: 4BC10ACD  bl 0x821c6768
	ctx.lr = 0x825B5CA0;
	sub_821C6768(ctx, base);
	// 825B5CA0: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x825B5CA4; continue 'dispatch;
            }
            0x825B5CA4 => {
    //   block [0x825B5CA4..0x825B5CFC)
	// 825B5CA4: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825B5CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5CAC: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 825B5CB0: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825B5CB4: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5CB8: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5CBC: 4082FFE8  bne 0x825b5ca4
	if !ctx.cr[0].eq {
	pc = 0x825B5CA4; continue 'dispatch;
	}
	// 825B5CC0: 83A10090  lwz r29, 0x90(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B5CC4: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B5CC8: 419A01F4  beq cr6, 0x825b5ebc
	if ctx.cr[6].eq {
	pc = 0x825B5EBC; continue 'dispatch;
	}
	// 825B5CCC: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825B5CD0: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825B5CD4: 4BD98FED  bl 0x8234ecc0
	ctx.lr = 0x825B5CD8;
	sub_8234ECC0(ctx, base);
	// 825B5CD8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B5CDC: 3881008C  addi r4, r1, 0x8c
	ctx.r[4].s64 = ctx.r[1].s64 + 140;
	// 825B5CE0: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825B5CE4: 4BC2D425  bl 0x821e3108
	ctx.lr = 0x825B5CE8;
	sub_821E3108(ctx, base);
	// 825B5CE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5CEC: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825B5CF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5CF4: 419A0008  beq cr6, 0x825b5cfc
	if ctx.cr[6].eq {
	pc = 0x825B5CFC; continue 'dispatch;
	}
	// 825B5CF8: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825B5CFC; continue 'dispatch;
            }
            0x825B5CFC => {
    //   block [0x825B5CFC..0x825B5D14)
	// 825B5CFC: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B5D00: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825B5D04: 481CD715  bl 0x82783418
	ctx.lr = 0x825B5D08;
	sub_82783418(ctx, base);
	// 825B5D08: 38610084  addi r3, r1, 0x84
	ctx.r[3].s64 = ctx.r[1].s64 + 132;
	// 825B5D0C: 4BC10A5D  bl 0x821c6768
	ctx.lr = 0x825B5D10;
	sub_821C6768(ctx, base);
	// 825B5D10: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	pc = 0x825B5D14; continue 'dispatch;
            }
            0x825B5D14 => {
    //   block [0x825B5D14..0x825B5D40)
	// 825B5D14: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B5D18: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5D1C: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B5D20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B5D24: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5D28: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5D2C: 4082FFE8  bne 0x825b5d14
	if !ctx.cr[0].eq {
	pc = 0x825B5D14; continue 'dispatch;
	}
	// 825B5D30: 93C10084  stw r30, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 825B5D34: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825B5D38: 4BC10A31  bl 0x821c6768
	ctx.lr = 0x825B5D3C;
	sub_821C6768(ctx, base);
	// 825B5D3C: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	pc = 0x825B5D40; continue 'dispatch;
            }
            0x825B5D40 => {
    //   block [0x825B5D40..0x825B5D8C)
	// 825B5D40: 7CE000A6  mfmsr r7
	ctx.r[7].u64 = ctx.msr;
	// 825B5D44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5D48: 7D003028  lwarx r8, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[8].u64 = ctx.reserved.u32 as u64;
	// 825B5D4C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 825B5D50: 7D00312D  stwcx. r8, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[8].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B5D54: 7CE10164  mtmsrd r7, 1
	ctx.msr = (ctx.r[7].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B5D58: 4082FFE8  bne 0x825b5d40
	if !ctx.cr[0].eq {
	pc = 0x825B5D40; continue 'dispatch;
	}
	// 825B5D5C: 83610094  lwz r27, 0x94(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B5D60: 93C10088  stw r30, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 825B5D64: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825B5D68: 419A0154  beq cr6, 0x825b5ebc
	if ctx.cr[6].eq {
	pc = 0x825B5EBC; continue 'dispatch;
	}
	// 825B5D6C: 81340094  lwz r9, 0x94(r20)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B5D70: 3BF40090  addi r31, r20, 0x90
	ctx.r[31].s64 = ctx.r[20].s64 + 144;
	// 825B5D74: 80F40098  lwz r7, 0x98(r20)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B5D78: 93C100A0  stw r30, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 825B5D7C: 7D693850  subf r11, r9, r7
	ctx.r[11].s64 = ctx.r[7].s64 - ctx.r[9].s64;
	// 825B5D80: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	// 825B5D84: 7D6B2E71  srawi. r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5D88: 40810040  ble 0x825b5dc8
	if !ctx.cr[0].gt {
	pc = 0x825B5DC8; continue 'dispatch;
	}
	pc = 0x825B5D8C; continue 'dispatch;
            }
            0x825B5D8C => {
    //   block [0x825B5D8C..0x825B5DB4)
	// 825B5D8C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B5D90: 55482834  slwi r8, r10, 5
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B5D94: 7D284A14  add r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B5D98: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5D9C: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B5DA0: 40980014  bge cr6, 0x825b5db4
	if !ctx.cr[6].lt {
	pc = 0x825B5DB4; continue 'dispatch;
	}
	// 825B5DA4: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B5DA8: 39290020  addi r9, r9, 0x20
	ctx.r[9].s64 = ctx.r[9].s64 + 32;
	// 825B5DAC: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B5DB0: 4800000C  b 0x825b5dbc
	pc = 0x825B5DBC; continue 'dispatch;
            }
            0x825B5DB4 => {
    //   block [0x825B5DB4..0x825B5DBC)
	// 825B5DB4: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 825B5DB8: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x825B5DBC; continue 'dispatch;
            }
            0x825B5DBC => {
    //   block [0x825B5DBC..0x825B5DC8)
	// 825B5DBC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B5DC0: 4199FFCC  bgt cr6, 0x825b5d8c
	if ctx.cr[6].gt {
	pc = 0x825B5D8C; continue 'dispatch;
	}
	// 825B5DC4: 912100A4  stw r9, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[9].u32 ) };
	pc = 0x825B5DC8; continue 'dispatch;
            }
            0x825B5DC8 => {
    //   block [0x825B5DC8..0x825B5DEC)
	// 825B5DC8: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825B5DCC: 419A0020  beq cr6, 0x825b5dec
	if ctx.cr[6].eq {
	pc = 0x825B5DEC; continue 'dispatch;
	}
	// 825B5DD0: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5DD4: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B5DD8: 41980014  blt cr6, 0x825b5dec
	if ctx.cr[6].lt {
	pc = 0x825B5DEC; continue 'dispatch;
	}
	// 825B5DDC: E96100A0  ld r11, 0xa0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 825B5DE0: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 825B5DE4: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B5DE8: 48000008  b 0x825b5df0
	pc = 0x825B5DF0; continue 'dispatch;
            }
            0x825B5DEC => {
    //   block [0x825B5DEC..0x825B5DF0)
	// 825B5DEC: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x825B5DF0; continue 'dispatch;
            }
            0x825B5DF0 => {
    //   block [0x825B5DF0..0x825B5E18)
	// 825B5DF0: 81540098  lwz r10, 0x98(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B5DF4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B5DF8: 419A0020  beq cr6, 0x825b5e18
	if ctx.cr[6].eq {
	pc = 0x825B5E18; continue 'dispatch;
	}
	// 825B5DFC: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825B5E00: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5E04: 386B0020  addi r3, r11, 0x20
	ctx.r[3].s64 = ctx.r[11].s64 + 32;
	// 825B5E08: 480065E1  bl 0x825bc3e8
	ctx.lr = 0x825B5E0C;
	sub_825BC3E8(ctx, base);
	// 825B5E0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5E10: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825B5E14: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825B5E18; continue 'dispatch;
            }
            0x825B5E18 => {
    //   block [0x825B5E18..0x825B5E58)
	// 825B5E18: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B5E1C: D3E100BC  stfs f31, 0xbc(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 825B5E20: D3C100C4  stfs f30, 0xc4(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 825B5E24: 93A100B0  stw r29, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[29].u32 ) };
	// 825B5E28: 936100B4  stw r27, 0xb4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), ctx.r[27].u32 ) };
	// 825B5E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B5E30: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 825B5E34: 9BC100C2  stb r30, 0xc2(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(194 as u32), ctx.r[30].u8 ) };
	// 825B5E38: 9BC100C1  stb r30, 0xc1(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(193 as u32), ctx.r[30].u8 ) };
	// 825B5E3C: 9BC100C0  stb r30, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u8 ) };
	// 825B5E40: 9AA100C3  stb r21, 0xc3(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(195 as u32), ctx.r[21].u8 ) };
	// 825B5E44: 93C100C8  stw r30, 0xc8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[30].u32 ) };
	// 825B5E48: 9AE100CC  stb r23, 0xcc(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(204 as u32), ctx.r[23].u8 ) };
	// 825B5E4C: 409A000C  bne cr6, 0x825b5e58
	if !ctx.cr[6].eq {
	pc = 0x825B5E58; continue 'dispatch;
	}
	// 825B5E50: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 825B5E54: 48000010  b 0x825b5e64
	pc = 0x825B5E64; continue 'dispatch;
            }
            0x825B5E58 => {
    //   block [0x825B5E58..0x825B5E64)
	// 825B5E58: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B5E5C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B5E60: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B5E64; continue 'dispatch;
            }
            0x825B5E64 => {
    //   block [0x825B5E64..0x825B5EA0)
	// 825B5E64: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5E68: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 825B5E6C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B5E70: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B5E74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5E78: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B5E7C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B5E80: 40980020  bge cr6, 0x825b5ea0
	if !ctx.cr[6].lt {
	pc = 0x825B5EA0; continue 'dispatch;
	}
	// 825B5E84: 48004E95  bl 0x825bad18
	ctx.lr = 0x825B5E88;
	sub_825BAD18(ctx, base);
	// 825B5E88: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B5E8C: 9AFF0011  stb r23, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[23].u8 ) };
	// 825B5E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5E94: 48003D1D  bl 0x825b9bb0
	ctx.lr = 0x825B5E98;
	sub_825B9BB0(ctx, base);
	// 825B5E98: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825B5E9C: 4BFFFC38  b 0x825b5ad4
	pc = 0x825B5AD4; continue 'dispatch;
            }
            0x825B5EA0 => {
    //   block [0x825B5EA0..0x825B5EBC)
	// 825B5EA0: 908100AC  stw r4, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[4].u32 ) };
	// 825B5EA4: 93C100A8  stw r30, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[30].u32 ) };
	// 825B5EA8: E88100A8  ld r4, 0xa8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 825B5EAC: 48005B2D  bl 0x825bb9d8
	ctx.lr = 0x825B5EB0;
	sub_825BB9D8(ctx, base);
	// 825B5EB0: 9AFF0011  stb r23, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[23].u8 ) };
	// 825B5EB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5EB8: 48003CF9  bl 0x825b9bb0
	ctx.lr = 0x825B5EBC;
	sub_825B9BB0(ctx, base);
	pc = 0x825B5EBC; continue 'dispatch;
            }
            0x825B5EBC => {
    //   block [0x825B5EBC..0x825B5EC4)
	// 825B5EBC: 3B390001  addi r25, r25, 1
	ctx.r[25].s64 = ctx.r[25].s64 + 1;
	// 825B5EC0: 4BFFFC14  b 0x825b5ad4
	pc = 0x825B5AD4; continue 'dispatch;
            }
            0x825B5EC4 => {
    //   block [0x825B5EC4..0x825B5ED4)
	// 825B5EC4: 3861008C  addi r3, r1, 0x8c
	ctx.r[3].s64 = ctx.r[1].s64 + 140;
	// 825B5EC8: 4BC5EF11  bl 0x82214dd8
	ctx.lr = 0x825B5ECC;
	sub_82214DD8(ctx, base);
	// 825B5ECC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 825B5ED0: 4BC5EF09  bl 0x82214dd8
	ctx.lr = 0x825B5ED4;
	sub_82214DD8(ctx, base);
	pc = 0x825B5ED4; continue 'dispatch;
            }
            0x825B5ED4 => {
    //   block [0x825B5ED4..0x825B5EE4)
	// 825B5ED4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 825B5ED8: CBC1FF88  lfd f30, -0x78(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 825B5EDC: CBE1FF90  lfd f31, -0x70(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 825B5EE0: 486F3558  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5EE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5EE8 size=68
    let mut pc: u32 = 0x825B5EE8;
    'dispatch: loop {
        match pc {
            0x825B5EE8 => {
    //   block [0x825B5EE8..0x825B5F18)
	// 825B5EE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5EEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B5EF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B5EF4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5EF8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B5EFC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5F00: 4BBE66E9  bl 0x8219c5e8
	ctx.lr = 0x825B5F04;
	sub_8219C5E8(ctx, base);
	// 825B5F04: 80810050  lwz r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B5F08: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5F0C: 419A000C  beq cr6, 0x825b5f18
	if ctx.cr[6].eq {
	pc = 0x825B5F18; continue 'dispatch;
	}
	// 825B5F10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B5F14: 4800001D  bl 0x825b5f30
	ctx.lr = 0x825B5F18;
	sub_825B5F30(ctx, base);
	pc = 0x825B5F18; continue 'dispatch;
            }
            0x825B5F18 => {
    //   block [0x825B5F18..0x825B5F2C)
	// 825B5F18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B5F1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B5F20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B5F24: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B5F28: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B5F30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B5F30 size=452
    let mut pc: u32 = 0x825B5F30;
    'dispatch: loop {
        match pc {
            0x825B5F30 => {
    //   block [0x825B5F30..0x825B5FC8)
	// 825B5F30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B5F34: 486F34B5  bl 0x82ca93e8
	ctx.lr = 0x825B5F38;
	sub_82CA93D0(ctx, base);
	// 825B5F38: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B5F3C: 7C761B78  mr r22, r3
	ctx.r[22].u64 = ctx.r[3].u64;
	// 825B5F40: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5F44: 7C942378  mr r20, r4
	ctx.r[20].u64 = ctx.r[4].u64;
	// 825B5F48: 4BC24401  bl 0x821da348
	ctx.lr = 0x825B5F4C;
	sub_821DA348(ctx, base);
	// 825B5F4C: 82A10050  lwz r21, 0x50(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B5F50: 2B150000  cmplwi cr6, r21, 0
	ctx.cr[6].compare_u32(ctx.r[21].u32, 0 as u32, &mut ctx.xer);
	// 825B5F54: 419A0198  beq cr6, 0x825b60ec
	if ctx.cr[6].eq {
	pc = 0x825B60EC; continue 'dispatch;
	}
	// 825B5F58: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B5F5C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B5F60: 4BC24451  bl 0x821da3b0
	ctx.lr = 0x825B5F64;
	sub_821DA3B0(ctx, base);
	// 825B5F64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B5F68: 38EB5358  addi r7, r11, 0x5358
	ctx.r[7].s64 = ctx.r[11].s64 + 21336;
	// 825B5F6C: 4BBFC58D  bl 0x821b24f8
	ctx.lr = 0x825B5F70;
	sub_821B24F8(ctx, base);
	// 825B5F70: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B5F74: 4BCF3A75  bl 0x822a99e8
	ctx.lr = 0x825B5F78;
	sub_822A99E8(ctx, base);
	// 825B5F78: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B5F7C: 3CC0811C  lis r6, -0x7ee4
	ctx.r[6].s64 = -2128871424;
	// 825B5F80: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B5F84: 60D89DC5  ori r24, r6, 0x9dc5
	ctx.r[24].u64 = ctx.r[6].u64 | 40389;
	// 825B5F88: 419A00DC  beq cr6, 0x825b6064
	if ctx.cr[6].eq {
	pc = 0x825B6064; continue 'dispatch;
	}
	// 825B5F8C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B5F90: 4844AA01  bl 0x82a00990
	ctx.lr = 0x825B5F94;
	sub_82A00990(ctx, base);
	// 825B5F94: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B5F98: 82E1005C  lwz r23, 0x5c(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B5F9C: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B5FA0: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 825B5FA4: 419A00B8  beq cr6, 0x825b605c
	if ctx.cr[6].eq {
	pc = 0x825B605C; continue 'dispatch;
	}
	// 825B5FA8: 3D208349  lis r9, -0x7cb7
	ctx.r[9].s64 = -2092367872;
	// 825B5FAC: 3D00834A  lis r8, -0x7cb6
	ctx.r[8].s64 = -2092302336;
	// 825B5FB0: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B5FB4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B5FB8: 3B4BE460  addi r26, r11, -0x1ba0
	ctx.r[26].s64 = ctx.r[11].s64 + -7072;
	// 825B5FBC: 83696DA0  lwz r27, 0x6da0(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B5FC0: 3B8A53A8  addi r28, r10, 0x53a8
	ctx.r[28].s64 = ctx.r[10].s64 + 21416;
	// 825B5FC4: 8328E454  lwz r25, -0x1bac(r8)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-7084 as u32) ) } as u64;
	pc = 0x825B5FC8; continue 'dispatch;
            }
            0x825B5FC8 => {
    //   block [0x825B5FC8..0x825B6000)
	// 825B5FC8: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5FCC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825B5FD0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B5FD4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825B5FD8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B5FDC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5FE0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B5FE4: 419A001C  beq cr6, 0x825b6000
	if ctx.cr[6].eq {
	pc = 0x825B6000; continue 'dispatch;
	}
	// 825B5FE8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B5FEC: 409A0014  bne cr6, 0x825b6000
	if !ctx.cr[6].eq {
	pc = 0x825B6000; continue 'dispatch;
	}
	// 825B5FF0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B5FF4: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825B5FF8: 409A0008  bne cr6, 0x825b6000
	if !ctx.cr[6].eq {
	pc = 0x825B6000; continue 'dispatch;
	}
	// 825B5FFC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x825B6000; continue 'dispatch;
            }
            0x825B6000 => {
    //   block [0x825B6000..0x825B6044)
	// 825B6000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B6004: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6008: 4BC2E249  bl 0x821e4250
	ctx.lr = 0x825B600C;
	sub_821E4250(ctx, base);
	// 825B600C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B6010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B6014: 419A003C  beq cr6, 0x825b6050
	if ctx.cr[6].eq {
	pc = 0x825B6050; continue 'dispatch;
	}
	// 825B6018: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B601C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B6020: 4BC3DD39  bl 0x821f3d58
	ctx.lr = 0x825B6024;
	sub_821F3D58(ctx, base);
	// 825B6024: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6028: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B602C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B6030: 4844A699  bl 0x82a006c8
	ctx.lr = 0x825B6034;
	sub_82A006C8(ctx, base);
	// 825B6034: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6038: 419A000C  beq cr6, 0x825b6044
	if ctx.cr[6].eq {
	pc = 0x825B6044; continue 'dispatch;
	}
	// 825B603C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6040: 48000008  b 0x825b6048
	pc = 0x825B6048; continue 'dispatch;
            }
            0x825B6044 => {
    //   block [0x825B6044..0x825B6048)
	// 825B6044: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B6048; continue 'dispatch;
            }
            0x825B6048 => {
    //   block [0x825B6048..0x825B6050)
	// 825B6048: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825B604C: 419A0058  beq cr6, 0x825b60a4
	if ctx.cr[6].eq {
	pc = 0x825B60A4; continue 'dispatch;
	}
	pc = 0x825B6050; continue 'dispatch;
            }
            0x825B6050 => {
    //   block [0x825B6050..0x825B605C)
	// 825B6050: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B6054: 7F1EB840  cmplw cr6, r30, r23
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[23].u32, &mut ctx.xer);
	// 825B6058: 409AFF70  bne cr6, 0x825b5fc8
	if !ctx.cr[6].eq {
	pc = 0x825B5FC8; continue 'dispatch;
	}
	pc = 0x825B605C; continue 'dispatch;
            }
            0x825B605C => {
    //   block [0x825B605C..0x825B6064)
	// 825B605C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B6060: 4BC65CD9  bl 0x8221bd38
	ctx.lr = 0x825B6064;
	sub_8221BD38(ctx, base);
	pc = 0x825B6064; continue 'dispatch;
            }
            0x825B6064 => {
    //   block [0x825B6064..0x825B60A4)
	// 825B6064: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B6068: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825B606C: 386B53C0  addi r3, r11, 0x53c0
	ctx.r[3].s64 = ctx.r[11].s64 + 21440;
	// 825B6070: 4BC3DCE9  bl 0x821f3d58
	ctx.lr = 0x825B6074;
	sub_821F3D58(ctx, base);
	// 825B6074: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B6078: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 825B607C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6080: 4BC24331  bl 0x821da3b0
	ctx.lr = 0x825B6084;
	sub_821DA3B0(ctx, base);
	// 825B6084: 4BBFC475  bl 0x821b24f8
	ctx.lr = 0x825B6088;
	sub_821B24F8(ctx, base);
	// 825B6088: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B608C: 38A00006  li r5, 6
	ctx.r[5].s64 = 6;
	// 825B6090: 4844A639  bl 0x82a006c8
	ctx.lr = 0x825B6094;
	sub_82A006C8(ctx, base);
	// 825B6094: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6098: 419A0028  beq cr6, 0x825b60c0
	if ctx.cr[6].eq {
	pc = 0x825B60C0; continue 'dispatch;
	}
	// 825B609C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B60A0: 48000024  b 0x825b60c4
	pc = 0x825B60C4; continue 'dispatch;
            }
            0x825B60A4 => {
    //   block [0x825B60A4..0x825B60C0)
	// 825B60A4: 917600B4  stw r11, 0xb4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 825B60A8: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B60AC: 48002A25  bl 0x825b8ad0
	ctx.lr = 0x825B60B0;
	sub_825B8AD0(ctx, base);
	// 825B60B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B60B4: 4BC65C85  bl 0x8221bd38
	ctx.lr = 0x825B60B8;
	sub_8221BD38(ctx, base);
	// 825B60B8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825B60BC: 486F337C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B60C0 => {
    //   block [0x825B60C0..0x825B60C4)
	// 825B60C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B60C4; continue 'dispatch;
            }
            0x825B60C4 => {
    //   block [0x825B60C4..0x825B60E0)
	// 825B60C4: 7F0BA840  cmplw cr6, r11, r21
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825B60C8: 409A0018  bne cr6, 0x825b60e0
	if !ctx.cr[6].eq {
	pc = 0x825B60E0; continue 'dispatch;
	}
	// 825B60CC: 917600B4  stw r11, 0xb4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(180 as u32), ctx.r[11].u32 ) };
	// 825B60D0: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B60D4: 480029FD  bl 0x825b8ad0
	ctx.lr = 0x825B60D8;
	sub_825B8AD0(ctx, base);
	// 825B60D8: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825B60DC: 486F335C  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B60E0 => {
    //   block [0x825B60E0..0x825B60EC)
	// 825B60E0: 929600B4  stw r20, 0xb4(r22)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[22].u32.wrapping_add(180 as u32), ctx.r[20].u32 ) };
	// 825B60E4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B60E8: 480029E9  bl 0x825b8ad0
	ctx.lr = 0x825B60EC;
	sub_825B8AD0(ctx, base);
	pc = 0x825B60EC; continue 'dispatch;
            }
            0x825B60EC => {
    //   block [0x825B60EC..0x825B60F4)
	// 825B60EC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825B60F0: 486F3348  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B60F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B60F8 size=448
    let mut pc: u32 = 0x825B60F8;
    'dispatch: loop {
        match pc {
            0x825B60F8 => {
    //   block [0x825B60F8..0x825B6188)
	// 825B60F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B60FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B6100: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B6104: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B6108: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B610C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B6110: 387F00A4  addi r3, r31, 0xa4
	ctx.r[3].s64 = ctx.r[31].s64 + 164;
	// 825B6114: 817F00A8  lwz r11, 0xa8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825B6118: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B611C: 4859EAA5  bl 0x82b54bc0
	ctx.lr = 0x825B6120;
	sub_82B54BC0(ctx, base);
	// 825B6120: 815F00A8  lwz r10, 0xa8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825B6124: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B6128: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B612C: 914A0004  stw r10, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B6130: 813F00A8  lwz r9, 0xa8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825B6134: 93DF00AC  stw r30, 0xac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), ctx.r[30].u32 ) };
	// 825B6138: 91290000  stw r9, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B613C: 811F00A8  lwz r8, 0xa8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) } as u64;
	// 825B6140: 91080008  stw r8, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B6144: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6148: 98BF00B0  stb r5, 0xb0(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), ctx.r[5].u8 ) };
	// 825B614C: 98BF00B3  stb r5, 0xb3(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(179 as u32), ctx.r[5].u8 ) };
	// 825B6150: 80EB0024  lwz r7, 0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B6154: 54E6EFFE  rlwinm r6, r7, 0x1d, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x00000007u64;
	// 825B6158: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825B615C: 419A00E8  beq cr6, 0x825b6244
	if ctx.cr[6].eq {
	pc = 0x825B6244; continue 'dispatch;
	}
	// 825B6160: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B6164: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B6168: 419A0020  beq cr6, 0x825b6188
	if ctx.cr[6].eq {
	pc = 0x825B6188; continue 'dispatch;
	}
	// 825B616C: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B6170: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6174: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B6178: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B617C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B6180: 83C90004  lwz r30, 4(r9)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6184: 480000C4  b 0x825b6248
	pc = 0x825B6248; continue 'dispatch;
            }
            0x825B6188 => {
    //   block [0x825B6188..0x825B61A4)
	// 825B6188: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B618C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B6190: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B6194: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B6198: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B619C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B61A0: 40810054  ble 0x825b61f4
	if !ctx.cr[0].gt {
	pc = 0x825B61F4; continue 'dispatch;
	}
	pc = 0x825B61A4; continue 'dispatch;
            }
            0x825B61A4 => {
    //   block [0x825B61A4..0x825B61C4)
	// 825B61A4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B61A8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B61AC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B61B0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B61B4: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825B61B8: 7CA72B78  mr r7, r5
	ctx.r[7].u64 = ctx.r[5].u64;
	// 825B61BC: 41980008  blt cr6, 0x825b61c4
	if ctx.cr[6].lt {
	pc = 0x825B61C4; continue 'dispatch;
	}
	// 825B61C0: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	pc = 0x825B61C4; continue 'dispatch;
            }
            0x825B61C4 => {
    //   block [0x825B61C4..0x825B61E0)
	// 825B61C4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B61C8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B61CC: 419A0014  beq cr6, 0x825b61e0
	if ctx.cr[6].eq {
	pc = 0x825B61E0; continue 'dispatch;
	}
	// 825B61D0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B61D4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B61D8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B61DC: 4800000C  b 0x825b61e8
	pc = 0x825B61E8; continue 'dispatch;
            }
            0x825B61E0 => {
    //   block [0x825B61E0..0x825B61E8)
	// 825B61E0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B61E4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B61E8; continue 'dispatch;
            }
            0x825B61E8 => {
    //   block [0x825B61E8..0x825B61F4)
	// 825B61E8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B61EC: 4199FFB8  bgt cr6, 0x825b61a4
	if ctx.cr[6].gt {
	pc = 0x825B61A4; continue 'dispatch;
	}
	// 825B61F0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B61F4; continue 'dispatch;
            }
            0x825B61F4 => {
    //   block [0x825B61F4..0x825B6210)
	// 825B61F4: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B61F8: 419A003C  beq cr6, 0x825b6234
	if ctx.cr[6].eq {
	pc = 0x825B6234; continue 'dispatch;
	}
	// 825B61FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6200: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B6204: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B6208: 41990008  bgt cr6, 0x825b6210
	if ctx.cr[6].gt {
	pc = 0x825B6210; continue 'dispatch;
	}
	// 825B620C: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825B6210; continue 'dispatch;
            }
            0x825B6210 => {
    //   block [0x825B6210..0x825B6234)
	// 825B6210: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B6214: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6218: 409A001C  bne cr6, 0x825b6234
	if !ctx.cr[6].eq {
	pc = 0x825B6234; continue 'dispatch;
	}
	// 825B621C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B6220: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B6224: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B6228: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B622C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B6230: 48000018  b 0x825b6248
	pc = 0x825B6248; continue 'dispatch;
            }
            0x825B6234 => {
    //   block [0x825B6234..0x825B6244)
	// 825B6234: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B6238: 83CB0004  lwz r30, 4(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B623C: 7CAB2B78  mr r11, r5
	ctx.r[11].u64 = ctx.r[5].u64;
	// 825B6240: 48000008  b 0x825b6248
	pc = 0x825B6248; continue 'dispatch;
            }
            0x825B6244 => {
    //   block [0x825B6244..0x825B6248)
	// 825B6244: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	pc = 0x825B6248; continue 'dispatch;
            }
            0x825B6248 => {
    //   block [0x825B6248..0x825B626C)
	// 825B6248: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B624C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6250: 419A0050  beq cr6, 0x825b62a0
	if ctx.cr[6].eq {
	pc = 0x825B62A0; continue 'dispatch;
	}
	// 825B6254: 83FE0090  lwz r31, 0x90(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B6258: 57EB0630  rlwinm r11, r31, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[31].u32 as u64 & 0xFFFFFFFFu64;
	// 825B625C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6260: 409A000C  bne cr6, 0x825b626c
	if !ctx.cr[6].eq {
	pc = 0x825B626C; continue 'dispatch;
	}
	// 825B6264: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B6268: 4BFBC681  bl 0x825728e8
	ctx.lr = 0x825B626C;
	sub_825728E8(ctx, base);
	pc = 0x825B626C; continue 'dispatch;
            }
            0x825B626C => {
    //   block [0x825B626C..0x825B62A0)
	// 825B626C: 817E0090  lwz r11, 0x90(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B6270: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825B6274: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 825B6278: 915E0090  stw r10, 0x90(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 825B627C: 409A0024  bne cr6, 0x825b62a0
	if !ctx.cr[6].eq {
	pc = 0x825B62A0; continue 'dispatch;
	}
	// 825B6280: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B6284: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6288: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B628C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B6290: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B6294: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6298: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B629C: 4BC5AD7D  bl 0x82211018
	ctx.lr = 0x825B62A0;
	sub_82211018(ctx, base);
	pc = 0x825B62A0; continue 'dispatch;
            }
            0x825B62A0 => {
    //   block [0x825B62A0..0x825B62B8)
	// 825B62A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B62A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B62A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B62AC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B62B0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B62B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B62B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B62B8 size=704
    let mut pc: u32 = 0x825B62B8;
    'dispatch: loop {
        match pc {
            0x825B62B8 => {
    //   block [0x825B62B8..0x825B62E8)
	// 825B62B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B62BC: 486F3129  bl 0x82ca93e4
	ctx.lr = 0x825B62C0;
	sub_82CA93D0(ctx, base);
	// 825B62C0: 9421FC20  stwu r1, -0x3e0(r1)
	ea = ctx.r[1].u32.wrapping_add(-992 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B62C4: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825B62C8: 3B940064  addi r28, r20, 0x64
	ctx.r[28].s64 = ctx.r[20].s64 + 100;
	// 825B62CC: 80B40068  lwz r5, 0x68(r20)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B62D0: 8094006C  lwz r4, 0x6c(r20)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B62D4: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825B62D8: 40990010  ble cr6, 0x825b62e8
	if !ctx.cr[6].gt {
	pc = 0x825B62E8; continue 'dispatch;
	}
	// 825B62DC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 825B62E0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	// 825B62E4: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	pc = 0x825B62E8; continue 'dispatch;
            }
            0x825B62E8 => {
    //   block [0x825B62E8..0x825B6308)
	// 825B62E8: 419A0038  beq cr6, 0x825b6320
	if ctx.cr[6].eq {
	pc = 0x825B6320; continue 'dispatch;
	}
	// 825B62EC: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B62F0: 4BF71D61  bl 0x82528050
	ctx.lr = 0x825B62F4;
	sub_82528050(ctx, base);
	// 825B62F4: 83DC0008  lwz r30, 8(r28)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B62F8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B62FC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825B6300: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B6304: 419A0018  beq cr6, 0x825b631c
	if ctx.cr[6].eq {
	pc = 0x825B631C; continue 'dispatch;
	}
	pc = 0x825B6308; continue 'dispatch;
            }
            0x825B6308 => {
    //   block [0x825B6308..0x825B631C)
	// 825B6308: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825B630C: 4BC0180D  bl 0x821b7b18
	ctx.lr = 0x825B6310;
	sub_821B7B18(ctx, base);
	// 825B6310: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 825B6314: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B6318: 409AFFF0  bne cr6, 0x825b6308
	if !ctx.cr[6].eq {
	pc = 0x825B6308; continue 'dispatch;
	}
	pc = 0x825B631C; continue 'dispatch;
            }
            0x825B631C => {
    //   block [0x825B631C..0x825B6320)
	// 825B631C: 93BC0008  stw r29, 8(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x825B6320; continue 'dispatch;
            }
            0x825B6320 => {
    //   block [0x825B6320..0x825B63A8)
	// 825B6320: 81740004  lwz r11, 4(r20)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[20].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6324: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B6328: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 825B632C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B6330: 419A0188  beq cr6, 0x825b64b8
	if ctx.cr[6].eq {
	pc = 0x825B64B8; continue 'dispatch;
	}
	// 825B6334: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 825B6338: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B633C: 4BC24075  bl 0x821da3b0
	ctx.lr = 0x825B6340;
	sub_821DA3B0(ctx, base);
	// 825B6340: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B6344: 38EB556C  addi r7, r11, 0x556c
	ctx.r[7].s64 = ctx.r[11].s64 + 21868;
	// 825B6348: 4BBFC1B1  bl 0x821b24f8
	ctx.lr = 0x825B634C;
	sub_821B24F8(ctx, base);
	// 825B634C: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B6350: 4BCF3699  bl 0x822a99e8
	ctx.lr = 0x825B6354;
	sub_822A99E8(ctx, base);
	// 825B6354: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6358: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B635C: 419A015C  beq cr6, 0x825b64b8
	if ctx.cr[6].eq {
	pc = 0x825B64B8; continue 'dispatch;
	}
	// 825B6360: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B6364: 4844A62D  bl 0x82a00990
	ctx.lr = 0x825B6368;
	sub_82A00990(ctx, base);
	// 825B6368: 83A10060  lwz r29, 0x60(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B636C: 8261005C  lwz r19, 0x5c(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B6370: 83010058  lwz r24, 0x58(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B6374: 7F1D9840  cmplw cr6, r29, r19
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[19].u32, &mut ctx.xer);
	// 825B6378: 419A0138  beq cr6, 0x825b64b0
	if ctx.cr[6].eq {
	pc = 0x825B64B0; continue 'dispatch;
	}
	// 825B637C: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B6380: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B6384: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B6388: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825B638C: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825B6390: 3AA0FFFF  li r21, -1
	ctx.r[21].s64 = -1;
	// 825B6394: 3EC0834A  lis r22, -0x7cb6
	ctx.r[22].s64 = -2092302336;
	// 825B6398: 3AEBE460  addi r23, r11, -0x1ba0
	ctx.r[23].s64 = ctx.r[11].s64 + -7072;
	// 825B639C: 3B6A558C  addi r27, r10, 0x558c
	ctx.r[27].s64 = ctx.r[10].s64 + 21900;
	// 825B63A0: 3B49557C  addi r26, r9, 0x557c
	ctx.r[26].s64 = ctx.r[9].s64 + 21884;
	// 825B63A4: 3B88541C  addi r28, r8, 0x541c
	ctx.r[28].s64 = ctx.r[8].s64 + 21532;
	pc = 0x825B63A8; continue 'dispatch;
            }
            0x825B63A8 => {
    //   block [0x825B63A8..0x825B63E4)
	// 825B63A8: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B63AC: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825B63B0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B63B4: 7D6BC214  add r11, r11, r24
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[24].u64;
	// 825B63B8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B63BC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B63C0: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B63C4: 419A0020  beq cr6, 0x825b63e4
	if ctx.cr[6].eq {
	pc = 0x825B63E4; continue 'dispatch;
	}
	// 825B63C8: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B63CC: 409A0018  bne cr6, 0x825b63e4
	if !ctx.cr[6].eq {
	pc = 0x825B63E4; continue 'dispatch;
	}
	// 825B63D0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B63D4: 8136E454  lwz r9, -0x1bac(r22)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B63D8: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B63DC: 409A0008  bne cr6, 0x825b63e4
	if !ctx.cr[6].eq {
	pc = 0x825B63E4; continue 'dispatch;
	}
	// 825B63E0: 7EEABB78  mr r10, r23
	ctx.r[10].u64 = ctx.r[23].u64;
	pc = 0x825B63E4; continue 'dispatch;
            }
            0x825B63E4 => {
    //   block [0x825B63E4..0x825B642C)
	// 825B63E4: 80796DA0  lwz r3, 0x6da0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B63E8: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B63EC: 4BC2DE65  bl 0x821e4250
	ctx.lr = 0x825B63F0;
	sub_821E4250(ctx, base);
	// 825B63F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B63F4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B63F8: 419A00AC  beq cr6, 0x825b64a4
	if ctx.cr[6].eq {
	pc = 0x825B64A4; continue 'dispatch;
	}
	// 825B63FC: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825B6400: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B6404: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825B6408: 4BC3D951  bl 0x821f3d58
	ctx.lr = 0x825B640C;
	sub_821F3D58(ctx, base);
	// 825B640C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6410: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6414: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 825B6418: 4844A2B1  bl 0x82a006c8
	ctx.lr = 0x825B641C;
	sub_82A006C8(ctx, base);
	// 825B641C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6420: 419A000C  beq cr6, 0x825b642c
	if ctx.cr[6].eq {
	pc = 0x825B642C; continue 'dispatch;
	}
	// 825B6424: 83C30000  lwz r30, 0(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6428: 48000008  b 0x825b6430
	pc = 0x825B6430; continue 'dispatch;
            }
            0x825B642C => {
    //   block [0x825B642C..0x825B6430)
	// 825B642C: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	pc = 0x825B6430; continue 'dispatch;
            }
            0x825B6430 => {
    //   block [0x825B6430..0x825B6458)
	// 825B6430: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825B6434: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6438: 4BCF35B1  bl 0x822a99e8
	ctx.lr = 0x825B643C;
	sub_822A99E8(ctx, base);
	// 825B643C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B6440: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825B6444: 419A0014  beq cr6, 0x825b6458
	if ctx.cr[6].eq {
	pc = 0x825B6458; continue 'dispatch;
	}
	// 825B6448: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B644C: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B6450: 48000241  bl 0x825b6690
	ctx.lr = 0x825B6454;
	sub_825B6690(ctx, base);
	// 825B6454: 48000050  b 0x825b64a4
	pc = 0x825B64A4; continue 'dispatch;
            }
            0x825B6458 => {
    //   block [0x825B6458..0x825B649C)
	// 825B6458: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B645C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6460: 4BD6D0E1  bl 0x82323540
	ctx.lr = 0x825B6464;
	sub_82323540(ctx, base);
	// 825B6464: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6468: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B646C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B6470: 4BC76A61  bl 0x8222ced0
	ctx.lr = 0x825B6474;
	sub_8222CED0(ctx, base);
	// 825B6474: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B6478: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B647C: 419A0020  beq cr6, 0x825b649c
	if ctx.cr[6].eq {
	pc = 0x825B649C; continue 'dispatch;
	}
	// 825B6480: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6484: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6488: 419A0014  beq cr6, 0x825b649c
	if ctx.cr[6].eq {
	pc = 0x825B649C; continue 'dispatch;
	}
	// 825B648C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B6490: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B6494: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B6498: 480005C1  bl 0x825b6a58
	ctx.lr = 0x825B649C;
	sub_825B6A58(ctx, base);
	pc = 0x825B649C; continue 'dispatch;
            }
            0x825B649C => {
    //   block [0x825B649C..0x825B64A4)
	// 825B649C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B64A0: 4BC5E939  bl 0x82214dd8
	ctx.lr = 0x825B64A4;
	sub_82214DD8(ctx, base);
	pc = 0x825B64A4; continue 'dispatch;
            }
            0x825B64A4 => {
    //   block [0x825B64A4..0x825B64B0)
	// 825B64A4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B64A8: 7F1D9840  cmplw cr6, r29, r19
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[19].u32, &mut ctx.xer);
	// 825B64AC: 409AFEFC  bne cr6, 0x825b63a8
	if !ctx.cr[6].eq {
	pc = 0x825B63A8; continue 'dispatch;
	}
	pc = 0x825B64B0; continue 'dispatch;
            }
            0x825B64B0 => {
    //   block [0x825B64B0..0x825B64B8)
	// 825B64B0: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B64B4: 4BC65885  bl 0x8221bd38
	ctx.lr = 0x825B64B8;
	sub_8221BD38(ctx, base);
	pc = 0x825B64B8; continue 'dispatch;
            }
            0x825B64B8 => {
    //   block [0x825B64B8..0x825B6510)
	// 825B64B8: 7E84A378  mr r4, r20
	ctx.r[4].u64 = ctx.r[20].u64;
	// 825B64BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B64C0: 4BC23EF1  bl 0x821da3b0
	ctx.lr = 0x825B64C4;
	sub_821DA3B0(ctx, base);
	// 825B64C4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B64C8: 38EB55A0  addi r7, r11, 0x55a0
	ctx.r[7].s64 = ctx.r[11].s64 + 21920;
	// 825B64CC: 4BBFC02D  bl 0x821b24f8
	ctx.lr = 0x825B64D0;
	sub_821B24F8(ctx, base);
	// 825B64D0: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B64D4: 4BD6D06D  bl 0x82323540
	ctx.lr = 0x825B64D8;
	sub_82323540(ctx, base);
	// 825B64D8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B64DC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B64E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B64E4: 4BC769ED  bl 0x8222ced0
	ctx.lr = 0x825B64E8;
	sub_8222CED0(ctx, base);
	// 825B64E8: 81610068  lwz r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B64EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B64F0: 419A0078  beq cr6, 0x825b6568
	if ctx.cr[6].eq {
	pc = 0x825B6568; continue 'dispatch;
	}
	// 825B64F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B64F8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B64FC: 419A006C  beq cr6, 0x825b6568
	if ctx.cr[6].eq {
	pc = 0x825B6568; continue 'dispatch;
	}
	// 825B6500: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B6504: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825B6508: 38CA7088  addi r6, r10, 0x7088
	ctx.r[6].s64 = ctx.r[10].s64 + 28808;
	// 825B650C: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	pc = 0x825B6510; continue 'dispatch;
            }
            0x825B6510 => {
    //   block [0x825B6510..0x825B6568)
	// 825B6510: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825B6514: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6518: 7D203028  lwarx r9, 0, r6
	// lwarx
	let ea = ctx.r[6].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825B651C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825B6520: 7D20312D  stwcx. r9, 0, r6
	// stwcx.
	let addr = ctx.r[6].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B6524: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6528: 4082FFE8  bne 0x825b6510
	if !ctx.cr[0].eq {
	pc = 0x825B6510; continue 'dispatch;
	}
	// 825B652C: 38E10170  addi r7, r1, 0x170
	ctx.r[7].s64 = ctx.r[1].s64 + 368;
	// 825B6530: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6534: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825B6538: 38A10270  addi r5, r1, 0x270
	ctx.r[5].s64 = ctx.r[1].s64 + 624;
	// 825B653C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B6540: 486FAB21  bl 0x82cb1060
	ctx.lr = 0x825B6544;
	sub_82CB1060(ctx, base);
	// 825B6544: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825B6548: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B654C: 4BCBEEED  bl 0x82275438
	ctx.lr = 0x825B6550;
	sub_82275438(ctx, base);
	// 825B6550: 38A10058  addi r5, r1, 0x58
	ctx.r[5].s64 = ctx.r[1].s64 + 88;
	// 825B6554: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B6558: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B655C: 480004FD  bl 0x825b6a58
	ctx.lr = 0x825B6560;
	sub_825B6A58(ctx, base);
	// 825B6560: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B6564: 4BC5E875  bl 0x82214dd8
	ctx.lr = 0x825B6568;
	sub_82214DD8(ctx, base);
	pc = 0x825B6568; continue 'dispatch;
            }
            0x825B6568 => {
    //   block [0x825B6568..0x825B6578)
	// 825B6568: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B656C: 4BC5E86D  bl 0x82214dd8
	ctx.lr = 0x825B6570;
	sub_82214DD8(ctx, base);
	// 825B6570: 382103E0  addi r1, r1, 0x3e0
	ctx.r[1].s64 = ctx.r[1].s64 + 992;
	// 825B6574: 486F2EC0  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6578 size=276
    let mut pc: u32 = 0x825B6578;
    'dispatch: loop {
        match pc {
            0x825B6578 => {
    //   block [0x825B6578..0x825B65F0)
	// 825B6578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B657C: 486F2E7D  bl 0x82ca93f8
	ctx.lr = 0x825B6580;
	sub_82CA93D0(ctx, base);
	// 825B6580: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6584: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825B6588: 808300B4  lwz r4, 0xb4(r3)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B658C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B6590: 419A00DC  beq cr6, 0x825b666c
	if ctx.cr[6].eq {
	pc = 0x825B666C; continue 'dispatch;
	}
	// 825B6594: 3F608349  lis r27, -0x7cb7
	ctx.r[27].s64 = -2092367872;
	// 825B6598: 807B6DA0  lwz r3, 0x6da0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B659C: 4BC2DCB5  bl 0x821e4250
	ctx.lr = 0x825B65A0;
	sub_821E4250(ctx, base);
	// 825B65A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B65A4: 419A00C8  beq cr6, 0x825b666c
	if ctx.cr[6].eq {
	pc = 0x825B666C; continue 'dispatch;
	}
	// 825B65A8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B65AC: 388B5464  addi r4, r11, 0x5464
	ctx.r[4].s64 = ctx.r[11].s64 + 21604;
	// 825B65B0: 4BCF3439  bl 0x822a99e8
	ctx.lr = 0x825B65B4;
	sub_822A99E8(ctx, base);
	// 825B65B4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B65B8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B65BC: 419A00B0  beq cr6, 0x825b666c
	if ctx.cr[6].eq {
	pc = 0x825B666C; continue 'dispatch;
	}
	// 825B65C0: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B65C4: 4844A3CD  bl 0x82a00990
	ctx.lr = 0x825B65C8;
	sub_82A00990(ctx, base);
	// 825B65C8: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B65CC: 8321005C  lwz r25, 0x5c(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B65D0: 83C10058  lwz r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B65D4: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825B65D8: 419A008C  beq cr6, 0x825b6664
	if ctx.cr[6].eq {
	pc = 0x825B6664; continue 'dispatch;
	}
	// 825B65DC: 3D40834A  lis r10, -0x7cb6
	ctx.r[10].s64 = -2092302336;
	// 825B65E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B65E4: 3F80834A  lis r28, -0x7cb6
	ctx.r[28].s64 = -2092302336;
	// 825B65E8: 3B4AE460  addi r26, r10, -0x1ba0
	ctx.r[26].s64 = ctx.r[10].s64 + -7072;
	// 825B65EC: 3BAB5444  addi r29, r11, 0x5444
	ctx.r[29].s64 = ctx.r[11].s64 + 21572;
	pc = 0x825B65F0; continue 'dispatch;
            }
            0x825B65F0 => {
    //   block [0x825B65F0..0x825B662C)
	// 825B65F0: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B65F4: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825B65F8: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B65FC: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B6600: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6604: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6608: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B660C: 419A0020  beq cr6, 0x825b662c
	if ctx.cr[6].eq {
	pc = 0x825B662C; continue 'dispatch;
	}
	// 825B6610: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B6614: 409A0018  bne cr6, 0x825b662c
	if !ctx.cr[6].eq {
	pc = 0x825B662C; continue 'dispatch;
	}
	// 825B6618: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B661C: 817CE454  lwz r11, -0x1bac(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B6620: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B6624: 409A0008  bne cr6, 0x825b662c
	if !ctx.cr[6].eq {
	pc = 0x825B662C; continue 'dispatch;
	}
	// 825B6628: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x825B662C; continue 'dispatch;
            }
            0x825B662C => {
    //   block [0x825B662C..0x825B6664)
	// 825B662C: 807B6DA0  lwz r3, 0x6da0(r27)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B6630: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825B6634: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6638: 4BC2DC19  bl 0x821e4250
	ctx.lr = 0x825B663C;
	sub_821E4250(ctx, base);
	// 825B663C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6644: 481CCDD5  bl 0x82783418
	ctx.lr = 0x825B6648;
	sub_82783418(ctx, base);
	// 825B6648: 81780000  lwz r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B664C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B6650: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B6654: 419A0024  beq cr6, 0x825b6678
	if ctx.cr[6].eq {
	pc = 0x825B6678; continue 'dispatch;
	}
	// 825B6658: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B665C: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825B6660: 409AFF90  bne cr6, 0x825b65f0
	if !ctx.cr[6].eq {
	pc = 0x825B65F0; continue 'dispatch;
	}
	pc = 0x825B6664; continue 'dispatch;
            }
            0x825B6664 => {
    //   block [0x825B6664..0x825B666C)
	// 825B6664: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B6668: 4BC656D1  bl 0x8221bd38
	ctx.lr = 0x825B666C;
	sub_8221BD38(ctx, base);
	pc = 0x825B666C; continue 'dispatch;
            }
            0x825B666C => {
    //   block [0x825B666C..0x825B6678)
	// 825B666C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B6670: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B6674: 486F2DD4  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B6678 => {
    //   block [0x825B6678..0x825B668C)
	// 825B6678: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B667C: 4BC656BD  bl 0x8221bd38
	ctx.lr = 0x825B6680;
	sub_8221BD38(ctx, base);
	// 825B6680: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B6684: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B6688: 486F2DC0  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B6690 size=968
    let mut pc: u32 = 0x825B6690;
    'dispatch: loop {
        match pc {
            0x825B6690 => {
    //   block [0x825B6690..0x825B6750)
	// 825B6690: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6694: 486F2D49  bl 0x82ca93dc
	ctx.lr = 0x825B6698;
	sub_82CA93D0(ctx, base);
	// 825B6698: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 825B669C: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 825B66A0: 9421FEC0  stwu r1, -0x140(r1)
	ea = ctx.r[1].u32.wrapping_add(-320 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B66A4: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 825B66A8: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B66AC: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 825B66B0: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B66B4: 4BFE3E55  bl 0x8259a508
	ctx.lr = 0x825B66B8;
	sub_8259A508(ctx, base);
	// 825B66B8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B66BC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B66C0: 4844A2D1  bl 0x82a00990
	ctx.lr = 0x825B66C4;
	sub_82A00990(ctx, base);
	// 825B66C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B66C8: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 825B66CC: 396B9484  addi r11, r11, -0x6b7c
	ctx.r[11].s64 = ctx.r[11].s64 + -27516;
	// 825B66D0: C3CB0000  lfs f30, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B66D4: 83A10070  lwz r29, 0x70(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B66D8: 82C1006C  lwz r22, 0x6c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B66DC: 82810068  lwz r20, 0x68(r1)
	ctx.r[20].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B66E0: 7F1DB040  cmplw cr6, r29, r22
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825B66E4: 419A0184  beq cr6, 0x825b6868
	if ctx.cr[6].eq {
	pc = 0x825B6868; continue 'dispatch;
	}
	// 825B66E8: C3EB000C  lfs f31, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B66EC: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B66F0: 3D20834A  lis r9, -0x7cb6
	ctx.r[9].s64 = -2092302336;
	// 825B66F4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825B66F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B66FC: 3F408349  lis r26, -0x7cb7
	ctx.r[26].s64 = -2092367872;
	// 825B6700: 3EE0834A  lis r23, -0x7cb6
	ctx.r[23].s64 = -2092302336;
	// 825B6704: 3B2A7088  addi r25, r10, 0x7088
	ctx.r[25].s64 = ctx.r[10].s64 + 28808;
	// 825B6708: 3B09E460  addi r24, r9, -0x1ba0
	ctx.r[24].s64 = ctx.r[9].s64 + -7072;
	// 825B670C: 3B8855DC  addi r28, r8, 0x55dc
	ctx.r[28].s64 = ctx.r[8].s64 + 21980;
	// 825B6710: 3B6B55D0  addi r27, r11, 0x55d0
	ctx.r[27].s64 = ctx.r[11].s64 + 21968;
	// 825B6714: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B6718: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825B671C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B6720: 7D6BA214  add r11, r11, r20
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[20].u64;
	// 825B6724: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B6728: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B672C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B6730: 419A0020  beq cr6, 0x825b6750
	if ctx.cr[6].eq {
	pc = 0x825B6750; continue 'dispatch;
	}
	// 825B6734: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 825B6738: 409A0018  bne cr6, 0x825b6750
	if !ctx.cr[6].eq {
	pc = 0x825B6750; continue 'dispatch;
	}
	// 825B673C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6740: 8137E454  lwz r9, -0x1bac(r23)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[23].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B6744: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B6748: 409A0008  bne cr6, 0x825b6750
	if !ctx.cr[6].eq {
	pc = 0x825B6750; continue 'dispatch;
	}
	// 825B674C: 7F0AC378  mr r10, r24
	ctx.r[10].u64 = ctx.r[24].u64;
	pc = 0x825B6750; continue 'dispatch;
            }
            0x825B6750 => {
    //   block [0x825B6750..0x825B685C)
	// 825B6750: 807A6DA0  lwz r3, 0x6da0(r26)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B6754: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6758: 4BC2DAF9  bl 0x821e4250
	ctx.lr = 0x825B675C;
	sub_821E4250(ctx, base);
	// 825B675C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B6760: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B6764: 419A00F8  beq cr6, 0x825b685c
	if ctx.cr[6].eq {
	pc = 0x825B685C; continue 'dispatch;
	}
	// 825B6768: 39410058  addi r10, r1, 0x58
	ctx.r[10].s64 = ctx.r[1].s64 + 88;
	// 825B676C: D3C10058  stfs f30, 0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825B6770: 39610054  addi r11, r1, 0x54
	ctx.r[11].s64 = ctx.r[1].s64 + 84;
	// 825B6774: D3E10054  stfs f31, 0x54(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 825B6778: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 825B677C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 825B6780: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x825B685C; continue 'dispatch;
            }
            0x825B685C => {
    //   block [0x825B685C..0x825B6868)
	// 825B685C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B6860: 7F1DB040  cmplw cr6, r29, r22
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825B6864: 409AFEB0  bne cr6, 0x825b6714
	if !ctx.cr[6].eq {
	pc = 0x825B6714; continue 'dispatch;
	}
	pc = 0x825B6868; continue 'dispatch;
            }
            0x825B6868 => {
    //   block [0x825B6868..0x825B6A58)
	// 825B6868: 81730004  lwz r11, 4(r19)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[19].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B686C: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 825B6870: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B6874: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 825B6878: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B687C: 419A00D4  beq cr6, 0x825b6950
	if ctx.cr[6].eq {
	pc = 0x825B6950; continue 'dispatch;
	}
	// 825B6880: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B6884: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B6888: 419A001C  beq cr6, 0x825b68a4
	if ctx.cr[6].eq {
	pc = 0x825B68A4; continue 'dispatch;
	}
	// 825B688C: 892A0006  lbz r9, 6(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B6890: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6894: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B6898: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B689C: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B68A0: 480000B0  b 0x825b6950
	pc = 0x825B6950; continue 'dispatch;
	// 825B68A4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B68A8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B68AC: 92A10060  stw r21, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[21].u32 ) };
	// 825B68B0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B68B4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B68B8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B68BC: 40810054  ble 0x825b6910
	if !ctx.cr[0].gt {
	pc = 0x825B6910; continue 'dispatch;
	}
	// 825B68C0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B68C4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B68C8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B68CC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B68D0: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825B68D4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B68D8: 41980008  blt cr6, 0x825b68e0
	if ctx.cr[6].lt {
	pc = 0x825B68E0; continue 'dispatch;
	}
	// 825B68DC: 7EA7AB78  mr r7, r21
	ctx.r[7].u64 = ctx.r[21].u64;
	// 825B68E0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B68E4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B68E8: 419A0014  beq cr6, 0x825b68fc
	if ctx.cr[6].eq {
	pc = 0x825B68FC; continue 'dispatch;
	}
	// 825B68EC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B68F0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B68F4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B68F8: 4800000C  b 0x825b6904
	pc = 0x825B6904; continue 'dispatch;
	// 825B68FC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B6900: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 825B6904: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6908: 4199FFB8  bgt cr6, 0x825b68c0
	if ctx.cr[6].gt {
	pc = 0x825B68C0; continue 'dispatch;
	}
	// 825B690C: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B6910: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B6914: 419A0034  beq cr6, 0x825b6948
	if ctx.cr[6].eq {
	pc = 0x825B6948; continue 'dispatch;
	}
	// 825B6918: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B691C: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B6920: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6924: 41990008  bgt cr6, 0x825b692c
	if ctx.cr[6].gt {
	pc = 0x825B692C; continue 'dispatch;
	}
	// 825B6928: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 825B692C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B6930: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6934: 409A0014  bne cr6, 0x825b6948
	if !ctx.cr[6].eq {
	pc = 0x825B6948; continue 'dispatch;
	}
	// 825B6938: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825B693C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825B6940: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B6944: 48000008  b 0x825b694c
	pc = 0x825B694C; continue 'dispatch;
	// 825B6948: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B694C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6950: 83EA0098  lwz r31, 0x98(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B6954: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825B6958: 83CA0094  lwz r30, 0x94(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B695C: 92A10060  stw r21, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[21].u32 ) };
	// 825B6960: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B6964: 92A10064  stw r21, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[21].u32 ) };
	// 825B6968: 419A0020  beq cr6, 0x825b6988
	if ctx.cr[6].eq {
	pc = 0x825B6988; continue 'dispatch;
	}
	// 825B696C: 4BC688ED  bl 0x8221f258
	ctx.lr = 0x825B6970;
	sub_8221F258(ctx, base);
	// 825B6970: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6974: 419A0054  beq cr6, 0x825b69c8
	if ctx.cr[6].eq {
	pc = 0x825B69C8; continue 'dispatch;
	}
	// 825B6978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B697C: 4BFC6E45  bl 0x8257d7c0
	ctx.lr = 0x825B6980;
	sub_8257D7C0(ctx, base);
	// 825B6980: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6984: 48000048  b 0x825b69cc
	pc = 0x825B69CC; continue 'dispatch;
	// 825B6988: 4BC688D1  bl 0x8221f258
	ctx.lr = 0x825B698C;
	sub_8221F258(ctx, base);
	// 825B698C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6990: 419A0038  beq cr6, 0x825b69c8
	if ctx.cr[6].eq {
	pc = 0x825B69C8; continue 'dispatch;
	}
	// 825B6994: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B6998: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B699C: 392B38C8  addi r9, r11, 0x38c8
	ctx.r[9].s64 = ctx.r[11].s64 + 14536;
	// 825B69A0: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B69A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B69A8: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B69AC: 92A30014  stw r21, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[21].u32 ) };
	// 825B69B0: 92A30018  stw r21, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[21].u32 ) };
	// 825B69B4: 92A3001C  stw r21, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[21].u32 ) };
	// 825B69B8: 9AA30021  stb r21, 0x21(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(33 as u32), ctx.r[21].u8 ) };
	// 825B69BC: D3C30024  stfs f30, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825B69C0: 92A30008  stw r21, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[21].u32 ) };
	// 825B69C4: 48000008  b 0x825b69cc
	pc = 0x825B69CC; continue 'dispatch;
	// 825B69C8: 7EA4AB78  mr r4, r21
	ctx.r[4].u64 = ctx.r[21].u64;
	// 825B69CC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B69D0: 4BCBC689  bl 0x82273058
	ctx.lr = 0x825B69D4;
	sub_82273058(ctx, base);
	// 825B69D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B69D8: 38810078  addi r4, r1, 0x78
	ctx.r[4].s64 = ctx.r[1].s64 + 120;
	// 825B69DC: 83E10060  lwz r31, 0x60(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B69E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B69E4: 485C4F2D  bl 0x82b7b910
	ctx.lr = 0x825B69E8;
	sub_82B7B910(ctx, base);
	// 825B69E8: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B69EC: 92410068  stw r18, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[18].u32 ) };
	// 825B69F0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825B69F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B69F8: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825B69FC: 419A0020  beq cr6, 0x825b6a1c
	if ctx.cr[6].eq {
	pc = 0x825B6A1C; continue 'dispatch;
	}
	// 825B6A00: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825B6A04: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6A08: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825B6A0C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B6A10: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B6A14: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6A18: 4082FFE8  bne 0x825b6a00
	if !ctx.cr[0].eq {
	pc = 0x825B6A00; continue 'dispatch;
	}
	// 825B6A1C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825B6A20: 38730064  addi r3, r19, 0x64
	ctx.r[3].s64 = ctx.r[19].s64 + 100;
	// 825B6A24: 480030A5  bl 0x825b9ac8
	ctx.lr = 0x825B6A28;
	sub_825B9AC8(ctx, base);
	// 825B6A28: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825B6A2C: 4BC010ED  bl 0x821b7b18
	ctx.lr = 0x825B6A30;
	sub_821B7B18(ctx, base);
	// 825B6A30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B6A34: 4BC010E5  bl 0x821b7b18
	ctx.lr = 0x825B6A38;
	sub_821B7B18(ctx, base);
	// 825B6A38: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825B6A3C: 4BC652FD  bl 0x8221bd38
	ctx.lr = 0x825B6A40;
	sub_8221BD38(ctx, base);
	// 825B6A40: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B6A44: 4BFE3C7D  bl 0x8259a6c0
	ctx.lr = 0x825B6A48;
	sub_8259A6C0(ctx, base);
	// 825B6A48: 38210140  addi r1, r1, 0x140
	ctx.r[1].s64 = ctx.r[1].s64 + 320;
	// 825B6A4C: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 825B6A50: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 825B6A54: 486F29D8  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6A58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B6A58 size=548
    let mut pc: u32 = 0x825B6A58;
    'dispatch: loop {
        match pc {
            0x825B6A58 => {
    //   block [0x825B6A58..0x825B6AD0)
	// 825B6A58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6A5C: 486F29A9  bl 0x82ca9404
	ctx.lr = 0x825B6A60;
	sub_82CA93D0(ctx, base);
	// 825B6A60: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6A64: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B6A68: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B6A6C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825B6A70: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825B6A74: 4BFE3A95  bl 0x8259a508
	ctx.lr = 0x825B6A78;
	sub_8259A508(ctx, base);
	// 825B6A78: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825B6A7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6A80: 4BFFD049  bl 0x825b3ac8
	ctx.lr = 0x825B6A84;
	sub_825B3AC8(ctx, base);
	// 825B6A84: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B6A88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6A8C: 419A01E0  beq cr6, 0x825b6c6c
	if ctx.cr[6].eq {
	pc = 0x825B6C6C; continue 'dispatch;
	}
	// 825B6A90: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6A94: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B6A98: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825B6A9C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B6AA0: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 825B6AA4: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B6AA8: 419A00D4  beq cr6, 0x825b6b7c
	if ctx.cr[6].eq {
	pc = 0x825B6B7C; continue 'dispatch;
	}
	// 825B6AAC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B6AB0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B6AB4: 419A001C  beq cr6, 0x825b6ad0
	if ctx.cr[6].eq {
	pc = 0x825B6AD0; continue 'dispatch;
	}
	// 825B6AB8: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B6ABC: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6AC0: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B6AC4: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B6AC8: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6ACC: 480000B0  b 0x825b6b7c
	pc = 0x825B6B7C; continue 'dispatch;
            }
            0x825B6AD0 => {
    //   block [0x825B6AD0..0x825B6AEC)
	// 825B6AD0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6AD4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B6AD8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B6ADC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B6AE0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B6AE4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6AE8: 40810054  ble 0x825b6b3c
	if !ctx.cr[0].gt {
	pc = 0x825B6B3C; continue 'dispatch;
	}
	pc = 0x825B6AEC; continue 'dispatch;
            }
            0x825B6AEC => {
    //   block [0x825B6AEC..0x825B6B0C)
	// 825B6AEC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B6AF0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B6AF4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B6AF8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6AFC: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825B6B00: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B6B04: 41980008  blt cr6, 0x825b6b0c
	if ctx.cr[6].lt {
	pc = 0x825B6B0C; continue 'dispatch;
	}
	// 825B6B08: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	pc = 0x825B6B0C; continue 'dispatch;
            }
            0x825B6B0C => {
    //   block [0x825B6B0C..0x825B6B28)
	// 825B6B0C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B6B10: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B6B14: 419A0014  beq cr6, 0x825b6b28
	if ctx.cr[6].eq {
	pc = 0x825B6B28; continue 'dispatch;
	}
	// 825B6B18: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B6B1C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B6B20: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B6B24: 4800000C  b 0x825b6b30
	pc = 0x825B6B30; continue 'dispatch;
            }
            0x825B6B28 => {
    //   block [0x825B6B28..0x825B6B30)
	// 825B6B28: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B6B2C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B6B30; continue 'dispatch;
            }
            0x825B6B30 => {
    //   block [0x825B6B30..0x825B6B3C)
	// 825B6B30: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6B34: 4199FFB8  bgt cr6, 0x825b6aec
	if ctx.cr[6].gt {
	pc = 0x825B6AEC; continue 'dispatch;
	}
	// 825B6B38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B6B3C; continue 'dispatch;
            }
            0x825B6B3C => {
    //   block [0x825B6B3C..0x825B6B58)
	// 825B6B3C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B6B40: 419A0034  beq cr6, 0x825b6b74
	if ctx.cr[6].eq {
	pc = 0x825B6B74; continue 'dispatch;
	}
	// 825B6B44: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6B48: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B6B4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6B50: 41990008  bgt cr6, 0x825b6b58
	if ctx.cr[6].gt {
	pc = 0x825B6B58; continue 'dispatch;
	}
	// 825B6B54: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x825B6B58; continue 'dispatch;
            }
            0x825B6B58 => {
    //   block [0x825B6B58..0x825B6B74)
	// 825B6B58: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B6B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6B60: 409A0014  bne cr6, 0x825b6b74
	if !ctx.cr[6].eq {
	pc = 0x825B6B74; continue 'dispatch;
	}
	// 825B6B64: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B6B68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B6B6C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B6B70: 48000008  b 0x825b6b78
	pc = 0x825B6B78; continue 'dispatch;
            }
            0x825B6B74 => {
    //   block [0x825B6B74..0x825B6B78)
	// 825B6B74: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825B6B78; continue 'dispatch;
            }
            0x825B6B78 => {
    //   block [0x825B6B78..0x825B6B7C)
	// 825B6B78: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B6B7C; continue 'dispatch;
            }
            0x825B6B7C => {
    //   block [0x825B6B7C..0x825B6BB4)
	// 825B6B7C: 83EA0098  lwz r31, 0x98(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B6B80: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825B6B84: 83CA0094  lwz r30, 0x94(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B6B88: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B6B8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B6B90: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825B6B94: 419A0020  beq cr6, 0x825b6bb4
	if ctx.cr[6].eq {
	pc = 0x825B6BB4; continue 'dispatch;
	}
	// 825B6B98: 4BC686C1  bl 0x8221f258
	ctx.lr = 0x825B6B9C;
	sub_8221F258(ctx, base);
	// 825B6B9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6BA0: 419A005C  beq cr6, 0x825b6bfc
	if ctx.cr[6].eq {
	pc = 0x825B6BFC; continue 'dispatch;
	}
	// 825B6BA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B6BA8: 4BFC6C19  bl 0x8257d7c0
	ctx.lr = 0x825B6BAC;
	sub_8257D7C0(ctx, base);
	// 825B6BAC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6BB0: 48000050  b 0x825b6c00
	pc = 0x825B6C00; continue 'dispatch;
            }
            0x825B6BB4 => {
    //   block [0x825B6BB4..0x825B6BFC)
	// 825B6BB4: 4BC686A5  bl 0x8221f258
	ctx.lr = 0x825B6BB8;
	sub_8221F258(ctx, base);
	// 825B6BB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6BBC: 419A0040  beq cr6, 0x825b6bfc
	if ctx.cr[6].eq {
	pc = 0x825B6BFC; continue 'dispatch;
	}
	// 825B6BC0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B6BC4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825B6BC8: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825B6BCC: 390B38C8  addi r8, r11, 0x38c8
	ctx.r[8].s64 = ctx.r[11].s64 + 14536;
	// 825B6BD0: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B6BD4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6BD8: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825B6BDC: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B6BE0: 93A30014  stw r29, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[29].u32 ) };
	// 825B6BE4: 93A30018  stw r29, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[29].u32 ) };
	// 825B6BE8: 93A3001C  stw r29, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 825B6BEC: 9BA30021  stb r29, 0x21(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(33 as u32), ctx.r[29].u8 ) };
	// 825B6BF0: D0030024  stfs f0, 0x24(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825B6BF4: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825B6BF8: 48000008  b 0x825b6c00
	pc = 0x825B6C00; continue 'dispatch;
            }
            0x825B6BFC => {
    //   block [0x825B6BFC..0x825B6C00)
	// 825B6BFC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x825B6C00; continue 'dispatch;
            }
            0x825B6C00 => {
    //   block [0x825B6C00..0x825B6C34)
	// 825B6C00: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6C04: 4BCBC455  bl 0x82273058
	ctx.lr = 0x825B6C08;
	sub_82273058(ctx, base);
	// 825B6C08: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B6C0C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 825B6C10: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B6C14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B6C18: 485C4CF9  bl 0x82b7b910
	ctx.lr = 0x825B6C1C;
	sub_82B7B910(ctx, base);
	// 825B6C1C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B6C20: 93610058  stw r27, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[27].u32 ) };
	// 825B6C24: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825B6C28: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6C2C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825B6C30: 419A0020  beq cr6, 0x825b6c50
	if ctx.cr[6].eq {
	pc = 0x825B6C50; continue 'dispatch;
	}
	pc = 0x825B6C34; continue 'dispatch;
            }
            0x825B6C34 => {
    //   block [0x825B6C34..0x825B6C50)
	// 825B6C34: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825B6C38: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6C3C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825B6C40: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825B6C44: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B6C48: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6C4C: 4082FFE8  bne 0x825b6c34
	if !ctx.cr[0].eq {
	pc = 0x825B6C34; continue 'dispatch;
	}
	pc = 0x825B6C50; continue 'dispatch;
            }
            0x825B6C50 => {
    //   block [0x825B6C50..0x825B6C6C)
	// 825B6C50: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825B6C54: 387C0064  addi r3, r28, 0x64
	ctx.r[3].s64 = ctx.r[28].s64 + 100;
	// 825B6C58: 48002E71  bl 0x825b9ac8
	ctx.lr = 0x825B6C5C;
	sub_825B9AC8(ctx, base);
	// 825B6C5C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825B6C60: 4BC00EB9  bl 0x821b7b18
	ctx.lr = 0x825B6C64;
	sub_821B7B18(ctx, base);
	// 825B6C64: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6C68: 4BC00EB1  bl 0x821b7b18
	ctx.lr = 0x825B6C6C;
	sub_821B7B18(ctx, base);
	pc = 0x825B6C6C; continue 'dispatch;
            }
            0x825B6C6C => {
    //   block [0x825B6C6C..0x825B6C7C)
	// 825B6C6C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B6C70: 4BFE3A51  bl 0x8259a6c0
	ctx.lr = 0x825B6C74;
	sub_8259A6C0(ctx, base);
	// 825B6C74: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B6C78: 486F27DC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6C80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6C80 size=152
    let mut pc: u32 = 0x825B6C80;
    'dispatch: loop {
        match pc {
            0x825B6C80 => {
    //   block [0x825B6C80..0x825B6CA4)
	// 825B6C80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6C84: 486F2789  bl 0x82ca940c
	ctx.lr = 0x825B6C88;
	sub_82CA93D0(ctx, base);
	// 825B6C88: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6C8C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B6C90: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B6C94: 807E0084  lwz r3, 0x84(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(132 as u32) ) } as u64;
	// 825B6C98: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6C9C: 419A0040  beq cr6, 0x825b6cdc
	if ctx.cr[6].eq {
	pc = 0x825B6CDC; continue 'dispatch;
	}
	// 825B6CA0: 39230004  addi r9, r3, 4
	ctx.r[9].s64 = ctx.r[3].s64 + 4;
	pc = 0x825B6CA4; continue 'dispatch;
            }
            0x825B6CA4 => {
    //   block [0x825B6CA4..0x825B6CD8)
	// 825B6CA4: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825B6CA8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6CAC: 7D604828  lwarx r11, 0, r9
	// lwarx
	let ea = ctx.r[9].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825B6CB0: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B6CB4: 7D60492D  stwcx. r11, 0, r9
	// stwcx.
	let addr = ctx.r[9].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B6CB8: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B6CBC: 4082FFE8  bne 0x825b6ca4
	if !ctx.cr[0].eq {
	pc = 0x825B6CA4; continue 'dispatch;
	}
	// 825B6CC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6CC4: 409A0014  bne cr6, 0x825b6cd8
	if !ctx.cr[6].eq {
	pc = 0x825B6CD8; continue 'dispatch;
	}
	// 825B6CC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6CCC: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6CD0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B6CD4: 4E800421  bctrl
	ctx.lr = 0x825B6CD8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B6CD8 => {
    //   block [0x825B6CD8..0x825B6CDC)
	// 825B6CD8: 93BE0084  stw r29, 0x84(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[29].u32 ) };
	pc = 0x825B6CDC; continue 'dispatch;
            }
            0x825B6CDC => {
    //   block [0x825B6CDC..0x825B6CF8)
	// 825B6CDC: 387E0080  addi r3, r30, 0x80
	ctx.r[3].s64 = ctx.r[30].s64 + 128;
	// 825B6CE0: 4BC7AFD9  bl 0x82231cb8
	ctx.lr = 0x825B6CE4;
	sub_82231CB8(ctx, base);
	// 825B6CE4: 807E0074  lwz r3, 0x74(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B6CE8: 3BFE0070  addi r31, r30, 0x70
	ctx.r[31].s64 = ctx.r[30].s64 + 112;
	// 825B6CEC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6CF0: 419A0008  beq cr6, 0x825b6cf8
	if ctx.cr[6].eq {
	pc = 0x825B6CF8; continue 'dispatch;
	}
	// 825B6CF4: 4BC65045  bl 0x8221bd38
	ctx.lr = 0x825B6CF8;
	sub_8221BD38(ctx, base);
	pc = 0x825B6CF8; continue 'dispatch;
            }
            0x825B6CF8 => {
    //   block [0x825B6CF8..0x825B6D18)
	// 825B6CF8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B6CFC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825B6D00: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825B6D04: 394B6A70  addi r10, r11, 0x6a70
	ctx.r[10].s64 = ctx.r[11].s64 + 27248;
	// 825B6D08: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 825B6D0C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B6D10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B6D14: 486F2748  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6D18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825B6D18 size=124
    let mut pc: u32 = 0x825B6D18;
    'dispatch: loop {
        match pc {
            0x825B6D18 => {
    //   block [0x825B6D18..0x825B6D94)
	// 825B6D18: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6D1C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825B6D20: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6D24: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B6D28: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B6D2C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825B6D30: 8124000C  lwz r9, 0xc(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B6D34: 9123000C  stw r9, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825B6D38: 89040013  lbz r8, 0x13(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 825B6D3C: 88E40010  lbz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B6D40: 88C40011  lbz r6, 0x11(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 825B6D44: 88A40012  lbz r5, 0x12(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 825B6D48: 98A30012  stb r5, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[5].u8 ) };
	// 825B6D4C: 98C30011  stb r6, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[6].u8 ) };
	// 825B6D50: 98E30010  stb r7, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 825B6D54: 99030013  stb r8, 0x13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825B6D58: 89640017  lbz r11, 0x17(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(23 as u32) ) } as u64;
	// 825B6D5C: 89440014  lbz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B6D60: 89240015  lbz r9, 0x15(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(21 as u32) ) } as u64;
	// 825B6D64: 89040016  lbz r8, 0x16(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 825B6D68: 99030016  stb r8, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[8].u8 ) };
	// 825B6D6C: 99230015  stb r9, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 825B6D70: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825B6D74: 99630017  stb r11, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[11].u8 ) };
	// 825B6D78: C1A40018  lfs f13, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B6D7C: D1A30018  stfs f13, 0x18(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825B6D80: 80E4001C  lwz r7, 0x1c(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B6D84: 90E3001C  stw r7, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825B6D88: C1840020  lfs f12, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825B6D8C: D1830020  stfs f12, 0x20(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825B6D90: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6D98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6D98 size=140
    let mut pc: u32 = 0x825B6D98;
    'dispatch: loop {
        match pc {
            0x825B6D98 => {
    //   block [0x825B6D98..0x825B6E0C)
	// 825B6D98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6D9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B6DA0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B6DA4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6DA8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B6DAC: 81640098  lwz r11, 0x98(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B6DB0: 81440094  lwz r10, 0x94(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B6DB4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B6DB8: 55280034  rlwinm r8, r9, 0, 0, 0x1a
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 825B6DBC: 7D070034  cntlzw r7, r8
	ctx.r[7].u64 = if ctx.r[8].u32 == 0 { 32 } else { ctx.r[8].u32.leading_zeros() as u64 };
	// 825B6DC0: 54E6DFFE  rlwinm r6, r7, 0x1b, 0x1f, 0x1f
	ctx.r[6].u64 = ctx.r[7].u32 as u64 & 0x0000001Fu64;
	// 825B6DC4: 68DF0001  xori r31, r6, 1
	ctx.r[31].u64 = ctx.r[6].u64 ^ 1;
	// 825B6DC8: 57E5063E  clrlwi r5, r31, 0x18
	ctx.r[5].u64 = ctx.r[31].u32 as u64 & 0x000000FFu64;
	// 825B6DCC: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825B6DD0: 409A003C  bne cr6, 0x825b6e0c
	if !ctx.cr[6].eq {
	pc = 0x825B6E0C; continue 'dispatch;
	}
	// 825B6DD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6DD8: 4BC235D9  bl 0x821da3b0
	ctx.lr = 0x825B6DDC;
	sub_821DA3B0(ctx, base);
	// 825B6DDC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B6DE0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6DE4: 38EB3F9C  addi r7, r11, 0x3f9c
	ctx.r[7].s64 = ctx.r[11].s64 + 16284;
	// 825B6DE8: 4BBFB711  bl 0x821b24f8
	ctx.lr = 0x825B6DEC;
	sub_821B24F8(ctx, base);
	// 825B6DEC: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B6DF0: 4BCF2BF9  bl 0x822a99e8
	ctx.lr = 0x825B6DF4;
	sub_822A99E8(ctx, base);
	// 825B6DF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6DF8: 419A0014  beq cr6, 0x825b6e0c
	if ctx.cr[6].eq {
	pc = 0x825B6E0C; continue 'dispatch;
	}
	// 825B6DFC: 48449555  bl 0x82a00350
	ctx.lr = 0x825B6E00;
	sub_82A00350(ctx, base);
	// 825B6E00: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B6E04: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B6E08: 409A0008  bne cr6, 0x825b6e10
	if !ctx.cr[6].eq {
	pc = 0x825B6E10; continue 'dispatch;
	}
	pc = 0x825B6E0C; continue 'dispatch;
            }
            0x825B6E0C => {
    //   block [0x825B6E0C..0x825B6E10)
	// 825B6E0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825B6E10; continue 'dispatch;
            }
            0x825B6E10 => {
    //   block [0x825B6E10..0x825B6E24)
	// 825B6E10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B6E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B6E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B6E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B6E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6E28 size=100
    let mut pc: u32 = 0x825B6E28;
    'dispatch: loop {
        match pc {
            0x825B6E28 => {
    //   block [0x825B6E28..0x825B6E60)
	// 825B6E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6E2C: 486F25D9  bl 0x82ca9404
	ctx.lr = 0x825B6E30;
	sub_82CA93D0(ctx, base);
	// 825B6E30: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6E34: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B6E38: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B6E3C: 3B7D0054  addi r27, r29, 0x54
	ctx.r[27].s64 = ctx.r[29].s64 + 84;
	// 825B6E40: 817D005C  lwz r11, 0x5c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B6E44: 815D0058  lwz r10, 0x58(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B6E48: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B6E4C: 7D2B1670  srawi r11, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825B6E50: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825B6E54: 40980024  bge cr6, 0x825b6e78
	if !ctx.cr[6].lt {
	pc = 0x825B6E78; continue 'dispatch;
	}
	// 825B6E58: 579E103A  slwi r30, r28, 2
	ctx.r[30].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825B6E5C: 7FFC5850  subf r31, r28, r11
	ctx.r[31].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	pc = 0x825B6E60; continue 'dispatch;
            }
            0x825B6E60 => {
    //   block [0x825B6E60..0x825B6E78)
	// 825B6E60: 817D0058  lwz r11, 0x58(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B6E64: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B6E68: 4BC37451  bl 0x821ee2b8
	ctx.lr = 0x825B6E6C;
	sub_821EE2B8(ctx, base);
	// 825B6E6C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825B6E70: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825B6E74: 4082FFEC  bne 0x825b6e60
	if !ctx.cr[0].eq {
	pc = 0x825B6E60; continue 'dispatch;
	}
	pc = 0x825B6E78; continue 'dispatch;
            }
            0x825B6E78 => {
    //   block [0x825B6E78..0x825B6E8C)
	// 825B6E78: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B6E7C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B6E80: 48002B91  bl 0x825b9a10
	ctx.lr = 0x825B6E84;
	sub_825B9A10(ctx, base);
	// 825B6E84: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B6E88: 486F25CC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B6E90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B6E90 size=620
    let mut pc: u32 = 0x825B6E90;
    'dispatch: loop {
        match pc {
            0x825B6E90 => {
    //   block [0x825B6E90..0x825B6EF0)
	// 825B6E90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B6E94: 486F2571  bl 0x82ca9404
	ctx.lr = 0x825B6E98;
	sub_82CA93D0(ctx, base);
	// 825B6E98: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B6E9C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B6EA0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B6EA4: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825B6EA8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825B6EAC: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825B6EB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6EB4: 814B003C  lwz r10, 0x3c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B6EB8: 554907FE  clrlwi r9, r10, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825B6EBC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B6EC0: 419A00F4  beq cr6, 0x825b6fb4
	if ctx.cr[6].eq {
	pc = 0x825B6FB4; continue 'dispatch;
	}
	// 825B6EC4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B6EC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B6ECC: 419A0024  beq cr6, 0x825b6ef0
	if ctx.cr[6].eq {
	pc = 0x825B6EF0; continue 'dispatch;
	}
	// 825B6ED0: 894A00C0  lbz r10, 0xc0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(192 as u32) ) } as u64;
	// 825B6ED4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6ED8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B6EDC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B6EE0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6EE4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B6EE8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6EEC: 480000CC  b 0x825b6fb8
	pc = 0x825B6FB8; continue 'dispatch;
            }
            0x825B6EF0 => {
    //   block [0x825B6EF0..0x825B6F0C)
	// 825B6EF0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B6EF4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B6EF8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B6EFC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B6F00: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B6F04: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6F08: 40810054  ble 0x825b6f5c
	if !ctx.cr[0].gt {
	pc = 0x825B6F5C; continue 'dispatch;
	}
	pc = 0x825B6F0C; continue 'dispatch;
            }
            0x825B6F0C => {
    //   block [0x825B6F0C..0x825B6F2C)
	// 825B6F0C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B6F10: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B6F14: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B6F18: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6F1C: 2F0700C0  cmpwi cr6, r7, 0xc0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 192, &mut ctx.xer);
	// 825B6F20: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B6F24: 41980008  blt cr6, 0x825b6f2c
	if ctx.cr[6].lt {
	pc = 0x825B6F2C; continue 'dispatch;
	}
	// 825B6F28: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B6F2C; continue 'dispatch;
            }
            0x825B6F2C => {
    //   block [0x825B6F2C..0x825B6F48)
	// 825B6F2C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B6F30: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B6F34: 419A0014  beq cr6, 0x825b6f48
	if ctx.cr[6].eq {
	pc = 0x825B6F48; continue 'dispatch;
	}
	// 825B6F38: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B6F3C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B6F40: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B6F44: 4800000C  b 0x825b6f50
	pc = 0x825B6F50; continue 'dispatch;
            }
            0x825B6F48 => {
    //   block [0x825B6F48..0x825B6F50)
	// 825B6F48: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B6F4C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B6F50; continue 'dispatch;
            }
            0x825B6F50 => {
    //   block [0x825B6F50..0x825B6F5C)
	// 825B6F50: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B6F54: 4199FFB8  bgt cr6, 0x825b6f0c
	if ctx.cr[6].gt {
	pc = 0x825B6F0C; continue 'dispatch;
	}
	// 825B6F58: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B6F5C; continue 'dispatch;
            }
            0x825B6F5C => {
    //   block [0x825B6F5C..0x825B6F78)
	// 825B6F5C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B6F60: 419A0040  beq cr6, 0x825b6fa0
	if ctx.cr[6].eq {
	pc = 0x825B6FA0; continue 'dispatch;
	}
	// 825B6F64: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B6F68: 2F0B00C0  cmpwi cr6, r11, 0xc0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 192, &mut ctx.xer);
	// 825B6F6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6F70: 41990008  bgt cr6, 0x825b6f78
	if ctx.cr[6].gt {
	pc = 0x825B6F78; continue 'dispatch;
	}
	// 825B6F74: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B6F78; continue 'dispatch;
            }
            0x825B6F78 => {
    //   block [0x825B6F78..0x825B6FA0)
	// 825B6F78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B6F7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6F80: 409A0020  bne cr6, 0x825b6fa0
	if !ctx.cr[6].eq {
	pc = 0x825B6FA0; continue 'dispatch;
	}
	// 825B6F84: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B6F88: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B6F8C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B6F90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6F94: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B6F98: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6F9C: 4800001C  b 0x825b6fb8
	pc = 0x825B6FB8; continue 'dispatch;
            }
            0x825B6FA0 => {
    //   block [0x825B6FA0..0x825B6FB4)
	// 825B6FA0: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B6FA4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B6FA8: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B6FAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B6FB0: 48000008  b 0x825b6fb8
	pc = 0x825B6FB8; continue 'dispatch;
            }
            0x825B6FB4 => {
    //   block [0x825B6FB4..0x825B6FB8)
	// 825B6FB4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B6FB8; continue 'dispatch;
            }
            0x825B6FB8 => {
    //   block [0x825B6FB8..0x825B7048)
	// 825B6FB8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B6FBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B6FC0: 419A0130  beq cr6, 0x825b70f0
	if ctx.cr[6].eq {
	pc = 0x825B70F0; continue 'dispatch;
	}
	// 825B6FC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B6FC8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B6FCC: 4BFFFE5D  bl 0x825b6e28
	ctx.lr = 0x825B6FD0;
	sub_825B6E28(ctx, base);
	// 825B6FD0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B6FD4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B6FD8: 4BC233D9  bl 0x821da3b0
	ctx.lr = 0x825B6FDC;
	sub_821DA3B0(ctx, base);
	// 825B6FDC: 4BBFB51D  bl 0x821b24f8
	ctx.lr = 0x825B6FE0;
	sub_821B24F8(ctx, base);
	// 825B6FE0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B6FE4: 388BFF70  addi r4, r11, -0x90
	ctx.r[4].s64 = ctx.r[11].s64 + -144;
	// 825B6FE8: 4BD592A9  bl 0x82310290
	ctx.lr = 0x825B6FEC;
	sub_82310290(ctx, base);
	// 825B6FEC: 546A063E  clrlwi r10, r3, 0x18
	ctx.r[10].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B6FF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B6FF4: 409A00FC  bne cr6, 0x825b70f0
	if !ctx.cr[6].eq {
	pc = 0x825B70F0; continue 'dispatch;
	}
	// 825B6FF8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B6FFC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B7000: 4BC233B1  bl 0x821da3b0
	ctx.lr = 0x825B7004;
	sub_821DA3B0(ctx, base);
	// 825B7004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B7008: 38AB2D60  addi r5, r11, 0x2d60
	ctx.r[5].s64 = ctx.r[11].s64 + 11616;
	// 825B700C: 4BBFB4ED  bl 0x821b24f8
	ctx.lr = 0x825B7010;
	sub_821B24F8(ctx, base);
	// 825B7010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7014: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B7018: 481CC401  bl 0x82783418
	ctx.lr = 0x825B701C;
	sub_82783418(ctx, base);
	// 825B701C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7020: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7024: 419A0024  beq cr6, 0x825b7048
	if ctx.cr[6].eq {
	pc = 0x825B7048; continue 'dispatch;
	}
	// 825B7028: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B702C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B7030: 38EBF774  addi r7, r11, -0x88c
	ctx.r[7].s64 = ctx.r[11].s64 + -2188;
	// 825B7034: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B7038: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B703C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B7040: 480000C1  bl 0x825b7100
	ctx.lr = 0x825B7044;
	sub_825B7100(ctx, base);
	// 825B7044: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x825B7048; continue 'dispatch;
            }
            0x825B7048 => {
    //   block [0x825B7048..0x825B7098)
	// 825B7048: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B704C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B7050: 4BC23361  bl 0x821da3b0
	ctx.lr = 0x825B7054;
	sub_821DA3B0(ctx, base);
	// 825B7054: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B7058: 38AB2D70  addi r5, r11, 0x2d70
	ctx.r[5].s64 = ctx.r[11].s64 + 11632;
	// 825B705C: 4BBFB49D  bl 0x821b24f8
	ctx.lr = 0x825B7060;
	sub_821B24F8(ctx, base);
	// 825B7060: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7064: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B7068: 481CC3B1  bl 0x82783418
	ctx.lr = 0x825B706C;
	sub_82783418(ctx, base);
	// 825B706C: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7070: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7074: 419A0024  beq cr6, 0x825b7098
	if ctx.cr[6].eq {
	pc = 0x825B7098; continue 'dispatch;
	}
	// 825B7078: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B707C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B7080: 38EBF778  addi r7, r11, -0x888
	ctx.r[7].s64 = ctx.r[11].s64 + -2184;
	// 825B7084: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B7088: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B708C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B7090: 48000071  bl 0x825b7100
	ctx.lr = 0x825B7094;
	sub_825B7100(ctx, base);
	// 825B7094: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x825B7098; continue 'dispatch;
            }
            0x825B7098 => {
    //   block [0x825B7098..0x825B70F0)
	// 825B7098: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B709C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B70A0: 4BC23311  bl 0x821da3b0
	ctx.lr = 0x825B70A4;
	sub_821DA3B0(ctx, base);
	// 825B70A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 825B70A8: 38AB2D80  addi r5, r11, 0x2d80
	ctx.r[5].s64 = ctx.r[11].s64 + 11648;
	// 825B70AC: 4BBFB44D  bl 0x821b24f8
	ctx.lr = 0x825B70B0;
	sub_821B24F8(ctx, base);
	// 825B70B0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B70B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B70B8: 481CC361  bl 0x82783418
	ctx.lr = 0x825B70BC;
	sub_82783418(ctx, base);
	// 825B70BC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B70C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B70C4: 419A002C  beq cr6, 0x825b70f0
	if ctx.cr[6].eq {
	pc = 0x825B70F0; continue 'dispatch;
	}
	// 825B70C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B70CC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B70D0: 38EBF77C  addi r7, r11, -0x884
	ctx.r[7].s64 = ctx.r[11].s64 + -2180;
	// 825B70D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B70D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B70DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B70E0: 48000021  bl 0x825b7100
	ctx.lr = 0x825B70E4;
	sub_825B7100(ctx, base);
	// 825B70E4: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B70E8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B70EC: 486F2368  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B70F0 => {
    //   block [0x825B70F0..0x825B70FC)
	// 825B70F0: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B70F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B70F8: 486F235C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7100(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B7100 size=364
    let mut pc: u32 = 0x825B7100;
    'dispatch: loop {
        match pc {
            0x825B7100 => {
    //   block [0x825B7100..0x825B71F8)
	// 825B7100: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7104: 486F2301  bl 0x82ca9404
	ctx.lr = 0x825B7108;
	sub_82CA93D0(ctx, base);
	// 825B7108: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B710C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825B7110: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7114: 396000FF  li r11, 0xff
	ctx.r[11].s64 = 255;
	// 825B7118: 390A9484  addi r8, r10, -0x6b7c
	ctx.r[8].s64 = ctx.r[10].s64 + -27516;
	// 825B711C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B7120: 99610082  stb r11, 0x82(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(130 as u32), ctx.r[11].u8 ) };
	// 825B7124: 99610081  stb r11, 0x81(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(129 as u32), ctx.r[11].u8 ) };
	// 825B7128: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B712C: C00A9484  lfs f0, -0x6b7c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7130: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825B7134: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 825B7138: 91210070  stw r9, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[9].u32 ) };
	// 825B713C: C008000C  lfs f0, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7140: 93E10068  stw r31, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 825B7144: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 825B7148: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825B714C: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 825B7150: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 825B7154: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 825B7158: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825B715C: 99610080  stb r11, 0x80(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u8 ) };
	// 825B7160: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 825B7164: 99610083  stb r11, 0x83(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(131 as u32), ctx.r[11].u8 ) };
	// 825B7168: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B716C: 99610086  stb r11, 0x86(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(134 as u32), ctx.r[11].u8 ) };
	// 825B7170: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825B7174: 99610085  stb r11, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[11].u8 ) };
	// 825B7178: 7CFB3B78  mr r27, r7
	ctx.r[27].u64 = ctx.r[7].u64;
	// 825B717C: 99610084  stb r11, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[11].u8 ) };
	// 825B7180: 99610087  stb r11, 0x87(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(135 as u32), ctx.r[11].u8 ) };
	// 825B7184: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 825B7188: 48002C81  bl 0x825b9e08
	ctx.lr = 0x825B718C;
	sub_825B9E08(ctx, base);
	// 825B718C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7190: 80BD00D4  lwz r5, 0xd4(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 825B7194: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825B7198: 93E100A4  stw r31, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[31].u32 ) };
	// 825B719C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 825B71A0: 38C75790  addi r6, r7, 0x5790
	ctx.r[6].s64 = ctx.r[7].s64 + 22416;
	// 825B71A4: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 825B71A8: 90C100A0  stw r6, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[6].u32 ) };
	// 825B71AC: 90A100A8  stw r5, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[5].u32 ) };
	// 825B71B0: 916100AC  stw r11, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[11].u32 ) };
	// 825B71B4: 8B7E00B2  lbz r27, 0xb2(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(178 as u32) ) } as u64;
	// 825B71B8: 48002BA1  bl 0x825b9d58
	ctx.lr = 0x825B71BC;
	sub_825B9D58(ctx, base);
	// 825B71BC: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B71C0: 9B6100C0  stb r27, 0xc0(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[27].u8 ) };
	// 825B71C4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825B71C8: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B71CC: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 825B71D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B71D4: 80DC0034  lwz r6, 0x34(r28)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) } as u64;
	// 825B71D8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B71DC: 4BFBB7AD  bl 0x82572988
	ctx.lr = 0x825B71E0;
	sub_82572988(ctx, base);
	// 825B71E0: 815E0058  lwz r10, 0x58(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B71E4: 387E0054  addi r3, r30, 0x54
	ctx.r[3].s64 = ctx.r[30].s64 + 84;
	// 825B71E8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B71EC: 409A000C  bne cr6, 0x825b71f8
	if !ctx.cr[6].eq {
	pc = 0x825B71F8; continue 'dispatch;
	}
	// 825B71F0: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 825B71F4: 48000010  b 0x825b7204
	pc = 0x825B7204; continue 'dispatch;
            }
            0x825B71F8 => {
    //   block [0x825B71F8..0x825B7204)
	// 825B71F8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B71FC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B7200: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x825B7204; continue 'dispatch;
            }
            0x825B7204 => {
    //   block [0x825B7204..0x825B7228)
	// 825B7204: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7208: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B720C: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825B7210: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B7214: 40980020  bge cr6, 0x825b7234
	if !ctx.cr[6].lt {
	pc = 0x825B7234; continue 'dispatch;
	}
	// 825B7218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B721C: 419A000C  beq cr6, 0x825b7228
	if ctx.cr[6].eq {
	pc = 0x825B7228; continue 'dispatch;
	}
	// 825B7220: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7224: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x825B7228; continue 'dispatch;
            }
            0x825B7228 => {
    //   block [0x825B7228..0x825B7234)
	// 825B7228: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825B722C: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B7230: 4800001C  b 0x825b724c
	pc = 0x825B724C; continue 'dispatch;
            }
            0x825B7234 => {
    //   block [0x825B7234..0x825B724C)
	// 825B7234: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B7238: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B723C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B7240: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825B7244: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B7248: 48003509  bl 0x825ba750
	ctx.lr = 0x825B724C;
	sub_825BA750(ctx, base);
	pc = 0x825B724C; continue 'dispatch;
            }
            0x825B724C => {
    //   block [0x825B724C..0x825B7264)
	// 825B724C: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 825B7250: 4BFFC719  bl 0x825b3968
	ctx.lr = 0x825B7254;
	sub_825B3968(ctx, base);
	// 825B7254: 80610064  lwz r3, 0x64(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B7258: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B725C: 419A0008  beq cr6, 0x825b7264
	if ctx.cr[6].eq {
	pc = 0x825B7264; continue 'dispatch;
	}
	// 825B7260: 4BC64AD9  bl 0x8221bd38
	ctx.lr = 0x825B7264;
	sub_8221BD38(ctx, base);
	pc = 0x825B7264; continue 'dispatch;
            }
            0x825B7264 => {
    //   block [0x825B7264..0x825B726C)
	// 825B7264: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825B7268: 486F21EC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B7270 size=508
    let mut pc: u32 = 0x825B7270;
    'dispatch: loop {
        match pc {
            0x825B7270 => {
    //   block [0x825B7270..0x825B72D0)
	// 825B7270: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7274: 486F2191  bl 0x82ca9404
	ctx.lr = 0x825B7278;
	sub_82CA93D0(ctx, base);
	// 825B7278: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B727C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B7280: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B7284: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825B7288: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825B728C: 7FFBFB78  mr r27, r31
	ctx.r[27].u64 = ctx.r[31].u64;
	// 825B7290: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7294: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B7298: 5549DFFE  rlwinm r9, r10, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 825B729C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B72A0: 419A00F4  beq cr6, 0x825b7394
	if ctx.cr[6].eq {
	pc = 0x825B7394; continue 'dispatch;
	}
	// 825B72A4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B72A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B72AC: 419A0024  beq cr6, 0x825b72d0
	if ctx.cr[6].eq {
	pc = 0x825B72D0; continue 'dispatch;
	}
	// 825B72B0: 894A00E5  lbz r10, 0xe5(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(229 as u32) ) } as u64;
	// 825B72B4: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B72B8: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B72BC: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B72C0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B72C4: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B72C8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B72CC: 480000CC  b 0x825b7398
	pc = 0x825B7398; continue 'dispatch;
            }
            0x825B72D0 => {
    //   block [0x825B72D0..0x825B72EC)
	// 825B72D0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B72D4: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B72D8: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B72DC: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B72E0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B72E4: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B72E8: 40810054  ble 0x825b733c
	if !ctx.cr[0].gt {
	pc = 0x825B733C; continue 'dispatch;
	}
	pc = 0x825B72EC; continue 'dispatch;
            }
            0x825B72EC => {
    //   block [0x825B72EC..0x825B730C)
	// 825B72EC: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B72F0: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B72F4: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B72F8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B72FC: 2F0700E5  cmpwi cr6, r7, 0xe5
	ctx.cr[6].compare_i32(ctx.r[7].s32, 229, &mut ctx.xer);
	// 825B7300: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B7304: 41980008  blt cr6, 0x825b730c
	if ctx.cr[6].lt {
	pc = 0x825B730C; continue 'dispatch;
	}
	// 825B7308: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B730C; continue 'dispatch;
            }
            0x825B730C => {
    //   block [0x825B730C..0x825B7328)
	// 825B730C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B7310: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B7314: 419A0014  beq cr6, 0x825b7328
	if ctx.cr[6].eq {
	pc = 0x825B7328; continue 'dispatch;
	}
	// 825B7318: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B731C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B7320: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B7324: 4800000C  b 0x825b7330
	pc = 0x825B7330; continue 'dispatch;
            }
            0x825B7328 => {
    //   block [0x825B7328..0x825B7330)
	// 825B7328: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B732C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B7330; continue 'dispatch;
            }
            0x825B7330 => {
    //   block [0x825B7330..0x825B733C)
	// 825B7330: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B7334: 4199FFB8  bgt cr6, 0x825b72ec
	if ctx.cr[6].gt {
	pc = 0x825B72EC; continue 'dispatch;
	}
	// 825B7338: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B733C; continue 'dispatch;
            }
            0x825B733C => {
    //   block [0x825B733C..0x825B7358)
	// 825B733C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B7340: 419A0040  beq cr6, 0x825b7380
	if ctx.cr[6].eq {
	pc = 0x825B7380; continue 'dispatch;
	}
	// 825B7344: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7348: 2F0B00E5  cmpwi cr6, r11, 0xe5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 229, &mut ctx.xer);
	// 825B734C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B7350: 41990008  bgt cr6, 0x825b7358
	if ctx.cr[6].gt {
	pc = 0x825B7358; continue 'dispatch;
	}
	// 825B7354: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B7358; continue 'dispatch;
            }
            0x825B7358 => {
    //   block [0x825B7358..0x825B7380)
	// 825B7358: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B735C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7360: 409A0020  bne cr6, 0x825b7380
	if !ctx.cr[6].eq {
	pc = 0x825B7380; continue 'dispatch;
	}
	// 825B7364: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B7368: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B736C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B7370: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7374: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B7378: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B737C: 4800001C  b 0x825b7398
	pc = 0x825B7398; continue 'dispatch;
            }
            0x825B7380 => {
    //   block [0x825B7380..0x825B7394)
	// 825B7380: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B7384: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7388: 7D7F5B78  mr r31, r11
	ctx.r[31].u64 = ctx.r[11].u64;
	// 825B738C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B7390: 48000008  b 0x825b7398
	pc = 0x825B7398; continue 'dispatch;
            }
            0x825B7394 => {
    //   block [0x825B7394..0x825B7398)
	// 825B7394: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B7398; continue 'dispatch;
            }
            0x825B7398 => {
    //   block [0x825B7398..0x825B73E8)
	// 825B7398: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B739C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B73A0: 419A00C0  beq cr6, 0x825b7460
	if ctx.cr[6].eq {
	pc = 0x825B7460; continue 'dispatch;
	}
	// 825B73A4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B73A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B73AC: 4BFFFA7D  bl 0x825b6e28
	ctx.lr = 0x825B73B0;
	sub_825B6E28(ctx, base);
	// 825B73B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B73B4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B73B8: 48302B51  bl 0x828b9f08
	ctx.lr = 0x825B73BC;
	sub_828B9F08(ctx, base);
	// 825B73BC: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B73C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B73C4: 419A0024  beq cr6, 0x825b73e8
	if ctx.cr[6].eq {
	pc = 0x825B73E8; continue 'dispatch;
	}
	// 825B73C8: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B73CC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B73D0: 38EBF774  addi r7, r11, -0x88c
	ctx.r[7].s64 = ctx.r[11].s64 + -2188;
	// 825B73D4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B73D8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B73DC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B73E0: 4BFFFD21  bl 0x825b7100
	ctx.lr = 0x825B73E4;
	sub_825B7100(ctx, base);
	// 825B73E4: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x825B73E8; continue 'dispatch;
            }
            0x825B73E8 => {
    //   block [0x825B73E8..0x825B7420)
	// 825B73E8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B73EC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B73F0: 48302BE9  bl 0x828b9fd8
	ctx.lr = 0x825B73F4;
	sub_828B9FD8(ctx, base);
	// 825B73F4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B73F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B73FC: 419A0024  beq cr6, 0x825b7420
	if ctx.cr[6].eq {
	pc = 0x825B7420; continue 'dispatch;
	}
	// 825B7400: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B7404: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B7408: 38EBF778  addi r7, r11, -0x888
	ctx.r[7].s64 = ctx.r[11].s64 + -2184;
	// 825B740C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B7410: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B7414: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B7418: 4BFFFCE9  bl 0x825b7100
	ctx.lr = 0x825B741C;
	sub_825B7100(ctx, base);
	// 825B741C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	pc = 0x825B7420; continue 'dispatch;
            }
            0x825B7420 => {
    //   block [0x825B7420..0x825B7460)
	// 825B7420: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B7424: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B7428: 48302C81  bl 0x828ba0a8
	ctx.lr = 0x825B742C;
	sub_828BA0A8(ctx, base);
	// 825B742C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7430: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7434: 419A002C  beq cr6, 0x825b7460
	if ctx.cr[6].eq {
	pc = 0x825B7460; continue 'dispatch;
	}
	// 825B7438: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B743C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B7440: 38EBF77C  addi r7, r11, -0x884
	ctx.r[7].s64 = ctx.r[11].s64 + -2180;
	// 825B7444: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825B7448: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B744C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B7450: 4BFFFCB1  bl 0x825b7100
	ctx.lr = 0x825B7454;
	sub_825B7100(ctx, base);
	// 825B7454: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B7458: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B745C: 486F1FF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B7460 => {
    //   block [0x825B7460..0x825B746C)
	// 825B7460: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B7464: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B7468: 486F1FEC  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7470(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B7470 size=1160
    let mut pc: u32 = 0x825B7470;
    'dispatch: loop {
        match pc {
            0x825B7470 => {
    //   block [0x825B7470..0x825B74F8)
	// 825B7470: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7474: 486F1F81  bl 0x82ca93f4
	ctx.lr = 0x825B7478;
	sub_82CA93D0(ctx, base);
	// 825B7478: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 825B747C: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825B7480: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7484: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825B7488: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B748C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825B7490: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825B7494: 419A0454  beq cr6, 0x825b78e8
	if ctx.cr[6].eq {
	pc = 0x825B78E8; continue 'dispatch;
	}
	// 825B7498: 3D608332  lis r11, -0x7cce
	ctx.r[11].s64 = -2093875200;
	// 825B749C: 891B0006  lbz r8, 6(r27)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B74A0: 3B200001  li r25, 1
	ctx.r[25].s64 = 1;
	// 825B74A4: 38ABB158  addi r5, r11, -0x4ea8
	ctx.r[5].s64 = ctx.r[11].s64 + -20136;
	// 825B74A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B74AC: 88EBB158  lbz r7, -0x4ea8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-20136 as u32) ) } as u64;
	// 825B74B0: 89450002  lbz r10, 2(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B74B4: 88C50003  lbz r6, 3(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B74B8: 89250001  lbz r9, 1(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B74BC: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B74C0: 409A0038  bne cr6, 0x825b74f8
	if !ctx.cr[6].eq {
	pc = 0x825B74F8; continue 'dispatch;
	}
	// 825B74C4: 897B0005  lbz r11, 5(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(5 as u32) ) } as u64;
	// 825B74C8: 5528063E  clrlwi r8, r9, 0x18
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 825B74CC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B74D0: 409A0028  bne cr6, 0x825b74f8
	if !ctx.cr[6].eq {
	pc = 0x825B74F8; continue 'dispatch;
	}
	// 825B74D4: 897B0004  lbz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B74D8: 54E8063E  clrlwi r8, r7, 0x18
	ctx.r[8].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B74DC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B74E0: 409A0018  bne cr6, 0x825b74f8
	if !ctx.cr[6].eq {
	pc = 0x825B74F8; continue 'dispatch;
	}
	// 825B74E4: 897B0007  lbz r11, 7(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(7 as u32) ) } as u64;
	// 825B74E8: 54C8063E  clrlwi r8, r6, 0x18
	ctx.r[8].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 825B74EC: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B74F0: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B74F4: 419A0008  beq cr6, 0x825b74fc
	if ctx.cr[6].eq {
	pc = 0x825B74FC; continue 'dispatch;
	}
	pc = 0x825B74F8; continue 'dispatch;
            }
            0x825B74F8 => {
    //   block [0x825B74F8..0x825B74FC)
	// 825B74F8: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825B74FC; continue 'dispatch;
            }
            0x825B74FC => {
    //   block [0x825B74FC..0x825B7524)
	// 825B74FC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 825B7500: 5565063E  clrlwi r5, r11, 0x18
	ctx.r[5].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7504: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825B7508: C0089A80  lfs f0, -0x6580(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B750C: 409A0018  bne cr6, 0x825b7524
	if !ctx.cr[6].eq {
	pc = 0x825B7524; continue 'dispatch;
	}
	// 825B7510: C1BB0008  lfs f13, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7514: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B7518: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825B751C: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825B7520: 40990008  ble cr6, 0x825b7528
	if !ctx.cr[6].gt {
	pc = 0x825B7528; continue 'dispatch;
	}
	pc = 0x825B7524; continue 'dispatch;
            }
            0x825B7524 => {
    //   block [0x825B7524..0x825B7528)
	// 825B7524: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825B7528; continue 'dispatch;
            }
            0x825B7528 => {
    //   block [0x825B7528..0x825B756C)
	// 825B7528: 88BB000E  lbz r5, 0xe(r27)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(14 as u32) ) } as u64;
	// 825B752C: 5568063E  clrlwi r8, r11, 0x18
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7530: 7F055040  cmplw cr6, r5, r10
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7534: 409A0038  bne cr6, 0x825b756c
	if !ctx.cr[6].eq {
	pc = 0x825B756C; continue 'dispatch;
	}
	// 825B7538: 897B000D  lbz r11, 0xd(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(13 as u32) ) } as u64;
	// 825B753C: 552A063E  clrlwi r10, r9, 0x18
	ctx.r[10].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 825B7540: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7544: 409A0028  bne cr6, 0x825b756c
	if !ctx.cr[6].eq {
	pc = 0x825B756C; continue 'dispatch;
	}
	// 825B7548: 897B000C  lbz r11, 0xc(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B754C: 54EA063E  clrlwi r10, r7, 0x18
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B7550: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7554: 409A0018  bne cr6, 0x825b756c
	if !ctx.cr[6].eq {
	pc = 0x825B756C; continue 'dispatch;
	}
	// 825B7558: 897B000F  lbz r11, 0xf(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(15 as u32) ) } as u64;
	// 825B755C: 54CA063E  clrlwi r10, r6, 0x18
	ctx.r[10].u64 = ctx.r[6].u32 as u64 & 0x000000FFu64;
	// 825B7560: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7564: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B7568: 419A0008  beq cr6, 0x825b7570
	if ctx.cr[6].eq {
	pc = 0x825B7570; continue 'dispatch;
	}
	pc = 0x825B756C; continue 'dispatch;
            }
            0x825B756C => {
    //   block [0x825B756C..0x825B7570)
	// 825B756C: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825B7570; continue 'dispatch;
            }
            0x825B7570 => {
    //   block [0x825B7570..0x825B7590)
	// 825B7570: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7574: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7578: 409A0018  bne cr6, 0x825b7590
	if !ctx.cr[6].eq {
	pc = 0x825B7590; continue 'dispatch;
	}
	// 825B757C: C1BB0010  lfs f13, 0x10(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825B7580: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825B7584: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 825B7588: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 825B758C: 40990008  ble cr6, 0x825b7594
	if !ctx.cr[6].gt {
	pc = 0x825B7594; continue 'dispatch;
	}
	pc = 0x825B7590; continue 'dispatch;
            }
            0x825B7590 => {
    //   block [0x825B7590..0x825B7594)
	// 825B7590: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	pc = 0x825B7594; continue 'dispatch;
            }
            0x825B7594 => {
    //   block [0x825B7594..0x825B75B0)
	// 825B7594: 551A063E  clrlwi r26, r8, 0x18
	ctx.r[26].u64 = ctx.r[8].u32 as u64 & 0x000000FFu64;
	// 825B7598: 5578063E  clrlwi r24, r11, 0x18
	ctx.r[24].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B759C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825B75A0: 409A0010  bne cr6, 0x825b75b0
	if !ctx.cr[6].eq {
	pc = 0x825B75B0; continue 'dispatch;
	}
	// 825B75A4: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 825B75A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B75AC: 419A033C  beq cr6, 0x825b78e8
	if ctx.cr[6].eq {
	pc = 0x825B78E8; continue 'dispatch;
	}
	pc = 0x825B75B0; continue 'dispatch;
            }
            0x825B75B0 => {
    //   block [0x825B75B0..0x825B7640)
	// 825B75B0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B75B4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B75B8: 38AB5548  addi r5, r11, 0x5548
	ctx.r[5].s64 = ctx.r[11].s64 + 21832;
	// 825B75BC: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B75C0: 481CBE59  bl 0x82783418
	ctx.lr = 0x825B75C4;
	sub_82783418(ctx, base);
	// 825B75C4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B75C8: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B75CC: 38AA5660  addi r5, r10, 0x5660
	ctx.r[5].s64 = ctx.r[10].s64 + 22112;
	// 825B75D0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B75D4: 481CBE45  bl 0x82783418
	ctx.lr = 0x825B75D8;
	sub_82783418(ctx, base);
	// 825B75D8: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825B75DC: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B75E0: 3BC000FF  li r30, 0xff
	ctx.r[30].s64 = 255;
	// 825B75E4: 39099484  addi r8, r9, -0x6b7c
	ctx.r[8].s64 = ctx.r[9].s64 + -27516;
	// 825B75E8: 83810058  lwz r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B75EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B75F0: C3C99484  lfs f30, -0x6b7c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-27516 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B75F4: C3E8000C  lfs f31, 0xc(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B75F8: 419A0094  beq cr6, 0x825b768c
	if ctx.cr[6].eq {
	pc = 0x825B768C; continue 'dispatch;
	}
	// 825B75FC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7600: 3920000B  li r9, 0xb
	ctx.r[9].s64 = 11;
	// 825B7604: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825B7608: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825B760C: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825B7610: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825B7614: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 825B7618: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B761C: 9BA10072  stb r29, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[29].u8 ) };
	// 825B7620: 9BA10071  stb r29, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[29].u8 ) };
	// 825B7624: 9BA10070  stb r29, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u8 ) };
	// 825B7628: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 825B762C: 91210078  stw r9, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 825B7630: 9BA1007C  stb r29, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 825B7634: 409A000C  bne cr6, 0x825b7640
	if !ctx.cr[6].eq {
	pc = 0x825B7640; continue 'dispatch;
	}
	// 825B7638: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825B763C: 48000010  b 0x825b764c
	pc = 0x825B764C; continue 'dispatch;
            }
            0x825B7640 => {
    //   block [0x825B7640..0x825B764C)
	// 825B7640: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B7644: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B7648: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B764C; continue 'dispatch;
            }
            0x825B764C => {
    //   block [0x825B764C..0x825B7678)
	// 825B764C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7650: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825B7654: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B7658: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B765C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B7660: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B7664: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7668: 40980010  bge cr6, 0x825b7678
	if !ctx.cr[6].lt {
	pc = 0x825B7678; continue 'dispatch;
	}
	// 825B766C: 480036AD  bl 0x825bad18
	ctx.lr = 0x825B7670;
	sub_825BAD18(ctx, base);
	// 825B7670: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B7674: 48000014  b 0x825b7688
	pc = 0x825B7688; continue 'dispatch;
            }
            0x825B7678 => {
    //   block [0x825B7678..0x825B7688)
	// 825B7678: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825B767C: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B7680: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B7684: 48004355  bl 0x825bb9d8
	ctx.lr = 0x825B7688;
	sub_825BB9D8(ctx, base);
	pc = 0x825B7688; continue 'dispatch;
            }
            0x825B7688 => {
    //   block [0x825B7688..0x825B768C)
	// 825B7688: 9B3F0011  stb r25, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	pc = 0x825B768C; continue 'dispatch;
            }
            0x825B768C => {
    //   block [0x825B768C..0x825B76A0)
	// 825B768C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825B7690: 419A0010  beq cr6, 0x825b76a0
	if ctx.cr[6].eq {
	pc = 0x825B76A0; continue 'dispatch;
	}
	// 825B7694: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 825B7698: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B769C: 409A0094  bne cr6, 0x825b7730
	if !ctx.cr[6].eq {
	pc = 0x825B7730; continue 'dispatch;
	}
	pc = 0x825B76A0; continue 'dispatch;
            }
            0x825B76A0 => {
    //   block [0x825B76A0..0x825B76E4)
	// 825B76A0: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B76A4: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 825B76A8: D3E1006C  stfs f31, 0x6c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825B76AC: 93810060  stw r28, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[28].u32 ) };
	// 825B76B0: D3C10074  stfs f30, 0x74(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825B76B4: 93810064  stw r28, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u32 ) };
	// 825B76B8: 93210068  stw r25, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[25].u32 ) };
	// 825B76BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B76C0: 9BA10072  stb r29, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[29].u8 ) };
	// 825B76C4: 9BA10071  stb r29, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[29].u8 ) };
	// 825B76C8: 9BA10070  stb r29, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[29].u8 ) };
	// 825B76CC: 9BC10073  stb r30, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[30].u8 ) };
	// 825B76D0: 91410078  stw r10, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 825B76D4: 9BA1007C  stb r29, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[29].u8 ) };
	// 825B76D8: 409A000C  bne cr6, 0x825b76e4
	if !ctx.cr[6].eq {
	pc = 0x825B76E4; continue 'dispatch;
	}
	// 825B76DC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825B76E0: 48000010  b 0x825b76f0
	pc = 0x825B76F0; continue 'dispatch;
            }
            0x825B76E4 => {
    //   block [0x825B76E4..0x825B76F0)
	// 825B76E4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B76E8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B76EC: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B76F0; continue 'dispatch;
            }
            0x825B76F0 => {
    //   block [0x825B76F0..0x825B771C)
	// 825B76F0: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B76F4: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825B76F8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B76FC: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B7700: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B7704: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B7708: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B770C: 40980010  bge cr6, 0x825b771c
	if !ctx.cr[6].lt {
	pc = 0x825B771C; continue 'dispatch;
	}
	// 825B7710: 48003609  bl 0x825bad18
	ctx.lr = 0x825B7714;
	sub_825BAD18(ctx, base);
	// 825B7714: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B7718: 48000014  b 0x825b772c
	pc = 0x825B772C; continue 'dispatch;
            }
            0x825B771C => {
    //   block [0x825B771C..0x825B772C)
	// 825B771C: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825B7720: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B7724: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B7728: 480042B1  bl 0x825bb9d8
	ctx.lr = 0x825B772C;
	sub_825BB9D8(ctx, base);
	pc = 0x825B772C; continue 'dispatch;
            }
            0x825B772C => {
    //   block [0x825B772C..0x825B7730)
	// 825B772C: 9B3F0011  stb r25, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	pc = 0x825B7730; continue 'dispatch;
            }
            0x825B7730 => {
    //   block [0x825B7730..0x825B77B8)
	// 825B7730: 3BC0000A  li r30, 0xa
	ctx.r[30].s64 = 10;
	// 825B7734: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825B7738: 419A00CC  beq cr6, 0x825b7804
	if ctx.cr[6].eq {
	pc = 0x825B7804; continue 'dispatch;
	}
	// 825B773C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B7740: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B7744: 38AB566C  addi r5, r11, 0x566c
	ctx.r[5].s64 = ctx.r[11].s64 + 22124;
	// 825B7748: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B774C: 481CBCCD  bl 0x82783418
	ctx.lr = 0x825B7750;
	sub_82783418(ctx, base);
	// 825B7750: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B7754: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7758: 419A00AC  beq cr6, 0x825b7804
	if ctx.cr[6].eq {
	pc = 0x825B7804; continue 'dispatch;
	}
	// 825B775C: 813B0004  lwz r9, 4(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7760: C01B0008  lfs f0, 8(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7764: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7768: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825B776C: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825B7770: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 825B7774: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 825B7778: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B777C: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 825B7780: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 825B7784: 88E1006E  lbz r7, 0x6e(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 825B7788: 88C1006D  lbz r6, 0x6d(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 825B778C: 88A1006C  lbz r5, 0x6c(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B7790: 8901006F  lbz r8, 0x6f(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 825B7794: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 825B7798: 9BA1009C  stb r29, 0x9c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u8 ) };
	// 825B779C: 99010093  stb r8, 0x93(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(147 as u32), ctx.r[8].u8 ) };
	// 825B77A0: 98C10091  stb r6, 0x91(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(145 as u32), ctx.r[6].u8 ) };
	// 825B77A4: 98E10092  stb r7, 0x92(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(146 as u32), ctx.r[7].u8 ) };
	// 825B77A8: 98A10090  stb r5, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u8 ) };
	// 825B77AC: 409A000C  bne cr6, 0x825b77b8
	if !ctx.cr[6].eq {
	pc = 0x825B77B8; continue 'dispatch;
	}
	// 825B77B0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825B77B4: 48000010  b 0x825b77c4
	pc = 0x825B77C4; continue 'dispatch;
            }
            0x825B77B8 => {
    //   block [0x825B77B8..0x825B77C4)
	// 825B77B8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B77BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B77C0: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B77C4; continue 'dispatch;
            }
            0x825B77C4 => {
    //   block [0x825B77C4..0x825B77F0)
	// 825B77C4: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B77C8: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825B77CC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B77D0: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B77D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B77D8: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B77DC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B77E0: 40980010  bge cr6, 0x825b77f0
	if !ctx.cr[6].lt {
	pc = 0x825B77F0; continue 'dispatch;
	}
	// 825B77E4: 48003535  bl 0x825bad18
	ctx.lr = 0x825B77E8;
	sub_825BAD18(ctx, base);
	// 825B77E8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B77EC: 48000014  b 0x825b7800
	pc = 0x825B7800; continue 'dispatch;
            }
            0x825B77F0 => {
    //   block [0x825B77F0..0x825B7800)
	// 825B77F0: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825B77F4: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B77F8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B77FC: 480041DD  bl 0x825bb9d8
	ctx.lr = 0x825B7800;
	sub_825BB9D8(ctx, base);
	pc = 0x825B7800; continue 'dispatch;
            }
            0x825B7800 => {
    //   block [0x825B7800..0x825B7804)
	// 825B7800: 9B3F0011  stb r25, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	pc = 0x825B7804; continue 'dispatch;
            }
            0x825B7804 => {
    //   block [0x825B7804..0x825B788C)
	// 825B7804: 570B063E  clrlwi r11, r24, 0x18
	ctx.r[11].u64 = ctx.r[24].u32 as u64 & 0x000000FFu64;
	// 825B7808: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B780C: 419A00DC  beq cr6, 0x825b78e8
	if ctx.cr[6].eq {
	pc = 0x825B78E8; continue 'dispatch;
	}
	// 825B7810: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B7814: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B7818: 38AB5674  addi r5, r11, 0x5674
	ctx.r[5].s64 = ctx.r[11].s64 + 22132;
	// 825B781C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B7820: 481CBBF9  bl 0x82783418
	ctx.lr = 0x825B7824;
	sub_82783418(ctx, base);
	// 825B7824: 81410058  lwz r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B7828: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B782C: 419A00BC  beq cr6, 0x825b78e8
	if ctx.cr[6].eq {
	pc = 0x825B78E8; continue 'dispatch;
	}
	// 825B7830: 813B000C  lwz r9, 0xc(r27)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B7834: C01B0010  lfs f0, 0x10(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7838: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B783C: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825B7840: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 825B7844: 93810080  stw r28, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[28].u32 ) };
	// 825B7848: 91410084  stw r10, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 825B784C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7850: 93210088  stw r25, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 825B7854: 9121006C  stw r9, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 825B7858: 8901006C  lbz r8, 0x6c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B785C: 93C10098  stw r30, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[30].u32 ) };
	// 825B7860: 9BA1009C  stb r29, 0x9c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[29].u8 ) };
	// 825B7864: 99010090  stb r8, 0x90(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u8 ) };
	// 825B7868: 88E1006F  lbz r7, 0x6f(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(111 as u32) ) } as u64;
	// 825B786C: 88C1006D  lbz r6, 0x6d(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(109 as u32) ) } as u64;
	// 825B7870: 88A1006E  lbz r5, 0x6e(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(110 as u32) ) } as u64;
	// 825B7874: 98E10093  stb r7, 0x93(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(147 as u32), ctx.r[7].u8 ) };
	// 825B7878: 98C10091  stb r6, 0x91(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(145 as u32), ctx.r[6].u8 ) };
	// 825B787C: 98A10092  stb r5, 0x92(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(146 as u32), ctx.r[5].u8 ) };
	// 825B7880: 409A000C  bne cr6, 0x825b788c
	if !ctx.cr[6].eq {
	pc = 0x825B788C; continue 'dispatch;
	}
	// 825B7884: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825B7888: 48000010  b 0x825b7898
	pc = 0x825B7898; continue 'dispatch;
            }
            0x825B788C => {
    //   block [0x825B788C..0x825B7898)
	// 825B788C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B7890: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B7894: 7D2A2E70  srawi r10, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825B7898; continue 'dispatch;
            }
            0x825B7898 => {
    //   block [0x825B7898..0x825B78D4)
	// 825B7898: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B789C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 825B78A0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B78A4: 7D6B2050  subf r11, r11, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825B78A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B78AC: 7D692E70  srawi r9, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825B78B0: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B78B4: 40980020  bge cr6, 0x825b78d4
	if !ctx.cr[6].lt {
	pc = 0x825B78D4; continue 'dispatch;
	}
	// 825B78B8: 48003461  bl 0x825bad18
	ctx.lr = 0x825B78BC;
	sub_825BAD18(ctx, base);
	// 825B78BC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825B78C0: 9B3F0011  stb r25, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	// 825B78C4: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825B78C8: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825B78CC: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825B78D0: 486F1B74  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B78D4 => {
    //   block [0x825B78D4..0x825B78E8)
	// 825B78D4: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 825B78D8: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B78DC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B78E0: 480040F9  bl 0x825bb9d8
	ctx.lr = 0x825B78E4;
	sub_825BB9D8(ctx, base);
	// 825B78E4: 9B3F0011  stb r25, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[25].u8 ) };
	pc = 0x825B78E8; continue 'dispatch;
            }
            0x825B78E8 => {
    //   block [0x825B78E8..0x825B78F8)
	// 825B78E8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825B78EC: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 825B78F0: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825B78F4: 486F1B50  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B78F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B78F8 size=968
    let mut pc: u32 = 0x825B78F8;
    'dispatch: loop {
        match pc {
            0x825B78F8 => {
    //   block [0x825B78F8..0x825B7954)
	// 825B78F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B78FC: 486F1AFD  bl 0x82ca93f8
	ctx.lr = 0x825B7900;
	sub_82CA93D0(ctx, base);
	// 825B7900: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 825B7904: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 825B7908: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B790C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B7910: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825B7914: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	// 825B7918: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B791C: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B7920: 5528D7FE  rlwinm r8, r9, 0x1a, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x0000003Fu64;
	// 825B7924: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B7928: 419A00E8  beq cr6, 0x825b7a10
	if ctx.cr[6].eq {
	pc = 0x825B7A10; continue 'dispatch;
	}
	// 825B792C: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B7930: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7934: 419A0020  beq cr6, 0x825b7954
	if ctx.cr[6].eq {
	pc = 0x825B7954; continue 'dispatch;
	}
	// 825B7938: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B793C: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B7940: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B7944: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B7948: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B794C: 81490004  lwz r10, 4(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7950: 480000C4  b 0x825b7a14
	pc = 0x825B7A14; continue 'dispatch;
            }
            0x825B7954 => {
    //   block [0x825B7954..0x825B7970)
	// 825B7954: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B7958: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B795C: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B7960: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B7964: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B7968: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B796C: 40810054  ble 0x825b79c0
	if !ctx.cr[0].gt {
	pc = 0x825B79C0; continue 'dispatch;
	}
	pc = 0x825B7970; continue 'dispatch;
            }
            0x825B7970 => {
    //   block [0x825B7970..0x825B7990)
	// 825B7970: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B7974: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B7978: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B797C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7980: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825B7984: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B7988: 41980008  blt cr6, 0x825b7990
	if ctx.cr[6].lt {
	pc = 0x825B7990; continue 'dispatch;
	}
	// 825B798C: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x825B7990; continue 'dispatch;
            }
            0x825B7990 => {
    //   block [0x825B7990..0x825B79AC)
	// 825B7990: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B7994: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B7998: 419A0014  beq cr6, 0x825b79ac
	if ctx.cr[6].eq {
	pc = 0x825B79AC; continue 'dispatch;
	}
	// 825B799C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B79A0: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B79A4: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B79A8: 4800000C  b 0x825b79b4
	pc = 0x825B79B4; continue 'dispatch;
            }
            0x825B79AC => {
    //   block [0x825B79AC..0x825B79B4)
	// 825B79AC: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B79B0: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B79B4; continue 'dispatch;
            }
            0x825B79B4 => {
    //   block [0x825B79B4..0x825B79C0)
	// 825B79B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B79B8: 4199FFB8  bgt cr6, 0x825b7970
	if ctx.cr[6].gt {
	pc = 0x825B7970; continue 'dispatch;
	}
	// 825B79BC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B79C0; continue 'dispatch;
            }
            0x825B79C0 => {
    //   block [0x825B79C0..0x825B79DC)
	// 825B79C0: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B79C4: 419A003C  beq cr6, 0x825b7a00
	if ctx.cr[6].eq {
	pc = 0x825B7A00; continue 'dispatch;
	}
	// 825B79C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B79CC: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B79D0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B79D4: 41990008  bgt cr6, 0x825b79dc
	if ctx.cr[6].gt {
	pc = 0x825B79DC; continue 'dispatch;
	}
	// 825B79D8: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B79DC; continue 'dispatch;
            }
            0x825B79DC => {
    //   block [0x825B79DC..0x825B7A00)
	// 825B79DC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B79E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B79E4: 409A001C  bne cr6, 0x825b7a00
	if !ctx.cr[6].eq {
	pc = 0x825B7A00; continue 'dispatch;
	}
	// 825B79E8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B79EC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B79F0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B79F4: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B79F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B79FC: 48000018  b 0x825b7a14
	pc = 0x825B7A14; continue 'dispatch;
            }
            0x825B7A00 => {
    //   block [0x825B7A00..0x825B7A10)
	// 825B7A00: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B7A04: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7A08: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B7A0C: 48000008  b 0x825b7a14
	pc = 0x825B7A14; continue 'dispatch;
            }
            0x825B7A10 => {
    //   block [0x825B7A10..0x825B7A14)
	// 825B7A10: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B7A14; continue 'dispatch;
            }
            0x825B7A14 => {
    //   block [0x825B7A14..0x825B7A68)
	// 825B7A14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7A18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7A1C: 419A0294  beq cr6, 0x825b7cb0
	if ctx.cr[6].eq {
	pc = 0x825B7CB0; continue 'dispatch;
	}
	// 825B7A20: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825B7A24: 83EA00A0  lwz r31, 0xa0(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(160 as u32) ) } as u64;
	// 825B7A28: 83CA0094  lwz r30, 0x94(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B7A2C: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825B7A30: 3B2B9490  addi r25, r11, -0x6b70
	ctx.r[25].s64 = ctx.r[11].s64 + -27504;
	// 825B7A34: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B7A38: C3D9FFF4  lfs f30, -0xc(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825B7A3C: 419A0040  beq cr6, 0x825b7a7c
	if ctx.cr[6].eq {
	pc = 0x825B7A7C; continue 'dispatch;
	}
	// 825B7A40: 4BC67819  bl 0x8221f258
	ctx.lr = 0x825B7A44;
	sub_8221F258(ctx, base);
	// 825B7A44: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B7A48: 419A0020  beq cr6, 0x825b7a68
	if ctx.cr[6].eq {
	pc = 0x825B7A68; continue 'dispatch;
	}
	// 825B7A4C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B7A50: 4BFC5D71  bl 0x8257d7c0
	ctx.lr = 0x825B7A54;
	sub_8257D7C0(ctx, base);
	// 825B7A54: 3B1D0074  addi r24, r29, 0x74
	ctx.r[24].s64 = ctx.r[29].s64 + 116;
	// 825B7A58: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7A5C: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B7A60: 4BCBB5F9  bl 0x82273058
	ctx.lr = 0x825B7A64;
	sub_82273058(ctx, base);
	// 825B7A64: 48000074  b 0x825b7ad8
	pc = 0x825B7AD8; continue 'dispatch;
            }
            0x825B7A68 => {
    //   block [0x825B7A68..0x825B7A7C)
	// 825B7A68: 3B1D0074  addi r24, r29, 0x74
	ctx.r[24].s64 = ctx.r[29].s64 + 116;
	// 825B7A6C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B7A70: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B7A74: 4BCBB5E5  bl 0x82273058
	ctx.lr = 0x825B7A78;
	sub_82273058(ctx, base);
	// 825B7A78: 48000060  b 0x825b7ad8
	pc = 0x825B7AD8; continue 'dispatch;
            }
            0x825B7A7C => {
    //   block [0x825B7A7C..0x825B7ABC)
	// 825B7A7C: 4BC677DD  bl 0x8221f258
	ctx.lr = 0x825B7A80;
	sub_8221F258(ctx, base);
	// 825B7A80: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B7A84: 419A0038  beq cr6, 0x825b7abc
	if ctx.cr[6].eq {
	pc = 0x825B7ABC; continue 'dispatch;
	}
	// 825B7A88: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B7A8C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B7A90: 392B38C8  addi r9, r11, 0x38c8
	ctx.r[9].s64 = ctx.r[11].s64 + 14536;
	// 825B7A94: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B7A98: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7A9C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825B7AA0: 93630014  stw r27, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[27].u32 ) };
	// 825B7AA4: 93630018  stw r27, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[27].u32 ) };
	// 825B7AA8: 9363001C  stw r27, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 825B7AAC: 9B630021  stb r27, 0x21(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(33 as u32), ctx.r[27].u8 ) };
	// 825B7AB0: D3C30024  stfs f30, 0x24(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825B7AB4: 93630008  stw r27, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825B7AB8: 48000008  b 0x825b7ac0
	pc = 0x825B7AC0; continue 'dispatch;
            }
            0x825B7ABC => {
    //   block [0x825B7ABC..0x825B7AC0)
	// 825B7ABC: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	pc = 0x825B7AC0; continue 'dispatch;
            }
            0x825B7AC0 => {
    //   block [0x825B7AC0..0x825B7AD8)
	// 825B7AC0: 3B1D0074  addi r24, r29, 0x74
	ctx.r[24].s64 = ctx.r[29].s64 + 116;
	// 825B7AC4: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825B7AC8: 4BCBB591  bl 0x82273058
	ctx.lr = 0x825B7ACC;
	sub_82273058(ctx, base);
	// 825B7ACC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B7AD0: 807D0074  lwz r3, 0x74(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B7AD4: 485C40A5  bl 0x82b7bb78
	ctx.lr = 0x825B7AD8;
	sub_82B7BB78(ctx, base);
	pc = 0x825B7AD8; continue 'dispatch;
            }
            0x825B7AD8 => {
    //   block [0x825B7AD8..0x825B7B10)
	// 825B7AD8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7ADC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B7AE0: 554967FE  rlwinm r9, r10, 0xc, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x000FFFFFu64;
	// 825B7AE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B7AE8: 419A00D8  beq cr6, 0x825b7bc0
	if ctx.cr[6].eq {
	pc = 0x825B7BC0; continue 'dispatch;
	}
	// 825B7AEC: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B7AF0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7AF4: 419A001C  beq cr6, 0x825b7b10
	if ctx.cr[6].eq {
	pc = 0x825B7B10; continue 'dispatch;
	}
	// 825B7AF8: 892A0074  lbz r9, 0x74(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B7AFC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B7B00: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B7B04: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B7B08: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7B0C: 480000B0  b 0x825b7bbc
	pc = 0x825B7BBC; continue 'dispatch;
            }
            0x825B7B10 => {
    //   block [0x825B7B10..0x825B7B2C)
	// 825B7B10: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B7B14: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B7B18: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B7B1C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B7B20: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B7B24: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B7B28: 40810054  ble 0x825b7b7c
	if !ctx.cr[0].gt {
	pc = 0x825B7B7C; continue 'dispatch;
	}
	pc = 0x825B7B2C; continue 'dispatch;
            }
            0x825B7B2C => {
    //   block [0x825B7B2C..0x825B7B4C)
	// 825B7B2C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B7B30: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B7B34: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B7B38: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7B3C: 2F070074  cmpwi cr6, r7, 0x74
	ctx.cr[6].compare_i32(ctx.r[7].s32, 116, &mut ctx.xer);
	// 825B7B40: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B7B44: 41980008  blt cr6, 0x825b7b4c
	if ctx.cr[6].lt {
	pc = 0x825B7B4C; continue 'dispatch;
	}
	// 825B7B48: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	pc = 0x825B7B4C; continue 'dispatch;
            }
            0x825B7B4C => {
    //   block [0x825B7B4C..0x825B7B68)
	// 825B7B4C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B7B50: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B7B54: 419A0014  beq cr6, 0x825b7b68
	if ctx.cr[6].eq {
	pc = 0x825B7B68; continue 'dispatch;
	}
	// 825B7B58: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B7B5C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B7B60: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B7B64: 4800000C  b 0x825b7b70
	pc = 0x825B7B70; continue 'dispatch;
            }
            0x825B7B68 => {
    //   block [0x825B7B68..0x825B7B70)
	// 825B7B68: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B7B6C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B7B70; continue 'dispatch;
            }
            0x825B7B70 => {
    //   block [0x825B7B70..0x825B7B7C)
	// 825B7B70: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B7B74: 4199FFB8  bgt cr6, 0x825b7b2c
	if ctx.cr[6].gt {
	pc = 0x825B7B2C; continue 'dispatch;
	}
	// 825B7B78: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B7B7C; continue 'dispatch;
            }
            0x825B7B7C => {
    //   block [0x825B7B7C..0x825B7B98)
	// 825B7B7C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B7B80: 419A0034  beq cr6, 0x825b7bb4
	if ctx.cr[6].eq {
	pc = 0x825B7BB4; continue 'dispatch;
	}
	// 825B7B84: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7B88: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 825B7B8C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B7B90: 41990008  bgt cr6, 0x825b7b98
	if ctx.cr[6].gt {
	pc = 0x825B7B98; continue 'dispatch;
	}
	// 825B7B94: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	pc = 0x825B7B98; continue 'dispatch;
            }
            0x825B7B98 => {
    //   block [0x825B7B98..0x825B7BB4)
	// 825B7B98: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7B9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7BA0: 409A0014  bne cr6, 0x825b7bb4
	if !ctx.cr[6].eq {
	pc = 0x825B7BB4; continue 'dispatch;
	}
	// 825B7BA4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B7BA8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B7BAC: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B7BB0: 48000008  b 0x825b7bb8
	pc = 0x825B7BB8; continue 'dispatch;
            }
            0x825B7BB4 => {
    //   block [0x825B7BB4..0x825B7BB8)
	// 825B7BB4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825B7BB8; continue 'dispatch;
            }
            0x825B7BB8 => {
    //   block [0x825B7BB8..0x825B7BBC)
	// 825B7BB8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B7BBC; continue 'dispatch;
            }
            0x825B7BBC => {
    //   block [0x825B7BBC..0x825B7BC0)
	// 825B7BBC: 7D7B5B78  mr r27, r11
	ctx.r[27].u64 = ctx.r[11].u64;
	pc = 0x825B7BC0; continue 'dispatch;
            }
            0x825B7BC0 => {
    //   block [0x825B7BC0..0x825B7BD8)
	// 825B7BC0: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B7BC4: 3B9D0064  addi r28, r29, 0x64
	ctx.r[28].s64 = ctx.r[29].s64 + 100;
	// 825B7BC8: 815D006C  lwz r10, 0x6c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B7BCC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7BD0: 40990008  ble cr6, 0x825b7bd8
	if !ctx.cr[6].gt {
	pc = 0x825B7BD8; continue 'dispatch;
	}
	// 825B7BD4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7BD8; continue 'dispatch;
            }
            0x825B7BD8 => {
    //   block [0x825B7BD8..0x825B7BF8)
	// 825B7BD8: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B7BDC: C3F90000  lfs f31, 0(r25)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B7BE0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B7BE4: 3F40820A  lis r26, -0x7df6
	ctx.r[26].s64 = -2113273856;
	// 825B7BE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B7BEC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B7BF0: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7BF4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825B7BF8; continue 'dispatch;
            }
            0x825B7BF8 => {
    //   block [0x825B7BF8..0x825B7C0C)
	// 825B7BF8: 817C0008  lwz r11, 8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7BFC: 815C0004  lwz r10, 4(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7C00: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7C04: 40990008  ble cr6, 0x825b7c0c
	if !ctx.cr[6].gt {
	pc = 0x825B7C0C; continue 'dispatch;
	}
	// 825B7C08: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7C0C; continue 'dispatch;
            }
            0x825B7C0C => {
    //   block [0x825B7C0C..0x825B7C1C)
	// 825B7C0C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B7C10: 419A000C  beq cr6, 0x825b7c1c
	if ctx.cr[6].eq {
	pc = 0x825B7C1C; continue 'dispatch;
	}
	// 825B7C14: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B7C18: 419A0008  beq cr6, 0x825b7c20
	if ctx.cr[6].eq {
	pc = 0x825B7C20; continue 'dispatch;
	}
	pc = 0x825B7C1C; continue 'dispatch;
            }
            0x825B7C1C => {
    //   block [0x825B7C1C..0x825B7C20)
	// 825B7C1C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7C20; continue 'dispatch;
            }
            0x825B7C20 => {
    //   block [0x825B7C20..0x825B7C34)
	// 825B7C20: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7C24: 419A008C  beq cr6, 0x825b7cb0
	if ctx.cr[6].eq {
	pc = 0x825B7CB0; continue 'dispatch;
	}
	// 825B7C28: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B7C2C: 409A0008  bne cr6, 0x825b7c34
	if !ctx.cr[6].eq {
	pc = 0x825B7C34; continue 'dispatch;
	}
	// 825B7C30: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7C34; continue 'dispatch;
            }
            0x825B7C34 => {
    //   block [0x825B7C34..0x825B7C44)
	// 825B7C34: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7C38: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7C3C: 41980008  blt cr6, 0x825b7c44
	if ctx.cr[6].lt {
	pc = 0x825B7C44; continue 'dispatch;
	}
	// 825B7C40: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7C44; continue 'dispatch;
            }
            0x825B7C44 => {
    //   block [0x825B7C44..0x825B7C60)
	// 825B7C44: 83FE0000  lwz r31, 0(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7C48: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 825B7C4C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 825B7C50: 419A0010  beq cr6, 0x825b7c60
	if ctx.cr[6].eq {
	pc = 0x825B7C60; continue 'dispatch;
	}
	// 825B7C54: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B7C58: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B7C5C: 4BD223CD  bl 0x822da028
	ctx.lr = 0x825B7C60;
	sub_822DA028(ctx, base);
	pc = 0x825B7C60; continue 'dispatch;
            }
            0x825B7C60 => {
    //   block [0x825B7C60..0x825B7C70)
	// 825B7C60: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825B7C64: 409A000C  bne cr6, 0x825b7c70
	if !ctx.cr[6].eq {
	pc = 0x825B7C70; continue 'dispatch;
	}
	// 825B7C68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 825B7C6C: 48000010  b 0x825b7c7c
	pc = 0x825B7C7C; continue 'dispatch;
            }
            0x825B7C70 => {
    //   block [0x825B7C70..0x825B7C7C)
	// 825B7C70: C01A9A80  lfs f0, -0x6580(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(-25984 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B7C74: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 825B7C78: 40990020  ble cr6, 0x825b7c98
	if !ctx.cr[6].gt {
	pc = 0x825B7C98; continue 'dispatch;
	}
	pc = 0x825B7C7C; continue 'dispatch;
            }
            0x825B7C7C => {
    //   block [0x825B7C7C..0x825B7C8C)
	// 825B7C7C: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7C80: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7C84: 41980008  blt cr6, 0x825b7c8c
	if ctx.cr[6].lt {
	pc = 0x825B7C8C; continue 'dispatch;
	}
	// 825B7C88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7C8C; continue 'dispatch;
            }
            0x825B7C8C => {
    //   block [0x825B7C8C..0x825B7C98)
	// 825B7C8C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7C90: 80780000  lwz r3, 0(r24)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7C94: 485C3F4D  bl 0x82b7bbe0
	ctx.lr = 0x825B7C98;
	sub_82B7BBE0(ctx, base);
	pc = 0x825B7C98; continue 'dispatch;
            }
            0x825B7C98 => {
    //   block [0x825B7C98..0x825B7CA8)
	// 825B7C98: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7C9C: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7CA0: 41980008  blt cr6, 0x825b7ca8
	if ctx.cr[6].lt {
	pc = 0x825B7CA8; continue 'dispatch;
	}
	// 825B7CA4: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7CA8; continue 'dispatch;
            }
            0x825B7CA8 => {
    //   block [0x825B7CA8..0x825B7CB0)
	// 825B7CA8: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 825B7CAC: 4BFFFF4C  b 0x825b7bf8
	pc = 0x825B7BF8; continue 'dispatch;
            }
            0x825B7CB0 => {
    //   block [0x825B7CB0..0x825B7CC0)
	// 825B7CB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B7CB4: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825B7CB8: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 825B7CBC: 486F178C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B7CC0 size=124
    let mut pc: u32 = 0x825B7CC0;
    'dispatch: loop {
        match pc {
            0x825B7CC0 => {
    //   block [0x825B7CC0..0x825B7D14)
	// 825B7CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7CC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B7CC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B7CCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7CD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7CD4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B7CD8: 4BC226D9  bl 0x821da3b0
	ctx.lr = 0x825B7CDC;
	sub_821DA3B0(ctx, base);
	// 825B7CDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B7CE0: 38EB55A0  addi r7, r11, 0x55a0
	ctx.r[7].s64 = ctx.r[11].s64 + 21920;
	// 825B7CE4: 4BBFA815  bl 0x821b24f8
	ctx.lr = 0x825B7CE8;
	sub_821B24F8(ctx, base);
	// 825B7CE8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B7CEC: 4BD6B855  bl 0x82323540
	ctx.lr = 0x825B7CF0;
	sub_82323540(ctx, base);
	// 825B7CF0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7CF4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B7CF8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B7CFC: 4BC751D5  bl 0x8222ced0
	ctx.lr = 0x825B7D00;
	sub_8222CED0(ctx, base);
	// 825B7D00: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7D04: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B7D08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7D0C: 419A0008  beq cr6, 0x825b7d14
	if ctx.cr[6].eq {
	pc = 0x825B7D14; continue 'dispatch;
	}
	// 825B7D10: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825B7D14; continue 'dispatch;
            }
            0x825B7D14 => {
    //   block [0x825B7D14..0x825B7D3C)
	// 825B7D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B7D18: 4BC5D0C1  bl 0x82214dd8
	ctx.lr = 0x825B7D1C;
	sub_82214DD8(ctx, base);
	// 825B7D1C: 7FEB0034  cntlzw r11, r31
	ctx.r[11].u64 = if ctx.r[31].u32 == 0 { 32 } else { ctx.r[31].u32.leading_zeros() as u64 };
	// 825B7D20: 556ADFFE  rlwinm r10, r11, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 825B7D24: 69430001  xori r3, r10, 1
	ctx.r[3].u64 = ctx.r[10].u64 ^ 1;
	// 825B7D28: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B7D2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7D30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B7D34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B7D38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7D40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B7D40 size=280
    let mut pc: u32 = 0x825B7D40;
    'dispatch: loop {
        match pc {
            0x825B7D40 => {
    //   block [0x825B7D40..0x825B7D6C)
	// 825B7D40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7D44: 486F16C1  bl 0x82ca9404
	ctx.lr = 0x825B7D48;
	sub_82CA93D0(ctx, base);
	// 825B7D48: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7D4C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B7D50: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825B7D54: 3BBC0064  addi r29, r28, 0x64
	ctx.r[29].s64 = ctx.r[28].s64 + 100;
	// 825B7D58: 817C0068  lwz r11, 0x68(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B7D5C: 815C006C  lwz r10, 0x6c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B7D60: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7D64: 40990008  ble cr6, 0x825b7d6c
	if !ctx.cr[6].gt {
	pc = 0x825B7D6C; continue 'dispatch;
	}
	// 825B7D68: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7D6C; continue 'dispatch;
            }
            0x825B7D6C => {
    //   block [0x825B7D6C..0x825B7D74)
	// 825B7D6C: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 825B7D70: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	pc = 0x825B7D74; continue 'dispatch;
            }
            0x825B7D74 => {
    //   block [0x825B7D74..0x825B7D78)
	// 825B7D74: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	pc = 0x825B7D78; continue 'dispatch;
            }
            0x825B7D78 => {
    //   block [0x825B7D78..0x825B7D8C)
	// 825B7D78: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7D7C: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7D80: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7D84: 40990008  ble cr6, 0x825b7d8c
	if !ctx.cr[6].gt {
	pc = 0x825B7D8C; continue 'dispatch;
	}
	// 825B7D88: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7D8C; continue 'dispatch;
            }
            0x825B7D8C => {
    //   block [0x825B7D8C..0x825B7D9C)
	// 825B7D8C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B7D90: 419A000C  beq cr6, 0x825b7d9c
	if ctx.cr[6].eq {
	pc = 0x825B7D9C; continue 'dispatch;
	}
	// 825B7D94: 7F09E840  cmplw cr6, r9, r29
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B7D98: 419A0008  beq cr6, 0x825b7da0
	if ctx.cr[6].eq {
	pc = 0x825B7DA0; continue 'dispatch;
	}
	pc = 0x825B7D9C; continue 'dispatch;
            }
            0x825B7D9C => {
    //   block [0x825B7D9C..0x825B7DA0)
	// 825B7D9C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7DA0; continue 'dispatch;
            }
            0x825B7DA0 => {
    //   block [0x825B7DA0..0x825B7DB4)
	// 825B7DA0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7DA4: 419A0094  beq cr6, 0x825b7e38
	if ctx.cr[6].eq {
	pc = 0x825B7E38; continue 'dispatch;
	}
	// 825B7DA8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B7DAC: 409A0008  bne cr6, 0x825b7db4
	if !ctx.cr[6].eq {
	pc = 0x825B7DB4; continue 'dispatch;
	}
	// 825B7DB0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7DB4; continue 'dispatch;
            }
            0x825B7DB4 => {
    //   block [0x825B7DB4..0x825B7DC4)
	// 825B7DB4: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7DB8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7DBC: 41980008  blt cr6, 0x825b7dc4
	if ctx.cr[6].lt {
	pc = 0x825B7DC4; continue 'dispatch;
	}
	// 825B7DC0: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7DC4; continue 'dispatch;
            }
            0x825B7DC4 => {
    //   block [0x825B7DC4..0x825B7DF0)
	// 825B7DC4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7DC8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B7DCC: 409A0058  bne cr6, 0x825b7e24
	if !ctx.cr[6].eq {
	pc = 0x825B7E24; continue 'dispatch;
	}
	// 825B7DD0: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825B7DD4: 809D0008  lwz r4, 8(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7DD8: 386B000C  addi r3, r11, 0xc
	ctx.r[3].s64 = ctx.r[11].s64 + 12;
	// 825B7DDC: 4BF70275  bl 0x82528050
	ctx.lr = 0x825B7DE0;
	sub_82528050(ctx, base);
	// 825B7DE0: 83DD0008  lwz r30, 8(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7DE4: 3BFEFFF4  addi r31, r30, -0xc
	ctx.r[31].s64 = ctx.r[30].s64 + -12;
	// 825B7DE8: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B7DEC: 419A0018  beq cr6, 0x825b7e04
	if ctx.cr[6].eq {
	pc = 0x825B7E04; continue 'dispatch;
	}
	pc = 0x825B7DF0; continue 'dispatch;
            }
            0x825B7DF0 => {
    //   block [0x825B7DF0..0x825B7E04)
	// 825B7DF0: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825B7DF4: 4BBFFD25  bl 0x821b7b18
	ctx.lr = 0x825B7DF8;
	sub_821B7B18(ctx, base);
	// 825B7DF8: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 825B7DFC: 7F1FF040  cmplw cr6, r31, r30
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825B7E00: 409AFFF0  bne cr6, 0x825b7df0
	if !ctx.cr[6].eq {
	pc = 0x825B7DF0; continue 'dispatch;
	}
	pc = 0x825B7E04; continue 'dispatch;
            }
            0x825B7E04 => {
    //   block [0x825B7E04..0x825B7E24)
	// 825B7E04: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B7E08: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7E0C: 390BFFF4  addi r8, r11, -0xc
	ctx.r[8].s64 = ctx.r[11].s64 + -12;
	// 825B7E10: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825B7E14: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B7E18: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7E1C: 911D0008  stw r8, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825B7E20: 4BFFFF58  b 0x825b7d78
	pc = 0x825B7D78; continue 'dispatch;
            }
            0x825B7E24 => {
    //   block [0x825B7E24..0x825B7E30)
	// 825B7E24: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B7E28: 41980008  blt cr6, 0x825b7e30
	if ctx.cr[6].lt {
	pc = 0x825B7E30; continue 'dispatch;
	}
	// 825B7E2C: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B7E30; continue 'dispatch;
            }
            0x825B7E30 => {
    //   block [0x825B7E30..0x825B7E38)
	// 825B7E30: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825B7E34: 4BFFFF40  b 0x825b7d74
	pc = 0x825B7D74; continue 'dispatch;
            }
            0x825B7E38 => {
    //   block [0x825B7E38..0x825B7E58)
	// 825B7E38: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825B7E3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B7E40: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B7E44: 4BFFEC15  bl 0x825b6a58
	ctx.lr = 0x825B7E48;
	sub_825B6A58(ctx, base);
	// 825B7E48: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B7E4C: 48001215  bl 0x825b9060
	ctx.lr = 0x825B7E50;
	sub_825B9060(ctx, base);
	// 825B7E50: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B7E54: 486F1600  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7E58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B7E58 size=184
    let mut pc: u32 = 0x825B7E58;
    'dispatch: loop {
        match pc {
            0x825B7E58 => {
    //   block [0x825B7E58..0x825B7EA4)
	// 825B7E58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7E5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B7E60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B7E64: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7E68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B7E6C: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825B7E70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B7E74: 386B567C  addi r3, r11, 0x567c
	ctx.r[3].s64 = ctx.r[11].s64 + 22140;
	// 825B7E78: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825B7E7C: 4BC3BEDD  bl 0x821f3d58
	ctx.lr = 0x825B7E80;
	sub_821F3D58(ctx, base);
	// 825B7E80: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B7E84: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B7E88: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825B7E8C: 4844883D  bl 0x82a006c8
	ctx.lr = 0x825B7E90;
	sub_82A006C8(ctx, base);
	// 825B7E90: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B7E94: 419A0010  beq cr6, 0x825b7ea4
	if ctx.cr[6].eq {
	pc = 0x825B7EA4; continue 'dispatch;
	}
	// 825B7E98: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7E9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B7EA0: 4800000C  b 0x825b7eac
	pc = 0x825B7EAC; continue 'dispatch;
            }
            0x825B7EA4 => {
    //   block [0x825B7EA4..0x825B7EAC)
	// 825B7EA4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B7EA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B7EAC; continue 'dispatch;
            }
            0x825B7EAC => {
    //   block [0x825B7EAC..0x825B7ED8)
	// 825B7EAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B7EB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7EB4: 419A002C  beq cr6, 0x825b7ee0
	if ctx.cr[6].eq {
	pc = 0x825B7EE0; continue 'dispatch;
	}
	// 825B7EB8: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825B7EBC: 409A001C  bne cr6, 0x825b7ed8
	if !ctx.cr[6].eq {
	pc = 0x825B7ED8; continue 'dispatch;
	}
	// 825B7EC0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 825B7EC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B7EC8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7ECC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B7ED0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B7ED4: 4E800020  blr
	return;
            }
            0x825B7ED8 => {
    //   block [0x825B7ED8..0x825B7EE0)
	// 825B7ED8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825B7EDC: 409A001C  bne cr6, 0x825b7ef8
	if !ctx.cr[6].eq {
	pc = 0x825B7EF8; continue 'dispatch;
	}
	pc = 0x825B7EE0; continue 'dispatch;
            }
            0x825B7EE0 => {
    //   block [0x825B7EE0..0x825B7EF8)
	// 825B7EE0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B7EE4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B7EE8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7EEC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B7EF0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B7EF4: 4E800020  blr
	return;
            }
            0x825B7EF8 => {
    //   block [0x825B7EF8..0x825B7F10)
	// 825B7EF8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B7EFC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B7F00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7F04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B7F08: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B7F0C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B7F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B7F10 size=448
    let mut pc: u32 = 0x825B7F10;
    'dispatch: loop {
        match pc {
            0x825B7F10 => {
    //   block [0x825B7F10..0x825B7F40)
	// 825B7F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B7F14: 486F14F5  bl 0x82ca9408
	ctx.lr = 0x825B7F18;
	sub_82CA93D0(ctx, base);
	// 825B7F18: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B7F1C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B7F20: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B7F24: 3BDC0038  addi r30, r28, 0x38
	ctx.r[30].s64 = ctx.r[28].s64 + 56;
	// 825B7F28: 817C0040  lwz r11, 0x40(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B7F2C: 815C003C  lwz r10, 0x3c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B7F30: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B7F34: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B7F38: 41820034  beq 0x825b7f6c
	if ctx.cr[0].eq {
	pc = 0x825B7F6C; continue 'dispatch;
	}
	// 825B7F3C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x825B7F40; continue 'dispatch;
            }
            0x825B7F40 => {
    //   block [0x825B7F40..0x825B7F6C)
	// 825B7F40: 817C003C  lwz r11, 0x3c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B7F44: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825B7F48: 4BC36371  bl 0x821ee2b8
	ctx.lr = 0x825B7F4C;
	sub_821EE2B8(ctx, base);
	// 825B7F4C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7F50: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7F54: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B7F58: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B7F5C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B7F60: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825B7F64: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B7F68: 4198FFD8  blt cr6, 0x825b7f40
	if ctx.cr[6].lt {
	pc = 0x825B7F40; continue 'dispatch;
	}
	pc = 0x825B7F6C; continue 'dispatch;
            }
            0x825B7F6C => {
    //   block [0x825B7F6C..0x825B7F9C)
	// 825B7F6C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7F70: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B7F74: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7F78: 419A003C  beq cr6, 0x825b7fb4
	if ctx.cr[6].eq {
	pc = 0x825B7FB4; continue 'dispatch;
	}
	// 825B7F7C: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B7F80: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B7F84: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B7F88: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7F8C: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B7F90: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B7F94: 419A001C  beq cr6, 0x825b7fb0
	if ctx.cr[6].eq {
	pc = 0x825B7FB0; continue 'dispatch;
	}
	// 825B7F98: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B7F9C; continue 'dispatch;
            }
            0x825B7F9C => {
    //   block [0x825B7F9C..0x825B7FB0)
	// 825B7F9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7FA0: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 825B7FA4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B7FA8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B7FAC: 409AFFF0  bne cr6, 0x825b7f9c
	if !ctx.cr[6].eq {
	pc = 0x825B7F9C; continue 'dispatch;
	}
	pc = 0x825B7FB0; continue 'dispatch;
            }
            0x825B7FB0 => {
    //   block [0x825B7FB0..0x825B7FB4)
	// 825B7FB0: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B7FB4; continue 'dispatch;
            }
            0x825B7FB4 => {
    //   block [0x825B7FB4..0x825B7FF4)
	// 825B7FB4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B7FB8: 83FCFFF8  lwz r31, -8(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B7FBC: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B7FC0: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B7FC4: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B7FC8: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B7FCC: 81680000  lwz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7FD0: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825B7FD4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B7FD8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B7FDC: 419A001C  beq cr6, 0x825b7ff8
	if ctx.cr[6].eq {
	pc = 0x825B7FF8; continue 'dispatch;
	}
	// 825B7FE0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B7FE4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B7FE8: 419A000C  beq cr6, 0x825b7ff4
	if ctx.cr[6].eq {
	pc = 0x825B7FF4; continue 'dispatch;
	}
	// 825B7FEC: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B7FF0: 4800000C  b 0x825b7ffc
	pc = 0x825B7FFC; continue 'dispatch;
            }
            0x825B7FF4 => {
    //   block [0x825B7FF4..0x825B7FF8)
	// 825B7FF4: 4BBDBE45  bl 0x82193e38
	ctx.lr = 0x825B7FF8;
	sub_82193E38(ctx, base);
	pc = 0x825B7FF8; continue 'dispatch;
            }
            0x825B7FF8 => {
    //   block [0x825B7FF8..0x825B7FFC)
	// 825B7FF8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B7FFC; continue 'dispatch;
            }
            0x825B7FFC => {
    //   block [0x825B7FFC..0x825B8020)
	// 825B7FFC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8000: 419A0020  beq cr6, 0x825b8020
	if ctx.cr[6].eq {
	pc = 0x825B8020; continue 'dispatch;
	}
	// 825B8004: 817CFFF8  lwz r11, -8(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B8008: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B800C: 5549FFFE  rlwinm r9, r10, 0x1f, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 825B8010: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B8014: 409A000C  bne cr6, 0x825b8020
	if !ctx.cr[6].eq {
	pc = 0x825B8020; continue 'dispatch;
	}
	// 825B8018: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B801C: 997C00A7  stb r11, 0xa7(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(167 as u32), ctx.r[11].u8 ) };
	pc = 0x825B8020; continue 'dispatch;
            }
            0x825B8020 => {
    //   block [0x825B8020..0x825B804C)
	// 825B8020: 897C00A7  lbz r11, 0xa7(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(167 as u32) ) } as u64;
	// 825B8024: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8028: 419A00A0  beq cr6, 0x825b80c8
	if ctx.cr[6].eq {
	pc = 0x825B80C8; continue 'dispatch;
	}
	// 825B802C: 817C0050  lwz r11, 0x50(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B8030: 3BDC0048  addi r30, r28, 0x48
	ctx.r[30].s64 = ctx.r[28].s64 + 72;
	// 825B8034: 815C004C  lwz r10, 0x4c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8038: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B803C: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B8040: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B8044: 41820034  beq 0x825b8078
	if ctx.cr[0].eq {
	pc = 0x825B8078; continue 'dispatch;
	}
	// 825B8048: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x825B804C; continue 'dispatch;
            }
            0x825B804C => {
    //   block [0x825B804C..0x825B8078)
	// 825B804C: 817C004C  lwz r11, 0x4c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8050: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825B8054: 4BC36265  bl 0x821ee2b8
	ctx.lr = 0x825B8058;
	sub_821EE2B8(ctx, base);
	// 825B8058: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B805C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8060: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B8064: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825B8068: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B806C: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825B8070: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B8074: 4198FFD8  blt cr6, 0x825b804c
	if ctx.cr[6].lt {
	pc = 0x825B804C; continue 'dispatch;
	}
	pc = 0x825B8078; continue 'dispatch;
            }
            0x825B8078 => {
    //   block [0x825B8078..0x825B80A8)
	// 825B8078: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B807C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8080: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8084: 419A003C  beq cr6, 0x825b80c0
	if ctx.cr[6].eq {
	pc = 0x825B80C0; continue 'dispatch;
	}
	// 825B8088: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B808C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B8090: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B8094: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8098: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B809C: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B80A0: 419A001C  beq cr6, 0x825b80bc
	if ctx.cr[6].eq {
	pc = 0x825B80BC; continue 'dispatch;
	}
	// 825B80A4: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B80A8; continue 'dispatch;
            }
            0x825B80A8 => {
    //   block [0x825B80A8..0x825B80BC)
	// 825B80A8: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B80AC: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 825B80B0: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B80B4: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B80B8: 409AFFF0  bne cr6, 0x825b80a8
	if !ctx.cr[6].eq {
	pc = 0x825B80A8; continue 'dispatch;
	}
	pc = 0x825B80BC; continue 'dispatch;
            }
            0x825B80BC => {
    //   block [0x825B80BC..0x825B80C0)
	// 825B80BC: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B80C0; continue 'dispatch;
            }
            0x825B80C0 => {
    //   block [0x825B80C0..0x825B80C8)
	// 825B80C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B80C4: 997C00A7  stb r11, 0xa7(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(167 as u32), ctx.r[11].u8 ) };
	pc = 0x825B80C8; continue 'dispatch;
            }
            0x825B80C8 => {
    //   block [0x825B80C8..0x825B80D0)
	// 825B80C8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B80CC: 486F138C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B80D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B80D0 size=112
    let mut pc: u32 = 0x825B80D0;
    'dispatch: loop {
        match pc {
            0x825B80D0 => {
    //   block [0x825B80D0..0x825B8108)
	// 825B80D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B80D4: 486F132D  bl 0x82ca9400
	ctx.lr = 0x825B80D8;
	sub_82CA93D0(ctx, base);
	// 825B80D8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B80DC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B80E0: 3B400018  li r26, 0x18
	ctx.r[26].s64 = 24;
	// 825B80E4: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825B80E8: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 825B80EC: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B80F0: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B80F4: 815C002C  lwz r10, 0x2c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B80F8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B80FC: 7D09D3D7  divw. r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B8100: 41820038  beq 0x825b8138
	if ctx.cr[0].eq {
	pc = 0x825B8138; continue 'dispatch;
	}
	// 825B8104: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825B8108; continue 'dispatch;
            }
            0x825B8108 => {
    //   block [0x825B8108..0x825B8138)
	// 825B8108: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B810C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825B8110: 7C8BEA14  add r4, r11, r29
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825B8114: 4BFC7315  bl 0x8257f428
	ctx.lr = 0x825B8118;
	sub_8257F428(ctx, base);
	// 825B8118: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B811C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8120: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B8124: 3BBD0018  addi r29, r29, 0x18
	ctx.r[29].s64 = ctx.r[29].s64 + 24;
	// 825B8128: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B812C: 7D09D3D6  divw r8, r9, r26
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825B8130: 7F1E4040  cmplw cr6, r30, r8
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B8134: 4198FFD4  blt cr6, 0x825b8108
	if ctx.cr[6].lt {
	pc = 0x825B8108; continue 'dispatch;
	}
	pc = 0x825B8138; continue 'dispatch;
            }
            0x825B8138 => {
    //   block [0x825B8138..0x825B8140)
	// 825B8138: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B813C: 486F1314  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8140 size=340
    let mut pc: u32 = 0x825B8140;
    'dispatch: loop {
        match pc {
            0x825B8140 => {
    //   block [0x825B8140..0x825B818C)
	// 825B8140: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8144: 486F12B1  bl 0x82ca93f4
	ctx.lr = 0x825B8148;
	sub_82CA93D0(ctx, base);
	// 825B8148: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B814C: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B8150: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B8154: 3B000018  li r24, 0x18
	ctx.r[24].s64 = 24;
	// 825B8158: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825B815C: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825B8160: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B8164: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 825B8168: 815C0030  lwz r10, 0x30(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B816C: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 825B8170: 813C002C  lwz r9, 0x2c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B8174: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825B8178: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B817C: 7CE8C3D7  divw. r7, r8, r24
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B8180: 83460070  lwz r26, 0x70(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B8184: 418200B0  beq 0x825b8234
	if ctx.cr[0].eq {
	pc = 0x825B8234; continue 'dispatch;
	}
	// 825B8188: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	pc = 0x825B818C; continue 'dispatch;
            }
            0x825B818C => {
    //   block [0x825B818C..0x825B81CC)
	// 825B818C: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 825B8190: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B8194: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B8198: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B819C: 7C9E5A14  add r4, r30, r11
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825B81A0: 4BC87059  bl 0x8223f1f8
	ctx.lr = 0x825B81A4;
	sub_8223F1F8(ctx, base);
	// 825B81A4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B81A8: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B81AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B81B0: 419A001C  beq cr6, 0x825b81cc
	if ctx.cr[6].eq {
	pc = 0x825B81CC; continue 'dispatch;
	}
	// 825B81B4: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B81B8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B81BC: 48303FE5  bl 0x828bc1a0
	ctx.lr = 0x825B81C0;
	sub_828BC1A0(ctx, base);
	// 825B81C0: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B81C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B81C8: 409A0078  bne cr6, 0x825b8240
	if !ctx.cr[6].eq {
	pc = 0x825B8240; continue 'dispatch;
	}
	pc = 0x825B81CC; continue 'dispatch;
            }
            0x825B81CC => {
    //   block [0x825B81CC..0x825B81D8)
	// 825B81CC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B81D0: 419A0044  beq cr6, 0x825b8214
	if ctx.cr[6].eq {
	pc = 0x825B8214; continue 'dispatch;
	}
	// 825B81D4: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	pc = 0x825B81D8; continue 'dispatch;
            }
            0x825B81D8 => {
    //   block [0x825B81D8..0x825B8214)
	// 825B81D8: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825B81DC: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B81E0: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825B81E4: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825B81E8: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B81EC: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B81F0: 4082FFE8  bne 0x825b81d8
	if !ctx.cr[0].eq {
	pc = 0x825B81D8; continue 'dispatch;
	}
	// 825B81F4: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B81F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B81FC: 409A0018  bne cr6, 0x825b8214
	if !ctx.cr[6].eq {
	pc = 0x825B8214; continue 'dispatch;
	}
	// 825B8200: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8204: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8208: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B820C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B8210: 4E800421  bctrl
	ctx.lr = 0x825B8214;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B8214 => {
    //   block [0x825B8214..0x825B8234)
	// 825B8214: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8218: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825B821C: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8220: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 825B8224: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B8228: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 825B822C: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B8230: 4198FF5C  blt cr6, 0x825b818c
	if ctx.cr[6].lt {
	pc = 0x825B818C; continue 'dispatch;
	}
	pc = 0x825B8234; continue 'dispatch;
            }
            0x825B8234 => {
    //   block [0x825B8234..0x825B8240)
	// 825B8234: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B8238: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B823C: 486F1208  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B8240 => {
    //   block [0x825B8240..0x825B824C)
	// 825B8240: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B8244: 419A0044  beq cr6, 0x825b8288
	if ctx.cr[6].eq {
	pc = 0x825B8288; continue 'dispatch;
	}
	// 825B8248: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	pc = 0x825B824C; continue 'dispatch;
            }
            0x825B824C => {
    //   block [0x825B824C..0x825B8288)
	// 825B824C: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825B8250: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B8254: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825B8258: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825B825C: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B8260: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B8264: 4082FFE8  bne 0x825b824c
	if !ctx.cr[0].eq {
	pc = 0x825B824C; continue 'dispatch;
	}
	// 825B8268: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B826C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8270: 409A0018  bne cr6, 0x825b8288
	if !ctx.cr[6].eq {
	pc = 0x825B8288; continue 'dispatch;
	}
	// 825B8274: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8278: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B827C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8280: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B8284: 4E800421  bctrl
	ctx.lr = 0x825B8288;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B8288 => {
    //   block [0x825B8288..0x825B8294)
	// 825B8288: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B828C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B8290: 486F11B4  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8298 size=240
    let mut pc: u32 = 0x825B8298;
    'dispatch: loop {
        match pc {
            0x825B8298 => {
    //   block [0x825B8298..0x825B82E4)
	// 825B8298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B829C: 486F1159  bl 0x82ca93f4
	ctx.lr = 0x825B82A0;
	sub_82CA93D0(ctx, base);
	// 825B82A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B82A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B82A8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B82AC: 3B000018  li r24, 0x18
	ctx.r[24].s64 = 24;
	// 825B82B0: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825B82B4: 7C972378  mr r23, r4
	ctx.r[23].u64 = ctx.r[4].u64;
	// 825B82B8: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B82BC: 3BFC0028  addi r31, r28, 0x28
	ctx.r[31].s64 = ctx.r[28].s64 + 40;
	// 825B82C0: 815C0030  lwz r10, 0x30(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B82C4: 7F3BCB78  mr r27, r25
	ctx.r[27].u64 = ctx.r[25].u64;
	// 825B82C8: 813C002C  lwz r9, 0x2c(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B82CC: 7D095050  subf r8, r9, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825B82D0: 80CB000C  lwz r6, 0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B82D4: 7CE8C3D7  divw. r7, r8, r24
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B82D8: 83460070  lwz r26, 0x70(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(112 as u32) ) } as u64;
	// 825B82DC: 418200A4  beq 0x825b8380
	if ctx.cr[0].eq {
	pc = 0x825B8380; continue 'dispatch;
	}
	// 825B82E0: 7F3ECB78  mr r30, r25
	ctx.r[30].u64 = ctx.r[25].u64;
	pc = 0x825B82E4; continue 'dispatch;
            }
            0x825B82E4 => {
    //   block [0x825B82E4..0x825B8318)
	// 825B82E4: 93210050  stw r25, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[25].u32 ) };
	// 825B82E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B82EC: 817C002C  lwz r11, 0x2c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B82F0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B82F4: 7C8BF214  add r4, r11, r30
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B82F8: 4BC86F01  bl 0x8223f1f8
	ctx.lr = 0x825B82FC;
	sub_8223F1F8(ctx, base);
	// 825B82FC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B8300: 83A10050  lwz r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B8304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8308: 419A0010  beq cr6, 0x825b8318
	if ctx.cr[6].eq {
	pc = 0x825B8318; continue 'dispatch;
	}
	// 825B830C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 825B8310: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8314: 48303F05  bl 0x828bc218
	ctx.lr = 0x825B8318;
	sub_828BC218(ctx, base);
	pc = 0x825B8318; continue 'dispatch;
            }
            0x825B8318 => {
    //   block [0x825B8318..0x825B8324)
	// 825B8318: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B831C: 419A0044  beq cr6, 0x825b8360
	if ctx.cr[6].eq {
	pc = 0x825B8360; continue 'dispatch;
	}
	// 825B8320: 397D0004  addi r11, r29, 4
	ctx.r[11].s64 = ctx.r[29].s64 + 4;
	pc = 0x825B8324; continue 'dispatch;
            }
            0x825B8324 => {
    //   block [0x825B8324..0x825B8360)
	// 825B8324: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825B8328: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B832C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825B8330: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 825B8334: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B8338: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B833C: 4082FFE8  bne 0x825b8324
	if !ctx.cr[0].eq {
	pc = 0x825B8324; continue 'dispatch;
	}
	// 825B8340: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825B8344: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8348: 409A0018  bne cr6, 0x825b8360
	if !ctx.cr[6].eq {
	pc = 0x825B8360; continue 'dispatch;
	}
	// 825B834C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8350: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8354: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8358: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 825B835C: 4E800421  bctrl
	ctx.lr = 0x825B8360;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825B8360 => {
    //   block [0x825B8360..0x825B8380)
	// 825B8360: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8364: 3B7B0001  addi r27, r27, 1
	ctx.r[27].s64 = ctx.r[27].s64 + 1;
	// 825B8368: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B836C: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 825B8370: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B8374: 7D09C3D6  divw r8, r9, r24
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	// 825B8378: 7F1B4040  cmplw cr6, r27, r8
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B837C: 4198FF68  blt cr6, 0x825b82e4
	if ctx.cr[6].lt {
	pc = 0x825B82E4; continue 'dispatch;
	}
	pc = 0x825B8380; continue 'dispatch;
            }
            0x825B8380 => {
    //   block [0x825B8380..0x825B8388)
	// 825B8380: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825B8384: 486F10C0  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8388(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8388 size=148
    let mut pc: u32 = 0x825B8388;
    'dispatch: loop {
        match pc {
            0x825B8388 => {
    //   block [0x825B8388..0x825B83CC)
	// 825B8388: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B838C: 486F1071  bl 0x82ca93fc
	ctx.lr = 0x825B8390;
	sub_82CA93D0(ctx, base);
	// 825B8390: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8394: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B8398: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825B839C: 3BFA0038  addi r31, r26, 0x38
	ctx.r[31].s64 = ctx.r[26].s64 + 56;
	// 825B83A0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B83A4: 817A0040  lwz r11, 0x40(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(64 as u32) ) } as u64;
	// 825B83A8: 815A003C  lwz r10, 0x3c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B83AC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B83B0: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B83B4: 41820060  beq 0x825b8414
	if ctx.cr[0].eq {
	pc = 0x825B8414; continue 'dispatch;
	}
	// 825B83B8: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 825B83BC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825B83C0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B83C4: 3B8A44B0  addi r28, r10, 0x44b0
	ctx.r[28].s64 = ctx.r[10].s64 + 17584;
	// 825B83C8: 3B6B113C  addi r27, r11, 0x113c
	ctx.r[27].s64 = ctx.r[11].s64 + 4412;
	pc = 0x825B83CC; continue 'dispatch;
            }
            0x825B83CC => {
    //   block [0x825B83CC..0x825B83F4)
	// 825B83CC: 817A003C  lwz r11, 0x3c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(60 as u32) ) } as u64;
	// 825B83D0: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825B83D4: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 825B83D8: 419A001C  beq cr6, 0x825b83f4
	if ctx.cr[6].eq {
	pc = 0x825B83F4; continue 'dispatch;
	}
	// 825B83DC: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 825B83E0: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B83E4: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825B83E8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B83EC: 4BC726DD  bl 0x8222aac8
	ctx.lr = 0x825B83F0;
	sub_8222AAC8(ctx, base);
	// 825B83F0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x825B83F4; continue 'dispatch;
            }
            0x825B83F4 => {
    //   block [0x825B83F4..0x825B8414)
	// 825B83F4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B83F8: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B83FC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8400: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825B8404: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B8408: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825B840C: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B8410: 4198FFBC  blt cr6, 0x825b83cc
	if ctx.cr[6].lt {
	pc = 0x825B83CC; continue 'dispatch;
	}
	pc = 0x825B8414; continue 'dispatch;
            }
            0x825B8414 => {
    //   block [0x825B8414..0x825B841C)
	// 825B8414: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B8418: 486F1034  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8420(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B8420 size=1164
    let mut pc: u32 = 0x825B8420;
    'dispatch: loop {
        match pc {
            0x825B8420 => {
    //   block [0x825B8420..0x825B84B4)
	// 825B8420: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8424: 486F0FAD  bl 0x82ca93d0
	ctx.lr = 0x825B8428;
	sub_82CA93D0(ctx, base);
	// 825B8428: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825B842C: 9421FE80  stwu r1, -0x180(r1)
	ea = ctx.r[1].u32.wrapping_add(-384 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8430: 39C00000  li r14, 0
	ctx.r[14].s64 = 0;
	// 825B8434: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B8438: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 825B843C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B8440: 93C10194  stw r30, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[30].u32 ) };
	// 825B8444: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B8448: 9BE10050  stb r31, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u8 ) };
	// 825B844C: 4BC21F65  bl 0x821da3b0
	ctx.lr = 0x825B8450;
	sub_821DA3B0(ctx, base);
	// 825B8450: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B8454: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 825B8458: 38EB3F9C  addi r7, r11, 0x3f9c
	ctx.r[7].s64 = ctx.r[11].s64 + 16284;
	// 825B845C: 4BBFA09D  bl 0x821b24f8
	ctx.lr = 0x825B8460;
	sub_821B24F8(ctx, base);
	// 825B8460: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B8464: 4BCF1585  bl 0x822a99e8
	ctx.lr = 0x825B8468;
	sub_822A99E8(ctx, base);
	// 825B8468: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B846C: 419A0430  beq cr6, 0x825b889c
	if ctx.cr[6].eq {
	pc = 0x825B889C; continue 'dispatch;
	}
	// 825B8470: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8474: 7DCA7378  mr r10, r14
	ctx.r[10].u64 = ctx.r[14].u64;
	// 825B8478: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 825B847C: 552867FE  rlwinm r8, r9, 0xc, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x000FFFFFu64;
	// 825B8480: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825B8484: 419A00F4  beq cr6, 0x825b8578
	if ctx.cr[6].eq {
	pc = 0x825B8578; continue 'dispatch;
	}
	// 825B8488: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B848C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B8490: 419A0024  beq cr6, 0x825b84b4
	if ctx.cr[6].eq {
	pc = 0x825B84B4; continue 'dispatch;
	}
	// 825B8494: 894A0074  lbz r10, 0x74(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B8498: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B849C: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B84A0: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B84A4: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B84A8: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B84AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B84B0: 480000CC  b 0x825b857c
	pc = 0x825B857C; continue 'dispatch;
            }
            0x825B84B4 => {
    //   block [0x825B84B4..0x825B84D0)
	// 825B84B4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B84B8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B84BC: 91C10078  stw r14, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[14].u32 ) };
	// 825B84C0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B84C4: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	// 825B84C8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B84CC: 40810054  ble 0x825b8520
	if !ctx.cr[0].gt {
	pc = 0x825B8520; continue 'dispatch;
	}
	pc = 0x825B84D0; continue 'dispatch;
            }
            0x825B84D0 => {
    //   block [0x825B84D0..0x825B84F0)
	// 825B84D0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B84D4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B84D8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B84DC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B84E0: 2F070074  cmpwi cr6, r7, 0x74
	ctx.cr[6].compare_i32(ctx.r[7].s32, 116, &mut ctx.xer);
	// 825B84E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B84E8: 41980008  blt cr6, 0x825b84f0
	if ctx.cr[6].lt {
	pc = 0x825B84F0; continue 'dispatch;
	}
	// 825B84EC: 7DC77378  mr r7, r14
	ctx.r[7].u64 = ctx.r[14].u64;
	pc = 0x825B84F0; continue 'dispatch;
            }
            0x825B84F0 => {
    //   block [0x825B84F0..0x825B850C)
	// 825B84F0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B84F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B84F8: 419A0014  beq cr6, 0x825b850c
	if ctx.cr[6].eq {
	pc = 0x825B850C; continue 'dispatch;
	}
	// 825B84FC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B8500: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B8504: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B8508: 4800000C  b 0x825b8514
	pc = 0x825B8514; continue 'dispatch;
            }
            0x825B850C => {
    //   block [0x825B850C..0x825B8514)
	// 825B850C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B8510: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B8514; continue 'dispatch;
            }
            0x825B8514 => {
    //   block [0x825B8514..0x825B8520)
	// 825B8514: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8518: 4199FFB8  bgt cr6, 0x825b84d0
	if ctx.cr[6].gt {
	pc = 0x825B84D0; continue 'dispatch;
	}
	// 825B851C: 9141007C  stw r10, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[10].u32 ) };
	pc = 0x825B8520; continue 'dispatch;
            }
            0x825B8520 => {
    //   block [0x825B8520..0x825B853C)
	// 825B8520: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B8524: 419A0040  beq cr6, 0x825b8564
	if ctx.cr[6].eq {
	pc = 0x825B8564; continue 'dispatch;
	}
	// 825B8528: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B852C: 2F0B0074  cmpwi cr6, r11, 0x74
	ctx.cr[6].compare_i32(ctx.r[11].s32, 116, &mut ctx.xer);
	// 825B8530: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8534: 41990008  bgt cr6, 0x825b853c
	if ctx.cr[6].gt {
	pc = 0x825B853C; continue 'dispatch;
	}
	// 825B8538: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	pc = 0x825B853C; continue 'dispatch;
            }
            0x825B853C => {
    //   block [0x825B853C..0x825B8564)
	// 825B853C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8540: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8544: 409A0020  bne cr6, 0x825b8564
	if !ctx.cr[6].eq {
	pc = 0x825B8564; continue 'dispatch;
	}
	// 825B8548: E9610078  ld r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 825B854C: F9610078  std r11, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[11].u64 ) };
	// 825B8550: 8161007C  lwz r11, 0x7c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(124 as u32) ) } as u64;
	// 825B8554: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8558: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B855C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8560: 4800001C  b 0x825b857c
	pc = 0x825B857C; continue 'dispatch;
            }
            0x825B8564 => {
    //   block [0x825B8564..0x825B8578)
	// 825B8564: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B8568: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B856C: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B8570: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8574: 48000008  b 0x825b857c
	pc = 0x825B857C; continue 'dispatch;
            }
            0x825B8578 => {
    //   block [0x825B8578..0x825B857C)
	// 825B8578: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	pc = 0x825B857C; continue 'dispatch;
            }
            0x825B857C => {
    //   block [0x825B857C..0x825B8634)
	// 825B857C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8580: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8584: 419A0318  beq cr6, 0x825b889c
	if ctx.cr[6].eq {
	pc = 0x825B889C; continue 'dispatch;
	}
	// 825B8588: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 825B858C: 39E0000C  li r15, 0xc
	ctx.r[15].s64 = 12;
	// 825B8590: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B8594: 3B6A0014  addi r27, r10, 0x14
	ctx.r[27].s64 = ctx.r[10].s64 + 20;
	// 825B8598: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B859C: 7CE87BD7  divw. r7, r8, r15
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[15].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B85A0: 418202FC  beq 0x825b889c
	if ctx.cr[0].eq {
	pc = 0x825B889C; continue 'dispatch;
	}
	// 825B85A4: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B85A8: 91C1009C  stw r14, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[14].u32 ) };
	// 825B85AC: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 825B85B0: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 825B85B4: 90C10054  stw r6, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[6].u32 ) };
	// 825B85B8: 3CC0820A  lis r6, -0x7df6
	ctx.r[6].s64 = -2113273856;
	// 825B85BC: 39200400  li r9, 0x400
	ctx.r[9].s64 = 1024;
	// 825B85C0: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825B85C4: 80EB6DA0  lwz r7, 0x6da0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B85C8: 3D000002  lis r8, 2
	ctx.r[8].s64 = 131072;
	// 825B85CC: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825B85D0: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	// 825B85D4: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 825B85D8: 7DDC7378  mr r28, r14
	ctx.r[28].u64 = ctx.r[14].u64;
	// 825B85DC: C3E69490  lfs f31, -0x6b70(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825B85E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B85E4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B85E8: 93C10094  stw r30, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[30].u32 ) };
	// 825B85EC: 90E10058  stw r7, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[7].u32 ) };
	// 825B85F0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B85F4: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825B85F8: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	// 825B85FC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825B8600: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825B8604: 3CA0820C  lis r5, -0x7df4
	ctx.r[5].s64 = -2113142784;
	// 825B8608: 3C80820C  lis r4, -0x7df4
	ctx.r[4].s64 = -2113142784;
	// 825B860C: 3A410080  addi r18, r1, 0x80
	ctx.r[18].s64 = ctx.r[1].s64 + 128;
	// 825B8610: 3B200018  li r25, 0x18
	ctx.r[25].s64 = 24;
	// 825B8614: 3A2B57A4  addi r17, r11, 0x57a4
	ctx.r[17].s64 = ctx.r[11].s64 + 22436;
	// 825B8618: 3B0A56D4  addi r24, r10, 0x56d4
	ctx.r[24].s64 = ctx.r[10].s64 + 22228;
	// 825B861C: 3AE956BC  addi r23, r9, 0x56bc
	ctx.r[23].s64 = ctx.r[9].s64 + 22204;
	// 825B8620: 3AC856A8  addi r22, r8, 0x56a8
	ctx.r[22].s64 = ctx.r[8].s64 + 22184;
	// 825B8624: 3AA75698  addi r21, r7, 0x5698
	ctx.r[21].s64 = ctx.r[7].s64 + 22168;
	// 825B8628: 3A865688  addi r20, r6, 0x5688
	ctx.r[20].s64 = ctx.r[6].s64 + 22152;
	// 825B862C: 3A6555FC  addi r19, r5, 0x55fc
	ctx.r[19].s64 = ctx.r[5].s64 + 22012;
	// 825B8630: 3A045548  addi r16, r4, 0x5548
	ctx.r[16].s64 = ctx.r[4].s64 + 21832;
	pc = 0x825B8634; continue 'dispatch;
            }
            0x825B8634 => {
    //   block [0x825B8634..0x825B8648)
	// 825B8634: 7DDA7378  mr r26, r14
	ctx.r[26].u64 = ctx.r[14].u64;
	// 825B8638: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B863C: 419A000C  beq cr6, 0x825b8648
	if ctx.cr[6].eq {
	pc = 0x825B8648; continue 'dispatch;
	}
	// 825B8640: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 825B8644: 93810098  stw r28, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[28].u32 ) };
	pc = 0x825B8648; continue 'dispatch;
            }
            0x825B8648 => {
    //   block [0x825B8648..0x825B8668)
	// 825B8648: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B864C: 7DDD7378  mr r29, r14
	ctx.r[29].u64 = ctx.r[14].u64;
	// 825B8650: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8654: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B8658: 7D097BD7  divw. r8, r9, r15
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[15].s32;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B865C: 4182012C  beq 0x825b8788
	if ctx.cr[0].eq {
	pc = 0x825B8788; continue 'dispatch;
	}
	// 825B8660: 83920000  lwz r28, 0(r18)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8664: 7DDE7378  mr r30, r14
	ctx.r[30].u64 = ctx.r[14].u64;
	pc = 0x825B8668; continue 'dispatch;
            }
            0x825B8668 => {
    //   block [0x825B8668..0x825B8708)
	// 825B8668: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825B866C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8670: 7D49E038  and r9, r10, r28
	ctx.r[9].u64 = ctx.r[10].u64 & ctx.r[28].u64;
	// 825B8674: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B8678: 419A00E8  beq cr6, 0x825b8760
	if ctx.cr[6].eq {
	pc = 0x825B8760; continue 'dispatch;
	}
	// 825B867C: 80610058  lwz r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8680: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8684: 4BC2BBCD  bl 0x821e4250
	ctx.lr = 0x825B8688;
	sub_821E4250(ctx, base);
	// 825B8688: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B868C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825B8690: 419A00D0  beq cr6, 0x825b8760
	if ctx.cr[6].eq {
	pc = 0x825B8760; continue 'dispatch;
	}
	// 825B8694: 7E058378  mr r5, r16
	ctx.r[5].u64 = ctx.r[16].u64;
	// 825B8698: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B869C: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 825B86A0: 481CAD79  bl 0x82783418
	ctx.lr = 0x825B86A4;
	sub_82783418(ctx, base);
	// 825B86A4: 83430000  lwz r26, 0(r3)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B86A8: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825B86AC: 419A00B4  beq cr6, 0x825b8760
	if ctx.cr[6].eq {
	pc = 0x825B8760; continue 'dispatch;
	}
	// 825B86B0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B86B4: D3E100A0  stfs f31, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 825B86B8: 91C100B0  stw r14, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[14].u32 ) };
	// 825B86BC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B86C0: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825B86C4: 894B0008  lbz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B86C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B86CC: 419A003C  beq cr6, 0x825b8708
	if ctx.cr[6].eq {
	pc = 0x825B8708; continue 'dispatch;
	}
	// 825B86D0: 7E659B78  mr r5, r19
	ctx.r[5].u64 = ctx.r[19].u64;
	// 825B86D4: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B86D8: 481CAD41  bl 0x82783418
	ctx.lr = 0x825B86DC;
	sub_82783418(ctx, base);
	// 825B86DC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B86E0: 7E85A378  mr r5, r20
	ctx.r[5].u64 = ctx.r[20].u64;
	// 825B86E4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B86E8: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 825B86EC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B86F0: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 825B86F4: 481CAD25  bl 0x82783418
	ctx.lr = 0x825B86F8;
	sub_82783418(ctx, base);
	// 825B86F8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B86FC: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825B8700: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 825B8704: 48000038  b 0x825b873c
	pc = 0x825B873C; continue 'dispatch;
            }
            0x825B8708 => {
    //   block [0x825B8708..0x825B873C)
	// 825B8708: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 825B870C: 3861006C  addi r3, r1, 0x6c
	ctx.r[3].s64 = ctx.r[1].s64 + 108;
	// 825B8710: 481CAD09  bl 0x82783418
	ctx.lr = 0x825B8714;
	sub_82783418(ctx, base);
	// 825B8714: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B8718: 7EE5BB78  mr r5, r23
	ctx.r[5].u64 = ctx.r[23].u64;
	// 825B871C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B8720: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B8724: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8728: 914100A4  stw r10, 0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[10].u32 ) };
	// 825B872C: 481CACED  bl 0x82783418
	ctx.lr = 0x825B8730;
	sub_82783418(ctx, base);
	// 825B8730: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825B8734: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825B8738: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	pc = 0x825B873C; continue 'dispatch;
            }
            0x825B873C => {
    //   block [0x825B873C..0x825B8760)
	// 825B873C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8740: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B8744: 910100A8  stw r8, 0xa8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u32 ) };
	// 825B8748: 481CACD1  bl 0x82783418
	ctx.lr = 0x825B874C;
	sub_82783418(ctx, base);
	// 825B874C: 80E30000  lwz r7, 0(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8750: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 825B8754: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825B8758: 90E100AC  stw r7, 0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), ctx.r[7].u32 ) };
	// 825B875C: 4800174D  bl 0x825b9ea8
	ctx.lr = 0x825B8760;
	sub_825B9EA8(ctx, base);
	pc = 0x825B8760; continue 'dispatch;
            }
            0x825B8760 => {
    //   block [0x825B8760..0x825B8788)
	// 825B8760: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8764: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B8768: 815B0008  lwz r10, 8(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B876C: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 825B8770: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B8774: 7D097BD6  divw r8, r9, r15
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[15].s32;
	// 825B8778: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825B877C: 4198FEEC  blt cr6, 0x825b8668
	if ctx.cr[6].lt {
	pc = 0x825B8668; continue 'dispatch;
	}
	// 825B8780: 83810098  lwz r28, 0x98(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B8784: 83C10094  lwz r30, 0x94(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	pc = 0x825B8788; continue 'dispatch;
            }
            0x825B8788 => {
    //   block [0x825B8788..0x825B87D8)
	// 825B8788: 7D7EE050  subf r11, r30, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[30].s64;
	// 825B878C: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825B8790: 7D2B53D7  divw. r9, r11, r10
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825B8794: 418200D4  beq 0x825b8868
	if ctx.cr[0].eq {
	pc = 0x825B8868; continue 'dispatch;
	}
	// 825B8798: 81610194  lwz r11, 0x194(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 825B879C: 7DDF7378  mr r31, r14
	ctx.r[31].u64 = ctx.r[14].u64;
	// 825B87A0: 81120000  lwz r8, 0(r18)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B87A4: 396B0034  addi r11, r11, 0x34
	ctx.r[11].s64 = ctx.r[11].s64 + 52;
	// 825B87A8: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B87AC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B87B0: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825B87B4: 7CC7CBD7  divw. r6, r7, r25
	ctx.r[6].s32 = ctx.r[7].s32 / ctx.r[25].s32;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 825B87B8: 418200B0  beq 0x825b8868
	if ctx.cr[0].eq {
	pc = 0x825B8868; continue 'dispatch;
	}
	// 825B87BC: 83A10194  lwz r29, 0x194(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(404 as u32) ) } as u64;
	// 825B87C0: 554A003E  slwi r10, r10, 0
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B87C4: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B87C8: 7CE95050  subf r7, r9, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[9].s64;
	// 825B87CC: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825B87D0: 7D27CBD6  divw r9, r7, r25
	ctx.r[9].s32 = ctx.r[7].s32 / ctx.r[25].s32;
	// 825B87D4: 394B0016  addi r10, r11, 0x16
	ctx.r[10].s64 = ctx.r[11].s64 + 22;
	pc = 0x825B87D8; continue 'dispatch;
            }
            0x825B87D8 => {
    //   block [0x825B87D8..0x825B8800)
	// 825B87D8: 896AFFFE  lbz r11, -2(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(-2 as u32) ) } as u64;
	// 825B87DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B87E0: 419A0038  beq cr6, 0x825b8818
	if ctx.cr[6].eq {
	pc = 0x825B8818; continue 'dispatch;
	}
	// 825B87E4: 88EA0000  lbz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B87E8: 7DCB7378  mr r11, r14
	ctx.r[11].u64 = ctx.r[14].u64;
	// 825B87EC: 2F080200  cmpwi cr6, r8, 0x200
	ctx.cr[6].compare_i32(ctx.r[8].s32, 512, &mut ctx.xer);
	// 825B87F0: 41990010  bgt cr6, 0x825b8800
	if ctx.cr[6].gt {
	pc = 0x825B8800; continue 'dispatch;
	}
	// 825B87F4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B87F8: 419A0014  beq cr6, 0x825b880c
	if ctx.cr[6].eq {
	pc = 0x825B880C; continue 'dispatch;
	}
	// 825B87FC: 4800000C  b 0x825b8808
	pc = 0x825B8808; continue 'dispatch;
            }
            0x825B8800 => {
    //   block [0x825B8800..0x825B8808)
	// 825B8800: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B8804: 409A0008  bne cr6, 0x825b880c
	if !ctx.cr[6].eq {
	pc = 0x825B880C; continue 'dispatch;
	}
	pc = 0x825B8808; continue 'dispatch;
            }
            0x825B8808 => {
    //   block [0x825B8808..0x825B880C)
	// 825B8808: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	pc = 0x825B880C; continue 'dispatch;
            }
            0x825B880C => {
    //   block [0x825B880C..0x825B8818)
	// 825B880C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8810: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8814: 409A0018  bne cr6, 0x825b882c
	if !ctx.cr[6].eq {
	pc = 0x825B882C; continue 'dispatch;
	}
	pc = 0x825B8818; continue 'dispatch;
            }
            0x825B8818 => {
    //   block [0x825B8818..0x825B882C)
	// 825B8818: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 825B881C: 394A0018  addi r10, r10, 0x18
	ctx.r[10].s64 = ctx.r[10].s64 + 24;
	// 825B8820: 7F1F4840  cmplw cr6, r31, r9
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B8824: 4198FFB4  blt cr6, 0x825b87d8
	if ctx.cr[6].lt {
	pc = 0x825B87D8; continue 'dispatch;
	}
	// 825B8828: 48000040  b 0x825b8868
	pc = 0x825B8868; continue 'dispatch;
            }
            0x825B882C => {
    //   block [0x825B882C..0x825B8868)
	// 825B882C: 934100C4  stw r26, 0xc4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[26].u32 ) };
	// 825B8830: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825B8834: 922100C0  stw r17, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[17].u32 ) };
	// 825B8838: 386100C8  addi r3, r1, 0xc8
	ctx.r[3].s64 = ctx.r[1].s64 + 200;
	// 825B883C: 48001D35  bl 0x825ba570
	ctx.lr = 0x825B8840;
	sub_825BA570(ctx, base);
	// 825B8840: 815D0048  lwz r10, 0x48(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8844: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8848: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B884C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 825B8850: 7C6B502E  lwzx r3, r11, r10
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 825B8854: 4BC72275  bl 0x8222aac8
	ctx.lr = 0x825B8858;
	sub_8222AAC8(ctx, base);
	// 825B8858: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 825B885C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 825B8860: 99210050  stb r9, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u8 ) };
	// 825B8864: 4BFFB205  bl 0x825b3a68
	ctx.lr = 0x825B8868;
	sub_825B3A68(ctx, base);
	pc = 0x825B8868; continue 'dispatch;
            }
            0x825B8868 => {
    //   block [0x825B8868..0x825B888C)
	// 825B8868: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B886C: 3A520004  addi r18, r18, 4
	ctx.r[18].s64 = ctx.r[18].s64 + 4;
	// 825B8870: 356BFFFF  addic. r11, r11, -1
	ctx.xer.ca = (ctx.r[11].u32 > (!(-1 as u32)));
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8874: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B8878: 4082FDBC  bne 0x825b8634
	if !ctx.cr[0].eq {
	pc = 0x825B8634; continue 'dispatch;
	}
	// 825B887C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825B8880: 419A000C  beq cr6, 0x825b888c
	if ctx.cr[6].eq {
	pc = 0x825B888C; continue 'dispatch;
	}
	// 825B8884: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B8888: 4BC634B1  bl 0x8221bd38
	ctx.lr = 0x825B888C;
	sub_8221BD38(ctx, base);
	pc = 0x825B888C; continue 'dispatch;
            }
            0x825B888C => {
    //   block [0x825B888C..0x825B889C)
	// 825B888C: 88610050  lbz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825B8890: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825B8894: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 825B8898: 486F0B88  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B889C => {
    //   block [0x825B889C..0x825B88AC)
	// 825B889C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B88A0: 38210180  addi r1, r1, 0x180
	ctx.r[1].s64 = ctx.r[1].s64 + 384;
	// 825B88A4: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 825B88A8: 486F0B78  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B88B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B88B0 size=544
    let mut pc: u32 = 0x825B88B0;
    'dispatch: loop {
        match pc {
            0x825B88B0 => {
    //   block [0x825B88B0..0x825B8948)
	// 825B88B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B88B4: 486F0B29  bl 0x82ca93dc
	ctx.lr = 0x825B88B8;
	sub_82CA93D0(ctx, base);
	// 825B88B8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B88BC: 7C922378  mr r18, r4
	ctx.r[18].u64 = ctx.r[4].u64;
	// 825B88C0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B88C4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B88C8: 4BC21AE9  bl 0x821da3b0
	ctx.lr = 0x825B88CC;
	sub_821DA3B0(ctx, base);
	// 825B88CC: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825B88D0: 38EB3F9C  addi r7, r11, 0x3f9c
	ctx.r[7].s64 = ctx.r[11].s64 + 16284;
	// 825B88D4: 4BBF9C25  bl 0x821b24f8
	ctx.lr = 0x825B88D8;
	sub_821B24F8(ctx, base);
	// 825B88D8: 7CE43B78  mr r4, r7
	ctx.r[4].u64 = ctx.r[7].u64;
	// 825B88DC: 4BCF110D  bl 0x822a99e8
	ctx.lr = 0x825B88E0;
	sub_822A99E8(ctx, base);
	// 825B88E0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B88E4: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B88E8: 419A01DC  beq cr6, 0x825b8ac4
	if ctx.cr[6].eq {
	pc = 0x825B8AC4; continue 'dispatch;
	}
	// 825B88EC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B88F0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825B88F4: 93E1007C  stw r31, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[31].u32 ) };
	// 825B88F8: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 825B88FC: 93E10078  stw r31, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[31].u32 ) };
	// 825B8900: 48448091  bl 0x82a00990
	ctx.lr = 0x825B8904;
	sub_82A00990(ctx, base);
	// 825B8904: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B8908: 82610064  lwz r19, 0x64(r1)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825B890C: 82A10060  lwz r21, 0x60(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B8910: 7F1D9840  cmplw cr6, r29, r19
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[19].u32, &mut ctx.xer);
	// 825B8914: 419A013C  beq cr6, 0x825b8a50
	if ctx.cr[6].eq {
	pc = 0x825B8A50; continue 'dispatch;
	}
	// 825B8918: 3F00834A  lis r24, -0x7cb6
	ctx.r[24].s64 = -2092302336;
	// 825B891C: 3D00811C  lis r8, -0x7ee4
	ctx.r[8].s64 = -2128871424;
	// 825B8920: 3D60834A  lis r11, -0x7cb6
	ctx.r[11].s64 = -2092302336;
	// 825B8924: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B8928: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B892C: 8398E454  lwz r28, -0x1bac(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7084 as u32) ) } as u64;
	// 825B8930: 611B9DC5  ori r27, r8, 0x9dc5
	ctx.r[27].u64 = ctx.r[8].u64 | 40389;
	// 825B8934: 3A80FFFF  li r20, -1
	ctx.r[20].s64 = -1;
	// 825B8938: 3F208349  lis r25, -0x7cb7
	ctx.r[25].s64 = -2092367872;
	// 825B893C: 3AEBE460  addi r23, r11, -0x1ba0
	ctx.r[23].s64 = ctx.r[11].s64 + -7072;
	// 825B8940: 3ACA56EC  addi r22, r10, 0x56ec
	ctx.r[22].s64 = ctx.r[10].s64 + 22252;
	// 825B8944: 3B49541C  addi r26, r9, 0x541c
	ctx.r[26].s64 = ctx.r[9].s64 + 21532;
	pc = 0x825B8948; continue 'dispatch;
            }
            0x825B8948 => {
    //   block [0x825B8948..0x825B8980)
	// 825B8948: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B894C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825B8950: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825B8954: 7FEBAA14  add r31, r11, r21
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[21].u64;
	// 825B8958: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B895C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8960: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 825B8964: 419A001C  beq cr6, 0x825b8980
	if ctx.cr[6].eq {
	pc = 0x825B8980; continue 'dispatch;
	}
	// 825B8968: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 825B896C: 409A0014  bne cr6, 0x825b8980
	if !ctx.cr[6].eq {
	pc = 0x825B8980; continue 'dispatch;
	}
	// 825B8970: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8974: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B8978: 409A0008  bne cr6, 0x825b8980
	if !ctx.cr[6].eq {
	pc = 0x825B8980; continue 'dispatch;
	}
	// 825B897C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825B8980; continue 'dispatch;
            }
            0x825B8980 => {
    //   block [0x825B8980..0x825B89F4)
	// 825B8980: 80796DA0  lwz r3, 0x6da0(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(28064 as u32) ) } as u64;
	// 825B8984: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8988: 4BC2B8C9  bl 0x821e4250
	ctx.lr = 0x825B898C;
	sub_821E4250(ctx, base);
	// 825B898C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B8990: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B8994: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B8998: 3A210054  addi r17, r1, 0x54
	ctx.r[17].s64 = ctx.r[1].s64 + 84;
	// 825B899C: 4BC3B3BD  bl 0x821f3d58
	ctx.lr = 0x825B89A0;
	sub_821F3D58(ctx, base);
	// 825B89A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B89A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B89A8: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 825B89AC: 4BC2D05D  bl 0x821e5a08
	ctx.lr = 0x825B89B0;
	sub_821E5A08(ctx, base);
	// 825B89B0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B89B4: 419A008C  beq cr6, 0x825b8a40
	if ctx.cr[6].eq {
	pc = 0x825B8A40; continue 'dispatch;
	}
	// 825B89B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B89BC: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 825B89C0: 409A0080  bne cr6, 0x825b8a40
	if !ctx.cr[6].eq {
	pc = 0x825B8A40; continue 'dispatch;
	}
	// 825B89C4: 7EC3B378  mr r3, r22
	ctx.r[3].u64 = ctx.r[22].u64;
	// 825B89C8: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B89CC: 3A210058  addi r17, r1, 0x58
	ctx.r[17].s64 = ctx.r[1].s64 + 88;
	// 825B89D0: 4BC3B389  bl 0x821f3d58
	ctx.lr = 0x825B89D4;
	sub_821F3D58(ctx, base);
	// 825B89D4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B89D8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B89DC: 7E258B78  mr r5, r17
	ctx.r[5].u64 = ctx.r[17].u64;
	// 825B89E0: 4BC2D029  bl 0x821e5a08
	ctx.lr = 0x825B89E4;
	sub_821E5A08(ctx, base);
	// 825B89E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B89E8: 419A000C  beq cr6, 0x825b89f4
	if ctx.cr[6].eq {
	pc = 0x825B89F4; continue 'dispatch;
	}
	// 825B89EC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B89F0: 48000008  b 0x825b89f8
	pc = 0x825B89F8; continue 'dispatch;
            }
            0x825B89F4 => {
    //   block [0x825B89F4..0x825B89F8)
	// 825B89F4: 7E8BA378  mr r11, r20
	ctx.r[11].u64 = ctx.r[20].u64;
	pc = 0x825B89F8; continue 'dispatch;
            }
            0x825B89F8 => {
    //   block [0x825B89F8..0x825B8A28)
	// 825B89F8: 7F0B9000  cmpw cr6, r11, r18
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[18].s32, &mut ctx.xer);
	// 825B89FC: 409A0044  bne cr6, 0x825b8a40
	if !ctx.cr[6].eq {
	pc = 0x825B8A40; continue 'dispatch;
	}
	// 825B8A00: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8A04: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B8A08: 2F0A0006  cmpwi cr6, r10, 6
	ctx.cr[6].compare_i32(ctx.r[10].s32, 6, &mut ctx.xer);
	// 825B8A0C: 419A001C  beq cr6, 0x825b8a28
	if ctx.cr[6].eq {
	pc = 0x825B8A28; continue 'dispatch;
	}
	// 825B8A10: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 825B8A14: 409A0014  bne cr6, 0x825b8a28
	if !ctx.cr[6].eq {
	pc = 0x825B8A28; continue 'dispatch;
	}
	// 825B8A18: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8A1C: 7F0AE040  cmplw cr6, r10, r28
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B8A20: 409A0008  bne cr6, 0x825b8a28
	if !ctx.cr[6].eq {
	pc = 0x825B8A28; continue 'dispatch;
	}
	// 825B8A24: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825B8A28; continue 'dispatch;
            }
            0x825B8A28 => {
    //   block [0x825B8A28..0x825B8A40)
	// 825B8A28: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8A2C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B8A30: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B8A34: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B8A38: 4BD3D619  bl 0x822f6050
	ctx.lr = 0x825B8A3C;
	sub_822F6050(ctx, base);
	// 825B8A3C: 8398E454  lwz r28, -0x1bac(r24)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7084 as u32) ) } as u64;
	pc = 0x825B8A40; continue 'dispatch;
            }
            0x825B8A40 => {
    //   block [0x825B8A40..0x825B8A50)
	// 825B8A40: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B8A44: 7F1D9840  cmplw cr6, r29, r19
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[19].u32, &mut ctx.xer);
	// 825B8A48: 409AFF00  bne cr6, 0x825b8948
	if !ctx.cr[6].eq {
	pc = 0x825B8948; continue 'dispatch;
	}
	// 825B8A4C: 83E10074  lwz r31, 0x74(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	pc = 0x825B8A50; continue 'dispatch;
            }
            0x825B8A50 => {
    //   block [0x825B8A50..0x825B8AB8)
	// 825B8A50: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B8A54: 7EA3AB78  mr r3, r21
	ctx.r[3].u64 = ctx.r[21].u64;
	// 825B8A58: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825B8A5C: 7D4B1671  srawi. r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8A60: 41820058  beq 0x825b8ab8
	if ctx.cr[0].eq {
	pc = 0x825B8AB8; continue 'dispatch;
	}
	// 825B8A64: 3D408349  lis r10, -0x7cb7
	ctx.r[10].s64 = -2092367872;
	// 825B8A68: 814A6AB8  lwz r10, 0x6ab8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B8A6C: 812A000C  lwz r9, 0xc(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B8A70: 81090058  lwz r8, 0x58(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8A74: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8A78: 80EA0078  lwz r7, 0x78(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(120 as u32) ) } as u64;
	// 825B8A7C: 1D2724A1  mulli r9, r7, 0x24a1
	ctx.r[9].s32 = ((ctx.r[7].s32 as i64 * 9377 as i64) as i32);
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 825B8A80: 38C924DF  addi r6, r9, 0x24df
	ctx.r[6].s64 = ctx.r[9].s64 + 9439;
	// 825B8A84: 54C5983E  rotlwi r5, r6, 0x13
	ctx.r[5].u64 = ((ctx.r[6].u32).rotate_left(19)) as u64;
	// 825B8A88: 90AA0078  stw r5, 0x78(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), ctx.r[5].u32 ) };
	// 825B8A8C: 7C855B96  divwu r4, r5, r11
	ctx.r[4].u32 = ctx.r[5].u32 / ctx.r[11].u32;
	// 825B8A90: 7D6459D6  mullw r11, r4, r11
	ctx.r[11].s32 = ((ctx.r[4].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825B8A94: 7D4B2850  subf r10, r11, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825B8A98: 5549103A  slwi r9, r10, 2
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B8A9C: 7FE9F82E  lwzx r31, r9, r31
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B8AA0: 4BC63299  bl 0x8221bd38
	ctx.lr = 0x825B8AA4;
	sub_8221BD38(ctx, base);
	// 825B8AA4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B8AA8: 480014B9  bl 0x825b9f60
	ctx.lr = 0x825B8AAC;
	sub_825B9F60(ctx, base);
	// 825B8AAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B8AB0: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825B8AB4: 486F0978  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B8AB8 => {
    //   block [0x825B8AB8..0x825B8AC4)
	// 825B8AB8: 4BC63281  bl 0x8221bd38
	ctx.lr = 0x825B8ABC;
	sub_8221BD38(ctx, base);
	// 825B8ABC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825B8AC0: 480014A1  bl 0x825b9f60
	ctx.lr = 0x825B8AC4;
	sub_825B9F60(ctx, base);
	pc = 0x825B8AC4; continue 'dispatch;
            }
            0x825B8AC4 => {
    //   block [0x825B8AC4..0x825B8AD0)
	// 825B8AC4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B8AC8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 825B8ACC: 486F0960  b 0x82ca942c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8AD0 size=412
    let mut pc: u32 = 0x825B8AD0;
    'dispatch: loop {
        match pc {
            0x825B8AD0 => {
    //   block [0x825B8AD0..0x825B8B20)
	// 825B8AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8AD4: 486F0935  bl 0x82ca9408
	ctx.lr = 0x825B8AD8;
	sub_82CA93D0(ctx, base);
	// 825B8AD8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8ADC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825B8AE0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B8AE4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8AE8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B8AEC: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825B8AF0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B8AF4: 419A00E8  beq cr6, 0x825b8bdc
	if ctx.cr[6].eq {
	pc = 0x825B8BDC; continue 'dispatch;
	}
	// 825B8AF8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B8AFC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B8B00: 419A0020  beq cr6, 0x825b8b20
	if ctx.cr[6].eq {
	pc = 0x825B8B20; continue 'dispatch;
	}
	// 825B8B04: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8B08: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8B0C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B8B10: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8B14: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8B18: 83E80004  lwz r31, 4(r8)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8B1C: 480000C4  b 0x825b8be0
	pc = 0x825B8BE0; continue 'dispatch;
            }
            0x825B8B20 => {
    //   block [0x825B8B20..0x825B8B3C)
	// 825B8B20: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8B24: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8B28: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B8B2C: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B8B30: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B8B34: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8B38: 40810054  ble 0x825b8b8c
	if !ctx.cr[0].gt {
	pc = 0x825B8B8C; continue 'dispatch;
	}
	pc = 0x825B8B3C; continue 'dispatch;
            }
            0x825B8B3C => {
    //   block [0x825B8B3C..0x825B8B5C)
	// 825B8B3C: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B8B40: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8B44: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B8B48: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8B4C: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825B8B50: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B8B54: 41980008  blt cr6, 0x825b8b5c
	if ctx.cr[6].lt {
	pc = 0x825B8B5C; continue 'dispatch;
	}
	// 825B8B58: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B8B5C; continue 'dispatch;
            }
            0x825B8B5C => {
    //   block [0x825B8B5C..0x825B8B78)
	// 825B8B5C: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B8B60: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B8B64: 419A0014  beq cr6, 0x825b8b78
	if ctx.cr[6].eq {
	pc = 0x825B8B78; continue 'dispatch;
	}
	// 825B8B68: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B8B6C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B8B70: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B8B74: 4800000C  b 0x825b8b80
	pc = 0x825B8B80; continue 'dispatch;
            }
            0x825B8B78 => {
    //   block [0x825B8B78..0x825B8B80)
	// 825B8B78: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B8B7C: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B8B80; continue 'dispatch;
            }
            0x825B8B80 => {
    //   block [0x825B8B80..0x825B8B8C)
	// 825B8B80: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8B84: 4199FFB8  bgt cr6, 0x825b8b3c
	if ctx.cr[6].gt {
	pc = 0x825B8B3C; continue 'dispatch;
	}
	// 825B8B88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B8B8C; continue 'dispatch;
            }
            0x825B8B8C => {
    //   block [0x825B8B8C..0x825B8BA8)
	// 825B8B8C: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B8B90: 419A003C  beq cr6, 0x825b8bcc
	if ctx.cr[6].eq {
	pc = 0x825B8BCC; continue 'dispatch;
	}
	// 825B8B94: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8B98: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B8B9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8BA0: 41990008  bgt cr6, 0x825b8ba8
	if ctx.cr[6].gt {
	pc = 0x825B8BA8; continue 'dispatch;
	}
	// 825B8BA4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8BA8; continue 'dispatch;
            }
            0x825B8BA8 => {
    //   block [0x825B8BA8..0x825B8BCC)
	// 825B8BA8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8BAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8BB0: 409A001C  bne cr6, 0x825b8bcc
	if !ctx.cr[6].eq {
	pc = 0x825B8BCC; continue 'dispatch;
	}
	// 825B8BB4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B8BB8: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825B8BBC: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B8BC0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8BC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8BC8: 48000018  b 0x825b8be0
	pc = 0x825B8BE0; continue 'dispatch;
            }
            0x825B8BCC => {
    //   block [0x825B8BCC..0x825B8BDC)
	// 825B8BCC: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B8BD0: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8BD4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8BD8: 48000008  b 0x825b8be0
	pc = 0x825B8BE0; continue 'dispatch;
            }
            0x825B8BDC => {
    //   block [0x825B8BDC..0x825B8BE0)
	// 825B8BDC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8BE0; continue 'dispatch;
            }
            0x825B8BE0 => {
    //   block [0x825B8BE0..0x825B8C64)
	// 825B8BE0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8BE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8BE8: 419A007C  beq cr6, 0x825b8c64
	if ctx.cr[6].eq {
	pc = 0x825B8C64; continue 'dispatch;
	}
	// 825B8BEC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8BF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B8BF4: 997C00B3  stb r11, 0xb3(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(179 as u32), ctx.r[11].u8 ) };
	// 825B8BF8: 3BDC000C  addi r30, r28, 0xc
	ctx.r[30].s64 = ctx.r[28].s64 + 12;
	// 825B8BFC: 4BFB9CED  bl 0x825728e8
	ctx.lr = 0x825B8C00;
	sub_825728E8(ctx, base);
	// 825B8C00: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B8C04: 3BBF000C  addi r29, r31, 0xc
	ctx.r[29].s64 = ctx.r[31].s64 + 12;
	// 825B8C08: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B8C0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8C10: 4BFBCF81  bl 0x82575b90
	ctx.lr = 0x825B8C14;
	sub_82575B90(ctx, base);
	// 825B8C14: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B8C18: 48000059  bl 0x825b8c70
	ctx.lr = 0x825B8C1C;
	sub_825B8C70(ctx, base);
	// 825B8C1C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825B8C20: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B8C24: 4BC2178D  bl 0x821da3b0
	ctx.lr = 0x825B8C28;
	sub_821DA3B0(ctx, base);
	// 825B8C28: 4BBF98D1  bl 0x821b24f8
	ctx.lr = 0x825B8C2C;
	sub_821B24F8(ctx, base);
	// 825B8C2C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B8C30: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B8C34: 4BFFBC45  bl 0x825b4878
	ctx.lr = 0x825B8C38;
	sub_825B4878(ctx, base);
	// 825B8C38: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 825B8C3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B8C40: 48000289  bl 0x825b8ec8
	ctx.lr = 0x825B8C44;
	sub_825B8EC8(ctx, base);
	// 825B8C44: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B8C48: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B8C4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B8C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8C54: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825B8C58: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B8C5C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B8C60: 484DE709  bl 0x82a97368
	ctx.lr = 0x825B8C64;
	sub_82A97368(ctx, base);
	pc = 0x825B8C64; continue 'dispatch;
            }
            0x825B8C64 => {
    //   block [0x825B8C64..0x825B8C6C)
	// 825B8C64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B8C68: 486F07F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8C70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8C70 size=600
    let mut pc: u32 = 0x825B8C70;
    'dispatch: loop {
        match pc {
            0x825B8C70 => {
    //   block [0x825B8C70..0x825B8CBC)
	// 825B8C70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8C74: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B8C78: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B8C7C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B8C80: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8C84: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B8C88: 38FF0044  addi r7, r31, 0x44
	ctx.r[7].s64 = ctx.r[31].s64 + 68;
	// 825B8C8C: 813F0048  lwz r9, 0x48(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8C90: 817F004C  lwz r11, 0x4c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8C94: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8C98: 419A003C  beq cr6, 0x825b8cd4
	if ctx.cr[6].eq {
	pc = 0x825B8CD4; continue 'dispatch;
	}
	// 825B8C9C: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B8CA0: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B8CA4: 7D061670  srawi r6, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B8CA8: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8CAC: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8CB0: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B8CB4: 419A001C  beq cr6, 0x825b8cd0
	if ctx.cr[6].eq {
	pc = 0x825B8CD0; continue 'dispatch;
	}
	// 825B8CB8: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B8CBC; continue 'dispatch;
            }
            0x825B8CBC => {
    //   block [0x825B8CBC..0x825B8CD0)
	// 825B8CBC: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8CC0: 7CC9512E  stwx r6, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 825B8CC4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B8CC8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8CCC: 409AFFF0  bne cr6, 0x825b8cbc
	if !ctx.cr[6].eq {
	pc = 0x825B8CBC; continue 'dispatch;
	}
	pc = 0x825B8CD0; continue 'dispatch;
            }
            0x825B8CD0 => {
    //   block [0x825B8CD0..0x825B8CD4)
	// 825B8CD0: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B8CD4; continue 'dispatch;
            }
            0x825B8CD4 => {
    //   block [0x825B8CD4..0x825B8D08)
	// 825B8CD4: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B8CD8: 38FF0054  addi r7, r31, 0x54
	ctx.r[7].s64 = ctx.r[31].s64 + 84;
	// 825B8CDC: 817F005C  lwz r11, 0x5c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B8CE0: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8CE4: 419A003C  beq cr6, 0x825b8d20
	if ctx.cr[6].eq {
	pc = 0x825B8D20; continue 'dispatch;
	}
	// 825B8CE8: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B8CEC: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B8CF0: 7D061670  srawi r6, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B8CF4: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8CF8: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8CFC: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B8D00: 419A001C  beq cr6, 0x825b8d1c
	if ctx.cr[6].eq {
	pc = 0x825B8D1C; continue 'dispatch;
	}
	// 825B8D04: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B8D08; continue 'dispatch;
            }
            0x825B8D08 => {
    //   block [0x825B8D08..0x825B8D1C)
	// 825B8D08: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8D0C: 7CC9512E  stwx r6, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[6].u32) };
	// 825B8D10: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B8D14: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8D18: 409AFFF0  bne cr6, 0x825b8d08
	if !ctx.cr[6].eq {
	pc = 0x825B8D08; continue 'dispatch;
	}
	pc = 0x825B8D1C; continue 'dispatch;
            }
            0x825B8D1C => {
    //   block [0x825B8D1C..0x825B8D20)
	// 825B8D1C: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B8D20; continue 'dispatch;
            }
            0x825B8D20 => {
    //   block [0x825B8D20..0x825B8D54)
	// 825B8D20: 813F0028  lwz r9, 0x28(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 825B8D24: 38FF0024  addi r7, r31, 0x24
	ctx.r[7].s64 = ctx.r[31].s64 + 36;
	// 825B8D28: 817F002C  lwz r11, 0x2c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B8D2C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8D30: 419A003C  beq cr6, 0x825b8d6c
	if ctx.cr[6].eq {
	pc = 0x825B8D6C; continue 'dispatch;
	}
	// 825B8D34: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B8D38: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B8D3C: 7D061670  srawi r6, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[6].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B8D40: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8D44: 54C8103A  slwi r8, r6, 2
	ctx.r[8].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8D48: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B8D4C: 419A001C  beq cr6, 0x825b8d68
	if ctx.cr[6].eq {
	pc = 0x825B8D68; continue 'dispatch;
	}
	// 825B8D50: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B8D54; continue 'dispatch;
            }
            0x825B8D54 => {
    //   block [0x825B8D54..0x825B8D68)
	// 825B8D54: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8D58: 7CCA492E  stwx r6, r10, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u32) };
	// 825B8D5C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B8D60: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B8D64: 409AFFF0  bne cr6, 0x825b8d54
	if !ctx.cr[6].eq {
	pc = 0x825B8D54; continue 'dispatch;
	}
	pc = 0x825B8D68; continue 'dispatch;
            }
            0x825B8D68 => {
    //   block [0x825B8D68..0x825B8D6C)
	// 825B8D68: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B8D6C; continue 'dispatch;
            }
            0x825B8D6C => {
    //   block [0x825B8D6C..0x825B8DCC)
	// 825B8D6C: 387F0034  addi r3, r31, 0x34
	ctx.r[3].s64 = ctx.r[31].s64 + 52;
	// 825B8D70: 48000BE9  bl 0x825b9958
	ctx.lr = 0x825B8D74;
	sub_825B9958(ctx, base);
	// 825B8D74: 809F00BC  lwz r4, 0xbc(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 825B8D78: 3BDF00BC  addi r30, r31, 0xbc
	ctx.r[30].s64 = ctx.r[31].s64 + 188;
	// 825B8D7C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B8D80: 419A0130  beq cr6, 0x825b8eb0
	if ctx.cr[6].eq {
	pc = 0x825B8EB0; continue 'dispatch;
	}
	// 825B8D84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8D88: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B8D8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B8D90: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B8D94: 554997FE  rlwinm r9, r10, 0x12, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00003FFFu64;
	// 825B8D98: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B8D9C: 419A00F4  beq cr6, 0x825b8e90
	if ctx.cr[6].eq {
	pc = 0x825B8E90; continue 'dispatch;
	}
	// 825B8DA0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B8DA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B8DA8: 419A0024  beq cr6, 0x825b8dcc
	if ctx.cr[6].eq {
	pc = 0x825B8DCC; continue 'dispatch;
	}
	// 825B8DAC: 892A000E  lbz r9, 0xe(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(14 as u32) ) } as u64;
	// 825B8DB0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8DB4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B8DB8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B8DBC: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8DC0: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B8DC4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8DC8: 480000CC  b 0x825b8e94
	pc = 0x825B8E94; continue 'dispatch;
            }
            0x825B8DCC => {
    //   block [0x825B8DCC..0x825B8DE8)
	// 825B8DCC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8DD0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8DD4: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B8DD8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B8DDC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B8DE0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8DE4: 40810054  ble 0x825b8e38
	if !ctx.cr[0].gt {
	pc = 0x825B8E38; continue 'dispatch;
	}
	pc = 0x825B8DE8; continue 'dispatch;
            }
            0x825B8DE8 => {
    //   block [0x825B8DE8..0x825B8E08)
	// 825B8DE8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B8DEC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8DF0: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B8DF4: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8DF8: 2F07000E  cmpwi cr6, r7, 0xe
	ctx.cr[6].compare_i32(ctx.r[7].s32, 14, &mut ctx.xer);
	// 825B8DFC: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B8E00: 41980008  blt cr6, 0x825b8e08
	if ctx.cr[6].lt {
	pc = 0x825B8E08; continue 'dispatch;
	}
	// 825B8E04: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B8E08; continue 'dispatch;
            }
            0x825B8E08 => {
    //   block [0x825B8E08..0x825B8E24)
	// 825B8E08: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B8E0C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B8E10: 419A0014  beq cr6, 0x825b8e24
	if ctx.cr[6].eq {
	pc = 0x825B8E24; continue 'dispatch;
	}
	// 825B8E14: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B8E18: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B8E1C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B8E20: 4800000C  b 0x825b8e2c
	pc = 0x825B8E2C; continue 'dispatch;
            }
            0x825B8E24 => {
    //   block [0x825B8E24..0x825B8E2C)
	// 825B8E24: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B8E28: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B8E2C; continue 'dispatch;
            }
            0x825B8E2C => {
    //   block [0x825B8E2C..0x825B8E38)
	// 825B8E2C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8E30: 4199FFB8  bgt cr6, 0x825b8de8
	if ctx.cr[6].gt {
	pc = 0x825B8DE8; continue 'dispatch;
	}
	// 825B8E34: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B8E38; continue 'dispatch;
            }
            0x825B8E38 => {
    //   block [0x825B8E38..0x825B8E54)
	// 825B8E38: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B8E3C: 419A0040  beq cr6, 0x825b8e7c
	if ctx.cr[6].eq {
	pc = 0x825B8E7C; continue 'dispatch;
	}
	// 825B8E40: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8E44: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 825B8E48: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8E4C: 41990008  bgt cr6, 0x825b8e54
	if ctx.cr[6].gt {
	pc = 0x825B8E54; continue 'dispatch;
	}
	// 825B8E50: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8E54; continue 'dispatch;
            }
            0x825B8E54 => {
    //   block [0x825B8E54..0x825B8E7C)
	// 825B8E54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8E58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8E5C: 409A0020  bne cr6, 0x825b8e7c
	if !ctx.cr[6].eq {
	pc = 0x825B8E7C; continue 'dispatch;
	}
	// 825B8E60: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B8E64: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B8E68: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B8E6C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8E70: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B8E74: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8E78: 4800001C  b 0x825b8e94
	pc = 0x825B8E94; continue 'dispatch;
            }
            0x825B8E7C => {
    //   block [0x825B8E7C..0x825B8E90)
	// 825B8E7C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B8E80: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8E84: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B8E88: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8E8C: 48000008  b 0x825b8e94
	pc = 0x825B8E94; continue 'dispatch;
            }
            0x825B8E90 => {
    //   block [0x825B8E90..0x825B8E94)
	// 825B8E90: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8E94; continue 'dispatch;
            }
            0x825B8E94 => {
    //   block [0x825B8E94..0x825B8EA4)
	// 825B8E94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8E98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8E9C: 419A0008  beq cr6, 0x825b8ea4
	if ctx.cr[6].eq {
	pc = 0x825B8EA4; continue 'dispatch;
	}
	// 825B8EA0: 48058D91  bl 0x82611c30
	ctx.lr = 0x825B8EA4;
	sub_82611C30(ctx, base);
	pc = 0x825B8EA4; continue 'dispatch;
            }
            0x825B8EA4 => {
    //   block [0x825B8EA4..0x825B8EB0)
	// 825B8EA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B8EA8: 4BBFEC71  bl 0x821b7b18
	ctx.lr = 0x825B8EAC;
	sub_821B7B18(ctx, base);
	// 825B8EAC: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x825B8EB0; continue 'dispatch;
            }
            0x825B8EB0 => {
    //   block [0x825B8EB0..0x825B8EC8)
	// 825B8EB0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B8EB4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B8EB8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B8EBC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B8EC0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B8EC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B8EC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B8EC8 size=404
    let mut pc: u32 = 0x825B8EC8;
    'dispatch: loop {
        match pc {
            0x825B8EC8 => {
    //   block [0x825B8EC8..0x825B8F28)
	// 825B8EC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B8ECC: 486F053D  bl 0x82ca9408
	ctx.lr = 0x825B8ED0;
	sub_82CA93D0(ctx, base);
	// 825B8ED0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B8ED4: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B8ED8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825B8EDC: 4BFFD3DD  bl 0x825b62b8
	ctx.lr = 0x825B8EE0;
	sub_825B62B8(ctx, base);
	// 825B8EE0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B8EE4: 4BBC6B6D  bl 0x8217fa50
	ctx.lr = 0x825B8EE8;
	sub_8217FA50(ctx, base);
	// 825B8EE8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8EEC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B8EF0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B8EF4: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825B8EF8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B8EFC: 419A00E8  beq cr6, 0x825b8fe4
	if ctx.cr[6].eq {
	pc = 0x825B8FE4; continue 'dispatch;
	}
	// 825B8F00: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B8F04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B8F08: 419A0020  beq cr6, 0x825b8f28
	if ctx.cr[6].eq {
	pc = 0x825B8F28; continue 'dispatch;
	}
	// 825B8F0C: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825B8F10: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8F14: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B8F18: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B8F1C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8F20: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8F24: 480000C4  b 0x825b8fe8
	pc = 0x825B8FE8; continue 'dispatch;
            }
            0x825B8F28 => {
    //   block [0x825B8F28..0x825B8F44)
	// 825B8F28: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B8F2C: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B8F30: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825B8F34: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B8F38: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B8F3C: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8F40: 40810054  ble 0x825b8f94
	if !ctx.cr[0].gt {
	pc = 0x825B8F94; continue 'dispatch;
	}
	pc = 0x825B8F44; continue 'dispatch;
            }
            0x825B8F44 => {
    //   block [0x825B8F44..0x825B8F64)
	// 825B8F44: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B8F48: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B8F4C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B8F50: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8F54: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825B8F58: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B8F5C: 41980008  blt cr6, 0x825b8f64
	if ctx.cr[6].lt {
	pc = 0x825B8F64; continue 'dispatch;
	}
	// 825B8F60: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	pc = 0x825B8F64; continue 'dispatch;
            }
            0x825B8F64 => {
    //   block [0x825B8F64..0x825B8F80)
	// 825B8F64: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B8F68: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B8F6C: 419A0014  beq cr6, 0x825b8f80
	if ctx.cr[6].eq {
	pc = 0x825B8F80; continue 'dispatch;
	}
	// 825B8F70: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B8F74: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B8F78: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B8F7C: 4800000C  b 0x825b8f88
	pc = 0x825B8F88; continue 'dispatch;
            }
            0x825B8F80 => {
    //   block [0x825B8F80..0x825B8F88)
	// 825B8F80: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B8F84: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B8F88; continue 'dispatch;
            }
            0x825B8F88 => {
    //   block [0x825B8F88..0x825B8F94)
	// 825B8F88: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B8F8C: 4199FFB8  bgt cr6, 0x825b8f44
	if ctx.cr[6].gt {
	pc = 0x825B8F44; continue 'dispatch;
	}
	// 825B8F90: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B8F94; continue 'dispatch;
            }
            0x825B8F94 => {
    //   block [0x825B8F94..0x825B8FB0)
	// 825B8F94: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B8F98: 419A003C  beq cr6, 0x825b8fd4
	if ctx.cr[6].eq {
	pc = 0x825B8FD4; continue 'dispatch;
	}
	// 825B8F9C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B8FA0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825B8FA4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8FA8: 41990008  bgt cr6, 0x825b8fb0
	if ctx.cr[6].gt {
	pc = 0x825B8FB0; continue 'dispatch;
	}
	// 825B8FAC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8FB0; continue 'dispatch;
            }
            0x825B8FB0 => {
    //   block [0x825B8FB0..0x825B8FD4)
	// 825B8FB0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8FB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8FB8: 409A001C  bne cr6, 0x825b8fd4
	if !ctx.cr[6].eq {
	pc = 0x825B8FD4; continue 'dispatch;
	}
	// 825B8FBC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B8FC0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B8FC4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B8FC8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8FCC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8FD0: 48000018  b 0x825b8fe8
	pc = 0x825B8FE8; continue 'dispatch;
            }
            0x825B8FD4 => {
    //   block [0x825B8FD4..0x825B8FE4)
	// 825B8FD4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B8FD8: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B8FDC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B8FE0: 48000008  b 0x825b8fe8
	pc = 0x825B8FE8; continue 'dispatch;
            }
            0x825B8FE4 => {
    //   block [0x825B8FE4..0x825B8FE8)
	// 825B8FE4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x825B8FE8; continue 'dispatch;
            }
            0x825B8FE8 => {
    //   block [0x825B8FE8..0x825B900C)
	// 825B8FE8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B8FEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B8FF0: 419A0050  beq cr6, 0x825b9040
	if ctx.cr[6].eq {
	pc = 0x825B9040; continue 'dispatch;
	}
	// 825B8FF4: 83DF0090  lwz r30, 0x90(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B8FF8: 57CB0630  rlwinm r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 825B8FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9000: 409A000C  bne cr6, 0x825b900c
	if !ctx.cr[6].eq {
	pc = 0x825B900C; continue 'dispatch;
	}
	// 825B9004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9008: 4BFB98E1  bl 0x825728e8
	ctx.lr = 0x825B900C;
	sub_825728E8(ctx, base);
	pc = 0x825B900C; continue 'dispatch;
            }
            0x825B900C => {
    //   block [0x825B900C..0x825B9040)
	// 825B900C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825B9010: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825B9014: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 825B9018: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 825B901C: 409A0024  bne cr6, 0x825b9040
	if !ctx.cr[6].eq {
	pc = 0x825B9040; continue 'dispatch;
	}
	// 825B9020: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B9024: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9028: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B902C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9030: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B9034: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9038: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B903C: 4BC57FDD  bl 0x82211018
	ctx.lr = 0x825B9040;
	sub_82211018(ctx, base);
	pc = 0x825B9040; continue 'dispatch;
            }
            0x825B9040 => {
    //   block [0x825B9040..0x825B9054)
	// 825B9040: 578B063E  clrlwi r11, r28, 0x18
	ctx.r[11].u64 = ctx.r[28].u32 as u64 & 0x000000FFu64;
	// 825B9044: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9048: 419A000C  beq cr6, 0x825b9054
	if ctx.cr[6].eq {
	pc = 0x825B9054; continue 'dispatch;
	}
	// 825B904C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B9050: 480004F1  bl 0x825b9540
	ctx.lr = 0x825B9054;
	sub_825B9540(ctx, base);
	pc = 0x825B9054; continue 'dispatch;
            }
            0x825B9054 => {
    //   block [0x825B9054..0x825B905C)
	// 825B9054: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B9058: 486F0400  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9060 size=676
    let mut pc: u32 = 0x825B9060;
    'dispatch: loop {
        match pc {
            0x825B9060 => {
    //   block [0x825B9060..0x825B90DC)
	// 825B9060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9064: 486F03A5  bl 0x82ca9408
	ctx.lr = 0x825B9068;
	sub_82CA93D0(ctx, base);
	// 825B9068: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B906C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825B9070: 817D0068  lwz r11, 0x68(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) } as u64;
	// 825B9074: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9078: 419A0284  beq cr6, 0x825b92fc
	if ctx.cr[6].eq {
	pc = 0x825B92FC; continue 'dispatch;
	}
	// 825B907C: 815D006C  lwz r10, 0x6c(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(108 as u32) ) } as u64;
	// 825B9080: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 825B9084: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B9088: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825B908C: 41820270  beq 0x825b92fc
	if ctx.cr[0].eq {
	pc = 0x825B92FC; continue 'dispatch;
	}
	// 825B9090: 4BFFE869  bl 0x825b78f8
	ctx.lr = 0x825B9094;
	sub_825B78F8(ctx, base);
	// 825B9094: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9098: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825B909C: 7F9EE378  mr r30, r28
	ctx.r[30].u64 = ctx.r[28].u64;
	// 825B90A0: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B90A4: 5549D7FE  rlwinm r9, r10, 0x1a, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0000003Fu64;
	// 825B90A8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B90AC: 419A00F4  beq cr6, 0x825b91a0
	if ctx.cr[6].eq {
	pc = 0x825B91A0; continue 'dispatch;
	}
	// 825B90B0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B90B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B90B8: 419A0024  beq cr6, 0x825b90dc
	if ctx.cr[6].eq {
	pc = 0x825B90DC; continue 'dispatch;
	}
	// 825B90BC: 894A0006  lbz r10, 6(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(6 as u32) ) } as u64;
	// 825B90C0: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B90C4: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B90C8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B90CC: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B90D0: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825B90D4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B90D8: 480000CC  b 0x825b91a4
	pc = 0x825B91A4; continue 'dispatch;
            }
            0x825B90DC => {
    //   block [0x825B90DC..0x825B90F8)
	// 825B90DC: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B90E0: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B90E4: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B90E8: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B90EC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B90F0: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B90F4: 40810054  ble 0x825b9148
	if !ctx.cr[0].gt {
	pc = 0x825B9148; continue 'dispatch;
	}
	pc = 0x825B90F8; continue 'dispatch;
            }
            0x825B90F8 => {
    //   block [0x825B90F8..0x825B9118)
	// 825B90F8: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B90FC: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B9100: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B9104: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9108: 2F070006  cmpwi cr6, r7, 6
	ctx.cr[6].compare_i32(ctx.r[7].s32, 6, &mut ctx.xer);
	// 825B910C: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B9110: 41980008  blt cr6, 0x825b9118
	if ctx.cr[6].lt {
	pc = 0x825B9118; continue 'dispatch;
	}
	// 825B9114: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x825B9118; continue 'dispatch;
            }
            0x825B9118 => {
    //   block [0x825B9118..0x825B9134)
	// 825B9118: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B911C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B9120: 419A0014  beq cr6, 0x825b9134
	if ctx.cr[6].eq {
	pc = 0x825B9134; continue 'dispatch;
	}
	// 825B9124: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B9128: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B912C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B9130: 4800000C  b 0x825b913c
	pc = 0x825B913C; continue 'dispatch;
            }
            0x825B9134 => {
    //   block [0x825B9134..0x825B913C)
	// 825B9134: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B9138: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B913C; continue 'dispatch;
            }
            0x825B913C => {
    //   block [0x825B913C..0x825B9148)
	// 825B913C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B9140: 4199FFB8  bgt cr6, 0x825b90f8
	if ctx.cr[6].gt {
	pc = 0x825B90F8; continue 'dispatch;
	}
	// 825B9144: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B9148; continue 'dispatch;
            }
            0x825B9148 => {
    //   block [0x825B9148..0x825B9164)
	// 825B9148: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B914C: 419A0040  beq cr6, 0x825b918c
	if ctx.cr[6].eq {
	pc = 0x825B918C; continue 'dispatch;
	}
	// 825B9150: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9154: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 825B9158: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B915C: 41990008  bgt cr6, 0x825b9164
	if ctx.cr[6].gt {
	pc = 0x825B9164; continue 'dispatch;
	}
	// 825B9160: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825B9164; continue 'dispatch;
            }
            0x825B9164 => {
    //   block [0x825B9164..0x825B918C)
	// 825B9164: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B9168: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B916C: 409A0020  bne cr6, 0x825b918c
	if !ctx.cr[6].eq {
	pc = 0x825B918C; continue 'dispatch;
	}
	// 825B9170: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9174: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B9178: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B917C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9180: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825B9184: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B9188: 4800001C  b 0x825b91a4
	pc = 0x825B91A4; continue 'dispatch;
            }
            0x825B918C => {
    //   block [0x825B918C..0x825B91A0)
	// 825B918C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B9190: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9194: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825B9198: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B919C: 48000008  b 0x825b91a4
	pc = 0x825B91A4; continue 'dispatch;
            }
            0x825B91A0 => {
    //   block [0x825B91A0..0x825B91A4)
	// 825B91A0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825B91A4; continue 'dispatch;
            }
            0x825B91A4 => {
    //   block [0x825B91A4..0x825B91D4)
	// 825B91A4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B91A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B91AC: 419A0034  beq cr6, 0x825b91e0
	if ctx.cr[6].eq {
	pc = 0x825B91E0; continue 'dispatch;
	}
	// 825B91B0: 38600028  li r3, 0x28
	ctx.r[3].s64 = 40;
	// 825B91B4: 83FD0074  lwz r31, 0x74(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(116 as u32) ) } as u64;
	// 825B91B8: 4BC660A1  bl 0x8221f258
	ctx.lr = 0x825B91BC;
	sub_8221F258(ctx, base);
	// 825B91BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B91C0: 419A0014  beq cr6, 0x825b91d4
	if ctx.cr[6].eq {
	pc = 0x825B91D4; continue 'dispatch;
	}
	// 825B91C4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825B91C8: 4BFC45F9  bl 0x8257d7c0
	ctx.lr = 0x825B91CC;
	sub_8257D7C0(ctx, base);
	// 825B91CC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B91D0: 48000008  b 0x825b91d8
	pc = 0x825B91D8; continue 'dispatch;
            }
            0x825B91D4 => {
    //   block [0x825B91D4..0x825B91D8)
	// 825B91D4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	pc = 0x825B91D8; continue 'dispatch;
            }
            0x825B91D8 => {
    //   block [0x825B91D8..0x825B91E0)
	// 825B91D8: 387E0098  addi r3, r30, 0x98
	ctx.r[3].s64 = ctx.r[30].s64 + 152;
	// 825B91DC: 4BCB9E7D  bl 0x82273058
	ctx.lr = 0x825B91E0;
	sub_82273058(ctx, base);
	pc = 0x825B91E0; continue 'dispatch;
            }
            0x825B91E0 => {
    //   block [0x825B91E0..0x825B9224)
	// 825B91E0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B91E4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825B91E8: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825B91EC: 554977FE  rlwinm r9, r10, 0xe, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0003FFFFu64;
	// 825B91F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B91F4: 419A00F4  beq cr6, 0x825b92e8
	if ctx.cr[6].eq {
	pc = 0x825B92E8; continue 'dispatch;
	}
	// 825B91F8: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B91FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9200: 419A0024  beq cr6, 0x825b9224
	if ctx.cr[6].eq {
	pc = 0x825B9224; continue 'dispatch;
	}
	// 825B9204: 892A0012  lbz r9, 0x12(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 825B9208: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B920C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825B9210: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825B9214: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9218: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B921C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B9220: 480000CC  b 0x825b92ec
	pc = 0x825B92EC; continue 'dispatch;
            }
            0x825B9224 => {
    //   block [0x825B9224..0x825B9240)
	// 825B9224: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B9228: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B922C: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825B9230: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B9234: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B9238: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B923C: 40810054  ble 0x825b9290
	if !ctx.cr[0].gt {
	pc = 0x825B9290; continue 'dispatch;
	}
	pc = 0x825B9240; continue 'dispatch;
            }
            0x825B9240 => {
    //   block [0x825B9240..0x825B9260)
	// 825B9240: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B9244: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B9248: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B924C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9250: 2F070012  cmpwi cr6, r7, 0x12
	ctx.cr[6].compare_i32(ctx.r[7].s32, 18, &mut ctx.xer);
	// 825B9254: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B9258: 41980008  blt cr6, 0x825b9260
	if ctx.cr[6].lt {
	pc = 0x825B9260; continue 'dispatch;
	}
	// 825B925C: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x825B9260; continue 'dispatch;
            }
            0x825B9260 => {
    //   block [0x825B9260..0x825B927C)
	// 825B9260: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B9264: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B9268: 419A0014  beq cr6, 0x825b927c
	if ctx.cr[6].eq {
	pc = 0x825B927C; continue 'dispatch;
	}
	// 825B926C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B9270: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B9274: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B9278: 4800000C  b 0x825b9284
	pc = 0x825B9284; continue 'dispatch;
            }
            0x825B927C => {
    //   block [0x825B927C..0x825B9284)
	// 825B927C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B9280: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B9284; continue 'dispatch;
            }
            0x825B9284 => {
    //   block [0x825B9284..0x825B9290)
	// 825B9284: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B9288: 4199FFB8  bgt cr6, 0x825b9240
	if ctx.cr[6].gt {
	pc = 0x825B9240; continue 'dispatch;
	}
	// 825B928C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B9290; continue 'dispatch;
            }
            0x825B9290 => {
    //   block [0x825B9290..0x825B92AC)
	// 825B9290: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B9294: 419A0040  beq cr6, 0x825b92d4
	if ctx.cr[6].eq {
	pc = 0x825B92D4; continue 'dispatch;
	}
	// 825B9298: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B929C: 2F0B0012  cmpwi cr6, r11, 0x12
	ctx.cr[6].compare_i32(ctx.r[11].s32, 18, &mut ctx.xer);
	// 825B92A0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B92A4: 41990008  bgt cr6, 0x825b92ac
	if ctx.cr[6].gt {
	pc = 0x825B92AC; continue 'dispatch;
	}
	// 825B92A8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825B92AC; continue 'dispatch;
            }
            0x825B92AC => {
    //   block [0x825B92AC..0x825B92D4)
	// 825B92AC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B92B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B92B4: 409A0020  bne cr6, 0x825b92d4
	if !ctx.cr[6].eq {
	pc = 0x825B92D4; continue 'dispatch;
	}
	// 825B92B8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B92BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B92C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B92C4: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B92C8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B92CC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B92D0: 4800001C  b 0x825b92ec
	pc = 0x825B92EC; continue 'dispatch;
            }
            0x825B92D4 => {
    //   block [0x825B92D4..0x825B92E8)
	// 825B92D4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B92D8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B92DC: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B92E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B92E4: 48000008  b 0x825b92ec
	pc = 0x825B92EC; continue 'dispatch;
            }
            0x825B92E8 => {
    //   block [0x825B92E8..0x825B92EC)
	// 825B92E8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825B92EC; continue 'dispatch;
            }
            0x825B92EC => {
    //   block [0x825B92EC..0x825B92FC)
	// 825B92EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B92F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B92F4: 419A0008  beq cr6, 0x825b92fc
	if ctx.cr[6].eq {
	pc = 0x825B92FC; continue 'dispatch;
	}
	// 825B92F8: 4815C0D1  bl 0x827153c8
	ctx.lr = 0x825B92FC;
	sub_827153C8(ctx, base);
	pc = 0x825B92FC; continue 'dispatch;
            }
            0x825B92FC => {
    //   block [0x825B92FC..0x825B9304)
	// 825B92FC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B9300: 486F0158  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9308(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9308 size=248
    let mut pc: u32 = 0x825B9308;
    'dispatch: loop {
        match pc {
            0x825B9308 => {
    //   block [0x825B9308..0x825B935C)
	// 825B9308: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B930C: 486F00F9  bl 0x82ca9404
	ctx.lr = 0x825B9310;
	sub_82CA93D0(ctx, base);
	// 825B9310: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9314: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825B9318: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B931C: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B9320: 815B0014  lwz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B9324: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9328: 5528003A  rlwinm r8, r9, 0, 0, 0x1d
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 825B932C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B9330: 419A00C4  beq cr6, 0x825b93f4
	if ctx.cr[6].eq {
	pc = 0x825B93F4; continue 'dispatch;
	}
	// 825B9334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 825B9338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825B933C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9340: 4BC28869  bl 0x821e1ba8
	ctx.lr = 0x825B9344;
	sub_821E1BA8(ctx, base);
	// 825B9344: 817B0018  lwz r11, 0x18(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B9348: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 825B934C: 83DB0014  lwz r30, 0x14(r27)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B9350: 7F1E5840  cmplw cr6, r30, r11
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9354: 419A0094  beq cr6, 0x825b93e8
	if ctx.cr[6].eq {
	pc = 0x825B93E8; continue 'dispatch;
	}
	// 825B9358: 3B800003  li r28, 3
	ctx.r[28].s64 = 3;
	pc = 0x825B935C; continue 'dispatch;
            }
            0x825B935C => {
    //   block [0x825B935C..0x825B93E8)
	// 825B935C: 7FAB07B4  extsw r11, r29
	ctx.r[11].s64 = ctx.r[29].s32 as i64;
	// 825B9360: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9364: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9368: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B936C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9370: FDA0069C  fcfid f13, f0
	ctx.f[13].f64 = (ctx.f[0].s64 as f64);
	// 825B9374: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 825B9378: D18A0000  stfs f12, 0(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B937C: 938A0004  stw r28, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825B9380: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9384: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B9388: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B938C: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9390: 7D2807B4  extsw r8, r9
	ctx.r[8].s64 = ctx.r[9].s32 as i64;
	// 825B9394: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 825B9398: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B939C: FD405E9C  fcfid f10, f11
	ctx.f[10].f64 = (ctx.f[11].s64 as f64);
	// 825B93A0: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825B93A4: FD205018  frsp f9, f10
	ctx.f[9].f64 = (ctx.f[10].f64 as f32) as f64;
	// 825B93A8: D12B0000  stfs f9, 0(r11)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B93AC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B93B0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B93B4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B93B8: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 825B93BC: 38CBFFF8  addi r6, r11, -8
	ctx.r[6].s64 = ctx.r[11].s64 + -8;
	// 825B93C0: 38ABFFF0  addi r5, r11, -0x10
	ctx.r[5].s64 = ctx.r[11].s64 + -16;
	// 825B93C4: 4BC6F965  bl 0x82228d28
	ctx.lr = 0x825B93C8;
	sub_82228D28(ctx, base);
	// 825B93C8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B93CC: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825B93D0: 38EBFFF0  addi r7, r11, -0x10
	ctx.r[7].s64 = ctx.r[11].s64 + -16;
	// 825B93D4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825B93D8: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825B93DC: 80DB0018  lwz r6, 0x18(r27)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B93E0: 7F1E3040  cmplw cr6, r30, r6
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B93E4: 409AFF78  bne cr6, 0x825b935c
	if !ctx.cr[6].eq {
	pc = 0x825B935C; continue 'dispatch;
	}
	pc = 0x825B93E8; continue 'dispatch;
            }
            0x825B93E8 => {
    //   block [0x825B93E8..0x825B93F4)
	// 825B93E8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825B93EC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B93F0: 486F0064  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825B93F4 => {
    //   block [0x825B93F4..0x825B9400)
	// 825B93F4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825B93F8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B93FC: 486F0058  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9400(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9400 size=320
    let mut pc: u32 = 0x825B9400;
    'dispatch: loop {
        match pc {
            0x825B9400 => {
    //   block [0x825B9400..0x825B9444)
	// 825B9400: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9404: 486F0001  bl 0x82ca9404
	ctx.lr = 0x825B9408;
	sub_82CA93D0(ctx, base);
	// 825B9408: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B940C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825B9410: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825B9414: 812B0014  lwz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825B9418: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825B941C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9420: 419A003C  beq cr6, 0x825b945c
	if ctx.cr[6].eq {
	pc = 0x825B945C; continue 'dispatch;
	}
	// 825B9424: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B9428: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B942C: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B9430: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9434: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B9438: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B943C: 419A001C  beq cr6, 0x825b9458
	if ctx.cr[6].eq {
	pc = 0x825B9458; continue 'dispatch;
	}
	// 825B9440: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B9444; continue 'dispatch;
            }
            0x825B9444 => {
    //   block [0x825B9444..0x825B9458)
	// 825B9444: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9448: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 825B944C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B9450: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9454: 409AFFF0  bne cr6, 0x825b9444
	if !ctx.cr[6].eq {
	pc = 0x825B9444; continue 'dispatch;
	}
	pc = 0x825B9458; continue 'dispatch;
            }
            0x825B9458 => {
    //   block [0x825B9458..0x825B945C)
	// 825B9458: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B945C; continue 'dispatch;
            }
            0x825B945C => {
    //   block [0x825B945C..0x825B94A0)
	// 825B945C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B9460: 419A00D8  beq cr6, 0x825b9538
	if ctx.cr[6].eq {
	pc = 0x825B9538; continue 'dispatch;
	}
	// 825B9464: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B9468: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B946C: 388B56FC  addi r4, r11, 0x56fc
	ctx.r[4].s64 = ctx.r[11].s64 + 22268;
	// 825B9470: 4BCF0579  bl 0x822a99e8
	ctx.lr = 0x825B9474;
	sub_822A99E8(ctx, base);
	// 825B9474: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B9478: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825B947C: 419A00BC  beq cr6, 0x825b9538
	if ctx.cr[6].eq {
	pc = 0x825B9538; continue 'dispatch;
	}
	// 825B9480: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B9484: 4844750D  bl 0x82a00990
	ctx.lr = 0x825B9488;
	sub_82A00990(ctx, base);
	// 825B9488: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 825B948C: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825B9490: 83A10058  lwz r29, 0x58(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825B9494: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825B9498: 419A0098  beq cr6, 0x825b9530
	if ctx.cr[6].eq {
	pc = 0x825B9530; continue 'dispatch;
	}
	// 825B949C: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825B94A0; continue 'dispatch;
            }
            0x825B94A0 => {
    //   block [0x825B94A0..0x825B94D0)
	// 825B94A0: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B94A4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B94A8: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825B94AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B94B0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B94B4: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825B94B8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B94BC: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B94C0: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825B94C4: 409A000C  bne cr6, 0x825b94d0
	if !ctx.cr[6].eq {
	pc = 0x825B94D0; continue 'dispatch;
	}
	// 825B94C8: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 825B94CC: 48000010  b 0x825b94dc
	pc = 0x825B94DC; continue 'dispatch;
            }
            0x825B94D0 => {
    //   block [0x825B94D0..0x825B94DC)
	// 825B94D0: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B94D4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B94D8: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x825B94DC; continue 'dispatch;
            }
            0x825B94DC => {
    //   block [0x825B94DC..0x825B94FC)
	// 825B94DC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B94E0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B94E4: 7D671670  srawi r7, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825B94E8: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B94EC: 4098001C  bge cr6, 0x825b9508
	if !ctx.cr[6].lt {
	pc = 0x825B9508; continue 'dispatch;
	}
	// 825B94F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B94F4: 419A0008  beq cr6, 0x825b94fc
	if ctx.cr[6].eq {
	pc = 0x825B94FC; continue 'dispatch;
	}
	// 825B94F8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	pc = 0x825B94FC; continue 'dispatch;
            }
            0x825B94FC => {
    //   block [0x825B94FC..0x825B9508)
	// 825B94FC: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 825B9500: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9504: 48000020  b 0x825b9524
	pc = 0x825B9524; continue 'dispatch;
            }
            0x825B9508 => {
    //   block [0x825B9508..0x825B9524)
	// 825B9508: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B950C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B9510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9514: 93810058  stw r28, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u32 ) };
	// 825B9518: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B951C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B9520: 4BF2F621  bl 0x824e8b40
	ctx.lr = 0x825B9524;
	sub_824E8B40(ctx, base);
	pc = 0x825B9524; continue 'dispatch;
            }
            0x825B9524 => {
    //   block [0x825B9524..0x825B9530)
	// 825B9524: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 825B9528: 7F1ED840  cmplw cr6, r30, r27
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825B952C: 409AFF74  bne cr6, 0x825b94a0
	if !ctx.cr[6].eq {
	pc = 0x825B94A0; continue 'dispatch;
	}
	pc = 0x825B9530; continue 'dispatch;
            }
            0x825B9530 => {
    //   block [0x825B9530..0x825B9538)
	// 825B9530: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B9534: 4BC62805  bl 0x8221bd38
	ctx.lr = 0x825B9538;
	sub_8221BD38(ctx, base);
	pc = 0x825B9538; continue 'dispatch;
            }
            0x825B9538 => {
    //   block [0x825B9538..0x825B9540)
	// 825B9538: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825B953C: 486EFF18  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9540(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9540 size=392
    let mut pc: u32 = 0x825B9540;
    'dispatch: loop {
        match pc {
            0x825B9540 => {
    //   block [0x825B9540..0x825B9594)
	// 825B9540: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9544: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9548: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B954C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B9554: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B9558: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B955C: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 825B9560: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 825B9564: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825B9568: 419A00EC  beq cr6, 0x825b9654
	if ctx.cr[6].eq {
	pc = 0x825B9654; continue 'dispatch;
	}
	// 825B956C: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B9570: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9574: 419A0020  beq cr6, 0x825b9594
	if ctx.cr[6].eq {
	pc = 0x825B9594; continue 'dispatch;
	}
	// 825B9578: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 825B957C: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B9580: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825B9584: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B9588: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B958C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9590: 480000C8  b 0x825b9658
	pc = 0x825B9658; continue 'dispatch;
            }
            0x825B9594 => {
    //   block [0x825B9594..0x825B95B4)
	// 825B9594: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825B9598: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B959C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 825B95A0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B95A4: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825B95A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B95AC: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B95B0: 40810054  ble 0x825b9604
	if !ctx.cr[0].gt {
	pc = 0x825B9604; continue 'dispatch;
	}
	pc = 0x825B95B4; continue 'dispatch;
            }
            0x825B95B4 => {
    //   block [0x825B95B4..0x825B95D4)
	// 825B95B4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825B95B8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B95BC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825B95C0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B95C4: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 825B95C8: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825B95CC: 41980008  blt cr6, 0x825b95d4
	if ctx.cr[6].lt {
	pc = 0x825B95D4; continue 'dispatch;
	}
	// 825B95D0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825B95D4; continue 'dispatch;
            }
            0x825B95D4 => {
    //   block [0x825B95D4..0x825B95F0)
	// 825B95D4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825B95D8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825B95DC: 419A0014  beq cr6, 0x825b95f0
	if ctx.cr[6].eq {
	pc = 0x825B95F0; continue 'dispatch;
	}
	// 825B95E0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B95E4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825B95E8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825B95EC: 4800000C  b 0x825b95f8
	pc = 0x825B95F8; continue 'dispatch;
            }
            0x825B95F0 => {
    //   block [0x825B95F0..0x825B95F8)
	// 825B95F0: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825B95F4: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825B95F8; continue 'dispatch;
            }
            0x825B95F8 => {
    //   block [0x825B95F8..0x825B9604)
	// 825B95F8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825B95FC: 4199FFB8  bgt cr6, 0x825b95b4
	if ctx.cr[6].gt {
	pc = 0x825B95B4; continue 'dispatch;
	}
	// 825B9600: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825B9604; continue 'dispatch;
            }
            0x825B9604 => {
    //   block [0x825B9604..0x825B9620)
	// 825B9604: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825B9608: 419A003C  beq cr6, 0x825b9644
	if ctx.cr[6].eq {
	pc = 0x825B9644; continue 'dispatch;
	}
	// 825B960C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9610: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 825B9614: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825B9618: 41990008  bgt cr6, 0x825b9620
	if ctx.cr[6].gt {
	pc = 0x825B9620; continue 'dispatch;
	}
	// 825B961C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825B9620; continue 'dispatch;
            }
            0x825B9620 => {
    //   block [0x825B9620..0x825B9644)
	// 825B9620: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825B9624: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9628: 409A001C  bne cr6, 0x825b9644
	if !ctx.cr[6].eq {
	pc = 0x825B9644; continue 'dispatch;
	}
	// 825B962C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9630: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B9634: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B9638: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825B963C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9640: 48000018  b 0x825b9658
	pc = 0x825B9658; continue 'dispatch;
            }
            0x825B9644 => {
    //   block [0x825B9644..0x825B9654)
	// 825B9644: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825B9648: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825B964C: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9650: 48000008  b 0x825b9658
	pc = 0x825B9658; continue 'dispatch;
            }
            0x825B9654 => {
    //   block [0x825B9654..0x825B9658)
	// 825B9654: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825B9658; continue 'dispatch;
            }
            0x825B9658 => {
    //   block [0x825B9658..0x825B96B4)
	// 825B9658: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825B965C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9660: 419A0054  beq cr6, 0x825b96b4
	if ctx.cr[6].eq {
	pc = 0x825B96B4; continue 'dispatch;
	}
	// 825B9664: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825B9668: 4BC5B491  bl 0x82214af8
	ctx.lr = 0x825B966C;
	sub_82214AF8(ctx, base);
	// 825B966C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B9670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9674: 419A0040  beq cr6, 0x825b96b4
	if ctx.cr[6].eq {
	pc = 0x825B96B4; continue 'dispatch;
	}
	// 825B9678: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825B967C: 814400B4  lwz r10, 0xb4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) } as u64;
	// 825B9680: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825B9684: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825B9688: 39099BEC  addi r8, r9, -0x6414
	ctx.r[8].s64 = ctx.r[9].s64 + -25620;
	// 825B968C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825B9690: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B9694: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825B9698: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B969C: 83E7008C  lwz r31, 0x8c(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 825B96A0: 4BBF8CF1  bl 0x821b2390
	ctx.lr = 0x825B96A4;
	sub_821B2390(ctx, base);
	// 825B96A4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825B96A8: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B96AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B96B0: 4BF1A5F9  bl 0x824d3ca8
	ctx.lr = 0x825B96B4;
	sub_824D3CA8(ctx, base);
	pc = 0x825B96B4; continue 'dispatch;
            }
            0x825B96B4 => {
    //   block [0x825B96B4..0x825B96C8)
	// 825B96B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B96B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B96BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B96C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B96C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B96C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B96C8 size=80
    let mut pc: u32 = 0x825B96C8;
    'dispatch: loop {
        match pc {
            0x825B96C8 => {
    //   block [0x825B96C8..0x825B9704)
	// 825B96C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B96CC: 486EFD41  bl 0x82ca940c
	ctx.lr = 0x825B96D0;
	sub_82CA93D0(ctx, base);
	// 825B96D0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B96D4: 83A40004  lwz r29, 4(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B96D8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B96DC: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825B96E0: 419A0030  beq cr6, 0x825b9710
	if ctx.cr[6].eq {
	pc = 0x825B9710; continue 'dispatch;
	}
	// 825B96E4: 80BE0094  lwz r5, 0x94(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) } as u64;
	// 825B96E8: 3BFE0090  addi r31, r30, 0x90
	ctx.r[31].s64 = ctx.r[30].s64 + 144;
	// 825B96EC: 809E0098  lwz r4, 0x98(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(152 as u32) ) } as u64;
	// 825B96F0: 7F052040  cmplw cr6, r5, r4
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825B96F4: 419A0010  beq cr6, 0x825b9704
	if ctx.cr[6].eq {
	pc = 0x825B9704; continue 'dispatch;
	}
	// 825B96F8: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825B96FC: 48002CED  bl 0x825bc3e8
	ctx.lr = 0x825B9700;
	sub_825BC3E8(ctx, base);
	// 825B9700: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	pc = 0x825B9704; continue 'dispatch;
            }
            0x825B9704 => {
    //   block [0x825B9704..0x825B9710)
	// 825B9704: 93BE00B4  stw r29, 0xb4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), ctx.r[29].u32 ) };
	// 825B9708: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B970C: 4BFFF3C5  bl 0x825b8ad0
	ctx.lr = 0x825B9710;
	sub_825B8AD0(ctx, base);
	pc = 0x825B9710; continue 'dispatch;
            }
            0x825B9710 => {
    //   block [0x825B9710..0x825B9718)
	// 825B9710: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9714: 486EFD48  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9718(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9718 size=424
    let mut pc: u32 = 0x825B9718;
    'dispatch: loop {
        match pc {
            0x825B9718 => {
    //   block [0x825B9718..0x825B98C0)
	// 825B9718: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B971C: 486EFCF1  bl 0x82ca940c
	ctx.lr = 0x825B9720;
	sub_82CA93D0(ctx, base);
	// 825B9720: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9724: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825B9728: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B972C: 3BAB5710  addi r29, r11, 0x5710
	ctx.r[29].s64 = ctx.r[11].s64 + 22288;
	// 825B9730: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9738: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B973C: 4BC73795  bl 0x8222ced0
	ctx.lr = 0x825B9740;
	sub_8222CED0(ctx, base);
	// 825B9740: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B9744: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B9748: 48002639  bl 0x825bbd80
	ctx.lr = 0x825B974C;
	sub_825BBD80(ctx, base);
	// 825B974C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9750: 4BC5B689  bl 0x82214dd8
	ctx.lr = 0x825B9754;
	sub_82214DD8(ctx, base);
	// 825B9754: 3D40825B  lis r10, -0x7da5
	ctx.r[10].s64 = -2107965440;
	// 825B9758: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825B975C: 390A5EE8  addi r8, r10, 0x5ee8
	ctx.r[8].s64 = ctx.r[10].s64 + 24296;
	// 825B9760: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 825B9764: 38895728  addi r4, r9, 0x5728
	ctx.r[4].s64 = ctx.r[9].s64 + 22312;
	// 825B9768: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825B976C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9770: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825B9774: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B9778: 4BC73759  bl 0x8222ced0
	ctx.lr = 0x825B977C;
	sub_8222CED0(ctx, base);
	// 825B977C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B9780: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9788: 4BC73749  bl 0x8222ced0
	ctx.lr = 0x825B978C;
	sub_8222CED0(ctx, base);
	// 825B978C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B9790: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825B9794: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B9798: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825B979C: 4BFBDE05  bl 0x825775a0
	ctx.lr = 0x825B97A0;
	sub_825775A0(ctx, base);
	// 825B97A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B97A4: 4BC5B635  bl 0x82214dd8
	ctx.lr = 0x825B97A8;
	sub_82214DD8(ctx, base);
	// 825B97A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B97AC: 4BC5B62D  bl 0x82214dd8
	ctx.lr = 0x825B97B0;
	sub_82214DD8(ctx, base);
	// 825B97B0: 3CE08235  lis r7, -0x7dcb
	ctx.r[7].s64 = -2110455808;
	// 825B97B4: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825B97B8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825B97BC: 38671618  addi r3, r7, 0x1618
	ctx.r[3].s64 = ctx.r[7].s64 + 5656;
	// 825B97C0: 3886573C  addi r4, r6, 0x573c
	ctx.r[4].s64 = ctx.r[6].s64 + 22332;
	// 825B97C4: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825B97C8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B97CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B97D0: 4BC73701  bl 0x8222ced0
	ctx.lr = 0x825B97D4;
	sub_8222CED0(ctx, base);
	// 825B97D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B97D8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B97DC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B97E0: 4BC736F1  bl 0x8222ced0
	ctx.lr = 0x825B97E4;
	sub_8222CED0(ctx, base);
	// 825B97E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B97E8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B97EC: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B97F0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825B97F4: 480027D5  bl 0x825bbfc8
	ctx.lr = 0x825B97F8;
	sub_825BBFC8(ctx, base);
	// 825B97F8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B97FC: 4BC5B5DD  bl 0x82214dd8
	ctx.lr = 0x825B9800;
	sub_82214DD8(ctx, base);
	// 825B9800: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9804: 4BC5B5D5  bl 0x82214dd8
	ctx.lr = 0x825B9808;
	sub_82214DD8(ctx, base);
	// 825B9808: 3D60825B  lis r11, -0x7da5
	ctx.r[11].s64 = -2107965440;
	// 825B980C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825B9810: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825B9814: 392B60F8  addi r9, r11, 0x60f8
	ctx.r[9].s64 = ctx.r[11].s64 + 24824;
	// 825B9818: 388A5758  addi r4, r10, 0x5758
	ctx.r[4].s64 = ctx.r[10].s64 + 22360;
	// 825B981C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9820: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B9824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9828: 4BC736A9  bl 0x8222ced0
	ctx.lr = 0x825B982C;
	sub_8222CED0(ctx, base);
	// 825B982C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B9830: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9834: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B9838: 4BC73699  bl 0x8222ced0
	ctx.lr = 0x825B983C;
	sub_8222CED0(ctx, base);
	// 825B983C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B9840: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825B9844: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B9848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B984C: 4800298D  bl 0x825bc1d8
	ctx.lr = 0x825B9850;
	sub_825BC1D8(ctx, base);
	// 825B9850: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B9854: 4BC5B585  bl 0x82214dd8
	ctx.lr = 0x825B9858;
	sub_82214DD8(ctx, base);
	// 825B9858: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B985C: 4BC5B57D  bl 0x82214dd8
	ctx.lr = 0x825B9860;
	sub_82214DD8(ctx, base);
	// 825B9860: 3D00825C  lis r8, -0x7da4
	ctx.r[8].s64 = -2107899904;
	// 825B9864: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825B9868: 38C88AD0  addi r6, r8, -0x7530
	ctx.r[6].s64 = ctx.r[8].s64 + -30000;
	// 825B986C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825B9870: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B9874: 3887576C  addi r4, r7, 0x576c
	ctx.r[4].s64 = ctx.r[7].s64 + 22380;
	// 825B9878: 90C10058  stw r6, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u32 ) };
	// 825B987C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B9880: 4BC73651  bl 0x8222ced0
	ctx.lr = 0x825B9884;
	sub_8222CED0(ctx, base);
	// 825B9884: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B9888: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825B988C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B9890: 4BC73641  bl 0x8222ced0
	ctx.lr = 0x825B9894;
	sub_8222CED0(ctx, base);
	// 825B9894: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825B9898: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 825B989C: E8C10058  ld r6, 0x58(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B98A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B98A4: 48002935  bl 0x825bc1d8
	ctx.lr = 0x825B98A8;
	sub_825BC1D8(ctx, base);
	// 825B98A8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825B98AC: 4BC5B52D  bl 0x82214dd8
	ctx.lr = 0x825B98B0;
	sub_82214DD8(ctx, base);
	// 825B98B0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825B98B4: 4BC5B525  bl 0x82214dd8
	ctx.lr = 0x825B98B8;
	sub_82214DD8(ctx, base);
	// 825B98B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B98BC: 486EFBA0  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B98C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B98C0 size=148
    let mut pc: u32 = 0x825B98C0;
    'dispatch: loop {
        match pc {
            0x825B98C0 => {
    //   block [0x825B98C0..0x825B98E4)
	// 825B98C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B98C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B98C8: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B98CC: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B98D0: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B98D4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B98D8: 409A000C  bne cr6, 0x825b98e4
	if !ctx.cr[6].eq {
	pc = 0x825B98E4; continue 'dispatch;
	}
	// 825B98DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B98E0: 48000010  b 0x825b98f0
	pc = 0x825B98F0; continue 'dispatch;
            }
            0x825B98E4 => {
    //   block [0x825B98E4..0x825B98F0)
	// 825B98E4: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B98E8: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B98EC: 7D291670  srawi r9, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x825B98F0; continue 'dispatch;
            }
            0x825B98F0 => {
    //   block [0x825B98F0..0x825B9914)
	// 825B98F0: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B98F4: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B98F8: 7D481670  srawi r8, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825B98FC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B9900: 4098002C  bge cr6, 0x825b992c
	if !ctx.cr[6].lt {
	pc = 0x825B992C; continue 'dispatch;
	}
	// 825B9904: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9908: 419A000C  beq cr6, 0x825b9914
	if ctx.cr[6].eq {
	pc = 0x825B9914; continue 'dispatch;
	}
	// 825B990C: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9910: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	pc = 0x825B9914; continue 'dispatch;
            }
            0x825B9914 => {
    //   block [0x825B9914..0x825B992C)
	// 825B9914: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825B9918: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B991C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B9920: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9924: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9928: 4E800020  blr
	return;
            }
            0x825B992C => {
    //   block [0x825B992C..0x825B9954)
	// 825B992C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B9930: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9934: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9938: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B993C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9940: 48000E11  bl 0x825ba750
	ctx.lr = 0x825B9944;
	sub_825BA750(ctx, base);
	// 825B9944: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B9948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B994C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9950: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9958(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9958 size=180
    let mut pc: u32 = 0x825B9958;
    'dispatch: loop {
        match pc {
            0x825B9958 => {
    //   block [0x825B9958..0x825B99A8)
	// 825B9958: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B995C: 486EFAA5  bl 0x82ca9400
	ctx.lr = 0x825B9960;
	sub_82CA93D0(ctx, base);
	// 825B9960: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9964: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825B9968: 817A0004  lwz r11, 4(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B996C: 83BA0008  lwz r29, 8(r26)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9970: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B9974: 419A0090  beq cr6, 0x825b9a04
	if ctx.cr[6].eq {
	pc = 0x825B9A04; continue 'dispatch;
	}
	// 825B9978: 39200018  li r9, 0x18
	ctx.r[9].s64 = 24;
	// 825B997C: 7D5DE850  subf r10, r29, r29
	ctx.r[10].s64 = ctx.r[29].s64 - ctx.r[29].s64;
	// 825B9980: 7F1DE840  cmplw cr6, r29, r29
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B9984: 7D4A4BD6  divw r10, r10, r9
	ctx.r[10].s32 = ctx.r[10].s32 / ctx.r[9].s32;
	// 825B9988: 5549083C  slwi r9, r10, 1
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825B998C: 7D0A4A14  add r8, r10, r9
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B9990: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B9994: 7F6A5A14  add r27, r10, r11
	ctx.r[27].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B9998: 419A0058  beq cr6, 0x825b99f0
	if ctx.cr[6].eq {
	pc = 0x825B99F0; continue 'dispatch;
	}
	// 825B999C: 3BDD0014  addi r30, r29, 0x14
	ctx.r[30].s64 = ctx.r[29].s64 + 20;
	// 825B99A0: 3BEB0010  addi r31, r11, 0x10
	ctx.r[31].s64 = ctx.r[11].s64 + 16;
	// 825B99A4: 7F8BE850  subf r28, r11, r29
	ctx.r[28].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	pc = 0x825B99A8; continue 'dispatch;
            }
            0x825B99A8 => {
    //   block [0x825B99A8..0x825B99F0)
	// 825B99A8: 817EFFEC  lwz r11, -0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825B99AC: 389EFFF0  addi r4, r30, -0x10
	ctx.r[4].s64 = ctx.r[30].s64 + -16;
	// 825B99B0: 387FFFF4  addi r3, r31, -0xc
	ctx.r[3].s64 = ctx.r[31].s64 + -12;
	// 825B99B4: 917FFFF0  stw r11, -0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-16 as u32), ctx.r[11].u32 ) };
	// 825B99B8: 4BF103C1  bl 0x824c9d78
	ctx.lr = 0x825B99BC;
	sub_824C9D78(ctx, base);
	// 825B99BC: 7D5CF82E  lwzx r10, r28, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 825B99C0: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B99C4: 893E0000  lbz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B99C8: 993F0004  stb r9, 4(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 825B99CC: 891E0001  lbz r8, 1(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(1 as u32) ) } as u64;
	// 825B99D0: 991F0005  stb r8, 5(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 825B99D4: 88FE0002  lbz r7, 2(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(2 as u32) ) } as u64;
	// 825B99D8: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 825B99DC: 98FF0006  stb r7, 6(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(6 as u32), ctx.r[7].u8 ) };
	// 825B99E0: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 825B99E4: 38DEFFEC  addi r6, r30, -0x14
	ctx.r[6].s64 = ctx.r[30].s64 + -20;
	// 825B99E8: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825B99EC: 409AFFBC  bne cr6, 0x825b99a8
	if !ctx.cr[6].eq {
	pc = 0x825B99A8; continue 'dispatch;
	}
	pc = 0x825B99F0; continue 'dispatch;
            }
            0x825B99F0 => {
    //   block [0x825B99F0..0x825B9A04)
	// 825B99F0: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825B99F4: 80BA0008  lwz r5, 8(r26)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B99F8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825B99FC: 4BF0D6B5  bl 0x824c70b0
	ctx.lr = 0x825B9A00;
	sub_824C70B0(ctx, base);
	// 825B9A00: 937A0008  stw r27, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	pc = 0x825B9A04; continue 'dispatch;
            }
            0x825B9A04 => {
    //   block [0x825B9A04..0x825B9A0C)
	// 825B9A04: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825B9A08: 486EFA48  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9A10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9A10 size=180
    let mut pc: u32 = 0x825B9A10;
    'dispatch: loop {
        match pc {
            0x825B9A10 => {
    //   block [0x825B9A10..0x825B9A68)
	// 825B9A10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9A14: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9A18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9A1C: 81230004  lwz r9, 4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9A20: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 825B9A24: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9A28: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B9A2C: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B9A30: 7D0A1670  srawi r10, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B9A34: 7F045040  cmplw cr6, r4, r10
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B9A38: 40990030  ble cr6, 0x825b9a68
	if !ctx.cr[6].gt {
	pc = 0x825B9A68; continue 'dispatch;
	}
	// 825B9A3C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B9A40: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825B9A44: 7CAA2050  subf r5, r10, r4
	ctx.r[5].s64 = ctx.r[4].s64 - ctx.r[10].s64;
	// 825B9A48: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825B9A4C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825B9A50: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B9A54: 48000CFD  bl 0x825ba750
	ctx.lr = 0x825B9A58;
	sub_825BA750(ctx, base);
	// 825B9A58: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9A5C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9A60: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9A64: 4E800020  blr
	return;
            }
            0x825B9A68 => {
    //   block [0x825B9A68..0x825B9A9C)
	// 825B9A68: 4098004C  bge cr6, 0x825b9ab4
	if !ctx.cr[6].lt {
	pc = 0x825B9AB4; continue 'dispatch;
	}
	// 825B9A6C: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B9A70: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825B9A74: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9A78: 419A003C  beq cr6, 0x825b9ab4
	if ctx.cr[6].eq {
	pc = 0x825B9AB4; continue 'dispatch;
	}
	// 825B9A7C: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825B9A80: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825B9A84: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825B9A88: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9A8C: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825B9A90: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825B9A94: 419A001C  beq cr6, 0x825b9ab0
	if ctx.cr[6].eq {
	pc = 0x825B9AB0; continue 'dispatch;
	}
	// 825B9A98: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825B9A9C; continue 'dispatch;
            }
            0x825B9A9C => {
    //   block [0x825B9A9C..0x825B9AB0)
	// 825B9A9C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9AA0: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 825B9AA4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825B9AA8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825B9AAC: 409AFFF0  bne cr6, 0x825b9a9c
	if !ctx.cr[6].eq {
	pc = 0x825B9A9C; continue 'dispatch;
	}
	pc = 0x825B9AB0; continue 'dispatch;
            }
            0x825B9AB0 => {
    //   block [0x825B9AB0..0x825B9AB4)
	// 825B9AB0: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825B9AB4; continue 'dispatch;
            }
            0x825B9AB4 => {
    //   block [0x825B9AB4..0x825B9AC4)
	// 825B9AB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9AC8 size=232
    let mut pc: u32 = 0x825B9AC8;
    'dispatch: loop {
        match pc {
            0x825B9AC8 => {
    //   block [0x825B9AC8..0x825B9AF0)
	// 825B9AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9AD0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9AD4: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9AD8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9ADC: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 825B9AE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9AE4: 409A000C  bne cr6, 0x825b9af0
	if !ctx.cr[6].eq {
	pc = 0x825B9AF0; continue 'dispatch;
	}
	// 825B9AE8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B9AEC: 48000010  b 0x825b9afc
	pc = 0x825B9AFC; continue 'dispatch;
            }
            0x825B9AF0 => {
    //   block [0x825B9AF0..0x825B9AFC)
	// 825B9AF0: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9AF4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B9AF8: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x825B9AFC; continue 'dispatch;
            }
            0x825B9AFC => {
    //   block [0x825B9AFC..0x825B9B44)
	// 825B9AFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9B00: 419A0078  beq cr6, 0x825b9b78
	if ctx.cr[6].eq {
	pc = 0x825B9B78; continue 'dispatch;
	}
	// 825B9B04: 8103000C  lwz r8, 0xc(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9B08: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825B9B0C: 7CA74BD6  divw r5, r7, r9
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[9].s32;
	// 825B9B10: 7F0A2840  cmplw cr6, r10, r5
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825B9B14: 40980064  bge cr6, 0x825b9b78
	if !ctx.cr[6].lt {
	pc = 0x825B9B78; continue 'dispatch;
	}
	// 825B9B18: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9B20: 419A0040  beq cr6, 0x825b9b60
	if ctx.cr[6].eq {
	pc = 0x825B9B60; continue 'dispatch;
	}
	// 825B9B24: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9B28: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B9B2C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9B30: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825B9B34: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9B38: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9B3C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825B9B40: 419A0020  beq cr6, 0x825b9b60
	if ctx.cr[6].eq {
	pc = 0x825B9B60; continue 'dispatch;
	}
	pc = 0x825B9B44; continue 'dispatch;
            }
            0x825B9B44 => {
    //   block [0x825B9B44..0x825B9B60)
	// 825B9B44: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825B9B48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B9B4C: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825B9B50: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825B9B54: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825B9B58: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825B9B5C: 4082FFE8  bne 0x825b9b44
	if !ctx.cr[0].eq {
	pc = 0x825B9B44; continue 'dispatch;
	}
	pc = 0x825B9B60; continue 'dispatch;
            }
            0x825B9B60 => {
    //   block [0x825B9B60..0x825B9B78)
	// 825B9B60: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825B9B64: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9B68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9B6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9B70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9B74: 4E800020  blr
	return;
            }
            0x825B9B78 => {
    //   block [0x825B9B78..0x825B9B88)
	// 825B9B78: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9B7C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B9B80: 40990008  ble cr6, 0x825b9b88
	if !ctx.cr[6].gt {
	pc = 0x825B9B88; continue 'dispatch;
	}
	// 825B9B84: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825B9B88; continue 'dispatch;
            }
            0x825B9B88 => {
    //   block [0x825B9B88..0x825B9BB0)
	// 825B9B88: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825B9B8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B9B90: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B9B94: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825B9B98: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9B9C: 480004AD  bl 0x825ba048
	ctx.lr = 0x825B9BA0;
	sub_825BA048(ctx, base);
	// 825B9BA0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9BA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9BA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9BAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9BB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9BB0 size=116
    let mut pc: u32 = 0x825B9BB0;
    'dispatch: loop {
        match pc {
            0x825B9BB0 => {
    //   block [0x825B9BB0..0x825B9C0C)
	// 825B9BB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9BB4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9BB8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B9BBC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B9BC0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9BC4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B9BC8: 897F0011  lbz r11, 0x11(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 825B9BCC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9BD0: 419A003C  beq cr6, 0x825b9c0c
	if ctx.cr[6].eq {
	pc = 0x825B9C0C; continue 'dispatch;
	}
	// 825B9BD4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9BD8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825B9BDC: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9BE0: 93C10050  stw r30, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u32 ) };
	// 825B9BE4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9BE8: 93C10058  stw r30, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 825B9BEC: 88DF0010  lbz r6, 0x10(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B9BF0: 7D252E70  srawi r5, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 825B9BF4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9BF8: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825B9BFC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9C00: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825B9C04: 4800332D  bl 0x825bcf30
	ctx.lr = 0x825B9C08;
	sub_825BCF30(ctx, base);
	// 825B9C08: 9BDF0011  stb r30, 0x11(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(17 as u32), ctx.r[30].u8 ) };
	pc = 0x825B9C0C; continue 'dispatch;
            }
            0x825B9C0C => {
    //   block [0x825B9C0C..0x825B9C24)
	// 825B9C0C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B9C10: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9C14: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9C18: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B9C1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B9C20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9C28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9C28 size=160
    let mut pc: u32 = 0x825B9C28;
    'dispatch: loop {
        match pc {
            0x825B9C28 => {
    //   block [0x825B9C28..0x825B9C4C)
	// 825B9C28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9C2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9C30: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9C34: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9C38: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9C3C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9C40: 409A000C  bne cr6, 0x825b9c4c
	if !ctx.cr[6].eq {
	pc = 0x825B9C4C; continue 'dispatch;
	}
	// 825B9C44: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B9C48: 48000010  b 0x825b9c58
	pc = 0x825B9C58; continue 'dispatch;
            }
            0x825B9C4C => {
    //   block [0x825B9C4C..0x825B9C58)
	// 825B9C4C: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9C50: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9C54: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x825B9C58; continue 'dispatch;
            }
            0x825B9C58 => {
    //   block [0x825B9C58..0x825B9C84)
	// 825B9C58: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9C5C: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9C60: 7D481E70  srawi r8, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 825B9C64: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B9C68: 40980034  bge cr6, 0x825b9c9c
	if !ctx.cr[6].lt {
	pc = 0x825B9C9C; continue 'dispatch;
	}
	// 825B9C6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9C70: 419A0014  beq cr6, 0x825b9c84
	if ctx.cr[6].eq {
	pc = 0x825B9C84; continue 'dispatch;
	}
	// 825B9C74: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825B9C78: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825B9C7C: C0060004  lfs f0, 4(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B9C80: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x825B9C84; continue 'dispatch;
            }
            0x825B9C84 => {
    //   block [0x825B9C84..0x825B9C9C)
	// 825B9C84: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825B9C88: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9C8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9C90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9C94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9C98: 4E800020  blr
	return;
            }
            0x825B9C9C => {
    //   block [0x825B9C9C..0x825B9CC8)
	// 825B9C9C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B9CA0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9CA4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825B9CA8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825B9CAC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825B9CB0: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9CB4: 48000015  bl 0x825b9cc8
	ctx.lr = 0x825B9CB8;
	sub_825B9CC8(ctx, base);
	// 825B9CB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9CBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9CC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9CC4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9CC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9CC8 size=140
    let mut pc: u32 = 0x825B9CC8;
    'dispatch: loop {
        match pc {
            0x825B9CC8 => {
    //   block [0x825B9CC8..0x825B9D04)
	// 825B9CC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9CCC: 486EF741  bl 0x82ca940c
	ctx.lr = 0x825B9CD0;
	sub_82CA93D0(ctx, base);
	// 825B9CD0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9CD4: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825B9CD8: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825B9CDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825B9CE0: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 825B9CE4: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9CE8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9CEC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B9CF0: 55280038  rlwinm r8, r9, 0, 0, 0x1c
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0xFFFFFFFFu64;
	// 825B9CF4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825B9CF8: 409A000C  bne cr6, 0x825b9d04
	if !ctx.cr[6].eq {
	pc = 0x825B9D04; continue 'dispatch;
	}
	// 825B9CFC: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B9D00: 48000010  b 0x825b9d10
	pc = 0x825B9D10; continue 'dispatch;
            }
            0x825B9D04 => {
    //   block [0x825B9D04..0x825B9D10)
	// 825B9D04: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825B9D08: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B9D0C: 7D3D1E70  srawi r29, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x825B9D10; continue 'dispatch;
            }
            0x825B9D10 => {
    //   block [0x825B9D10..0x825B9D54)
	// 825B9D10: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9D18: 48000529  bl 0x825ba240
	ctx.lr = 0x825B9D1C;
	sub_825BA240(ctx, base);
	// 825B9D1C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9D20: 57AA1838  slwi r10, r29, 3
	ctx.r[10].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825B9D24: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B9D28: 7D0A5A14  add r8, r10, r11
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825B9D2C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825B9D30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825B9D34: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9D38: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9D3C: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825B9D40: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825B9D44: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9D48: F8DE0000  std r6, 0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[6].u64 ) };
	// 825B9D4C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B9D50: 486EF70C  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9D58 size=176
    let mut pc: u32 = 0x825B9D58;
    'dispatch: loop {
        match pc {
            0x825B9D58 => {
    //   block [0x825B9D58..0x825B9D9C)
	// 825B9D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9D5C: 486EF6AD  bl 0x82ca9408
	ctx.lr = 0x825B9D60;
	sub_82CA93D0(ctx, base);
	// 825B9D60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9D64: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825B9D68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B9D6C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825B9D70: 39400024  li r10, 0x24
	ctx.r[10].s64 = 36;
	// 825B9D74: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9D78: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9D7C: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825B9D80: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825B9D84: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825B9D88: 93BF000C  stw r29, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 825B9D8C: 7C8853D7  divw. r4, r8, r10
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825B9D90: 4082000C  bne 0x825b9d9c
	if !ctx.cr[0].eq {
	pc = 0x825B9D9C; continue 'dispatch;
	}
	// 825B9D94: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825B9D98: 4800000C  b 0x825b9da4
	pc = 0x825B9DA4; continue 'dispatch;
            }
            0x825B9D9C => {
    //   block [0x825B9D9C..0x825B9DA4)
	// 825B9D9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9DA0: 48001001  bl 0x825bada0
	ctx.lr = 0x825B9DA4;
	sub_825BADA0(ctx, base);
	pc = 0x825B9DA4; continue 'dispatch;
            }
            0x825B9DA4 => {
    //   block [0x825B9DA4..0x825B9DD8)
	// 825B9DA4: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825B9DA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9DAC: 419A0050  beq cr6, 0x825b9dfc
	if ctx.cr[6].eq {
	pc = 0x825B9DFC; continue 'dispatch;
	}
	// 825B9DB0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9DB4: 839E0008  lwz r28, 8(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9DB8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825B9DBC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B9DC0: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9DC4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9DC8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9DCC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825B9DD0: 419A0028  beq cr6, 0x825b9df8
	if ctx.cr[6].eq {
	pc = 0x825B9DF8; continue 'dispatch;
	}
	// 825B9DD4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825B9DD8; continue 'dispatch;
            }
            0x825B9DD8 => {
    //   block [0x825B9DD8..0x825B9DF8)
	// 825B9DD8: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825B9DDC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825B9DE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9DE4: 4800330D  bl 0x825bd0f0
	ctx.lr = 0x825B9DE8;
	sub_825BD0F0(ctx, base);
	// 825B9DE8: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 825B9DEC: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 825B9DF0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825B9DF4: 409AFFE4  bne cr6, 0x825b9dd8
	if !ctx.cr[6].eq {
	pc = 0x825B9DD8; continue 'dispatch;
	}
	pc = 0x825B9DF8; continue 'dispatch;
            }
            0x825B9DF8 => {
    //   block [0x825B9DF8..0x825B9DFC)
	// 825B9DF8: 93BF0008  stw r29, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	pc = 0x825B9DFC; continue 'dispatch;
            }
            0x825B9DFC => {
    //   block [0x825B9DFC..0x825B9E08)
	// 825B9DFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9E00: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825B9E04: 486EF654  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9E08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9E08 size=160
    let mut pc: u32 = 0x825B9E08;
    'dispatch: loop {
        match pc {
            0x825B9E08 => {
    //   block [0x825B9E08..0x825B9E3C)
	// 825B9E08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9E0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9E10: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825B9E14: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B9E18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B9E20: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9E24: 39200024  li r9, 0x24
	ctx.r[9].s64 = 36;
	// 825B9E28: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9E2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9E30: 409A000C  bne cr6, 0x825b9e3c
	if !ctx.cr[6].eq {
	pc = 0x825B9E3C; continue 'dispatch;
	}
	// 825B9E34: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825B9E38: 48000010  b 0x825b9e48
	pc = 0x825B9E48; continue 'dispatch;
            }
            0x825B9E3C => {
    //   block [0x825B9E3C..0x825B9E48)
	// 825B9E3C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9E40: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825B9E44: 7D484BD6  divw r10, r8, r9
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x825B9E48; continue 'dispatch;
            }
            0x825B9E48 => {
    //   block [0x825B9E48..0x825B9E78)
	// 825B9E48: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9E50: 7D6BF050  subf r11, r11, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 825B9E54: 7D2B4BD6  divw r9, r11, r9
	ctx.r[9].s32 = ctx.r[11].s32 / ctx.r[9].s32;
	// 825B9E58: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825B9E5C: 4098001C  bge cr6, 0x825b9e78
	if !ctx.cr[6].lt {
	pc = 0x825B9E78; continue 'dispatch;
	}
	// 825B9E60: 7CC53378  mr r5, r6
	ctx.r[5].u64 = ctx.r[6].u64;
	// 825B9E64: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825B9E68: 48003289  bl 0x825bd0f0
	ctx.lr = 0x825B9E6C;
	sub_825BD0F0(ctx, base);
	// 825B9E6C: 397E0024  addi r11, r30, 0x24
	ctx.r[11].s64 = ctx.r[30].s64 + 36;
	// 825B9E70: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9E74: 4800001C  b 0x825b9e90
	pc = 0x825B9E90; continue 'dispatch;
            }
            0x825B9E78 => {
    //   block [0x825B9E78..0x825B9E90)
	// 825B9E78: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B9E7C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825B9E80: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9E84: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B9E88: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9E8C: 48000F95  bl 0x825bae20
	ctx.lr = 0x825B9E90;
	sub_825BAE20(ctx, base);
	pc = 0x825B9E90; continue 'dispatch;
            }
            0x825B9E90 => {
    //   block [0x825B9E90..0x825B9EA8)
	// 825B9E90: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825B9E94: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9E98: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9E9C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825B9EA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B9EA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9EA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825B9EA8 size=184
    let mut pc: u32 = 0x825B9EA8;
    'dispatch: loop {
        match pc {
            0x825B9EA8 => {
    //   block [0x825B9EA8..0x825B9ED0)
	// 825B9EA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9EAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9EB0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9EB4: 81430004  lwz r10, 4(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9EB8: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9EBC: 39000014  li r8, 0x14
	ctx.r[8].s64 = 20;
	// 825B9EC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9EC4: 409A000C  bne cr6, 0x825b9ed0
	if !ctx.cr[6].eq {
	pc = 0x825B9ED0; continue 'dispatch;
	}
	// 825B9EC8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B9ECC: 48000010  b 0x825b9edc
	pc = 0x825B9EDC; continue 'dispatch;
            }
            0x825B9ED0 => {
    //   block [0x825B9ED0..0x825B9EDC)
	// 825B9ED0: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9ED4: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9ED8: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	pc = 0x825B9EDC; continue 'dispatch;
            }
            0x825B9EDC => {
    //   block [0x825B9EDC..0x825B9F20)
	// 825B9EDC: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9EE0: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9EE4: 7D0A43D6  divw r8, r10, r8
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 825B9EE8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B9EEC: 4098004C  bge cr6, 0x825b9f38
	if !ctx.cr[6].lt {
	pc = 0x825B9F38; continue 'dispatch;
	}
	// 825B9EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825B9EF4: 419A002C  beq cr6, 0x825b9f20
	if ctx.cr[6].eq {
	pc = 0x825B9F20; continue 'dispatch;
	}
	// 825B9EF8: C0060000  lfs f0, 0(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825B9EFC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825B9F00: 81460004  lwz r10, 4(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9F04: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825B9F08: 81260008  lwz r9, 8(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9F0C: 912B0008  stw r9, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825B9F10: 8106000C  lwz r8, 0xc(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9F14: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825B9F18: 80E60010  lwz r7, 0x10(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825B9F1C: 90EB0010  stw r7, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	pc = 0x825B9F20; continue 'dispatch;
            }
            0x825B9F20 => {
    //   block [0x825B9F20..0x825B9F38)
	// 825B9F20: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825B9F24: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9F28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B9F2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9F30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9F34: 4E800020  blr
	return;
            }
            0x825B9F38 => {
    //   block [0x825B9F38..0x825B9F60)
	// 825B9F38: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825B9F3C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B9F40: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9F44: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825B9F48: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825B9F4C: 48001245  bl 0x825bb190
	ctx.lr = 0x825B9F50;
	sub_825BB190(ctx, base);
	// 825B9F50: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B9F54: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9F58: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9F5C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9F60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9F60 size=72
    let mut pc: u32 = 0x825B9F60;
    'dispatch: loop {
        match pc {
            0x825B9F60 => {
    //   block [0x825B9F60..0x825B9F84)
	// 825B9F60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9F64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9F68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B9F6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9F70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B9F74: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9F78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825B9F7C: 419A0008  beq cr6, 0x825b9f84
	if ctx.cr[6].eq {
	pc = 0x825B9F84; continue 'dispatch;
	}
	// 825B9F80: 4BC61DB9  bl 0x8221bd38
	ctx.lr = 0x825B9F84;
	sub_8221BD38(ctx, base);
	pc = 0x825B9F84; continue 'dispatch;
            }
            0x825B9F84 => {
    //   block [0x825B9F84..0x825B9FA8)
	// 825B9F84: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825B9F88: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825B9F8C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825B9F90: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825B9F94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825B9F98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825B9F9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825B9FA0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825B9FA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825B9FA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825B9FA8 size=160
    let mut pc: u32 = 0x825B9FA8;
    'dispatch: loop {
        match pc {
            0x825B9FA8 => {
    //   block [0x825B9FA8..0x825B9FD8)
	// 825B9FA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825B9FAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825B9FB0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825B9FB4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825B9FB8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825B9FBC: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825B9FC0: 39000028  li r8, 0x28
	ctx.r[8].s64 = 40;
	// 825B9FC4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825B9FC8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825B9FCC: 409A000C  bne cr6, 0x825b9fd8
	if !ctx.cr[6].eq {
	pc = 0x825B9FD8; continue 'dispatch;
	}
	// 825B9FD0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825B9FD4: 48000010  b 0x825b9fe4
	pc = 0x825B9FE4; continue 'dispatch;
            }
            0x825B9FD8 => {
    //   block [0x825B9FD8..0x825B9FE4)
	// 825B9FD8: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825B9FDC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9FE0: 7D2943D6  divw r9, r9, r8
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[8].s32;
	pc = 0x825B9FE4; continue 'dispatch;
            }
            0x825B9FE4 => {
    //   block [0x825B9FE4..0x825BA020)
	// 825B9FE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825B9FE8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825B9FEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825B9FF0: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825B9FF4: 7D0A43D6  divw r8, r10, r8
	ctx.r[8].s32 = ctx.r[10].s32 / ctx.r[8].s32;
	// 825B9FF8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825B9FFC: 40980024  bge cr6, 0x825ba020
	if !ctx.cr[6].lt {
	pc = 0x825BA020; continue 'dispatch;
	}
	// 825BA000: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BA004: 4800063D  bl 0x825ba640
	ctx.lr = 0x825BA008;
	sub_825BA640(ctx, base);
	// 825BA008: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BA00C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BA010: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BA014: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BA018: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BA01C: 4E800020  blr
	return;
            }
            0x825BA020 => {
    //   block [0x825BA020..0x825BA048)
	// 825BA020: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BA024: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BA028: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BA02C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BA030: 48001411  bl 0x825bb440
	ctx.lr = 0x825BA034;
	sub_825BB440(ctx, base);
	// 825BA034: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BA038: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BA03C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BA040: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BA044: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA048(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BA048 size=232
    let mut pc: u32 = 0x825BA048;
    'dispatch: loop {
        match pc {
            0x825BA048 => {
    //   block [0x825BA048..0x825BA084)
	// 825BA048: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA04C: 486EF3C1  bl 0x82ca940c
	ctx.lr = 0x825BA050;
	sub_82CA93D0(ctx, base);
	// 825BA050: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA054: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825BA058: 7CA42B78  mr r4, r5
	ctx.r[4].u64 = ctx.r[5].u64;
	// 825BA05C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BA060: F88100A0  std r4, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[4].u64 ) };
	// 825BA064: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA068: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA06C: 419A0018  beq cr6, 0x825ba084
	if ctx.cr[6].eq {
	pc = 0x825BA084; continue 'dispatch;
	}
	// 825BA070: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA074: 3920000C  li r9, 0xc
	ctx.r[9].s64 = 12;
	// 825BA078: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA07C: 7CE84BD7  divw. r7, r8, r9
	ctx.r[7].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	ctx.cr[0].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 825BA080: 4082000C  bne 0x825ba08c
	if !ctx.cr[0].eq {
	pc = 0x825BA08C; continue 'dispatch;
	}
	pc = 0x825BA084; continue 'dispatch;
            }
            0x825BA084 => {
    //   block [0x825BA084..0x825BA08C)
	// 825BA084: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825BA088: 48000034  b 0x825ba0bc
	pc = 0x825BA0BC; continue 'dispatch;
            }
            0x825BA08C => {
    //   block [0x825BA08C..0x825BA098)
	// 825BA08C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA090: 40990008  ble cr6, 0x825ba098
	if !ctx.cr[6].gt {
	pc = 0x825BA098; continue 'dispatch;
	}
	// 825BA094: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825BA098; continue 'dispatch;
            }
            0x825BA098 => {
    //   block [0x825BA098..0x825BA0AC)
	// 825BA098: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825BA09C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA0A0: 419A000C  beq cr6, 0x825ba0ac
	if ctx.cr[6].eq {
	pc = 0x825BA0AC; continue 'dispatch;
	}
	// 825BA0A4: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BA0A8: 419A0008  beq cr6, 0x825ba0b0
	if ctx.cr[6].eq {
	pc = 0x825BA0B0; continue 'dispatch;
	}
	pc = 0x825BA0AC; continue 'dispatch;
            }
            0x825BA0AC => {
    //   block [0x825BA0AC..0x825BA0B0)
	// 825BA0AC: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825BA0B0; continue 'dispatch;
            }
            0x825BA0B0 => {
    //   block [0x825BA0B0..0x825BA0BC)
	// 825BA0B0: 814100A4  lwz r10, 0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BA0B4: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA0B8: 7FC84BD6  divw r30, r8, r9
	ctx.r[30].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	pc = 0x825BA0BC; continue 'dispatch;
            }
            0x825BA0BC => {
    //   block [0x825BA0BC..0x825BA0DC)
	// 825BA0BC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BA0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BA0C4: 4800094D  bl 0x825baa10
	ctx.lr = 0x825BA0C8;
	sub_825BAA10(ctx, base);
	// 825BA0C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA0CC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA0D0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA0D4: 40990008  ble cr6, 0x825ba0dc
	if !ctx.cr[6].gt {
	pc = 0x825BA0DC; continue 'dispatch;
	}
	// 825BA0D8: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825BA0DC; continue 'dispatch;
            }
            0x825BA0DC => {
    //   block [0x825BA0DC..0x825BA114)
	// 825BA0DC: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA0E0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BA0E4: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA0E8: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BA0EC: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825BA0F0: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BA0F4: 550A103A  slwi r10, r8, 2
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA0F8: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 825BA0FC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BA100: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA104: 41990010  bgt cr6, 0x825ba114
	if ctx.cr[6].gt {
	pc = 0x825BA114; continue 'dispatch;
	}
	// 825BA108: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA10C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA110: 40980008  bge cr6, 0x825ba118
	if !ctx.cr[6].lt {
	pc = 0x825BA118; continue 'dispatch;
	}
	pc = 0x825BA114; continue 'dispatch;
            }
            0x825BA114 => {
    //   block [0x825BA114..0x825BA118)
	// 825BA114: 0FE00016  twui r0, 0x16
	// twui: trap word unsigned immediate — TODO: implement trap semantics
	pc = 0x825BA118; continue 'dispatch;
            }
            0x825BA118 => {
    //   block [0x825BA118..0x825BA130)
	// 825BA118: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BA11C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BA120: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BA124: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825BA128: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA12C: 486EF330  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA130(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BA130 size=112
    let mut pc: u32 = 0x825BA130;
    'dispatch: loop {
        match pc {
            0x825BA130 => {
    //   block [0x825BA130..0x825BA140)
	// 825BA130: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 825BA134: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825BA138: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825BA13C: 419A0050  beq cr6, 0x825ba18c
	if ctx.cr[6].eq {
	pc = 0x825BA18C; continue 'dispatch;
	}
	pc = 0x825BA140; continue 'dispatch;
            }
            0x825BA140 => {
    //   block [0x825BA140..0x825BA168)
	// 825BA140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA144: 419A0040  beq cr6, 0x825ba184
	if ctx.cr[6].eq {
	pc = 0x825BA184; continue 'dispatch;
	}
	// 825BA148: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA14C: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BA150: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA154: 912B0004  stw r9, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BA158: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA15C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA160: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BA164: 419A0020  beq cr6, 0x825ba184
	if ctx.cr[6].eq {
	pc = 0x825BA184; continue 'dispatch;
	}
	pc = 0x825BA168; continue 'dispatch;
            }
            0x825BA168 => {
    //   block [0x825BA168..0x825BA184)
	// 825BA168: 7D0000A6  mfmsr r8
	ctx.r[8].u64 = ctx.msr;
	// 825BA16C: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BA170: 7D205028  lwarx r9, 0, r10
	// lwarx
	let ea = ctx.r[10].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[9].u64 = ctx.reserved.u32 as u64;
	// 825BA174: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 825BA178: 7D20512D  stwcx. r9, 0, r10
	// stwcx.
	let addr = ctx.r[10].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[9].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BA17C: 7D010164  mtmsrd r8, 1
	ctx.msr = (ctx.r[8].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BA180: 4082FFE8  bne 0x825ba168
	if !ctx.cr[0].eq {
	pc = 0x825BA168; continue 'dispatch;
	}
	pc = 0x825BA184; continue 'dispatch;
            }
            0x825BA184 => {
    //   block [0x825BA184..0x825BA18C)
	// 825BA184: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BA188: 4200FFB8  bdnz 0x825ba140
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA140; continue 'dispatch;
	}
	pc = 0x825BA18C; continue 'dispatch;
            }
            0x825BA18C => {
    //   block [0x825BA18C..0x825BA1A0)
	// 825BA18C: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA190: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 825BA194: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA198: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825BA19C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BA1A0 size=156
    let mut pc: u32 = 0x825BA1A0;
    'dispatch: loop {
        match pc {
            0x825BA1A0 => {
    //   block [0x825BA1A0..0x825BA1CC)
	// 825BA1A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA1A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BA1A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BA1AC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA1B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BA1B4: 7C862378  mr r6, r4
	ctx.r[6].u64 = ctx.r[4].u64;
	// 825BA1B8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA1BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA1C0: 409A000C  bne cr6, 0x825ba1cc
	if !ctx.cr[6].eq {
	pc = 0x825BA1CC; continue 'dispatch;
	}
	// 825BA1C4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BA1C8: 48000010  b 0x825ba1d8
	pc = 0x825BA1D8; continue 'dispatch;
            }
            0x825BA1CC => {
    //   block [0x825BA1CC..0x825BA1D8)
	// 825BA1CC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA1D0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825BA1D4: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825BA1D8; continue 'dispatch;
            }
            0x825BA1D8 => {
    //   block [0x825BA1D8..0x825BA214)
	// 825BA1D8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA1DC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BA1E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BA1E4: 7D4A5850  subf r10, r10, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825BA1E8: 7D482E70  srawi r8, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 825BA1EC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA1F0: 40980024  bge cr6, 0x825ba214
	if !ctx.cr[6].lt {
	pc = 0x825BA214; continue 'dispatch;
	}
	// 825BA1F4: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BA1F8: 48000B21  bl 0x825bad18
	ctx.lr = 0x825BA1FC;
	sub_825BAD18(ctx, base);
	// 825BA1FC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BA200: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BA204: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BA208: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BA20C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BA210: 4E800020  blr
	return;
            }
            0x825BA214 => {
    //   block [0x825BA214..0x825BA23C)
	// 825BA214: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BA218: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BA21C: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BA220: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BA224: 480017B5  bl 0x825bb9d8
	ctx.lr = 0x825BA228;
	sub_825BB9D8(ctx, base);
	// 825BA228: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BA22C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BA230: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BA234: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BA238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BA240 size=720
    let mut pc: u32 = 0x825BA240;
    'dispatch: loop {
        match pc {
            0x825BA240 => {
    //   block [0x825BA240..0x825BA274)
	// 825BA240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA244: 486EF1C5  bl 0x82ca9408
	ctx.lr = 0x825BA248;
	sub_82CA93D0(ctx, base);
	// 825BA248: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 825BA24C: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA250: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BA254: C3E60004  lfs f31, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BA258: 83E60000  lwz r31, 0(r6)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA25C: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 825BA260: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA264: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA268: 409A000C  bne cr6, 0x825ba274
	if !ctx.cr[6].eq {
	pc = 0x825BA274; continue 'dispatch;
	}
	// 825BA26C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BA270: 48000010  b 0x825ba280
	pc = 0x825BA280; continue 'dispatch;
            }
            0x825BA274 => {
    //   block [0x825BA274..0x825BA280)
	// 825BA274: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA278: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA27C: 7D291E70  srawi r9, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 3) as i64;
	pc = 0x825BA280; continue 'dispatch;
            }
            0x825BA280 => {
    //   block [0x825BA280..0x825BA2B0)
	// 825BA280: 80FD0008  lwz r7, 8(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA284: 3D401FFF  lis r10, 0x1fff
	ctx.r[10].s64 = 536805376;
	// 825BA288: 7D0B3850  subf r8, r11, r7
	ctx.r[8].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 825BA28C: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 825BA290: 7D0B1E70  srawi r11, r8, 3
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 3) as i64;
	// 825BA294: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA298: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 825BA29C: 40980014  bge cr6, 0x825ba2b0
	if !ctx.cr[6].lt {
	pc = 0x825BA2B0; continue 'dispatch;
	}
	// 825BA2A0: 4848D229  bl 0x82a474c8
	ctx.lr = 0x825BA2A4;
	sub_82A474C8(ctx, base);
	// 825BA2A4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA2A8: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825BA2AC: 486EF1AC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA2B0 => {
    //   block [0x825BA2B0..0x825BA2D4)
	// 825BA2B0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 825BA2B4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA2B8: 40980110  bge cr6, 0x825ba3c8
	if !ctx.cr[6].lt {
	pc = 0x825BA3C8; continue 'dispatch;
	}
	// 825BA2BC: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA2C0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825BA2C4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA2C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA2CC: 41980008  blt cr6, 0x825ba2d4
	if ctx.cr[6].lt {
	pc = 0x825BA2D4; continue 'dispatch;
	}
	// 825BA2D0: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BA2D4; continue 'dispatch;
            }
            0x825BA2D4 => {
    //   block [0x825BA2D4..0x825BA2E0)
	// 825BA2D4: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA2D8: 40980008  bge cr6, 0x825ba2e0
	if !ctx.cr[6].lt {
	pc = 0x825BA2E0; continue 'dispatch;
	}
	// 825BA2DC: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x825BA2E0; continue 'dispatch;
            }
            0x825BA2E0 => {
    //   block [0x825BA2E0..0x825BA304)
	// 825BA2E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BA2E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BA2E8: 484F6671  bl 0x82ab0958
	ctx.lr = 0x825BA2EC;
	sub_82AB0958(ctx, base);
	// 825BA2EC: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA2F0: 8121009C  lwz r9, 0x9c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BA2F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BA2F8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA2FC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825BA300: 419A002C  beq cr6, 0x825ba32c
	if ctx.cr[6].eq {
	pc = 0x825BA32C; continue 'dispatch;
	}
	pc = 0x825BA304; continue 'dispatch;
            }
            0x825BA304 => {
    //   block [0x825BA304..0x825BA31C)
	// 825BA304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA308: 419A0014  beq cr6, 0x825ba31c
	if ctx.cr[6].eq {
	pc = 0x825BA31C; continue 'dispatch;
	}
	// 825BA30C: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA310: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BA314: C00A0004  lfs f0, 4(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA318: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x825BA31C; continue 'dispatch;
            }
            0x825BA31C => {
    //   block [0x825BA31C..0x825BA32C)
	// 825BA31C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BA320: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825BA324: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA328: 409AFFDC  bne cr6, 0x825ba304
	if !ctx.cr[6].eq {
	pc = 0x825BA304; continue 'dispatch;
	}
	pc = 0x825BA32C; continue 'dispatch;
            }
            0x825BA32C => {
    //   block [0x825BA32C..0x825BA33C)
	// 825BA32C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA330: 419A000C  beq cr6, 0x825ba33c
	if ctx.cr[6].eq {
	pc = 0x825BA33C; continue 'dispatch;
	}
	// 825BA334: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825BA338: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x825BA33C; continue 'dispatch;
            }
            0x825BA33C => {
    //   block [0x825BA33C..0x825BA358)
	// 825BA33C: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA340: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 825BA344: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA348: 419A0038  beq cr6, 0x825ba380
	if ctx.cr[6].eq {
	pc = 0x825BA380; continue 'dispatch;
	}
	// 825BA34C: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA350: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BA354: 396BFFF8  addi r11, r11, -8
	ctx.r[11].s64 = ctx.r[11].s64 + -8;
	pc = 0x825BA358; continue 'dispatch;
            }
            0x825BA358 => {
    //   block [0x825BA358..0x825BA370)
	// 825BA358: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA35C: 419A0014  beq cr6, 0x825ba370
	if ctx.cr[6].eq {
	pc = 0x825BA370; continue 'dispatch;
	}
	// 825BA360: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA364: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BA368: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA36C: D00A0004  stfs f0, 4(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x825BA370; continue 'dispatch;
            }
            0x825BA370 => {
    //   block [0x825BA370..0x825BA380)
	// 825BA370: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825BA374: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BA378: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA37C: 409AFFDC  bne cr6, 0x825ba358
	if !ctx.cr[6].eq {
	pc = 0x825BA358; continue 'dispatch;
	}
	pc = 0x825BA380; continue 'dispatch;
            }
            0x825BA380 => {
    //   block [0x825BA380..0x825BA3A0)
	// 825BA380: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA384: 817D0008  lwz r11, 8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA388: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BA38C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BA390: 7D4B1E70  srawi r11, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 825BA394: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 825BA398: 419A0008  beq cr6, 0x825ba3a0
	if ctx.cr[6].eq {
	pc = 0x825BA3A0; continue 'dispatch;
	}
	// 825BA39C: 4BC6199D  bl 0x8221bd38
	ctx.lr = 0x825BA3A0;
	sub_8221BD38(ctx, base);
	pc = 0x825BA3A0; continue 'dispatch;
            }
            0x825BA3A0 => {
    //   block [0x825BA3A0..0x825BA3C8)
	// 825BA3A0: 578A1838  slwi r10, r28, 3
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA3A4: 93DD0004  stw r30, 4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BA3A8: 57EB1838  slwi r11, r31, 3
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA3AC: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825BA3B0: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BA3B4: 915D000C  stw r10, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825BA3B8: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BA3BC: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA3C0: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825BA3C4: 486EF094  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA3C8 => {
    //   block [0x825BA3C8..0x825BA3EC)
	// 825BA3C8: 8161009C  lwz r11, 0x9c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BA3CC: 7D4B3850  subf r10, r11, r7
	ctx.r[10].s64 = ctx.r[7].s64 - ctx.r[11].s64;
	// 825BA3D0: 7D491E70  srawi r9, r10, 3
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 3) as i64;
	// 825BA3D4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 825BA3D8: 409800A8  bge cr6, 0x825ba480
	if !ctx.cr[6].lt {
	pc = 0x825BA480; continue 'dispatch;
	}
	// 825BA3DC: 392B0008  addi r9, r11, 8
	ctx.r[9].s64 = ctx.r[11].s64 + 8;
	// 825BA3E0: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA3E4: 419A0030  beq cr6, 0x825ba414
	if ctx.cr[6].eq {
	pc = 0x825BA414; continue 'dispatch;
	}
	// 825BA3E8: 3949FFF8  addi r10, r9, -8
	ctx.r[10].s64 = ctx.r[9].s64 + -8;
	pc = 0x825BA3EC; continue 'dispatch;
            }
            0x825BA3EC => {
    //   block [0x825BA3EC..0x825BA404)
	// 825BA3EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BA3F0: 419A0014  beq cr6, 0x825ba404
	if ctx.cr[6].eq {
	pc = 0x825BA404; continue 'dispatch;
	}
	// 825BA3F4: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA3F8: 91090000  stw r8, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BA3FC: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA400: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x825BA404; continue 'dispatch;
            }
            0x825BA404 => {
    //   block [0x825BA404..0x825BA414)
	// 825BA404: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BA408: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 825BA40C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA410: 409AFFDC  bne cr6, 0x825ba3ec
	if !ctx.cr[6].eq {
	pc = 0x825BA3EC; continue 'dispatch;
	}
	pc = 0x825BA414; continue 'dispatch;
            }
            0x825BA414 => {
    //   block [0x825BA414..0x825BA42C)
	// 825BA414: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA418: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA41C: 7D281E70  srawi r8, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 3) as i64;
	// 825BA420: 21280001  subfic r9, r8, 1
	ctx.xer.ca = ctx.r[8].u32 <= 1 as u32;
	ctx.r[9].s64 = (1 as i64) - ctx.r[8].s64;
	// 825BA424: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BA428: 419A0020  beq cr6, 0x825ba448
	if ctx.cr[6].eq {
	pc = 0x825BA448; continue 'dispatch;
	}
	pc = 0x825BA42C; continue 'dispatch;
            }
            0x825BA42C => {
    //   block [0x825BA42C..0x825BA43C)
	// 825BA42C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA430: 419A000C  beq cr6, 0x825ba43c
	if ctx.cr[6].eq {
	pc = 0x825BA43C; continue 'dispatch;
	}
	// 825BA434: D3EA0004  stfs f31, 4(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825BA438: 93EA0000  stw r31, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	pc = 0x825BA43C; continue 'dispatch;
            }
            0x825BA43C => {
    //   block [0x825BA43C..0x825BA448)
	// 825BA43C: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BA440: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BA444: 4082FFE8  bne 0x825ba42c
	if !ctx.cr[0].eq {
	pc = 0x825BA42C; continue 'dispatch;
	}
	pc = 0x825BA448; continue 'dispatch;
            }
            0x825BA448 => {
    //   block [0x825BA448..0x825BA460)
	// 825BA448: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA44C: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BA450: 392AFFF8  addi r9, r10, -8
	ctx.r[9].s64 = ctx.r[10].s64 + -8;
	// 825BA454: 915D0008  stw r10, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BA458: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA45C: 419A00A8  beq cr6, 0x825ba504
	if ctx.cr[6].eq {
	pc = 0x825BA504; continue 'dispatch;
	}
	pc = 0x825BA460; continue 'dispatch;
            }
            0x825BA460 => {
    //   block [0x825BA460..0x825BA480)
	// 825BA460: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825BA464: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825BA468: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825BA46C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA470: 409AFFF0  bne cr6, 0x825ba460
	if !ctx.cr[6].eq {
	pc = 0x825BA460; continue 'dispatch;
	}
	// 825BA474: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA478: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825BA47C: 486EEFDC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA480 => {
    //   block [0x825BA480..0x825BA494)
	// 825BA480: 3947FFF8  addi r10, r7, -8
	ctx.r[10].s64 = ctx.r[7].s64 + -8;
	// 825BA484: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 825BA488: 7D485378  mr r8, r10
	ctx.r[8].u64 = ctx.r[10].u64;
	// 825BA48C: 7F0A3840  cmplw cr6, r10, r7
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA490: 419A002C  beq cr6, 0x825ba4bc
	if ctx.cr[6].eq {
	pc = 0x825BA4BC; continue 'dispatch;
	}
	pc = 0x825BA494; continue 'dispatch;
            }
            0x825BA494 => {
    //   block [0x825BA494..0x825BA4AC)
	// 825BA494: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BA498: 419A0014  beq cr6, 0x825ba4ac
	if ctx.cr[6].eq {
	pc = 0x825BA4AC; continue 'dispatch;
	}
	// 825BA49C: 80C80000  lwz r6, 0(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA4A0: 90C90000  stw r6, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BA4A4: C0080004  lfs f0, 4(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA4A8: D0090004  stfs f0, 4(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), tmp.u32 ) };
	pc = 0x825BA4AC; continue 'dispatch;
            }
            0x825BA4AC => {
    //   block [0x825BA4AC..0x825BA4BC)
	// 825BA4AC: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 825BA4B0: 39290008  addi r9, r9, 8
	ctx.r[9].s64 = ctx.r[9].s64 + 8;
	// 825BA4B4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA4B8: 409AFFDC  bne cr6, 0x825ba494
	if !ctx.cr[6].eq {
	pc = 0x825BA494; continue 'dispatch;
	}
	pc = 0x825BA4BC; continue 'dispatch;
            }
            0x825BA4BC => {
    //   block [0x825BA4BC..0x825BA4C8)
	// 825BA4BC: 913D0008  stw r9, 8(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BA4C0: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA4C4: 419A0020  beq cr6, 0x825ba4e4
	if ctx.cr[6].eq {
	pc = 0x825BA4E4; continue 'dispatch;
	}
	pc = 0x825BA4C8; continue 'dispatch;
            }
            0x825BA4C8 => {
    //   block [0x825BA4C8..0x825BA4E4)
	// 825BA4C8: 394AFFF8  addi r10, r10, -8
	ctx.r[10].s64 = ctx.r[10].s64 + -8;
	// 825BA4CC: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BA4D0: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA4D4: 912A0008  stw r9, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BA4D8: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA4DC: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BA4E0: 409AFFE8  bne cr6, 0x825ba4c8
	if !ctx.cr[6].eq {
	pc = 0x825BA4C8; continue 'dispatch;
	}
	pc = 0x825BA4E4; continue 'dispatch;
            }
            0x825BA4E4 => {
    //   block [0x825BA4E4..0x825BA4F0)
	// 825BA4E4: 394B0008  addi r10, r11, 8
	ctx.r[10].s64 = ctx.r[11].s64 + 8;
	// 825BA4E8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA4EC: 419A0018  beq cr6, 0x825ba504
	if ctx.cr[6].eq {
	pc = 0x825BA504; continue 'dispatch;
	}
	pc = 0x825BA4F0; continue 'dispatch;
            }
            0x825BA4F0 => {
    //   block [0x825BA4F0..0x825BA504)
	// 825BA4F0: D3EB0004  stfs f31, 4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 825BA4F4: 93EB0000  stw r31, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 825BA4F8: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 825BA4FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA500: 409AFFF0  bne cr6, 0x825ba4f0
	if !ctx.cr[6].eq {
	pc = 0x825BA4F0; continue 'dispatch;
	}
	pc = 0x825BA504; continue 'dispatch;
            }
            0x825BA504 => {
    //   block [0x825BA504..0x825BA510)
	// 825BA504: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA508: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 825BA50C: 486EEF4C  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BA510 size=96
    let mut pc: u32 = 0x825BA510;
    'dispatch: loop {
        match pc {
            0x825BA510 => {
    //   block [0x825BA510..0x825BA53C)
	// 825BA510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA514: 486EEEED  bl 0x82ca9400
	ctx.lr = 0x825BA518;
	sub_82CA93D0(ctx, base);
	// 825BA518: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA51C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BA520: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 825BA524: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BA528: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BA52C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	// 825BA530: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 825BA534: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BA538: 419A0020  beq cr6, 0x825ba558
	if ctx.cr[6].eq {
	pc = 0x825BA558; continue 'dispatch;
	}
	pc = 0x825BA53C; continue 'dispatch;
            }
            0x825BA53C => {
    //   block [0x825BA53C..0x825BA558)
	// 825BA53C: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825BA540: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BA544: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BA548: 48002BA9  bl 0x825bd0f0
	ctx.lr = 0x825BA54C;
	sub_825BD0F0(ctx, base);
	// 825BA54C: 37FFFFFF  addic. r31, r31, -1
	ctx.xer.ca = (ctx.r[31].u32 > (!(-1 as u32)));
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825BA550: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 825BA554: 4082FFE8  bne 0x825ba53c
	if !ctx.cr[0].eq {
	pc = 0x825BA53C; continue 'dispatch;
	}
	pc = 0x825BA558; continue 'dispatch;
            }
            0x825BA558 => {
    //   block [0x825BA558..0x825BA570)
	// 825BA558: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA55C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825BA560: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA564: 7C6BD214  add r3, r11, r26
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BA568: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BA56C: 486EEEE4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BA570 size=208
    let mut pc: u32 = 0x825BA570;
    'dispatch: loop {
        match pc {
            0x825BA570 => {
    //   block [0x825BA570..0x825BA5B4)
	// 825BA570: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA574: 486EEE99  bl 0x82ca940c
	ctx.lr = 0x825BA578;
	sub_82CA93D0(ctx, base);
	// 825BA578: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA57C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825BA580: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BA584: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825BA588: 39400014  li r10, 0x14
	ctx.r[10].s64 = 20;
	// 825BA58C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA590: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA594: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825BA598: 7D095850  subf r8, r9, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825BA59C: 93BE0008  stw r29, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825BA5A0: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 825BA5A4: 7C8853D7  divw. r4, r8, r10
	ctx.r[4].s32 = ctx.r[8].s32 / ctx.r[10].s32;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825BA5A8: 4082000C  bne 0x825ba5b4
	if !ctx.cr[0].eq {
	pc = 0x825BA5B4; continue 'dispatch;
	}
	// 825BA5AC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BA5B0: 4800000C  b 0x825ba5bc
	pc = 0x825BA5BC; continue 'dispatch;
            }
            0x825BA5B4 => {
    //   block [0x825BA5B4..0x825BA5BC)
	// 825BA5B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BA5B8: 4BE5DBE9  bl 0x824181a0
	ctx.lr = 0x825BA5BC;
	sub_824181A0(ctx, base);
	pc = 0x825BA5BC; continue 'dispatch;
            }
            0x825BA5BC => {
    //   block [0x825BA5BC..0x825BA5F0)
	// 825BA5BC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825BA5C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA5C4: 419A0070  beq cr6, 0x825ba634
	if ctx.cr[6].eq {
	pc = 0x825BA634; continue 'dispatch;
	}
	// 825BA5C8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA5CC: 813F0008  lwz r9, 8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA5D0: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825BA5D4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA5D8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA5DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BA5E0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BA5E4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825BA5E8: 419A0048  beq cr6, 0x825ba630
	if ctx.cr[6].eq {
	pc = 0x825BA630; continue 'dispatch;
	}
	// 825BA5EC: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	pc = 0x825BA5F0; continue 'dispatch;
            }
            0x825BA5F0 => {
    //   block [0x825BA5F0..0x825BA620)
	// 825BA5F0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA5F4: 419A002C  beq cr6, 0x825ba620
	if ctx.cr[6].eq {
	pc = 0x825BA620; continue 'dispatch;
	}
	// 825BA5F8: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA5FC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BA600: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA604: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BA608: 80EA0008  lwz r7, 8(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA60C: 90EB0008  stw r7, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825BA610: 80CA000C  lwz r6, 0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA614: 90CB000C  stw r6, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 825BA618: 80AA0010  lwz r5, 0x10(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BA61C: 90AB0010  stw r5, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x825BA620; continue 'dispatch;
            }
            0x825BA620 => {
    //   block [0x825BA620..0x825BA630)
	// 825BA620: 394A0014  addi r10, r10, 0x14
	ctx.r[10].s64 = ctx.r[10].s64 + 20;
	// 825BA624: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BA628: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA62C: 409AFFC4  bne cr6, 0x825ba5f0
	if !ctx.cr[6].eq {
	pc = 0x825BA5F0; continue 'dispatch;
	}
	pc = 0x825BA630; continue 'dispatch;
            }
            0x825BA630 => {
    //   block [0x825BA630..0x825BA634)
	// 825BA630: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	pc = 0x825BA634; continue 'dispatch;
            }
            0x825BA634 => {
    //   block [0x825BA634..0x825BA640)
	// 825BA634: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BA638: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA63C: 486EEE20  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BA640 size=184
    let mut pc: u32 = 0x825BA640;
    'dispatch: loop {
        match pc {
            0x825BA640 => {
    //   block [0x825BA640..0x825BA650)
	// 825BA640: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 825BA644: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825BA648: 419A009C  beq cr6, 0x825ba6e4
	if ctx.cr[6].eq {
	pc = 0x825BA6E4; continue 'dispatch;
	}
	// 825BA64C: 39640015  addi r11, r4, 0x15
	ctx.r[11].s64 = ctx.r[4].s64 + 21;
	pc = 0x825BA650; continue 'dispatch;
            }
            0x825BA650 => {
    //   block [0x825BA650..0x825BA6DC)
	// 825BA650: 354BFFEB  addic. r10, r11, -0x15
	ctx.xer.ca = (ctx.r[11].u32 > (!(-21 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + -21;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BA654: 41820088  beq 0x825ba6dc
	if ctx.cr[0].eq {
	pc = 0x825BA6DC; continue 'dispatch;
	}
	// 825BA658: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA65C: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825BA660: 912BFFEB  stw r9, -0x15(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-21 as u32), ctx.r[9].u32 ) };
	// 825BA664: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA668: 910BFFEF  stw r8, -0x11(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17 as u32), ctx.r[8].u32 ) };
	// 825BA66C: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA670: 90EBFFF3  stw r7, -0xd(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-13 as u32), ctx.r[7].u32 ) };
	// 825BA674: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA678: D00BFFF7  stfs f0, -9(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9 as u32), tmp.u32 ) };
	// 825BA67C: 80660010  lwz r3, 0x10(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BA680: 906BFFFB  stw r3, -5(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-5 as u32), ctx.r[3].u32 ) };
	// 825BA684: 89460017  lbz r10, 0x17(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BA688: 89260014  lbz r9, 0x14(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA68C: 89060015  lbz r8, 0x15(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BA690: 88E60016  lbz r7, 0x16(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BA694: 98EB0001  stb r7, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 825BA698: 990B0000  stb r8, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 825BA69C: 992BFFFF  stb r9, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[9].u8 ) };
	// 825BA6A0: 994B0002  stb r10, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[10].u8 ) };
	// 825BA6A4: 8866001B  lbz r3, 0x1b(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BA6A8: 89460018  lbz r10, 0x18(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BA6AC: 89260019  lbz r9, 0x19(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BA6B0: 8906001A  lbz r8, 0x1a(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BA6B4: 990B0005  stb r8, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[8].u8 ) };
	// 825BA6B8: 992B0004  stb r9, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[9].u8 ) };
	// 825BA6BC: 994B0003  stb r10, 3(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), ctx.r[10].u8 ) };
	// 825BA6C0: 986B0006  stb r3, 6(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[3].u8 ) };
	// 825BA6C4: C1A6001C  lfs f13, 0x1c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BA6C8: D1AB0007  stfs f13, 7(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), tmp.u32 ) };
	// 825BA6CC: 80E60020  lwz r7, 0x20(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BA6D0: 90EB000B  stw r7, 0xb(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[7].u32 ) };
	// 825BA6D4: C1860024  lfs f12, 0x24(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BA6D8: D18B000F  stfs f12, 0xf(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), tmp.u32 ) };
	pc = 0x825BA6DC; continue 'dispatch;
            }
            0x825BA6DC => {
    //   block [0x825BA6DC..0x825BA6E4)
	// 825BA6DC: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 825BA6E0: 4200FF70  bdnz 0x825ba650
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BA650; continue 'dispatch;
	}
	pc = 0x825BA6E4; continue 'dispatch;
            }
            0x825BA6E4 => {
    //   block [0x825BA6E4..0x825BA6F8)
	// 825BA6E4: 54AB103A  slwi r11, r5, 2
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA6E8: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 825BA6EC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA6F0: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825BA6F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BA6F8 size=84
    let mut pc: u32 = 0x825BA6F8;
    'dispatch: loop {
        match pc {
            0x825BA6F8 => {
    //   block [0x825BA6F8..0x825BA74C)
	// 825BA6F8: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA6FC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BA700: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA704: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825BA708: C0040008  lfs f0, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BA70C: D0030008  stfs f0, 8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825BA710: 8924000F  lbz r9, 0xf(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(15 as u32) ) } as u64;
	// 825BA714: 8904000C  lbz r8, 0xc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA718: 88E4000D  lbz r7, 0xd(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(13 as u32) ) } as u64;
	// 825BA71C: 88C4000E  lbz r6, 0xe(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(14 as u32) ) } as u64;
	// 825BA720: 98C3000E  stb r6, 0xe(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(14 as u32), ctx.r[6].u8 ) };
	// 825BA724: 98E3000D  stb r7, 0xd(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(13 as u32), ctx.r[7].u8 ) };
	// 825BA728: 9903000C  stb r8, 0xc(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 825BA72C: 9923000F  stb r9, 0xf(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(15 as u32), ctx.r[9].u8 ) };
	// 825BA730: C1A40010  lfs f13, 0x10(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BA734: D1A30010  stfs f13, 0x10(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825BA738: 80A40014  lwz r5, 0x14(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BA73C: 90A30014  stw r5, 0x14(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 825BA740: 88840018  lbz r4, 0x18(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BA744: 98830018  stb r4, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[4].u8 ) };
	// 825BA748: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BA750(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BA750 size=700
    let mut pc: u32 = 0x825BA750;
    'dispatch: loop {
        match pc {
            0x825BA750 => {
    //   block [0x825BA750..0x825BA780)
	// 825BA750: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BA754: 486EECB1  bl 0x82ca9404
	ctx.lr = 0x825BA758;
	sub_82CA93D0(ctx, base);
	// 825BA758: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BA75C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BA760: 83660000  lwz r27, 0(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA764: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 825BA768: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BA76C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA774: 409A000C  bne cr6, 0x825ba780
	if !ctx.cr[6].eq {
	pc = 0x825BA780; continue 'dispatch;
	}
	// 825BA778: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825BA77C: 48000010  b 0x825ba78c
	pc = 0x825BA78C; continue 'dispatch;
            }
            0x825BA780 => {
    //   block [0x825BA780..0x825BA78C)
	// 825BA780: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BA784: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA788: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	pc = 0x825BA78C; continue 'dispatch;
            }
            0x825BA78C => {
    //   block [0x825BA78C..0x825BA7C0)
	// 825BA78C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BA790: 419A0274  beq cr6, 0x825baa04
	if ctx.cr[6].eq {
	pc = 0x825BAA04; continue 'dispatch;
	}
	// 825BA794: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA798: 3D403FFF  lis r10, 0x3fff
	ctx.r[10].s64 = 1073676288;
	// 825BA79C: 7CEB4850  subf r7, r11, r9
	ctx.r[7].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825BA7A0: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 825BA7A4: 7CEB1670  srawi r11, r7, 2
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 2) as i64;
	// 825BA7A8: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA7AC: 7F06F840  cmplw cr6, r6, r31
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BA7B0: 40980010  bge cr6, 0x825ba7c0
	if !ctx.cr[6].lt {
	pc = 0x825BA7C0; continue 'dispatch;
	}
	// 825BA7B4: 4848CD15  bl 0x82a474c8
	ctx.lr = 0x825BA7B8;
	sub_82A474C8(ctx, base);
	// 825BA7B8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA7BC: 486EEC98  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA7C0 => {
    //   block [0x825BA7C0..0x825BA7E4)
	// 825BA7C0: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BA7C4: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA7C8: 40980118  bge cr6, 0x825ba8e0
	if !ctx.cr[6].lt {
	pc = 0x825BA8E0; continue 'dispatch;
	}
	// 825BA7CC: 550BF87E  srwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA7D0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825BA7D4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BA7D8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA7DC: 41980008  blt cr6, 0x825ba7e4
	if ctx.cr[6].lt {
	pc = 0x825BA7E4; continue 'dispatch;
	}
	// 825BA7E0: 7F8B4214  add r28, r11, r8
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	pc = 0x825BA7E4; continue 'dispatch;
            }
            0x825BA7E4 => {
    //   block [0x825BA7E4..0x825BA7F0)
	// 825BA7E4: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA7E8: 40980008  bge cr6, 0x825ba7f0
	if !ctx.cr[6].lt {
	pc = 0x825BA7F0; continue 'dispatch;
	}
	// 825BA7EC: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	pc = 0x825BA7F0; continue 'dispatch;
            }
            0x825BA7F0 => {
    //   block [0x825BA7F0..0x825BA814)
	// 825BA7F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BA7F4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BA7F8: 484CB821  bl 0x82a86018
	ctx.lr = 0x825BA7FC;
	sub_82A86018(ctx, base);
	// 825BA7FC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA800: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BA804: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BA808: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA80C: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825BA810: 419A0024  beq cr6, 0x825ba834
	if ctx.cr[6].eq {
	pc = 0x825BA834; continue 'dispatch;
	}
	pc = 0x825BA814; continue 'dispatch;
            }
            0x825BA814 => {
    //   block [0x825BA814..0x825BA824)
	// 825BA814: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA818: 419A000C  beq cr6, 0x825ba824
	if ctx.cr[6].eq {
	pc = 0x825BA824; continue 'dispatch;
	}
	// 825BA81C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA820: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x825BA824; continue 'dispatch;
            }
            0x825BA824 => {
    //   block [0x825BA824..0x825BA834)
	// 825BA824: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA828: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825BA82C: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA830: 409AFFE4  bne cr6, 0x825ba814
	if !ctx.cr[6].eq {
	pc = 0x825BA814; continue 'dispatch;
	}
	pc = 0x825BA834; continue 'dispatch;
            }
            0x825BA834 => {
    //   block [0x825BA834..0x825BA844)
	// 825BA834: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	// 825BA838: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825BA83C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BA840: 419A001C  beq cr6, 0x825ba85c
	if ctx.cr[6].eq {
	pc = 0x825BA85C; continue 'dispatch;
	}
	pc = 0x825BA844; continue 'dispatch;
            }
            0x825BA844 => {
    //   block [0x825BA844..0x825BA850)
	// 825BA844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA848: 419A0008  beq cr6, 0x825ba850
	if ctx.cr[6].eq {
	pc = 0x825BA850; continue 'dispatch;
	}
	// 825BA84C: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x825BA850; continue 'dispatch;
            }
            0x825BA850 => {
    //   block [0x825BA850..0x825BA85C)
	// 825BA850: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BA854: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA858: 4082FFEC  bne 0x825ba844
	if !ctx.cr[0].eq {
	pc = 0x825BA844; continue 'dispatch;
	}
	pc = 0x825BA85C; continue 'dispatch;
            }
            0x825BA85C => {
    //   block [0x825BA85C..0x825BA87C)
	// 825BA85C: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA860: 57E9103A  slwi r9, r31, 2
	ctx.r[9].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BA864: 7D695214  add r11, r9, r10
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825BA868: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA86C: 419A0030  beq cr6, 0x825ba89c
	if ctx.cr[6].eq {
	pc = 0x825BA89C; continue 'dispatch;
	}
	// 825BA870: 7D295850  subf r9, r9, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825BA874: 7D4A4850  subf r10, r10, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825BA878: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	pc = 0x825BA87C; continue 'dispatch;
            }
            0x825BA87C => {
    //   block [0x825BA87C..0x825BA88C)
	// 825BA87C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA880: 419A000C  beq cr6, 0x825ba88c
	if ctx.cr[6].eq {
	pc = 0x825BA88C; continue 'dispatch;
	}
	// 825BA884: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA888: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x825BA88C; continue 'dispatch;
            }
            0x825BA88C => {
    //   block [0x825BA88C..0x825BA89C)
	// 825BA88C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825BA890: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA894: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BA898: 409AFFE4  bne cr6, 0x825ba87c
	if !ctx.cr[6].eq {
	pc = 0x825BA87C; continue 'dispatch;
	}
	pc = 0x825BA89C; continue 'dispatch;
            }
            0x825BA89C => {
    //   block [0x825BA89C..0x825BA8BC)
	// 825BA89C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BA8A0: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA8A4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BA8A8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BA8AC: 7D4B1670  srawi r11, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825BA8B0: 7FEBFA14  add r31, r11, r31
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825BA8B4: 419A0008  beq cr6, 0x825ba8bc
	if ctx.cr[6].eq {
	pc = 0x825BA8BC; continue 'dispatch;
	}
	// 825BA8B8: 4BC61481  bl 0x8221bd38
	ctx.lr = 0x825BA8BC;
	sub_8221BD38(ctx, base);
	pc = 0x825BA8BC; continue 'dispatch;
            }
            0x825BA8BC => {
    //   block [0x825BA8BC..0x825BA8E0)
	// 825BA8BC: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BA8C0: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825BA8C4: 57EB103A  slwi r11, r31, 2
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BA8C8: 7D4AEA14  add r10, r10, r29
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825BA8CC: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BA8D0: 915E000C  stw r10, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825BA8D4: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BA8D8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA8DC: 486EEB78  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA8E0 => {
    //   block [0x825BA8E0..0x825BA908)
	// 825BA8E0: 80E1009C  lwz r7, 0x9c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BA8E4: 7D674850  subf r11, r7, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[7].s64;
	// 825BA8E8: 7D6A1670  srawi r10, r11, 2
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 2) as i64;
	// 825BA8EC: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BA8F0: 40980098  bge cr6, 0x825ba988
	if !ctx.cr[6].lt {
	pc = 0x825BA988; continue 'dispatch;
	}
	// 825BA8F4: 57E8103A  slwi r8, r31, 2
	ctx.r[8].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BA8F8: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA8FC: 7D683A14  add r11, r8, r7
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[7].u64;
	// 825BA900: 419A0028  beq cr6, 0x825ba928
	if ctx.cr[6].eq {
	pc = 0x825BA928; continue 'dispatch;
	}
	// 825BA904: 7D485850  subf r10, r8, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[8].s64;
	pc = 0x825BA908; continue 'dispatch;
            }
            0x825BA908 => {
    //   block [0x825BA908..0x825BA918)
	// 825BA908: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA90C: 419A000C  beq cr6, 0x825ba918
	if ctx.cr[6].eq {
	pc = 0x825BA918; continue 'dispatch;
	}
	// 825BA910: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA914: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	pc = 0x825BA918; continue 'dispatch;
            }
            0x825BA918 => {
    //   block [0x825BA918..0x825BA928)
	// 825BA918: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825BA91C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA920: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA924: 409AFFE4  bne cr6, 0x825ba908
	if !ctx.cr[6].eq {
	pc = 0x825BA908; continue 'dispatch;
	}
	pc = 0x825BA928; continue 'dispatch;
            }
            0x825BA928 => {
    //   block [0x825BA928..0x825BA93C)
	// 825BA928: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA92C: 7D475850  subf r10, r7, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[7].s64;
	// 825BA930: 7D491670  srawi r9, r10, 2
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 2) as i64;
	// 825BA934: 7D49F851  subf. r10, r9, r31
	ctx.r[10].s64 = ctx.r[31].s64 - ctx.r[9].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BA938: 4182001C  beq 0x825ba954
	if ctx.cr[0].eq {
	pc = 0x825BA954; continue 'dispatch;
	}
	pc = 0x825BA93C; continue 'dispatch;
            }
            0x825BA93C => {
    //   block [0x825BA93C..0x825BA948)
	// 825BA93C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BA940: 419A0008  beq cr6, 0x825ba948
	if ctx.cr[6].eq {
	pc = 0x825BA948; continue 'dispatch;
	}
	// 825BA944: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	pc = 0x825BA948; continue 'dispatch;
            }
            0x825BA948 => {
    //   block [0x825BA948..0x825BA954)
	// 825BA948: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BA94C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA950: 4082FFEC  bne 0x825ba93c
	if !ctx.cr[0].eq {
	pc = 0x825BA93C; continue 'dispatch;
	}
	pc = 0x825BA954; continue 'dispatch;
            }
            0x825BA954 => {
    //   block [0x825BA954..0x825BA970)
	// 825BA954: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BA958: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825BA95C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825BA960: 7D285050  subf r9, r8, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825BA964: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BA968: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA96C: 419A0098  beq cr6, 0x825baa04
	if ctx.cr[6].eq {
	pc = 0x825BAA04; continue 'dispatch;
	}
	pc = 0x825BA970; continue 'dispatch;
            }
            0x825BA970 => {
    //   block [0x825BA970..0x825BA988)
	// 825BA970: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BA974: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA978: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA97C: 409AFFF4  bne cr6, 0x825ba970
	if !ctx.cr[6].eq {
	pc = 0x825BA970; continue 'dispatch;
	}
	// 825BA980: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BA984: 486EEAD0  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BA988 => {
    //   block [0x825BA988..0x825BA9A0)
	// 825BA988: 57E6103A  slwi r6, r31, 2
	ctx.r[6].u32 = ctx.r[31].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825BA98C: 7D2A4B78  mr r10, r9
	ctx.r[10].u64 = ctx.r[9].u64;
	// 825BA990: 7D664850  subf r11, r6, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[6].s64;
	// 825BA994: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825BA998: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA99C: 419A0024  beq cr6, 0x825ba9c0
	if ctx.cr[6].eq {
	pc = 0x825BA9C0; continue 'dispatch;
	}
	pc = 0x825BA9A0; continue 'dispatch;
            }
            0x825BA9A0 => {
    //   block [0x825BA9A0..0x825BA9B0)
	// 825BA9A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BA9A4: 419A000C  beq cr6, 0x825ba9b0
	if ctx.cr[6].eq {
	pc = 0x825BA9B0; continue 'dispatch;
	}
	// 825BA9A8: 80A80000  lwz r5, 0(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA9AC: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	pc = 0x825BA9B0; continue 'dispatch;
            }
            0x825BA9B0 => {
    //   block [0x825BA9B0..0x825BA9C0)
	// 825BA9B0: 39080004  addi r8, r8, 4
	ctx.r[8].s64 = ctx.r[8].s64 + 4;
	// 825BA9B4: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825BA9B8: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BA9BC: 409AFFE4  bne cr6, 0x825ba9a0
	if !ctx.cr[6].eq {
	pc = 0x825BA9A0; continue 'dispatch;
	}
	pc = 0x825BA9C0; continue 'dispatch;
            }
            0x825BA9C0 => {
    //   block [0x825BA9C0..0x825BA9D0)
	// 825BA9C0: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BA9C4: 7F075840  cmplw cr6, r7, r11
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BA9C8: 419A001C  beq cr6, 0x825ba9e4
	if ctx.cr[6].eq {
	pc = 0x825BA9E4; continue 'dispatch;
	}
	// 825BA9CC: 7D4B4850  subf r10, r11, r9
	ctx.r[10].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825BA9D0; continue 'dispatch;
            }
            0x825BA9D0 => {
    //   block [0x825BA9D0..0x825BA9E4)
	// 825BA9D0: 396BFFFC  addi r11, r11, -4
	ctx.r[11].s64 = ctx.r[11].s64 + -4;
	// 825BA9D4: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BA9D8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BA9DC: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	// 825BA9E0: 409AFFF0  bne cr6, 0x825ba9d0
	if !ctx.cr[6].eq {
	pc = 0x825BA9D0; continue 'dispatch;
	}
	pc = 0x825BA9E4; continue 'dispatch;
            }
            0x825BA9E4 => {
    //   block [0x825BA9E4..0x825BA9F4)
	// 825BA9E4: 7D463A14  add r10, r6, r7
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[7].u64;
	// 825BA9E8: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 825BA9EC: 7F075040  cmplw cr6, r7, r10
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BA9F0: 419A0014  beq cr6, 0x825baa04
	if ctx.cr[6].eq {
	pc = 0x825BAA04; continue 'dispatch;
	}
	pc = 0x825BA9F4; continue 'dispatch;
            }
            0x825BA9F4 => {
    //   block [0x825BA9F4..0x825BAA04)
	// 825BA9F4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BA9F8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 825BA9FC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BAA00: 409AFFF4  bne cr6, 0x825ba9f4
	if !ctx.cr[6].eq {
	pc = 0x825BA9F4; continue 'dispatch;
	}
	pc = 0x825BAA04; continue 'dispatch;
            }
            0x825BAA04 => {
    //   block [0x825BAA04..0x825BAA0C)
	// 825BAA04: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BAA08: 486EEA4C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BAA10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BAA10 size=772
    let mut pc: u32 = 0x825BAA10;
    'dispatch: loop {
        match pc {
            0x825BAA10 => {
    //   block [0x825BAA10..0x825BAA44)
	// 825BAA10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BAA14: 486EE9ED  bl 0x82ca9400
	ctx.lr = 0x825BAA18;
	sub_82CA93D0(ctx, base);
	// 825BAA18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BAA1C: 81660008  lwz r11, 8(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAA20: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BAA24: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAA28: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAA30: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 825BAA34: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 825BAA38: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BAA3C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BAA40: 419A0020  beq cr6, 0x825baa60
	if ctx.cr[6].eq {
	pc = 0x825BAA60; continue 'dispatch;
	}
	pc = 0x825BAA44; continue 'dispatch;
            }
            0x825BAA44 => {
    //   block [0x825BAA44..0x825BAA60)
	// 825BAA44: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 825BAA48: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BAA4C: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 825BAA50: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825BAA54: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BAA58: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BAA5C: 4082FFE8  bne 0x825baa44
	if !ctx.cr[0].eq {
	pc = 0x825BAA44; continue 'dispatch;
	}
	pc = 0x825BAA60; continue 'dispatch;
            }
            0x825BAA60 => {
    //   block [0x825BAA60..0x825BAA78)
	// 825BAA60: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAA64: 3B60000C  li r27, 0xc
	ctx.r[27].s64 = 12;
	// 825BAA68: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAA6C: 409A000C  bne cr6, 0x825baa78
	if !ctx.cr[6].eq {
	pc = 0x825BAA78; continue 'dispatch;
	}
	// 825BAA70: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BAA74: 48000010  b 0x825baa84
	pc = 0x825BAA84; continue 'dispatch;
            }
            0x825BAA78 => {
    //   block [0x825BAA78..0x825BAA84)
	// 825BAA78: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BAA7C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAA80: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BAA84; continue 'dispatch;
            }
            0x825BAA84 => {
    //   block [0x825BAA84..0x825BAA94)
	// 825BAA84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAA88: 409A000C  bne cr6, 0x825baa94
	if !ctx.cr[6].eq {
	pc = 0x825BAA94; continue 'dispatch;
	}
	// 825BAA8C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BAA90: 48000010  b 0x825baaa0
	pc = 0x825BAAA0; continue 'dispatch;
            }
            0x825BAA94 => {
    //   block [0x825BAA94..0x825BAAA0)
	// 825BAA94: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAA98: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAA9C: 7D48DBD6  divw r10, r8, r27
	ctx.r[10].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	pc = 0x825BAAA0; continue 'dispatch;
            }
            0x825BAAA0 => {
    //   block [0x825BAAA0..0x825BAAC8)
	// 825BAAA0: 3D001555  lis r8, 0x1555
	ctx.r[8].s64 = 357892096;
	// 825BAAA4: 61085555  ori r8, r8, 0x5555
	ctx.r[8].u64 = ctx.r[8].u64 | 21845;
	// 825BAAA8: 7CEA4050  subf r7, r10, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825BAAAC: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825BAAB0: 40980018  bge cr6, 0x825baac8
	if !ctx.cr[6].lt {
	pc = 0x825BAAC8; continue 'dispatch;
	}
	// 825BAAB4: 4BF3A01D  bl 0x824f4ad0
	ctx.lr = 0x825BAAB8;
	sub_824F4AD0(ctx, base);
	// 825BAAB8: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BAABC: 4BBFD05D  bl 0x821b7b18
	ctx.lr = 0x825BAAC0;
	sub_821B7B18(ctx, base);
	// 825BAAC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BAAC4: 486EE98C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BAAC8 => {
    //   block [0x825BAAC8..0x825BAAD8)
	// 825BAAC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAACC: 409A000C  bne cr6, 0x825baad8
	if !ctx.cr[6].eq {
	pc = 0x825BAAD8; continue 'dispatch;
	}
	// 825BAAD0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BAAD4: 48000010  b 0x825baae4
	pc = 0x825BAAE4; continue 'dispatch;
            }
            0x825BAAD8 => {
    //   block [0x825BAAD8..0x825BAAE4)
	// 825BAAD8: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAADC: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAAE0: 7D47DBD6  divw r10, r7, r27
	ctx.r[10].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	pc = 0x825BAAE4; continue 'dispatch;
            }
            0x825BAAE4 => {
    //   block [0x825BAAE4..0x825BAB08)
	// 825BAAE4: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825BAAE8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BAAEC: 40980140  bge cr6, 0x825bac2c
	if !ctx.cr[6].lt {
	pc = 0x825BAC2C; continue 'dispatch;
	}
	// 825BAAF0: 552AF87E  srwi r10, r9, 1
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BAAF4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825BAAF8: 7D0A4050  subf r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	// 825BAAFC: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BAB00: 41980008  blt cr6, 0x825bab08
	if ctx.cr[6].lt {
	pc = 0x825BAB08; continue 'dispatch;
	}
	// 825BAB04: 7F4A4A14  add r26, r10, r9
	ctx.r[26].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	pc = 0x825BAB08; continue 'dispatch;
            }
            0x825BAB08 => {
    //   block [0x825BAB08..0x825BAB18)
	// 825BAB08: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAB0C: 409A000C  bne cr6, 0x825bab18
	if !ctx.cr[6].eq {
	pc = 0x825BAB18; continue 'dispatch;
	}
	// 825BAB10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BAB14: 48000010  b 0x825bab24
	pc = 0x825BAB24; continue 'dispatch;
            }
            0x825BAB18 => {
    //   block [0x825BAB18..0x825BAB24)
	// 825BAB18: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAB1C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAB20: 7D49DBD6  divw r10, r9, r27
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BAB24; continue 'dispatch;
            }
            0x825BAB24 => {
    //   block [0x825BAB24..0x825BAB44)
	// 825BAB24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 825BAB28: 7F1A5040  cmplw cr6, r26, r10
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BAB2C: 4098001C  bge cr6, 0x825bab48
	if !ctx.cr[6].lt {
	pc = 0x825BAB48; continue 'dispatch;
	}
	// 825BAB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAB34: 419A0010  beq cr6, 0x825bab44
	if ctx.cr[6].eq {
	pc = 0x825BAB44; continue 'dispatch;
	}
	// 825BAB38: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAB3C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAB40: 7D69DBD6  divw r11, r9, r27
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BAB44; continue 'dispatch;
            }
            0x825BAB44 => {
    //   block [0x825BAB44..0x825BAB48)
	// 825BAB44: 3B4B0001  addi r26, r11, 1
	ctx.r[26].s64 = ctx.r[11].s64 + 1;
	pc = 0x825BAB48; continue 'dispatch;
            }
            0x825BAB48 => {
    //   block [0x825BAB48..0x825BABAC)
	// 825BAB48: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825BAB4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAB50: 4BD68861  bl 0x823233b0
	ctx.lr = 0x825BAB54;
	sub_823233B0(ctx, base);
	// 825BAB54: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BAB58: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BAB5C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAB60: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BAB64: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825BAB68: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAB6C: 482F27D5  bl 0x828ad340
	ctx.lr = 0x825BAB70;
	sub_828AD340(ctx, base);
	// 825BAB70: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BAB74: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BAB78: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BAB7C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAB80: 4BFFF5B1  bl 0x825ba130
	ctx.lr = 0x825BAB84;
	sub_825BA130(ctx, base);
	// 825BAB84: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825BAB88: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BAB8C: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAB94: 482F27AD  bl 0x828ad340
	ctx.lr = 0x825BAB98;
	sub_828AD340(ctx, base);
	// 825BAB98: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAB9C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BABA0: 409A000C  bne cr6, 0x825babac
	if !ctx.cr[6].eq {
	pc = 0x825BABAC; continue 'dispatch;
	}
	// 825BABA4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BABA8: 48000010  b 0x825babb8
	pc = 0x825BABB8; continue 'dispatch;
            }
            0x825BABAC => {
    //   block [0x825BABAC..0x825BABB8)
	// 825BABAC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BABB0: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BABB4: 7D49DBD6  divw r10, r9, r27
	ctx.r[10].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BABB8; continue 'dispatch;
            }
            0x825BABB8 => {
    //   block [0x825BABB8..0x825BABD4)
	// 825BABB8: 3B6A0001  addi r27, r10, 1
	ctx.r[27].s64 = ctx.r[10].s64 + 1;
	// 825BABBC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BABC0: 419A0030  beq cr6, 0x825babf0
	if ctx.cr[6].eq {
	pc = 0x825BABF0; continue 'dispatch;
	}
	// 825BABC4: 839F0008  lwz r28, 8(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BABC8: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825BABCC: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BABD0: 419A0018  beq cr6, 0x825babe8
	if ctx.cr[6].eq {
	pc = 0x825BABE8; continue 'dispatch;
	}
	pc = 0x825BABD4; continue 'dispatch;
            }
            0x825BABD4 => {
    //   block [0x825BABD4..0x825BABE8)
	// 825BABD4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BABD8: 4BBFCF41  bl 0x821b7b18
	ctx.lr = 0x825BABDC;
	sub_821B7B18(ctx, base);
	// 825BABDC: 3BDE000C  addi r30, r30, 0xc
	ctx.r[30].s64 = ctx.r[30].s64 + 12;
	// 825BABE0: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BABE4: 409AFFF0  bne cr6, 0x825babd4
	if !ctx.cr[6].eq {
	pc = 0x825BABD4; continue 'dispatch;
	}
	pc = 0x825BABE8; continue 'dispatch;
            }
            0x825BABE8 => {
    //   block [0x825BABE8..0x825BABF0)
	// 825BABE8: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BABEC: 4BC6114D  bl 0x8221bd38
	ctx.lr = 0x825BABF0;
	sub_8221BD38(ctx, base);
	pc = 0x825BABF0; continue 'dispatch;
            }
            0x825BABF0 => {
    //   block [0x825BABF0..0x825BAC2C)
	// 825BABF0: 574B083C  slwi r11, r26, 1
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BABF4: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825BABF8: 576A083C  slwi r10, r27, 1
	ctx.r[10].u32 = ctx.r[27].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BABFC: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 825BAC00: 7D5B5214  add r10, r27, r10
	ctx.r[10].u64 = ctx.r[27].u64 + ctx.r[10].u64;
	// 825BAC04: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAC08: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BAC0C: 7D2BEA14  add r9, r11, r29
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BAC10: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825BAC14: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825BAC18: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BAC1C: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BAC20: 4BBFCEF9  bl 0x821b7b18
	ctx.lr = 0x825BAC24;
	sub_821B7B18(ctx, base);
	// 825BAC24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BAC28: 486EE828  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BAC2C => {
    //   block [0x825BAC2C..0x825BAC84)
	// 825BAC2C: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BAC30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAC34: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAC38: 7D7C2850  subf r11, r28, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[28].s64;
	// 825BAC3C: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BAC40: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825BAC44: 40980040  bge cr6, 0x825bac84
	if !ctx.cr[6].lt {
	pc = 0x825BAC84; continue 'dispatch;
	}
	// 825BAC48: 38DC000C  addi r6, r28, 0xc
	ctx.r[6].s64 = ctx.r[28].s64 + 12;
	// 825BAC4C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BAC50: 482F26F1  bl 0x828ad340
	ctx.lr = 0x825BAC54;
	sub_828AD340(ctx, base);
	// 825BAC54: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAC58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BAC5C: 7D7C2050  subf r11, r28, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[28].s64;
	// 825BAC60: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAC64: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BAC68: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 825BAC6C: 4BFFF4C5  bl 0x825ba130
	ctx.lr = 0x825BAC70;
	sub_825BA130(ctx, base);
	// 825BAC70: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAC74: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BAC78: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BAC7C: 388BFFF4  addi r4, r11, -0xc
	ctx.r[4].s64 = ctx.r[11].s64 + -12;
	// 825BAC80: 48000078  b 0x825bacf8
	pc = 0x825BACF8; continue 'dispatch;
            }
            0x825BAC84 => {
    //   block [0x825BAC84..0x825BACA4)
	// 825BAC84: 3BA5FFF4  addi r29, r5, -0xc
	ctx.r[29].s64 = ctx.r[5].s64 + -12;
	// 825BAC88: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825BAC8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BAC90: 482F26B1  bl 0x828ad340
	ctx.lr = 0x825BAC94;
	sub_828AD340(ctx, base);
	// 825BAC94: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BAC98: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BAC9C: 419A0058  beq cr6, 0x825bacf4
	if ctx.cr[6].eq {
	pc = 0x825BACF4; continue 'dispatch;
	}
	// 825BACA0: 3BFD0010  addi r31, r29, 0x10
	ctx.r[31].s64 = ctx.r[29].s64 + 16;
	pc = 0x825BACA4; continue 'dispatch;
            }
            0x825BACA4 => {
    //   block [0x825BACA4..0x825BACEC)
	// 825BACA4: 3BBDFFF4  addi r29, r29, -0xc
	ctx.r[29].s64 = ctx.r[29].s64 + -12;
	// 825BACA8: 3BFFFFF4  addi r31, r31, -0xc
	ctx.r[31].s64 = ctx.r[31].s64 + -12;
	// 825BACAC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BACB0: 917FFFFC  stw r11, -4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), ctx.r[11].u32 ) };
	// 825BACB4: 83DFFFF8  lwz r30, -8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BACB8: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BACBC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BACC0: 837FFFF4  lwz r27, -0xc(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BACC4: 419A0028  beq cr6, 0x825bacec
	if ctx.cr[6].eq {
	pc = 0x825BACEC; continue 'dispatch;
	}
	// 825BACC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BACCC: 4BBFCE4D  bl 0x821b7b18
	ctx.lr = 0x825BACD0;
	sub_821B7B18(ctx, base);
	// 825BACD0: 937F0000  stw r27, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BACD4: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BACD8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825BACDC: 419A0010  beq cr6, 0x825bacec
	if ctx.cr[6].eq {
	pc = 0x825BACEC; continue 'dispatch;
	}
	// 825BACE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BACE4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BACE8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x825BACEC; continue 'dispatch;
            }
            0x825BACEC => {
    //   block [0x825BACEC..0x825BACF4)
	// 825BACEC: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BACF0: 409AFFB4  bne cr6, 0x825baca4
	if !ctx.cr[6].eq {
	pc = 0x825BACA4; continue 'dispatch;
	}
	pc = 0x825BACF4; continue 'dispatch;
            }
            0x825BACF4 => {
    //   block [0x825BACF4..0x825BACF8)
	// 825BACF4: 389C000C  addi r4, r28, 0xc
	ctx.r[4].s64 = ctx.r[28].s64 + 12;
	pc = 0x825BACF8; continue 'dispatch;
            }
            0x825BACF8 => {
    //   block [0x825BACF8..0x825BAD14)
	// 825BACF8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BACFC: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BAD00: 482CD721  bl 0x82888420
	ctx.lr = 0x825BAD04;
	sub_82888420(ctx, base);
	// 825BAD04: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BAD08: 4BBFCE11  bl 0x821b7b18
	ctx.lr = 0x825BAD0C;
	sub_821B7B18(ctx, base);
	// 825BAD0C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BAD10: 486EE740  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BAD18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BAD18 size=136
    let mut pc: u32 = 0x825BAD18;
    'dispatch: loop {
        match pc {
            0x825BAD18 => {
    //   block [0x825BAD18..0x825BAD28)
	// 825BAD18: 7CA903A6  mtctr r5
	ctx.ctr.u64 = ctx.r[5].u64;
	// 825BAD1C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825BAD20: 419A0074  beq cr6, 0x825bad94
	if ctx.cr[6].eq {
	pc = 0x825BAD94; continue 'dispatch;
	}
	// 825BAD24: 39640011  addi r11, r4, 0x11
	ctx.r[11].s64 = ctx.r[4].s64 + 17;
	pc = 0x825BAD28; continue 'dispatch;
            }
            0x825BAD28 => {
    //   block [0x825BAD28..0x825BAD8C)
	// 825BAD28: 354BFFEF  addic. r10, r11, -0x11
	ctx.xer.ca = (ctx.r[11].u32 > (!(-17 as u32)));
	ctx.r[10].s64 = ctx.r[11].s64 + -17;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BAD2C: 41820060  beq 0x825bad8c
	if ctx.cr[0].eq {
	pc = 0x825BAD8C; continue 'dispatch;
	}
	// 825BAD30: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAD34: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825BAD38: 912BFFEF  stw r9, -0x11(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17 as u32), ctx.r[9].u32 ) };
	// 825BAD3C: 81060004  lwz r8, 4(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAD40: 910BFFF3  stw r8, -0xd(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-13 as u32), ctx.r[8].u32 ) };
	// 825BAD44: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAD48: 90EBFFF7  stw r7, -9(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-9 as u32), ctx.r[7].u32 ) };
	// 825BAD4C: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BAD50: D00BFFFB  stfs f0, -5(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-5 as u32), tmp.u32 ) };
	// 825BAD54: 88660013  lbz r3, 0x13(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BAD58: 89460010  lbz r10, 0x10(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BAD5C: 89260011  lbz r9, 0x11(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BAD60: 89060012  lbz r8, 0x12(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BAD64: 990B0001  stb r8, 1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(1 as u32), ctx.r[8].u8 ) };
	// 825BAD68: 992B0000  stb r9, 0(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u8 ) };
	// 825BAD6C: 994BFFFF  stb r10, -1(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(-1 as u32), ctx.r[10].u8 ) };
	// 825BAD70: 986B0002  stb r3, 2(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(2 as u32), ctx.r[3].u8 ) };
	// 825BAD74: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BAD78: D1AB0003  stfs f13, 3(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(3 as u32), tmp.u32 ) };
	// 825BAD7C: 80E60018  lwz r7, 0x18(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BAD80: 90EB0007  stw r7, 7(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), ctx.r[7].u32 ) };
	// 825BAD84: 8866001C  lbz r3, 0x1c(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BAD88: 986B000B  stb r3, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[3].u8 ) };
	pc = 0x825BAD8C; continue 'dispatch;
            }
            0x825BAD8C => {
    //   block [0x825BAD8C..0x825BAD94)
	// 825BAD8C: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825BAD90: 4200FF98  bdnz 0x825bad28
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x825BAD28; continue 'dispatch;
	}
	pc = 0x825BAD94; continue 'dispatch;
            }
            0x825BAD94 => {
    //   block [0x825BAD94..0x825BADA0)
	// 825BAD94: 54AB2834  slwi r11, r5, 5
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAD98: 7C6B2214  add r3, r11, r4
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 825BAD9C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BADA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BADA0 size=124
    let mut pc: u32 = 0x825BADA0;
    'dispatch: loop {
        match pc {
            0x825BADA0 => {
    //   block [0x825BADA0..0x825BADD4)
	// 825BADA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BADA4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BADA8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BADAC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BADB0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BADB4: 3D60071C  lis r11, 0x71c
	ctx.r[11].s64 = 119275520;
	// 825BADB8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BADBC: 616A71C7  ori r10, r11, 0x71c7
	ctx.r[10].u64 = ctx.r[11].u64 | 29127;
	// 825BADC0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BADC4: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BADC8: 4099000C  ble cr6, 0x825badd4
	if !ctx.cr[6].gt {
	pc = 0x825BADD4; continue 'dispatch;
	}
	// 825BADCC: 4848C6FD  bl 0x82a474c8
	ctx.lr = 0x825BADD0;
	sub_82A474C8(ctx, base);
	// 825BADD0: 48000030  b 0x825bae00
	pc = 0x825BAE00; continue 'dispatch;
            }
            0x825BADD4 => {
    //   block [0x825BADD4..0x825BAE00)
	// 825BADD4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BADD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BADDC: 4858C365  bl 0x82b47140
	ctx.lr = 0x825BADE0;
	sub_82B47140(ctx, base);
	// 825BADE0: 57CA1838  slwi r10, r30, 3
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BADE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825BADE8: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BADEC: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825BADF0: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BADF4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BADF8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BADFC: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	pc = 0x825BAE00; continue 'dispatch;
            }
            0x825BAE00 => {
    //   block [0x825BAE00..0x825BAE1C)
	// 825BAE00: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825BAE04: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BAE08: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BAE0C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BAE10: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BAE14: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BAE18: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BAE20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BAE20 size=880
    let mut pc: u32 = 0x825BAE20;
    'dispatch: loop {
        match pc {
            0x825BAE20 => {
    //   block [0x825BAE20..0x825BAEC8)
	// 825BAE20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BAE24: 486EE5D5  bl 0x82ca93f8
	ctx.lr = 0x825BAE28;
	sub_82CA93D0(ctx, base);
	// 825BAE28: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BAE2C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BAE30: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 825BAE34: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825BAE38: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BAE3C: C0060008  lfs f0, 8(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BAE40: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAE44: C1A60018  lfs f13, 0x18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BAE48: 8106000C  lwz r8, 0xc(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BAE4C: C1860020  lfs f12, 0x20(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BAE50: 88E60012  lbz r7, 0x12(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BAE54: 88A60011  lbz r5, 0x11(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BAE58: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 825BAE5C: 88860010  lbz r4, 0x10(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BAE60: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 825BAE64: 88660013  lbz r3, 0x13(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BAE68: D1810070  stfs f12, 0x70(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 825BAE6C: 8BC60016  lbz r30, 0x16(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BAE70: 3B000024  li r24, 0x24
	ctx.r[24].s64 = 36;
	// 825BAE74: 8BA60015  lbz r29, 0x15(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BAE78: 8B860014  lbz r28, 0x14(r6)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BAE7C: 8B660017  lbz r27, 0x17(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BAE80: 80C6001C  lwz r6, 0x1c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BAE84: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAE88: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BAE8C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BAE90: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BAE94: 9101005C  stw r8, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[8].u32 ) };
	// 825BAE98: 98E10062  stb r7, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[7].u8 ) };
	// 825BAE9C: 98A10061  stb r5, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[5].u8 ) };
	// 825BAEA0: 98810060  stb r4, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u8 ) };
	// 825BAEA4: 98610063  stb r3, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[3].u8 ) };
	// 825BAEA8: 9BC10066  stb r30, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[30].u8 ) };
	// 825BAEAC: 9BA10065  stb r29, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[29].u8 ) };
	// 825BAEB0: 9B810064  stb r28, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[28].u8 ) };
	// 825BAEB4: 9B610067  stb r27, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[27].u8 ) };
	// 825BAEB8: 90C1006C  stw r6, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[6].u32 ) };
	// 825BAEBC: 409A000C  bne cr6, 0x825baec8
	if !ctx.cr[6].eq {
	pc = 0x825BAEC8; continue 'dispatch;
	}
	// 825BAEC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BAEC4: 48000010  b 0x825baed4
	pc = 0x825BAED4; continue 'dispatch;
            }
            0x825BAEC8 => {
    //   block [0x825BAEC8..0x825BAED4)
	// 825BAEC8: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BAECC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAED0: 7D29C3D6  divw r9, r9, r24
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[24].s32;
	pc = 0x825BAED4; continue 'dispatch;
            }
            0x825BAED4 => {
    //   block [0x825BAED4..0x825BAF08)
	// 825BAED4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825BAED8: 419A02B0  beq cr6, 0x825bb188
	if ctx.cr[6].eq {
	pc = 0x825BB188; continue 'dispatch;
	}
	// 825BAEDC: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAEE0: 3D40071C  lis r10, 0x71c
	ctx.r[10].s64 = 119275520;
	// 825BAEE4: 7D0BF050  subf r8, r11, r30
	ctx.r[8].s64 = ctx.r[30].s64 - ctx.r[11].s64;
	// 825BAEE8: 614A71C7  ori r10, r10, 0x71c7
	ctx.r[10].u64 = ctx.r[10].u64 | 29127;
	// 825BAEEC: 7D68C3D6  divw r11, r8, r24
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[24].s32;
	// 825BAEF0: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAEF4: 7F07D040  cmplw cr6, r7, r26
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BAEF8: 40980010  bge cr6, 0x825baf08
	if !ctx.cr[6].lt {
	pc = 0x825BAF08; continue 'dispatch;
	}
	// 825BAEFC: 4848C5CD  bl 0x82a474c8
	ctx.lr = 0x825BAF00;
	sub_82A474C8(ctx, base);
	// 825BAF00: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BAF04: 486EE544  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BAF08 => {
    //   block [0x825BAF08..0x825BAF2C)
	// 825BAF08: 7D0BD214  add r8, r11, r26
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BAF0C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BAF10: 40980100  bge cr6, 0x825bb010
	if !ctx.cr[6].lt {
	pc = 0x825BB010; continue 'dispatch;
	}
	// 825BAF14: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAF18: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	// 825BAF1C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BAF20: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BAF24: 41980008  blt cr6, 0x825baf2c
	if ctx.cr[6].lt {
	pc = 0x825BAF2C; continue 'dispatch;
	}
	// 825BAF28: 7F2B4A14  add r25, r11, r9
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BAF2C; continue 'dispatch;
            }
            0x825BAF2C => {
    //   block [0x825BAF2C..0x825BAF38)
	// 825BAF2C: 7F194040  cmplw cr6, r25, r8
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BAF30: 40980008  bge cr6, 0x825baf38
	if !ctx.cr[6].lt {
	pc = 0x825BAF38; continue 'dispatch;
	}
	// 825BAF34: 7D194378  mr r25, r8
	ctx.r[25].u64 = ctx.r[8].u64;
	pc = 0x825BAF38; continue 'dispatch;
            }
            0x825BAF38 => {
    //   block [0x825BAF38..0x825BAF5C)
	// 825BAF38: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825BAF3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAF40: 4858C201  bl 0x82b47140
	ctx.lr = 0x825BAF44;
	sub_82B47140(ctx, base);
	// 825BAF44: 83BF0004  lwz r29, 4(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAF48: 83C100DC  lwz r30, 0xdc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 825BAF4C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BAF50: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BAF54: 7F7CDB78  mr r28, r27
	ctx.r[28].u64 = ctx.r[27].u64;
	// 825BAF58: 419A0024  beq cr6, 0x825baf7c
	if ctx.cr[6].eq {
	pc = 0x825BAF7C; continue 'dispatch;
	}
	pc = 0x825BAF5C; continue 'dispatch;
            }
            0x825BAF5C => {
    //   block [0x825BAF5C..0x825BAF7C)
	// 825BAF5C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BAF60: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BAF64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAF68: 48002189  bl 0x825bd0f0
	ctx.lr = 0x825BAF6C;
	sub_825BD0F0(ctx, base);
	// 825BAF6C: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 825BAF70: 3B9C0024  addi r28, r28, 0x24
	ctx.r[28].s64 = ctx.r[28].s64 + 36;
	// 825BAF74: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BAF78: 409AFFE4  bne cr6, 0x825baf5c
	if !ctx.cr[6].eq {
	pc = 0x825BAF5C; continue 'dispatch;
	}
	pc = 0x825BAF7C; continue 'dispatch;
            }
            0x825BAF7C => {
    //   block [0x825BAF7C..0x825BAFA0)
	// 825BAF7C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BAF80: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825BAF84: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BAF88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAF8C: 4BFFF585  bl 0x825ba510
	ctx.lr = 0x825BAF90;
	sub_825BA510(ctx, base);
	// 825BAF90: 83BF0008  lwz r29, 8(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAF94: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BAF98: 419A0024  beq cr6, 0x825bafbc
	if ctx.cr[6].eq {
	pc = 0x825BAFBC; continue 'dispatch;
	}
	// 825BAF9C: 7F9E1850  subf r28, r30, r3
	ctx.r[28].s64 = ctx.r[3].s64 - ctx.r[30].s64;
	pc = 0x825BAFA0; continue 'dispatch;
            }
            0x825BAFA0 => {
    //   block [0x825BAFA0..0x825BAFBC)
	// 825BAFA0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BAFA4: 7C9EE214  add r4, r30, r28
	ctx.r[4].u64 = ctx.r[30].u64 + ctx.r[28].u64;
	// 825BAFA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BAFAC: 48002145  bl 0x825bd0f0
	ctx.lr = 0x825BAFB0;
	sub_825BD0F0(ctx, base);
	// 825BAFB0: 3BDE0024  addi r30, r30, 0x24
	ctx.r[30].s64 = ctx.r[30].s64 + 36;
	// 825BAFB4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BAFB8: 409AFFE8  bne cr6, 0x825bafa0
	if !ctx.cr[6].eq {
	pc = 0x825BAFA0; continue 'dispatch;
	}
	pc = 0x825BAFBC; continue 'dispatch;
            }
            0x825BAFBC => {
    //   block [0x825BAFBC..0x825BAFDC)
	// 825BAFBC: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BAFC0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BAFC4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BAFC8: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BAFCC: 7D6AC3D6  divw r11, r10, r24
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[24].s32;
	// 825BAFD0: 7FCBD214  add r30, r11, r26
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BAFD4: 419A0008  beq cr6, 0x825bafdc
	if ctx.cr[6].eq {
	pc = 0x825BAFDC; continue 'dispatch;
	}
	// 825BAFD8: 4BC60D61  bl 0x8221bd38
	ctx.lr = 0x825BAFDC;
	sub_8221BD38(ctx, base);
	pc = 0x825BAFDC; continue 'dispatch;
            }
            0x825BAFDC => {
    //   block [0x825BAFDC..0x825BB010)
	// 825BAFDC: 57CB1838  slwi r11, r30, 3
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAFE0: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825BAFE4: 572A1838  slwi r10, r25, 3
	ctx.r[10].u32 = ctx.r[25].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BAFE8: 7D3E5A14  add r9, r30, r11
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825BAFEC: 7D595214  add r10, r25, r10
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 825BAFF0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BAFF4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BAFF8: 7CEBDA14  add r7, r11, r27
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825BAFFC: 7D0ADA14  add r8, r10, r27
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 825BB000: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825BB004: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825BB008: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BB00C: 486EE43C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB010 => {
    //   block [0x825BB010..0x825BB044)
	// 825BB010: 836100DC  lwz r27, 0xdc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 825BB014: 7D7BF050  subf r11, r27, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[27].s64;
	// 825BB018: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 825BB01C: 574B1838  slwi r11, r26, 3
	ctx.r[11].u32 = ctx.r[26].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB020: 7F0AD040  cmplw cr6, r10, r26
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BB024: 7D7A5A14  add r11, r26, r11
	ctx.r[11].u64 = ctx.r[26].u64 + ctx.r[11].u64;
	// 825BB028: 40980078  bge cr6, 0x825bb0a0
	if !ctx.cr[6].lt {
	pc = 0x825BB0A0; continue 'dispatch;
	}
	// 825BB02C: 557C103A  slwi r28, r11, 2
	ctx.r[28].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 825BB030: 7F7DDB78  mr r29, r27
	ctx.r[29].u64 = ctx.r[27].u64;
	// 825BB034: 7F1BF040  cmplw cr6, r27, r30
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB038: 7D7CDA14  add r11, r28, r27
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[27].u64;
	// 825BB03C: 419A0024  beq cr6, 0x825bb060
	if ctx.cr[6].eq {
	pc = 0x825BB060; continue 'dispatch;
	}
	// 825BB040: 7F3B5850  subf r25, r27, r11
	ctx.r[25].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	pc = 0x825BB044; continue 'dispatch;
            }
            0x825BB044 => {
    //   block [0x825BB044..0x825BB060)
	// 825BB044: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BB048: 7C9DCA14  add r4, r29, r25
	ctx.r[4].u64 = ctx.r[29].u64 + ctx.r[25].u64;
	// 825BB04C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB050: 480020A1  bl 0x825bd0f0
	ctx.lr = 0x825BB054;
	sub_825BD0F0(ctx, base);
	// 825BB054: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 825BB058: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB05C: 409AFFE8  bne cr6, 0x825bb044
	if !ctx.cr[6].eq {
	pc = 0x825BB044; continue 'dispatch;
	}
	pc = 0x825BB060; continue 'dispatch;
            }
            0x825BB060 => {
    //   block [0x825BB060..0x825BB0A0)
	// 825BB060: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB064: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BB068: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB06C: 7D7B2050  subf r11, r27, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[27].s64;
	// 825BB070: 7D4BC3D6  divw r10, r11, r24
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[24].s32;
	// 825BB074: 7CAAD050  subf r5, r10, r26
	ctx.r[5].s64 = ctx.r[26].s64 - ctx.r[10].s64;
	// 825BB078: 4BFFF499  bl 0x825ba510
	ctx.lr = 0x825BB07C;
	sub_825BA510(ctx, base);
	// 825BB07C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB080: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BB084: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825BB088: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BB08C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BB090: 7C9C5850  subf r4, r28, r11
	ctx.r[4].s64 = ctx.r[11].s64 - ctx.r[28].s64;
	// 825BB094: 480013F5  bl 0x825bc488
	ctx.lr = 0x825BB098;
	sub_825BC488(ctx, base);
	// 825BB098: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BB09C: 486EE3AC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB0A0 => {
    //   block [0x825BB0A0..0x825BB0B8)
	// 825BB0A0: 5579103A  slwi r25, r11, 2
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825BB0A4: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 825BB0A8: 7F59F050  subf r26, r25, r30
	ctx.r[26].s64 = ctx.r[30].s64 - ctx.r[25].s64;
	// 825BB0AC: 7F5DD378  mr r29, r26
	ctx.r[29].u64 = ctx.r[26].u64;
	// 825BB0B0: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB0B4: 419A0024  beq cr6, 0x825bb0d8
	if ctx.cr[6].eq {
	pc = 0x825BB0D8; continue 'dispatch;
	}
	pc = 0x825BB0B8; continue 'dispatch;
            }
            0x825BB0B8 => {
    //   block [0x825BB0B8..0x825BB0D8)
	// 825BB0B8: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BB0BC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BB0C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB0C4: 4800202D  bl 0x825bd0f0
	ctx.lr = 0x825BB0C8;
	sub_825BD0F0(ctx, base);
	// 825BB0C8: 3BBD0024  addi r29, r29, 0x24
	ctx.r[29].s64 = ctx.r[29].s64 + 36;
	// 825BB0CC: 3B9C0024  addi r28, r28, 0x24
	ctx.r[28].s64 = ctx.r[28].s64 + 36;
	// 825BB0D0: 7F1DF040  cmplw cr6, r29, r30
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB0D4: 409AFFE4  bne cr6, 0x825bb0b8
	if !ctx.cr[6].eq {
	pc = 0x825BB0B8; continue 'dispatch;
	}
	pc = 0x825BB0D8; continue 'dispatch;
            }
            0x825BB0D8 => {
    //   block [0x825BB0D8..0x825BB0F0)
	// 825BB0D8: 939F0008  stw r28, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[28].u32 ) };
	// 825BB0DC: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825BB0E0: 7F1BD040  cmplw cr6, r27, r26
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BB0E4: 419A0094  beq cr6, 0x825bb178
	if ctx.cr[6].eq {
	pc = 0x825BB178; continue 'dispatch;
	}
	// 825BB0E8: 7D595A14  add r10, r25, r11
	ctx.r[10].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 825BB0EC: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	pc = 0x825BB0F0; continue 'dispatch;
            }
            0x825BB0F0 => {
    //   block [0x825BB0F0..0x825BB178)
	// 825BB0F0: 396BFFDC  addi r11, r11, -0x24
	ctx.r[11].s64 = ctx.r[11].s64 + -36;
	// 825BB0F4: 394AFFDC  addi r10, r10, -0x24
	ctx.r[10].s64 = ctx.r[10].s64 + -36;
	// 825BB0F8: 7F0BD840  cmplw cr6, r11, r27
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825BB0FC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB100: 912AFFF8  stw r9, -8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-8 as u32), ctx.r[9].u32 ) };
	// 825BB104: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB108: 910AFFFC  stw r8, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 825BB10C: C00B0008  lfs f0, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB110: D00A0000  stfs f0, 0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BB114: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB118: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BB11C: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BB120: 98CA0008  stb r6, 8(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u8 ) };
	// 825BB124: 88AB0011  lbz r5, 0x11(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BB128: 98AA0009  stb r5, 9(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(9 as u32), ctx.r[5].u8 ) };
	// 825BB12C: 888B0012  lbz r4, 0x12(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BB130: 988A000A  stb r4, 0xa(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(10 as u32), ctx.r[4].u8 ) };
	// 825BB134: 886B0013  lbz r3, 0x13(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BB138: 986A000B  stb r3, 0xb(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(11 as u32), ctx.r[3].u8 ) };
	// 825BB13C: 892B0014  lbz r9, 0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BB140: 992A000C  stb r9, 0xc(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u8 ) };
	// 825BB144: 890B0015  lbz r8, 0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BB148: 990A000D  stb r8, 0xd(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(13 as u32), ctx.r[8].u8 ) };
	// 825BB14C: 88EB0016  lbz r7, 0x16(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BB150: 98EA000E  stb r7, 0xe(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(14 as u32), ctx.r[7].u8 ) };
	// 825BB154: 88CB0017  lbz r6, 0x17(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BB158: 98CA000F  stb r6, 0xf(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(15 as u32), ctx.r[6].u8 ) };
	// 825BB15C: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BB160: D1AA0010  stfs f13, 0x10(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825BB164: 80AB001C  lwz r5, 0x1c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BB168: 90AA0014  stw r5, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[5].u32 ) };
	// 825BB16C: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BB170: D18A0018  stfs f12, 0x18(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825BB174: 409AFF7C  bne cr6, 0x825bb0f0
	if !ctx.cr[6].eq {
	pc = 0x825BB0F0; continue 'dispatch;
	}
	pc = 0x825BB178; continue 'dispatch;
            }
            0x825BB178 => {
    //   block [0x825BB178..0x825BB188)
	// 825BB178: 7C99DA14  add r4, r25, r27
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[27].u64;
	// 825BB17C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BB180: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BB184: 48001305  bl 0x825bc488
	ctx.lr = 0x825BB188;
	sub_825BC488(ctx, base);
	pc = 0x825BB188; continue 'dispatch;
            }
            0x825BB188 => {
    //   block [0x825BB188..0x825BB190)
	// 825BB188: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BB18C: 486EE2BC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BB190(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BB190 size=684
    let mut pc: u32 = 0x825BB190;
    'dispatch: loop {
        match pc {
            0x825BB190 => {
    //   block [0x825BB190..0x825BB1D4)
	// 825BB190: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BB194: 486EE261  bl 0x82ca93f4
	ctx.lr = 0x825BB198;
	sub_82CA93D0(ctx, base);
	// 825BB198: DBE1FFA8  stfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 825BB19C: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BB1A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BB1A4: C3E60000  lfs f31, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BB1A8: 83460004  lwz r26, 4(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB1AC: 3B600014  li r27, 0x14
	ctx.r[27].s64 = 20;
	// 825BB1B0: 83260008  lwz r25, 8(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB1B4: 8306000C  lwz r24, 0xc(r6)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB1B8: 82E60010  lwz r23, 0x10(r6)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BB1BC: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB1C0: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 825BB1C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB1C8: 409A000C  bne cr6, 0x825bb1d4
	if !ctx.cr[6].eq {
	pc = 0x825BB1D4; continue 'dispatch;
	}
	// 825BB1CC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BB1D0: 48000010  b 0x825bb1e0
	pc = 0x825BB1E0; continue 'dispatch;
            }
            0x825BB1D4 => {
    //   block [0x825BB1D4..0x825BB1E0)
	// 825BB1D4: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB1D8: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB1DC: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BB1E0; continue 'dispatch;
            }
            0x825BB1E0 => {
    //   block [0x825BB1E0..0x825BB210)
	// 825BB1E0: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB1E4: 3D400CCC  lis r10, 0xccc
	ctx.r[10].s64 = 214695936;
	// 825BB1E8: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825BB1EC: 614ACCCC  ori r10, r10, 0xcccc
	ctx.r[10].u64 = ctx.r[10].u64 | 52428;
	// 825BB1F0: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 825BB1F4: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB1F8: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825BB1FC: 40980014  bge cr6, 0x825bb210
	if !ctx.cr[6].lt {
	pc = 0x825BB210; continue 'dispatch;
	}
	// 825BB200: 4848C2C9  bl 0x82a474c8
	ctx.lr = 0x825BB204;
	sub_82A474C8(ctx, base);
	// 825BB204: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB208: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825BB20C: 486EE238  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB210 => {
    //   block [0x825BB210..0x825BB234)
	// 825BB210: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 825BB214: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB218: 409800D8  bge cr6, 0x825bb2f0
	if !ctx.cr[6].lt {
	pc = 0x825BB2F0; continue 'dispatch;
	}
	// 825BB21C: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB220: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825BB224: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB228: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB22C: 41980008  blt cr6, 0x825bb234
	if ctx.cr[6].lt {
	pc = 0x825BB234; continue 'dispatch;
	}
	// 825BB230: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BB234; continue 'dispatch;
            }
            0x825BB234 => {
    //   block [0x825BB234..0x825BB240)
	// 825BB234: 7F1C4040  cmplw cr6, r28, r8
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB238: 40980008  bge cr6, 0x825bb240
	if !ctx.cr[6].lt {
	pc = 0x825BB240; continue 'dispatch;
	}
	// 825BB23C: 7D1C4378  mr r28, r8
	ctx.r[28].u64 = ctx.r[8].u64;
	pc = 0x825BB240; continue 'dispatch;
            }
            0x825BB240 => {
    //   block [0x825BB240..0x825BB284)
	// 825BB240: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BB244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB248: 4BEA80E1  bl 0x82463328
	ctx.lr = 0x825BB24C;
	sub_82463328(ctx, base);
	// 825BB24C: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BB250: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BB254: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB258: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BB25C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 825BB260: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB264: 480012CD  bl 0x825bc530
	ctx.lr = 0x825BB268;
	sub_825BC530(ctx, base);
	// 825BB268: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BB26C: 419A0018  beq cr6, 0x825bb284
	if ctx.cr[6].eq {
	pc = 0x825BB284; continue 'dispatch;
	}
	// 825BB270: D3E30000  stfs f31, 0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BB274: 93430004  stw r26, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB278: 93230008  stw r25, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825BB27C: 9303000C  stw r24, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 825BB280: 92E30010  stw r23, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	pc = 0x825BB284; continue 'dispatch;
            }
            0x825BB284 => {
    //   block [0x825BB284..0x825BB2B8)
	// 825BB284: 38C30014  addi r6, r3, 0x14
	ctx.r[6].s64 = ctx.r[3].s64 + 20;
	// 825BB288: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB28C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BB290: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB294: 4800129D  bl 0x825bc530
	ctx.lr = 0x825BB298;
	sub_825BC530(ctx, base);
	// 825BB298: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB29C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB2A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BB2A4: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BB2A8: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 825BB2AC: 3BCB0001  addi r30, r11, 1
	ctx.r[30].s64 = ctx.r[11].s64 + 1;
	// 825BB2B0: 419A0008  beq cr6, 0x825bb2b8
	if ctx.cr[6].eq {
	pc = 0x825BB2B8; continue 'dispatch;
	}
	// 825BB2B4: 4BC60A85  bl 0x8221bd38
	ctx.lr = 0x825BB2B8;
	sub_8221BD38(ctx, base);
	pc = 0x825BB2B8; continue 'dispatch;
            }
            0x825BB2B8 => {
    //   block [0x825BB2B8..0x825BB2F0)
	// 825BB2B8: 578B103A  slwi r11, r28, 2
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB2BC: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825BB2C0: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB2C4: 7D7C5A14  add r11, r28, r11
	ctx.r[11].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825BB2C8: 7D3E5214  add r9, r30, r10
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BB2CC: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB2D0: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB2D4: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825BB2D8: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BB2DC: 911F000C  stw r8, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825BB2E0: 90FF0008  stw r7, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825BB2E4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB2E8: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825BB2EC: 486EE158  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB2F0 => {
    //   block [0x825BB2F0..0x825BB32C)
	// 825BB2F0: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BB2F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB2F8: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 825BB2FC: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BB300: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825BB304: 4098009C  bge cr6, 0x825bb3a0
	if !ctx.cr[6].lt {
	pc = 0x825BB3A0; continue 'dispatch;
	}
	// 825BB308: 38DE0014  addi r6, r30, 0x14
	ctx.r[6].s64 = ctx.r[30].s64 + 20;
	// 825BB30C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BB310: 48001221  bl 0x825bc530
	ctx.lr = 0x825BB314;
	sub_825BC530(ctx, base);
	// 825BB314: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB318: 7D5E5850  subf r10, r30, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[30].s64;
	// 825BB31C: 7D2ADBD6  divw r9, r10, r27
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 825BB320: 21490001  subfic r10, r9, 1
	ctx.xer.ca = ctx.r[9].u32 <= 1 as u32;
	ctx.r[10].s64 = (1 as i64) - ctx.r[9].s64;
	// 825BB324: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BB328: 419A002C  beq cr6, 0x825bb354
	if ctx.cr[6].eq {
	pc = 0x825BB354; continue 'dispatch;
	}
	pc = 0x825BB32C; continue 'dispatch;
            }
            0x825BB32C => {
    //   block [0x825BB32C..0x825BB348)
	// 825BB32C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB330: 419A0018  beq cr6, 0x825bb348
	if ctx.cr[6].eq {
	pc = 0x825BB348; continue 'dispatch;
	}
	// 825BB334: D3EB0000  stfs f31, 0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BB338: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB33C: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825BB340: 930B000C  stw r24, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 825BB344: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	pc = 0x825BB348; continue 'dispatch;
            }
            0x825BB348 => {
    //   block [0x825BB348..0x825BB354)
	// 825BB348: 354AFFFF  addic. r10, r10, -1
	ctx.xer.ca = (ctx.r[10].u32 > (!(-1 as u32)));
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BB34C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BB350: 4082FFDC  bne 0x825bb32c
	if !ctx.cr[0].eq {
	pc = 0x825BB32C; continue 'dispatch;
	}
	pc = 0x825BB354; continue 'dispatch;
            }
            0x825BB354 => {
    //   block [0x825BB354..0x825BB370)
	// 825BB354: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB358: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BB35C: 394BFFEC  addi r10, r11, -0x14
	ctx.r[10].s64 = ctx.r[11].s64 + -20;
	// 825BB360: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BB364: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB368: 419A00C8  beq cr6, 0x825bb430
	if ctx.cr[6].eq {
	pc = 0x825BB430; continue 'dispatch;
	}
	// 825BB36C: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	pc = 0x825BB370; continue 'dispatch;
            }
            0x825BB370 => {
    //   block [0x825BB370..0x825BB3A0)
	// 825BB370: D3EBFFF8  stfs f31, -8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 825BB374: 934BFFFC  stw r26, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[26].u32 ) };
	// 825BB378: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825BB37C: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 825BB380: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 825BB384: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BB388: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825BB38C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB390: 409AFFE0  bne cr6, 0x825bb370
	if !ctx.cr[6].eq {
	pc = 0x825BB370; continue 'dispatch;
	}
	// 825BB394: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB398: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825BB39C: 486EE0A8  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB3A0 => {
    //   block [0x825BB3A0..0x825BB3C4)
	// 825BB3A0: 3BA5FFEC  addi r29, r5, -0x14
	ctx.r[29].s64 = ctx.r[5].s64 + -20;
	// 825BB3A4: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825BB3A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BB3AC: 48001185  bl 0x825bc530
	ctx.lr = 0x825BB3B0;
	sub_825BC530(ctx, base);
	// 825BB3B0: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BB3B4: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825BB3B8: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BB3BC: 419A0040  beq cr6, 0x825bb3fc
	if ctx.cr[6].eq {
	pc = 0x825BB3FC; continue 'dispatch;
	}
	// 825BB3C0: 396A001C  addi r11, r10, 0x1c
	ctx.r[11].s64 = ctx.r[10].s64 + 28;
	pc = 0x825BB3C4; continue 'dispatch;
            }
            0x825BB3C4 => {
    //   block [0x825BB3C4..0x825BB3FC)
	// 825BB3C4: 394AFFEC  addi r10, r10, -0x14
	ctx.r[10].s64 = ctx.r[10].s64 + -20;
	// 825BB3C8: 396BFFEC  addi r11, r11, -0x14
	ctx.r[11].s64 = ctx.r[11].s64 + -20;
	// 825BB3CC: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB3D0: C00A0000  lfs f0, 0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB3D4: D00BFFF8  stfs f0, -8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 825BB3D8: 812BFFE8  lwz r9, -0x18(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825BB3DC: 912BFFFC  stw r9, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[9].u32 ) };
	// 825BB3E0: 810BFFEC  lwz r8, -0x14(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825BB3E4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BB3E8: 80EBFFF0  lwz r7, -0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BB3EC: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BB3F0: 80CBFFF4  lwz r6, -0xc(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BB3F4: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825BB3F8: 409AFFCC  bne cr6, 0x825bb3c4
	if !ctx.cr[6].eq {
	pc = 0x825BB3C4; continue 'dispatch;
	}
	pc = 0x825BB3FC; continue 'dispatch;
            }
            0x825BB3FC => {
    //   block [0x825BB3FC..0x825BB40C)
	// 825BB3FC: 395E0014  addi r10, r30, 0x14
	ctx.r[10].s64 = ctx.r[30].s64 + 20;
	// 825BB400: 7F1E5040  cmplw cr6, r30, r10
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB404: 419A002C  beq cr6, 0x825bb430
	if ctx.cr[6].eq {
	pc = 0x825BB430; continue 'dispatch;
	}
	// 825BB408: 397E0008  addi r11, r30, 8
	ctx.r[11].s64 = ctx.r[30].s64 + 8;
	pc = 0x825BB40C; continue 'dispatch;
            }
            0x825BB40C => {
    //   block [0x825BB40C..0x825BB430)
	// 825BB40C: D3EBFFF8  stfs f31, -8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 825BB410: 934BFFFC  stw r26, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[26].u32 ) };
	// 825BB414: 932B0000  stw r25, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825BB418: 930B0004  stw r24, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[24].u32 ) };
	// 825BB41C: 92EB0008  stw r23, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[23].u32 ) };
	// 825BB420: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BB424: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825BB428: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB42C: 409AFFE0  bne cr6, 0x825bb40c
	if !ctx.cr[6].eq {
	pc = 0x825BB40C; continue 'dispatch;
	}
	pc = 0x825BB430; continue 'dispatch;
            }
            0x825BB430 => {
    //   block [0x825BB430..0x825BB43C)
	// 825BB430: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB434: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 825BB438: 486EE00C  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BB440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BB440 size=628
    let mut pc: u32 = 0x825BB440;
    'dispatch: loop {
        match pc {
            0x825BB440 => {
    //   block [0x825BB440..0x825BB478)
	// 825BB440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BB444: 486EDFC1  bl 0x82ca9404
	ctx.lr = 0x825BB448;
	sub_82CA93D0(ctx, base);
	// 825BB448: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BB44C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BB450: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 825BB454: 7CC43378  mr r4, r6
	ctx.r[4].u64 = ctx.r[6].u64;
	// 825BB458: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BB45C: 48000895  bl 0x825bbcf0
	ctx.lr = 0x825BB460;
	sub_825BBCF0(ctx, base);
	// 825BB460: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB464: 3B600028  li r27, 0x28
	ctx.r[27].s64 = 40;
	// 825BB468: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB46C: 409A000C  bne cr6, 0x825bb478
	if !ctx.cr[6].eq {
	pc = 0x825BB478; continue 'dispatch;
	}
	// 825BB470: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BB474: 48000010  b 0x825bb484
	pc = 0x825BB484; continue 'dispatch;
            }
            0x825BB478 => {
    //   block [0x825BB478..0x825BB484)
	// 825BB478: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB47C: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB480: 7D29DBD6  divw r9, r9, r27
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[27].s32;
	pc = 0x825BB484; continue 'dispatch;
            }
            0x825BB484 => {
    //   block [0x825BB484..0x825BB4B0)
	// 825BB484: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB488: 3D400666  lis r10, 0x666
	ctx.r[10].s64 = 107347968;
	// 825BB48C: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825BB490: 614A6666  ori r10, r10, 0x6666
	ctx.r[10].u64 = ctx.r[10].u64 | 26214;
	// 825BB494: 7D68DBD6  divw r11, r8, r27
	ctx.r[11].s32 = ctx.r[8].s32 / ctx.r[27].s32;
	// 825BB498: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB49C: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825BB4A0: 40980010  bge cr6, 0x825bb4b0
	if !ctx.cr[6].lt {
	pc = 0x825BB4B0; continue 'dispatch;
	}
	// 825BB4A4: 4848C025  bl 0x82a474c8
	ctx.lr = 0x825BB4A8;
	sub_82A474C8(ctx, base);
	// 825BB4A8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB4AC: 486EDFA8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB4B0 => {
    //   block [0x825BB4B0..0x825BB4D4)
	// 825BB4B0: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 825BB4B4: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB4B8: 409800CC  bge cr6, 0x825bb584
	if !ctx.cr[6].lt {
	pc = 0x825BB584; continue 'dispatch;
	}
	// 825BB4BC: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB4C0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825BB4C4: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB4C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB4CC: 41980008  blt cr6, 0x825bb4d4
	if ctx.cr[6].lt {
	pc = 0x825BB4D4; continue 'dispatch;
	}
	// 825BB4D0: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BB4D4; continue 'dispatch;
            }
            0x825BB4D4 => {
    //   block [0x825BB4D4..0x825BB4E0)
	// 825BB4D4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB4D8: 40980008  bge cr6, 0x825bb4e0
	if !ctx.cr[6].lt {
	pc = 0x825BB4E0; continue 'dispatch;
	}
	// 825BB4DC: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x825BB4E0; continue 'dispatch;
            }
            0x825BB4E0 => {
    //   block [0x825BB4E0..0x825BB550)
	// 825BB4E0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BB4E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB4E8: 4BE81A49  bl 0x8243cf30
	ctx.lr = 0x825BB4EC;
	sub_8243CF30(ctx, base);
	// 825BB4EC: 838100CC  lwz r28, 0xcc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BB4F0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BB4F4: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB4F8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BB4FC: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BB500: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB504: 4800108D  bl 0x825bc590
	ctx.lr = 0x825BB508;
	sub_825BC590(ctx, base);
	// 825BB508: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BB50C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BB510: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BB514: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB518: 4BFFF129  bl 0x825ba640
	ctx.lr = 0x825BB51C;
	sub_825BA640(ctx, base);
	// 825BB51C: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825BB520: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BB524: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB528: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB52C: 48001065  bl 0x825bc590
	ctx.lr = 0x825BB530;
	sub_825BC590(ctx, base);
	// 825BB530: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB534: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB538: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BB53C: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BB540: 7D6ADBD6  divw r11, r10, r27
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[27].s32;
	// 825BB544: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 825BB548: 419A0008  beq cr6, 0x825bb550
	if ctx.cr[6].eq {
	pc = 0x825BB550; continue 'dispatch;
	}
	// 825BB54C: 4BC607ED  bl 0x8221bd38
	ctx.lr = 0x825BB550;
	sub_8221BD38(ctx, base);
	pc = 0x825BB550; continue 'dispatch;
            }
            0x825BB550 => {
    //   block [0x825BB550..0x825BB584)
	// 825BB550: 57AB103A  slwi r11, r29, 2
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB554: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BB558: 578A103A  slwi r10, r28, 2
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB55C: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825BB560: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 825BB564: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB568: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB56C: 7D2BF214  add r9, r11, r30
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BB570: 7D0AF214  add r8, r10, r30
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825BB574: 913F000C  stw r9, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825BB578: 911F0008  stw r8, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BB57C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB580: 486EDED4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB584 => {
    //   block [0x825BB584..0x825BB5E8)
	// 825BB584: 83C100CC  lwz r30, 0xcc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BB588: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB58C: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 825BB590: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BB594: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825BB598: 40980050  bge cr6, 0x825bb5e8
	if !ctx.cr[6].lt {
	pc = 0x825BB5E8; continue 'dispatch;
	}
	// 825BB59C: 38DE0028  addi r6, r30, 0x28
	ctx.r[6].s64 = ctx.r[30].s64 + 40;
	// 825BB5A0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BB5A4: 48000FED  bl 0x825bc590
	ctx.lr = 0x825BB5A8;
	sub_825BC590(ctx, base);
	// 825BB5A8: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB5AC: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BB5B0: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 825BB5B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BB5B8: 7D4BDBD6  divw r10, r11, r27
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BB5BC: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 825BB5C0: 4BFFF081  bl 0x825ba640
	ctx.lr = 0x825BB5C4;
	sub_825BA640(ctx, base);
	// 825BB5C4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB5C8: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BB5CC: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 825BB5D0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BB5D4: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BB5D8: 388BFFD8  addi r4, r11, -0x28
	ctx.r[4].s64 = ctx.r[11].s64 + -40;
	// 825BB5DC: 48001075  bl 0x825bc650
	ctx.lr = 0x825BB5E0;
	sub_825BC650(ctx, base);
	// 825BB5E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB5E4: 486EDE70  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB5E8 => {
    //   block [0x825BB5E8..0x825BB60C)
	// 825BB5E8: 3BA5FFD8  addi r29, r5, -0x28
	ctx.r[29].s64 = ctx.r[5].s64 + -40;
	// 825BB5EC: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825BB5F0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BB5F4: 48000F9D  bl 0x825bc590
	ctx.lr = 0x825BB5F8;
	sub_825BC590(ctx, base);
	// 825BB5F8: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BB5FC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825BB600: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BB604: 419A0098  beq cr6, 0x825bb69c
	if ctx.cr[6].eq {
	pc = 0x825BB69C; continue 'dispatch;
	}
	// 825BB608: 396A0034  addi r11, r10, 0x34
	ctx.r[11].s64 = ctx.r[10].s64 + 52;
	pc = 0x825BB60C; continue 'dispatch;
            }
            0x825BB60C => {
    //   block [0x825BB60C..0x825BB69C)
	// 825BB60C: 394AFFD8  addi r10, r10, -0x28
	ctx.r[10].s64 = ctx.r[10].s64 + -40;
	// 825BB610: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 825BB614: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BB618: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB61C: 912BFFF4  stw r9, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 825BB620: 810BFFD0  lwz r8, -0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) } as u64;
	// 825BB624: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 825BB628: 80EBFFD4  lwz r7, -0x2c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) } as u64;
	// 825BB62C: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 825BB630: C00BFFD8  lfs f0, -0x28(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB634: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BB638: 80CBFFDC  lwz r6, -0x24(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BB63C: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BB640: 88ABFFE0  lbz r5, -0x20(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BB644: 98AB0008  stb r5, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[5].u8 ) };
	// 825BB648: 888BFFE1  lbz r4, -0x1f(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-31 as u32) ) } as u64;
	// 825BB64C: 988B0009  stb r4, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[4].u8 ) };
	// 825BB650: 886BFFE2  lbz r3, -0x1e(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-30 as u32) ) } as u64;
	// 825BB654: 986B000A  stb r3, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[3].u8 ) };
	// 825BB658: 892BFFE3  lbz r9, -0x1d(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-29 as u32) ) } as u64;
	// 825BB65C: 992B000B  stb r9, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[9].u8 ) };
	// 825BB660: 890BFFE4  lbz r8, -0x1c(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825BB664: 990B000C  stb r8, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 825BB668: 88EBFFE5  lbz r7, -0x1b(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27 as u32) ) } as u64;
	// 825BB66C: 98EB000D  stb r7, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[7].u8 ) };
	// 825BB670: 88CBFFE6  lbz r6, -0x1a(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-26 as u32) ) } as u64;
	// 825BB674: 98CB000E  stb r6, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[6].u8 ) };
	// 825BB678: 88ABFFE7  lbz r5, -0x19(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-25 as u32) ) } as u64;
	// 825BB67C: 98AB000F  stb r5, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[5].u8 ) };
	// 825BB680: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BB684: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825BB688: 808BFFEC  lwz r4, -0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825BB68C: 908B0014  stw r4, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[4].u32 ) };
	// 825BB690: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BB694: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825BB698: 409AFF74  bne cr6, 0x825bb60c
	if !ctx.cr[6].eq {
	pc = 0x825BB60C; continue 'dispatch;
	}
	pc = 0x825BB69C; continue 'dispatch;
            }
            0x825BB69C => {
    //   block [0x825BB69C..0x825BB6B4)
	// 825BB69C: 389E0028  addi r4, r30, 0x28
	ctx.r[4].s64 = ctx.r[30].s64 + 40;
	// 825BB6A0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BB6A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BB6A8: 48000FA9  bl 0x825bc650
	ctx.lr = 0x825BB6AC;
	sub_825BC650(ctx, base);
	// 825BB6AC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BB6B0: 486EDDA4  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BB6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BB6B8 size=796
    let mut pc: u32 = 0x825BB6B8;
    'dispatch: loop {
        match pc {
            0x825BB6B8 => {
    //   block [0x825BB6B8..0x825BB6F0)
	// 825BB6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BB6BC: 486EDD41  bl 0x82ca93fc
	ctx.lr = 0x825BB6C0;
	sub_82CA93D0(ctx, base);
	// 825BB6C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BB6C4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BB6C8: 83660000  lwz r27, 0(r6)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB6CC: 83460004  lwz r26, 4(r6)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB6D0: 3BE0000C  li r31, 0xc
	ctx.r[31].s64 = 12;
	// 825BB6D4: 83260008  lwz r25, 8(r6)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB6D8: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 825BB6DC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB6E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB6E4: 409A000C  bne cr6, 0x825bb6f0
	if !ctx.cr[6].eq {
	pc = 0x825BB6F0; continue 'dispatch;
	}
	// 825BB6E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BB6EC: 48000010  b 0x825bb6fc
	pc = 0x825BB6FC; continue 'dispatch;
            }
            0x825BB6F0 => {
    //   block [0x825BB6F0..0x825BB6FC)
	// 825BB6F0: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BB6F4: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB6F8: 7D29FBD6  divw r9, r9, r31
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	pc = 0x825BB6FC; continue 'dispatch;
            }
            0x825BB6FC => {
    //   block [0x825BB6FC..0x825BB728)
	// 825BB6FC: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB700: 3D401555  lis r10, 0x1555
	ctx.r[10].s64 = 357892096;
	// 825BB704: 7CEB4050  subf r7, r11, r8
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BB708: 614A5555  ori r10, r10, 0x5555
	ctx.r[10].u64 = ctx.r[10].u64 | 21845;
	// 825BB70C: 7D67FBD6  divw r11, r7, r31
	ctx.r[11].s32 = ctx.r[7].s32 / ctx.r[31].s32;
	// 825BB710: 7CCB5050  subf r6, r11, r10
	ctx.r[6].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB714: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 825BB718: 40980010  bge cr6, 0x825bb728
	if !ctx.cr[6].lt {
	pc = 0x825BB728; continue 'dispatch;
	}
	// 825BB71C: 4848BDAD  bl 0x82a474c8
	ctx.lr = 0x825BB720;
	sub_82A474C8(ctx, base);
	// 825BB720: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BB724: 486EDD28  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB728 => {
    //   block [0x825BB728..0x825BB74C)
	// 825BB728: 38EB0001  addi r7, r11, 1
	ctx.r[7].s64 = ctx.r[11].s64 + 1;
	// 825BB72C: 7F093840  cmplw cr6, r9, r7
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BB730: 40980130  bge cr6, 0x825bb860
	if !ctx.cr[6].lt {
	pc = 0x825BB860; continue 'dispatch;
	}
	// 825BB734: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB738: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825BB73C: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB740: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB744: 41980008  blt cr6, 0x825bb74c
	if ctx.cr[6].lt {
	pc = 0x825BB74C; continue 'dispatch;
	}
	// 825BB748: 7F8B4A14  add r28, r11, r9
	ctx.r[28].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BB74C; continue 'dispatch;
            }
            0x825BB74C => {
    //   block [0x825BB74C..0x825BB758)
	// 825BB74C: 7F1C3840  cmplw cr6, r28, r7
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BB750: 40980008  bge cr6, 0x825bb758
	if !ctx.cr[6].lt {
	pc = 0x825BB758; continue 'dispatch;
	}
	// 825BB754: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	pc = 0x825BB758; continue 'dispatch;
            }
            0x825BB758 => {
    //   block [0x825BB758..0x825BB77C)
	// 825BB758: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BB75C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BB760: 4BD67C51  bl 0x823233b0
	ctx.lr = 0x825BB764;
	sub_823233B0(ctx, base);
	// 825BB764: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB768: 812100AC  lwz r9, 0xac(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BB76C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BB770: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB774: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 825BB778: 419A0034  beq cr6, 0x825bb7ac
	if ctx.cr[6].eq {
	pc = 0x825BB7AC; continue 'dispatch;
	}
	pc = 0x825BB77C; continue 'dispatch;
            }
            0x825BB77C => {
    //   block [0x825BB77C..0x825BB79C)
	// 825BB77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB780: 419A001C  beq cr6, 0x825bb79c
	if ctx.cr[6].eq {
	pc = 0x825BB79C; continue 'dispatch;
	}
	// 825BB784: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB788: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BB78C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB790: 90EB0004  stw r7, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BB794: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB798: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x825BB79C; continue 'dispatch;
            }
            0x825BB79C => {
    //   block [0x825BB79C..0x825BB7AC)
	// 825BB79C: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825BB7A0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BB7A4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BB7A8: 409AFFD4  bne cr6, 0x825bb77c
	if !ctx.cr[6].eq {
	pc = 0x825BB77C; continue 'dispatch;
	}
	pc = 0x825BB7AC; continue 'dispatch;
            }
            0x825BB7AC => {
    //   block [0x825BB7AC..0x825BB7C0)
	// 825BB7AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BB7B0: 419A0010  beq cr6, 0x825bb7c0
	if ctx.cr[6].eq {
	pc = 0x825BB7C0; continue 'dispatch;
	}
	// 825BB7B4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BB7B8: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB7BC: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	pc = 0x825BB7C0; continue 'dispatch;
            }
            0x825BB7C0 => {
    //   block [0x825BB7C0..0x825BB7DC)
	// 825BB7C0: 811E0008  lwz r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB7C4: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 825BB7C8: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB7CC: 419A0040  beq cr6, 0x825bb80c
	if ctx.cr[6].eq {
	pc = 0x825BB80C; continue 'dispatch;
	}
	// 825BB7D0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB7D4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BB7D8: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	pc = 0x825BB7DC; continue 'dispatch;
            }
            0x825BB7DC => {
    //   block [0x825BB7DC..0x825BB7FC)
	// 825BB7DC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BB7E0: 419A001C  beq cr6, 0x825bb7fc
	if ctx.cr[6].eq {
	pc = 0x825BB7FC; continue 'dispatch;
	}
	// 825BB7E4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB7E8: 912A0000  stw r9, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BB7EC: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB7F0: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BB7F4: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB7F8: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x825BB7FC; continue 'dispatch;
            }
            0x825BB7FC => {
    //   block [0x825BB7FC..0x825BB80C)
	// 825BB7FC: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BB800: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825BB804: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB808: 409AFFD4  bne cr6, 0x825bb7dc
	if !ctx.cr[6].eq {
	pc = 0x825BB7DC; continue 'dispatch;
	}
	pc = 0x825BB80C; continue 'dispatch;
            }
            0x825BB80C => {
    //   block [0x825BB80C..0x825BB82C)
	// 825BB80C: 807E0004  lwz r3, 4(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB810: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB814: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BB818: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BB81C: 7D6AFBD6  divw r11, r10, r31
	ctx.r[11].s32 = ctx.r[10].s32 / ctx.r[31].s32;
	// 825BB820: 3BEB0001  addi r31, r11, 1
	ctx.r[31].s64 = ctx.r[11].s64 + 1;
	// 825BB824: 419A0008  beq cr6, 0x825bb82c
	if ctx.cr[6].eq {
	pc = 0x825BB82C; continue 'dispatch;
	}
	// 825BB828: 4BC60511  bl 0x8221bd38
	ctx.lr = 0x825BB82C;
	sub_8221BD38(ctx, base);
	pc = 0x825BB82C; continue 'dispatch;
            }
            0x825BB82C => {
    //   block [0x825BB82C..0x825BB860)
	// 825BB82C: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB830: 93BE0004  stw r29, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 825BB834: 578A083C  slwi r10, r28, 1
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB838: 7D3F5A14  add r9, r31, r11
	ctx.r[9].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BB83C: 7D5C5214  add r10, r28, r10
	ctx.r[10].u64 = ctx.r[28].u64 + ctx.r[10].u64;
	// 825BB840: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BB844: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BB848: 7CEBEA14  add r7, r11, r29
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BB84C: 7D0AEA14  add r8, r10, r29
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 825BB850: 90FE0008  stw r7, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 825BB854: 911E000C  stw r8, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825BB858: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BB85C: 486EDBF0  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB860 => {
    //   block [0x825BB860..0x825BB884)
	// 825BB860: 816100AC  lwz r11, 0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BB864: 7D4B4050  subf r10, r11, r8
	ctx.r[10].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BB868: 7D2AFBD6  divw r9, r10, r31
	ctx.r[9].s32 = ctx.r[10].s32 / ctx.r[31].s32;
	// 825BB86C: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 825BB870: 409800B8  bge cr6, 0x825bb928
	if !ctx.cr[6].lt {
	pc = 0x825BB928; continue 'dispatch;
	}
	// 825BB874: 392B000C  addi r9, r11, 0xc
	ctx.r[9].s64 = ctx.r[11].s64 + 12;
	// 825BB878: 7F0B4040  cmplw cr6, r11, r8
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB87C: 419A003C  beq cr6, 0x825bb8b8
	if ctx.cr[6].eq {
	pc = 0x825BB8B8; continue 'dispatch;
	}
	// 825BB880: 3949FFF8  addi r10, r9, -8
	ctx.r[10].s64 = ctx.r[9].s64 + -8;
	pc = 0x825BB884; continue 'dispatch;
            }
            0x825BB884 => {
    //   block [0x825BB884..0x825BB8A4)
	// 825BB884: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BB888: 419A001C  beq cr6, 0x825bb8a4
	if ctx.cr[6].eq {
	pc = 0x825BB8A4; continue 'dispatch;
	}
	// 825BB88C: 80EAFFFC  lwz r7, -4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BB890: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BB894: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB898: 90CA000C  stw r6, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[6].u32 ) };
	// 825BB89C: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB8A0: 90AA0010  stw r5, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	pc = 0x825BB8A4; continue 'dispatch;
            }
            0x825BB8A4 => {
    //   block [0x825BB8A4..0x825BB8B8)
	// 825BB8A4: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825BB8A8: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BB8AC: 38EAFFFC  addi r7, r10, -4
	ctx.r[7].s64 = ctx.r[10].s64 + -4;
	// 825BB8B0: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB8B4: 409AFFD0  bne cr6, 0x825bb884
	if !ctx.cr[6].eq {
	pc = 0x825BB884; continue 'dispatch;
	}
	pc = 0x825BB8B8; continue 'dispatch;
            }
            0x825BB8B8 => {
    //   block [0x825BB8B8..0x825BB8D0)
	// 825BB8B8: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB8BC: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BB8C0: 7D09FBD6  divw r8, r9, r31
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[31].s32;
	// 825BB8C4: 21280001  subfic r9, r8, 1
	ctx.xer.ca = ctx.r[8].u32 <= 1 as u32;
	ctx.r[9].s64 = (1 as i64) - ctx.r[8].s64;
	// 825BB8C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BB8CC: 419A0024  beq cr6, 0x825bb8f0
	if ctx.cr[6].eq {
	pc = 0x825BB8F0; continue 'dispatch;
	}
	pc = 0x825BB8D0; continue 'dispatch;
            }
            0x825BB8D0 => {
    //   block [0x825BB8D0..0x825BB8E4)
	// 825BB8D0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BB8D4: 419A0010  beq cr6, 0x825bb8e4
	if ctx.cr[6].eq {
	pc = 0x825BB8E4; continue 'dispatch;
	}
	// 825BB8D8: 936A0000  stw r27, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BB8DC: 934A0004  stw r26, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB8E0: 932A0008  stw r25, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	pc = 0x825BB8E4; continue 'dispatch;
            }
            0x825BB8E4 => {
    //   block [0x825BB8E4..0x825BB8F0)
	// 825BB8E4: 3529FFFF  addic. r9, r9, -1
	ctx.xer.ca = (ctx.r[9].u32 > (!(-1 as u32)));
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 825BB8E8: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825BB8EC: 4082FFE4  bne 0x825bb8d0
	if !ctx.cr[0].eq {
	pc = 0x825BB8D0; continue 'dispatch;
	}
	pc = 0x825BB8F0; continue 'dispatch;
            }
            0x825BB8F0 => {
    //   block [0x825BB8F0..0x825BB908)
	// 825BB8F0: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB8F4: 392A000C  addi r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 + 12;
	// 825BB8F8: 3949FFF4  addi r10, r9, -0xc
	ctx.r[10].s64 = ctx.r[9].s64 + -12;
	// 825BB8FC: 913E0008  stw r9, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	// 825BB900: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB904: 419A00C8  beq cr6, 0x825bb9cc
	if ctx.cr[6].eq {
	pc = 0x825BB9CC; continue 'dispatch;
	}
	pc = 0x825BB908; continue 'dispatch;
            }
            0x825BB908 => {
    //   block [0x825BB908..0x825BB928)
	// 825BB908: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BB90C: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB910: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825BB914: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BB918: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB91C: 409AFFEC  bne cr6, 0x825bb908
	if !ctx.cr[6].eq {
	pc = 0x825BB908; continue 'dispatch;
	}
	// 825BB920: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BB924: 486EDB28  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BB928 => {
    //   block [0x825BB928..0x825BB93C)
	// 825BB928: 38E8FFF4  addi r7, r8, -0xc
	ctx.r[7].s64 = ctx.r[8].s64 + -12;
	// 825BB92C: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 825BB930: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 825BB934: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB938: 419A0034  beq cr6, 0x825bb96c
	if ctx.cr[6].eq {
	pc = 0x825BB96C; continue 'dispatch;
	}
	pc = 0x825BB93C; continue 'dispatch;
            }
            0x825BB93C => {
    //   block [0x825BB93C..0x825BB95C)
	// 825BB93C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BB940: 419A001C  beq cr6, 0x825bb95c
	if ctx.cr[6].eq {
	pc = 0x825BB95C; continue 'dispatch;
	}
	// 825BB944: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB948: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BB94C: 80A90004  lwz r5, 4(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB950: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BB954: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BB958: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x825BB95C; continue 'dispatch;
            }
            0x825BB95C => {
    //   block [0x825BB95C..0x825BB96C)
	// 825BB95C: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BB960: 394A000C  addi r10, r10, 0xc
	ctx.r[10].s64 = ctx.r[10].s64 + 12;
	// 825BB964: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BB968: 409AFFD4  bne cr6, 0x825bb93c
	if !ctx.cr[6].eq {
	pc = 0x825BB93C; continue 'dispatch;
	}
	pc = 0x825BB96C; continue 'dispatch;
            }
            0x825BB96C => {
    //   block [0x825BB96C..0x825BB980)
	// 825BB96C: 915E0008  stw r10, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BB970: 7CE93B78  mr r9, r7
	ctx.r[9].u64 = ctx.r[7].u64;
	// 825BB974: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BB978: 419A0030  beq cr6, 0x825bb9a8
	if ctx.cr[6].eq {
	pc = 0x825BB9A8; continue 'dispatch;
	}
	// 825BB97C: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	pc = 0x825BB980; continue 'dispatch;
            }
            0x825BB980 => {
    //   block [0x825BB980..0x825BB9A8)
	// 825BB980: 3929FFF4  addi r9, r9, -0xc
	ctx.r[9].s64 = ctx.r[9].s64 + -12;
	// 825BB984: 394AFFF4  addi r10, r10, -0xc
	ctx.r[10].s64 = ctx.r[10].s64 + -12;
	// 825BB988: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BB98C: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB990: 910AFFFC  stw r8, -4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-4 as u32), ctx.r[8].u32 ) };
	// 825BB994: 80EAFFF4  lwz r7, -0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BB998: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BB99C: 80CAFFF8  lwz r6, -8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BB9A0: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BB9A4: 409AFFDC  bne cr6, 0x825bb980
	if !ctx.cr[6].eq {
	pc = 0x825BB980; continue 'dispatch;
	}
	pc = 0x825BB9A8; continue 'dispatch;
            }
            0x825BB9A8 => {
    //   block [0x825BB9A8..0x825BB9B4)
	// 825BB9A8: 394B000C  addi r10, r11, 0xc
	ctx.r[10].s64 = ctx.r[11].s64 + 12;
	// 825BB9AC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB9B0: 419A001C  beq cr6, 0x825bb9cc
	if ctx.cr[6].eq {
	pc = 0x825BB9CC; continue 'dispatch;
	}
	pc = 0x825BB9B4; continue 'dispatch;
            }
            0x825BB9B4 => {
    //   block [0x825BB9B4..0x825BB9CC)
	// 825BB9B4: 936B0000  stw r27, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BB9B8: 934B0004  stw r26, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[26].u32 ) };
	// 825BB9BC: 932B0008  stw r25, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825BB9C0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BB9C4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BB9C8: 409AFFEC  bne cr6, 0x825bb9b4
	if !ctx.cr[6].eq {
	pc = 0x825BB9B4; continue 'dispatch;
	}
	pc = 0x825BB9CC; continue 'dispatch;
            }
            0x825BB9CC => {
    //   block [0x825BB9CC..0x825BB9D4)
	// 825BB9CC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BB9D0: 486EDA7C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BB9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BB9D8 size=648
    let mut pc: u32 = 0x825BB9D8;
    'dispatch: loop {
        match pc {
            0x825BB9D8 => {
    //   block [0x825BB9D8..0x825BBA5C)
	// 825BB9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BB9DC: 486EDA2D  bl 0x82ca9408
	ctx.lr = 0x825BB9E0;
	sub_82CA93D0(ctx, base);
	// 825BB9E0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BB9E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BB9E8: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 825BB9EC: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BB9F0: C006000C  lfs f0, 0xc(r6)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BB9F4: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BB9F8: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BB9FC: 81060008  lwz r8, 8(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBA00: 39660004  addi r11, r6, 4
	ctx.r[11].s64 = ctx.r[6].s64 + 4;
	// 825BBA04: 88E60012  lbz r7, 0x12(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BBA08: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825BBA0C: 88A60011  lbz r5, 0x11(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BBA10: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825BBA14: 88860010  lbz r4, 0x10(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BBA18: 88660013  lbz r3, 0x13(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BBA1C: 83C60018  lwz r30, 0x18(r6)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BBA20: 88C6001C  lbz r6, 0x1c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BBA24: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBA28: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BBA2C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BBA30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BBA34: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825BBA38: 98E10062  stb r7, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[7].u8 ) };
	// 825BBA3C: 98A10061  stb r5, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[5].u8 ) };
	// 825BBA40: 98810060  stb r4, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u8 ) };
	// 825BBA44: 98610063  stb r3, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[3].u8 ) };
	// 825BBA48: 93C10068  stw r30, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u32 ) };
	// 825BBA4C: 98C1006C  stb r6, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[6].u8 ) };
	// 825BBA50: 409A000C  bne cr6, 0x825bba5c
	if !ctx.cr[6].eq {
	pc = 0x825BBA5C; continue 'dispatch;
	}
	// 825BBA54: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BBA58: 48000010  b 0x825bba68
	pc = 0x825BBA68; continue 'dispatch;
            }
            0x825BBA5C => {
    //   block [0x825BBA5C..0x825BBA68)
	// 825BBA5C: 815F000C  lwz r10, 0xc(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BBA60: 7D2B5050  subf r9, r11, r10
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BBA64: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	pc = 0x825BBA68; continue 'dispatch;
            }
            0x825BBA68 => {
    //   block [0x825BBA68..0x825BBA94)
	// 825BBA68: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBA6C: 3D4007FF  lis r10, 0x7ff
	ctx.r[10].s64 = 134152192;
	// 825BBA70: 7D0B2850  subf r8, r11, r5
	ctx.r[8].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825BBA74: 614AFFFF  ori r10, r10, 0xffff
	ctx.r[10].u64 = ctx.r[10].u64 | 65535;
	// 825BBA78: 7D0B2E70  srawi r11, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 825BBA7C: 7CEB5050  subf r7, r11, r10
	ctx.r[7].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BBA80: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 825BBA84: 40980010  bge cr6, 0x825bba94
	if !ctx.cr[6].lt {
	pc = 0x825BBA94; continue 'dispatch;
	}
	// 825BBA88: 4848BA41  bl 0x82a474c8
	ctx.lr = 0x825BBA8C;
	sub_82A474C8(ctx, base);
	// 825BBA8C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BBA90: 486ED9C8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BBA94 => {
    //   block [0x825BBA94..0x825BBAB8)
	// 825BBA94: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 825BBA98: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BBA9C: 409800BC  bge cr6, 0x825bbb58
	if !ctx.cr[6].lt {
	pc = 0x825BBB58; continue 'dispatch;
	}
	// 825BBAA0: 552BF87E  srwi r11, r9, 1
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shr(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBAA4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825BBAA8: 7D4B5050  subf r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BBAAC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BBAB0: 41980008  blt cr6, 0x825bbab8
	if ctx.cr[6].lt {
	pc = 0x825BBAB8; continue 'dispatch;
	}
	// 825BBAB4: 7FAB4A14  add r29, r11, r9
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	pc = 0x825BBAB8; continue 'dispatch;
            }
            0x825BBAB8 => {
    //   block [0x825BBAB8..0x825BBAC4)
	// 825BBAB8: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BBABC: 40980008  bge cr6, 0x825bbac4
	if !ctx.cr[6].lt {
	pc = 0x825BBAC4; continue 'dispatch;
	}
	// 825BBAC0: 7D1D4378  mr r29, r8
	ctx.r[29].u64 = ctx.r[8].u64;
	pc = 0x825BBAC4; continue 'dispatch;
            }
            0x825BBAC4 => {
    //   block [0x825BBAC4..0x825BBB34)
	// 825BBAC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BBAC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBACC: 48455B05  bl 0x82a115d0
	ctx.lr = 0x825BBAD0;
	sub_82A115D0(ctx, base);
	// 825BBAD0: 838100BC  lwz r28, 0xbc(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BBAD4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BBAD8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBADC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BBAE0: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BBAE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBAE8: 48000C19  bl 0x825bc700
	ctx.lr = 0x825BBAEC;
	sub_825BC700(ctx, base);
	// 825BBAEC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BBAF0: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BBAF4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BBAF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBAFC: 4BFFF21D  bl 0x825bad18
	ctx.lr = 0x825BBB00;
	sub_825BAD18(ctx, base);
	// 825BBB00: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825BBB04: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BBB08: 80BF0008  lwz r5, 8(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBB0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBB10: 48000BF1  bl 0x825bc700
	ctx.lr = 0x825BBB14;
	sub_825BC700(ctx, base);
	// 825BBB14: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBB18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBB1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BBB20: 7D435850  subf r10, r3, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[3].s64;
	// 825BBB24: 7D4B2E70  srawi r11, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 825BBB28: 3B8B0001  addi r28, r11, 1
	ctx.r[28].s64 = ctx.r[11].s64 + 1;
	// 825BBB2C: 419A0008  beq cr6, 0x825bbb34
	if ctx.cr[6].eq {
	pc = 0x825BBB34; continue 'dispatch;
	}
	// 825BBB30: 4BC60209  bl 0x8221bd38
	ctx.lr = 0x825BBB34;
	sub_8221BD38(ctx, base);
	pc = 0x825BBB34; continue 'dispatch;
            }
            0x825BBB34 => {
    //   block [0x825BBB34..0x825BBB58)
	// 825BBB34: 57AB2834  slwi r11, r29, 5
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BBB38: 93DF0004  stw r30, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BBB3C: 578A2834  slwi r10, r28, 5
	ctx.r[10].u32 = ctx.r[28].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BBB40: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 825BBB44: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	// 825BBB48: 917F000C  stw r11, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825BBB4C: 915F0008  stw r10, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BBB50: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BBB54: 486ED904  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BBB58 => {
    //   block [0x825BBB58..0x825BBBBC)
	// 825BBB58: 83C100BC  lwz r30, 0xbc(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BBB5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBB60: 7D7E2850  subf r11, r30, r5
	ctx.r[11].s64 = ctx.r[5].s64 - ctx.r[30].s64;
	// 825BBB64: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BBB68: 2B0A0001  cmplwi cr6, r10, 1
	ctx.cr[6].compare_u32(ctx.r[10].u32, 1 as u32, &mut ctx.xer);
	// 825BBB6C: 40980050  bge cr6, 0x825bbbbc
	if !ctx.cr[6].lt {
	pc = 0x825BBBBC; continue 'dispatch;
	}
	// 825BBB70: 38DE0020  addi r6, r30, 0x20
	ctx.r[6].s64 = ctx.r[30].s64 + 32;
	// 825BBB74: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BBB78: 48000B89  bl 0x825bc700
	ctx.lr = 0x825BBB7C;
	sub_825BC700(ctx, base);
	// 825BBB7C: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBB80: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BBB84: 7D7E2050  subf r11, r30, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[30].s64;
	// 825BBB88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BBB8C: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BBB90: 20AA0001  subfic r5, r10, 1
	ctx.xer.ca = ctx.r[10].u32 <= 1 as u32;
	ctx.r[5].s64 = (1 as i64) - ctx.r[10].s64;
	// 825BBB94: 4BFFF185  bl 0x825bad18
	ctx.lr = 0x825BBB98;
	sub_825BAD18(ctx, base);
	// 825BBB98: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBB9C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BBBA0: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825BBBA4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBBA8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825BBBAC: 388BFFE0  addi r4, r11, -0x20
	ctx.r[4].s64 = ctx.r[11].s64 + -32;
	// 825BBBB0: 48000BE9  bl 0x825bc798
	ctx.lr = 0x825BBBB4;
	sub_825BC798(ctx, base);
	// 825BBBB4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BBBB8: 486ED8A0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BBBBC => {
    //   block [0x825BBBBC..0x825BBBE0)
	// 825BBBBC: 3BA5FFE0  addi r29, r5, -0x20
	ctx.r[29].s64 = ctx.r[5].s64 + -32;
	// 825BBBC0: 7CA62B78  mr r6, r5
	ctx.r[6].u64 = ctx.r[5].u64;
	// 825BBBC4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BBBC8: 48000B39  bl 0x825bc700
	ctx.lr = 0x825BBBCC;
	sub_825BC700(ctx, base);
	// 825BBBCC: 907F0008  stw r3, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BBBD0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 825BBBD4: 7F1EE840  cmplw cr6, r30, r29
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BBBD8: 419A0070  beq cr6, 0x825bbc48
	if ctx.cr[6].eq {
	pc = 0x825BBC48; continue 'dispatch;
	}
	// 825BBBDC: 396A002C  addi r11, r10, 0x2c
	ctx.r[11].s64 = ctx.r[10].s64 + 44;
	pc = 0x825BBBE0; continue 'dispatch;
            }
            0x825BBBE0 => {
    //   block [0x825BBBE0..0x825BBC48)
	// 825BBBE0: 394AFFE0  addi r10, r10, -0x20
	ctx.r[10].s64 = ctx.r[10].s64 + -32;
	// 825BBBE4: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825BBBE8: 7F0AF040  cmplw cr6, r10, r30
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BBBEC: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBBF0: 912BFFF4  stw r9, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[9].u32 ) };
	// 825BBBF4: 810BFFD8  lwz r8, -0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BBBF8: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 825BBBFC: 80EBFFDC  lwz r7, -0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BBC00: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 825BBC04: C00BFFE0  lfs f0, -0x20(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BBC08: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BBC0C: 88CBFFE4  lbz r6, -0x1c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825BBC10: 98CB0004  stb r6, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u8 ) };
	// 825BBC14: 88ABFFE5  lbz r5, -0x1b(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-27 as u32) ) } as u64;
	// 825BBC18: 98AB0005  stb r5, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[5].u8 ) };
	// 825BBC1C: 888BFFE6  lbz r4, -0x1a(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-26 as u32) ) } as u64;
	// 825BBC20: 988B0006  stb r4, 6(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[4].u8 ) };
	// 825BBC24: 886BFFE7  lbz r3, -0x19(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-25 as u32) ) } as u64;
	// 825BBC28: 986B0007  stb r3, 7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), ctx.r[3].u8 ) };
	// 825BBC2C: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BBC30: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825BBC34: 812BFFEC  lwz r9, -0x14(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825BBC38: 912B000C  stw r9, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825BBC3C: 890BFFF0  lbz r8, -0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BBC40: 990B0010  stb r8, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 825BBC44: 409AFF9C  bne cr6, 0x825bbbe0
	if !ctx.cr[6].eq {
	pc = 0x825BBBE0; continue 'dispatch;
	}
	pc = 0x825BBC48; continue 'dispatch;
            }
            0x825BBC48 => {
    //   block [0x825BBC48..0x825BBC60)
	// 825BBC48: 389E0020  addi r4, r30, 0x20
	ctx.r[4].s64 = ctx.r[30].s64 + 32;
	// 825BBC4C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825BBC50: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBC54: 48000B45  bl 0x825bc798
	ctx.lr = 0x825BBC58;
	sub_825BC798(ctx, base);
	// 825BBC58: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BBC5C: 486ED7FC  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BBC60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BBC60 size=144
    let mut pc: u32 = 0x825BBC60;
    'dispatch: loop {
        match pc {
            0x825BBC60 => {
    //   block [0x825BBC60..0x825BBCB4)
	// 825BBC60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BBC64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BBC68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BBC6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BBC70: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BBC74: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825BBC78: 3C80811C  lis r4, -0x7ee4
	ctx.r[4].s64 = -2128871424;
	// 825BBC7C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BBC80: 386B2304  addi r3, r11, 0x2304
	ctx.r[3].s64 = ctx.r[11].s64 + 8964;
	// 825BBC84: 60849DC5  ori r4, r4, 0x9dc5
	ctx.r[4].u64 = ctx.r[4].u64 | 40389;
	// 825BBC88: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BBC8C: 4BC380CD  bl 0x821f3d58
	ctx.lr = 0x825BBC90;
	sub_821F3D58(ctx, base);
	// 825BBC90: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BBC94: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBC98: 38A00002  li r5, 2
	ctx.r[5].s64 = 2;
	// 825BBC9C: 48444A2D  bl 0x82a006c8
	ctx.lr = 0x825BBCA0;
	sub_82A006C8(ctx, base);
	// 825BBCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BBCA4: 419A0010  beq cr6, 0x825bbcb4
	if ctx.cr[6].eq {
	pc = 0x825BBCB4; continue 'dispatch;
	}
	// 825BBCA8: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBCAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BBCB0: 4800000C  b 0x825bbcbc
	pc = 0x825BBCBC; continue 'dispatch;
            }
            0x825BBCB4 => {
    //   block [0x825BBCB4..0x825BBCBC)
	// 825BBCB4: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BBCB8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BBCBC; continue 'dispatch;
            }
            0x825BBCBC => {
    //   block [0x825BBCBC..0x825BBCD4)
	// 825BBCBC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BBCC0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BBCC4: 419A0010  beq cr6, 0x825bbcd4
	if ctx.cr[6].eq {
	pc = 0x825BBCD4; continue 'dispatch;
	}
	// 825BBCC8: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 825BBCCC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BBCD0: 48000008  b 0x825bbcd8
	pc = 0x825BBCD8; continue 'dispatch;
            }
            0x825BBCD4 => {
    //   block [0x825BBCD4..0x825BBCD8)
	// 825BBCD4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x825BBCD8; continue 'dispatch;
            }
            0x825BBCD8 => {
    //   block [0x825BBCD8..0x825BBCF0)
	// 825BBCD8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BBCDC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BBCE0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BBCE4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BBCE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BBCEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BBCF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BBCF0 size=140
    let mut pc: u32 = 0x825BBCF0;
    'dispatch: loop {
        match pc {
            0x825BBCF0 => {
    //   block [0x825BBCF0..0x825BBD7C)
	// 825BBCF0: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBCF4: 39630004  addi r11, r3, 4
	ctx.r[11].s64 = ctx.r[3].s64 + 4;
	// 825BBCF8: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 825BBCFC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BBD00: 81240004  lwz r9, 4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBD04: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BBD08: 81040008  lwz r8, 8(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBD0C: 91030008  stw r8, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BBD10: C004000C  lfs f0, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BBD14: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BBD18: 80E40010  lwz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BBD1C: 90E30010  stw r7, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825BBD20: 88C40017  lbz r6, 0x17(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BBD24: 88A40014  lbz r5, 0x14(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BBD28: 89640015  lbz r11, 0x15(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BBD2C: 89440016  lbz r10, 0x16(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BBD30: 99430016  stb r10, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[10].u8 ) };
	// 825BBD34: 99630015  stb r11, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[11].u8 ) };
	// 825BBD38: 98A30014  stb r5, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[5].u8 ) };
	// 825BBD3C: 98C30017  stb r6, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[6].u8 ) };
	// 825BBD40: 8924001B  lbz r9, 0x1b(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BBD44: 89040018  lbz r8, 0x18(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BBD48: 88E40019  lbz r7, 0x19(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BBD4C: 88C4001A  lbz r6, 0x1a(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BBD50: 98C3001A  stb r6, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[6].u8 ) };
	// 825BBD54: 98E30019  stb r7, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[7].u8 ) };
	// 825BBD58: 99030018  stb r8, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[8].u8 ) };
	// 825BBD5C: 9923001B  stb r9, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[9].u8 ) };
	// 825BBD60: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BBD64: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825BBD68: 80A40020  lwz r5, 0x20(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BBD6C: 90A30020  stw r5, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[5].u32 ) };
	// 825BBD70: C1840024  lfs f12, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BBD74: D1830024  stfs f12, 0x24(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825BBD78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BBD80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BBD80 size=584
    let mut pc: u32 = 0x825BBD80;
    'dispatch: loop {
        match pc {
            0x825BBD80 => {
    //   block [0x825BBD80..0x825BBDA8)
	// 825BBD80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BBD84: 486ED67D  bl 0x82ca9400
	ctx.lr = 0x825BBD88;
	sub_82CA93D0(ctx, base);
	// 825BBD88: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BBD8C: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBD90: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BBD94: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BBD98: 409A0010  bne cr6, 0x825bbda8
	if !ctx.cr[6].eq {
	pc = 0x825BBDA8; continue 'dispatch;
	}
	// 825BBD9C: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825BBDA0: 3BEBFFDF  addi r31, r11, -0x21
	ctx.r[31].s64 = ctx.r[11].s64 + -33;
	// 825BBDA4: 48000008  b 0x825bbdac
	pc = 0x825BBDAC; continue 'dispatch;
            }
            0x825BBDA8 => {
    //   block [0x825BBDA8..0x825BBDAC)
	// 825BBDA8: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BBDAC; continue 'dispatch;
            }
            0x825BBDAC => {
    //   block [0x825BBDAC..0x825BBE24)
	// 825BBDAC: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBDB0: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BBDB4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBDB8: 4BE12809  bl 0x823ce5c0
	ctx.lr = 0x825BBDBC;
	sub_823CE5C0(ctx, base);
	// 825BBDBC: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BBDC0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BBDC4: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BBDC8: 4BE12439  bl 0x823ce200
	ctx.lr = 0x825BBDCC;
	sub_823CE200(ctx, base);
	// 825BBDCC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BBDD0: 4BBFBD49  bl 0x821b7b18
	ctx.lr = 0x825BBDD4;
	sub_821B7B18(ctx, base);
	// 825BBDD4: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 825BBDD8: 4BC63481  bl 0x8221f258
	ctx.lr = 0x825BBDDC;
	sub_8221F258(ctx, base);
	// 825BBDDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BBDE0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BBDE4: 419A0040  beq cr6, 0x825bbe24
	if ctx.cr[6].eq {
	pc = 0x825BBE24; continue 'dispatch;
	}
	// 825BBDE8: 3D60820F  lis r11, -0x7df1
	ctx.r[11].s64 = -2112946176;
	// 825BBDEC: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825BBDF0: 394B2B90  addi r10, r11, 0x2b90
	ctx.r[10].s64 = ctx.r[11].s64 + 11152;
	// 825BBDF4: 915D0000  stw r10, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BBDF8: 4BC63461  bl 0x8221f258
	ctx.lr = 0x825BBDFC;
	sub_8221F258(ctx, base);
	// 825BBDFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BBE00: 419A0028  beq cr6, 0x825bbe28
	if ctx.cr[6].eq {
	pc = 0x825BBE28; continue 'dispatch;
	}
	// 825BBE04: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825BBE08: 93A30008  stw r29, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[29].u32 ) };
	// 825BBE0C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BBE10: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825BBE14: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BBE18: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BBE1C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BBE20: 4800000C  b 0x825bbe2c
	pc = 0x825BBE2C; continue 'dispatch;
            }
            0x825BBE24 => {
    //   block [0x825BBE24..0x825BBE28)
	// 825BBE24: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825BBE28; continue 'dispatch;
            }
            0x825BBE28 => {
    //   block [0x825BBE28..0x825BBE2C)
	// 825BBE28: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825BBE2C; continue 'dispatch;
            }
            0x825BBE2C => {
    //   block [0x825BBE2C..0x825BBF30)
	// 825BBE2C: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825BBE30: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BBE34: 419A00FC  beq cr6, 0x825bbf30
	if ctx.cr[6].eq {
	pc = 0x825BBF30; continue 'dispatch;
	}
	// 825BBE38: 835F0000  lwz r26, 0(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBE3C: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825BBE40: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBE44: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BBE48: 4BC6D2C1  bl 0x82229108
	ctx.lr = 0x825BBE4C;
	sub_82229108(ctx, base);
	// 825BBE4C: 3D60825C  lis r11, -0x7da4
	ctx.r[11].s64 = -2107899904;
	// 825BBE50: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825BBE54: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BBE58: 3BCBC820  addi r30, r11, -0x37e0
	ctx.r[30].s64 = ctx.r[11].s64 + -14304;
	// 825BBE5C: 4BC6BA25  bl 0x82227880
	ctx.lr = 0x825BBE60;
	sub_82227880(ctx, base);
	// 825BBE60: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825BBE64: 3D40821E  lis r10, -0x7de2
	ctx.r[10].s64 = -2111963136;
	// 825BBE68: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BBE6C: 388A8160  addi r4, r10, -0x7ea0
	ctx.r[4].s64 = ctx.r[10].s64 + -32416;
	// 825BBE70: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BBE74: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825BBE78: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BBE7C: 4BBDEC05  bl 0x8219aa80
	ctx.lr = 0x825BBE80;
	sub_8219AA80(ctx, base);
	// 825BBE80: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825BBE84: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825BBE88: 3BC9A910  addi r30, r9, -0x56f0
	ctx.r[30].s64 = ctx.r[9].s64 + -22256;
	// 825BBE8C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BBE90: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BBE94: 4BE1258D  bl 0x823ce420
	ctx.lr = 0x825BBE98;
	sub_823CE420(ctx, base);
	// 825BBE98: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BBE9C: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825BBEA0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BBEA4: 48468825  bl 0x82a246c8
	ctx.lr = 0x825BBEA8;
	sub_82A246C8(ctx, base);
	// 825BBEA8: 817A0008  lwz r11, 8(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBEAC: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825BBEB0: 390BFFF8  addi r8, r11, -8
	ctx.r[8].s64 = ctx.r[11].s64 + -8;
	// 825BBEB4: 911A0008  stw r8, 8(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BBEB8: 80BF0004  lwz r5, 4(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBEBC: 83DF0000  lwz r30, 0(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBEC0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBEC4: 4BC6D245  bl 0x82229108
	ctx.lr = 0x825BBEC8;
	sub_82229108(ctx, base);
	// 825BBEC8: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 825BBECC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825BBED0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBED4: 3BEBBCE0  addi r31, r11, -0x4320
	ctx.r[31].s64 = ctx.r[11].s64 + -17184;
	// 825BBED8: 4BC6B9A9  bl 0x82227880
	ctx.lr = 0x825BBEDC;
	sub_82227880(ctx, base);
	// 825BBEDC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 825BBEE0: 3CC08296  lis r6, -0x7d6a
	ctx.r[6].s64 = -2104098816;
	// 825BBEE4: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BBEE8: 388646A0  addi r4, r6, 0x46a0
	ctx.r[4].s64 = ctx.r[6].s64 + 18080;
	// 825BBEEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBEF0: 93A70000  stw r29, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825BBEF4: 93E70004  stw r31, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 825BBEF8: 4BBDEB89  bl 0x8219aa80
	ctx.lr = 0x825BBEFC;
	sub_8219AA80(ctx, base);
	// 825BBEFC: 3CA0820B  lis r5, -0x7df5
	ctx.r[5].s64 = -2113208320;
	// 825BBF00: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BBF04: 3BE5A91C  addi r31, r5, -0x56e4
	ctx.r[31].s64 = ctx.r[5].s64 + -22244;
	// 825BBF08: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BBF0C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BBF10: 4BE12511  bl 0x823ce420
	ctx.lr = 0x825BBF14;
	sub_823CE420(ctx, base);
	// 825BBF14: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BBF18: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825BBF1C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BBF20: 484687A9  bl 0x82a246c8
	ctx.lr = 0x825BBF24;
	sub_82A246C8(ctx, base);
	// 825BBF24: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBF28: 388BFFF8  addi r4, r11, -8
	ctx.r[4].s64 = ctx.r[11].s64 + -8;
	// 825BBF2C: 909E0008  stw r4, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x825BBF30; continue 'dispatch;
            }
            0x825BBF30 => {
    //   block [0x825BBF30..0x825BBF40)
	// 825BBF30: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825BBF34: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825BBF38: 9381005C  stw r28, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[28].u32 ) };
	// 825BBF3C: 419A0020  beq cr6, 0x825bbf5c
	if ctx.cr[6].eq {
	pc = 0x825BBF5C; continue 'dispatch;
	}
	pc = 0x825BBF40; continue 'dispatch;
            }
            0x825BBF40 => {
    //   block [0x825BBF40..0x825BBF5C)
	// 825BBF40: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BBF44: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BBF48: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BBF4C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BBF50: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BBF54: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BBF58: 4082FFE8  bne 0x825bbf40
	if !ctx.cr[0].eq {
	pc = 0x825BBF40; continue 'dispatch;
	}
	pc = 0x825BBF5C; continue 'dispatch;
            }
            0x825BBF5C => {
    //   block [0x825BBF5C..0x825BBF7C)
	// 825BBF5C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBF60: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 825BBF64: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825BBF68: 4BD399E1  bl 0x822f5948
	ctx.lr = 0x825BBF6C;
	sub_822F5948(ctx, base);
	// 825BBF6C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BBF70: 4BBFBBA9  bl 0x821b7b18
	ctx.lr = 0x825BBF74;
	sub_821B7B18(ctx, base);
	// 825BBF74: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 825BBF78: 419A0040  beq cr6, 0x825bbfb8
	if ctx.cr[6].eq {
	pc = 0x825BBFB8; continue 'dispatch;
	}
	pc = 0x825BBF7C; continue 'dispatch;
            }
            0x825BBF7C => {
    //   block [0x825BBF7C..0x825BBFB8)
	// 825BBF7C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BBF80: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BBF84: 7D60E028  lwarx r11, 0, r28
	// lwarx
	let ea = ctx.r[28].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BBF88: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BBF8C: 7D60E12D  stwcx. r11, 0, r28
	// stwcx.
	let addr = ctx.r[28].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BBF90: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BBF94: 4082FFE8  bne 0x825bbf7c
	if !ctx.cr[0].eq {
	pc = 0x825BBF7C; continue 'dispatch;
	}
	// 825BBF98: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BBF9C: 409A001C  bne cr6, 0x825bbfb8
	if !ctx.cr[6].eq {
	pc = 0x825BBFB8; continue 'dispatch;
	}
	// 825BBFA0: 807C0008  lwz r3, 8(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BBFA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BBFA8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BBFAC: 4E800421  bctrl
	ctx.lr = 0x825BBFB0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BBFB0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BBFB4: 4BC5FD85  bl 0x8221bd38
	ctx.lr = 0x825BBFB8;
	sub_8221BD38(ctx, base);
            }
            0x825BBFB8 => {
    //   block [0x825BBFB8..0x825BBFC8)
	// 825BBFB8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BBFBC: 4BBFBB5D  bl 0x821b7b18
	ctx.lr = 0x825BBFC0;
	sub_821B7B18(ctx, base);
	// 825BBFC0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BBFC4: 486ED48C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BBFC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BBFC8 size=528
    let mut pc: u32 = 0x825BBFC8;
    'dispatch: loop {
        match pc {
            0x825BBFC8 => {
    //   block [0x825BBFC8..0x825BC000)
	// 825BBFC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BBFCC: 486ED431  bl 0x82ca93fc
	ctx.lr = 0x825BBFD0;
	sub_82CA93D0(ctx, base);
	// 825BBFD0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BBFD4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BBFD8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825BBFDC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825BBFE0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825BBFE4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825BBFE8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BBFEC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825BBFF0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825BBFF4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BBFF8: 419A0008  beq cr6, 0x825bc000
	if ctx.cr[6].eq {
	pc = 0x825BC000; continue 'dispatch;
	}
	// 825BBFFC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BC000; continue 'dispatch;
            }
            0x825BC000 => {
    //   block [0x825BC000..0x825BC0A4)
	// 825BC000: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC004: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BC008: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC00C: 4BE125B5  bl 0x823ce5c0
	ctx.lr = 0x825BC010;
	sub_823CE5C0(ctx, base);
	// 825BC010: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BC014: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC018: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC01C: 4BE120F5  bl 0x823ce110
	ctx.lr = 0x825BC020;
	sub_823CE110(ctx, base);
	// 825BC020: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BC024: 4BBFBAF5  bl 0x821b7b18
	ctx.lr = 0x825BC028;
	sub_821B7B18(ctx, base);
	// 825BC028: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825BC02C: 4BC6322D  bl 0x8221f258
	ctx.lr = 0x825BC030;
	sub_8221F258(ctx, base);
	// 825BC030: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BC034: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BC038: 419A006C  beq cr6, 0x825bc0a4
	if ctx.cr[6].eq {
	pc = 0x825BC0A4; continue 'dispatch;
	}
	// 825BC03C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825BC040: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825BC044: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BC048: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BC04C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825BC050: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BC054: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BC058: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BC05C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BC060: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825BC064: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BC068: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 825BC06C: 4BC341D5  bl 0x821f0240
	ctx.lr = 0x825BC070;
	sub_821F0240(ctx, base);
	// 825BC070: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825BC074: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BC078: 4BC631E1  bl 0x8221f258
	ctx.lr = 0x825BC07C;
	sub_8221F258(ctx, base);
	// 825BC07C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BC080: 419A0028  beq cr6, 0x825bc0a8
	if ctx.cr[6].eq {
	pc = 0x825BC0A8; continue 'dispatch;
	}
	// 825BC084: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825BC088: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825BC08C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BC090: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825BC094: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC098: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BC09C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BC0A0: 4800000C  b 0x825bc0ac
	pc = 0x825BC0AC; continue 'dispatch;
            }
            0x825BC0A4 => {
    //   block [0x825BC0A4..0x825BC0A8)
	// 825BC0A4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825BC0A8; continue 'dispatch;
            }
            0x825BC0A8 => {
    //   block [0x825BC0A8..0x825BC0AC)
	// 825BC0A8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825BC0AC; continue 'dispatch;
            }
            0x825BC0AC => {
    //   block [0x825BC0AC..0x825BC0C0)
	// 825BC0AC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC0B0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825BC0B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC0B8: 419A0008  beq cr6, 0x825bc0c0
	if ctx.cr[6].eq {
	pc = 0x825BC0C0; continue 'dispatch;
	}
	// 825BC0BC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BC0C0; continue 'dispatch;
            }
            0x825BC0C0 => {
    //   block [0x825BC0C0..0x825BC140)
	// 825BC0C0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825BC0C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC0C8: 419A0078  beq cr6, 0x825bc140
	if ctx.cr[6].eq {
	pc = 0x825BC140; continue 'dispatch;
	}
	// 825BC0CC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC0D0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825BC0D4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC0D8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC0DC: 4BC6D02D  bl 0x82229108
	ctx.lr = 0x825BC0E0;
	sub_82229108(ctx, base);
	// 825BC0E0: 3D608258  lis r11, -0x7da8
	ctx.r[11].s64 = -2108162048;
	// 825BC0E4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825BC0E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC0EC: 3BCB8490  addi r30, r11, -0x7b70
	ctx.r[30].s64 = ctx.r[11].s64 + -31600;
	// 825BC0F0: 4BC6B791  bl 0x82227880
	ctx.lr = 0x825BC0F4;
	sub_82227880(ctx, base);
	// 825BC0F4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825BC0F8: 3D40827C  lis r10, -0x7d84
	ctx.r[10].s64 = -2105802752;
	// 825BC0FC: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BC100: 388AD6C8  addi r4, r10, -0x2938
	ctx.r[4].s64 = ctx.r[10].s64 + -10552;
	// 825BC104: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC108: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825BC10C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BC110: 4BBDE971  bl 0x8219aa80
	ctx.lr = 0x825BC114;
	sub_8219AA80(ctx, base);
	// 825BC114: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC118: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BC11C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC120: 4BE12301  bl 0x823ce420
	ctx.lr = 0x825BC124;
	sub_823CE420(ctx, base);
	// 825BC124: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC128: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825BC12C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC130: 48468599  bl 0x82a246c8
	ctx.lr = 0x825BC134;
	sub_82A246C8(ctx, base);
	// 825BC134: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC138: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825BC13C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825BC140; continue 'dispatch;
            }
            0x825BC140 => {
    //   block [0x825BC140..0x825BC150)
	// 825BC140: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825BC144: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BC148: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BC14C: 419A0020  beq cr6, 0x825bc16c
	if ctx.cr[6].eq {
	pc = 0x825BC16C; continue 'dispatch;
	}
	pc = 0x825BC150; continue 'dispatch;
            }
            0x825BC150 => {
    //   block [0x825BC150..0x825BC16C)
	// 825BC150: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BC154: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC158: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BC15C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BC160: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BC164: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC168: 4082FFE8  bne 0x825bc150
	if !ctx.cr[0].eq {
	pc = 0x825BC150; continue 'dispatch;
	}
	pc = 0x825BC16C; continue 'dispatch;
            }
            0x825BC16C => {
    //   block [0x825BC16C..0x825BC18C)
	// 825BC16C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC170: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825BC174: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825BC178: 4BD397D1  bl 0x822f5948
	ctx.lr = 0x825BC17C;
	sub_822F5948(ctx, base);
	// 825BC17C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BC180: 4BBFB999  bl 0x821b7b18
	ctx.lr = 0x825BC184;
	sub_821B7B18(ctx, base);
	// 825BC184: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BC188: 419A0040  beq cr6, 0x825bc1c8
	if ctx.cr[6].eq {
	pc = 0x825BC1C8; continue 'dispatch;
	}
	pc = 0x825BC18C; continue 'dispatch;
            }
            0x825BC18C => {
    //   block [0x825BC18C..0x825BC1C8)
	// 825BC18C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BC190: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC194: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BC198: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BC19C: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BC1A0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC1A4: 4082FFE8  bne 0x825bc18c
	if !ctx.cr[0].eq {
	pc = 0x825BC18C; continue 'dispatch;
	}
	// 825BC1A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BC1AC: 409A001C  bne cr6, 0x825bc1c8
	if !ctx.cr[6].eq {
	pc = 0x825BC1C8; continue 'dispatch;
	}
	// 825BC1B0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC1B4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC1B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BC1BC: 4E800421  bctrl
	ctx.lr = 0x825BC1C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BC1C0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BC1C4: 4BC5FB75  bl 0x8221bd38
	ctx.lr = 0x825BC1C8;
	sub_8221BD38(ctx, base);
            }
            0x825BC1C8 => {
    //   block [0x825BC1C8..0x825BC1D8)
	// 825BC1C8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC1CC: 4BBFB94D  bl 0x821b7b18
	ctx.lr = 0x825BC1D0;
	sub_821B7B18(ctx, base);
	// 825BC1D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BC1D4: 486ED278  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC1D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BC1D8 size=528
    let mut pc: u32 = 0x825BC1D8;
    'dispatch: loop {
        match pc {
            0x825BC1D8 => {
    //   block [0x825BC1D8..0x825BC210)
	// 825BC1D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BC1DC: 486ED221  bl 0x82ca93fc
	ctx.lr = 0x825BC1E0;
	sub_82CA93D0(ctx, base);
	// 825BC1E0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BC1E4: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825BC1E8: 3D408209  lis r10, -0x7df7
	ctx.r[10].s64 = -2113339392;
	// 825BC1EC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825BC1F0: 3B6AFFDF  addi r27, r10, -0x21
	ctx.r[27].s64 = ctx.r[10].s64 + -33;
	// 825BC1F4: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825BC1F8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC1FC: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 825BC200: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825BC204: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC208: 419A0008  beq cr6, 0x825bc210
	if ctx.cr[6].eq {
	pc = 0x825BC210; continue 'dispatch;
	}
	// 825BC20C: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BC210; continue 'dispatch;
            }
            0x825BC210 => {
    //   block [0x825BC210..0x825BC2B4)
	// 825BC210: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC214: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BC218: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC21C: 4BE123A5  bl 0x823ce5c0
	ctx.lr = 0x825BC220;
	sub_823CE5C0(ctx, base);
	// 825BC220: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825BC224: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC228: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC22C: 4BE11EE5  bl 0x823ce110
	ctx.lr = 0x825BC230;
	sub_823CE110(ctx, base);
	// 825BC230: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BC234: 4BBFB8E5  bl 0x821b7b18
	ctx.lr = 0x825BC238;
	sub_821B7B18(ctx, base);
	// 825BC238: 38600020  li r3, 0x20
	ctx.r[3].s64 = 32;
	// 825BC23C: 4BC6301D  bl 0x8221f258
	ctx.lr = 0x825BC240;
	sub_8221F258(ctx, base);
	// 825BC240: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825BC244: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825BC248: 419A006C  beq cr6, 0x825bc2b4
	if ctx.cr[6].eq {
	pc = 0x825BC2B4; continue 'dispatch;
	}
	// 825BC24C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825BC250: FBBF0008  std r29, 8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[29].u64 ) };
	// 825BC254: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 825BC258: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 825BC25C: 390B04D0  addi r8, r11, 0x4d0
	ctx.r[8].s64 = ctx.r[11].s64 + 1232;
	// 825BC260: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BC264: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BC268: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BC26C: E8E10050  ld r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BC270: 387F0018  addi r3, r31, 0x18
	ctx.r[3].s64 = ctx.r[31].s64 + 24;
	// 825BC274: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BC278: F8FF0010  std r7, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[7].u64 ) };
	// 825BC27C: 4BC33FC5  bl 0x821f0240
	ctx.lr = 0x825BC280;
	sub_821F0240(ctx, base);
	// 825BC280: 3860000C  li r3, 0xc
	ctx.r[3].s64 = 12;
	// 825BC284: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BC288: 4BC62FD1  bl 0x8221f258
	ctx.lr = 0x825BC28C;
	sub_8221F258(ctx, base);
	// 825BC28C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BC290: 419A0028  beq cr6, 0x825bc2b8
	if ctx.cr[6].eq {
	pc = 0x825BC2B8; continue 'dispatch;
	}
	// 825BC294: 3D608253  lis r11, -0x7dad
	ctx.r[11].s64 = -2108489728;
	// 825BC298: 93E30008  stw r31, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[31].u32 ) };
	// 825BC29C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BC2A0: 392B9238  addi r9, r11, -0x6dc8
	ctx.r[9].s64 = ctx.r[11].s64 + -28104;
	// 825BC2A4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BC2A8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BC2AC: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BC2B0: 4800000C  b 0x825bc2bc
	pc = 0x825BC2BC; continue 'dispatch;
            }
            0x825BC2B4 => {
    //   block [0x825BC2B4..0x825BC2B8)
	// 825BC2B4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	pc = 0x825BC2B8; continue 'dispatch;
            }
            0x825BC2B8 => {
    //   block [0x825BC2B8..0x825BC2BC)
	// 825BC2B8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x825BC2BC; continue 'dispatch;
            }
            0x825BC2BC => {
    //   block [0x825BC2BC..0x825BC2D0)
	// 825BC2BC: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC2C0: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 825BC2C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC2C8: 419A0008  beq cr6, 0x825bc2d0
	if ctx.cr[6].eq {
	pc = 0x825BC2D0; continue 'dispatch;
	}
	// 825BC2CC: 83EB0000  lwz r31, 0(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BC2D0; continue 'dispatch;
            }
            0x825BC2D0 => {
    //   block [0x825BC2D0..0x825BC350)
	// 825BC2D0: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 825BC2D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC2D8: 419A0078  beq cr6, 0x825bc350
	if ctx.cr[6].eq {
	pc = 0x825BC350; continue 'dispatch;
	}
	// 825BC2DC: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC2E0: 3880D8F0  li r4, -0x2710
	ctx.r[4].s64 = -10000;
	// 825BC2E4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC2E8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC2EC: 4BC6CE1D  bl 0x82229108
	ctx.lr = 0x825BC2F0;
	sub_82229108(ctx, base);
	// 825BC2F0: 3D60825C  lis r11, -0x7da4
	ctx.r[11].s64 = -2107899904;
	// 825BC2F4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 825BC2F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC2FC: 3BCBC860  addi r30, r11, -0x37a0
	ctx.r[30].s64 = ctx.r[11].s64 + -14240;
	// 825BC300: 4BC6B581  bl 0x82227880
	ctx.lr = 0x825BC304;
	sub_82227880(ctx, base);
	// 825BC304: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 825BC308: 3D408246  lis r10, -0x7dba
	ctx.r[10].s64 = -2109341696;
	// 825BC30C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825BC310: 388A5B50  addi r4, r10, 0x5b50
	ctx.r[4].s64 = ctx.r[10].s64 + 23376;
	// 825BC314: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC318: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825BC31C: 93CB0004  stw r30, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 825BC320: 4BBDE761  bl 0x8219aa80
	ctx.lr = 0x825BC324;
	sub_8219AA80(ctx, base);
	// 825BC324: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC328: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BC32C: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC330: 4BE120F1  bl 0x823ce420
	ctx.lr = 0x825BC334;
	sub_823CE420(ctx, base);
	// 825BC334: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BC338: 3880FFFE  li r4, -2
	ctx.r[4].s64 = -2;
	// 825BC33C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BC340: 48468389  bl 0x82a246c8
	ctx.lr = 0x825BC344;
	sub_82A246C8(ctx, base);
	// 825BC344: 817B0008  lwz r11, 8(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC348: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825BC34C: 913B0008  stw r9, 8(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[9].u32 ) };
	pc = 0x825BC350; continue 'dispatch;
            }
            0x825BC350 => {
    //   block [0x825BC350..0x825BC360)
	// 825BC350: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825BC354: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BC358: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BC35C: 419A0020  beq cr6, 0x825bc37c
	if ctx.cr[6].eq {
	pc = 0x825BC37C; continue 'dispatch;
	}
	pc = 0x825BC360; continue 'dispatch;
            }
            0x825BC360 => {
    //   block [0x825BC360..0x825BC37C)
	// 825BC360: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BC364: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC368: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BC36C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BC370: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BC374: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC378: 4082FFE8  bne 0x825bc360
	if !ctx.cr[0].eq {
	pc = 0x825BC360; continue 'dispatch;
	}
	pc = 0x825BC37C; continue 'dispatch;
            }
            0x825BC37C => {
    //   block [0x825BC37C..0x825BC39C)
	// 825BC37C: 81790004  lwz r11, 4(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC380: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825BC384: 386B0068  addi r3, r11, 0x68
	ctx.r[3].s64 = ctx.r[11].s64 + 104;
	// 825BC388: 4BD395C1  bl 0x822f5948
	ctx.lr = 0x825BC38C;
	sub_822F5948(ctx, base);
	// 825BC38C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BC390: 4BBFB789  bl 0x821b7b18
	ctx.lr = 0x825BC394;
	sub_821B7B18(ctx, base);
	// 825BC394: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 825BC398: 419A0040  beq cr6, 0x825bc3d8
	if ctx.cr[6].eq {
	pc = 0x825BC3D8; continue 'dispatch;
	}
	pc = 0x825BC39C; continue 'dispatch;
            }
            0x825BC39C => {
    //   block [0x825BC39C..0x825BC3D8)
	// 825BC39C: 7D4000A6  mfmsr r10
	ctx.r[10].u64 = ctx.msr;
	// 825BC3A0: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC3A4: 7D60E828  lwarx r11, 0, r29
	// lwarx
	let ea = ctx.r[29].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[11].u64 = ctx.reserved.u32 as u64;
	// 825BC3A8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BC3AC: 7D60E92D  stwcx. r11, 0, r29
	// stwcx.
	let addr = ctx.r[29].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[11].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 825BC3B0: 7D410164  mtmsrd r10, 1
	ctx.msr = (ctx.r[10].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 825BC3B4: 4082FFE8  bne 0x825bc39c
	if !ctx.cr[0].eq {
	pc = 0x825BC39C; continue 'dispatch;
	}
	// 825BC3B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BC3BC: 409A001C  bne cr6, 0x825bc3d8
	if !ctx.cr[6].eq {
	pc = 0x825BC3D8; continue 'dispatch;
	}
	// 825BC3C0: 807D0008  lwz r3, 8(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC3C4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC3C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 825BC3CC: 4E800421  bctrl
	ctx.lr = 0x825BC3D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 825BC3D0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BC3D4: 4BC5F965  bl 0x8221bd38
	ctx.lr = 0x825BC3D8;
	sub_8221BD38(ctx, base);
            }
            0x825BC3D8 => {
    //   block [0x825BC3D8..0x825BC3E8)
	// 825BC3D8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 825BC3DC: 4BBFB73D  bl 0x821b7b18
	ctx.lr = 0x825BC3E0;
	sub_821B7B18(ctx, base);
	// 825BC3E0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BC3E4: 486ED068  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC3E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC3E8 size=156
    let mut pc: u32 = 0x825BC3E8;
    'dispatch: loop {
        match pc {
            0x825BC3E8 => {
    //   block [0x825BC3E8..0x825BC410)
	// 825BC3E8: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 825BC3EC: 7D692050  subf r11, r9, r4
	ctx.r[11].s64 = ctx.r[4].s64 - ctx.r[9].s64;
	// 825BC3F0: 7F092040  cmplw cr6, r9, r4
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC3F4: 7D6A2E70  srawi r10, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BC3F8: 554B2834  slwi r11, r10, 5
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BC3FC: 7C6B2A14  add r3, r11, r5
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 825BC400: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC404: 39490010  addi r10, r9, 0x10
	ctx.r[10].s64 = ctx.r[9].s64 + 16;
	// 825BC408: 3965000C  addi r11, r5, 0xc
	ctx.r[11].s64 = ctx.r[5].s64 + 12;
	// 825BC40C: 7D254850  subf r9, r5, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[5].s64;
	pc = 0x825BC410; continue 'dispatch;
            }
            0x825BC410 => {
    //   block [0x825BC410..0x825BC484)
	// 825BC410: 810AFFF0  lwz r8, -0x10(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BC414: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 825BC418: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 825BC41C: 80CAFFF4  lwz r6, -0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BC420: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825BC424: 80AAFFF8  lwz r5, -8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BC428: 90ABFFFC  stw r5, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[5].u32 ) };
	// 825BC42C: 7C095C2E  lfsx f0, r9, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC430: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BC434: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC438: 990B0004  stb r8, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
	// 825BC43C: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC440: 98EB0005  stb r7, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[7].u8 ) };
	// 825BC444: 88CA0002  lbz r6, 2(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC448: 98CB0006  stb r6, 6(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u8 ) };
	// 825BC44C: 88AA0003  lbz r5, 3(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC450: 98AB0007  stb r5, 7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), ctx.r[5].u8 ) };
	// 825BC454: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC458: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825BC45C: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC460: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825BC464: 88EA000C  lbz r7, 0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC468: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 825BC46C: 98EB0010  stb r7, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 825BC470: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825BC474: 38CAFFF0  addi r6, r10, -0x10
	ctx.r[6].s64 = ctx.r[10].s64 + -16;
	// 825BC478: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC47C: 409AFF94  bne cr6, 0x825bc410
	if !ctx.cr[6].eq {
	pc = 0x825BC410; continue 'dispatch;
	}
	// 825BC480: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC488(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC488 size=164
    let mut pc: u32 = 0x825BC488;
    'dispatch: loop {
        match pc {
            0x825BC488 => {
    //   block [0x825BC488..0x825BC49C)
	// 825BC488: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC48C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC490: 39450010  addi r10, r5, 0x10
	ctx.r[10].s64 = ctx.r[5].s64 + 16;
	// 825BC494: 39250014  addi r9, r5, 0x14
	ctx.r[9].s64 = ctx.r[5].s64 + 20;
	// 825BC498: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	pc = 0x825BC49C; continue 'dispatch;
            }
            0x825BC49C => {
    //   block [0x825BC49C..0x825BC52C)
	// 825BC49C: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC4A0: 38EB0008  addi r7, r11, 8
	ctx.r[7].s64 = ctx.r[11].s64 + 8;
	// 825BC4A4: 910BFFF8  stw r8, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[8].u32 ) };
	// 825BC4A8: 80C50004  lwz r6, 4(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC4AC: 90CBFFFC  stw r6, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[6].u32 ) };
	// 825BC4B0: C0050008  lfs f0, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC4B4: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BC4B8: 8065000C  lwz r3, 0xc(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC4BC: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BC4C0: 890A0000  lbz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC4C4: 990B0008  stb r8, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u8 ) };
	// 825BC4C8: 88EA0001  lbz r7, 1(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC4CC: 98EB0009  stb r7, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[7].u8 ) };
	// 825BC4D0: 88CA0002  lbz r6, 2(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC4D4: 98CB000A  stb r6, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[6].u8 ) };
	// 825BC4D8: 886A0003  lbz r3, 3(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC4DC: 986B000B  stb r3, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[3].u8 ) };
	// 825BC4E0: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC4E4: 990B000C  stb r8, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u8 ) };
	// 825BC4E8: 88E90001  lbz r7, 1(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC4EC: 98EB000D  stb r7, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[7].u8 ) };
	// 825BC4F0: 88C90002  lbz r6, 2(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC4F4: 98CB000E  stb r6, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[6].u8 ) };
	// 825BC4F8: 88690003  lbz r3, 3(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC4FC: 986B000F  stb r3, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[3].u8 ) };
	// 825BC500: C1A50018  lfs f13, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC504: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825BC508: 8105001C  lwz r8, 0x1c(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BC50C: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 825BC510: C1850020  lfs f12, 0x20(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BC514: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825BC518: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 825BC51C: 38EBFFF8  addi r7, r11, -8
	ctx.r[7].s64 = ctx.r[11].s64 + -8;
	// 825BC520: 7F072040  cmplw cr6, r7, r4
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC524: 409AFF78  bne cr6, 0x825bc49c
	if !ctx.cr[6].eq {
	pc = 0x825BC49C; continue 'dispatch;
	}
	// 825BC528: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC530(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC530 size=92
    let mut pc: u32 = 0x825BC530;
    'dispatch: loop {
        match pc {
            0x825BC530 => {
    //   block [0x825BC530..0x825BC544)
	// 825BC530: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825BC534: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC538: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC53C: 39640008  addi r11, r4, 8
	ctx.r[11].s64 = ctx.r[4].s64 + 8;
	// 825BC540: 7D441850  subf r10, r4, r3
	ctx.r[10].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x825BC544; continue 'dispatch;
            }
            0x825BC544 => {
    //   block [0x825BC544..0x825BC574)
	// 825BC544: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BC548: 419A002C  beq cr6, 0x825bc574
	if ctx.cr[6].eq {
	pc = 0x825BC574; continue 'dispatch;
	}
	// 825BC54C: C00BFFF8  lfs f0, -8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC550: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BC554: 812BFFFC  lwz r9, -4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BC558: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BC55C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC560: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 825BC564: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC568: 90E3000C  stw r7, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[7].u32 ) };
	// 825BC56C: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC570: 90C30010  stw r6, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	pc = 0x825BC574; continue 'dispatch;
            }
            0x825BC574 => {
    //   block [0x825BC574..0x825BC58C)
	// 825BC574: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	// 825BC578: 38630014  addi r3, r3, 0x14
	ctx.r[3].s64 = ctx.r[3].s64 + 20;
	// 825BC57C: 392BFFF8  addi r9, r11, -8
	ctx.r[9].s64 = ctx.r[11].s64 + -8;
	// 825BC580: 7F092840  cmplw cr6, r9, r5
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC584: 409AFFC0  bne cr6, 0x825bc544
	if !ctx.cr[6].eq {
	pc = 0x825BC544; continue 'dispatch;
	}
	// 825BC588: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC590 size=188
    let mut pc: u32 = 0x825BC590;
    'dispatch: loop {
        match pc {
            0x825BC590 => {
    //   block [0x825BC590..0x825BC5A8)
	// 825BC590: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825BC594: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC598: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC59C: 39430017  addi r10, r3, 0x17
	ctx.r[10].s64 = ctx.r[3].s64 + 23;
	// 825BC5A0: 39640015  addi r11, r4, 0x15
	ctx.r[11].s64 = ctx.r[4].s64 + 21;
	// 825BC5A4: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x825BC5A8; continue 'dispatch;
            }
            0x825BC5A8 => {
    //   block [0x825BC5A8..0x825BC630)
	// 825BC5A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BC5AC: 419A0084  beq cr6, 0x825bc630
	if ctx.cr[6].eq {
	pc = 0x825BC630; continue 'dispatch;
	}
	// 825BC5B0: 810BFFEB  lwz r8, -0x15(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-21 as u32) ) } as u64;
	// 825BC5B4: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BC5B8: 80EBFFEF  lwz r7, -0x11(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17 as u32) ) } as u64;
	// 825BC5BC: 90EAFFED  stw r7, -0x13(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-19 as u32), ctx.r[7].u32 ) };
	// 825BC5C0: 80CBFFF3  lwz r6, -0xd(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13 as u32) ) } as u64;
	// 825BC5C4: 90CAFFF1  stw r6, -0xf(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15 as u32), ctx.r[6].u32 ) };
	// 825BC5C8: C00BFFF7  lfs f0, -9(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC5CC: D00AFFF5  stfs f0, -0xb(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11 as u32), tmp.u32 ) };
	// 825BC5D0: 808BFFFB  lwz r4, -5(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5 as u32) ) } as u64;
	// 825BC5D4: 908AFFF9  stw r4, -7(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7 as u32), ctx.r[4].u32 ) };
	// 825BC5D8: 890B0002  lbz r8, 2(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC5DC: 88EBFFFF  lbz r7, -1(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825BC5E0: 88CB0000  lbz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC5E4: 888B0001  lbz r4, 1(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC5E8: 988AFFFF  stb r4, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[4].u8 ) };
	// 825BC5EC: 7CCB49AE  stbx r6, r11, r9
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[6].u8) };
	// 825BC5F0: 98EAFFFD  stb r7, -3(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-3 as u32), ctx.r[7].u8 ) };
	// 825BC5F4: 990A0000  stb r8, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u8 ) };
	// 825BC5F8: 890B0006  lbz r8, 6(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(6 as u32) ) } as u64;
	// 825BC5FC: 88EB0003  lbz r7, 3(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC600: 88CB0004  lbz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC604: 888B0005  lbz r4, 5(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(5 as u32) ) } as u64;
	// 825BC608: 988A0003  stb r4, 3(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(3 as u32), ctx.r[4].u8 ) };
	// 825BC60C: 98CA0002  stb r6, 2(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(2 as u32), ctx.r[6].u8 ) };
	// 825BC610: 98EA0001  stb r7, 1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(1 as u32), ctx.r[7].u8 ) };
	// 825BC614: 990A0004  stb r8, 4(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
	// 825BC618: C1AB0007  lfs f13, 7(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC61C: D1AA0005  stfs f13, 5(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5 as u32), tmp.u32 ) };
	// 825BC620: 810B000B  lwz r8, 0xb(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11 as u32) ) } as u64;
	// 825BC624: 910A0009  stw r8, 9(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(9 as u32), ctx.r[8].u32 ) };
	// 825BC628: C18B000F  lfs f12, 0xf(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(15 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BC62C: D18A000D  stfs f12, 0xd(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(13 as u32), tmp.u32 ) };
	pc = 0x825BC630; continue 'dispatch;
            }
            0x825BC630 => {
    //   block [0x825BC630..0x825BC64C)
	// 825BC630: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 825BC634: 38630028  addi r3, r3, 0x28
	ctx.r[3].s64 = ctx.r[3].s64 + 40;
	// 825BC638: 390BFFEB  addi r8, r11, -0x15
	ctx.r[8].s64 = ctx.r[11].s64 + -21;
	// 825BC63C: 394A0028  addi r10, r10, 0x28
	ctx.r[10].s64 = ctx.r[10].s64 + 40;
	// 825BC640: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC644: 409AFF64  bne cr6, 0x825bc5a8
	if !ctx.cr[6].eq {
	pc = 0x825BC5A8; continue 'dispatch;
	}
	// 825BC648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC650 size=176
    let mut pc: u32 = 0x825BC650;
    'dispatch: loop {
        match pc {
            0x825BC650 => {
    //   block [0x825BC650..0x825BC668)
	// 825BC650: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC654: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC658: 39450004  addi r10, r5, 4
	ctx.r[10].s64 = ctx.r[5].s64 + 4;
	// 825BC65C: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 825BC660: 392A0010  addi r9, r10, 0x10
	ctx.r[9].s64 = ctx.r[10].s64 + 16;
	// 825BC664: 390A0014  addi r8, r10, 0x14
	ctx.r[8].s64 = ctx.r[10].s64 + 20;
	pc = 0x825BC668; continue 'dispatch;
            }
            0x825BC668 => {
    //   block [0x825BC668..0x825BC700)
	// 825BC668: 80E50000  lwz r7, 0(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC66C: 38CB0008  addi r6, r11, 8
	ctx.r[6].s64 = ctx.r[11].s64 + 8;
	// 825BC670: 90EBFFF4  stw r7, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[7].u32 ) };
	// 825BC674: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC678: 906BFFF8  stw r3, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[3].u32 ) };
	// 825BC67C: 80EA0004  lwz r7, 4(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC680: 90EBFFFC  stw r7, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[7].u32 ) };
	// 825BC684: C00A0008  lfs f0, 8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC688: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BC68C: 80CA000C  lwz r6, 0xc(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC690: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BC694: 88690000  lbz r3, 0(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC698: 986B0008  stb r3, 8(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u8 ) };
	// 825BC69C: 88E90001  lbz r7, 1(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC6A0: 98EB0009  stb r7, 9(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(9 as u32), ctx.r[7].u8 ) };
	// 825BC6A4: 88C90002  lbz r6, 2(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC6A8: 98CB000A  stb r6, 0xa(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(10 as u32), ctx.r[6].u8 ) };
	// 825BC6AC: 88690003  lbz r3, 3(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC6B0: 986B000B  stb r3, 0xb(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(11 as u32), ctx.r[3].u8 ) };
	// 825BC6B4: 88E80000  lbz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC6B8: 98EB000C  stb r7, 0xc(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[7].u8 ) };
	// 825BC6BC: 88C80001  lbz r6, 1(r8)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC6C0: 98CB000D  stb r6, 0xd(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(13 as u32), ctx.r[6].u8 ) };
	// 825BC6C4: 88680002  lbz r3, 2(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC6C8: 986B000E  stb r3, 0xe(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(14 as u32), ctx.r[3].u8 ) };
	// 825BC6CC: 88E80003  lbz r7, 3(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC6D0: 98EB000F  stb r7, 0xf(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(15 as u32), ctx.r[7].u8 ) };
	// 825BC6D4: C1AA0018  lfs f13, 0x18(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC6D8: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 825BC6DC: 80CA001C  lwz r6, 0x1c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BC6E0: 90CB0014  stw r6, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[6].u32 ) };
	// 825BC6E4: C18A0020  lfs f12, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BC6E8: D18B0018  stfs f12, 0x18(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825BC6EC: 396B0028  addi r11, r11, 0x28
	ctx.r[11].s64 = ctx.r[11].s64 + 40;
	// 825BC6F0: 386BFFF4  addi r3, r11, -0xc
	ctx.r[3].s64 = ctx.r[11].s64 + -12;
	// 825BC6F4: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC6F8: 409AFF70  bne cr6, 0x825bc668
	if !ctx.cr[6].eq {
	pc = 0x825BC668; continue 'dispatch;
	}
	// 825BC6FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC700(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC700 size=148
    let mut pc: u32 = 0x825BC700;
    'dispatch: loop {
        match pc {
            0x825BC700 => {
    //   block [0x825BC700..0x825BC718)
	// 825BC700: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	// 825BC704: 7F042840  cmplw cr6, r4, r5
	ctx.cr[6].compare_u32(ctx.r[4].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC708: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC70C: 39430013  addi r10, r3, 0x13
	ctx.r[10].s64 = ctx.r[3].s64 + 19;
	// 825BC710: 39640011  addi r11, r4, 0x11
	ctx.r[11].s64 = ctx.r[4].s64 + 17;
	// 825BC714: 7D241850  subf r9, r4, r3
	ctx.r[9].s64 = ctx.r[3].s64 - ctx.r[4].s64;
	pc = 0x825BC718; continue 'dispatch;
            }
            0x825BC718 => {
    //   block [0x825BC718..0x825BC778)
	// 825BC718: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825BC71C: 419A005C  beq cr6, 0x825bc778
	if ctx.cr[6].eq {
	pc = 0x825BC778; continue 'dispatch;
	}
	// 825BC720: 810BFFEF  lwz r8, -0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17 as u32) ) } as u64;
	// 825BC724: 91030000  stw r8, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BC728: 80EBFFF3  lwz r7, -0xd(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-13 as u32) ) } as u64;
	// 825BC72C: 90EAFFF1  stw r7, -0xf(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-15 as u32), ctx.r[7].u32 ) };
	// 825BC730: 80CBFFF7  lwz r6, -9(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-9 as u32) ) } as u64;
	// 825BC734: 90CAFFF5  stw r6, -0xb(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-11 as u32), ctx.r[6].u32 ) };
	// 825BC738: C00BFFFB  lfs f0, -5(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-5 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC73C: D00AFFF9  stfs f0, -7(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-7 as u32), tmp.u32 ) };
	// 825BC740: 888B0002  lbz r4, 2(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC744: 890BFFFF  lbz r8, -1(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-1 as u32) ) } as u64;
	// 825BC748: 88EB0000  lbz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC74C: 88CB0001  lbz r6, 1(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC750: 98CAFFFF  stb r6, -1(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-1 as u32), ctx.r[6].u8 ) };
	// 825BC754: 7CE959AE  stbx r7, r9, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32), ctx.r[7].u8) };
	// 825BC758: 990AFFFD  stb r8, -3(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(-3 as u32), ctx.r[8].u8 ) };
	// 825BC75C: 988A0000  stb r4, 0(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u8 ) };
	// 825BC760: C1AB0003  lfs f13, 3(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(3 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC764: D1AA0001  stfs f13, 1(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(1 as u32), tmp.u32 ) };
	// 825BC768: 808B0007  lwz r4, 7(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(7 as u32) ) } as u64;
	// 825BC76C: 908A0005  stw r4, 5(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(5 as u32), ctx.r[4].u32 ) };
	// 825BC770: 890B000B  lbz r8, 0xb(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(11 as u32) ) } as u64;
	// 825BC774: 990A0009  stb r8, 9(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(9 as u32), ctx.r[8].u8 ) };
	pc = 0x825BC778; continue 'dispatch;
            }
            0x825BC778 => {
    //   block [0x825BC778..0x825BC794)
	// 825BC778: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825BC77C: 38630020  addi r3, r3, 0x20
	ctx.r[3].s64 = ctx.r[3].s64 + 32;
	// 825BC780: 390BFFEF  addi r8, r11, -0x11
	ctx.r[8].s64 = ctx.r[11].s64 + -17;
	// 825BC784: 394A0020  addi r10, r10, 0x20
	ctx.r[10].s64 = ctx.r[10].s64 + 32;
	// 825BC788: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BC78C: 409AFF8C  bne cr6, 0x825bc718
	if !ctx.cr[6].eq {
	pc = 0x825BC718; continue 'dispatch;
	}
	// 825BC790: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC798(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BC798 size=132
    let mut pc: u32 = 0x825BC798;
    'dispatch: loop {
        match pc {
            0x825BC798 => {
    //   block [0x825BC798..0x825BC7AC)
	// 825BC798: 7F032040  cmplw cr6, r3, r4
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC79C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BC7A0: 39450004  addi r10, r5, 4
	ctx.r[10].s64 = ctx.r[5].s64 + 4;
	// 825BC7A4: 3963000C  addi r11, r3, 0xc
	ctx.r[11].s64 = ctx.r[3].s64 + 12;
	// 825BC7A8: 392A000C  addi r9, r10, 0xc
	ctx.r[9].s64 = ctx.r[10].s64 + 12;
	pc = 0x825BC7AC; continue 'dispatch;
            }
            0x825BC7AC => {
    //   block [0x825BC7AC..0x825BC81C)
	// 825BC7AC: 81050000  lwz r8, 0(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC7B0: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 825BC7B4: 910BFFF4  stw r8, -0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-12 as u32), ctx.r[8].u32 ) };
	// 825BC7B8: 80CA0000  lwz r6, 0(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC7BC: 90CBFFF8  stw r6, -8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), ctx.r[6].u32 ) };
	// 825BC7C0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC7C4: 906BFFFC  stw r3, -4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), ctx.r[3].u32 ) };
	// 825BC7C8: C00A0008  lfs f0, 8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BC7CC: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 825BC7D0: 89090000  lbz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC7D4: 990B0004  stb r8, 4(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u8 ) };
	// 825BC7D8: 88E90001  lbz r7, 1(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(1 as u32) ) } as u64;
	// 825BC7DC: 98EB0005  stb r7, 5(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(5 as u32), ctx.r[7].u8 ) };
	// 825BC7E0: 88C90002  lbz r6, 2(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(2 as u32) ) } as u64;
	// 825BC7E4: 98CB0006  stb r6, 6(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(6 as u32), ctx.r[6].u8 ) };
	// 825BC7E8: 88690003  lbz r3, 3(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(3 as u32) ) } as u64;
	// 825BC7EC: 986B0007  stb r3, 7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(7 as u32), ctx.r[3].u8 ) };
	// 825BC7F0: C1AA0010  lfs f13, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BC7F4: D1AB0008  stfs f13, 8(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825BC7F8: 810A0014  lwz r8, 0x14(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BC7FC: 910B000C  stw r8, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 825BC800: 88EA0018  lbz r7, 0x18(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BC804: 98EB0010  stb r7, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 825BC808: 396B0020  addi r11, r11, 0x20
	ctx.r[11].s64 = ctx.r[11].s64 + 32;
	// 825BC80C: 38CBFFF4  addi r6, r11, -0xc
	ctx.r[6].s64 = ctx.r[11].s64 + -12;
	// 825BC810: 7F062040  cmplw cr6, r6, r4
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825BC814: 409AFF98  bne cr6, 0x825bc7ac
	if !ctx.cr[6].eq {
	pc = 0x825BC7AC; continue 'dispatch;
	}
	// 825BC818: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BC820 size=56
    let mut pc: u32 = 0x825BC820;
    'dispatch: loop {
        match pc {
            0x825BC820 => {
    //   block [0x825BC820..0x825BC83C)
	// 825BC820: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825BC824: 419A0018  beq cr6, 0x825bc83c
	if ctx.cr[6].eq {
	pc = 0x825BC83C; continue 'dispatch;
	}
	// 825BC828: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825BC82C: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825BC830: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BC834: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BC838: 409A0008  bne cr6, 0x825bc840
	if !ctx.cr[6].eq {
	pc = 0x825BC840; continue 'dispatch;
	}
	pc = 0x825BC83C; continue 'dispatch;
            }
            0x825BC83C => {
    //   block [0x825BC83C..0x825BC840)
	// 825BC83C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BC840; continue 'dispatch;
            }
            0x825BC840 => {
    //   block [0x825BC840..0x825BC858)
	// 825BC840: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BC844: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC848: 419A0010  beq cr6, 0x825bc858
	if ctx.cr[6].eq {
		sub_825BC858(ctx, base);
		return;
	}
	// 825BC84C: 81640024  lwz r11, 0x24(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 825BC850: 55637FFE  rlwinm r3, r11, 0xf, 0x1f, 0x1f
	ctx.r[3].u64 = ctx.r[11].u32 as u64 & 0x0001FFFFu64;
	// 825BC854: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BC858 size=8
    let mut pc: u32 = 0x825BC858;
    'dispatch: loop {
        match pc {
            0x825BC858 => {
    //   block [0x825BC858..0x825BC860)
	// 825BC858: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825BC85C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BC860 size=356
    let mut pc: u32 = 0x825BC860;
    'dispatch: loop {
        match pc {
            0x825BC860 => {
    //   block [0x825BC860..0x825BC888)
	// 825BC860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BC864: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BC868: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BC86C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825BC870: 419A0018  beq cr6, 0x825bc888
	if ctx.cr[6].eq {
	pc = 0x825BC888; continue 'dispatch;
	}
	// 825BC874: 89640090  lbz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 825BC878: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 825BC87C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BC880: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BC884: 409A0008  bne cr6, 0x825bc88c
	if !ctx.cr[6].eq {
	pc = 0x825BC88C; continue 'dispatch;
	}
	pc = 0x825BC888; continue 'dispatch;
            }
            0x825BC888 => {
    //   block [0x825BC888..0x825BC88C)
	// 825BC888: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BC88C; continue 'dispatch;
            }
            0x825BC88C => {
    //   block [0x825BC88C..0x825BC8D4)
	// 825BC88C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BC890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC894: 419A0120  beq cr6, 0x825bc9b4
	if ctx.cr[6].eq {
	pc = 0x825BC9B4; continue 'dispatch;
	}
	// 825BC898: 81440024  lwz r10, 0x24(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) } as u64;
	// 825BC89C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825BC8A0: 55497FFE  rlwinm r9, r10, 0xf, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x0001FFFFu64;
	// 825BC8A4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825BC8A8: 419A00E8  beq cr6, 0x825bc990
	if ctx.cr[6].eq {
	pc = 0x825BC990; continue 'dispatch;
	}
	// 825BC8AC: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 825BC8B0: 81440048  lwz r10, 0x48(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(72 as u32) ) } as u64;
	// 825BC8B4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC8B8: 419A001C  beq cr6, 0x825bc8d4
	if ctx.cr[6].eq {
	pc = 0x825BC8D4; continue 'dispatch;
	}
	// 825BC8BC: 896B0011  lbz r11, 0x11(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BC8C0: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 825BC8C4: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BC8C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC8CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BC8D0: 480000C4  b 0x825bc994
	pc = 0x825BC994; continue 'dispatch;
            }
            0x825BC8D4 => {
    //   block [0x825BC8D4..0x825BC8F0)
	// 825BC8D4: 80C4004C  lwz r6, 0x4c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(76 as u32) ) } as u64;
	// 825BC8D8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825BC8DC: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BC8E0: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825BC8E4: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BC8E8: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BC8EC: 40810054  ble 0x825bc940
	if !ctx.cr[0].gt {
	pc = 0x825BC940; continue 'dispatch;
	}
	pc = 0x825BC8F0; continue 'dispatch;
            }
            0x825BC8F0 => {
    //   block [0x825BC8F0..0x825BC910)
	// 825BC8F0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BC8F4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BC8F8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825BC8FC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC900: 2F070011  cmpwi cr6, r7, 0x11
	ctx.cr[6].compare_i32(ctx.r[7].s32, 17, &mut ctx.xer);
	// 825BC904: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825BC908: 41980008  blt cr6, 0x825bc910
	if ctx.cr[6].lt {
	pc = 0x825BC910; continue 'dispatch;
	}
	// 825BC90C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825BC910; continue 'dispatch;
            }
            0x825BC910 => {
    //   block [0x825BC910..0x825BC92C)
	// 825BC910: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825BC914: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825BC918: 419A0014  beq cr6, 0x825bc92c
	if ctx.cr[6].eq {
	pc = 0x825BC92C; continue 'dispatch;
	}
	// 825BC91C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825BC920: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825BC924: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825BC928: 4800000C  b 0x825bc934
	pc = 0x825BC934; continue 'dispatch;
            }
            0x825BC92C => {
    //   block [0x825BC92C..0x825BC934)
	// 825BC92C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825BC930: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825BC934; continue 'dispatch;
            }
            0x825BC934 => {
    //   block [0x825BC934..0x825BC940)
	// 825BC934: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825BC938: 4199FFB8  bgt cr6, 0x825bc8f0
	if ctx.cr[6].gt {
	pc = 0x825BC8F0; continue 'dispatch;
	}
	// 825BC93C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825BC940; continue 'dispatch;
            }
            0x825BC940 => {
    //   block [0x825BC940..0x825BC95C)
	// 825BC940: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BC944: 419A003C  beq cr6, 0x825bc980
	if ctx.cr[6].eq {
	pc = 0x825BC980; continue 'dispatch;
	}
	// 825BC948: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BC94C: 2F0B0011  cmpwi cr6, r11, 0x11
	ctx.cr[6].compare_i32(ctx.r[11].s32, 17, &mut ctx.xer);
	// 825BC950: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BC954: 41990008  bgt cr6, 0x825bc95c
	if ctx.cr[6].gt {
	pc = 0x825BC95C; continue 'dispatch;
	}
	// 825BC958: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BC95C; continue 'dispatch;
            }
            0x825BC95C => {
    //   block [0x825BC95C..0x825BC980)
	// 825BC95C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BC960: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BC964: 409A001C  bne cr6, 0x825bc980
	if !ctx.cr[6].eq {
	pc = 0x825BC980; continue 'dispatch;
	}
	// 825BC968: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BC96C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BC970: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825BC974: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BC978: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC97C: 48000018  b 0x825bc994
	pc = 0x825BC994; continue 'dispatch;
            }
            0x825BC980 => {
    //   block [0x825BC980..0x825BC990)
	// 825BC980: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825BC984: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BC988: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BC98C: 48000008  b 0x825bc994
	pc = 0x825BC994; continue 'dispatch;
            }
            0x825BC990 => {
    //   block [0x825BC990..0x825BC994)
	// 825BC990: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825BC994; continue 'dispatch;
            }
            0x825BC994 => {
    //   block [0x825BC994..0x825BC9B4)
	// 825BC994: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825BC998: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BC99C: 419A0018  beq cr6, 0x825bc9b4
	if ctx.cr[6].eq {
	pc = 0x825BC9B4; continue 'dispatch;
	}
	// 825BC9A0: 8143000C  lwz r10, 0xc(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BC9A4: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BC9A8: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BC9AC: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	// 825BC9B0: 4E800421  bctrl
	ctx.lr = 0x825BC9B4;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x825BC9B4 => {
    //   block [0x825BC9B4..0x825BC9C4)
	// 825BC9B4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825BC9B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BC9BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BC9C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BC9C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BC9C8 size=540
    let mut pc: u32 = 0x825BC9C8;
    'dispatch: loop {
        match pc {
            0x825BC9C8 => {
    //   block [0x825BC9C8..0x825BCA08)
	// 825BC9C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BC9CC: 486ECA2D  bl 0x82ca93f8
	ctx.lr = 0x825BC9D0;
	sub_82CA93D0(ctx, base);
	// 825BC9D0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BC9D4: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 825BC9D8: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825BC9DC: FB2100E0  std r25, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[25].u64 ) };
	// 825BC9E0: 3B600018  li r27, 0x18
	ctx.r[27].s64 = 24;
	// 825BC9E4: FB0100E8  std r24, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[24].u64 ) };
	// 825BC9E8: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BC9EC: 83A100E4  lwz r29, 0xe4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BC9F0: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 825BC9F4: 83C100EC  lwz r30, 0xec(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825BC9F8: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 825BC9FC: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BCA00: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCA04: 409900A0  ble cr6, 0x825bcaa4
	if !ctx.cr[6].gt {
	pc = 0x825BCAA4; continue 'dispatch;
	}
	pc = 0x825BCA08; continue 'dispatch;
            }
            0x825BCA08 => {
    //   block [0x825BCA08..0x825BCA7C)
	// 825BCA08: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825BCA0C: 409900B8  ble cr6, 0x825bcac4
	if !ctx.cr[6].gt {
	pc = 0x825BCAC4; continue 'dispatch;
	}
	// 825BCA10: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825BCA14: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825BCA18: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825BCA1C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BCA20: 48000759  bl 0x825bd178
	ctx.lr = 0x825BCA24;
	sub_825BD178(ctx, base);
	// 825BCA24: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 825BCA28: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BCA2C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BCA30: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCA34: 7CE9F050  subf r7, r9, r30
	ctx.r[7].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 825BCA38: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BCA3C: 7CDD4050  subf r6, r29, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[29].s64;
	// 825BCA40: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 825BCA44: 7CA7DBD6  divw r5, r7, r27
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[27].s32;
	// 825BCA48: 7C86DBD6  divw r4, r6, r27
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[27].s32;
	// 825BCA4C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BCA50: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BCA54: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 825BCA58: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BCA5C: 40980020  bge cr6, 0x825bca7c
	if !ctx.cr[6].lt {
	pc = 0x825BCA7C; continue 'dispatch;
	}
	// 825BCA60: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825BCA64: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCA68: 4BFFFF61  bl 0x825bc9c8
	ctx.lr = 0x825BCA6C;
	sub_825BC9C8(ctx, base);
	// 825BCA6C: EB210058  ld r25, 0x58(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCA70: FB2100E0  std r25, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[25].u64 ) };
	// 825BCA74: 83A100E4  lwz r29, 0xe4(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BCA78: 4800001C  b 0x825bca94
	pc = 0x825BCA94; continue 'dispatch;
            }
            0x825BCA7C => {
    //   block [0x825BCA7C..0x825BCA94)
	// 825BCA7C: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825BCA80: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCA84: 4BFFFF45  bl 0x825bc9c8
	ctx.lr = 0x825BCA88;
	sub_825BC9C8(ctx, base);
	// 825BCA88: EB010050  ld r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCA8C: FB0100E8  std r24, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[24].u64 ) };
	// 825BCA90: 83C100EC  lwz r30, 0xec(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	pc = 0x825BCA94; continue 'dispatch;
            }
            0x825BCA94 => {
    //   block [0x825BCA94..0x825BCAA4)
	// 825BCA94: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 825BCA98: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BCA9C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCAA0: 4199FF68  bgt cr6, 0x825bca08
	if ctx.cr[6].gt {
	pc = 0x825BCA08; continue 'dispatch;
	}
	pc = 0x825BCAA4; continue 'dispatch;
            }
            0x825BCAA4 => {
    //   block [0x825BCAA4..0x825BCABC)
	// 825BCAA4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCAA8: 40990014  ble cr6, 0x825bcabc
	if !ctx.cr[6].gt {
	pc = 0x825BCABC; continue 'dispatch;
	}
	// 825BCAAC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 825BCAB0: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825BCAB4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825BCAB8: 48000FA1  bl 0x825bda58
	ctx.lr = 0x825BCABC;
	sub_825BDA58(ctx, base);
	pc = 0x825BCABC; continue 'dispatch;
            }
            0x825BCABC => {
    //   block [0x825BCABC..0x825BCAC4)
	// 825BCABC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825BCAC0: 486EC988  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BCAC4 => {
    //   block [0x825BCAC4..0x825BCAF8)
	// 825BCAC4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCAC8: 4099FFDC  ble cr6, 0x825bcaa4
	if !ctx.cr[6].gt {
	pc = 0x825BCAA4; continue 'dispatch;
	}
	// 825BCACC: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 825BCAD0: 7F8BDBD6  divw r28, r11, r27
	ctx.r[28].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BCAD4: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825BCAD8: 40990084  ble cr6, 0x825bcb5c
	if !ctx.cr[6].gt {
	pc = 0x825BCB5C; continue 'dispatch;
	}
	// 825BCADC: 7F8B0E70  srawi r11, r28, 1
	ctx.xer.ca = (ctx.r[28].s32 < 0) && ((ctx.r[28].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[28].s32 >> 1) as i64;
	// 825BCAE0: 7FCB0195  addze. r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BCAE4: 40810078  ble 0x825bcb5c
	if !ctx.cr[0].gt {
	pc = 0x825BCB5C; continue 'dispatch;
	}
	// 825BCAE8: 57CB083C  slwi r11, r30, 1
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BCAEC: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825BCAF0: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BCAF4: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	pc = 0x825BCAF8; continue 'dispatch;
            }
            0x825BCAF8 => {
    //   block [0x825BCAF8..0x825BCB5C)
	// 825BCAF8: 3BFFFFE8  addi r31, r31, -0x18
	ctx.r[31].s64 = ctx.r[31].s64 + -24;
	// 825BCAFC: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BCB00: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825BCB04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BCB08: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BCB0C: 4BEC372D  bl 0x82480238
	ctx.lr = 0x825BCB10;
	sub_82480238(ctx, base);
	// 825BCB10: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 825BCB14: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BCB18: 4BF09C41  bl 0x824c6758
	ctx.lr = 0x825BCB1C;
	sub_824C6758(ctx, base);
	// 825BCB1C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BCB20: 893F0014  lbz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BCB24: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825BCB28: 891F0015  lbz r8, 0x15(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BCB2C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BCB30: 897F0016  lbz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BCB34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BCB38: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BCB3C: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BCB40: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825BCB44: 99210064  stb r9, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u8 ) };
	// 825BCB48: 99010065  stb r8, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[8].u8 ) };
	// 825BCB4C: 99610066  stb r11, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[11].u8 ) };
	// 825BCB50: 48002889  bl 0x825bf3d8
	ctx.lr = 0x825BCB54;
	sub_825BF3D8(ctx, base);
	// 825BCB54: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BCB58: 4199FFA0  bgt cr6, 0x825bcaf8
	if ctx.cr[6].gt {
	pc = 0x825BCAF8; continue 'dispatch;
	}
	pc = 0x825BCB5C; continue 'dispatch;
            }
            0x825BCB5C => {
    //   block [0x825BCB5C..0x825BCB78)
	// 825BCB5C: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 825BCB60: 2F1C0001  cmpwi cr6, r28, 1
	ctx.cr[6].compare_i32(ctx.r[28].s32, 1, &mut ctx.xer);
	// 825BCB64: 4099FF58  ble cr6, 0x825bcabc
	if !ctx.cr[6].gt {
	pc = 0x825BCABC; continue 'dispatch;
	}
	// 825BCB68: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 825BCB6C: 83810054  lwz r28, 0x54(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCB70: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCB74: 40990054  ble cr6, 0x825bcbc8
	if !ctx.cr[6].gt {
	pc = 0x825BCBC8; continue 'dispatch;
	}
	pc = 0x825BCB78; continue 'dispatch;
            }
            0x825BCB78 => {
    //   block [0x825BCB78..0x825BCBC8)
	// 825BCB78: 3BFCFFE8  addi r31, r28, -0x18
	ctx.r[31].s64 = ctx.r[28].s64 + -24;
	// 825BCB7C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BCB80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BCB84: 4BF0A4CD  bl 0x824c7050
	ctx.lr = 0x825BCB88;
	sub_824C7050(ctx, base);
	// 825BCB88: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BCB8C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BCB90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BCB94: 4BF0D175  bl 0x824c9d08
	ctx.lr = 0x825BCB98;
	sub_824C9D08(ctx, base);
	// 825BCB98: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BCB9C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 825BCBA0: 4BF0A4B1  bl 0x824c7050
	ctx.lr = 0x825BCBA4;
	sub_824C7050(ctx, base);
	// 825BCBA4: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 825BCBA8: 7C661B78  mr r6, r3
	ctx.r[6].u64 = ctx.r[3].u64;
	// 825BCBAC: 7CABDBD6  divw r5, r11, r27
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BCBB0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825BCBB4: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 825BCBB8: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 825BCBBC: 4800281D  bl 0x825bf3d8
	ctx.lr = 0x825BCBC0;
	sub_825BF3D8(ctx, base);
	// 825BCBC0: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BCBC4: 4BEC33B5  bl 0x8247ff78
	ctx.lr = 0x825BCBC8;
	sub_8247FF78(ctx, base);
	pc = 0x825BCBC8; continue 'dispatch;
            }
            0x825BCBC8 => {
    //   block [0x825BCBC8..0x825BCBE4)
	// 825BCBC8: 3B9CFFE8  addi r28, r28, -0x18
	ctx.r[28].s64 = ctx.r[28].s64 + -24;
	// 825BCBCC: 7D7DE050  subf r11, r29, r28
	ctx.r[11].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 825BCBD0: 7D6BDBD6  divw r11, r11, r27
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[27].s32;
	// 825BCBD4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCBD8: 4199FFA0  bgt cr6, 0x825bcb78
	if ctx.cr[6].gt {
	pc = 0x825BCB78; continue 'dispatch;
	}
	// 825BCBDC: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825BCBE0: 486EC868  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BCBE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BCBE8 size=324
    let mut pc: u32 = 0x825BCBE8;
    'dispatch: loop {
        match pc {
            0x825BCBE8 => {
    //   block [0x825BCBE8..0x825BCC28)
	// 825BCBE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BCBEC: 486EC811  bl 0x82ca93fc
	ctx.lr = 0x825BCBF0;
	sub_82CA93D0(ctx, base);
	// 825BCBF0: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BCBF4: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BCBF8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825BCBFC: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 825BCC00: 3BA00028  li r29, 0x28
	ctx.r[29].s64 = 40;
	// 825BCC04: FB8100B8  std r28, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u64 ) };
	// 825BCC08: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BCC0C: 832100B4  lwz r25, 0xb4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825BCC10: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825BCC14: 834100BC  lwz r26, 0xbc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BCC18: 7D79D050  subf r11, r25, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	// 825BCC1C: 7D6BEBD6  divw r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	// 825BCC20: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCC24: 409900A0  ble cr6, 0x825bccc4
	if !ctx.cr[6].gt {
	pc = 0x825BCCC4; continue 'dispatch;
	}
	pc = 0x825BCC28; continue 'dispatch;
            }
            0x825BCC28 => {
    //   block [0x825BCC28..0x825BCC9C)
	// 825BCC28: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825BCC2C: 409900B8  ble cr6, 0x825bcce4
	if !ctx.cr[6].gt {
	pc = 0x825BCCE4; continue 'dispatch;
	}
	// 825BCC30: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BCC34: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BCC38: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BCC3C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BCC40: 48000F31  bl 0x825bdb70
	ctx.lr = 0x825BCC44;
	sub_825BDB70(ctx, base);
	// 825BCC44: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 825BCC48: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BCC4C: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BCC50: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCC54: 7CE9D050  subf r7, r9, r26
	ctx.r[7].s64 = ctx.r[26].s64 - ctx.r[9].s64;
	// 825BCC58: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BCC5C: 7CD94050  subf r6, r25, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[25].s64;
	// 825BCC60: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 825BCC64: 7CA7EBD6  divw r5, r7, r29
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[29].s32;
	// 825BCC68: 7C86EBD6  divw r4, r6, r29
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[29].s32;
	// 825BCC6C: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BCC70: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BCC74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BCC78: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BCC7C: 40980020  bge cr6, 0x825bcc9c
	if !ctx.cr[6].lt {
	pc = 0x825BCC9C; continue 'dispatch;
	}
	// 825BCC80: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BCC84: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCC88: 4BFFFF61  bl 0x825bcbe8
	ctx.lr = 0x825BCC8C;
	sub_825BCBE8(ctx, base);
	// 825BCC8C: EB610058  ld r27, 0x58(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCC90: FB6100B0  std r27, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[27].u64 ) };
	// 825BCC94: 832100B4  lwz r25, 0xb4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825BCC98: 4800001C  b 0x825bccb4
	pc = 0x825BCCB4; continue 'dispatch;
            }
            0x825BCC9C => {
    //   block [0x825BCC9C..0x825BCCB4)
	// 825BCC9C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BCCA0: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCCA4: 4BFFFF45  bl 0x825bcbe8
	ctx.lr = 0x825BCCA8;
	sub_825BCBE8(ctx, base);
	// 825BCCA8: EB810050  ld r28, 0x50(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCCAC: FB8100B8  std r28, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[28].u64 ) };
	// 825BCCB0: 834100BC  lwz r26, 0xbc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	pc = 0x825BCCB4; continue 'dispatch;
            }
            0x825BCCB4 => {
    //   block [0x825BCCB4..0x825BCCC4)
	// 825BCCB4: 7D79D050  subf r11, r25, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	// 825BCCB8: 7D6BEBD6  divw r11, r11, r29
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	// 825BCCBC: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCCC0: 4199FF68  bgt cr6, 0x825bcc28
	if ctx.cr[6].gt {
	pc = 0x825BCC28; continue 'dispatch;
	}
	pc = 0x825BCCC4; continue 'dispatch;
            }
            0x825BCCC4 => {
    //   block [0x825BCCC4..0x825BCCDC)
	// 825BCCC4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCCC8: 40990014  ble cr6, 0x825bccdc
	if !ctx.cr[6].gt {
	pc = 0x825BCCDC; continue 'dispatch;
	}
	// 825BCCCC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BCCD0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BCCD4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BCCD8: 48001331  bl 0x825be008
	ctx.lr = 0x825BCCDC;
	sub_825BE008(ctx, base);
	pc = 0x825BCCDC; continue 'dispatch;
            }
            0x825BCCDC => {
    //   block [0x825BCCDC..0x825BCCE4)
	// 825BCCDC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BCCE0: 486EC76C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BCCE4 => {
    //   block [0x825BCCE4..0x825BCD14)
	// 825BCCE4: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCCE8: 4099FFDC  ble cr6, 0x825bccc4
	if !ctx.cr[6].gt {
	pc = 0x825BCCC4; continue 'dispatch;
	}
	// 825BCCEC: 7D79D050  subf r11, r25, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[25].s64;
	// 825BCCF0: 7D4BEBD6  divw r10, r11, r29
	ctx.r[10].s32 = ctx.r[11].s32 / ctx.r[29].s32;
	// 825BCCF4: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825BCCF8: 4099001C  ble cr6, 0x825bcd14
	if !ctx.cr[6].gt {
	pc = 0x825BCD14; continue 'dispatch;
	}
	// 825BCCFC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BCD00: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BCD04: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BCD08: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BCD0C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BCD10: 48001FD1  bl 0x825bece0
	ctx.lr = 0x825BCD14;
	sub_825BECE0(ctx, base);
	pc = 0x825BCD14; continue 'dispatch;
            }
            0x825BCD14 => {
    //   block [0x825BCD14..0x825BCD2C)
	// 825BCD14: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BCD18: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BCD1C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BCD20: 480020C1  bl 0x825bede0
	ctx.lr = 0x825BCD24;
	sub_825BEDE0(ctx, base);
	// 825BCD24: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BCD28: 486EC724  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BCD30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BCD30 size=512
    let mut pc: u32 = 0x825BCD30;
    'dispatch: loop {
        match pc {
            0x825BCD30 => {
    //   block [0x825BCD30..0x825BCD70)
	// 825BCD30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BCD34: 486EC6C5  bl 0x82ca93f8
	ctx.lr = 0x825BCD38;
	sub_82CA93D0(ctx, base);
	// 825BCD38: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BCD3C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825BCD40: 7C982378  mr r24, r4
	ctx.r[24].u64 = ctx.r[4].u64;
	// 825BCD44: FB4100C0  std r26, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u64 ) };
	// 825BCD48: 3B80000C  li r28, 0xc
	ctx.r[28].s64 = 12;
	// 825BCD4C: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 825BCD50: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825BCD54: 83E100C4  lwz r31, 0xc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BCD58: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BCD5C: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BCD60: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 825BCD64: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BCD68: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCD6C: 409900A0  ble cr6, 0x825bce0c
	if !ctx.cr[6].gt {
	pc = 0x825BCE0C; continue 'dispatch;
	}
	pc = 0x825BCD70; continue 'dispatch;
            }
            0x825BCD70 => {
    //   block [0x825BCD70..0x825BCDE4)
	// 825BCD70: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BCD74: 409900B8  ble cr6, 0x825bce2c
	if !ctx.cr[6].gt {
	pc = 0x825BCE2C; continue 'dispatch;
	}
	// 825BCD78: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BCD7C: 7F05C378  mr r5, r24
	ctx.r[5].u64 = ctx.r[24].u64;
	// 825BCD80: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 825BCD84: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BCD88: 480013D9  bl 0x825be160
	ctx.lr = 0x825BCD8C;
	sub_825BE160(ctx, base);
	// 825BCD8C: 7FCB0E70  srawi r11, r30, 1
	ctx.xer.ca = (ctx.r[30].s32 < 0) && ((ctx.r[30].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[30].s32 >> 1) as i64;
	// 825BCD90: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BCD94: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BCD98: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCD9C: 7CE9E850  subf r7, r9, r29
	ctx.r[7].s64 = ctx.r[29].s64 - ctx.r[9].s64;
	// 825BCDA0: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BCDA4: 7CDF4050  subf r6, r31, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[31].s64;
	// 825BCDA8: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 825BCDAC: 7CA7E3D6  divw r5, r7, r28
	ctx.r[5].s32 = ctx.r[7].s32 / ctx.r[28].s32;
	// 825BCDB0: 7C86E3D6  divw r4, r6, r28
	ctx.r[4].s32 = ctx.r[6].s32 / ctx.r[28].s32;
	// 825BCDB4: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BCDB8: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BCDBC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BCDC0: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BCDC4: 40980020  bge cr6, 0x825bcde4
	if !ctx.cr[6].lt {
	pc = 0x825BCDE4; continue 'dispatch;
	}
	// 825BCDC8: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BCDCC: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCDD0: 4BFFFF61  bl 0x825bcd30
	ctx.lr = 0x825BCDD4;
	sub_825BCD30(ctx, base);
	// 825BCDD4: EB410058  ld r26, 0x58(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCDD8: FB4100C0  std r26, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[26].u64 ) };
	// 825BCDDC: 83E100C4  lwz r31, 0xc4(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BCDE0: 4800001C  b 0x825bcdfc
	pc = 0x825BCDFC; continue 'dispatch;
            }
            0x825BCDE4 => {
    //   block [0x825BCDE4..0x825BCDFC)
	// 825BCDE4: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825BCDE8: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCDEC: 4BFFFF45  bl 0x825bcd30
	ctx.lr = 0x825BCDF0;
	sub_825BCD30(ctx, base);
	// 825BCDF0: EB010050  ld r24, 0x50(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCDF4: FB0100C8  std r24, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[24].u64 ) };
	// 825BCDF8: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	pc = 0x825BCDFC; continue 'dispatch;
            }
            0x825BCDFC => {
    //   block [0x825BCDFC..0x825BCE0C)
	// 825BCDFC: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 825BCE00: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BCE04: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCE08: 4199FF68  bgt cr6, 0x825bcd70
	if ctx.cr[6].gt {
	pc = 0x825BCD70; continue 'dispatch;
	}
	pc = 0x825BCE0C; continue 'dispatch;
            }
            0x825BCE0C => {
    //   block [0x825BCE0C..0x825BCE24)
	// 825BCE0C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCE10: 40990014  ble cr6, 0x825bce24
	if !ctx.cr[6].gt {
	pc = 0x825BCE24; continue 'dispatch;
	}
	// 825BCE14: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825BCE18: 7F04C378  mr r4, r24
	ctx.r[4].u64 = ctx.r[24].u64;
	// 825BCE1C: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BCE20: 480016F1  bl 0x825be510
	ctx.lr = 0x825BCE24;
	sub_825BE510(ctx, base);
	pc = 0x825BCE24; continue 'dispatch;
            }
            0x825BCE24 => {
    //   block [0x825BCE24..0x825BCE2C)
	// 825BCE24: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BCE28: 486EC620  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BCE2C => {
    //   block [0x825BCE2C..0x825BCE60)
	// 825BCE2C: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCE30: 4099FFDC  ble cr6, 0x825bce0c
	if !ctx.cr[6].gt {
	pc = 0x825BCE0C; continue 'dispatch;
	}
	// 825BCE34: 7D7FE850  subf r11, r31, r29
	ctx.r[11].s64 = ctx.r[29].s64 - ctx.r[31].s64;
	// 825BCE38: 7F2BE3D6  divw r25, r11, r28
	ctx.r[25].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BCE3C: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 825BCE40: 40990060  ble cr6, 0x825bcea0
	if !ctx.cr[6].gt {
	pc = 0x825BCEA0; continue 'dispatch;
	}
	// 825BCE44: 7F2B0E70  srawi r11, r25, 1
	ctx.xer.ca = (ctx.r[25].s32 < 0) && ((ctx.r[25].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[25].s32 >> 1) as i64;
	// 825BCE48: 7FAB0195  addze. r29, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[29].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825BCE4C: 40810054  ble 0x825bcea0
	if !ctx.cr[0].gt {
	pc = 0x825BCEA0; continue 'dispatch;
	}
	// 825BCE50: 57AB083C  slwi r11, r29, 1
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BCE54: 7D7D5A14  add r11, r29, r11
	ctx.r[11].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825BCE58: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BCE5C: 7FCBFA14  add r30, r11, r31
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825BCE60; continue 'dispatch;
            }
            0x825BCE60 => {
    //   block [0x825BCE60..0x825BCEA0)
	// 825BCE60: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 825BCE64: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 825BCE68: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825BCE6C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BCE70: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 825BCE74: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BCE78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BCE7C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BCE80: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BCE84: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BCE88: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BCE8C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BCE90: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825BCE94: 48002B85  bl 0x825bfa18
	ctx.lr = 0x825BCE98;
	sub_825BFA18(ctx, base);
	// 825BCE98: 2F1D0000  cmpwi cr6, r29, 0
	ctx.cr[6].compare_i32(ctx.r[29].s32, 0, &mut ctx.xer);
	// 825BCE9C: 4199FFC4  bgt cr6, 0x825bce60
	if ctx.cr[6].gt {
	pc = 0x825BCE60; continue 'dispatch;
	}
	pc = 0x825BCEA0; continue 'dispatch;
            }
            0x825BCEA0 => {
    //   block [0x825BCEA0..0x825BCEBC)
	// 825BCEA0: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 825BCEA4: 2F190001  cmpwi cr6, r25, 1
	ctx.cr[6].compare_i32(ctx.r[25].s32, 1, &mut ctx.xer);
	// 825BCEA8: 4099FF7C  ble cr6, 0x825bce24
	if !ctx.cr[6].gt {
	pc = 0x825BCE24; continue 'dispatch;
	}
	// 825BCEAC: 7F2BCB78  mr r11, r25
	ctx.r[11].u64 = ctx.r[25].u64;
	// 825BCEB0: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCEB4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCEB8: 4099005C  ble cr6, 0x825bcf14
	if !ctx.cr[6].gt {
	pc = 0x825BCF14; continue 'dispatch;
	}
	pc = 0x825BCEBC; continue 'dispatch;
            }
            0x825BCEBC => {
    //   block [0x825BCEBC..0x825BCF14)
	// 825BCEBC: 397EFFF4  addi r11, r30, -0xc
	ctx.r[11].s64 = ctx.r[30].s64 + -12;
	// 825BCEC0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BCEC4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825BCEC8: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 825BCECC: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 825BCED0: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825BCED4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BCED8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825BCEDC: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BCEE0: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 825BCEE4: 83A90004  lwz r29, 4(r9)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BCEE8: 7CA5E3D6  divw r5, r5, r28
	ctx.r[5].s32 = ctx.r[5].s32 / ctx.r[28].s32;
	// 825BCEEC: 81290008  lwz r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BCEF0: 91480000  stw r10, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BCEF4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BCEF8: 91480004  stw r10, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825BCEFC: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BCF00: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825BCF04: 91480008  stw r10, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BCF08: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BCF0C: 91210058  stw r9, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u32 ) };
	// 825BCF10: 48002B09  bl 0x825bfa18
	ctx.lr = 0x825BCF14;
	sub_825BFA18(ctx, base);
	pc = 0x825BCF14; continue 'dispatch;
            }
            0x825BCF14 => {
    //   block [0x825BCF14..0x825BCF30)
	// 825BCF14: 3BDEFFF4  addi r30, r30, -0xc
	ctx.r[30].s64 = ctx.r[30].s64 + -12;
	// 825BCF18: 7D7FF050  subf r11, r31, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[31].s64;
	// 825BCF1C: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BCF20: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BCF24: 4199FF98  bgt cr6, 0x825bcebc
	if ctx.cr[6].gt {
	pc = 0x825BCEBC; continue 'dispatch;
	}
	// 825BCF28: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BCF2C: 486EC51C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BCF30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BCF30 size=296
    let mut pc: u32 = 0x825BCF30;
    'dispatch: loop {
        match pc {
            0x825BCF30 => {
    //   block [0x825BCF30..0x825BCF6C)
	// 825BCF30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BCF34: 486EC4CD  bl 0x82ca9400
	ctx.lr = 0x825BCF38;
	sub_82CA93D0(ctx, base);
	// 825BCF38: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BCF3C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BCF40: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BCF44: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 825BCF48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BCF4C: FBA100B8  std r29, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u64 ) };
	// 825BCF50: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825BCF54: 834100B4  lwz r26, 0xb4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825BCF58: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825BCF5C: 7D7AD850  subf r11, r26, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 825BCF60: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BCF64: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BCF68: 409900A0  ble cr6, 0x825bd008
	if !ctx.cr[6].gt {
	pc = 0x825BD008; continue 'dispatch;
	}
	pc = 0x825BCF6C; continue 'dispatch;
            }
            0x825BCF6C => {
    //   block [0x825BCF6C..0x825BCFE0)
	// 825BCF6C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 825BCF70: 409900B8  ble cr6, 0x825bd028
	if !ctx.cr[6].gt {
	pc = 0x825BD028; continue 'dispatch;
	}
	// 825BCF74: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BCF78: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BCF7C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BCF80: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BCF84: 4800167D  bl 0x825be600
	ctx.lr = 0x825BCF88;
	sub_825BE600(ctx, base);
	// 825BCF88: 7FEB0E70  srawi r11, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 825BCF8C: 8121005C  lwz r9, 0x5c(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BCF90: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BCF94: 81010054  lwz r8, 0x54(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BCF98: 7CE9D850  subf r7, r9, r27
	ctx.r[7].s64 = ctx.r[27].s64 - ctx.r[9].s64;
	// 825BCF9C: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BCFA0: 7CDA4050  subf r6, r26, r8
	ctx.r[6].s64 = ctx.r[8].s64 - ctx.r[26].s64;
	// 825BCFA4: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 825BCFA8: 54E50034  rlwinm r5, r7, 0, 0, 0x1a
	ctx.r[5].u64 = ctx.r[7].u32 as u64 & 0xFFFFFFFFu64;
	// 825BCFAC: 54C40034  rlwinm r4, r6, 0, 0, 0x1a
	ctx.r[4].u64 = ctx.r[6].u32 as u64 & 0xFFFFFFFFu64;
	// 825BCFB0: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BCFB4: 7F042800  cmpw cr6, r4, r5
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BCFB8: 7FC6F378  mr r6, r30
	ctx.r[6].u64 = ctx.r[30].u64;
	// 825BCFBC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 825BCFC0: 40980020  bge cr6, 0x825bcfe0
	if !ctx.cr[6].lt {
	pc = 0x825BCFE0; continue 'dispatch;
	}
	// 825BCFC4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BCFC8: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCFCC: 4BFFFF65  bl 0x825bcf30
	ctx.lr = 0x825BCFD0;
	sub_825BCF30(ctx, base);
	// 825BCFD0: EB810058  ld r28, 0x58(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCFD4: FB8100B0  std r28, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[28].u64 ) };
	// 825BCFD8: 834100B4  lwz r26, 0xb4(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825BCFDC: 4800001C  b 0x825bcff8
	pc = 0x825BCFF8; continue 'dispatch;
            }
            0x825BCFE0 => {
    //   block [0x825BCFE0..0x825BCFF8)
	// 825BCFE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BCFE4: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BCFE8: 4BFFFF49  bl 0x825bcf30
	ctx.lr = 0x825BCFEC;
	sub_825BCF30(ctx, base);
	// 825BCFEC: EBA10050  ld r29, 0x50(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BCFF0: FBA100B8  std r29, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[29].u64 ) };
	// 825BCFF4: 836100BC  lwz r27, 0xbc(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	pc = 0x825BCFF8; continue 'dispatch;
            }
            0x825BCFF8 => {
    //   block [0x825BCFF8..0x825BD008)
	// 825BCFF8: 7D7AD850  subf r11, r26, r27
	ctx.r[11].s64 = ctx.r[27].s64 - ctx.r[26].s64;
	// 825BCFFC: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BD000: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BD004: 4199FF68  bgt cr6, 0x825bcf6c
	if ctx.cr[6].gt {
	pc = 0x825BCF6C; continue 'dispatch;
	}
	pc = 0x825BD008; continue 'dispatch;
            }
            0x825BD008 => {
    //   block [0x825BD008..0x825BD020)
	// 825BD008: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BD00C: 40990014  ble cr6, 0x825bd020
	if !ctx.cr[6].gt {
	pc = 0x825BD020; continue 'dispatch;
	}
	// 825BD010: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BD014: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD018: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD01C: 4800191D  bl 0x825be938
	ctx.lr = 0x825BD020;
	sub_825BE938(ctx, base);
	pc = 0x825BD020; continue 'dispatch;
            }
            0x825BD020 => {
    //   block [0x825BD020..0x825BD028)
	// 825BD020: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BD024: 486EC42C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BD028 => {
    //   block [0x825BD028..0x825BD058)
	// 825BD028: 2F0B0020  cmpwi cr6, r11, 0x20
	ctx.cr[6].compare_i32(ctx.r[11].s32, 32, &mut ctx.xer);
	// 825BD02C: 4099FFDC  ble cr6, 0x825bd008
	if !ctx.cr[6].gt {
	pc = 0x825BD008; continue 'dispatch;
	}
	// 825BD030: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BD034: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD038: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD03C: 48001825  bl 0x825be860
	ctx.lr = 0x825BD040;
	sub_825BE860(ctx, base);
	// 825BD040: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 825BD044: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD048: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD04C: 480021D5  bl 0x825bf220
	ctx.lr = 0x825BD050;
	sub_825BF220(ctx, base);
	// 825BD050: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BD054: 486EC3FC  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD058(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BD058 size=148
    let mut pc: u32 = 0x825BD058;
    'dispatch: loop {
        match pc {
            0x825BD058 => {
    //   block [0x825BD058..0x825BD0EC)
	// 825BD058: 81240000  lwz r9, 0(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD05C: 39640004  addi r11, r4, 4
	ctx.r[11].s64 = ctx.r[4].s64 + 4;
	// 825BD060: 39430004  addi r10, r3, 4
	ctx.r[10].s64 = ctx.r[3].s64 + 4;
	// 825BD064: 38EB0010  addi r7, r11, 0x10
	ctx.r[7].s64 = ctx.r[11].s64 + 16;
	// 825BD068: 390A0010  addi r8, r10, 0x10
	ctx.r[8].s64 = ctx.r[10].s64 + 16;
	// 825BD06C: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BD070: 80C40004  lwz r6, 4(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD074: 90C30004  stw r6, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BD078: 80A40008  lwz r5, 8(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BD07C: 90A30008  stw r5, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825BD080: C004000C  lfs f0, 0xc(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD084: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BD088: 81640010  lwz r11, 0x10(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD08C: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825BD090: 89440014  lbz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD094: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825BD098: 89240015  lbz r9, 0x15(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD09C: 99230015  stb r9, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 825BD0A0: 89040016  lbz r8, 0x16(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD0A4: 99030016  stb r8, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[8].u8 ) };
	// 825BD0A8: 88E40017  lbz r7, 0x17(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BD0AC: 98E30017  stb r7, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[7].u8 ) };
	// 825BD0B0: 88C40018  lbz r6, 0x18(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BD0B4: 98C30018  stb r6, 0x18(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[6].u8 ) };
	// 825BD0B8: 88A40019  lbz r5, 0x19(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BD0BC: 98A30019  stb r5, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[5].u8 ) };
	// 825BD0C0: 8964001A  lbz r11, 0x1a(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BD0C4: 9963001A  stb r11, 0x1a(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(26 as u32), ctx.r[11].u8 ) };
	// 825BD0C8: 8944001B  lbz r10, 0x1b(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BD0CC: 9943001B  stb r10, 0x1b(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(27 as u32), ctx.r[10].u8 ) };
	// 825BD0D0: C1A4001C  lfs f13, 0x1c(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BD0D4: D1A3001C  stfs f13, 0x1c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825BD0D8: 81240020  lwz r9, 0x20(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BD0DC: 91230020  stw r9, 0x20(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825BD0E0: C1840024  lfs f12, 0x24(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BD0E4: D1830024  stfs f12, 0x24(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825BD0E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD0F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BD0F0 size=132
    let mut pc: u32 = 0x825BD0F0;
    'dispatch: loop {
        match pc {
            0x825BD0F0 => {
    //   block [0x825BD0F0..0x825BD174)
	// 825BD0F0: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 825BD0F4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825BD0F8: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD0FC: 91640000  stw r11, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BD100: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD104: 91440004  stw r10, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825BD108: C0050008  lfs f0, 8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BD10C: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825BD110: 8125000C  lwz r9, 0xc(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(12 as u32) ) } as u64;
	// 825BD114: 9124000C  stw r9, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 825BD118: 89050013  lbz r8, 0x13(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BD11C: 88E50010  lbz r7, 0x10(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD120: 88C50011  lbz r6, 0x11(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BD124: 88650012  lbz r3, 0x12(r5)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BD128: 98640012  stb r3, 0x12(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(18 as u32), ctx.r[3].u8 ) };
	// 825BD12C: 98C40011  stb r6, 0x11(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(17 as u32), ctx.r[6].u8 ) };
	// 825BD130: 98E40010  stb r7, 0x10(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[7].u8 ) };
	// 825BD134: 99040013  stb r8, 0x13(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825BD138: 89650017  lbz r11, 0x17(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BD13C: 89450014  lbz r10, 0x14(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD140: 89250015  lbz r9, 0x15(r5)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD144: 89050016  lbz r8, 0x16(r5)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD148: 99040016  stb r8, 0x16(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(22 as u32), ctx.r[8].u8 ) };
	// 825BD14C: 99240015  stb r9, 0x15(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 825BD150: 99440014  stb r10, 0x14(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825BD154: 99640017  stb r11, 0x17(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(23 as u32), ctx.r[11].u8 ) };
	// 825BD158: C1A50018  lfs f13, 0x18(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BD15C: D1A40018  stfs f13, 0x18(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825BD160: 80E5001C  lwz r7, 0x1c(r5)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BD164: 90E4001C  stw r7, 0x1c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825BD168: C1850020  lfs f12, 0x20(r5)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BD16C: D1840020  stfs f12, 0x20(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825BD170: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BD178(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BD178 size=2272
    let mut pc: u32 = 0x825BD178;
    'dispatch: loop {
        match pc {
            0x825BD178 => {
    //   block [0x825BD178..0x825BD20C)
	// 825BD178: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BD17C: 486EC26D  bl 0x82ca93e8
	ctx.lr = 0x825BD180;
	sub_82CA93D0(ctx, base);
	// 825BD180: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BD184: F8810298  std r4, 0x298(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(664 as u32), ctx.r[4].u64 ) };
	// 825BD188: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 825BD18C: 82C1029C  lwz r22, 0x29c(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(668 as u32) ) } as u64;
	// 825BD190: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 825BD194: F8A102A0  std r5, 0x2a0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(672 as u32), ctx.r[5].u64 ) };
	// 825BD198: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BD19C: 82A102A4  lwz r21, 0x2a4(r1)
	ctx.r[21].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(676 as u32) ) } as u64;
	// 825BD1A0: 3955FFE8  addi r10, r21, -0x18
	ctx.r[10].s64 = ctx.r[21].s64 + -24;
	// 825BD1A4: 7D36A850  subf r9, r22, r21
	ctx.r[9].s64 = ctx.r[21].s64 - ctx.r[22].s64;
	// 825BD1A8: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 825BD1AC: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825BD1B0: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BD1B4: F8810068  std r4, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[4].u64 ) };
	// 825BD1B8: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 825BD1BC: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BD1C0: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BD1C4: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BD1C8: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BD1CC: 7FEBB214  add r31, r11, r22
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[22].u64;
	// 825BD1D0: 93E1006C  stw r31, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 825BD1D4: EBC10068  ld r30, 0x68(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BD1D8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BD1DC: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BD1E0: 48001849  bl 0x825bea28
	ctx.lr = 0x825BD1E4;
	sub_825BEA28(ctx, base);
	// 825BD1E4: 393F0018  addi r9, r31, 0x18
	ctx.r[9].s64 = ctx.r[31].s64 + 24;
	// 825BD1E8: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 825BD1EC: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BD1F0: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 825BD1F4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BD1F8: 7F16F840  cmplw cr6, r22, r31
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BD1FC: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BD200: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BD204: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BD208: 40980058  bge cr6, 0x825bd260
	if !ctx.cr[6].lt {
	pc = 0x825BD260; continue 'dispatch;
	}
	pc = 0x825BD20C; continue 'dispatch;
            }
            0x825BD20C => {
    //   block [0x825BD20C..0x825BD224)
	// 825BD20C: 817EFFF8  lwz r11, -8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BD210: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD214: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BD218: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD21C: 41990008  bgt cr6, 0x825bd224
	if ctx.cr[6].gt {
	pc = 0x825BD224; continue 'dispatch;
	}
	// 825BD220: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD224; continue 'dispatch;
            }
            0x825BD224 => {
    //   block [0x825BD224..0x825BD244)
	// 825BD224: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD228: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD22C: 409A0034  bne cr6, 0x825bd260
	if !ctx.cr[6].eq {
	pc = 0x825BD260; continue 'dispatch;
	}
	// 825BD230: 817EFFF8  lwz r11, -8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BD234: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BD238: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD23C: 41990008  bgt cr6, 0x825bd244
	if ctx.cr[6].gt {
	pc = 0x825BD244; continue 'dispatch;
	}
	// 825BD240: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD244; continue 'dispatch;
            }
            0x825BD244 => {
    //   block [0x825BD244..0x825BD260)
	// 825BD244: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD24C: 409A0014  bne cr6, 0x825bd260
	if !ctx.cr[6].eq {
	pc = 0x825BD260; continue 'dispatch;
	}
	// 825BD250: 3BDEFFE8  addi r30, r30, -0x18
	ctx.r[30].s64 = ctx.r[30].s64 + -24;
	// 825BD254: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BD258: 7F16F040  cmplw cr6, r22, r30
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BD25C: 4198FFB0  blt cr6, 0x825bd20c
	if ctx.cr[6].lt {
	pc = 0x825BD20C; continue 'dispatch;
	}
	pc = 0x825BD260; continue 'dispatch;
            }
            0x825BD260 => {
    //   block [0x825BD260..0x825BD270)
	// 825BD260: 8301005C  lwz r24, 0x5c(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BD264: 7F09A840  cmplw cr6, r9, r21
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD268: 40980054  bge cr6, 0x825bd2bc
	if !ctx.cr[6].lt {
	pc = 0x825BD2BC; continue 'dispatch;
	}
	// 825BD26C: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	pc = 0x825BD270; continue 'dispatch;
            }
            0x825BD270 => {
    //   block [0x825BD270..0x825BD284)
	// 825BD270: 81580010  lwz r10, 0x10(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD274: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD278: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BD27C: 41990008  bgt cr6, 0x825bd284
	if ctx.cr[6].gt {
	pc = 0x825BD284; continue 'dispatch;
	}
	// 825BD280: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD284; continue 'dispatch;
            }
            0x825BD284 => {
    //   block [0x825BD284..0x825BD2A0)
	// 825BD284: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD28C: 409A0030  bne cr6, 0x825bd2bc
	if !ctx.cr[6].eq {
	pc = 0x825BD2BC; continue 'dispatch;
	}
	// 825BD290: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BD294: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD298: 41990008  bgt cr6, 0x825bd2a0
	if ctx.cr[6].gt {
	pc = 0x825BD2A0; continue 'dispatch;
	}
	// 825BD29C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD2A0; continue 'dispatch;
            }
            0x825BD2A0 => {
    //   block [0x825BD2A0..0x825BD2BC)
	// 825BD2A0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD2A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD2A8: 409A0014  bne cr6, 0x825bd2bc
	if !ctx.cr[6].eq {
	pc = 0x825BD2BC; continue 'dispatch;
	}
	// 825BD2AC: 3B180018  addi r24, r24, 0x18
	ctx.r[24].s64 = ctx.r[24].s64 + 24;
	// 825BD2B0: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 825BD2B4: 7F18A840  cmplw cr6, r24, r21
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD2B8: 4198FFB8  blt cr6, 0x825bd270
	if ctx.cr[6].lt {
	pc = 0x825BD270; continue 'dispatch;
	}
	pc = 0x825BD2BC; continue 'dispatch;
            }
            0x825BD2BC => {
    //   block [0x825BD2BC..0x825BD2D4)
	// 825BD2BC: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BD2C0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BD2C4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 825BD2C8: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 825BD2CC: 8341006C  lwz r26, 0x6c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BD2D0: 83210064  lwz r25, 0x64(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x825BD2D4; continue 'dispatch;
            }
            0x825BD2D4 => {
    //   block [0x825BD2D4..0x825BD2DC)
	// 825BD2D4: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD2D8: 40980158  bge cr6, 0x825bd430
	if !ctx.cr[6].lt {
	pc = 0x825BD430; continue 'dispatch;
	}
	pc = 0x825BD2DC; continue 'dispatch;
            }
            0x825BD2DC => {
    //   block [0x825BD2DC..0x825BD2F4)
	// 825BD2DC: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD2E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD2E4: 813A0010  lwz r9, 0x10(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD2E8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BD2EC: 41990008  bgt cr6, 0x825bd2f4
	if ctx.cr[6].gt {
	pc = 0x825BD2F4; continue 'dispatch;
	}
	// 825BD2F0: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD2F4; continue 'dispatch;
            }
            0x825BD2F4 => {
    //   block [0x825BD2F4..0x825BD310)
	// 825BD2F4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD2F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD2FC: 409A0124  bne cr6, 0x825bd420
	if !ctx.cr[6].eq {
	pc = 0x825BD420; continue 'dispatch;
	}
	// 825BD300: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BD304: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD308: 41990008  bgt cr6, 0x825bd310
	if ctx.cr[6].gt {
	pc = 0x825BD310; continue 'dispatch;
	}
	// 825BD30C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD310; continue 'dispatch;
            }
            0x825BD310 => {
    //   block [0x825BD310..0x825BD420)
	// 825BD310: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD314: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD318: 409A0118  bne cr6, 0x825bd430
	if !ctx.cr[6].eq {
	pc = 0x825BD430; continue 'dispatch;
	}
	// 825BD31C: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BD320: 3B180018  addi r24, r24, 0x18
	ctx.r[24].s64 = ctx.r[24].s64 + 24;
	// 825BD324: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 825BD328: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 825BD32C: F9610108  std r11, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 825BD330: 83E1010C  lwz r31, 0x10c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 825BD334: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD338: 914100F0  stw r10, 0xf0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[10].u32 ) };
	// 825BD33C: 4BEC2EFD  bl 0x82480238
	ctx.lr = 0x825BD340;
	sub_82480238(ctx, base);
	// 825BD340: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 825BD344: 386100F4  addi r3, r1, 0xf4
	ctx.r[3].s64 = ctx.r[1].s64 + 244;
	// 825BD348: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD34C: 4BF0940D  bl 0x824c6758
	ctx.lr = 0x825BD350;
	sub_824C6758(ctx, base);
	// 825BD350: 813A0000  lwz r9, 0(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD354: 811F0010  lwz r8, 0x10(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD358: 3B9A0004  addi r28, r26, 4
	ctx.r[28].s64 = ctx.r[26].s64 + 4;
	// 825BD35C: 88FF0014  lbz r7, 0x14(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD360: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BD364: 88DF0015  lbz r6, 0x15(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD368: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BD36C: 88BF0016  lbz r5, 0x16(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD370: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BD374: 91010100  stw r8, 0x100(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[8].u32 ) };
	// 825BD378: 98E10104  stb r7, 0x104(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), ctx.r[7].u8 ) };
	// 825BD37C: 98C10105  stb r6, 0x105(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(261 as u32), ctx.r[6].u8 ) };
	// 825BD380: 98A10106  stb r5, 0x106(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(262 as u32), ctx.r[5].u8 ) };
	// 825BD384: 4BF0C9F5  bl 0x824c9d78
	ctx.lr = 0x825BD388;
	sub_824C9D78(ctx, base);
	// 825BD388: 817A0010  lwz r11, 0x10(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD38C: 814100F0  lwz r10, 0xf0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) } as u64;
	// 825BD390: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 825BD394: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD398: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825BD39C: 893A0014  lbz r9, 0x14(r26)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD3A0: 993F0014  stb r9, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 825BD3A4: 891A0015  lbz r8, 0x15(r26)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD3A8: 991F0015  stb r8, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[8].u8 ) };
	// 825BD3AC: 88FA0016  lbz r7, 0x16(r26)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD3B0: 98FF0016  stb r7, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[7].u8 ) };
	// 825BD3B4: 915A0000  stw r10, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD3B8: 4BF0C9C1  bl 0x824c9d78
	ctx.lr = 0x825BD3BC;
	sub_824C9D78(ctx, base);
	// 825BD3BC: 816100F8  lwz r11, 0xf8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 825BD3C0: 38C100F4  addi r6, r1, 0xf4
	ctx.r[6].s64 = ctx.r[1].s64 + 244;
	// 825BD3C4: 81410100  lwz r10, 0x100(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) } as u64;
	// 825BD3C8: 89210104  lbz r9, 0x104(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825BD3CC: 38A100F4  addi r5, r1, 0xf4
	ctx.r[5].s64 = ctx.r[1].s64 + 244;
	// 825BD3D0: 90C10120  stw r6, 0x120(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), ctx.r[6].u32 ) };
	// 825BD3D4: 388100F4  addi r4, r1, 0xf4
	ctx.r[4].s64 = ctx.r[1].s64 + 244;
	// 825BD3D8: 89010105  lbz r8, 0x105(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(261 as u32) ) } as u64;
	// 825BD3DC: 386101C0  addi r3, r1, 0x1c0
	ctx.r[3].s64 = ctx.r[1].s64 + 448;
	// 825BD3E0: 91610124  stw r11, 0x124(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), ctx.r[11].u32 ) };
	// 825BD3E4: E8C10120  ld r6, 0x120(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(288 as u32) ) };
	// 825BD3E8: 88E10106  lbz r7, 0x106(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(262 as u32) ) } as u64;
	// 825BD3EC: 915A0010  stw r10, 0x10(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825BD3F0: 993A0014  stb r9, 0x14(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 825BD3F4: 991A0015  stb r8, 0x15(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(21 as u32), ctx.r[8].u8 ) };
	// 825BD3F8: 90A10118  stw r5, 0x118(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(280 as u32), ctx.r[5].u32 ) };
	// 825BD3FC: 98FA0016  stb r7, 0x16(r26)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[26].u32.wrapping_add(22 as u32), ctx.r[7].u8 ) };
	// 825BD400: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD404: 90A1011C  stw r5, 0x11c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(284 as u32), ctx.r[5].u32 ) };
	// 825BD408: E8A10118  ld r5, 0x118(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(280 as u32) ) };
	// 825BD40C: 4BEC2D45  bl 0x82480150
	ctx.lr = 0x825BD410;
	sub_82480150(ctx, base);
	// 825BD410: 806100F8  lwz r3, 0xf8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) } as u64;
	// 825BD414: 4BC5E925  bl 0x8221bd38
	ctx.lr = 0x825BD418;
	sub_8221BD38(ctx, base);
	// 825BD418: 92E100F8  stw r23, 0xf8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[23].u32 ) };
	// 825BD41C: 92E100FC  stw r23, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[23].u32 ) };
	pc = 0x825BD420; continue 'dispatch;
            }
            0x825BD420 => {
    //   block [0x825BD420..0x825BD430)
	// 825BD420: 3B5A0018  addi r26, r26, 0x18
	ctx.r[26].s64 = ctx.r[26].s64 + 24;
	// 825BD424: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 825BD428: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD42C: 4198FEB0  blt cr6, 0x825bd2dc
	if ctx.cr[6].lt {
	pc = 0x825BD2DC; continue 'dispatch;
	}
	pc = 0x825BD430; continue 'dispatch;
            }
            0x825BD430 => {
    //   block [0x825BD430..0x825BD43C)
	// 825BD430: 7F19B040  cmplw cr6, r25, r22
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825BD434: 409901C8  ble cr6, 0x825bd5fc
	if !ctx.cr[6].gt {
	pc = 0x825BD5FC; continue 'dispatch;
	}
	// 825BD438: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	pc = 0x825BD43C; continue 'dispatch;
            }
            0x825BD43C => {
    //   block [0x825BD43C..0x825BD458)
	// 825BD43C: 8179FFF8  lwz r11, -8(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BD440: 3BF9FFE8  addi r31, r25, -0x18
	ctx.r[31].s64 = ctx.r[25].s64 + -24;
	// 825BD444: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD448: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BD44C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD450: 41990008  bgt cr6, 0x825bd458
	if ctx.cr[6].gt {
	pc = 0x825BD458; continue 'dispatch;
	}
	// 825BD454: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD458; continue 'dispatch;
            }
            0x825BD458 => {
    //   block [0x825BD458..0x825BD478)
	// 825BD458: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD45C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD460: 409A018C  bne cr6, 0x825bd5ec
	if !ctx.cr[6].eq {
	pc = 0x825BD5EC; continue 'dispatch;
	}
	// 825BD464: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD468: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BD46C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BD470: 41990008  bgt cr6, 0x825bd478
	if ctx.cr[6].gt {
	pc = 0x825BD478; continue 'dispatch;
	}
	// 825BD474: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	pc = 0x825BD478; continue 'dispatch;
            }
            0x825BD478 => {
    //   block [0x825BD478..0x825BD51C)
	// 825BD478: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BD47C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BD480: 409A0178  bne cr6, 0x825bd5f8
	if !ctx.cr[6].eq {
	pc = 0x825BD5F8; continue 'dispatch;
	}
	// 825BD484: 3BDEFFE8  addi r30, r30, -0x18
	ctx.r[30].s64 = ctx.r[30].s64 + -24;
	// 825BD488: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825BD48C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BD490: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD494: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825BD498: 4BEC2DA1  bl 0x82480238
	ctx.lr = 0x825BD49C;
	sub_82480238(ctx, base);
	// 825BD49C: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 825BD4A0: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825BD4A4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD4A8: 4BF092B1  bl 0x824c6758
	ctx.lr = 0x825BD4AC;
	sub_824C6758(ctx, base);
	// 825BD4AC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD4B0: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD4B4: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 825BD4B8: 891E0014  lbz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD4BC: 3B7E0010  addi r27, r30, 0x10
	ctx.r[27].s64 = ctx.r[30].s64 + 16;
	// 825BD4C0: 88FE0015  lbz r7, 0x15(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD4C4: 7F1DE040  cmplw cr6, r29, r28
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BD4C8: 88DE0016  lbz r6, 0x16(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD4CC: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD4D0: 91210080  stw r9, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 825BD4D4: 99010084  stb r8, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[8].u8 ) };
	// 825BD4D8: 98E10085  stb r7, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[7].u8 ) };
	// 825BD4DC: 98C10086  stb r6, 0x86(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(134 as u32), ctx.r[6].u8 ) };
	// 825BD4E0: 419A003C  beq cr6, 0x825bd51c
	if ctx.cr[6].eq {
	pc = 0x825BD51C; continue 'dispatch;
	}
	// 825BD4E4: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD4E8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD4EC: 386101D0  addi r3, r1, 0x1d0
	ctx.r[3].s64 = ctx.r[1].s64 + 464;
	// 825BD4F0: 93A10198  stw r29, 0x198(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(408 as u32), ctx.r[29].u32 ) };
	// 825BD4F4: 93A10188  stw r29, 0x188(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(392 as u32), ctx.r[29].u32 ) };
	// 825BD4F8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD4FC: 9161019C  stw r11, 0x19c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(412 as u32), ctx.r[11].u32 ) };
	// 825BD500: E8C10198  ld r6, 0x198(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(408 as u32) ) };
	// 825BD504: 9141018C  stw r10, 0x18c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(396 as u32), ctx.r[10].u32 ) };
	// 825BD508: E8A10188  ld r5, 0x188(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(392 as u32) ) };
	// 825BD50C: 4BEC2C45  bl 0x82480150
	ctx.lr = 0x825BD510;
	sub_82480150(ctx, base);
	// 825BD510: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BD514: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BD518: 4BF09241  bl 0x824c6758
	ctx.lr = 0x825BD51C;
	sub_824C6758(ctx, base);
	pc = 0x825BD51C; continue 'dispatch;
            }
            0x825BD51C => {
    //   block [0x825BD51C..0x825BD588)
	// 825BD51C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD520: 39410074  addi r10, r1, 0x74
	ctx.r[10].s64 = ctx.r[1].s64 + 116;
	// 825BD524: 81210070  lwz r9, 0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) } as u64;
	// 825BD528: 7F1C5040  cmplw cr6, r28, r10
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BD52C: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BD530: 891F0014  lbz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD534: 991E0014  stb r8, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD538: 88FF0015  lbz r7, 0x15(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD53C: 98FE0015  stb r7, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[7].u8 ) };
	// 825BD540: 88DF0016  lbz r6, 0x16(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD544: 98DE0016  stb r6, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[6].u8 ) };
	// 825BD548: 913F0000  stw r9, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BD54C: 419A003C  beq cr6, 0x825bd588
	if ctx.cr[6].eq {
	pc = 0x825BD588; continue 'dispatch;
	}
	// 825BD550: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD554: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BD558: 938101A8  stw r28, 0x1a8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(424 as u32), ctx.r[28].u32 ) };
	// 825BD55C: 386101E0  addi r3, r1, 0x1e0
	ctx.r[3].s64 = ctx.r[1].s64 + 480;
	// 825BD560: 938101B8  stw r28, 0x1b8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(440 as u32), ctx.r[28].u32 ) };
	// 825BD564: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD568: 916101AC  stw r11, 0x1ac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(428 as u32), ctx.r[11].u32 ) };
	// 825BD56C: 914101BC  stw r10, 0x1bc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(444 as u32), ctx.r[10].u32 ) };
	// 825BD570: E8C101A8  ld r6, 0x1a8(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(424 as u32) ) };
	// 825BD574: E8A101B8  ld r5, 0x1b8(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(440 as u32) ) };
	// 825BD578: 4BEC2BD9  bl 0x82480150
	ctx.lr = 0x825BD57C;
	sub_82480150(ctx, base);
	// 825BD57C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 825BD580: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD584: 4BF091D5  bl 0x824c6758
	ctx.lr = 0x825BD588;
	sub_824C6758(ctx, base);
	pc = 0x825BD588; continue 'dispatch;
            }
            0x825BD588 => {
    //   block [0x825BD588..0x825BD5EC)
	// 825BD588: 88C10085  lbz r6, 0x85(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(133 as u32) ) } as u64;
	// 825BD58C: 39210074  addi r9, r1, 0x74
	ctx.r[9].s64 = ctx.r[1].s64 + 116;
	// 825BD590: 88A10086  lbz r5, 0x86(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(134 as u32) ) } as u64;
	// 825BD594: 38E10074  addi r7, r1, 0x74
	ctx.r[7].s64 = ctx.r[1].s64 + 116;
	// 825BD598: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 825BD59C: 38810074  addi r4, r1, 0x74
	ctx.r[4].s64 = ctx.r[1].s64 + 116;
	// 825BD5A0: 89010084  lbz r8, 0x84(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825BD5A4: 386101F0  addi r3, r1, 0x1f0
	ctx.r[3].s64 = ctx.r[1].s64 + 496;
	// 825BD5A8: 81610078  lwz r11, 0x78(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825BD5AC: 98DF0015  stb r6, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[6].u8 ) };
	// 825BD5B0: 98BF0016  stb r5, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[5].u8 ) };
	// 825BD5B4: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825BD5B8: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD5BC: 91610174  stw r11, 0x174(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(372 as u32), ctx.r[11].u32 ) };
	// 825BD5C0: 91210170  stw r9, 0x170(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(368 as u32), ctx.r[9].u32 ) };
	// 825BD5C4: 90E10168  stw r7, 0x168(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(360 as u32), ctx.r[7].u32 ) };
	// 825BD5C8: E8C10170  ld r6, 0x170(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(368 as u32) ) };
	// 825BD5CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD5D0: 9161016C  stw r11, 0x16c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(364 as u32), ctx.r[11].u32 ) };
	// 825BD5D4: E8A10168  ld r5, 0x168(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(360 as u32) ) };
	// 825BD5D8: 4BEC2B79  bl 0x82480150
	ctx.lr = 0x825BD5DC;
	sub_82480150(ctx, base);
	// 825BD5DC: 80610078  lwz r3, 0x78(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) } as u64;
	// 825BD5E0: 4BC5E759  bl 0x8221bd38
	ctx.lr = 0x825BD5E4;
	sub_8221BD38(ctx, base);
	// 825BD5E4: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 825BD5E8: 92E1007C  stw r23, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[23].u32 ) };
	pc = 0x825BD5EC; continue 'dispatch;
            }
            0x825BD5EC => {
    //   block [0x825BD5EC..0x825BD5F8)
	// 825BD5EC: 7FF9FB78  mr r25, r31
	ctx.r[25].u64 = ctx.r[31].u64;
	// 825BD5F0: 7F16C840  cmplw cr6, r22, r25
	ctx.cr[6].compare_u32(ctx.r[22].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BD5F4: 4198FE48  blt cr6, 0x825bd43c
	if ctx.cr[6].lt {
	pc = 0x825BD43C; continue 'dispatch;
	}
	pc = 0x825BD5F8; continue 'dispatch;
            }
            0x825BD5F8 => {
    //   block [0x825BD5F8..0x825BD5FC)
	// 825BD5F8: 7F19B040  cmplw cr6, r25, r22
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[22].u32, &mut ctx.xer);
	pc = 0x825BD5FC; continue 'dispatch;
            }
            0x825BD5FC => {
    //   block [0x825BD5FC..0x825BD69C)
	// 825BD5FC: 409A0300  bne cr6, 0x825bd8fc
	if !ctx.cr[6].eq {
	pc = 0x825BD8FC; continue 'dispatch;
	}
	// 825BD600: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD604: 419A0438  beq cr6, 0x825bda3c
	if ctx.cr[6].eq {
	pc = 0x825BDA3C; continue 'dispatch;
	}
	// 825BD608: 7F18D040  cmplw cr6, r24, r26
	ctx.cr[6].compare_u32(ctx.r[24].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BD60C: 419A0160  beq cr6, 0x825bd76c
	if ctx.cr[6].eq {
	pc = 0x825BD76C; continue 'dispatch;
	}
	// 825BD610: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD614: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 825BD618: 916100B0  stw r11, 0xb0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[11].u32 ) };
	// 825BD61C: 4BEC2C1D  bl 0x82480238
	ctx.lr = 0x825BD620;
	sub_82480238(ctx, base);
	// 825BD620: 3BFE0004  addi r31, r30, 4
	ctx.r[31].s64 = ctx.r[30].s64 + 4;
	// 825BD624: 386100B4  addi r3, r1, 0xb4
	ctx.r[3].s64 = ctx.r[1].s64 + 180;
	// 825BD628: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BD62C: 4BF0912D  bl 0x824c6758
	ctx.lr = 0x825BD630;
	sub_824C6758(ctx, base);
	// 825BD630: 81580000  lwz r10, 0(r24)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD634: 813E0010  lwz r9, 0x10(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD638: 3BB80004  addi r29, r24, 4
	ctx.r[29].s64 = ctx.r[24].s64 + 4;
	// 825BD63C: 891E0014  lbz r8, 0x14(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD640: 88FE0015  lbz r7, 0x15(r30)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD644: 7F1FE840  cmplw cr6, r31, r29
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BD648: 88DE0016  lbz r6, 0x16(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD64C: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD650: 912100C0  stw r9, 0xc0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 825BD654: 990100C4  stb r8, 0xc4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(196 as u32), ctx.r[8].u8 ) };
	// 825BD658: 98E100C5  stb r7, 0xc5(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(197 as u32), ctx.r[7].u8 ) };
	// 825BD65C: 98C100C6  stb r6, 0xc6(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(198 as u32), ctx.r[6].u8 ) };
	// 825BD660: 419A003C  beq cr6, 0x825bd69c
	if ctx.cr[6].eq {
	pc = 0x825BD69C; continue 'dispatch;
	}
	// 825BD664: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD668: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BD66C: 93E10130  stw r31, 0x130(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[31].u32 ) };
	// 825BD670: 38610200  addi r3, r1, 0x200
	ctx.r[3].s64 = ctx.r[1].s64 + 512;
	// 825BD674: 93E10178  stw r31, 0x178(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(376 as u32), ctx.r[31].u32 ) };
	// 825BD678: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD67C: 91610134  stw r11, 0x134(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(308 as u32), ctx.r[11].u32 ) };
	// 825BD680: 9141017C  stw r10, 0x17c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(380 as u32), ctx.r[10].u32 ) };
	// 825BD684: E8C10130  ld r6, 0x130(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	// 825BD688: E8A10178  ld r5, 0x178(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(376 as u32) ) };
	// 825BD68C: 4BEC2AC5  bl 0x82480150
	ctx.lr = 0x825BD690;
	sub_82480150(ctx, base);
	// 825BD690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD694: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BD698: 4BF090C1  bl 0x824c6758
	ctx.lr = 0x825BD69C;
	sub_824C6758(ctx, base);
	pc = 0x825BD69C; continue 'dispatch;
            }
            0x825BD69C => {
    //   block [0x825BD69C..0x825BD708)
	// 825BD69C: 81780010  lwz r11, 0x10(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD6A0: 394100B4  addi r10, r1, 0xb4
	ctx.r[10].s64 = ctx.r[1].s64 + 180;
	// 825BD6A4: 812100B0  lwz r9, 0xb0(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(176 as u32) ) } as u64;
	// 825BD6A8: 7F1D5040  cmplw cr6, r29, r10
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BD6AC: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825BD6B0: 89180014  lbz r8, 0x14(r24)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD6B4: 991E0014  stb r8, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD6B8: 88F80015  lbz r7, 0x15(r24)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD6BC: 98FE0015  stb r7, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[7].u8 ) };
	// 825BD6C0: 88D80016  lbz r6, 0x16(r24)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[24].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD6C4: 98DE0016  stb r6, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[6].u8 ) };
	// 825BD6C8: 91380000  stw r9, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BD6CC: 419A003C  beq cr6, 0x825bd708
	if ctx.cr[6].eq {
	pc = 0x825BD708; continue 'dispatch;
	}
	// 825BD6D0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD6D4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD6D8: 93A101B0  stw r29, 0x1b0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(432 as u32), ctx.r[29].u32 ) };
	// 825BD6DC: 38610210  addi r3, r1, 0x210
	ctx.r[3].s64 = ctx.r[1].s64 + 528;
	// 825BD6E0: 93A10140  stw r29, 0x140(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[29].u32 ) };
	// 825BD6E4: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD6E8: 916101B4  stw r11, 0x1b4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(436 as u32), ctx.r[11].u32 ) };
	// 825BD6EC: 91410144  stw r10, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[10].u32 ) };
	// 825BD6F0: E8C101B0  ld r6, 0x1b0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(432 as u32) ) };
	// 825BD6F4: E8A10140  ld r5, 0x140(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(320 as u32) ) };
	// 825BD6F8: 4BEC2A59  bl 0x82480150
	ctx.lr = 0x825BD6FC;
	sub_82480150(ctx, base);
	// 825BD6FC: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 825BD700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BD704: 4BF09055  bl 0x824c6758
	ctx.lr = 0x825BD708;
	sub_824C6758(ctx, base);
	pc = 0x825BD708; continue 'dispatch;
            }
            0x825BD708 => {
    //   block [0x825BD708..0x825BD76C)
	// 825BD708: 88C100C5  lbz r6, 0xc5(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(197 as u32) ) } as u64;
	// 825BD70C: 392100B4  addi r9, r1, 0xb4
	ctx.r[9].s64 = ctx.r[1].s64 + 180;
	// 825BD710: 88A100C6  lbz r5, 0xc6(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(198 as u32) ) } as u64;
	// 825BD714: 38E100B4  addi r7, r1, 0xb4
	ctx.r[7].s64 = ctx.r[1].s64 + 180;
	// 825BD718: 814100C0  lwz r10, 0xc0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) } as u64;
	// 825BD71C: 388100B4  addi r4, r1, 0xb4
	ctx.r[4].s64 = ctx.r[1].s64 + 180;
	// 825BD720: 890100C4  lbz r8, 0xc4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BD724: 38610208  addi r3, r1, 0x208
	ctx.r[3].s64 = ctx.r[1].s64 + 520;
	// 825BD728: 816100B8  lwz r11, 0xb8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825BD72C: 98D80015  stb r6, 0x15(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(21 as u32), ctx.r[6].u8 ) };
	// 825BD730: 98B80016  stb r5, 0x16(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(22 as u32), ctx.r[5].u8 ) };
	// 825BD734: 91580010  stw r10, 0x10(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825BD738: 99180014  stb r8, 0x14(r24)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[24].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD73C: 91610184  stw r11, 0x184(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 825BD740: 91210180  stw r9, 0x180(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(384 as u32), ctx.r[9].u32 ) };
	// 825BD744: 90E10150  stw r7, 0x150(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(336 as u32), ctx.r[7].u32 ) };
	// 825BD748: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD74C: E8C10180  ld r6, 0x180(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(384 as u32) ) };
	// 825BD750: 91610154  stw r11, 0x154(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(340 as u32), ctx.r[11].u32 ) };
	// 825BD754: E8A10150  ld r5, 0x150(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(336 as u32) ) };
	// 825BD758: 4BEC29F9  bl 0x82480150
	ctx.lr = 0x825BD75C;
	sub_82480150(ctx, base);
	// 825BD75C: 806100B8  lwz r3, 0xb8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(184 as u32) ) } as u64;
	// 825BD760: 4BC5E5D9  bl 0x8221bd38
	ctx.lr = 0x825BD764;
	sub_8221BD38(ctx, base);
	// 825BD764: 92E100B8  stw r23, 0xb8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[23].u32 ) };
	// 825BD768: 92E100BC  stw r23, 0xbc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(188 as u32), ctx.r[23].u32 ) };
	pc = 0x825BD76C; continue 'dispatch;
            }
            0x825BD76C => {
    //   block [0x825BD76C..0x825BD828)
	// 825BD76C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BD770: 3B180018  addi r24, r24, 0x18
	ctx.r[24].s64 = ctx.r[24].s64 + 24;
	// 825BD774: E9410068  ld r10, 0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BD778: 3B5A0018  addi r26, r26, 0x18
	ctx.r[26].s64 = ctx.r[26].s64 + 24;
	// 825BD77C: 3BDE0018  addi r30, r30, 0x18
	ctx.r[30].s64 = ctx.r[30].s64 + 24;
	// 825BD780: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 825BD784: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825BD788: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 825BD78C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BD790: F9610108  std r11, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[11].u64 ) };
	// 825BD794: 83E1010C  lwz r31, 0x10c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 825BD798: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD79C: F9410108  std r10, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[10].u64 ) };
	// 825BD7A0: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 825BD7A4: 4BEC2A95  bl 0x82480238
	ctx.lr = 0x825BD7A8;
	sub_82480238(ctx, base);
	// 825BD7A8: 3B9F0004  addi r28, r31, 4
	ctx.r[28].s64 = ctx.r[31].s64 + 4;
	// 825BD7AC: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825BD7B0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BD7B4: 4BF08FA5  bl 0x824c6758
	ctx.lr = 0x825BD7B8;
	sub_824C6758(ctx, base);
	// 825BD7B8: 83A1010C  lwz r29, 0x10c(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 825BD7BC: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD7C0: 88DF0014  lbz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD7C4: 3B7D0004  addi r27, r29, 4
	ctx.r[27].s64 = ctx.r[29].s64 + 4;
	// 825BD7C8: 88BF0015  lbz r5, 0x15(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD7CC: 889F0016  lbz r4, 0x16(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD7D0: 7F1CD840  cmplw cr6, r28, r27
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825BD7D4: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD7D8: 90E100A0  stw r7, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u32 ) };
	// 825BD7DC: 98C100A4  stb r6, 0xa4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), ctx.r[6].u8 ) };
	// 825BD7E0: 98A100A5  stb r5, 0xa5(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(165 as u32), ctx.r[5].u8 ) };
	// 825BD7E4: 988100A6  stb r4, 0xa6(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(166 as u32), ctx.r[4].u8 ) };
	// 825BD7E8: 911F0000  stw r8, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BD7EC: 419A003C  beq cr6, 0x825bd828
	if ctx.cr[6].eq {
	pc = 0x825BD828; continue 'dispatch;
	}
	// 825BD7F0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD7F4: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BD7F8: 938101A0  stw r28, 0x1a0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(416 as u32), ctx.r[28].u32 ) };
	// 825BD7FC: 386101D8  addi r3, r1, 0x1d8
	ctx.r[3].s64 = ctx.r[1].s64 + 472;
	// 825BD800: 93810160  stw r28, 0x160(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(352 as u32), ctx.r[28].u32 ) };
	// 825BD804: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD808: 916101A4  stw r11, 0x1a4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 825BD80C: 91410164  stw r10, 0x164(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(356 as u32), ctx.r[10].u32 ) };
	// 825BD810: E8C101A0  ld r6, 0x1a0(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(416 as u32) ) };
	// 825BD814: E8A10160  ld r5, 0x160(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(352 as u32) ) };
	// 825BD818: 4BEC2939  bl 0x82480150
	ctx.lr = 0x825BD81C;
	sub_82480150(ctx, base);
	// 825BD81C: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BD820: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BD824: 4BF08F35  bl 0x824c6758
	ctx.lr = 0x825BD828;
	sub_824C6758(ctx, base);
	pc = 0x825BD828; continue 'dispatch;
            }
            0x825BD828 => {
    //   block [0x825BD828..0x825BD894)
	// 825BD828: 817D0010  lwz r11, 0x10(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD82C: 39410094  addi r10, r1, 0x94
	ctx.r[10].s64 = ctx.r[1].s64 + 148;
	// 825BD830: 81210090  lwz r9, 0x90(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 825BD834: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BD838: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 825BD83C: 891D0014  lbz r8, 0x14(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD840: 991F0014  stb r8, 0x14(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD844: 88FD0015  lbz r7, 0x15(r29)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD848: 98FF0015  stb r7, 0x15(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(21 as u32), ctx.r[7].u8 ) };
	// 825BD84C: 88DD0016  lbz r6, 0x16(r29)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD850: 98DF0016  stb r6, 0x16(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(22 as u32), ctx.r[6].u8 ) };
	// 825BD854: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BD858: 419A003C  beq cr6, 0x825bd894
	if ctx.cr[6].eq {
	pc = 0x825BD894; continue 'dispatch;
	}
	// 825BD85C: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BD860: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BD864: 93610190  stw r27, 0x190(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(400 as u32), ctx.r[27].u32 ) };
	// 825BD868: 386101F8  addi r3, r1, 0x1f8
	ctx.r[3].s64 = ctx.r[1].s64 + 504;
	// 825BD86C: 93610110  stw r27, 0x110(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), ctx.r[27].u32 ) };
	// 825BD870: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD874: 91610194  stw r11, 0x194(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 825BD878: 91410114  stw r10, 0x114(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(276 as u32), ctx.r[10].u32 ) };
	// 825BD87C: E8C10190  ld r6, 0x190(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(400 as u32) ) };
	// 825BD880: E8A10110  ld r5, 0x110(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	// 825BD884: 4BEC28CD  bl 0x82480150
	ctx.lr = 0x825BD888;
	sub_82480150(ctx, base);
	// 825BD888: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 825BD88C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BD890: 4BF08EC9  bl 0x824c6758
	ctx.lr = 0x825BD894;
	sub_824C6758(ctx, base);
	pc = 0x825BD894; continue 'dispatch;
            }
            0x825BD894 => {
    //   block [0x825BD894..0x825BD8FC)
	// 825BD894: 88C100A5  lbz r6, 0xa5(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(165 as u32) ) } as u64;
	// 825BD898: 39210094  addi r9, r1, 0x94
	ctx.r[9].s64 = ctx.r[1].s64 + 148;
	// 825BD89C: 88A100A6  lbz r5, 0xa6(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(166 as u32) ) } as u64;
	// 825BD8A0: 38E10094  addi r7, r1, 0x94
	ctx.r[7].s64 = ctx.r[1].s64 + 148;
	// 825BD8A4: 814100A0  lwz r10, 0xa0(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) } as u64;
	// 825BD8A8: 38810094  addi r4, r1, 0x94
	ctx.r[4].s64 = ctx.r[1].s64 + 148;
	// 825BD8AC: 890100A4  lbz r8, 0xa4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BD8B0: 386101E8  addi r3, r1, 0x1e8
	ctx.r[3].s64 = ctx.r[1].s64 + 488;
	// 825BD8B4: 81610098  lwz r11, 0x98(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BD8B8: 98DD0015  stb r6, 0x15(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(21 as u32), ctx.r[6].u8 ) };
	// 825BD8BC: 98BD0016  stb r5, 0x16(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(22 as u32), ctx.r[5].u8 ) };
	// 825BD8C0: 915D0010  stw r10, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825BD8C4: 991D0014  stb r8, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825BD8C8: 9161012C  stw r11, 0x12c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(300 as u32), ctx.r[11].u32 ) };
	// 825BD8CC: 91210128  stw r9, 0x128(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), ctx.r[9].u32 ) };
	// 825BD8D0: 90E10138  stw r7, 0x138(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[7].u32 ) };
	// 825BD8D4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD8D8: E8C10128  ld r6, 0x128(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(296 as u32) ) };
	// 825BD8DC: 9161013C  stw r11, 0x13c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(316 as u32), ctx.r[11].u32 ) };
	// 825BD8E0: E8A10138  ld r5, 0x138(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(312 as u32) ) };
	// 825BD8E4: 4BEC286D  bl 0x82480150
	ctx.lr = 0x825BD8E8;
	sub_82480150(ctx, base);
	// 825BD8E8: 80610098  lwz r3, 0x98(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) } as u64;
	// 825BD8EC: 4BC5E44D  bl 0x8221bd38
	ctx.lr = 0x825BD8F0;
	sub_8221BD38(ctx, base);
	// 825BD8F0: 92E10098  stw r23, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[23].u32 ) };
	// 825BD8F4: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 825BD8F8: 4BFFF9DC  b 0x825bd2d4
	pc = 0x825BD2D4; continue 'dispatch;
            }
            0x825BD8FC => {
    //   block [0x825BD8FC..0x825BDA08)
	// 825BD8FC: 7F1AA840  cmplw cr6, r26, r21
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[21].u32, &mut ctx.xer);
	// 825BD900: 3B39FFE8  addi r25, r25, -0x18
	ctx.r[25].s64 = ctx.r[25].s64 + -24;
	// 825BD904: 409A011C  bne cr6, 0x825bda20
	if !ctx.cr[6].eq {
	pc = 0x825BDA20; continue 'dispatch;
	}
	// 825BD908: 3BDEFFE8  addi r30, r30, -0x18
	ctx.r[30].s64 = ctx.r[30].s64 + -24;
	// 825BD90C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BD910: 7F19F040  cmplw cr6, r25, r30
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BD914: 419A00F4  beq cr6, 0x825bda08
	if ctx.cr[6].eq {
	pc = 0x825BDA08; continue 'dispatch;
	}
	// 825BD918: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD91C: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 825BD920: 916100D0  stw r11, 0xd0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 825BD924: 4BEC2915  bl 0x82480238
	ctx.lr = 0x825BD928;
	sub_82480238(ctx, base);
	// 825BD928: 3BF90004  addi r31, r25, 4
	ctx.r[31].s64 = ctx.r[25].s64 + 4;
	// 825BD92C: 386100D4  addi r3, r1, 0xd4
	ctx.r[3].s64 = ctx.r[1].s64 + 212;
	// 825BD930: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BD934: 4BF08E25  bl 0x824c6758
	ctx.lr = 0x825BD938;
	sub_824C6758(ctx, base);
	// 825BD938: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD93C: 81390010  lwz r9, 0x10(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD940: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 825BD944: 89190014  lbz r8, 0x14(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD948: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BD94C: 88F90015  lbz r7, 0x15(r25)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD950: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BD954: 88D90016  lbz r6, 0x16(r25)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD958: 91590000  stw r10, 0(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BD95C: 912100E0  stw r9, 0xe0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[9].u32 ) };
	// 825BD960: 990100E4  stb r8, 0xe4(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(228 as u32), ctx.r[8].u8 ) };
	// 825BD964: 98E100E5  stb r7, 0xe5(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(229 as u32), ctx.r[7].u8 ) };
	// 825BD968: 98C100E6  stb r6, 0xe6(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(230 as u32), ctx.r[6].u8 ) };
	// 825BD96C: 4BF0C40D  bl 0x824c9d78
	ctx.lr = 0x825BD970;
	sub_824C9D78(ctx, base);
	// 825BD970: 80BE0010  lwz r5, 0x10(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BD974: 816100D0  lwz r11, 0xd0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) } as u64;
	// 825BD978: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 825BD97C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BD980: 90B90010  stw r5, 0x10(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 825BD984: 895E0014  lbz r10, 0x14(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BD988: 99590014  stb r10, 0x14(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825BD98C: 893E0015  lbz r9, 0x15(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BD990: 99390015  stb r9, 0x15(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(21 as u32), ctx.r[9].u8 ) };
	// 825BD994: 891E0016  lbz r8, 0x16(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BD998: 99190016  stb r8, 0x16(r25)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[25].u32.wrapping_add(22 as u32), ctx.r[8].u8 ) };
	// 825BD99C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BD9A0: 4BF0C3D9  bl 0x824c9d78
	ctx.lr = 0x825BD9A4;
	sub_824C9D78(ctx, base);
	// 825BD9A4: 816100D8  lwz r11, 0xd8(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 825BD9A8: 38E100D4  addi r7, r1, 0xd4
	ctx.r[7].s64 = ctx.r[1].s64 + 212;
	// 825BD9AC: 80A100E0  lwz r5, 0xe0(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) } as u64;
	// 825BD9B0: 38C100D4  addi r6, r1, 0xd4
	ctx.r[6].s64 = ctx.r[1].s64 + 212;
	// 825BD9B4: 894100E5  lbz r10, 0xe5(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(229 as u32) ) } as u64;
	// 825BD9B8: 90E10148  stw r7, 0x148(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[7].u32 ) };
	// 825BD9BC: 388100D4  addi r4, r1, 0xd4
	ctx.r[4].s64 = ctx.r[1].s64 + 212;
	// 825BD9C0: 90C10158  stw r6, 0x158(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(344 as u32), ctx.r[6].u32 ) };
	// 825BD9C4: 386101C8  addi r3, r1, 0x1c8
	ctx.r[3].s64 = ctx.r[1].s64 + 456;
	// 825BD9C8: 9161014C  stw r11, 0x14c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(332 as u32), ctx.r[11].u32 ) };
	// 825BD9CC: E8C10148  ld r6, 0x148(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(328 as u32) ) };
	// 825BD9D0: 892100E4  lbz r9, 0xe4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BD9D4: 890100E6  lbz r8, 0xe6(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(230 as u32) ) } as u64;
	// 825BD9D8: 90BE0010  stw r5, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 825BD9DC: 995E0015  stb r10, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 825BD9E0: 993E0014  stb r9, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 825BD9E4: 991E0016  stb r8, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[8].u8 ) };
	// 825BD9E8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BD9EC: 90E1015C  stw r7, 0x15c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(348 as u32), ctx.r[7].u32 ) };
	// 825BD9F0: E8A10158  ld r5, 0x158(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(344 as u32) ) };
	// 825BD9F4: 4BEC275D  bl 0x82480150
	ctx.lr = 0x825BD9F8;
	sub_82480150(ctx, base);
	// 825BD9F8: 806100D8  lwz r3, 0xd8(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) } as u64;
	// 825BD9FC: 4BC5E33D  bl 0x8221bd38
	ctx.lr = 0x825BDA00;
	sub_8221BD38(ctx, base);
	// 825BDA00: 92E100D8  stw r23, 0xd8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[23].u32 ) };
	// 825BDA04: 92E100DC  stw r23, 0xdc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(220 as u32), ctx.r[23].u32 ) };
	pc = 0x825BDA08; continue 'dispatch;
            }
            0x825BDA08 => {
    //   block [0x825BDA08..0x825BDA20)
	// 825BDA08: 3B18FFE8  addi r24, r24, -0x18
	ctx.r[24].s64 = ctx.r[24].s64 + -24;
	// 825BDA0C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDA10: 9301005C  stw r24, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[24].u32 ) };
	// 825BDA14: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDA18: 48001139  bl 0x825beb50
	ctx.lr = 0x825BDA1C;
	sub_825BEB50(ctx, base);
	// 825BDA1C: 4BFFF8B8  b 0x825bd2d4
	pc = 0x825BD2D4; continue 'dispatch;
            }
            0x825BDA20 => {
    //   block [0x825BDA20..0x825BDA3C)
	// 825BDA20: 3B5A0018  addi r26, r26, 0x18
	ctx.r[26].s64 = ctx.r[26].s64 + 24;
	// 825BDA24: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BDA28: 93210064  stw r25, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 825BDA2C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BDA30: 9341006C  stw r26, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[26].u32 ) };
	// 825BDA34: 4800111D  bl 0x825beb50
	ctx.lr = 0x825BDA38;
	sub_825BEB50(ctx, base);
	// 825BDA38: 4BFFF89C  b 0x825bd2d4
	pc = 0x825BD2D4; continue 'dispatch;
            }
            0x825BDA3C => {
    //   block [0x825BDA3C..0x825BDA58)
	// 825BDA3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDA40: 7E83A378  mr r3, r20
	ctx.r[3].u64 = ctx.r[20].u64;
	// 825BDA44: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDA48: F9740000  std r11, 0(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825BDA4C: F9540008  std r10, 8(r20)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[20].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825BDA50: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 825BDA54: 486EB9E4  b 0x82ca9438
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDA58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BDA58 size=276
    let mut pc: u32 = 0x825BDA58;
    'dispatch: loop {
        match pc {
            0x825BDA58 => {
    //   block [0x825BDA58..0x825BDA94)
	// 825BDA58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BDA5C: 486EB9AD  bl 0x82ca9408
	ctx.lr = 0x825BDA60;
	sub_82CA93D0(ctx, base);
	// 825BDA60: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BDA64: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BDA68: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 825BDA6C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 825BDA70: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BDA74: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BDA78: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BDA7C: 419A00E8  beq cr6, 0x825bdb64
	if ctx.cr[6].eq {
	pc = 0x825BDB64; continue 'dispatch;
	}
	// 825BDA80: 3BFE0018  addi r31, r30, 0x18
	ctx.r[31].s64 = ctx.r[30].s64 + 24;
	// 825BDA84: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BDA88: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BDA8C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BDA90: 419A00D4  beq cr6, 0x825bdb64
	if ctx.cr[6].eq {
	pc = 0x825BDB64; continue 'dispatch;
	}
	pc = 0x825BDA94; continue 'dispatch;
            }
            0x825BDA94 => {
    //   block [0x825BDA94..0x825BDAAC)
	// 825BDA94: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BDA98: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BDA9C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BDAA0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDAA4: 41990008  bgt cr6, 0x825bdaac
	if ctx.cr[6].gt {
	pc = 0x825BDAAC; continue 'dispatch;
	}
	// 825BDAA8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDAAC; continue 'dispatch;
            }
            0x825BDAAC => {
    //   block [0x825BDAAC..0x825BDAE0)
	// 825BDAAC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDAB0: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDAB4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDAB8: 419A0028  beq cr6, 0x825bdae0
	if ctx.cr[6].eq {
	pc = 0x825BDAE0; continue 'dispatch;
	}
	// 825BDABC: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 825BDAC0: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BDAC4: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BDAC8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BDACC: 419A0088  beq cr6, 0x825bdb54
	if ctx.cr[6].eq {
	pc = 0x825BDB54; continue 'dispatch;
	}
	// 825BDAD0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BDAD4: 419A0080  beq cr6, 0x825bdb54
	if ctx.cr[6].eq {
	pc = 0x825BDB54; continue 'dispatch;
	}
	// 825BDAD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BDADC: 48000068  b 0x825bdb44
	pc = 0x825BDB44; continue 'dispatch;
            }
            0x825BDAE0 => {
    //   block [0x825BDAE0..0x825BDAF0)
	// 825BDAE0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BDAE4: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BDAE8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BDAEC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x825BDAF0; continue 'dispatch;
            }
            0x825BDAF0 => {
    //   block [0x825BDAF0..0x825BDB0C)
	// 825BDAF0: 394AFFE8  addi r10, r10, -0x18
	ctx.r[10].s64 = ctx.r[10].s64 + -24;
	// 825BDAF4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BDAF8: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BDAFC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BDB00: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDB04: 41990008  bgt cr6, 0x825bdb0c
	if ctx.cr[6].gt {
	pc = 0x825BDB0C; continue 'dispatch;
	}
	// 825BDB08: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDB0C; continue 'dispatch;
            }
            0x825BDB0C => {
    //   block [0x825BDB0C..0x825BDB20)
	// 825BDB0C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDB10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDB14: 419A000C  beq cr6, 0x825bdb20
	if ctx.cr[6].eq {
	pc = 0x825BDB20; continue 'dispatch;
	}
	// 825BDB18: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDB1C: 4BFFFFD4  b 0x825bdaf0
	pc = 0x825BDAF0; continue 'dispatch;
            }
            0x825BDB20 => {
    //   block [0x825BDB20..0x825BDB44)
	// 825BDB20: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BDB24: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BDB28: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BDB2C: 419A0028  beq cr6, 0x825bdb54
	if ctx.cr[6].eq {
	pc = 0x825BDB54; continue 'dispatch;
	}
	// 825BDB30: 397F0018  addi r11, r31, 0x18
	ctx.r[11].s64 = ctx.r[31].s64 + 24;
	// 825BDB34: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BDB38: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BDB3C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BDB40: 419A0014  beq cr6, 0x825bdb54
	if ctx.cr[6].eq {
	pc = 0x825BDB54; continue 'dispatch;
	}
	pc = 0x825BDB44; continue 'dispatch;
            }
            0x825BDB44 => {
    //   block [0x825BDB44..0x825BDB54)
	// 825BDB44: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BDB48: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDB4C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BDB50: 480023E9  bl 0x825bff38
	ctx.lr = 0x825BDB54;
	sub_825BFF38(ctx, base);
	pc = 0x825BDB54; continue 'dispatch;
            }
            0x825BDB54 => {
    //   block [0x825BDB54..0x825BDB64)
	// 825BDB54: 3BFF0018  addi r31, r31, 0x18
	ctx.r[31].s64 = ctx.r[31].s64 + 24;
	// 825BDB58: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BDB5C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BDB60: 409AFF34  bne cr6, 0x825bda94
	if !ctx.cr[6].eq {
	pc = 0x825BDA94; continue 'dispatch;
	}
	pc = 0x825BDB64; continue 'dispatch;
            }
            0x825BDB64 => {
    //   block [0x825BDB64..0x825BDB6C)
	// 825BDB64: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BDB68: 486EB8F0  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BDB70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BDB70 size=1172
    let mut pc: u32 = 0x825BDB70;
    'dispatch: loop {
        match pc {
            0x825BDB70 => {
    //   block [0x825BDB70..0x825BDC00)
	// 825BDB70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BDB74: 486EB885  bl 0x82ca93f8
	ctx.lr = 0x825BDB78;
	sub_82CA93D0(ctx, base);
	// 825BDB78: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BDB7C: F88100D8  std r4, 0xd8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(216 as u32), ctx.r[4].u64 ) };
	// 825BDB80: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 825BDB84: 834100DC  lwz r26, 0xdc(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(220 as u32) ) } as u64;
	// 825BDB88: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825BDB8C: F8A100E0  std r5, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[5].u64 ) };
	// 825BDB90: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BDB94: 832100E4  lwz r25, 0xe4(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BDB98: 3959FFD8  addi r10, r25, -0x28
	ctx.r[10].s64 = ctx.r[25].s64 + -40;
	// 825BDB9C: 7D3AC850  subf r9, r26, r25
	ctx.r[9].s64 = ctx.r[25].s64 - ctx.r[26].s64;
	// 825BDBA0: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 825BDBA4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825BDBA8: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BDBAC: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BDBB0: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 825BDBB4: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BDBB8: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BDBBC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BDBC0: 548B1838  slwi r11, r4, 3
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BDBC4: 7FEBD214  add r31, r11, r26
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[26].u64;
	// 825BDBC8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BDBCC: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDBD0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BDBD4: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BDBD8: 48000FE1  bl 0x825bebb8
	ctx.lr = 0x825BDBDC;
	sub_825BEBB8(ctx, base);
	// 825BDBDC: 393F0028  addi r9, r31, 0x28
	ctx.r[9].s64 = ctx.r[31].s64 + 40;
	// 825BDBE0: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 825BDBE4: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BDBE8: 7F1AF840  cmplw cr6, r26, r31
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BDBEC: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BDBF0: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BDBF4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BDBF8: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BDBFC: 40980098  bge cr6, 0x825bdc94
	if !ctx.cr[6].lt {
	pc = 0x825BDC94; continue 'dispatch;
	}
	pc = 0x825BDC00; continue 'dispatch;
            }
            0x825BDC00 => {
    //   block [0x825BDC00..0x825BDC28)
	// 825BDC00: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDC04: 817EFFD8  lwz r11, -0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BDC08: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDC0C: 409A001C  bne cr6, 0x825bdc28
	if !ctx.cr[6].eq {
	pc = 0x825BDC28; continue 'dispatch;
	}
	// 825BDC10: 817EFFDC  lwz r11, -0x24(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BDC14: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDC18: 7CEB4010  subfc r7, r11, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[11].u32;
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BDC1C: 7CC73910  subfe r6, r7, r7
	let x = (!ctx.r[7].u32);
	let y = ctx.r[7].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDC20: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 825BDC24: 48000014  b 0x825bdc38
	pc = 0x825BDC38; continue 'dispatch;
            }
            0x825BDC28 => {
    //   block [0x825BDC28..0x825BDC34)
	// 825BDC28: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDC2C: 41980008  blt cr6, 0x825bdc34
	if ctx.cr[6].lt {
	pc = 0x825BDC34; continue 'dispatch;
	}
	// 825BDC30: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDC34; continue 'dispatch;
            }
            0x825BDC34 => {
    //   block [0x825BDC34..0x825BDC38)
	// 825BDC34: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDC38; continue 'dispatch;
            }
            0x825BDC38 => {
    //   block [0x825BDC38..0x825BDC68)
	// 825BDC38: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDC3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDC40: 409A0054  bne cr6, 0x825bdc94
	if !ctx.cr[6].eq {
	pc = 0x825BDC94; continue 'dispatch;
	}
	// 825BDC44: 817EFFD8  lwz r11, -0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BDC48: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BDC4C: 409A001C  bne cr6, 0x825bdc68
	if !ctx.cr[6].eq {
	pc = 0x825BDC68; continue 'dispatch;
	}
	// 825BDC50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDC54: 815EFFDC  lwz r10, -0x24(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BDC58: 7D0B5010  subfc r8, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BDC5C: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDC60: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825BDC64: 48000014  b 0x825bdc78
	pc = 0x825BDC78; continue 'dispatch;
            }
            0x825BDC68 => {
    //   block [0x825BDC68..0x825BDC74)
	// 825BDC68: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDC6C: 41980008  blt cr6, 0x825bdc74
	if ctx.cr[6].lt {
	pc = 0x825BDC74; continue 'dispatch;
	}
	// 825BDC70: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDC74; continue 'dispatch;
            }
            0x825BDC74 => {
    //   block [0x825BDC74..0x825BDC78)
	// 825BDC74: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDC78; continue 'dispatch;
            }
            0x825BDC78 => {
    //   block [0x825BDC78..0x825BDC94)
	// 825BDC78: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDC7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDC80: 409A0014  bne cr6, 0x825bdc94
	if !ctx.cr[6].eq {
	pc = 0x825BDC94; continue 'dispatch;
	}
	// 825BDC84: 3BDEFFD8  addi r30, r30, -0x28
	ctx.r[30].s64 = ctx.r[30].s64 + -40;
	// 825BDC88: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BDC8C: 7F1AF040  cmplw cr6, r26, r30
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BDC90: 4198FF70  blt cr6, 0x825bdc00
	if ctx.cr[6].lt {
	pc = 0x825BDC00; continue 'dispatch;
	}
	pc = 0x825BDC94; continue 'dispatch;
            }
            0x825BDC94 => {
    //   block [0x825BDC94..0x825BDCA4)
	// 825BDC94: 8361005C  lwz r27, 0x5c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BDC98: 7F09C840  cmplw cr6, r9, r25
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDC9C: 40980094  bge cr6, 0x825bdd30
	if !ctx.cr[6].lt {
	pc = 0x825BDD30; continue 'dispatch;
	}
	// 825BDCA0: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BDCA4; continue 'dispatch;
            }
            0x825BDCA4 => {
    //   block [0x825BDCA4..0x825BDCC8)
	// 825BDCA4: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDCA8: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BDCAC: 409A001C  bne cr6, 0x825bdcc8
	if !ctx.cr[6].eq {
	pc = 0x825BDCC8; continue 'dispatch;
	}
	// 825BDCB0: 817B0004  lwz r11, 4(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDCB4: 811E0004  lwz r8, 4(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDCB8: 7CEB4010  subfc r7, r11, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[11].u32;
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BDCBC: 7CC73910  subfe r6, r7, r7
	let x = (!ctx.r[7].u32);
	let y = ctx.r[7].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDCC0: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 825BDCC4: 48000014  b 0x825bdcd8
	pc = 0x825BDCD8; continue 'dispatch;
            }
            0x825BDCC8 => {
    //   block [0x825BDCC8..0x825BDCD4)
	// 825BDCC8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDCCC: 41980008  blt cr6, 0x825bdcd4
	if ctx.cr[6].lt {
	pc = 0x825BDCD4; continue 'dispatch;
	}
	// 825BDCD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDCD4; continue 'dispatch;
            }
            0x825BDCD4 => {
    //   block [0x825BDCD4..0x825BDCD8)
	// 825BDCD4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDCD8; continue 'dispatch;
            }
            0x825BDCD8 => {
    //   block [0x825BDCD8..0x825BDD04)
	// 825BDCD8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDCDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDCE0: 409A0050  bne cr6, 0x825bdd30
	if !ctx.cr[6].eq {
	pc = 0x825BDD30; continue 'dispatch;
	}
	// 825BDCE4: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDCE8: 409A001C  bne cr6, 0x825bdd04
	if !ctx.cr[6].eq {
	pc = 0x825BDD04; continue 'dispatch;
	}
	// 825BDCEC: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDCF0: 815B0004  lwz r10, 4(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDCF4: 7D0B5010  subfc r8, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BDCF8: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDCFC: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825BDD00: 48000014  b 0x825bdd14
	pc = 0x825BDD14; continue 'dispatch;
            }
            0x825BDD04 => {
    //   block [0x825BDD04..0x825BDD10)
	// 825BDD04: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDD08: 41980008  blt cr6, 0x825bdd10
	if ctx.cr[6].lt {
	pc = 0x825BDD10; continue 'dispatch;
	}
	// 825BDD0C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDD10; continue 'dispatch;
            }
            0x825BDD10 => {
    //   block [0x825BDD10..0x825BDD14)
	// 825BDD10: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDD14; continue 'dispatch;
            }
            0x825BDD14 => {
    //   block [0x825BDD14..0x825BDD30)
	// 825BDD14: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDD1C: 409A0014  bne cr6, 0x825bdd30
	if !ctx.cr[6].eq {
	pc = 0x825BDD30; continue 'dispatch;
	}
	// 825BDD20: 3B7B0028  addi r27, r27, 0x28
	ctx.r[27].s64 = ctx.r[27].s64 + 40;
	// 825BDD24: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 825BDD28: 7F1BC840  cmplw cr6, r27, r25
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDD2C: 4198FF78  blt cr6, 0x825bdca4
	if ctx.cr[6].lt {
	pc = 0x825BDCA4; continue 'dispatch;
	}
	pc = 0x825BDD30; continue 'dispatch;
            }
            0x825BDD30 => {
    //   block [0x825BDD30..0x825BDD48)
	// 825BDD30: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDD34: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDD38: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825BDD3C: F9410068  std r10, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[10].u64 ) };
	// 825BDD40: 83A10064  lwz r29, 0x64(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825BDD44: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x825BDD48; continue 'dispatch;
            }
            0x825BDD48 => {
    //   block [0x825BDD48..0x825BDD50)
	// 825BDD48: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDD4C: 409800C4  bge cr6, 0x825bde10
	if !ctx.cr[6].lt {
	pc = 0x825BDE10; continue 'dispatch;
	}
	pc = 0x825BDD50; continue 'dispatch;
            }
            0x825BDD50 => {
    //   block [0x825BDD50..0x825BDD78)
	// 825BDD50: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDD54: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDD58: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BDD5C: 409A001C  bne cr6, 0x825bdd78
	if !ctx.cr[6].eq {
	pc = 0x825BDD78; continue 'dispatch;
	}
	// 825BDD60: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDD64: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDD68: 7CEB4010  subfc r7, r11, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[11].u32;
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BDD6C: 7CC73910  subfe r6, r7, r7
	let x = (!ctx.r[7].u32);
	let y = ctx.r[7].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDD70: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 825BDD74: 48000014  b 0x825bdd88
	pc = 0x825BDD88; continue 'dispatch;
            }
            0x825BDD78 => {
    //   block [0x825BDD78..0x825BDD84)
	// 825BDD78: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDD7C: 41980008  blt cr6, 0x825bdd84
	if ctx.cr[6].lt {
	pc = 0x825BDD84; continue 'dispatch;
	}
	// 825BDD80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDD84; continue 'dispatch;
            }
            0x825BDD84 => {
    //   block [0x825BDD84..0x825BDD88)
	// 825BDD84: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDD88; continue 'dispatch;
            }
            0x825BDD88 => {
    //   block [0x825BDD88..0x825BDDB4)
	// 825BDD88: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDD8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDD90: 409A0070  bne cr6, 0x825bde00
	if !ctx.cr[6].eq {
	pc = 0x825BDE00; continue 'dispatch;
	}
	// 825BDD94: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDD98: 409A001C  bne cr6, 0x825bddb4
	if !ctx.cr[6].eq {
	pc = 0x825BDDB4; continue 'dispatch;
	}
	// 825BDD9C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDDA0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDDA4: 7D2B5010  subfc r9, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BDDA8: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDDAC: 550B07FE  clrlwi r11, r8, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825BDDB0: 48000014  b 0x825bddc4
	pc = 0x825BDDC4; continue 'dispatch;
            }
            0x825BDDB4 => {
    //   block [0x825BDDB4..0x825BDDC0)
	// 825BDDB4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDDB8: 41980008  blt cr6, 0x825bddc0
	if ctx.cr[6].lt {
	pc = 0x825BDDC0; continue 'dispatch;
	}
	// 825BDDBC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDDC0; continue 'dispatch;
            }
            0x825BDDC0 => {
    //   block [0x825BDDC0..0x825BDDC4)
	// 825BDDC0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDDC4; continue 'dispatch;
            }
            0x825BDDC4 => {
    //   block [0x825BDDC4..0x825BDE00)
	// 825BDDC4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDDC8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDDCC: 409A0044  bne cr6, 0x825bde10
	if !ctx.cr[6].eq {
	pc = 0x825BDE10; continue 'dispatch;
	}
	// 825BDDD0: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDDD4: 3B7B0028  addi r27, r27, 0x28
	ctx.r[27].s64 = ctx.r[27].s64 + 40;
	// 825BDDD8: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDDDC: 389D0004  addi r4, r29, 4
	ctx.r[4].s64 = ctx.r[29].s64 + 4;
	// 825BDDE0: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 825BDDE4: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 825BDDE8: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BDDEC: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825BDDF0: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDDF4: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDDF8: 913D0000  stw r9, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BDDFC: 48002BD5  bl 0x825c09d0
	ctx.lr = 0x825BDE00;
	sub_825C09D0(ctx, base);
	pc = 0x825BDE00; continue 'dispatch;
            }
            0x825BDE00 => {
    //   block [0x825BDE00..0x825BDE10)
	// 825BDE00: 3BBD0028  addi r29, r29, 0x28
	ctx.r[29].s64 = ctx.r[29].s64 + 40;
	// 825BDE04: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825BDE08: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDE0C: 4198FF44  blt cr6, 0x825bdd50
	if ctx.cr[6].lt {
	pc = 0x825BDD50; continue 'dispatch;
	}
	pc = 0x825BDE10; continue 'dispatch;
            }
            0x825BDE10 => {
    //   block [0x825BDE10..0x825BDE18)
	// 825BDE10: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825BDE14: 409900C0  ble cr6, 0x825bded4
	if !ctx.cr[6].gt {
	pc = 0x825BDED4; continue 'dispatch;
	}
	pc = 0x825BDE18; continue 'dispatch;
            }
            0x825BDE18 => {
    //   block [0x825BDE18..0x825BDE44)
	// 825BDE18: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDE1C: 3BFCFFD8  addi r31, r28, -0x28
	ctx.r[31].s64 = ctx.r[28].s64 + -40;
	// 825BDE20: 817CFFD8  lwz r11, -0x28(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BDE24: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BDE28: 409A001C  bne cr6, 0x825bde44
	if !ctx.cr[6].eq {
	pc = 0x825BDE44; continue 'dispatch;
	}
	// 825BDE2C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDE30: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDE34: 7D0B4810  subfc r8, r11, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[11].u32;
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 825BDE38: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDE3C: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825BDE40: 48000014  b 0x825bde54
	pc = 0x825BDE54; continue 'dispatch;
            }
            0x825BDE44 => {
    //   block [0x825BDE44..0x825BDE50)
	// 825BDE44: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDE48: 41980008  blt cr6, 0x825bde50
	if ctx.cr[6].lt {
	pc = 0x825BDE50; continue 'dispatch;
	}
	// 825BDE4C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDE50; continue 'dispatch;
            }
            0x825BDE50 => {
    //   block [0x825BDE50..0x825BDE54)
	// 825BDE50: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDE54; continue 'dispatch;
            }
            0x825BDE54 => {
    //   block [0x825BDE54..0x825BDE84)
	// 825BDE54: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDE5C: 409A0068  bne cr6, 0x825bdec4
	if !ctx.cr[6].eq {
	pc = 0x825BDEC4; continue 'dispatch;
	}
	// 825BDE60: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDE64: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BDE68: 409A001C  bne cr6, 0x825bde84
	if !ctx.cr[6].eq {
	pc = 0x825BDE84; continue 'dispatch;
	}
	// 825BDE6C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDE70: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BDE74: 7D2B5010  subfc r9, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BDE78: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BDE7C: 550B07FE  clrlwi r11, r8, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825BDE80: 48000014  b 0x825bde94
	pc = 0x825BDE94; continue 'dispatch;
            }
            0x825BDE84 => {
    //   block [0x825BDE84..0x825BDE90)
	// 825BDE84: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BDE88: 41980008  blt cr6, 0x825bde90
	if ctx.cr[6].lt {
	pc = 0x825BDE90; continue 'dispatch;
	}
	// 825BDE8C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BDE90; continue 'dispatch;
            }
            0x825BDE90 => {
    //   block [0x825BDE90..0x825BDE94)
	// 825BDE90: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BDE94; continue 'dispatch;
            }
            0x825BDE94 => {
    //   block [0x825BDE94..0x825BDEC4)
	// 825BDE94: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BDE98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BDE9C: 409A0034  bne cr6, 0x825bded0
	if !ctx.cr[6].eq {
	pc = 0x825BDED0; continue 'dispatch;
	}
	// 825BDEA0: 3BDEFFD8  addi r30, r30, -0x28
	ctx.r[30].s64 = ctx.r[30].s64 + -40;
	// 825BDEA4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDEA8: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 825BDEAC: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BDEB0: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BDEB4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDEB8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BDEBC: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDEC0: 48002B11  bl 0x825c09d0
	ctx.lr = 0x825BDEC4;
	sub_825C09D0(ctx, base);
	pc = 0x825BDEC4; continue 'dispatch;
            }
            0x825BDEC4 => {
    //   block [0x825BDEC4..0x825BDED0)
	// 825BDEC4: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BDEC8: 7F1AE040  cmplw cr6, r26, r28
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BDECC: 4198FF4C  blt cr6, 0x825bde18
	if ctx.cr[6].lt {
	pc = 0x825BDE18; continue 'dispatch;
	}
	pc = 0x825BDED0; continue 'dispatch;
            }
            0x825BDED0 => {
    //   block [0x825BDED0..0x825BDED4)
	// 825BDED0: 7F1CD040  cmplw cr6, r28, r26
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[26].u32, &mut ctx.xer);
	pc = 0x825BDED4; continue 'dispatch;
            }
            0x825BDED4 => {
    //   block [0x825BDED4..0x825BDF04)
	// 825BDED4: 409A0080  bne cr6, 0x825bdf54
	if !ctx.cr[6].eq {
	pc = 0x825BDF54; continue 'dispatch;
	}
	// 825BDED8: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDEDC: 419A010C  beq cr6, 0x825bdfe8
	if ctx.cr[6].eq {
	pc = 0x825BDFE8; continue 'dispatch;
	}
	// 825BDEE0: 7F1BE840  cmplw cr6, r27, r29
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BDEE4: 419A0020  beq cr6, 0x825bdf04
	if ctx.cr[6].eq {
	pc = 0x825BDF04; continue 'dispatch;
	}
	// 825BDEE8: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDEEC: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 825BDEF0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDEF4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BDEF8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BDEFC: 915B0000  stw r10, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDF00: 48002AD1  bl 0x825c09d0
	ctx.lr = 0x825BDF04;
	sub_825C09D0(ctx, base);
	pc = 0x825BDF04; continue 'dispatch;
            }
            0x825BDF04 => {
    //   block [0x825BDF04..0x825BDF54)
	// 825BDF04: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDF08: 3B7B0028  addi r27, r27, 0x28
	ctx.r[27].s64 = ctx.r[27].s64 + 40;
	// 825BDF0C: E9210060  ld r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BDF10: 3BBD0028  addi r29, r29, 0x28
	ctx.r[29].s64 = ctx.r[29].s64 + 40;
	// 825BDF14: 3BDE0028  addi r30, r30, 0x28
	ctx.r[30].s64 = ctx.r[30].s64 + 40;
	// 825BDF18: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 825BDF1C: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825BDF20: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BDF24: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 825BDF28: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BDF2C: 386A0004  addi r3, r10, 4
	ctx.r[3].s64 = ctx.r[10].s64 + 4;
	// 825BDF30: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 825BDF34: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BDF38: 388B0004  addi r4, r11, 4
	ctx.r[4].s64 = ctx.r[11].s64 + 4;
	// 825BDF3C: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF44: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BDF48: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BDF4C: 48002A85  bl 0x825c09d0
	ctx.lr = 0x825BDF50;
	sub_825C09D0(ctx, base);
	// 825BDF50: 4BFFFDF8  b 0x825bdd48
	pc = 0x825BDD48; continue 'dispatch;
            }
            0x825BDF54 => {
    //   block [0x825BDF54..0x825BDF8C)
	// 825BDF54: 7F1DC840  cmplw cr6, r29, r25
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BDF58: 3B9CFFD8  addi r28, r28, -0x28
	ctx.r[28].s64 = ctx.r[28].s64 + -40;
	// 825BDF5C: 409A0058  bne cr6, 0x825bdfb4
	if !ctx.cr[6].eq {
	pc = 0x825BDFB4; continue 'dispatch;
	}
	// 825BDF60: 3BDEFFD8  addi r30, r30, -0x28
	ctx.r[30].s64 = ctx.r[30].s64 + -40;
	// 825BDF64: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 825BDF68: 7F1CF040  cmplw cr6, r28, r30
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[30].u32, &mut ctx.xer);
	// 825BDF6C: 419A0020  beq cr6, 0x825bdf8c
	if ctx.cr[6].eq {
	pc = 0x825BDF8C; continue 'dispatch;
	}
	// 825BDF70: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF74: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825BDF78: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF7C: 387C0004  addi r3, r28, 4
	ctx.r[3].s64 = ctx.r[28].s64 + 4;
	// 825BDF80: 917C0000  stw r11, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BDF84: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDF88: 48002A49  bl 0x825c09d0
	ctx.lr = 0x825BDF8C;
	sub_825C09D0(ctx, base);
	pc = 0x825BDF8C; continue 'dispatch;
            }
            0x825BDF8C => {
    //   block [0x825BDF8C..0x825BDFB4)
	// 825BDF8C: 3B7BFFD8  addi r27, r27, -0x28
	ctx.r[27].s64 = ctx.r[27].s64 + -40;
	// 825BDF90: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDF94: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BDF98: 389B0004  addi r4, r27, 4
	ctx.r[4].s64 = ctx.r[27].s64 + 4;
	// 825BDF9C: 9361005C  stw r27, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[27].u32 ) };
	// 825BDFA0: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFA4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDFA8: 917B0000  stw r11, 0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BDFAC: 48002A25  bl 0x825c09d0
	ctx.lr = 0x825BDFB0;
	sub_825C09D0(ctx, base);
	// 825BDFB0: 4BFFFD98  b 0x825bdd48
	pc = 0x825BDD48; continue 'dispatch;
            }
            0x825BDFB4 => {
    //   block [0x825BDFB4..0x825BDFE8)
	// 825BDFB4: E9610060  ld r11, 0x60(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BDFB8: 3BBD0028  addi r29, r29, 0x28
	ctx.r[29].s64 = ctx.r[29].s64 + 40;
	// 825BDFBC: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFC0: 389C0004  addi r4, r28, 4
	ctx.r[4].s64 = ctx.r[28].s64 + 4;
	// 825BDFC4: 93A10064  stw r29, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[29].u32 ) };
	// 825BDFC8: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 825BDFCC: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BDFD0: 386B0004  addi r3, r11, 4
	ctx.r[3].s64 = ctx.r[11].s64 + 4;
	// 825BDFD4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BDFD8: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BDFDC: 913C0000  stw r9, 0(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825BDFE0: 480029F1  bl 0x825c09d0
	ctx.lr = 0x825BDFE4;
	sub_825C09D0(ctx, base);
	// 825BDFE4: 4BFFFD64  b 0x825bdd48
	pc = 0x825BDD48; continue 'dispatch;
            }
            0x825BDFE8 => {
    //   block [0x825BDFE8..0x825BE004)
	// 825BDFE8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BDFEC: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 825BDFF0: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BDFF4: F9780000  std r11, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825BDFF8: F9580008  std r10, 8(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825BDFFC: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BE000: 486EB448  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE008(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BE008 size=340
    let mut pc: u32 = 0x825BE008;
    'dispatch: loop {
        match pc {
            0x825BE008 => {
    //   block [0x825BE008..0x825BE044)
	// 825BE008: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE00C: 486EB3FD  bl 0x82ca9408
	ctx.lr = 0x825BE010;
	sub_82CA93D0(ctx, base);
	// 825BE010: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE014: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BE018: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 825BE01C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 825BE020: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BE024: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BE028: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE02C: 419A0128  beq cr6, 0x825be154
	if ctx.cr[6].eq {
	pc = 0x825BE154; continue 'dispatch;
	}
	// 825BE030: 3BFE0028  addi r31, r30, 0x28
	ctx.r[31].s64 = ctx.r[30].s64 + 40;
	// 825BE034: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BE038: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BE03C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE040: 419A0114  beq cr6, 0x825be154
	if ctx.cr[6].eq {
	pc = 0x825BE154; continue 'dispatch;
	}
	pc = 0x825BE044; continue 'dispatch;
            }
            0x825BE044 => {
    //   block [0x825BE044..0x825BE06C)
	// 825BE044: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE048: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE04C: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BE050: 409A001C  bne cr6, 0x825be06c
	if !ctx.cr[6].eq {
	pc = 0x825BE06C; continue 'dispatch;
	}
	// 825BE054: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE058: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE05C: 7D0B5010  subfc r8, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BE060: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BE064: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825BE068: 48000014  b 0x825be07c
	pc = 0x825BE07C; continue 'dispatch;
            }
            0x825BE06C => {
    //   block [0x825BE06C..0x825BE078)
	// 825BE06C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BE070: 41980008  blt cr6, 0x825be078
	if ctx.cr[6].lt {
	pc = 0x825BE078; continue 'dispatch;
	}
	// 825BE074: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BE078; continue 'dispatch;
            }
            0x825BE078 => {
    //   block [0x825BE078..0x825BE07C)
	// 825BE078: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BE07C; continue 'dispatch;
            }
            0x825BE07C => {
    //   block [0x825BE07C..0x825BE0B0)
	// 825BE07C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BE080: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE084: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BE088: 419A0028  beq cr6, 0x825be0b0
	if ctx.cr[6].eq {
	pc = 0x825BE0B0; continue 'dispatch;
	}
	// 825BE08C: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 825BE090: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE094: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE098: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE09C: 419A00A8  beq cr6, 0x825be144
	if ctx.cr[6].eq {
	pc = 0x825BE144; continue 'dispatch;
	}
	// 825BE0A0: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE0A4: 419A00A0  beq cr6, 0x825be144
	if ctx.cr[6].eq {
	pc = 0x825BE144; continue 'dispatch;
	}
	// 825BE0A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BE0AC: 48000088  b 0x825be134
	pc = 0x825BE134; continue 'dispatch;
            }
            0x825BE0B0 => {
    //   block [0x825BE0B0..0x825BE0C0)
	// 825BE0B0: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BE0B4: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BE0B8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE0BC: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	pc = 0x825BE0C0; continue 'dispatch;
            }
            0x825BE0C0 => {
    //   block [0x825BE0C0..0x825BE0EC)
	// 825BE0C0: 394AFFD8  addi r10, r10, -0x28
	ctx.r[10].s64 = ctx.r[10].s64 + -40;
	// 825BE0C4: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BE0C8: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE0CC: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BE0D0: 409A001C  bne cr6, 0x825be0ec
	if !ctx.cr[6].eq {
	pc = 0x825BE0EC; continue 'dispatch;
	}
	// 825BE0D4: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE0D8: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE0DC: 7CEB4010  subfc r7, r11, r8
	ctx.xer.ca = ctx.r[8].u32 >= ctx.r[11].u32;
	ctx.r[7].s64 = ctx.r[8].s64 - ctx.r[11].s64;
	// 825BE0E0: 7CC73910  subfe r6, r7, r7
	let x = (!ctx.r[7].u32);
	let y = ctx.r[7].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[6].u32 = res;
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BE0E4: 54CB07FE  clrlwi r11, r6, 0x1f
	ctx.r[11].u64 = ctx.r[6].u32 as u64 & 0x00000001u64;
	// 825BE0E8: 48000014  b 0x825be0fc
	pc = 0x825BE0FC; continue 'dispatch;
            }
            0x825BE0EC => {
    //   block [0x825BE0EC..0x825BE0F8)
	// 825BE0EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BE0F0: 41980008  blt cr6, 0x825be0f8
	if ctx.cr[6].lt {
	pc = 0x825BE0F8; continue 'dispatch;
	}
	// 825BE0F4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BE0F8; continue 'dispatch;
            }
            0x825BE0F8 => {
    //   block [0x825BE0F8..0x825BE0FC)
	// 825BE0F8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BE0FC; continue 'dispatch;
            }
            0x825BE0FC => {
    //   block [0x825BE0FC..0x825BE110)
	// 825BE0FC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BE100: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BE104: 419A000C  beq cr6, 0x825be110
	if ctx.cr[6].eq {
	pc = 0x825BE110; continue 'dispatch;
	}
	// 825BE108: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE10C: 4BFFFFB4  b 0x825be0c0
	pc = 0x825BE0C0; continue 'dispatch;
            }
            0x825BE110 => {
    //   block [0x825BE110..0x825BE134)
	// 825BE110: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BE114: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BE118: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE11C: 419A0028  beq cr6, 0x825be144
	if ctx.cr[6].eq {
	pc = 0x825BE144; continue 'dispatch;
	}
	// 825BE120: 397F0028  addi r11, r31, 0x28
	ctx.r[11].s64 = ctx.r[31].s64 + 40;
	// 825BE124: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE128: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE12C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE130: 419A0014  beq cr6, 0x825be144
	if ctx.cr[6].eq {
	pc = 0x825BE144; continue 'dispatch;
	}
	pc = 0x825BE134; continue 'dispatch;
            }
            0x825BE134 => {
    //   block [0x825BE134..0x825BE144)
	// 825BE134: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BE138: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE13C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BE140: 48002149  bl 0x825c0288
	ctx.lr = 0x825BE144;
	sub_825C0288(ctx, base);
	pc = 0x825BE144; continue 'dispatch;
            }
            0x825BE144 => {
    //   block [0x825BE144..0x825BE154)
	// 825BE144: 3BFF0028  addi r31, r31, 0x28
	ctx.r[31].s64 = ctx.r[31].s64 + 40;
	// 825BE148: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BE14C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE150: 409AFEF4  bne cr6, 0x825be044
	if !ctx.cr[6].eq {
	pc = 0x825BE044; continue 'dispatch;
	}
	pc = 0x825BE154; continue 'dispatch;
            }
            0x825BE154 => {
    //   block [0x825BE154..0x825BE15C)
	// 825BE154: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BE158: 486EB300  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BE160 size=944
    let mut pc: u32 = 0x825BE160;
    'dispatch: loop {
        match pc {
            0x825BE160 => {
    //   block [0x825BE160..0x825BE1F0)
	// 825BE160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE164: 486EB2A1  bl 0x82ca9404
	ctx.lr = 0x825BE168;
	sub_82CA93D0(ctx, base);
	// 825BE168: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE16C: F88100C8  std r4, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[4].u64 ) };
	// 825BE170: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825BE174: 83A100CC  lwz r29, 0xcc(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BE178: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BE17C: F8A100D0  std r5, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[5].u64 ) };
	// 825BE180: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BE184: 838100D4  lwz r28, 0xd4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BE188: 395CFFF4  addi r10, r28, -0xc
	ctx.r[10].s64 = ctx.r[28].s64 + -12;
	// 825BE18C: 7D3DE050  subf r9, r29, r28
	ctx.r[9].s64 = ctx.r[28].s64 - ctx.r[29].s64;
	// 825BE190: F8A10060  std r5, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[5].u64 ) };
	// 825BE194: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825BE198: 7D095BD6  divw r8, r9, r11
	ctx.r[8].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BE19C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE1A0: 7D070E70  srawi r7, r8, 1
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 1) as i64;
	// 825BE1A4: 7D670194  addze r11, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BE1A8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BE1AC: 7C8B5214  add r4, r11, r10
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BE1B0: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE1B4: 7FEBEA14  add r31, r11, r29
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825BE1B8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BE1BC: EBC10058  ld r30, 0x58(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE1C0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BE1C4: E8A10060  ld r5, 0x60(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE1C8: 48000D39  bl 0x825bef00
	ctx.lr = 0x825BE1CC;
	sub_825BEF00(ctx, base);
	// 825BE1CC: 393F000C  addi r9, r31, 0xc
	ctx.r[9].s64 = ctx.r[31].s64 + 12;
	// 825BE1D0: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 825BE1D4: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BE1D8: 7F1DF840  cmplw cr6, r29, r31
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE1DC: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BE1E0: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE1E4: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BE1E8: F8610058  std r3, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u64 ) };
	// 825BE1EC: 40980030  bge cr6, 0x825be21c
	if !ctx.cr[6].lt {
	pc = 0x825BE21C; continue 'dispatch;
	}
	pc = 0x825BE1F0; continue 'dispatch;
            }
            0x825BE1F0 => {
    //   block [0x825BE1F0..0x825BE21C)
	// 825BE1F0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE1F4: 810BFFF4  lwz r8, -0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BE1F8: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BE1FC: 41980020  blt cr6, 0x825be21c
	if ctx.cr[6].lt {
	pc = 0x825BE21C; continue 'dispatch;
	}
	// 825BE200: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BE204: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BE208: 41980014  blt cr6, 0x825be21c
	if ctx.cr[6].lt {
	pc = 0x825BE21C; continue 'dispatch;
	}
	// 825BE20C: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825BE210: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BE214: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE218: 4198FFD8  blt cr6, 0x825be1f0
	if ctx.cr[6].lt {
	pc = 0x825BE1F0; continue 'dispatch;
	}
	pc = 0x825BE21C; continue 'dispatch;
            }
            0x825BE21C => {
    //   block [0x825BE21C..0x825BE22C)
	// 825BE21C: 80E1005C  lwz r7, 0x5c(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BE220: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE224: 40980028  bge cr6, 0x825be24c
	if !ctx.cr[6].lt {
	pc = 0x825BE24C; continue 'dispatch;
	}
	// 825BE228: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BE22C; continue 'dispatch;
            }
            0x825BE22C => {
    //   block [0x825BE22C..0x825BE24C)
	// 825BE22C: 81470000  lwz r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE230: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BE234: 41990018  bgt cr6, 0x825be24c
	if ctx.cr[6].gt {
	pc = 0x825BE24C; continue 'dispatch;
	}
	// 825BE238: 41980014  blt cr6, 0x825be24c
	if ctx.cr[6].lt {
	pc = 0x825BE24C; continue 'dispatch;
	}
	// 825BE23C: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 825BE240: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825BE244: 7F07E040  cmplw cr6, r7, r28
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE248: 4198FFE4  blt cr6, 0x825be22c
	if ctx.cr[6].lt {
	pc = 0x825BE22C; continue 'dispatch;
	}
	pc = 0x825BE24C; continue 'dispatch;
            }
            0x825BE24C => {
    //   block [0x825BE24C..0x825BE264)
	// 825BE24C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE250: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE254: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 825BE258: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 825BE25C: 81210064  lwz r9, 0x64(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825BE260: 80C1006C  lwz r6, 0x6c(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	pc = 0x825BE264; continue 'dispatch;
            }
            0x825BE264 => {
    //   block [0x825BE264..0x825BE26C)
	// 825BE264: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE268: 40980074  bge cr6, 0x825be2dc
	if !ctx.cr[6].lt {
	pc = 0x825BE2DC; continue 'dispatch;
	}
	pc = 0x825BE26C; continue 'dispatch;
            }
            0x825BE26C => {
    //   block [0x825BE26C..0x825BE2CC)
	// 825BE26C: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE270: 81090000  lwz r8, 0(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE274: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BE278: 41990054  bgt cr6, 0x825be2cc
	if ctx.cr[6].gt {
	pc = 0x825BE2CC; continue 'dispatch;
	}
	// 825BE27C: 41980060  blt cr6, 0x825be2dc
	if ctx.cr[6].lt {
	pc = 0x825BE2DC; continue 'dispatch;
	}
	// 825BE280: E9010058  ld r8, 0x58(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE284: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825BE288: 80A90000  lwz r5, 0(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE28C: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 825BE290: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825BE294: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 825BE298: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BE29C: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825BE2A0: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE2A4: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE2A8: 90890000  stw r4, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825BE2AC: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE2B0: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE2B4: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BE2B8: 90690004  stw r3, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE2BC: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE2C0: 80890008  lwz r4, 8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE2C4: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825BE2C8: 90A90008  stw r5, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	pc = 0x825BE2CC; continue 'dispatch;
            }
            0x825BE2CC => {
    //   block [0x825BE2CC..0x825BE2DC)
	// 825BE2CC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BE2D0: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BE2D4: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE2D8: 4198FF94  blt cr6, 0x825be26c
	if ctx.cr[6].lt {
	pc = 0x825BE26C; continue 'dispatch;
	}
	pc = 0x825BE2DC; continue 'dispatch;
            }
            0x825BE2DC => {
    //   block [0x825BE2DC..0x825BE2E4)
	// 825BE2DC: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BE2E0: 40990074  ble cr6, 0x825be354
	if !ctx.cr[6].gt {
	pc = 0x825BE354; continue 'dispatch;
	}
	pc = 0x825BE2E4; continue 'dispatch;
            }
            0x825BE2E4 => {
    //   block [0x825BE2E4..0x825BE344)
	// 825BE2E4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE2E8: 3946FFF4  addi r10, r6, -0xc
	ctx.r[10].s64 = ctx.r[6].s64 + -12;
	// 825BE2EC: 80A6FFF4  lwz r5, -0xc(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BE2F0: 7F054040  cmplw cr6, r5, r8
	ctx.cr[6].compare_u32(ctx.r[5].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BE2F4: 41980050  blt cr6, 0x825be344
	if ctx.cr[6].lt {
	pc = 0x825BE344; continue 'dispatch;
	}
	// 825BE2F8: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE2FC: 7F082840  cmplw cr6, r8, r5
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BE300: 41980050  blt cr6, 0x825be350
	if ctx.cr[6].lt {
	pc = 0x825BE350; continue 'dispatch;
	}
	// 825BE304: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825BE308: 54A6003E  slwi r6, r5, 0
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(0);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 825BE30C: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825BE310: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BE314: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825BE318: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE31C: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BE320: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE324: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE328: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE32C: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE330: 908A0004  stw r4, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BE334: 810A0008  lwz r8, 8(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE338: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE33C: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BE340: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	pc = 0x825BE344; continue 'dispatch;
            }
            0x825BE344 => {
    //   block [0x825BE344..0x825BE350)
	// 825BE344: 7D465378  mr r6, r10
	ctx.r[6].u64 = ctx.r[10].u64;
	// 825BE348: 7F1D3040  cmplw cr6, r29, r6
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BE34C: 4198FF98  blt cr6, 0x825be2e4
	if ctx.cr[6].lt {
	pc = 0x825BE2E4; continue 'dispatch;
	}
	pc = 0x825BE350; continue 'dispatch;
            }
            0x825BE350 => {
    //   block [0x825BE350..0x825BE354)
	// 825BE350: 7F06E840  cmplw cr6, r6, r29
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[29].u32, &mut ctx.xer);
	pc = 0x825BE354; continue 'dispatch;
            }
            0x825BE354 => {
    //   block [0x825BE354..0x825BE3A0)
	// 825BE354: 409A00B8  bne cr6, 0x825be40c
	if !ctx.cr[6].eq {
	pc = 0x825BE40C; continue 'dispatch;
	}
	// 825BE358: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE35C: 419A0198  beq cr6, 0x825be4f4
	if ctx.cr[6].eq {
	pc = 0x825BE4F4; continue 'dispatch;
	}
	// 825BE360: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE364: 419A003C  beq cr6, 0x825be3a0
	if ctx.cr[6].eq {
	pc = 0x825BE3A0; continue 'dispatch;
	}
	// 825BE368: 81070000  lwz r8, 0(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE36C: 39470004  addi r10, r7, 4
	ctx.r[10].s64 = ctx.r[7].s64 + 4;
	// 825BE370: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE374: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825BE378: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BE37C: 90A70000  stw r5, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE380: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE384: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE388: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE38C: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BE390: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE394: 81070008  lwz r8, 8(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE398: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BE39C: 91470008  stw r10, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x825BE3A0; continue 'dispatch;
            }
            0x825BE3A0 => {
    //   block [0x825BE3A0..0x825BE40C)
	// 825BE3A0: E9410050  ld r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE3A4: 38E7000C  addi r7, r7, 0xc
	ctx.r[7].s64 = ctx.r[7].s64 + 12;
	// 825BE3A8: E9010060  ld r8, 0x60(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE3AC: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BE3B0: 396B000C  addi r11, r11, 0xc
	ctx.r[11].s64 = ctx.r[11].s64 + 12;
	// 825BE3B4: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825BE3B8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BE3BC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BE3C0: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 825BE3C4: F9010068  std r8, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[8].u64 ) };
	// 825BE3C8: 8141006C  lwz r10, 0x6c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BE3CC: 38AA0004  addi r5, r10, 4
	ctx.r[5].s64 = ctx.r[10].s64 + 4;
	// 825BE3D0: 81010074  lwz r8, 0x74(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825BE3D4: 80AA0000  lwz r5, 0(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE3D8: 38880004  addi r4, r8, 4
	ctx.r[4].s64 = ctx.r[8].s64 + 4;
	// 825BE3DC: 80880000  lwz r4, 0(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE3E0: 90A80000  stw r5, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE3E4: 908A0000  stw r4, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825BE3E8: 806A0004  lwz r3, 4(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE3EC: 80A80004  lwz r5, 4(r8)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE3F0: 90680004  stw r3, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE3F4: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BE3F8: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE3FC: 80880008  lwz r4, 8(r8)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE400: 90680008  stw r3, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BE404: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825BE408: 4BFFFE5C  b 0x825be264
	pc = 0x825BE264; continue 'dispatch;
            }
            0x825BE40C => {
    //   block [0x825BE40C..0x825BE460)
	// 825BE40C: 7F09E040  cmplw cr6, r9, r28
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE410: 38C6FFF4  addi r6, r6, -0xc
	ctx.r[6].s64 = ctx.r[6].s64 + -12;
	// 825BE414: 409A0090  bne cr6, 0x825be4a4
	if !ctx.cr[6].eq {
	pc = 0x825BE4A4; continue 'dispatch;
	}
	// 825BE418: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825BE41C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BE420: 7F065840  cmplw cr6, r6, r11
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE424: 419A003C  beq cr6, 0x825be460
	if ctx.cr[6].eq {
	pc = 0x825BE460; continue 'dispatch;
	}
	// 825BE428: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE42C: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825BE430: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE434: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825BE438: 91060000  stw r8, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BE43C: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE440: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE444: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE448: 90860004  stw r4, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BE44C: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE450: 81460008  lwz r10, 8(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE454: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE458: 91060008  stw r8, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BE45C: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	pc = 0x825BE460; continue 'dispatch;
            }
            0x825BE460 => {
    //   block [0x825BE460..0x825BE4A4)
	// 825BE460: 38E7FFF4  addi r7, r7, -0xc
	ctx.r[7].s64 = ctx.r[7].s64 + -12;
	// 825BE464: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE468: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825BE46C: 39470004  addi r10, r7, 4
	ctx.r[10].s64 = ctx.r[7].s64 + 4;
	// 825BE470: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825BE474: 80A70000  lwz r5, 0(r7)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE478: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE47C: 91070000  stw r8, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BE480: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE484: 80670004  lwz r3, 4(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE488: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE48C: 90870004  stw r4, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BE490: 81470008  lwz r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE494: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE498: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 825BE49C: 91070008  stw r8, 8(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BE4A0: 4BFFFDC4  b 0x825be264
	pc = 0x825BE264; continue 'dispatch;
            }
            0x825BE4A4 => {
    //   block [0x825BE4A4..0x825BE4F4)
	// 825BE4A4: E9410060  ld r10, 0x60(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE4A8: 39060004  addi r8, r6, 4
	ctx.r[8].s64 = ctx.r[6].s64 + 4;
	// 825BE4AC: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE4B0: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BE4B4: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BE4B8: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 825BE4BC: 81410074  lwz r10, 0x74(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) } as u64;
	// 825BE4C0: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825BE4C4: 808A0000  lwz r4, 0(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE4C8: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BE4CC: 90860000  stw r4, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u32 ) };
	// 825BE4D0: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE4D4: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE4D8: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BE4DC: 91060004  stw r8, 4(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BE4E0: 80AA0008  lwz r5, 8(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE4E4: 80860008  lwz r4, 8(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE4E8: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825BE4EC: 90A60008  stw r5, 8(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825BE4F0: 4BFFFD74  b 0x825be264
	pc = 0x825BE264; continue 'dispatch;
            }
            0x825BE4F4 => {
    //   block [0x825BE4F4..0x825BE510)
	// 825BE4F4: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE4F8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BE4FC: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE500: F97B0000  std r11, 0(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 825BE504: F95B0008  std r10, 8(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 825BE508: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BE50C: 486EAF48  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BE510 size=236
    let mut pc: u32 = 0x825BE510;
    'dispatch: loop {
        match pc {
            0x825BE510 => {
    //   block [0x825BE510..0x825BE54C)
	// 825BE510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE514: 486EAEF5  bl 0x82ca9408
	ctx.lr = 0x825BE518;
	sub_82CA93D0(ctx, base);
	// 825BE518: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE51C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BE520: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 825BE524: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 825BE528: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BE52C: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BE530: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE534: 419A00C0  beq cr6, 0x825be5f4
	if ctx.cr[6].eq {
	pc = 0x825BE5F4; continue 'dispatch;
	}
	// 825BE538: 3BFE000C  addi r31, r30, 0xc
	ctx.r[31].s64 = ctx.r[30].s64 + 12;
	// 825BE53C: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BE540: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BE544: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE548: 419A00AC  beq cr6, 0x825be5f4
	if ctx.cr[6].eq {
	pc = 0x825BE5F4; continue 'dispatch;
	}
	pc = 0x825BE54C; continue 'dispatch;
            }
            0x825BE54C => {
    //   block [0x825BE54C..0x825BE584)
	// 825BE54C: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE550: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE554: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE558: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE55C: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE560: 40980024  bge cr6, 0x825be584
	if !ctx.cr[6].lt {
	pc = 0x825BE584; continue 'dispatch;
	}
	// 825BE564: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 825BE568: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE56C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE570: 419A0074  beq cr6, 0x825be5e4
	if ctx.cr[6].eq {
	pc = 0x825BE5E4; continue 'dispatch;
	}
	// 825BE574: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE578: 419A006C  beq cr6, 0x825be5e4
	if ctx.cr[6].eq {
	pc = 0x825BE5E4; continue 'dispatch;
	}
	// 825BE57C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BE580: 48000054  b 0x825be5d4
	pc = 0x825BE5D4; continue 'dispatch;
            }
            0x825BE584 => {
    //   block [0x825BE584..0x825BE598)
	// 825BE584: 397FFFF4  addi r11, r31, -0xc
	ctx.r[11].s64 = ctx.r[31].s64 + -12;
	// 825BE588: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE58C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE590: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE594: 40980050  bge cr6, 0x825be5e4
	if !ctx.cr[6].lt {
	pc = 0x825BE5E4; continue 'dispatch;
	}
	pc = 0x825BE598; continue 'dispatch;
            }
            0x825BE598 => {
    //   block [0x825BE598..0x825BE5D4)
	// 825BE598: 396BFFF4  addi r11, r11, -0xc
	ctx.r[11].s64 = ctx.r[11].s64 + -12;
	// 825BE59C: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE5A0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE5A4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE5A8: F8610060  std r3, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u64 ) };
	// 825BE5AC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE5B0: 4198FFE8  blt cr6, 0x825be598
	if ctx.cr[6].lt {
	pc = 0x825BE598; continue 'dispatch;
	}
	// 825BE5B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825BE5B8: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE5BC: 419A0028  beq cr6, 0x825be5e4
	if ctx.cr[6].eq {
	pc = 0x825BE5E4; continue 'dispatch;
	}
	// 825BE5C0: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	// 825BE5C4: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE5C8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE5CC: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE5D0: 419A0014  beq cr6, 0x825be5e4
	if ctx.cr[6].eq {
	pc = 0x825BE5E4; continue 'dispatch;
	}
	pc = 0x825BE5D4; continue 'dispatch;
            }
            0x825BE5D4 => {
    //   block [0x825BE5D4..0x825BE5E4)
	// 825BE5D4: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BE5D8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE5DC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BE5E0: 48001F29  bl 0x825c0508
	ctx.lr = 0x825BE5E4;
	sub_825C0508(ctx, base);
	pc = 0x825BE5E4; continue 'dispatch;
            }
            0x825BE5E4 => {
    //   block [0x825BE5E4..0x825BE5F4)
	// 825BE5E4: 3BFF000C  addi r31, r31, 0xc
	ctx.r[31].s64 = ctx.r[31].s64 + 12;
	// 825BE5E8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BE5EC: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE5F0: 409AFF5C  bne cr6, 0x825be54c
	if !ctx.cr[6].eq {
	pc = 0x825BE54C; continue 'dispatch;
	}
	pc = 0x825BE5F4; continue 'dispatch;
            }
            0x825BE5F4 => {
    //   block [0x825BE5F4..0x825BE5FC)
	// 825BE5F4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BE5F8: 486EAE60  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE600(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BE600 size=604
    let mut pc: u32 = 0x825BE600;
    'dispatch: loop {
        match pc {
            0x825BE600 => {
    //   block [0x825BE600..0x825BE684)
	// 825BE600: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE604: 486EADF1  bl 0x82ca93f4
	ctx.lr = 0x825BE608;
	sub_82CA93D0(ctx, base);
	// 825BE608: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE60C: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 825BE610: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825BE614: F8A100F0  std r5, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[5].u64 ) };
	// 825BE618: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 825BE61C: 830100F4  lwz r24, 0xf4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 825BE620: 3978FFE0  addi r11, r24, -0x20
	ctx.r[11].s64 = ctx.r[24].s64 + -32;
	// 825BE624: F8A10068  std r5, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u64 ) };
	// 825BE628: 9161006C  stw r11, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 825BE62C: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BE630: 832100EC  lwz r25, 0xec(r1)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825BE634: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 825BE638: 7D492E70  srawi r9, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 5) as i64;
	// 825BE63C: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 825BE640: 7D280E70  srawi r8, r9, 1
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 1) as i64;
	// 825BE644: 7CE80194  addze r7, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[7].s64 = tmp.s64;
	// 825BE648: 54EB2834  slwi r11, r7, 5
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE64C: 7FEBCA14  add r31, r11, r25
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[25].u64;
	// 825BE650: 93E10064  stw r31, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[31].u32 ) };
	// 825BE654: EBC10060  ld r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE658: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BE65C: 480009CD  bl 0x825bf028
	ctx.lr = 0x825BE660;
	sub_825BF028(ctx, base);
	// 825BE660: 395F0020  addi r10, r31, 0x20
	ctx.r[10].s64 = ctx.r[31].s64 + 32;
	// 825BE664: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 825BE668: 7F19F840  cmplw cr6, r25, r31
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE66C: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 825BE670: E8C10068  ld r6, 0x68(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BE674: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BE678: 83A10054  lwz r29, 0x54(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825BE67C: F8C10058  std r6, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[6].u64 ) };
	// 825BE680: 40980034  bge cr6, 0x825be6b4
	if !ctx.cr[6].lt {
	pc = 0x825BE6B4; continue 'dispatch;
	}
	pc = 0x825BE684; continue 'dispatch;
            }
            0x825BE684 => {
    //   block [0x825BE684..0x825BE6B4)
	// 825BE684: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE688: 813DFFE0  lwz r9, -0x20(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BE68C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE690: 41980024  blt cr6, 0x825be6b4
	if ctx.cr[6].lt {
	pc = 0x825BE6B4; continue 'dispatch;
	}
	// 825BE694: 5529003E  slwi r9, r9, 0
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(0);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BE698: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE69C: 41980018  blt cr6, 0x825be6b4
	if ctx.cr[6].lt {
	pc = 0x825BE6B4; continue 'dispatch;
	}
	// 825BE6A0: 3BBDFFE0  addi r29, r29, -0x20
	ctx.r[29].s64 = ctx.r[29].s64 + -32;
	// 825BE6A4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BE6A8: 7F19E840  cmplw cr6, r25, r29
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BE6AC: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE6B0: 4198FFD4  blt cr6, 0x825be684
	if ctx.cr[6].lt {
	pc = 0x825BE684; continue 'dispatch;
	}
	pc = 0x825BE6B4; continue 'dispatch;
            }
            0x825BE6B4 => {
    //   block [0x825BE6B4..0x825BE6C4)
	// 825BE6B4: 8341005C  lwz r26, 0x5c(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825BE6B8: 7F0AC040  cmplw cr6, r10, r24
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE6BC: 40980028  bge cr6, 0x825be6e4
	if !ctx.cr[6].lt {
	pc = 0x825BE6E4; continue 'dispatch;
	}
	// 825BE6C0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825BE6C4; continue 'dispatch;
            }
            0x825BE6C4 => {
    //   block [0x825BE6C4..0x825BE6E4)
	// 825BE6C4: 817A0000  lwz r11, 0(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE6C8: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE6CC: 41990018  bgt cr6, 0x825be6e4
	if ctx.cr[6].gt {
	pc = 0x825BE6E4; continue 'dispatch;
	}
	// 825BE6D0: 41980014  blt cr6, 0x825be6e4
	if ctx.cr[6].lt {
	pc = 0x825BE6E4; continue 'dispatch;
	}
	// 825BE6D4: 3B5A0020  addi r26, r26, 0x20
	ctx.r[26].s64 = ctx.r[26].s64 + 32;
	// 825BE6D8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BE6DC: 7F1AC040  cmplw cr6, r26, r24
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE6E0: 4198FFE4  blt cr6, 0x825be6c4
	if ctx.cr[6].lt {
	pc = 0x825BE6C4; continue 'dispatch;
	}
	pc = 0x825BE6E4; continue 'dispatch;
            }
            0x825BE6E4 => {
    //   block [0x825BE6E4..0x825BE6F8)
	// 825BE6E4: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE6E8: FBC10068  std r30, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[30].u64 ) };
	// 825BE6EC: 8381006C  lwz r28, 0x6c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 825BE6F0: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 825BE6F4: 83610064  lwz r27, 0x64(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	pc = 0x825BE6F8; continue 'dispatch;
            }
            0x825BE6F8 => {
    //   block [0x825BE6F8..0x825BE700)
	// 825BE6F8: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE6FC: 4098003C  bge cr6, 0x825be738
	if !ctx.cr[6].lt {
	pc = 0x825BE738; continue 'dispatch;
	}
	pc = 0x825BE700; continue 'dispatch;
            }
            0x825BE700 => {
    //   block [0x825BE700..0x825BE728)
	// 825BE700: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE704: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE708: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE70C: 4199001C  bgt cr6, 0x825be728
	if ctx.cr[6].gt {
	pc = 0x825BE728; continue 'dispatch;
	}
	// 825BE710: 41980028  blt cr6, 0x825be738
	if ctx.cr[6].lt {
	pc = 0x825BE738; continue 'dispatch;
	}
	// 825BE714: 3B5A0020  addi r26, r26, 0x20
	ctx.r[26].s64 = ctx.r[26].s64 + 32;
	// 825BE718: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE71C: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE720: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BE724: 48000A1D  bl 0x825bf140
	ctx.lr = 0x825BE728;
	sub_825BF140(ctx, base);
	pc = 0x825BE728; continue 'dispatch;
            }
            0x825BE728 => {
    //   block [0x825BE728..0x825BE738)
	// 825BE728: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 825BE72C: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825BE730: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE734: 4198FFCC  blt cr6, 0x825be700
	if ctx.cr[6].lt {
	pc = 0x825BE700; continue 'dispatch;
	}
	pc = 0x825BE738; continue 'dispatch;
            }
            0x825BE738 => {
    //   block [0x825BE738..0x825BE740)
	// 825BE738: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825BE73C: 4099005C  ble cr6, 0x825be798
	if !ctx.cr[6].gt {
	pc = 0x825BE798; continue 'dispatch;
	}
	pc = 0x825BE740; continue 'dispatch;
            }
            0x825BE740 => {
    //   block [0x825BE740..0x825BE784)
	// 825BE740: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE744: 3BFCFFE0  addi r31, r28, -0x20
	ctx.r[31].s64 = ctx.r[28].s64 + -32;
	// 825BE748: 815CFFE0  lwz r10, -0x20(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BE74C: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE750: 41980034  blt cr6, 0x825be784
	if ctx.cr[6].lt {
	pc = 0x825BE784; continue 'dispatch;
	}
	// 825BE754: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE758: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BE75C: 41980038  blt cr6, 0x825be794
	if ctx.cr[6].lt {
	pc = 0x825BE794; continue 'dispatch;
	}
	// 825BE760: 3BBDFFE0  addi r29, r29, -0x20
	ctx.r[29].s64 = ctx.r[29].s64 + -32;
	// 825BE764: E9610068  ld r11, 0x68(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BE768: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BE76C: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	// 825BE770: 93E10074  stw r31, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[31].u32 ) };
	// 825BE774: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE778: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BE77C: E8810070  ld r4, 0x70(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 825BE780: 480009C1  bl 0x825bf140
	ctx.lr = 0x825BE784;
	sub_825BF140(ctx, base);
	pc = 0x825BE784; continue 'dispatch;
            }
            0x825BE784 => {
    //   block [0x825BE784..0x825BE794)
	// 825BE784: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BE788: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 825BE78C: 7F19E040  cmplw cr6, r25, r28
	ctx.cr[6].compare_u32(ctx.r[25].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE790: 4198FFB0  blt cr6, 0x825be740
	if ctx.cr[6].lt {
	pc = 0x825BE740; continue 'dispatch;
	}
	pc = 0x825BE794; continue 'dispatch;
            }
            0x825BE794 => {
    //   block [0x825BE794..0x825BE798)
	// 825BE794: 7F1CC840  cmplw cr6, r28, r25
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[25].u32, &mut ctx.xer);
	pc = 0x825BE798; continue 'dispatch;
            }
            0x825BE798 => {
    //   block [0x825BE798..0x825BE7B8)
	// 825BE798: 409A004C  bne cr6, 0x825be7e4
	if !ctx.cr[6].eq {
	pc = 0x825BE7E4; continue 'dispatch;
	}
	// 825BE79C: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE7A0: 419A00A4  beq cr6, 0x825be844
	if ctx.cr[6].eq {
	pc = 0x825BE844; continue 'dispatch;
	}
	// 825BE7A4: 7F1AD840  cmplw cr6, r26, r27
	ctx.cr[6].compare_u32(ctx.r[26].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825BE7A8: 419A0010  beq cr6, 0x825be7b8
	if ctx.cr[6].eq {
	pc = 0x825BE7B8; continue 'dispatch;
	}
	// 825BE7AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BE7B0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE7B4: 4800098D  bl 0x825bf140
	ctx.lr = 0x825BE7B8;
	sub_825BF140(ctx, base);
	pc = 0x825BE7B8; continue 'dispatch;
            }
            0x825BE7B8 => {
    //   block [0x825BE7B8..0x825BE7E4)
	// 825BE7B8: 3B5A0020  addi r26, r26, 0x20
	ctx.r[26].s64 = ctx.r[26].s64 + 32;
	// 825BE7BC: E8810060  ld r4, 0x60(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE7C0: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 825BE7C4: 3BBD0020  addi r29, r29, 0x20
	ctx.r[29].s64 = ctx.r[29].s64 + 32;
	// 825BE7C8: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BE7CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BE7D0: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825BE7D4: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BE7D8: 48000969  bl 0x825bf140
	ctx.lr = 0x825BE7DC;
	sub_825BF140(ctx, base);
	// 825BE7DC: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE7E0: 4BFFFF18  b 0x825be6f8
	pc = 0x825BE6F8; continue 'dispatch;
            }
            0x825BE7E4 => {
    //   block [0x825BE7E4..0x825BE814)
	// 825BE7E4: 3B9CFFE0  addi r28, r28, -0x20
	ctx.r[28].s64 = ctx.r[28].s64 + -32;
	// 825BE7E8: 7F1BC040  cmplw cr6, r27, r24
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[24].u32, &mut ctx.xer);
	// 825BE7EC: 9381006C  stw r28, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u32 ) };
	// 825BE7F0: 409A003C  bne cr6, 0x825be82c
	if !ctx.cr[6].eq {
	pc = 0x825BE82C; continue 'dispatch;
	}
	// 825BE7F4: 3BBDFFE0  addi r29, r29, -0x20
	ctx.r[29].s64 = ctx.r[29].s64 + -32;
	// 825BE7F8: 93A10054  stw r29, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[29].u32 ) };
	// 825BE7FC: 7F1CE840  cmplw cr6, r28, r29
	ctx.cr[6].compare_u32(ctx.r[28].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825BE800: EBC10050  ld r30, 0x50(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE804: 419A0010  beq cr6, 0x825be814
	if ctx.cr[6].eq {
	pc = 0x825BE814; continue 'dispatch;
	}
	// 825BE808: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BE80C: E8610068  ld r3, 0x68(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BE810: 48000931  bl 0x825bf140
	ctx.lr = 0x825BE814;
	sub_825BF140(ctx, base);
	pc = 0x825BE814; continue 'dispatch;
            }
            0x825BE814 => {
    //   block [0x825BE814..0x825BE82C)
	// 825BE814: 3B5AFFE0  addi r26, r26, -0x20
	ctx.r[26].s64 = ctx.r[26].s64 + -32;
	// 825BE818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BE81C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BE820: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE824: 4800091D  bl 0x825bf140
	ctx.lr = 0x825BE828;
	sub_825BF140(ctx, base);
	// 825BE828: 4BFFFED0  b 0x825be6f8
	pc = 0x825BE6F8; continue 'dispatch;
            }
            0x825BE82C => {
    //   block [0x825BE82C..0x825BE844)
	// 825BE82C: 3B7B0020  addi r27, r27, 0x20
	ctx.r[27].s64 = ctx.r[27].s64 + 32;
	// 825BE830: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825BE834: E8810068  ld r4, 0x68(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825BE838: 93610064  stw r27, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[27].u32 ) };
	// 825BE83C: 48000905  bl 0x825bf140
	ctx.lr = 0x825BE840;
	sub_825BF140(ctx, base);
	// 825BE840: 4BFFFEB8  b 0x825be6f8
	pc = 0x825BE6F8; continue 'dispatch;
            }
            0x825BE844 => {
    //   block [0x825BE844..0x825BE85C)
	// 825BE844: E9610058  ld r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE848: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825BE84C: FBD70000  std r30, 0(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 825BE850: F9770008  std r11, 8(r23)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[23].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 825BE854: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825BE858: 486EABEC  b 0x82ca9444
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BE860 size=212
    let mut pc: u32 = 0x825BE860;
    'dispatch: loop {
        match pc {
            0x825BE860 => {
    //   block [0x825BE860..0x825BE8A8)
	// 825BE860: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE864: 486EAB8D  bl 0x82ca93f0
	ctx.lr = 0x825BE868;
	sub_82CA93D0(ctx, base);
	// 825BE868: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE86C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BE870: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825BE874: FB8100E0  std r28, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[28].u64 ) };
	// 825BE878: F88100E8  std r4, 0xe8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(232 as u32), ctx.r[4].u64 ) };
	// 825BE87C: 816100EC  lwz r11, 0xec(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(236 as u32) ) } as u64;
	// 825BE880: 814100E4  lwz r10, 0xe4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BE884: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825BE888: 7D3D2E70  srawi r29, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[29].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 825BE88C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 825BE890: 4099009C  ble cr6, 0x825be92c
	if !ctx.cr[6].gt {
	pc = 0x825BE92C; continue 'dispatch;
	}
	// 825BE894: 7FAB0E70  srawi r11, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 825BE898: 7FCB0195  addze. r30, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[30].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BE89C: 40810090  ble 0x825be92c
	if !ctx.cr[0].gt {
	pc = 0x825BE92C; continue 'dispatch;
	}
	// 825BE8A0: 57CB2834  slwi r11, r30, 5
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BE8A4: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	pc = 0x825BE8A8; continue 'dispatch;
            }
            0x825BE8A8 => {
    //   block [0x825BE8A8..0x825BE92C)
	// 825BE8A8: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 825BE8AC: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825BE8B0: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BE8B4: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825BE8B8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BE8BC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE8C0: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BE8C4: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BE8C8: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BE8CC: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BE8D0: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825BE8D4: 8B5F0012  lbz r26, 0x12(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BE8D8: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825BE8DC: 8B3F0011  lbz r25, 0x11(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BE8E0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BE8E4: 8B1F0010  lbz r24, 0x10(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BE8E8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BE8EC: 8AFF0013  lbz r23, 0x13(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BE8F0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BE8F4: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BE8F8: 8ADF001C  lbz r22, 0x1c(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BE8FC: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BE900: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BE904: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825BE908: 9B410062  stb r26, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[26].u8 ) };
	// 825BE90C: 9B210061  stb r25, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[25].u8 ) };
	// 825BE910: 9B010060  stb r24, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[24].u8 ) };
	// 825BE914: 9AE10063  stb r23, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[23].u8 ) };
	// 825BE918: 91610068  stw r11, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 825BE91C: 9AC1006C  stb r22, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[22].u8 ) };
	// 825BE920: 48001319  bl 0x825bfc38
	ctx.lr = 0x825BE924;
	sub_825BFC38(ctx, base);
	// 825BE924: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BE928: 4199FF80  bgt cr6, 0x825be8a8
	if ctx.cr[6].gt {
	pc = 0x825BE8A8; continue 'dispatch;
	}
	pc = 0x825BE92C; continue 'dispatch;
            }
            0x825BE92C => {
    //   block [0x825BE92C..0x825BE934)
	// 825BE92C: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825BE930: 486EAB10  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BE938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BE938 size=236
    let mut pc: u32 = 0x825BE938;
    'dispatch: loop {
        match pc {
            0x825BE938 => {
    //   block [0x825BE938..0x825BE974)
	// 825BE938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BE93C: 486EAACD  bl 0x82ca9408
	ctx.lr = 0x825BE940;
	sub_82CA93D0(ctx, base);
	// 825BE940: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BE944: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BE948: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 825BE94C: F88100A8  std r4, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[4].u64 ) };
	// 825BE950: 83C100A4  lwz r30, 0xa4(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BE954: 838100AC  lwz r28, 0xac(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(172 as u32) ) } as u64;
	// 825BE958: 7F1EE040  cmplw cr6, r30, r28
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE95C: 419A00C0  beq cr6, 0x825bea1c
	if ctx.cr[6].eq {
	pc = 0x825BEA1C; continue 'dispatch;
	}
	// 825BE960: 3BFE0020  addi r31, r30, 0x20
	ctx.r[31].s64 = ctx.r[30].s64 + 32;
	// 825BE964: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BE968: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BE96C: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BE970: 419A00AC  beq cr6, 0x825bea1c
	if ctx.cr[6].eq {
	pc = 0x825BEA1C; continue 'dispatch;
	}
	pc = 0x825BE974; continue 'dispatch;
            }
            0x825BE974 => {
    //   block [0x825BE974..0x825BE9AC)
	// 825BE974: E8810050  ld r4, 0x50(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BE978: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE97C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE980: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE984: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE988: 40980024  bge cr6, 0x825be9ac
	if !ctx.cr[6].lt {
	pc = 0x825BE9AC; continue 'dispatch;
	}
	// 825BE98C: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825BE990: 7F1EF840  cmplw cr6, r30, r31
	ctx.cr[6].compare_u32(ctx.r[30].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE994: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE998: 419A0074  beq cr6, 0x825bea0c
	if ctx.cr[6].eq {
	pc = 0x825BEA0C; continue 'dispatch;
	}
	// 825BE99C: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE9A0: 419A006C  beq cr6, 0x825bea0c
	if ctx.cr[6].eq {
	pc = 0x825BEA0C; continue 'dispatch;
	}
	// 825BE9A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BE9A8: 48000054  b 0x825be9fc
	pc = 0x825BE9FC; continue 'dispatch;
            }
            0x825BE9AC => {
    //   block [0x825BE9AC..0x825BE9C0)
	// 825BE9AC: 397FFFE0  addi r11, r31, -0x20
	ctx.r[11].s64 = ctx.r[31].s64 + -32;
	// 825BE9B0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE9B4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE9B8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE9BC: 40980050  bge cr6, 0x825bea0c
	if !ctx.cr[6].lt {
	pc = 0x825BEA0C; continue 'dispatch;
	}
	pc = 0x825BE9C0; continue 'dispatch;
            }
            0x825BE9C0 => {
    //   block [0x825BE9C0..0x825BE9FC)
	// 825BE9C0: 396BFFE0  addi r11, r11, -0x20
	ctx.r[11].s64 = ctx.r[11].s64 + -32;
	// 825BE9C4: E8610058  ld r3, 0x58(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BE9C8: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE9CC: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BE9D0: F8610060  std r3, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[3].u64 ) };
	// 825BE9D4: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825BE9D8: 4198FFE8  blt cr6, 0x825be9c0
	if ctx.cr[6].lt {
	pc = 0x825BE9C0; continue 'dispatch;
	}
	// 825BE9DC: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 825BE9E0: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825BE9E4: 419A0028  beq cr6, 0x825bea0c
	if ctx.cr[6].eq {
	pc = 0x825BEA0C; continue 'dispatch;
	}
	// 825BE9E8: 397F0020  addi r11, r31, 0x20
	ctx.r[11].s64 = ctx.r[31].s64 + 32;
	// 825BE9EC: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BE9F0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BE9F4: 7F1F5840  cmplw cr6, r31, r11
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825BE9F8: 419A0014  beq cr6, 0x825bea0c
	if ctx.cr[6].eq {
	pc = 0x825BEA0C; continue 'dispatch;
	}
	pc = 0x825BE9FC; continue 'dispatch;
            }
            0x825BE9FC => {
    //   block [0x825BE9FC..0x825BEA0C)
	// 825BE9FC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 825BEA00: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEA04: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 825BEA08: 48001DC1  bl 0x825c07c8
	ctx.lr = 0x825BEA0C;
	sub_825C07C8(ctx, base);
	pc = 0x825BEA0C; continue 'dispatch;
            }
            0x825BEA0C => {
    //   block [0x825BEA0C..0x825BEA1C)
	// 825BEA0C: 3BFF0020  addi r31, r31, 0x20
	ctx.r[31].s64 = ctx.r[31].s64 + 32;
	// 825BEA10: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 825BEA14: 7F1FE040  cmplw cr6, r31, r28
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[28].u32, &mut ctx.xer);
	// 825BEA18: 409AFF5C  bne cr6, 0x825be974
	if !ctx.cr[6].eq {
	pc = 0x825BE974; continue 'dispatch;
	}
	pc = 0x825BEA1C; continue 'dispatch;
            }
            0x825BEA1C => {
    //   block [0x825BEA1C..0x825BEA24)
	// 825BEA1C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825BEA20: 486EAA38  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEA28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEA28 size=296
    let mut pc: u32 = 0x825BEA28;
    'dispatch: loop {
        match pc {
            0x825BEA28 => {
    //   block [0x825BEA28..0x825BEB3C)
	// 825BEA28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEA2C: 486EA9CD  bl 0x82ca93f8
	ctx.lr = 0x825BEA30;
	sub_82CA93D0(ctx, base);
	// 825BEA30: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEA34: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BEA38: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825BEA3C: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 825BEA40: 39600018  li r11, 0x18
	ctx.r[11].s64 = 24;
	// 825BEA44: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 825BEA48: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BEA4C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BEA50: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BEA54: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BEA58: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 825BEA5C: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BEA60: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 825BEA64: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 825BEA68: 409900D4  ble cr6, 0x825beb3c
	if !ctx.cr[6].gt {
	pc = 0x825BEB3C; continue 'dispatch;
	}
	// 825BEA6C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BEA70: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BEA74: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 825BEA78: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825BEA7C: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BEA80: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BEA84: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BEA88: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BEA8C: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BEA90: 54FF1838  slwi r31, r7, 3
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BEA94: 54B92036  slwi r25, r5, 4
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825BEA98: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 825BEA9C: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 825BEAA0: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BEAA4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825BEAA8: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEAAC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEAB0: 48000861  bl 0x825bf310
	ctx.lr = 0x825BEAB4;
	sub_825BF310(ctx, base);
	// 825BEAB4: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BEAB8: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEABC: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 825BEAC0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEAC4: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BEAC8: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BEACC: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825BEAD0: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 825BEAD4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BEAD8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEADC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEAE0: 48000831  bl 0x825bf310
	ctx.lr = 0x825BEAE4;
	sub_825BF310(ctx, base);
	// 825BEAE4: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 825BEAE8: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BEAEC: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825BEAF0: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825BEAF4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEAF8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BEAFC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BEB00: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BEB04: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEB08: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEB0C: 48000805  bl 0x825bf310
	ctx.lr = 0x825BEB10;
	sub_825BF310(ctx, base);
	// 825BEB10: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BEB14: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEB18: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BEB1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEB20: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BEB24: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 825BEB28: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEB2C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEB30: 480007E1  bl 0x825bf310
	ctx.lr = 0x825BEB34;
	sub_825BF310(ctx, base);
	// 825BEB34: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BEB38: 486EA910  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BEB3C => {
    //   block [0x825BEB3C..0x825BEB50)
	// 825BEB3C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BEB40: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEB44: 480007CD  bl 0x825bf310
	ctx.lr = 0x825BEB48;
	sub_825BF310(ctx, base);
	// 825BEB48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BEB4C: 486EA8FC  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEB50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BEB50 size=104
    let mut pc: u32 = 0x825BEB50;
    'dispatch: loop {
        match pc {
            0x825BEB50 => {
    //   block [0x825BEB50..0x825BEBB8)
	// 825BEB50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEB54: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BEB58: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BEB5C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BEB60: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEB64: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 825BEB68: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825BEB6C: 83E10094  lwz r31, 0x94(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825BEB70: F8810098  std r4, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[4].u64 ) };
	// 825BEB74: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BEB78: 4BF084D9  bl 0x824c7050
	ctx.lr = 0x825BEB7C;
	sub_824C7050(ctx, base);
	// 825BEB7C: 83C1009C  lwz r30, 0x9c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BEB80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BEB84: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BEB88: 4BF0B181  bl 0x824c9d08
	ctx.lr = 0x825BEB8C;
	sub_824C9D08(ctx, base);
	// 825BEB8C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825BEB90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BEB94: 4BF0B175  bl 0x824c9d08
	ctx.lr = 0x825BEB98;
	sub_824C9D08(ctx, base);
	// 825BEB98: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 825BEB9C: 4BEC13DD  bl 0x8247ff78
	ctx.lr = 0x825BEBA0;
	sub_8247FF78(ctx, base);
	// 825BEBA0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BEBA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BEBA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BEBAC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BEBB0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BEBB4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEBB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEBB8 size=296
    let mut pc: u32 = 0x825BEBB8;
    'dispatch: loop {
        match pc {
            0x825BEBB8 => {
    //   block [0x825BEBB8..0x825BECCC)
	// 825BEBB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEBBC: 486EA83D  bl 0x82ca93f8
	ctx.lr = 0x825BEBC0;
	sub_82CA93D0(ctx, base);
	// 825BEBC0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEBC4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BEBC8: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825BEBCC: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 825BEBD0: 39600028  li r11, 0x28
	ctx.r[11].s64 = 40;
	// 825BEBD4: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 825BEBD8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BEBDC: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BEBE0: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BEBE4: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BEBE8: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 825BEBEC: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BEBF0: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 825BEBF4: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 825BEBF8: 409900D4  ble cr6, 0x825beccc
	if !ctx.cr[6].gt {
	pc = 0x825BECCC; continue 'dispatch;
	}
	// 825BEBFC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BEC00: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BEC04: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 825BEC08: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825BEC0C: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BEC10: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BEC14: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BEC18: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BEC1C: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BEC20: 54FF1838  slwi r31, r7, 3
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BEC24: 54B92036  slwi r25, r5, 4
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(4);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825BEC28: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 825BEC2C: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 825BEC30: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BEC34: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825BEC38: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEC3C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEC40: 48000951  bl 0x825bf590
	ctx.lr = 0x825BEC44;
	sub_825BF590(ctx, base);
	// 825BEC44: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BEC48: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEC4C: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 825BEC50: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEC54: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BEC58: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BEC5C: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825BEC60: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 825BEC64: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BEC68: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEC6C: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEC70: 48000921  bl 0x825bf590
	ctx.lr = 0x825BEC74;
	sub_825BF590(ctx, base);
	// 825BEC74: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 825BEC78: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BEC7C: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825BEC80: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825BEC84: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEC88: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BEC8C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BEC90: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BEC94: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEC98: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEC9C: 480008F5  bl 0x825bf590
	ctx.lr = 0x825BECA0;
	sub_825BF590(ctx, base);
	// 825BECA0: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BECA4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BECA8: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BECAC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BECB0: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BECB4: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 825BECB8: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BECBC: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BECC0: 480008D1  bl 0x825bf590
	ctx.lr = 0x825BECC4;
	sub_825BF590(ctx, base);
	// 825BECC4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BECC8: 486EA780  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BECCC => {
    //   block [0x825BECCC..0x825BECE0)
	// 825BECCC: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BECD0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BECD4: 480008BD  bl 0x825bf590
	ctx.lr = 0x825BECD8;
	sub_825BF590(ctx, base);
	// 825BECD8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BECDC: 486EA76C  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BECE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BECE0 size=256
    let mut pc: u32 = 0x825BECE0;
    'dispatch: loop {
        match pc {
            0x825BECE0 => {
    //   block [0x825BECE0..0x825BED2C)
	// 825BECE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BECE4: 486EA6FD  bl 0x82ca93e0
	ctx.lr = 0x825BECE8;
	sub_82CA93D0(ctx, base);
	// 825BECE8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BECEC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825BECF0: 39200028  li r9, 0x28
	ctx.r[9].s64 = 40;
	// 825BECF4: FB810100  std r28, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[28].u64 ) };
	// 825BECF8: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 825BECFC: F8810108  std r4, 0x108(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), ctx.r[4].u64 ) };
	// 825BED00: 8141010C  lwz r10, 0x10c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(268 as u32) ) } as u64;
	// 825BED04: 81610104  lwz r11, 0x104(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825BED08: 7D0B5050  subf r8, r11, r10
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BED0C: 7FA84BD6  divw r29, r8, r9
	ctx.r[29].s32 = ctx.r[8].s32 / ctx.r[9].s32;
	// 825BED10: 7FA70E70  srawi r7, r29, 1
	ctx.xer.ca = (ctx.r[29].s32 < 0) && ((ctx.r[29].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[29].s32 >> 1) as i64;
	// 825BED14: 7FC70195  addze. r30, r7
	tmp.s64 = ctx.r[7].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[7].u32);
	ctx.r[30].s64 = tmp.s64;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BED18: 408100C0  ble 0x825bedd8
	if !ctx.cr[0].gt {
	pc = 0x825BEDD8; continue 'dispatch;
	}
	// 825BED1C: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BED20: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BED24: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BED28: 7FEA5A14  add r31, r10, r11
	ctx.r[31].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x825BED2C; continue 'dispatch;
            }
            0x825BED2C => {
    //   block [0x825BED2C..0x825BEDD8)
	// 825BED2C: 3BFFFFD8  addi r31, r31, -0x28
	ctx.r[31].s64 = ctx.r[31].s64 + -40;
	// 825BED30: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 825BED34: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BED38: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825BED3C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BED40: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BED44: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BED48: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BED4C: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BED50: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BED54: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BED58: 835F0010  lwz r26, 0x10(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BED5C: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825BED60: 8B3F0016  lbz r25, 0x16(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BED64: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825BED68: 8B1F0015  lbz r24, 0x15(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BED6C: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825BED70: 8AFF0014  lbz r23, 0x14(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BED74: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BED78: 8ADF0017  lbz r22, 0x17(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BED7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BED80: 8ABF001A  lbz r21, 0x1a(r31)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BED84: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 825BED88: 897F0019  lbz r11, 0x19(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BED8C: 8A9F0018  lbz r20, 0x18(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BED90: 8A7F001B  lbz r19, 0x1b(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BED94: 825F0020  lwz r18, 0x20(r31)
	ctx.r[18].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BED98: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BED9C: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BEDA0: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825BEDA4: 93410060  stw r26, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[26].u32 ) };
	// 825BEDA8: 9B210066  stb r25, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[25].u8 ) };
	// 825BEDAC: 9B010065  stb r24, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[24].u8 ) };
	// 825BEDB0: 9AE10064  stb r23, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[23].u8 ) };
	// 825BEDB4: 9AC10067  stb r22, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[22].u8 ) };
	// 825BEDB8: 9AA1006A  stb r21, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[21].u8 ) };
	// 825BEDBC: 99610069  stb r11, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[11].u8 ) };
	// 825BEDC0: 9A810068  stb r20, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[20].u8 ) };
	// 825BEDC4: 9A61006B  stb r19, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[19].u8 ) };
	// 825BEDC8: 92410070  stw r18, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[18].u32 ) };
	// 825BEDCC: 4800092D  bl 0x825bf6f8
	ctx.lr = 0x825BEDD0;
	sub_825BF6F8(ctx, base);
	// 825BEDD0: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825BEDD4: 4199FF58  bgt cr6, 0x825bed2c
	if ctx.cr[6].gt {
	pc = 0x825BED2C; continue 'dispatch;
	}
	pc = 0x825BEDD8; continue 'dispatch;
            }
            0x825BEDD8 => {
    //   block [0x825BEDD8..0x825BEDE0)
	// 825BEDD8: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825BEDDC: 486EA654  b 0x82ca9430
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEDE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEDE0 size=284
    let mut pc: u32 = 0x825BEDE0;
    'dispatch: loop {
        match pc {
            0x825BEDE0 => {
    //   block [0x825BEDE0..0x825BEE24)
	// 825BEDE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEDE4: 486EA5ED  bl 0x82ca93d0
	ctx.lr = 0x825BEDE8;
	sub_82CA93D0(ctx, base);
	// 825BEDE8: DBA1FF50  stfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.f[29].u64 ) };
	// 825BEDEC: DBC1FF58  stfd f30, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.f[30].u64 ) };
	// 825BEDF0: DBE1FF60  stfd f31, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 825BEDF4: 9421FED0  stwu r1, -0x130(r1)
	ea = ctx.r[1].u32.wrapping_add(-304 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEDF8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BEDFC: 98A10157  stb r5, 0x157(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(343 as u32), ctx.r[5].u8 ) };
	// 825BEE00: 3B800028  li r28, 0x28
	ctx.r[28].s64 = 40;
	// 825BEE04: FB610140  std r27, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[27].u64 ) };
	// 825BEE08: F8810148  std r4, 0x148(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(328 as u32), ctx.r[4].u64 ) };
	// 825BEE0C: 83A10144  lwz r29, 0x144(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 825BEE10: 83C1014C  lwz r30, 0x14c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(332 as u32) ) } as u64;
	// 825BEE14: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 825BEE18: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BEE1C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BEE20: 409900C8  ble cr6, 0x825beee8
	if !ctx.cr[6].gt {
	pc = 0x825BEEE8; continue 'dispatch;
	}
	pc = 0x825BEE24; continue 'dispatch;
            }
            0x825BEE24 => {
    //   block [0x825BEE24..0x825BEEE8)
	// 825BEE24: 3BFEFFD8  addi r31, r30, -0x28
	ctx.r[31].s64 = ctx.r[30].s64 + -40;
	// 825BEE28: 835EFFD8  lwz r26, -0x28(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BEE2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEE30: C3FEFFE4  lfs f31, -0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-28 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 825BEE34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BEE38: 833EFFDC  lwz r25, -0x24(r30)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BEE3C: C3DEFFF4  lfs f30, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 825BEE40: 831EFFE0  lwz r24, -0x20(r30)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BEE44: C3BEFFFC  lfs f29, -4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 825BEE48: 82FEFFE8  lwz r23, -0x18(r30)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825BEE4C: 8ADEFFEE  lbz r22, -0x12(r30)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-18 as u32) ) } as u64;
	// 825BEE50: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BEE54: 8ABEFFED  lbz r21, -0x13(r30)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-19 as u32) ) } as u64;
	// 825BEE58: 8A9EFFEC  lbz r20, -0x14(r30)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825BEE5C: 8A7EFFEF  lbz r19, -0x11(r30)
	ctx.r[19].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-17 as u32) ) } as u64;
	// 825BEE60: 8A5EFFF2  lbz r18, -0xe(r30)
	ctx.r[18].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-14 as u32) ) } as u64;
	// 825BEE64: 8A3EFFF1  lbz r17, -0xf(r30)
	ctx.r[17].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-15 as u32) ) } as u64;
	// 825BEE68: 8A1EFFF0  lbz r16, -0x10(r30)
	ctx.r[16].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BEE6C: 89FEFFF3  lbz r15, -0xd(r30)
	ctx.r[15].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(-13 as u32) ) } as u64;
	// 825BEE70: 81DEFFF8  lwz r14, -8(r30)
	ctx.r[14].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BEE74: 4BFFE1E5  bl 0x825bd058
	ctx.lr = 0x825BEE78;
	sub_825BD058(ctx, base);
	// 825BEE78: D3E1005C  stfs f31, 0x5c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825BEE7C: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 825BEE80: D3C1006C  stfs f30, 0x6c(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825BEE84: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 825BEE88: D3A10074  stfs f29, 0x74(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825BEE8C: 93010058  stw r24, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u32 ) };
	// 825BEE90: 92E10060  stw r23, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u32 ) };
	// 825BEE94: 7D7DF850  subf r11, r29, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[29].s64;
	// 825BEE98: 9AC10066  stb r22, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[22].u8 ) };
	// 825BEE9C: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BEEA0: 9AA10065  stb r21, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[21].u8 ) };
	// 825BEEA4: 7CABE3D6  divw r5, r11, r28
	ctx.r[5].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BEEA8: 9A810064  stb r20, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[20].u8 ) };
	// 825BEEAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825BEEB0: 9A610067  stb r19, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[19].u8 ) };
	// 825BEEB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 825BEEB8: 9A41006A  stb r18, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[18].u8 ) };
	// 825BEEBC: 9A210069  stb r17, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[17].u8 ) };
	// 825BEEC0: 9A010068  stb r16, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[16].u8 ) };
	// 825BEEC4: 99E1006B  stb r15, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[15].u8 ) };
	// 825BEEC8: 91C10070  stw r14, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[14].u32 ) };
	// 825BEECC: 88E10157  lbz r7, 0x157(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[1].u32.wrapping_add(343 as u32) ) } as u64;
	// 825BEED0: 48000829  bl 0x825bf6f8
	ctx.lr = 0x825BEED4;
	sub_825BF6F8(ctx, base);
	// 825BEED4: 3BDEFFD8  addi r30, r30, -0x28
	ctx.r[30].s64 = ctx.r[30].s64 + -40;
	// 825BEED8: 7D7DF050  subf r11, r29, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[29].s64;
	// 825BEEDC: 7D6BE3D6  divw r11, r11, r28
	ctx.r[11].s32 = ctx.r[11].s32 / ctx.r[28].s32;
	// 825BEEE0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BEEE4: 4199FF40  bgt cr6, 0x825bee24
	if ctx.cr[6].gt {
	pc = 0x825BEE24; continue 'dispatch;
	}
	pc = 0x825BEEE8; continue 'dispatch;
            }
            0x825BEEE8 => {
    //   block [0x825BEEE8..0x825BEEFC)
	// 825BEEE8: 38210130  addi r1, r1, 0x130
	ctx.r[1].s64 = ctx.r[1].s64 + 304;
	// 825BEEEC: CBA1FF50  lfd f29, -0xb0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 825BEEF0: CBC1FF58  lfd f30, -0xa8(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 825BEEF4: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 825BEEF8: 486EA528  b 0x82ca9420
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BEF00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BEF00 size=296
    let mut pc: u32 = 0x825BEF00;
    'dispatch: loop {
        match pc {
            0x825BEF00 => {
    //   block [0x825BEF00..0x825BF014)
	// 825BEF00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BEF04: 486EA4F5  bl 0x82ca93f8
	ctx.lr = 0x825BEF08;
	sub_82CA93D0(ctx, base);
	// 825BEF08: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BEF0C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BEF10: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825BEF14: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 825BEF18: 3960000C  li r11, 0xc
	ctx.r[11].s64 = 12;
	// 825BEF1C: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 825BEF20: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BEF24: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BEF28: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BEF2C: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BEF30: 7D2AC050  subf r9, r10, r24
	ctx.r[9].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 825BEF34: 7D695BD6  divw r11, r9, r11
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[11].s32;
	// 825BEF38: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 825BEF3C: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 825BEF40: 409900D4  ble cr6, 0x825bf014
	if !ctx.cr[6].gt {
	pc = 0x825BF014; continue 'dispatch;
	}
	// 825BEF44: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BEF48: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BEF4C: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 825BEF50: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825BEF54: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BEF58: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BEF5C: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BEF60: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BEF64: 7CAB4214  add r5, r11, r8
	ctx.r[5].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BEF68: 54FF103A  slwi r31, r7, 2
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BEF6C: 54B91838  slwi r25, r5, 3
	ctx.r[25].u32 = ctx.r[5].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825BEF70: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 825BEF74: 7C995214  add r4, r25, r10
	ctx.r[4].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 825BEF78: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BEF7C: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825BEF80: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEF84: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEF88: 48000999  bl 0x825bf920
	ctx.lr = 0x825BEF8C;
	sub_825BF920(ctx, base);
	// 825BEF8C: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BEF90: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEF94: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 825BEF98: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEF9C: 7C7F5A14  add r3, r31, r11
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BEFA0: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BEFA4: 7D7F5850  subf r11, r31, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825BEFA8: 9061005C  stw r3, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[3].u32 ) };
	// 825BEFAC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BEFB0: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEFB4: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEFB8: 48000969  bl 0x825bf920
	ctx.lr = 0x825BEFBC;
	sub_825BF920(ctx, base);
	// 825BEFBC: 7D59C050  subf r10, r25, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 825BEFC0: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BEFC4: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825BEFC8: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825BEFCC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEFD0: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BEFD4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BEFD8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BEFDC: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BEFE0: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BEFE4: 4800093D  bl 0x825bf920
	ctx.lr = 0x825BEFE8;
	sub_825BF920(ctx, base);
	// 825BEFE8: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BEFEC: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BEFF0: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BEFF4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BEFF8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BEFFC: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 825BF000: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF004: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF008: 48000919  bl 0x825bf920
	ctx.lr = 0x825BF00C;
	sub_825BF920(ctx, base);
	// 825BF00C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BF010: 486EA438  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BF014 => {
    //   block [0x825BF014..0x825BF028)
	// 825BF014: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BF018: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BF01C: 48000905  bl 0x825bf920
	ctx.lr = 0x825BF020;
	sub_825BF920(ctx, base);
	// 825BF020: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BF024: 486EA424  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF028(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BF028 size=276
    let mut pc: u32 = 0x825BF028;
    'dispatch: loop {
        match pc {
            0x825BF028 => {
    //   block [0x825BF028..0x825BF128)
	// 825BF028: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF02C: 486EA3CD  bl 0x82ca93f8
	ctx.lr = 0x825BF030;
	sub_82CA93D0(ctx, base);
	// 825BF030: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF034: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BF038: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825BF03C: FBC100C0  std r30, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[30].u64 ) };
	// 825BF040: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BF044: FB8100D0  std r28, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[28].u64 ) };
	// 825BF048: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825BF04C: 814100C4  lwz r10, 0xc4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825BF050: 830100D4  lwz r24, 0xd4(r1)
	ctx.r[24].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BF054: 7D6AC050  subf r11, r10, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[10].s64;
	// 825BF058: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BF05C: FBA100C8  std r29, 0xc8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(200 as u32), ctx.r[29].u64 ) };
	// 825BF060: 2F0B0028  cmpwi cr6, r11, 0x28
	ctx.cr[6].compare_i32(ctx.r[11].s32, 40, &mut ctx.xer);
	// 825BF064: 409900C4  ble cr6, 0x825bf128
	if !ctx.cr[6].gt {
	pc = 0x825BF128; continue 'dispatch;
	}
	// 825BF068: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 825BF06C: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BF070: FBC10058  std r30, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[30].u64 ) };
	// 825BF074: 7D691E70  srawi r9, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 3) as i64;
	// 825BF078: 7D690194  addze r11, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BF07C: 557F2834  slwi r31, r11, 5
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BF080: 55793032  slwi r25, r11, 6
	ctx.r[25].u32 = ctx.r[11].u32.wrapping_shl(6);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825BF084: 7F5F5214  add r26, r31, r10
	ctx.r[26].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 825BF088: 7D195214  add r8, r25, r10
	ctx.r[8].u64 = ctx.r[25].u64 + ctx.r[10].u64;
	// 825BF08C: 9341005C  stw r26, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[26].u32 ) };
	// 825BF090: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825BF094: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF098: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF09C: 48000B0D  bl 0x825bfba8
	ctx.lr = 0x825BF0A0;
	sub_825BFBA8(ctx, base);
	// 825BF0A0: 816100CC  lwz r11, 0xcc(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(204 as u32) ) } as u64;
	// 825BF0A4: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BF0A8: FBA10058  std r29, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u64 ) };
	// 825BF0AC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BF0B0: 7CBF5850  subf r5, r31, r11
	ctx.r[5].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825BF0B4: FBA10050  std r29, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u64 ) };
	// 825BF0B8: 7CFF5A14  add r7, r31, r11
	ctx.r[7].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BF0BC: 90A10054  stw r5, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[5].u32 ) };
	// 825BF0C0: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 825BF0C4: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF0C8: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF0CC: 48000ADD  bl 0x825bfba8
	ctx.lr = 0x825BF0D0;
	sub_825BFBA8(ctx, base);
	// 825BF0D0: 7C99C050  subf r4, r25, r24
	ctx.r[4].s64 = ctx.r[24].s64 - ctx.r[25].s64;
	// 825BF0D4: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BF0D8: 7FFFC050  subf r31, r31, r24
	ctx.r[31].s64 = ctx.r[24].s64 - ctx.r[31].s64;
	// 825BF0DC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825BF0E0: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BF0E4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 825BF0E8: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BF0EC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BF0F0: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF0F4: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF0F8: 48000AB1  bl 0x825bfba8
	ctx.lr = 0x825BF0FC;
	sub_825BFBA8(ctx, base);
	// 825BF0FC: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825BF100: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 825BF104: FBC10050  std r30, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[30].u64 ) };
	// 825BF108: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BF10C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825BF110: 93410054  stw r26, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[26].u32 ) };
	// 825BF114: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF118: E8610050  ld r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF11C: 48000A8D  bl 0x825bfba8
	ctx.lr = 0x825BF120;
	sub_825BFBA8(ctx, base);
	// 825BF120: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BF124: 486EA324  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            0x825BF128 => {
    //   block [0x825BF128..0x825BF13C)
	// 825BF128: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 825BF12C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BF130: 48000A79  bl 0x825bfba8
	ctx.lr = 0x825BF134;
	sub_825BFBA8(ctx, base);
	// 825BF134: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 825BF138: 486EA310  b 0x82ca9448
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BF140 size=220
    let mut pc: u32 = 0x825BF140;
    'dispatch: loop {
        match pc {
            0x825BF140 => {
    //   block [0x825BF140..0x825BF21C)
	// 825BF140: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825BF144: 81610014  lwz r11, 0x14(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF148: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 825BF14C: 8141001C  lwz r10, 0x1c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BF150: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825BF154: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF158: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825BF15C: 80CB0000  lwz r6, 0(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF160: 3929000C  addi r9, r9, 0xc
	ctx.r[9].s64 = ctx.r[9].s64 + 12;
	// 825BF164: 3928000C  addi r9, r8, 0xc
	ctx.r[9].s64 = ctx.r[8].s64 + 12;
	// 825BF168: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BF16C: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BF170: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF174: 88AB0012  lbz r5, 0x12(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BF178: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BF17C: 888B0011  lbz r4, 0x11(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BF180: 886B0010  lbz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF184: 892B0013  lbz r9, 0x13(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BF188: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF18C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF190: 910B0004  stw r8, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825BF194: 80CA0008  lwz r6, 8(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF198: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF19C: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825BF1A0: C18A000C  lfs f12, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BF1A4: D18B000C  stfs f12, 0xc(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BF1A8: 88CA0010  lbz r6, 0x10(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF1AC: 98CB0010  stb r6, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[6].u8 ) };
	// 825BF1B0: 88CA0011  lbz r6, 0x11(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BF1B4: 98CB0011  stb r6, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[6].u8 ) };
	// 825BF1B8: 88CA0012  lbz r6, 0x12(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BF1BC: 98CB0012  stb r6, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[6].u8 ) };
	// 825BF1C0: 88CA0013  lbz r6, 0x13(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BF1C4: 98CB0013  stb r6, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[6].u8 ) };
	// 825BF1C8: C16A0014  lfs f11, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825BF1CC: 98A1FFEE  stb r5, -0x12(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-18 as u32), ctx.r[5].u8 ) };
	// 825BF1D0: D16B0014  stfs f11, 0x14(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825BF1D4: 88AB001C  lbz r5, 0x1c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BF1D8: 9861FFEC  stb r3, -0x14(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), ctx.r[3].u8 ) };
	// 825BF1DC: 9921FFEF  stb r9, -0x11(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-17 as u32), ctx.r[9].u8 ) };
	// 825BF1E0: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BF1E4: 812A0018  lwz r9, 0x18(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BF1E8: 912B0018  stw r9, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 825BF1EC: 88CA001C  lbz r6, 0x1c(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BF1F0: 9881FFED  stb r4, -0x13(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-19 as u32), ctx.r[4].u8 ) };
	// 825BF1F4: 98CB001C  stb r6, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[6].u8 ) };
	// 825BF1F8: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BF1FC: 8081FFEC  lwz r4, -0x14(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-20 as u32) ) } as u64;
	// 825BF200: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825BF204: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BF208: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BF20C: 908A0010  stw r4, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 825BF210: 906A0018  stw r3, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 825BF214: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 825BF218: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF220(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BF220 size=240
    let mut pc: u32 = 0x825BF220;
    'dispatch: loop {
        match pc {
            0x825BF220 => {
    //   block [0x825BF220..0x825BF258)
	// 825BF220: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF224: 486EA1CD  bl 0x82ca93f0
	ctx.lr = 0x825BF228;
	sub_82CA93D0(ctx, base);
	// 825BF228: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF22C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BF230: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BF234: FBC100F0  std r30, 0xf0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(240 as u32), ctx.r[30].u64 ) };
	// 825BF238: F88100F8  std r4, 0xf8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(248 as u32), ctx.r[4].u64 ) };
	// 825BF23C: 838100F4  lwz r28, 0xf4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) } as u64;
	// 825BF240: 83E100FC  lwz r31, 0xfc(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(252 as u32) ) } as u64;
	// 825BF244: 7D7CF850  subf r11, r28, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 825BF248: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BF24C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BF250: 409900B8  ble cr6, 0x825bf308
	if !ctx.cr[6].gt {
	pc = 0x825BF308; continue 'dispatch;
	}
	// 825BF254: 48000008  b 0x825bf25c
	pc = 0x825BF25C; continue 'dispatch;
            }
            0x825BF258 => {
    //   block [0x825BF258..0x825BF25C)
	// 825BF258: E88100F8  ld r4, 0xf8(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	pc = 0x825BF25C; continue 'dispatch;
            }
            0x825BF25C => {
    //   block [0x825BF25C..0x825BF2F0)
	// 825BF25C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BF260: 40990090  ble cr6, 0x825bf2f0
	if !ctx.cr[6].gt {
	pc = 0x825BF2F0; continue 'dispatch;
	}
	// 825BF264: 815FFFE0  lwz r10, -0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BF268: C01FFFEC  lfs f0, -0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF26C: 80BFFFE8  lwz r5, -0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825BF270: C1BFFFF4  lfs f13, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BF274: 813FFFE4  lwz r9, -0x1c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825BF278: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825BF27C: 8B7FFFF2  lbz r27, -0xe(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-14 as u32) ) } as u64;
	// 825BF280: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825BF284: 8B5FFFF1  lbz r26, -0xf(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-15 as u32) ) } as u64;
	// 825BF288: 397FFFE0  addi r11, r31, -0x20
	ctx.r[11].s64 = ctx.r[31].s64 + -32;
	// 825BF28C: 8B3FFFF0  lbz r25, -0x10(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BF290: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 825BF294: 8B1FFFF3  lbz r24, -0xd(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-13 as u32) ) } as u64;
	// 825BF298: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 825BF29C: 82FFFFF8  lwz r23, -8(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BF2A0: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825BF2A4: 8ADFFFFC  lbz r22, -4(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BF2A8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825BF2AC: 91410060  stw r10, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 825BF2B0: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825BF2B4: 90A10068  stw r5, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 825BF2B8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 825BF2BC: 9B610072  stb r27, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[27].u8 ) };
	// 825BF2C0: 9B410071  stb r26, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[26].u8 ) };
	// 825BF2C4: 9B210070  stb r25, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[25].u8 ) };
	// 825BF2C8: 9B010073  stb r24, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[24].u8 ) };
	// 825BF2CC: 92E10078  stw r23, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[23].u32 ) };
	// 825BF2D0: 9AC1007C  stb r22, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[22].u8 ) };
	// 825BF2D4: F8810050  std r4, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[4].u64 ) };
	// 825BF2D8: F8810058  std r4, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[4].u64 ) };
	// 825BF2DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825BF2E0: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 825BF2E4: E8A10050  ld r5, 0x50(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF2E8: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF2EC: 48001805  bl 0x825c0af0
	ctx.lr = 0x825BF2F0;
	sub_825C0AF0(ctx, base);
	pc = 0x825BF2F0; continue 'dispatch;
            }
            0x825BF2F0 => {
    //   block [0x825BF2F0..0x825BF308)
	// 825BF2F0: 3BFFFFE0  addi r31, r31, -0x20
	ctx.r[31].s64 = ctx.r[31].s64 + -32;
	// 825BF2F4: 7D7CF850  subf r11, r28, r31
	ctx.r[11].s64 = ctx.r[31].s64 - ctx.r[28].s64;
	// 825BF2F8: 93E100FC  stw r31, 0xfc(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(252 as u32), ctx.r[31].u32 ) };
	// 825BF2FC: 7D6B2E70  srawi r11, r11, 5
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 5) as i64;
	// 825BF300: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 825BF304: 4199FF54  bgt cr6, 0x825bf258
	if ctx.cr[6].gt {
	pc = 0x825BF258; continue 'dispatch;
	}
	pc = 0x825BF308; continue 'dispatch;
            }
            0x825BF308 => {
    //   block [0x825BF308..0x825BF310)
	// 825BF308: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 825BF30C: 486EA134  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF310(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BF310 size=200
    let mut pc: u32 = 0x825BF310;
    'dispatch: loop {
        match pc {
            0x825BF310 => {
    //   block [0x825BF310..0x825BF354)
	// 825BF310: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF314: 486EA0F1  bl 0x82ca9404
	ctx.lr = 0x825BF318;
	sub_82CA93D0(ctx, base);
	// 825BF318: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF31C: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 825BF320: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BF324: FB610090  std r27, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[27].u64 ) };
	// 825BF328: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 825BF32C: FBA10098  std r29, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[29].u64 ) };
	// 825BF330: 83C1009C  lwz r30, 0x9c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BF334: 83810094  lwz r28, 0x94(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825BF338: FBE100A0  std r31, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[31].u64 ) };
	// 825BF33C: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF340: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF344: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF348: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF34C: 41990008  bgt cr6, 0x825bf354
	if ctx.cr[6].gt {
	pc = 0x825BF354; continue 'dispatch;
	}
	// 825BF350: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF354; continue 'dispatch;
            }
            0x825BF354 => {
    //   block [0x825BF354..0x825BF36C)
	// 825BF354: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF358: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF35C: 419A0010  beq cr6, 0x825bf36c
	if ctx.cr[6].eq {
	pc = 0x825BF36C; continue 'dispatch;
	}
	// 825BF360: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BF364: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BF368: 4BFFF7E9  bl 0x825beb50
	ctx.lr = 0x825BF36C;
	sub_825BEB50(ctx, base);
	pc = 0x825BF36C; continue 'dispatch;
            }
            0x825BF36C => {
    //   block [0x825BF36C..0x825BF388)
	// 825BF36C: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BF370: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF374: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF378: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF37C: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF380: 41990008  bgt cr6, 0x825bf388
	if ctx.cr[6].gt {
	pc = 0x825BF388; continue 'dispatch;
	}
	// 825BF384: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF388; continue 'dispatch;
            }
            0x825BF388 => {
    //   block [0x825BF388..0x825BF3A0)
	// 825BF388: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF38C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF390: 419A0010  beq cr6, 0x825bf3a0
	if ctx.cr[6].eq {
	pc = 0x825BF3A0; continue 'dispatch;
	}
	// 825BF394: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BF398: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BF39C: 4BFFF7B5  bl 0x825beb50
	ctx.lr = 0x825BF3A0;
	sub_825BEB50(ctx, base);
	pc = 0x825BF3A0; continue 'dispatch;
            }
            0x825BF3A0 => {
    //   block [0x825BF3A0..0x825BF3B8)
	// 825BF3A0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF3A4: 815C0010  lwz r10, 0x10(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF3A8: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF3B0: 41990008  bgt cr6, 0x825bf3b8
	if ctx.cr[6].gt {
	pc = 0x825BF3B8; continue 'dispatch;
	}
	// 825BF3B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF3B8; continue 'dispatch;
            }
            0x825BF3B8 => {
    //   block [0x825BF3B8..0x825BF3D0)
	// 825BF3B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF3BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF3C0: 419A0010  beq cr6, 0x825bf3d0
	if ctx.cr[6].eq {
	pc = 0x825BF3D0; continue 'dispatch;
	}
	// 825BF3C4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825BF3C8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BF3CC: 4BFFF785  bl 0x825beb50
	ctx.lr = 0x825BF3D0;
	sub_825BEB50(ctx, base);
	pc = 0x825BF3D0; continue 'dispatch;
            }
            0x825BF3D0 => {
    //   block [0x825BF3D0..0x825BF3D8)
	// 825BF3D0: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BF3D4: 486EA080  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF3D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BF3D8 size=440
    let mut pc: u32 = 0x825BF3D8;
    'dispatch: loop {
        match pc {
            0x825BF3D8 => {
    //   block [0x825BF3D8..0x825BF418)
	// 825BF3D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF3DC: 486EA011  bl 0x82ca93ec
	ctx.lr = 0x825BF3E0;
	sub_82CA93D0(ctx, base);
	// 825BF3E0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF3E4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 825BF3E8: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 825BF3EC: 397C0001  addi r11, r28, 1
	ctx.r[11].s64 = ctx.r[28].s64 + 1;
	// 825BF3F0: 7CBA2B78  mr r26, r5
	ctx.r[26].u64 = ctx.r[5].u64;
	// 825BF3F4: FAE10100  std r23, 0x100(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), ctx.r[23].u64 ) };
	// 825BF3F8: 557F083C  slwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BF3FC: 83610104  lwz r27, 0x104(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) } as u64;
	// 825BF400: 3B000000  li r24, 0
	ctx.r[24].s64 = 0;
	// 825BF404: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 825BF408: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 825BF40C: 7F95E378  mr r21, r28
	ctx.r[21].u64 = ctx.r[28].u64;
	// 825BF410: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825BF414: 409800B0  bge cr6, 0x825bf4c4
	if !ctx.cr[6].lt {
	pc = 0x825BF4C4; continue 'dispatch;
	}
	pc = 0x825BF418; continue 'dispatch;
            }
            0x825BF418 => {
    //   block [0x825BF418..0x825BF448)
	// 825BF418: 57EB083C  slwi r11, r31, 1
	ctx.r[11].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF41C: 7D7F5A14  add r11, r31, r11
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[11].u64;
	// 825BF420: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF424: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825BF428: 394BFFE8  addi r10, r11, -0x18
	ctx.r[10].s64 = ctx.r[11].s64 + -24;
	// 825BF42C: 9141005C  stw r10, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 825BF430: 812BFFF8  lwz r9, -8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BF434: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF438: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF43C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BF440: 41990008  bgt cr6, 0x825bf448
	if ctx.cr[6].gt {
	pc = 0x825BF448; continue 'dispatch;
	}
	// 825BF444: 7F0BC378  mr r11, r24
	ctx.r[11].u64 = ctx.r[24].u64;
	pc = 0x825BF448; continue 'dispatch;
            }
            0x825BF448 => {
    //   block [0x825BF448..0x825BF458)
	// 825BF448: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF44C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF450: 419A0008  beq cr6, 0x825bf458
	if ctx.cr[6].eq {
	pc = 0x825BF458; continue 'dispatch;
	}
	// 825BF454: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	pc = 0x825BF458; continue 'dispatch;
            }
            0x825BF458 => {
    //   block [0x825BF458..0x825BF4C4)
	// 825BF458: 57EA083C  slwi r10, r31, 1
	ctx.r[10].u32 = ctx.r[31].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF45C: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF460: 7D5F5214  add r10, r31, r10
	ctx.r[10].u64 = ctx.r[31].u64 + ctx.r[10].u64;
	// 825BF464: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825BF468: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF46C: 552B1838  slwi r11, r9, 3
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF470: 7FCADA14  add r30, r10, r27
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 825BF474: 7FABDA14  add r29, r11, r27
	ctx.r[29].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825BF478: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825BF47C: 7D0AD82E  lwzx r8, r10, r27
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 825BF480: 387D0004  addi r3, r29, 4
	ctx.r[3].s64 = ctx.r[29].s64 + 4;
	// 825BF484: 7D0BD92E  stwx r8, r11, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[27].u32), ctx.r[8].u32) };
	// 825BF488: 4BF0A8F1  bl 0x824c9d78
	ctx.lr = 0x825BF48C;
	sub_824C9D78(ctx, base);
	// 825BF48C: 80DE0010  lwz r6, 0x10(r30)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF490: 38FF0001  addi r7, r31, 1
	ctx.r[7].s64 = ctx.r[31].s64 + 1;
	// 825BF494: 7FFCFB78  mr r28, r31
	ctx.r[28].u64 = ctx.r[31].u64;
	// 825BF498: 54FF083C  slwi r31, r7, 1
	ctx.r[31].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 825BF49C: 90DD0010  stw r6, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[6].u32 ) };
	// 825BF4A0: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	// 825BF4A4: 88BE0014  lbz r5, 0x14(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF4A8: 98BD0014  stb r5, 0x14(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[5].u8 ) };
	// 825BF4AC: 889E0015  lbz r4, 0x15(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BF4B0: 989D0015  stb r4, 0x15(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(21 as u32), ctx.r[4].u8 ) };
	// 825BF4B4: 887E0016  lbz r3, 0x16(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BF4B8: 987D0016  stb r3, 0x16(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(22 as u32), ctx.r[3].u8 ) };
	// 825BF4BC: 4198FF5C  blt cr6, 0x825bf418
	if ctx.cr[6].lt {
	pc = 0x825BF418; continue 'dispatch;
	}
	// 825BF4C0: 7F1FD000  cmpw cr6, r31, r26
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[26].s32, &mut ctx.xer);
	pc = 0x825BF4C4; continue 'dispatch;
            }
            0x825BF4C4 => {
    //   block [0x825BF4C4..0x825BF4F4)
	// 825BF4C4: 409A0030  bne cr6, 0x825bf4f4
	if !ctx.cr[6].eq {
	pc = 0x825BF4F4; continue 'dispatch;
	}
	// 825BF4C8: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF4CC: 578B083C  slwi r11, r28, 1
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF4D0: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 825BF4D4: 7D3C5A14  add r9, r28, r11
	ctx.r[9].u64 = ctx.r[28].u64 + ctx.r[11].u64;
	// 825BF4D8: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF4DC: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF4E0: 7D6BDA14  add r11, r11, r27
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825BF4E4: 7C6ADA14  add r3, r10, r27
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[27].u64;
	// 825BF4E8: 388BFFE8  addi r4, r11, -0x18
	ctx.r[4].s64 = ctx.r[11].s64 + -24;
	// 825BF4EC: 4BF0A81D  bl 0x824c9d08
	ctx.lr = 0x825BF4F0;
	sub_824C9D08(ctx, base);
	// 825BF4F0: 3B9AFFFF  addi r28, r26, -1
	ctx.r[28].s64 = ctx.r[26].s64 + -1;
	pc = 0x825BF4F4; continue 'dispatch;
            }
            0x825BF4F4 => {
    //   block [0x825BF4F4..0x825BF590)
	// 825BF4F4: 81790000  lwz r11, 0(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF4F8: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825BF4FC: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825BF500: 4BEC0D39  bl 0x82480238
	ctx.lr = 0x825BF504;
	sub_82480238(ctx, base);
	// 825BF504: 3BF90004  addi r31, r25, 4
	ctx.r[31].s64 = ctx.r[25].s64 + 4;
	// 825BF508: 38610074  addi r3, r1, 0x74
	ctx.r[3].s64 = ctx.r[1].s64 + 116;
	// 825BF50C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BF510: 4BF07249  bl 0x824c6758
	ctx.lr = 0x825BF514;
	sub_824C6758(ctx, base);
	// 825BF514: 81590010  lwz r10, 0x10(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF518: 89390014  lbz r9, 0x14(r25)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF51C: 7EC7B378  mr r7, r22
	ctx.r[7].u64 = ctx.r[22].u64;
	// 825BF520: 89190015  lbz r8, 0x15(r25)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BF524: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 825BF528: 89790016  lbz r11, 0x16(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[25].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BF52C: 7EA5AB78  mr r5, r21
	ctx.r[5].u64 = ctx.r[21].u64;
	// 825BF530: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825BF534: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825BF538: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 825BF53C: 99210084  stb r9, 0x84(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u8 ) };
	// 825BF540: 99010085  stb r8, 0x85(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(133 as u32), ctx.r[8].u8 ) };
	// 825BF544: 99610086  stb r11, 0x86(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(134 as u32), ctx.r[11].u8 ) };
	// 825BF548: 480008C9  bl 0x825bfe10
	ctx.lr = 0x825BF54C;
	sub_825BFE10(ctx, base);
	// 825BF54C: 81590008  lwz r10, 8(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF550: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BF554: 93E10050  stw r31, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u32 ) };
	// 825BF558: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BF55C: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 825BF560: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF564: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BF568: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BF56C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825BF570: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BF574: 4BEC0BDD  bl 0x82480150
	ctx.lr = 0x825BF578;
	sub_82480150(ctx, base);
	// 825BF578: 80790008  lwz r3, 8(r25)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF57C: 4BC5C7BD  bl 0x8221bd38
	ctx.lr = 0x825BF580;
	sub_8221BD38(ctx, base);
	// 825BF580: 93190008  stw r24, 8(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(8 as u32), ctx.r[24].u32 ) };
	// 825BF584: 9319000C  stw r24, 0xc(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(12 as u32), ctx.r[24].u32 ) };
	// 825BF588: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 825BF58C: 486E9EB0  b 0x82ca943c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF590(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BF590 size=356
    let mut pc: u32 = 0x825BF590;
    'dispatch: loop {
        match pc {
            0x825BF590 => {
    //   block [0x825BF590..0x825BF5E0)
	// 825BF590: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF594: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825BF598: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 825BF59C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825BF5A0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF5A4: F8610080  std r3, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[3].u64 ) };
	// 825BF5A8: F8810088  std r4, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[4].u64 ) };
	// 825BF5AC: 83E1008C  lwz r31, 0x8c(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) } as u64;
	// 825BF5B0: 83C10084  lwz r30, 0x84(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) } as u64;
	// 825BF5B4: F8A10090  std r5, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[5].u64 ) };
	// 825BF5B8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF5BC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF5C0: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF5C4: 409A001C  bne cr6, 0x825bf5e0
	if !ctx.cr[6].eq {
	pc = 0x825BF5E0; continue 'dispatch;
	}
	// 825BF5C8: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF5CC: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF5D0: 7D2B5010  subfc r9, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BF5D4: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BF5D8: 550B07FE  clrlwi r11, r8, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825BF5DC: 48000014  b 0x825bf5f0
	pc = 0x825BF5F0; continue 'dispatch;
            }
            0x825BF5E0 => {
    //   block [0x825BF5E0..0x825BF5EC)
	// 825BF5E0: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF5E4: 41980008  blt cr6, 0x825bf5ec
	if ctx.cr[6].lt {
	pc = 0x825BF5EC; continue 'dispatch;
	}
	// 825BF5E8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF5EC; continue 'dispatch;
            }
            0x825BF5EC => {
    //   block [0x825BF5EC..0x825BF5F0)
	// 825BF5EC: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BF5F0; continue 'dispatch;
            }
            0x825BF5F0 => {
    //   block [0x825BF5F0..0x825BF618)
	// 825BF5F0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF5F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF5F8: 419A0020  beq cr6, 0x825bf618
	if ctx.cr[6].eq {
	pc = 0x825BF618; continue 'dispatch;
	}
	// 825BF5FC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF600: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825BF604: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF608: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825BF60C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BF610: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BF614: 480013BD  bl 0x825c09d0
	ctx.lr = 0x825BF618;
	sub_825C09D0(ctx, base);
	pc = 0x825BF618; continue 'dispatch;
            }
            0x825BF618 => {
    //   block [0x825BF618..0x825BF644)
	// 825BF618: 81210094  lwz r9, 0x94(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825BF61C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF620: 81690000  lwz r11, 0(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF624: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF628: 409A001C  bne cr6, 0x825bf644
	if !ctx.cr[6].eq {
	pc = 0x825BF644; continue 'dispatch;
	}
	// 825BF62C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF630: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF634: 7D0B5010  subfc r8, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[8].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BF638: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BF63C: 54EB07FE  clrlwi r11, r7, 0x1f
	ctx.r[11].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825BF640: 48000014  b 0x825bf654
	pc = 0x825BF654; continue 'dispatch;
            }
            0x825BF644 => {
    //   block [0x825BF644..0x825BF650)
	// 825BF644: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF648: 41980008  blt cr6, 0x825bf650
	if ctx.cr[6].lt {
	pc = 0x825BF650; continue 'dispatch;
	}
	// 825BF64C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF650; continue 'dispatch;
            }
            0x825BF650 => {
    //   block [0x825BF650..0x825BF654)
	// 825BF650: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BF654; continue 'dispatch;
            }
            0x825BF654 => {
    //   block [0x825BF654..0x825BF67C)
	// 825BF654: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF65C: 419A0020  beq cr6, 0x825bf67c
	if ctx.cr[6].eq {
	pc = 0x825BF67C; continue 'dispatch;
	}
	// 825BF660: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF664: 389F0004  addi r4, r31, 4
	ctx.r[4].s64 = ctx.r[31].s64 + 4;
	// 825BF668: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF66C: 38690004  addi r3, r9, 4
	ctx.r[3].s64 = ctx.r[9].s64 + 4;
	// 825BF670: 91690000  stw r11, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BF674: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BF678: 48001359  bl 0x825c09d0
	ctx.lr = 0x825BF67C;
	sub_825C09D0(ctx, base);
	pc = 0x825BF67C; continue 'dispatch;
            }
            0x825BF67C => {
    //   block [0x825BF67C..0x825BF6A4)
	// 825BF67C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF680: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF684: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF688: 409A001C  bne cr6, 0x825bf6a4
	if !ctx.cr[6].eq {
	pc = 0x825BF6A4; continue 'dispatch;
	}
	// 825BF68C: 817F0004  lwz r11, 4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF690: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF694: 7D2B5010  subfc r9, r11, r10
	ctx.xer.ca = ctx.r[10].u32 >= ctx.r[11].u32;
	ctx.r[9].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 825BF698: 7D094910  subfe r8, r9, r9
	let x = (!ctx.r[9].u32);
	let y = ctx.r[9].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[8].u32 = res;
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BF69C: 550B07FE  clrlwi r11, r8, 0x1f
	ctx.r[11].u64 = ctx.r[8].u32 as u64 & 0x00000001u64;
	// 825BF6A0: 48000014  b 0x825bf6b4
	pc = 0x825BF6B4; continue 'dispatch;
            }
            0x825BF6A4 => {
    //   block [0x825BF6A4..0x825BF6B0)
	// 825BF6A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF6A8: 41980008  blt cr6, 0x825bf6b0
	if ctx.cr[6].lt {
	pc = 0x825BF6B0; continue 'dispatch;
	}
	// 825BF6AC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF6B0; continue 'dispatch;
            }
            0x825BF6B0 => {
    //   block [0x825BF6B0..0x825BF6B4)
	// 825BF6B0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BF6B4; continue 'dispatch;
            }
            0x825BF6B4 => {
    //   block [0x825BF6B4..0x825BF6DC)
	// 825BF6B4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF6B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF6BC: 419A0020  beq cr6, 0x825bf6dc
	if ctx.cr[6].eq {
	pc = 0x825BF6DC; continue 'dispatch;
	}
	// 825BF6C0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF6C4: 389E0004  addi r4, r30, 4
	ctx.r[4].s64 = ctx.r[30].s64 + 4;
	// 825BF6C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF6CC: 387F0004  addi r3, r31, 4
	ctx.r[3].s64 = ctx.r[31].s64 + 4;
	// 825BF6D0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825BF6D4: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825BF6D8: 480012F9  bl 0x825c09d0
	ctx.lr = 0x825BF6DC;
	sub_825C09D0(ctx, base);
	pc = 0x825BF6DC; continue 'dispatch;
            }
            0x825BF6DC => {
    //   block [0x825BF6DC..0x825BF6F4)
	// 825BF6DC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825BF6E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BF6E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825BF6E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 825BF6EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BF6F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF6F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BF6F8 size=552
    let mut pc: u32 = 0x825BF6F8;
    'dispatch: loop {
        match pc {
            0x825BF6F8 => {
    //   block [0x825BF6F8..0x825BF730)
	// 825BF6F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BF6FC: 486E9CF5  bl 0x82ca93f0
	ctx.lr = 0x825BF700;
	sub_82CA93D0(ctx, base);
	// 825BF700: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BF704: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 825BF708: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825BF70C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 825BF710: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BF714: FBA100E0  std r29, 0xe0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(224 as u32), ctx.r[29].u64 ) };
	// 825BF718: 810100E4  lwz r8, 0xe4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) } as u64;
	// 825BF71C: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825BF720: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 825BF724: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 825BF728: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825BF72C: 40980124  bge cr6, 0x825bf850
	if !ctx.cr[6].lt {
	pc = 0x825BF850; continue 'dispatch;
	}
	pc = 0x825BF730; continue 'dispatch;
            }
            0x825BF730 => {
    //   block [0x825BF730..0x825BF768)
	// 825BF730: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF734: 7D695A14  add r11, r9, r11
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 825BF738: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF73C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BF740: 814BFFD8  lwz r10, -0x28(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) } as u64;
	// 825BF744: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF748: 7F075000  cmpw cr6, r7, r10
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BF74C: 409A001C  bne cr6, 0x825bf768
	if !ctx.cr[6].eq {
	pc = 0x825BF768; continue 'dispatch;
	}
	// 825BF750: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF754: 80EBFFDC  lwz r7, -0x24(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-36 as u32) ) } as u64;
	// 825BF758: 7CCA3810  subfc r6, r10, r7
	ctx.xer.ca = ctx.r[7].u32 >= ctx.r[10].u32;
	ctx.r[6].s64 = ctx.r[7].s64 - ctx.r[10].s64;
	// 825BF75C: 7CA63110  subfe r5, r6, r6
	let x = (!ctx.r[6].u32);
	let y = ctx.r[6].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[5].u32 = res;
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825BF760: 54AB07FE  clrlwi r11, r5, 0x1f
	ctx.r[11].u64 = ctx.r[5].u32 as u64 & 0x00000001u64;
	// 825BF764: 48000014  b 0x825bf778
	pc = 0x825BF778; continue 'dispatch;
            }
            0x825BF768 => {
    //   block [0x825BF768..0x825BF774)
	// 825BF768: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825BF76C: 41980008  blt cr6, 0x825bf774
	if ctx.cr[6].lt {
	pc = 0x825BF774; continue 'dispatch;
	}
	// 825BF770: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825BF774; continue 'dispatch;
            }
            0x825BF774 => {
    //   block [0x825BF774..0x825BF778)
	// 825BF774: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	pc = 0x825BF778; continue 'dispatch;
            }
            0x825BF778 => {
    //   block [0x825BF778..0x825BF788)
	// 825BF778: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825BF77C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825BF780: 419A0008  beq cr6, 0x825bf788
	if ctx.cr[6].eq {
	pc = 0x825BF788; continue 'dispatch;
	}
	// 825BF784: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	pc = 0x825BF788; continue 'dispatch;
            }
            0x825BF788 => {
    //   block [0x825BF788..0x825BF850)
	// 825BF788: 552A103A  slwi r10, r9, 2
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF78C: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF790: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 825BF794: 7CE45A14  add r7, r4, r11
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 825BF798: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF79C: 54EA1838  slwi r10, r7, 3
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF7A0: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BF7A4: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BF7A8: 38A90001  addi r5, r9, 1
	ctx.r[5].s64 = ctx.r[9].s64 + 1;
	// 825BF7AC: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 825BF7B0: 54A9083C  slwi r9, r5, 1
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BF7B4: 806B0000  lwz r3, 0(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF7B8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 825BF7BC: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 825BF7C0: 38E70010  addi r7, r7, 0x10
	ctx.r[7].s64 = ctx.r[7].s64 + 16;
	// 825BF7C4: 38C60010  addi r6, r6, 0x10
	ctx.r[6].s64 = ctx.r[6].s64 + 16;
	// 825BF7C8: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	// 825BF7CC: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825BF7D0: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF7D4: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BF7D8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF7DC: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BF7E0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF7E4: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BF7E8: 80EB0010  lwz r7, 0x10(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF7EC: 90EA0010  stw r7, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825BF7F0: 88CB0014  lbz r6, 0x14(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF7F4: 98CA0014  stb r6, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[6].u8 ) };
	// 825BF7F8: 88AB0015  lbz r5, 0x15(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BF7FC: 98AA0015  stb r5, 0x15(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(21 as u32), ctx.r[5].u8 ) };
	// 825BF800: 886B0016  lbz r3, 0x16(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BF804: 986A0016  stb r3, 0x16(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(22 as u32), ctx.r[3].u8 ) };
	// 825BF808: 88EB0017  lbz r7, 0x17(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BF80C: 98EA0017  stb r7, 0x17(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(23 as u32), ctx.r[7].u8 ) };
	// 825BF810: 88CB0018  lbz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BF814: 98CA0018  stb r6, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[6].u8 ) };
	// 825BF818: 88AB0019  lbz r5, 0x19(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BF81C: 98AA0019  stb r5, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[5].u8 ) };
	// 825BF820: 886B001A  lbz r3, 0x1a(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BF824: 986A001A  stb r3, 0x1a(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(26 as u32), ctx.r[3].u8 ) };
	// 825BF828: 88EB001B  lbz r7, 0x1b(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BF82C: 98EA001B  stb r7, 0x1b(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(27 as u32), ctx.r[7].u8 ) };
	// 825BF830: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BF834: D1AA001C  stfs f13, 0x1c(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825BF838: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BF83C: 90CA0020  stw r6, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 825BF840: C18B0024  lfs f12, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BF844: D18A0024  stfs f12, 0x24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825BF848: 4198FEE8  blt cr6, 0x825bf730
	if ctx.cr[6].lt {
	pc = 0x825BF730; continue 'dispatch;
	}
	// 825BF84C: 7F09F000  cmpw cr6, r9, r30
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[30].s32, &mut ctx.xer);
	pc = 0x825BF850; continue 'dispatch;
            }
            0x825BF850 => {
    //   block [0x825BF850..0x825BF880)
	// 825BF850: 409A0030  bne cr6, 0x825bf880
	if !ctx.cr[6].eq {
	pc = 0x825BF880; continue 'dispatch;
	}
	// 825BF854: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF858: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF85C: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BF860: 7D245A14  add r9, r4, r11
	ctx.r[9].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 825BF864: 554B1838  slwi r11, r10, 3
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BF868: 552A1838  slwi r10, r9, 3
	ctx.r[10].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BF86C: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BF870: 7C6A4214  add r3, r10, r8
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BF874: 388BFFD8  addi r4, r11, -0x28
	ctx.r[4].s64 = ctx.r[11].s64 + -40;
	// 825BF878: 4BFFD7E1  bl 0x825bd058
	ctx.lr = 0x825BF87C;
	sub_825BD058(ctx, base);
	// 825BF87C: 389EFFFF  addi r4, r30, -1
	ctx.r[4].s64 = ctx.r[30].s64 + -1;
	pc = 0x825BF880; continue 'dispatch;
            }
            0x825BF880 => {
    //   block [0x825BF880..0x825BF920)
	// 825BF880: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	// 825BF884: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF888: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 825BF88C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF890: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BF894: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF898: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 825BF89C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BF8A0: 8B5F0016  lbz r26, 0x16(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BF8A4: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BF8A8: 8B3F0015  lbz r25, 0x15(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BF8AC: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BF8B0: 8B1F0014  lbz r24, 0x14(r31)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF8B4: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825BF8B8: 8B9F0017  lbz r28, 0x17(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(23 as u32) ) } as u64;
	// 825BF8BC: D001005C  stfs f0, 0x5c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825BF8C0: 8AFF001A  lbz r23, 0x1a(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 825BF8C4: D1A1006C  stfs f13, 0x6c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825BF8C8: 8B7F0019  lbz r27, 0x19(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 825BF8CC: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825BF8D0: 8ADF0018  lbz r22, 0x18(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BF8D4: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825BF8D8: 8BBF001B  lbz r29, 0x1b(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(27 as u32) ) } as u64;
	// 825BF8DC: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825BF8E0: 91410050  stw r10, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u32 ) };
	// 825BF8E4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825BF8E8: 91010058  stw r8, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 825BF8EC: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 825BF8F0: 9B410066  stb r26, 0x66(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(102 as u32), ctx.r[26].u8 ) };
	// 825BF8F4: 9B210065  stb r25, 0x65(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(101 as u32), ctx.r[25].u8 ) };
	// 825BF8F8: 9B010064  stb r24, 0x64(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[24].u8 ) };
	// 825BF8FC: 9B810067  stb r28, 0x67(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(103 as u32), ctx.r[28].u8 ) };
	// 825BF900: 9AE1006A  stb r23, 0x6a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(106 as u32), ctx.r[23].u8 ) };
	// 825BF904: 9B610069  stb r27, 0x69(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(105 as u32), ctx.r[27].u8 ) };
	// 825BF908: 9AC10068  stb r22, 0x68(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[22].u8 ) };
	// 825BF90C: 9BA1006B  stb r29, 0x6b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(107 as u32), ctx.r[29].u8 ) };
	// 825BF910: 91610070  stw r11, 0x70(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 825BF914: 48000815  bl 0x825c0128
	ctx.lr = 0x825BF918;
	sub_825C0128(ctx, base);
	// 825BF918: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 825BF91C: 486E9B24  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BF920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825BF920 size=244
    let mut pc: u32 = 0x825BF920;
    'dispatch: loop {
        match pc {
            0x825BF920 => {
    //   block [0x825BF920..0x825BF97C)
	// 825BF920: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825BF924: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 825BF928: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BF92C: 81410014  lwz r10, 0x14(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BF930: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 825BF934: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF938: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF93C: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BF940: 4098003C  bge cr6, 0x825bf97c
	if !ctx.cr[6].lt {
	pc = 0x825BF97C; continue 'dispatch;
	}
	// 825BF944: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF948: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BF94C: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825BF950: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BF954: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 825BF958: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BF95C: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF960: 80AA0004  lwz r5, 4(r10)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF964: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BF968: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BF96C: 808B0008  lwz r4, 8(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF970: 806A0008  lwz r3, 8(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF974: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BF978: 908A0008  stw r4, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	pc = 0x825BF97C; continue 'dispatch;
            }
            0x825BF97C => {
    //   block [0x825BF97C..0x825BF9C8)
	// 825BF97C: 81210024  lwz r9, 0x24(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 825BF980: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF984: 80E90000  lwz r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF988: 7F074040  cmplw cr6, r7, r8
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BF98C: 4098003C  bge cr6, 0x825bf9c8
	if !ctx.cr[6].lt {
	pc = 0x825BF9C8; continue 'dispatch;
	}
	// 825BF990: 80C90000  lwz r6, 0(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF994: 5507003E  slwi r7, r8, 0
	ctx.r[7].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BF998: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825BF99C: 90E90000  stw r7, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BF9A0: 39090004  addi r8, r9, 4
	ctx.r[8].s64 = ctx.r[9].s64 + 4;
	// 825BF9A4: 90CB0000  stw r6, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BF9A8: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF9AC: 80890004  lwz r4, 4(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF9B0: 90A90004  stw r5, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BF9B4: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825BF9B8: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF9BC: 81090008  lwz r8, 8(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BF9C0: 90690008  stw r3, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BF9C4: 910B0008  stw r8, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825BF9C8; continue 'dispatch;
            }
            0x825BF9C8 => {
    //   block [0x825BF9C8..0x825BFA14)
	// 825BF9C8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF9CC: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF9D0: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825BF9D4: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 825BF9D8: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BF9DC: 5508003E  slwi r8, r8, 0
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BF9E0: 392A0004  addi r9, r10, 4
	ctx.r[9].s64 = ctx.r[10].s64 + 4;
	// 825BF9E4: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BF9E8: 392B0004  addi r9, r11, 4
	ctx.r[9].s64 = ctx.r[11].s64 + 4;
	// 825BF9EC: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BF9F0: 80CA0004  lwz r6, 4(r10)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF9F4: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BF9F8: 90CB0004  stw r6, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BF9FC: 90AA0004  stw r5, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825BFA00: 808A0008  lwz r4, 8(r10)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFA04: 806B0008  lwz r3, 8(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFA08: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825BFA0C: 906A0008  stw r3, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825BFA10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFA18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825BFA18 size=400
    let mut pc: u32 = 0x825BFA18;
    'dispatch: loop {
        match pc {
            0x825BFA18 => {
    //   block [0x825BFA18..0x825BFA3C)
	// 825BFA18: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 825BFA1C: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825BFA20: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 825BFA24: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825BFA28: 81210014  lwz r9, 0x14(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BFA2C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825BFA30: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFA34: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BFA38: 40980080  bge cr6, 0x825bfab8
	if !ctx.cr[6].lt {
	pc = 0x825BFAB8; continue 'dispatch;
	}
	pc = 0x825BFA3C; continue 'dispatch;
            }
            0x825BFA3C => {
    //   block [0x825BFA3C..0x825BFA68)
	// 825BFA3C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFA40: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BFA44: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFA48: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BFA4C: 390AFFF4  addi r8, r10, -0xc
	ctx.r[8].s64 = ctx.r[10].s64 + -12;
	// 825BFA50: 9101FFE4  stw r8, -0x1c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), ctx.r[8].u32 ) };
	// 825BFA54: 80EAFFF4  lwz r7, -0xc(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BFA58: 806A0000  lwz r3, 0(r10)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFA5C: 7F033840  cmplw cr6, r3, r7
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825BFA60: 40980008  bge cr6, 0x825bfa68
	if !ctx.cr[6].lt {
	pc = 0x825BFA68; continue 'dispatch;
	}
	// 825BFA64: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	pc = 0x825BFA68; continue 'dispatch;
            }
            0x825BFA68 => {
    //   block [0x825BFA68..0x825BFAB8)
	// 825BFA68: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFA6C: 548A083C  slwi r10, r4, 1
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFA70: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BFA74: 7CE45214  add r7, r4, r10
	ctx.r[7].u64 = ctx.r[4].u64 + ctx.r[10].u64;
	// 825BFA78: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFA7C: 54EA103A  slwi r10, r7, 2
	ctx.r[10].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFA80: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825BFA84: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 825BFA88: 386B0001  addi r3, r11, 1
	ctx.r[3].s64 = ctx.r[11].s64 + 1;
	// 825BFA8C: 7D645B78  mr r4, r11
	ctx.r[4].u64 = ctx.r[11].u64;
	// 825BFA90: 546B083C  slwi r11, r3, 1
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFA94: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFA98: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BFA9C: 90EA0000  stw r7, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825BFAA0: 80680004  lwz r3, 4(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFAA4: 906A0004  stw r3, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BFAA8: 81080008  lwz r8, 8(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFAAC: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BFAB0: 4198FF8C  blt cr6, 0x825bfa3c
	if ctx.cr[6].lt {
	pc = 0x825BFA3C; continue 'dispatch;
	}
	// 825BFAB4: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	pc = 0x825BFAB8; continue 'dispatch;
            }
            0x825BFAB8 => {
    //   block [0x825BFAB8..0x825BFAFC)
	// 825BFAB8: 409A0044  bne cr6, 0x825bfafc
	if !ctx.cr[6].eq {
	pc = 0x825BFAFC; continue 'dispatch;
	}
	// 825BFABC: 548B083C  slwi r11, r4, 1
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFAC0: 54AA083C  slwi r10, r5, 1
	ctx.r[10].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFAC4: 7D645A14  add r11, r4, r11
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[11].u64;
	// 825BFAC8: 7D455214  add r10, r5, r10
	ctx.r[10].u64 = ctx.r[5].u64 + ctx.r[10].u64;
	// 825BFACC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFAD0: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFAD4: 7D4B4A14  add r10, r11, r9
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BFAD8: 7D684A14  add r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825BFADC: 3885FFFF  addi r4, r5, -1
	ctx.r[4].s64 = ctx.r[5].s64 + -1;
	// 825BFAE0: 390BFFF4  addi r8, r11, -0xc
	ctx.r[8].s64 = ctx.r[11].s64 + -12;
	// 825BFAE4: 810BFFF4  lwz r8, -0xc(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) } as u64;
	// 825BFAE8: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825BFAEC: 80EBFFF8  lwz r7, -8(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BFAF0: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BFAF4: 80ABFFFC  lwz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BFAF8: 90AA0008  stw r5, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	pc = 0x825BFAFC; continue 'dispatch;
            }
            0x825BFAFC => {
    //   block [0x825BFAFC..0x825BFB20)
	// 825BFAFC: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 825BFB00: 80A60000  lwz r5, 0(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFB04: 80660004  lwz r3, 4(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFB08: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 825BFB0C: 7D680E70  srawi r8, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825BFB10: 80C60008  lwz r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFB14: 7F1F2000  cmpw cr6, r31, r4
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825BFB18: 7D680194  addze r11, r8
	tmp.s64 = ctx.r[8].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[8].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BFB1C: 40980064  bge cr6, 0x825bfb80
	if !ctx.cr[6].lt {
	pc = 0x825BFB80; continue 'dispatch;
	}
	pc = 0x825BFB20; continue 'dispatch;
            }
            0x825BFB20 => {
    //   block [0x825BFB20..0x825BFB80)
	// 825BFB20: 5568083C  slwi r8, r11, 1
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFB24: 7D0B4214  add r8, r11, r8
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BFB28: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFB2C: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825BFB30: 80E80000  lwz r7, 0(r8)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFB34: 7F072840  cmplw cr6, r7, r5
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[5].u32, &mut ctx.xer);
	// 825BFB38: 40980048  bge cr6, 0x825bfb80
	if !ctx.cr[6].lt {
	pc = 0x825BFB80; continue 'dispatch;
	}
	// 825BFB3C: 5547083C  slwi r7, r10, 1
	ctx.r[7].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 825BFB40: 7D044378  mr r4, r8
	ctx.r[4].u64 = ctx.r[8].u64;
	// 825BFB44: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825BFB48: 38EBFFFF  addi r7, r11, -1
	ctx.r[7].s64 = ctx.r[11].s64 + -1;
	// 825BFB4C: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825BFB50: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825BFB54: 83C40000  lwz r30, 0(r4)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFB58: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825BFB5C: 7CEB0E70  srawi r11, r7, 1
	ctx.xer.ca = (ctx.r[7].s32 < 0) && ((ctx.r[7].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[7].s32 >> 1) as i64;
	// 825BFB60: 7F1F5000  cmpw cr6, r31, r10
	ctx.cr[6].compare_i32(ctx.r[31].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825BFB64: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 825BFB68: 93C80000  stw r30, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825BFB6C: 80E40004  lwz r7, 4(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFB70: 90E80004  stw r7, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825BFB74: 80840008  lwz r4, 8(r4)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFB78: 90880008  stw r4, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825BFB7C: 4198FFA4  blt cr6, 0x825bfb20
	if ctx.cr[6].lt {
	pc = 0x825BFB20; continue 'dispatch;
	}
	pc = 0x825BFB80; continue 'dispatch;
            }
            0x825BFB80 => {
    //   block [0x825BFB80..0x825BFBA8)
	// 825BFB80: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFB84: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825BFB88: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFB8C: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825BFB90: 90AB0000  stw r5, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825BFB94: 906B0004  stw r3, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 825BFB98: 90CB0008  stw r6, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825BFB9C: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825BFBA0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 825BFBA4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BFBA8 size=140
    let mut pc: u32 = 0x825BFBA8;
    'dispatch: loop {
        match pc {
            0x825BFBA8 => {
    //   block [0x825BFBA8..0x825BFBF0)
	// 825BFBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BFBAC: 486E9859  bl 0x82ca9404
	ctx.lr = 0x825BFBB0;
	sub_82CA93D0(ctx, base);
	// 825BFBB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BFBB4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825BFBB8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825BFBBC: FBC10090  std r30, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[30].u64 ) };
	// 825BFBC0: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BFBC4: FBE10098  std r31, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[31].u64 ) };
	// 825BFBC8: 8381009C  lwz r28, 0x9c(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(156 as u32) ) } as u64;
	// 825BFBCC: 83610094  lwz r27, 0x94(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825BFBD0: FBA100A0  std r29, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[29].u64 ) };
	// 825BFBD4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFBD8: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFBDC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BFBE0: 40980010  bge cr6, 0x825bfbf0
	if !ctx.cr[6].lt {
	pc = 0x825BFBF0; continue 'dispatch;
	}
	// 825BFBE4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BFBE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BFBEC: 4BFFF555  bl 0x825bf140
	ctx.lr = 0x825BFBF0;
	sub_825BF140(ctx, base);
	pc = 0x825BFBF0; continue 'dispatch;
            }
            0x825BFBF0 => {
    //   block [0x825BFBF0..0x825BFC10)
	// 825BFBF0: 816100A4  lwz r11, 0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) } as u64;
	// 825BFBF4: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFBF8: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFBFC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BFC00: 40980010  bge cr6, 0x825bfc10
	if !ctx.cr[6].lt {
	pc = 0x825BFC10; continue 'dispatch;
	}
	// 825BFC04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825BFC08: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825BFC0C: 4BFFF535  bl 0x825bf140
	ctx.lr = 0x825BFC10;
	sub_825BF140(ctx, base);
	pc = 0x825BFC10; continue 'dispatch;
            }
            0x825BFC10 => {
    //   block [0x825BFC10..0x825BFC2C)
	// 825BFC10: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFC14: 815B0000  lwz r10, 0(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFC18: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825BFC1C: 40980010  bge cr6, 0x825bfc2c
	if !ctx.cr[6].lt {
	pc = 0x825BFC2C; continue 'dispatch;
	}
	// 825BFC20: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825BFC24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825BFC28: 4BFFF519  bl 0x825bf140
	ctx.lr = 0x825BFC2C;
	sub_825BF140(ctx, base);
	pc = 0x825BFC2C; continue 'dispatch;
            }
            0x825BFC2C => {
    //   block [0x825BFC2C..0x825BFC34)
	// 825BFC2C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825BFC30: 486E9824  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BFC38 size=468
    let mut pc: u32 = 0x825BFC38;
    'dispatch: loop {
        match pc {
            0x825BFC38 => {
    //   block [0x825BFC38..0x825BFC64)
	// 825BFC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BFC3C: 486E97C5  bl 0x82ca9400
	ctx.lr = 0x825BFC40;
	sub_82CA93D0(ctx, base);
	// 825BFC40: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BFC44: 39640001  addi r11, r4, 1
	ctx.r[11].s64 = ctx.r[4].s64 + 1;
	// 825BFC48: F86100D0  std r3, 0xd0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(208 as u32), ctx.r[3].u64 ) };
	// 825BFC4C: 810100D4  lwz r8, 0xd4(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) } as u64;
	// 825BFC50: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 825BFC54: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BFC58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825BFC5C: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BFC60: 409800B8  bge cr6, 0x825bfd18
	if !ctx.cr[6].lt {
	pc = 0x825BFD18; continue 'dispatch;
	}
	pc = 0x825BFC64; continue 'dispatch;
            }
            0x825BFC64 => {
    //   block [0x825BFC64..0x825BFC88)
	// 825BFC64: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFC68: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BFC6C: 394BFFE0  addi r10, r11, -0x20
	ctx.r[10].s64 = ctx.r[11].s64 + -32;
	// 825BFC70: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BFC74: 80CBFFE0  lwz r6, -0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BFC78: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFC7C: 7F0B3040  cmplw cr6, r11, r6
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825BFC80: 40980008  bge cr6, 0x825bfc88
	if !ctx.cr[6].lt {
	pc = 0x825BFC88; continue 'dispatch;
	}
	// 825BFC84: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	pc = 0x825BFC88; continue 'dispatch;
            }
            0x825BFC88 => {
    //   block [0x825BFC88..0x825BFD18)
	// 825BFC88: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFC8C: 548A2834  slwi r10, r4, 5
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFC90: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BFC94: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825BFC98: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 825BFC9C: 3BEA0004  addi r31, r10, 4
	ctx.r[31].s64 = ctx.r[10].s64 + 4;
	// 825BFCA0: 38C6000C  addi r6, r6, 0xc
	ctx.r[6].s64 = ctx.r[6].s64 + 12;
	// 825BFCA4: 836B0000  lwz r27, 0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFCA8: 38DF000C  addi r6, r31, 0xc
	ctx.r[6].s64 = ctx.r[31].s64 + 12;
	// 825BFCAC: 3B890001  addi r28, r9, 1
	ctx.r[28].s64 = ctx.r[9].s64 + 1;
	// 825BFCB0: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 825BFCB4: 5789083C  slwi r9, r28, 1
	ctx.r[9].u32 = ctx.r[28].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BFCB8: 936A0000  stw r27, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 825BFCBC: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825BFCC0: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFCC4: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825BFCC8: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFCCC: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825BFCD0: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BFCD4: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BFCD8: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BFCDC: 98CA0010  stb r6, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u8 ) };
	// 825BFCE0: 88CB0011  lbz r6, 0x11(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BFCE4: 98CA0011  stb r6, 0x11(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(17 as u32), ctx.r[6].u8 ) };
	// 825BFCE8: 88CB0012  lbz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BFCEC: 98CA0012  stb r6, 0x12(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[6].u8 ) };
	// 825BFCF0: 88CB0013  lbz r6, 0x13(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BFCF4: 98CA0013  stb r6, 0x13(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(19 as u32), ctx.r[6].u8 ) };
	// 825BFCF8: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BFCFC: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825BFD00: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BFD04: 90CA0018  stw r6, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825BFD08: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BFD0C: 996A001C  stb r11, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 825BFD10: 4198FF54  blt cr6, 0x825bfc64
	if ctx.cr[6].lt {
	pc = 0x825BFC64; continue 'dispatch;
	}
	// 825BFD14: 7F092800  cmpw cr6, r9, r5
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[5].s32, &mut ctx.xer);
	pc = 0x825BFD18; continue 'dispatch;
            }
            0x825BFD18 => {
    //   block [0x825BFD18..0x825BFD9C)
	// 825BFD18: 409A0084  bne cr6, 0x825bfd9c
	if !ctx.cr[6].eq {
	pc = 0x825BFD9C; continue 'dispatch;
	}
	// 825BFD1C: 548B2834  slwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFD20: 54A92834  slwi r9, r5, 5
	ctx.r[9].u32 = ctx.r[5].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825BFD24: 7D4B4214  add r10, r11, r8
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 825BFD28: 7D694214  add r11, r9, r8
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 825BFD2C: 3885FFFF  addi r4, r5, -1
	ctx.r[4].s64 = ctx.r[5].s64 + -1;
	// 825BFD30: 392BFFE0  addi r9, r11, -0x20
	ctx.r[9].s64 = ctx.r[11].s64 + -32;
	// 825BFD34: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825BFD38: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 825BFD3C: 80CBFFE0  lwz r6, -0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-32 as u32) ) } as u64;
	// 825BFD40: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 825BFD44: 38A9000C  addi r5, r9, 0xc
	ctx.r[5].s64 = ctx.r[9].s64 + 12;
	// 825BFD48: 90CA0000  stw r6, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 825BFD4C: 812BFFE4  lwz r9, -0x1c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-28 as u32) ) } as u64;
	// 825BFD50: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825BFD54: 810BFFE8  lwz r8, -0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) } as u64;
	// 825BFD58: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825BFD5C: C00BFFEC  lfs f0, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BFD60: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825BFD64: 88CBFFF0  lbz r6, -0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) } as u64;
	// 825BFD68: 98CA0010  stb r6, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u8 ) };
	// 825BFD6C: 88ABFFF1  lbz r5, -0xf(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-15 as u32) ) } as u64;
	// 825BFD70: 98AA0011  stb r5, 0x11(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(17 as u32), ctx.r[5].u8 ) };
	// 825BFD74: 892BFFF2  lbz r9, -0xe(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-14 as u32) ) } as u64;
	// 825BFD78: 992A0012  stb r9, 0x12(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[9].u8 ) };
	// 825BFD7C: 890BFFF3  lbz r8, -0xd(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-13 as u32) ) } as u64;
	// 825BFD80: 990A0013  stb r8, 0x13(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825BFD84: C1ABFFF4  lfs f13, -0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BFD88: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825BFD8C: 80CBFFF8  lwz r6, -8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825BFD90: 90CA0018  stw r6, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825BFD94: 88ABFFFC  lbz r5, -4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 825BFD98: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	pc = 0x825BFD9C; continue 'dispatch;
            }
            0x825BFD9C => {
    //   block [0x825BFD9C..0x825BFE0C)
	// 825BFD9C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825BFDA0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFDA4: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825BFDA8: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825BFDAC: 813E0008  lwz r9, 8(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFDB0: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825BFDB4: 891E0012  lbz r8, 0x12(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(18 as u32) ) } as u64;
	// 825BFDB8: D001006C  stfs f0, 0x6c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 825BFDBC: 8BFE0011  lbz r31, 0x11(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(17 as u32) ) } as u64;
	// 825BFDC0: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 825BFDC4: 8B9E0010  lbz r28, 0x10(r30)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BFDC8: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 825BFDCC: 8B7E0013  lbz r27, 0x13(r30)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(19 as u32) ) } as u64;
	// 825BFDD0: 83BE0018  lwz r29, 0x18(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) } as u64;
	// 825BFDD4: 8B5E001C  lbz r26, 0x1c(r30)
	ctx.r[26].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 825BFDD8: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 825BFDDC: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	// 825BFDE0: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 825BFDE4: 91210068  stw r9, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u32 ) };
	// 825BFDE8: 99010072  stb r8, 0x72(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(114 as u32), ctx.r[8].u8 ) };
	// 825BFDEC: 9BE10071  stb r31, 0x71(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(113 as u32), ctx.r[31].u8 ) };
	// 825BFDF0: 9B810070  stb r28, 0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[28].u8 ) };
	// 825BFDF4: 9B610073  stb r27, 0x73(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(115 as u32), ctx.r[27].u8 ) };
	// 825BFDF8: 93A10078  stw r29, 0x78(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 825BFDFC: 9B41007C  stb r26, 0x7c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[26].u8 ) };
	// 825BFE00: 48000891  bl 0x825c0690
	ctx.lr = 0x825BFE04;
	sub_825C0690(ctx, base);
	// 825BFE04: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 825BFE08: 486E9648  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFE10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825BFE10 size=292
    let mut pc: u32 = 0x825BFE10;
    'dispatch: loop {
        match pc {
            0x825BFE10 => {
    //   block [0x825BFE10..0x825BFE48)
	// 825BFE10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BFE14: 486E95F1  bl 0x82ca9404
	ctx.lr = 0x825BFE18;
	sub_82CA93D0(ctx, base);
	// 825BFE18: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BFE1C: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825BFE20: F86100B0  std r3, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u64 ) };
	// 825BFE24: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 825BFE28: 838100B4  lwz r28, 0xb4(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825BFE2C: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825BFE30: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825BFE34: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 825BFE38: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 825BFE3C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BFE40: 7FC90194  addze r30, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[30].s64 = tmp.s64;
	// 825BFE44: 40980064  bge cr6, 0x825bfea8
	if !ctx.cr[6].lt {
	pc = 0x825BFEA8; continue 'dispatch;
	}
	pc = 0x825BFE48; continue 'dispatch;
            }
            0x825BFE48 => {
    //   block [0x825BFE48..0x825BFE70)
	// 825BFE48: 57CA083C  slwi r10, r30, 1
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFE4C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BFE50: 7D1E5214  add r8, r30, r10
	ctx.r[8].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825BFE54: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFE58: 7C8AE214  add r4, r10, r28
	ctx.r[4].u64 = ctx.r[10].u64 + ctx.r[28].u64;
	// 825BFE5C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825BFE60: 80E40010  lwz r7, 0x10(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BFE64: 7F074800  cmpw cr6, r7, r9
	ctx.cr[6].compare_i32(ctx.r[7].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BFE68: 41990008  bgt cr6, 0x825bfe70
	if ctx.cr[6].gt {
	pc = 0x825BFE70; continue 'dispatch;
	}
	// 825BFE6C: 7F6ADB78  mr r10, r27
	ctx.r[10].u64 = ctx.r[27].u64;
	pc = 0x825BFE70; continue 'dispatch;
            }
            0x825BFE70 => {
    //   block [0x825BFE70..0x825BFEA8)
	// 825BFE70: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825BFE74: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825BFE78: 419A0030  beq cr6, 0x825bfea8
	if ctx.cr[6].eq {
	pc = 0x825BFEA8; continue 'dispatch;
	}
	// 825BFE7C: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFE80: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BFE84: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFE88: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 825BFE8C: 4BF09E7D  bl 0x824c9d08
	ctx.lr = 0x825BFE90;
	sub_824C9D08(ctx, base);
	// 825BFE90: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 825BFE94: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825BFE98: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 825BFE9C: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825BFEA0: 7FC90194  addze r30, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[30].s64 = tmp.s64;
	// 825BFEA4: 4198FFA4  blt cr6, 0x825bfe48
	if ctx.cr[6].lt {
	pc = 0x825BFE48; continue 'dispatch;
	}
	pc = 0x825BFEA8; continue 'dispatch;
            }
            0x825BFEA8 => {
    //   block [0x825BFEA8..0x825BFF34)
	// 825BFEA8: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFEAC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFEB0: 3BBF0004  addi r29, r31, 4
	ctx.r[29].s64 = ctx.r[31].s64 + 4;
	// 825BFEB4: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825BFEB8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BFEBC: 550B1838  slwi r11, r8, 3
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFEC0: 7FCBE214  add r30, r11, r28
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 825BFEC4: 387E0004  addi r3, r30, 4
	ctx.r[3].s64 = ctx.r[30].s64 + 4;
	// 825BFEC8: 7D2BE12E  stwx r9, r11, r28
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32), ctx.r[9].u32) };
	// 825BFECC: 4BF09EAD  bl 0x824c9d78
	ctx.lr = 0x825BFED0;
	sub_824C9D78(ctx, base);
	// 825BFED0: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825BFED4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825BFED8: 93A10050  stw r29, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[29].u32 ) };
	// 825BFEDC: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 825BFEE0: 93A10058  stw r29, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 825BFEE4: 90FE0010  stw r7, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[7].u32 ) };
	// 825BFEE8: 88DF0014  lbz r6, 0x14(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825BFEEC: 98DE0014  stb r6, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[6].u8 ) };
	// 825BFEF0: 88BF0015  lbz r5, 0x15(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825BFEF4: 98BE0015  stb r5, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[5].u8 ) };
	// 825BFEF8: 897F0016  lbz r11, 0x16(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825BFEFC: 997E0016  stb r11, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[11].u8 ) };
	// 825BFF00: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFF04: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825BFF08: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825BFF0C: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825BFF10: E8C10050  ld r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825BFF14: E8A10058  ld r5, 0x58(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BFF18: 4BEC0239  bl 0x82480150
	ctx.lr = 0x825BFF1C;
	sub_82480150(ctx, base);
	// 825BFF1C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825BFF20: 4BC5BE19  bl 0x8221bd38
	ctx.lr = 0x825BFF24;
	sub_8221BD38(ctx, base);
	// 825BFF24: 937F0008  stw r27, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825BFF28: 937F000C  stw r27, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 825BFF2C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825BFF30: 486E9524  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825BFF38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825BFF38 size=492
    let mut pc: u32 = 0x825BFF38;
    'dispatch: loop {
        match pc {
            0x825BFF38 => {
    //   block [0x825BFF38..0x825BFF80)
	// 825BFF38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825BFF3C: 486E94A9  bl 0x82ca93e4
	ctx.lr = 0x825BFF40;
	sub_82CA93D0(ctx, base);
	// 825BFF40: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825BFF44: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 825BFF48: 3A600018  li r19, 0x18
	ctx.r[19].s64 = 24;
	// 825BFF4C: FB010130  std r24, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[24].u64 ) };
	// 825BFF50: F8A10140  std r5, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[5].u64 ) };
	// 825BFF54: 82C10144  lwz r22, 0x144(r1)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 825BFF58: F8810138  std r4, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[4].u64 ) };
	// 825BFF5C: 82E10134  lwz r23, 0x134(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 825BFF60: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 825BFF64: 7D575850  subf r10, r23, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	// 825BFF68: 7D37B050  subf r9, r23, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[23].s64;
	// 825BFF6C: 7F4A9BD7  divw. r26, r10, r19
	ctx.r[26].s32 = ctx.r[10].s32 / ctx.r[19].s32;
	ctx.cr[0].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 825BFF70: 7D299BD6  divw r9, r9, r19
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[19].s32;
	// 825BFF74: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	// 825BFF78: 7D344B78  mr r20, r9
	ctx.r[20].u64 = ctx.r[9].u64;
	// 825BFF7C: 4182001C  beq 0x825bff98
	if ctx.cr[0].eq {
	pc = 0x825BFF98; continue 'dispatch;
	}
	pc = 0x825BFF80; continue 'dispatch;
            }
            0x825BFF80 => {
    //   block [0x825BFF80..0x825BFF98)
	// 825BFF80: 7D545BD6  divw r10, r20, r11
	ctx.r[10].s32 = ctx.r[20].s32 / ctx.r[11].s32;
	// 825BFF84: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825BFF88: 7D48A051  subf. r10, r8, r20
	ctx.r[10].s64 = ctx.r[20].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825BFF8C: 7D745B78  mr r20, r11
	ctx.r[20].u64 = ctx.r[11].u64;
	// 825BFF90: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825BFF94: 4082FFEC  bne 0x825bff80
	if !ctx.cr[0].eq {
	pc = 0x825BFF80; continue 'dispatch;
	}
	pc = 0x825BFF98; continue 'dispatch;
            }
            0x825BFF98 => {
    //   block [0x825BFF98..0x825BFFC4)
	// 825BFF98: 7F144800  cmpw cr6, r20, r9
	ctx.cr[6].compare_i32(ctx.r[20].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825BFF9C: 40980180  bge cr6, 0x825c011c
	if !ctx.cr[6].lt {
	pc = 0x825C011C; continue 'dispatch;
	}
	// 825BFFA0: 2F140000  cmpwi cr6, r20, 0
	ctx.cr[6].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 825BFFA4: 40990178  ble cr6, 0x825c011c
	if !ctx.cr[6].gt {
	pc = 0x825C011C; continue 'dispatch;
	}
	// 825BFFA8: 568B083C  slwi r11, r20, 1
	ctx.r[11].u32 = ctx.r[20].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFFAC: 574A083C  slwi r10, r26, 1
	ctx.r[10].u32 = ctx.r[26].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825BFFB0: 7D745A14  add r11, r20, r11
	ctx.r[11].u64 = ctx.r[20].u64 + ctx.r[11].u64;
	// 825BFFB4: 7D5A5214  add r10, r26, r10
	ctx.r[10].u64 = ctx.r[26].u64 + ctx.r[10].u64;
	// 825BFFB8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825BFFBC: 55551838  slwi r21, r10, 3
	ctx.r[21].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[21].u64 = ctx.r[21].u32 as u64;
	// 825BFFC0: 7F2BBA14  add r25, r11, r23
	ctx.r[25].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x825BFFC4; continue 'dispatch;
            }
            0x825BFFC4 => {
    //   block [0x825BFFC4..0x825BFFF4)
	// 825BFFC4: FB010058  std r24, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[24].u64 ) };
	// 825BFFC8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 825BFFCC: 9321005C  stw r25, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[25].u32 ) };
	// 825BFFD0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 825BFFD4: EBE10058  ld r31, 0x58(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825BFFD8: FBE10058  std r31, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u64 ) };
	// 825BFFDC: 4BF07075  bl 0x824c7050
	ctx.lr = 0x825BFFE0;
	sub_824C7050(ctx, base);
	// 825BFFE0: 7D79AA14  add r11, r25, r21
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[21].u64;
	// 825BFFE4: 7F0BB040  cmplw cr6, r11, r22
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[22].u32, &mut ctx.xer);
	// 825BFFE8: 409A000C  bne cr6, 0x825bfff4
	if !ctx.cr[6].eq {
	pc = 0x825BFFF4; continue 'dispatch;
	}
	// 825BFFEC: 39410130  addi r10, r1, 0x130
	ctx.r[10].s64 = ctx.r[1].s64 + 304;
	// 825BFFF0: 48000018  b 0x825c0008
	pc = 0x825C0008; continue 'dispatch;
            }
            0x825BFFF4 => {
    //   block [0x825BFFF4..0x825C0008)
	// 825BFFF4: FBE10050  std r31, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[31].u64 ) };
	// 825BFFF8: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825BFFFC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825C0000: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C0004: F9610070  std r11, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[11].u64 ) };
	pc = 0x825C0008; continue 'dispatch;
            }
            0x825C0008 => {
    //   block [0x825C0008..0x825C001C)
	// 825C0008: EB8A0000  ld r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C000C: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825C0010: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C0014: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825C0018: 419A00E4  beq cr6, 0x825c00fc
	if ctx.cr[6].eq {
	pc = 0x825C00FC; continue 'dispatch;
	}
	pc = 0x825C001C; continue 'dispatch;
            }
            0x825C001C => {
    //   block [0x825C001C..0x825C0070)
	// 825C001C: 83C1005C  lwz r30, 0x5c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825C0020: 3B7F0004  addi r27, r31, 4
	ctx.r[27].s64 = ctx.r[31].s64 + 4;
	// 825C0024: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0028: 3BBE0004  addi r29, r30, 4
	ctx.r[29].s64 = ctx.r[30].s64 + 4;
	// 825C002C: 7F1DD840  cmplw cr6, r29, r27
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[27].u32, &mut ctx.xer);
	// 825C0030: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 825C0034: 419A003C  beq cr6, 0x825c0070
	if ctx.cr[6].eq {
	pc = 0x825C0070; continue 'dispatch;
	}
	// 825C0038: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C003C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0040: 38610088  addi r3, r1, 0x88
	ctx.r[3].s64 = ctx.r[1].s64 + 136;
	// 825C0044: 93A10060  stw r29, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[29].u32 ) };
	// 825C0048: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 825C004C: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 825C0050: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0054: 9141006C  stw r10, 0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 825C0058: E8A10068  ld r5, 0x68(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 825C005C: E8C10060  ld r6, 0x60(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 825C0060: 4BEC00F1  bl 0x82480150
	ctx.lr = 0x825C0064;
	sub_82480150(ctx, base);
	// 825C0064: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 825C0068: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C006C: 4BF066ED  bl 0x824c6758
	ctx.lr = 0x825C0070;
	sub_824C6758(ctx, base);
	pc = 0x825C0070; continue 'dispatch;
            }
            0x825C0070 => {
    //   block [0x825C0070..0x825C00C0)
	// 825C0070: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0074: 7D3FB050  subf r9, r31, r22
	ctx.r[9].s64 = ctx.r[22].s64 - ctx.r[31].s64;
	// 825C0078: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825C007C: 7D699BD6  divw r11, r9, r19
	ctx.r[11].s32 = ctx.r[9].s32 / ctx.r[19].s32;
	// 825C0080: 7F1A5800  cmpw cr6, r26, r11
	ctx.cr[6].compare_i32(ctx.r[26].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C0084: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825C0088: 891F0014  lbz r8, 0x14(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C008C: 991E0014  stb r8, 0x14(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[8].u8 ) };
	// 825C0090: 88FF0015  lbz r7, 0x15(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C0094: 98FE0015  stb r7, 0x15(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(21 as u32), ctx.r[7].u8 ) };
	// 825C0098: 88DF0016  lbz r6, 0x16(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C009C: 98DE0016  stb r6, 0x16(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(22 as u32), ctx.r[6].u8 ) };
	// 825C00A0: 40980020  bge cr6, 0x825c00c0
	if !ctx.cr[6].lt {
	pc = 0x825C00C0; continue 'dispatch;
	}
	// 825C00A4: 7D75FA14  add r11, r21, r31
	ctx.r[11].u64 = ctx.r[21].u64 + ctx.r[31].u64;
	// 825C00A8: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825C00AC: 39410078  addi r10, r1, 0x78
	ctx.r[10].s64 = ctx.r[1].s64 + 120;
	// 825C00B0: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825C00B4: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C00B8: F9210078  std r9, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[9].u64 ) };
	// 825C00BC: 4800002C  b 0x825c00e8
	pc = 0x825C00E8; continue 'dispatch;
            }
            0x825C00C0 => {
    //   block [0x825C00C0..0x825C00E8)
	// 825C00C0: 7D6BD050  subf r11, r11, r26
	ctx.r[11].s64 = ctx.r[26].s64 - ctx.r[11].s64;
	// 825C00C4: FB010050  std r24, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[24].u64 ) };
	// 825C00C8: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
	// 825C00CC: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C00D0: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C00D4: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C00D8: 7D2BBA14  add r9, r11, r23
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	// 825C00DC: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825C00E0: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C00E4: F9010080  std r8, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[8].u64 ) };
	pc = 0x825C00E8; continue 'dispatch;
            }
            0x825C00E8 => {
    //   block [0x825C00E8..0x825C00FC)
	// 825C00E8: EB8A0000  ld r28, 0(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C00EC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825C00F0: 83E10054  lwz r31, 0x54(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C00F4: 7F1FC840  cmplw cr6, r31, r25
	ctx.cr[6].compare_u32(ctx.r[31].u32, ctx.r[25].u32, &mut ctx.xer);
	// 825C00F8: 409AFF24  bne cr6, 0x825c001c
	if !ctx.cr[6].eq {
	pc = 0x825C001C; continue 'dispatch;
	}
	pc = 0x825C00FC; continue 'dispatch;
            }
            0x825C00FC => {
    //   block [0x825C00FC..0x825C011C)
	// 825C00FC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 825C0100: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825C0104: 4BF09C05  bl 0x824c9d08
	ctx.lr = 0x825C0108;
	sub_824C9D08(ctx, base);
	// 825C0108: 38610094  addi r3, r1, 0x94
	ctx.r[3].s64 = ctx.r[1].s64 + 148;
	// 825C010C: 4BEBFE6D  bl 0x8247ff78
	ctx.lr = 0x825C0110;
	sub_8247FF78(ctx, base);
	// 825C0110: 3694FFFF  addic. r20, r20, -1
	ctx.xer.ca = (ctx.r[20].u32 > (!(-1 as u32)));
	ctx.r[20].s64 = ctx.r[20].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[20].s32, 0, &mut ctx.xer);
	// 825C0114: 3B39FFE8  addi r25, r25, -0x18
	ctx.r[25].s64 = ctx.r[25].s64 + -24;
	// 825C0118: 4181FEAC  bgt 0x825bffc4
	if ctx.cr[0].gt {
	pc = 0x825BFFC4; continue 'dispatch;
	}
	pc = 0x825C011C; continue 'dispatch;
            }
            0x825C011C => {
    //   block [0x825C011C..0x825C0124)
	// 825C011C: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825C0120: 486E9314  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C0128 size=348
    let mut pc: u32 = 0x825C0128;
    'dispatch: loop {
        match pc {
            0x825C0128 => {
    //   block [0x825C0128..0x825C015C)
	// 825C0128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C012C: 486E92DD  bl 0x82ca9408
	ctx.lr = 0x825C0130;
	sub_82CA93D0(ctx, base);
	// 825C0130: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0134: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825C0138: F8610090  std r3, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[3].u64 ) };
	// 825C013C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 825C0140: 83A10094  lwz r29, 0x94(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) } as u64;
	// 825C0144: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825C0148: 7CDF3378  mr r31, r6
	ctx.r[31].u64 = ctx.r[6].u64;
	// 825C014C: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 825C0150: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C0154: 7FC90194  addze r30, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[30].s64 = tmp.s64;
	// 825C0158: 40980084  bge cr6, 0x825c01dc
	if !ctx.cr[6].lt {
	pc = 0x825C01DC; continue 'dispatch;
	}
	pc = 0x825C015C; continue 'dispatch;
            }
            0x825C015C => {
    //   block [0x825C015C..0x825C0194)
	// 825C015C: 57C9103A  slwi r9, r30, 2
	ctx.r[9].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C0160: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0164: 7D3E4A14  add r9, r30, r9
	ctx.r[9].u64 = ctx.r[30].u64 + ctx.r[9].u64;
	// 825C0168: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C016C: 7C89EA14  add r4, r9, r29
	ctx.r[4].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C0170: 7D29E82E  lwzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 825C0174: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 825C0178: 409A001C  bne cr6, 0x825c0194
	if !ctx.cr[6].eq {
	pc = 0x825C0194; continue 'dispatch;
	}
	// 825C017C: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0180: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0184: 7D0A4810  subfc r8, r10, r9
	ctx.xer.ca = ctx.r[9].u32 >= ctx.r[10].u32;
	ctx.r[8].s64 = ctx.r[9].s64 - ctx.r[10].s64;
	// 825C0188: 7CE84110  subfe r7, r8, r8
	let x = (!ctx.r[8].u32);
	let y = ctx.r[8].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[7].u32 = res;
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 825C018C: 54EA07FE  clrlwi r10, r7, 0x1f
	ctx.r[10].u64 = ctx.r[7].u32 as u64 & 0x00000001u64;
	// 825C0190: 48000014  b 0x825c01a4
	pc = 0x825C01A4; continue 'dispatch;
            }
            0x825C0194 => {
    //   block [0x825C0194..0x825C01A0)
	// 825C0194: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825C0198: 41980008  blt cr6, 0x825c01a0
	if ctx.cr[6].lt {
	pc = 0x825C01A0; continue 'dispatch;
	}
	// 825C019C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825C01A0; continue 'dispatch;
            }
            0x825C01A0 => {
    //   block [0x825C01A0..0x825C01A4)
	// 825C01A0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	pc = 0x825C01A4; continue 'dispatch;
            }
            0x825C01A4 => {
    //   block [0x825C01A4..0x825C01DC)
	// 825C01A4: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825C01A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C01AC: 419A0030  beq cr6, 0x825c01dc
	if ctx.cr[6].eq {
	pc = 0x825C01DC; continue 'dispatch;
	}
	// 825C01B0: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C01B4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C01B8: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C01BC: 7C6BEA14  add r3, r11, r29
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825C01C0: 4BFFCE99  bl 0x825bd058
	ctx.lr = 0x825C01C4;
	sub_825BD058(ctx, base);
	// 825C01C4: 395EFFFF  addi r10, r30, -1
	ctx.r[10].s64 = ctx.r[30].s64 + -1;
	// 825C01C8: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825C01CC: 7D490E70  srawi r9, r10, 1
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[10].s32 >> 1) as i64;
	// 825C01D0: 7F1C5800  cmpw cr6, r28, r11
	ctx.cr[6].compare_i32(ctx.r[28].s32, ctx.r[11].s32, &mut ctx.xer);
	// 825C01D4: 7FC90194  addze r30, r9
	tmp.s64 = ctx.r[9].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[9].u32);
	ctx.r[30].s64 = tmp.s64;
	// 825C01D8: 4198FF84  blt cr6, 0x825c015c
	if ctx.cr[6].lt {
	pc = 0x825C015C; continue 'dispatch;
	}
	pc = 0x825C01DC; continue 'dispatch;
            }
            0x825C01DC => {
    //   block [0x825C01DC..0x825C0284)
	// 825C01DC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C01E0: 811F0000  lwz r8, 0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C01E4: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 825C01E8: 7CEB4A14  add r7, r11, r9
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C01EC: 38CA0010  addi r6, r10, 0x10
	ctx.r[6].s64 = ctx.r[10].s64 + 16;
	// 825C01F0: 54EB1838  slwi r11, r7, 3
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C01F4: 7D6BEA14  add r11, r11, r29
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 825C01F8: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825C01FC: 38AA0010  addi r5, r10, 0x10
	ctx.r[5].s64 = ctx.r[10].s64 + 16;
	// 825C0200: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C0204: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0208: 908B0004  stw r4, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[4].u32 ) };
	// 825C020C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0210: 906B0008  stw r3, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[3].u32 ) };
	// 825C0214: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0218: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C021C: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0220: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825C0224: 893F0014  lbz r9, 0x14(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0228: 992B0014  stb r9, 0x14(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[9].u8 ) };
	// 825C022C: 891F0015  lbz r8, 0x15(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C0230: 990B0015  stb r8, 0x15(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(21 as u32), ctx.r[8].u8 ) };
	// 825C0234: 88FF0016  lbz r7, 0x16(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C0238: 98EB0016  stb r7, 0x16(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(22 as u32), ctx.r[7].u8 ) };
	// 825C023C: 88DF0017  lbz r6, 0x17(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(23 as u32) ) } as u64;
	// 825C0240: 98CB0017  stb r6, 0x17(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(23 as u32), ctx.r[6].u8 ) };
	// 825C0244: 88BF0018  lbz r5, 0x18(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0248: 98AB0018  stb r5, 0x18(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[5].u8 ) };
	// 825C024C: 889F0019  lbz r4, 0x19(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 825C0250: 988B0019  stb r4, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[4].u8 ) };
	// 825C0254: 887F001A  lbz r3, 0x1a(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 825C0258: 986B001A  stb r3, 0x1a(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(26 as u32), ctx.r[3].u8 ) };
	// 825C025C: 895F001B  lbz r10, 0x1b(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(27 as u32) ) } as u64;
	// 825C0260: 994B001B  stb r10, 0x1b(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(27 as u32), ctx.r[10].u8 ) };
	// 825C0264: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0268: D1AB001C  stfs f13, 0x1c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825C026C: 813F0020  lwz r9, 0x20(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825C0270: 912B0020  stw r9, 0x20(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), ctx.r[9].u32 ) };
	// 825C0274: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C0278: D18B0024  stfs f12, 0x24(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825C027C: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C0280: 486E91D8  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0288(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C0288 size=636
    let mut pc: u32 = 0x825C0288;
    'dispatch: loop {
        match pc {
            0x825C0288 => {
    //   block [0x825C0288..0x825C02D0)
	// 825C0288: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C028C: 486E9159  bl 0x82ca93e4
	ctx.lr = 0x825C0290;
	sub_82CA93D0(ctx, base);
	// 825C0290: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0294: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825C0298: 3B400028  li r26, 0x28
	ctx.r[26].s64 = 40;
	// 825C029C: FB810130  std r28, 0x130(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), ctx.r[28].u64 ) };
	// 825C02A0: F8A10140  std r5, 0x140(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(320 as u32), ctx.r[5].u64 ) };
	// 825C02A4: 83A10144  lwz r29, 0x144(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 825C02A8: F8810138  std r4, 0x138(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(312 as u32), ctx.r[4].u64 ) };
	// 825C02AC: 83610134  lwz r27, 0x134(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(308 as u32) ) } as u64;
	// 825C02B0: 8161013C  lwz r11, 0x13c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(316 as u32) ) } as u64;
	// 825C02B4: 7D5B5850  subf r10, r27, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[27].s64;
	// 825C02B8: 7D3BE850  subf r9, r27, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[27].s64;
	// 825C02BC: 7FCAD3D7  divw. r30, r10, r26
	ctx.r[30].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825C02C0: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825C02C4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 825C02C8: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 825C02CC: 4182001C  beq 0x825c02e8
	if ctx.cr[0].eq {
	pc = 0x825C02E8; continue 'dispatch;
	}
	pc = 0x825C02D0; continue 'dispatch;
            }
            0x825C02D0 => {
    //   block [0x825C02D0..0x825C02E8)
	// 825C02D0: 7D585BD6  divw r10, r24, r11
	ctx.r[10].s32 = ctx.r[24].s32 / ctx.r[11].s32;
	// 825C02D4: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825C02D8: 7D48C051  subf. r10, r8, r24
	ctx.r[10].s64 = ctx.r[24].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C02DC: 7D785B78  mr r24, r11
	ctx.r[24].u64 = ctx.r[11].u64;
	// 825C02E0: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C02E4: 4082FFEC  bne 0x825c02d0
	if !ctx.cr[0].eq {
	pc = 0x825C02D0; continue 'dispatch;
	}
	pc = 0x825C02E8; continue 'dispatch;
            }
            0x825C02E8 => {
    //   block [0x825C02E8..0x825C0314)
	// 825C02E8: 7F184800  cmpw cr6, r24, r9
	ctx.cr[6].compare_i32(ctx.r[24].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C02EC: 40980210  bge cr6, 0x825c04fc
	if !ctx.cr[6].lt {
	pc = 0x825C04FC; continue 'dispatch;
	}
	// 825C02F0: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825C02F4: 40990208  ble cr6, 0x825c04fc
	if !ctx.cr[6].gt {
	pc = 0x825C04FC; continue 'dispatch;
	}
	// 825C02F8: 570B103A  slwi r11, r24, 2
	ctx.r[11].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C02FC: 57CA103A  slwi r10, r30, 2
	ctx.r[10].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C0300: 7D785A14  add r11, r24, r11
	ctx.r[11].u64 = ctx.r[24].u64 + ctx.r[11].u64;
	// 825C0304: 7D5E5214  add r10, r30, r10
	ctx.r[10].u64 = ctx.r[30].u64 + ctx.r[10].u64;
	// 825C0308: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C030C: 55591838  slwi r25, r10, 3
	ctx.r[25].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[25].u64 = ctx.r[25].u32 as u64;
	// 825C0310: 7FEBDA14  add r31, r11, r27
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	pc = 0x825C0314; continue 'dispatch;
            }
            0x825C0314 => {
    //   block [0x825C0314..0x825C03BC)
	// 825C0314: FB810058  std r28, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[28].u64 ) };
	// 825C0318: 395F0004  addi r10, r31, 4
	ctx.r[10].s64 = ctx.r[31].s64 + 4;
	// 825C031C: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 825C0320: 7D7FCA14  add r11, r31, r25
	ctx.r[11].u64 = ctx.r[31].u64 + ctx.r[25].u64;
	// 825C0324: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0328: C01F000C  lfs f0, 0xc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C032C: 813F0004  lwz r9, 4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0330: C1BF001C  lfs f13, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0334: 811F0008  lwz r8, 8(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0338: C19F0024  lfs f12, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C033C: 80FF0010  lwz r7, 0x10(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0340: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 825C0344: 88DF0016  lbz r6, 0x16(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C0348: D1A1009C  stfs f13, 0x9c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 825C034C: 91410080  stw r10, 0x80(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 825C0350: D18100A4  stfs f12, 0xa4(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 825C0354: 88BF0015  lbz r5, 0x15(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C0358: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 825C035C: 889F0014  lbz r4, 0x14(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0360: 887F0017  lbz r3, 0x17(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(23 as u32) ) } as u64;
	// 825C0364: 8AFF001A  lbz r23, 0x1a(r31)
	ctx.r[23].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(26 as u32) ) } as u64;
	// 825C0368: 8ADF0019  lbz r22, 0x19(r31)
	ctx.r[22].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(25 as u32) ) } as u64;
	// 825C036C: 8ABF0018  lbz r21, 0x18(r31)
	ctx.r[21].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0370: 8A9F001B  lbz r20, 0x1b(r31)
	ctx.r[20].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(27 as u32) ) } as u64;
	// 825C0374: 827F0020  lwz r19, 0x20(r31)
	ctx.r[19].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 825C0378: 91210084  stw r9, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 825C037C: 91010088  stw r8, 0x88(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u32 ) };
	// 825C0380: 90E10090  stw r7, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u32 ) };
	// 825C0384: 98C10096  stb r6, 0x96(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(150 as u32), ctx.r[6].u8 ) };
	// 825C0388: 98A10095  stb r5, 0x95(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(149 as u32), ctx.r[5].u8 ) };
	// 825C038C: E9410058  ld r10, 0x58(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825C0390: 98810094  stb r4, 0x94(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[4].u8 ) };
	// 825C0394: 98610097  stb r3, 0x97(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(151 as u32), ctx.r[3].u8 ) };
	// 825C0398: 9AE1009A  stb r23, 0x9a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(154 as u32), ctx.r[23].u8 ) };
	// 825C039C: 9AC10099  stb r22, 0x99(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(153 as u32), ctx.r[22].u8 ) };
	// 825C03A0: 9AA10098  stb r21, 0x98(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[21].u8 ) };
	// 825C03A4: 9A81009B  stb r20, 0x9b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(155 as u32), ctx.r[20].u8 ) };
	// 825C03A8: 926100A0  stw r19, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[19].u32 ) };
	// 825C03AC: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 825C03B0: 409A000C  bne cr6, 0x825c03bc
	if !ctx.cr[6].eq {
	pc = 0x825C03BC; continue 'dispatch;
	}
	// 825C03B4: 39410130  addi r10, r1, 0x130
	ctx.r[10].s64 = ctx.r[1].s64 + 304;
	// 825C03B8: 48000018  b 0x825c03d0
	pc = 0x825C03D0; continue 'dispatch;
            }
            0x825C03BC => {
    //   block [0x825C03BC..0x825C03D0)
	// 825C03BC: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 825C03C0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 825C03C4: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825C03C8: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C03CC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	pc = 0x825C03D0; continue 'dispatch;
            }
            0x825C03D0 => {
    //   block [0x825C03D0..0x825C03E4)
	// 825C03D0: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C03D4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825C03D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C03DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825C03E0: 419A0104  beq cr6, 0x825c04e4
	if ctx.cr[6].eq {
	pc = 0x825C04E4; continue 'dispatch;
	}
	pc = 0x825C03E4; continue 'dispatch;
            }
            0x825C03E4 => {
    //   block [0x825C03E4..0x825C04A8)
	// 825C03E4: 8141005C  lwz r10, 0x5c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825C03E8: 38EB0004  addi r7, r11, 4
	ctx.r[7].s64 = ctx.r[11].s64 + 4;
	// 825C03EC: 80AB0000  lwz r5, 0(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C03F0: 7D2BE850  subf r9, r11, r29
	ctx.r[9].s64 = ctx.r[29].s64 - ctx.r[11].s64;
	// 825C03F4: 38CA0004  addi r6, r10, 4
	ctx.r[6].s64 = ctx.r[10].s64 + 4;
	// 825C03F8: F9010058  std r8, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[8].u64 ) };
	// 825C03FC: 38870010  addi r4, r7, 0x10
	ctx.r[4].s64 = ctx.r[7].s64 + 16;
	// 825C0400: 38660010  addi r3, r6, 0x10
	ctx.r[3].s64 = ctx.r[6].s64 + 16;
	// 825C0404: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825C0408: 90AA0000  stw r5, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[5].u32 ) };
	// 825C040C: 80EB0004  lwz r7, 4(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0410: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C0414: 90EA0004  stw r7, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[7].u32 ) };
	// 825C0418: 80CB0008  lwz r6, 8(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C041C: 90CA0008  stw r6, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[6].u32 ) };
	// 825C0420: C00B000C  lfs f0, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0424: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0428: 80AB0010  lwz r5, 0x10(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C042C: 90AA0010  stw r5, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[5].u32 ) };
	// 825C0430: 888B0014  lbz r4, 0x14(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0434: 988A0014  stb r4, 0x14(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[4].u8 ) };
	// 825C0438: 886B0015  lbz r3, 0x15(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C043C: 986A0015  stb r3, 0x15(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(21 as u32), ctx.r[3].u8 ) };
	// 825C0440: 88EB0016  lbz r7, 0x16(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C0444: 98EA0016  stb r7, 0x16(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(22 as u32), ctx.r[7].u8 ) };
	// 825C0448: 88CB0017  lbz r6, 0x17(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(23 as u32) ) } as u64;
	// 825C044C: 98CA0017  stb r6, 0x17(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(23 as u32), ctx.r[6].u8 ) };
	// 825C0450: 88AB0018  lbz r5, 0x18(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0454: 98AA0018  stb r5, 0x18(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[5].u8 ) };
	// 825C0458: 888B0019  lbz r4, 0x19(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(25 as u32) ) } as u64;
	// 825C045C: 988A0019  stb r4, 0x19(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(25 as u32), ctx.r[4].u8 ) };
	// 825C0460: 886B001A  lbz r3, 0x1a(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(26 as u32) ) } as u64;
	// 825C0464: 986A001A  stb r3, 0x1a(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(26 as u32), ctx.r[3].u8 ) };
	// 825C0468: 88EB001B  lbz r7, 0x1b(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(27 as u32) ) } as u64;
	// 825C046C: 98EA001B  stb r7, 0x1b(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(27 as u32), ctx.r[7].u8 ) };
	// 825C0470: C1AB001C  lfs f13, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0474: D1AA001C  stfs f13, 0x1c(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 825C0478: 80CB0020  lwz r6, 0x20(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 825C047C: 90CA0020  stw r6, 0x20(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(32 as u32), ctx.r[6].u32 ) };
	// 825C0480: C18B0024  lfs f12, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C0484: D18A0024  stfs f12, 0x24(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 825C0488: 40980020  bge cr6, 0x825c04a8
	if !ctx.cr[6].lt {
	pc = 0x825C04A8; continue 'dispatch;
	}
	// 825C048C: 7D795A14  add r11, r25, r11
	ctx.r[11].u64 = ctx.r[25].u64 + ctx.r[11].u64;
	// 825C0490: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825C0494: 39410068  addi r10, r1, 0x68
	ctx.r[10].s64 = ctx.r[1].s64 + 104;
	// 825C0498: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 825C049C: E9210050  ld r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C04A0: F9210068  std r9, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[9].u64 ) };
	// 825C04A4: 4800002C  b 0x825c04d0
	pc = 0x825C04D0; continue 'dispatch;
            }
            0x825C04A8 => {
    //   block [0x825C04A8..0x825C04D0)
	// 825C04A8: 7D69F050  subf r11, r9, r30
	ctx.r[11].s64 = ctx.r[30].s64 - ctx.r[9].s64;
	// 825C04AC: FB810050  std r28, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u64 ) };
	// 825C04B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 825C04B4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C04B8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C04BC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C04C0: 7D2BDA14  add r9, r11, r27
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[27].u64;
	// 825C04C4: 91210054  stw r9, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[9].u32 ) };
	// 825C04C8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C04CC: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	pc = 0x825C04D0; continue 'dispatch;
            }
            0x825C04D0 => {
    //   block [0x825C04D0..0x825C04E4)
	// 825C04D0: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C04D4: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 825C04D8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C04DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825C04E0: 409AFF04  bne cr6, 0x825c03e4
	if !ctx.cr[6].eq {
	pc = 0x825C03E4; continue 'dispatch;
	}
	pc = 0x825C04E4; continue 'dispatch;
            }
            0x825C04E4 => {
    //   block [0x825C04E4..0x825C04FC)
	// 825C04E4: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 825C04E8: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825C04EC: 4BFFCB6D  bl 0x825bd058
	ctx.lr = 0x825C04F0;
	sub_825BD058(ctx, base);
	// 825C04F0: 3718FFFF  addic. r24, r24, -1
	ctx.xer.ca = (ctx.r[24].u32 > (!(-1 as u32)));
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 825C04F4: 3BFFFFD8  addi r31, r31, -0x28
	ctx.r[31].s64 = ctx.r[31].s64 + -40;
	// 825C04F8: 4181FE1C  bgt 0x825c0314
	if ctx.cr[0].gt {
	pc = 0x825C0314; continue 'dispatch;
	}
	pc = 0x825C04FC; continue 'dispatch;
            }
            0x825C04FC => {
    //   block [0x825C04FC..0x825C0504)
	// 825C04FC: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 825C0500: 486E8F34  b 0x82ca9434
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0508(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C0508 size=388
    let mut pc: u32 = 0x825C0508;
    'dispatch: loop {
        match pc {
            0x825C0508 => {
    //   block [0x825C0508..0x825C0548)
	// 825C0508: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C050C: 486E8EF1  bl 0x82ca93fc
	ctx.lr = 0x825C0510;
	sub_82CA93D0(ctx, base);
	// 825C0510: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825C0514: 3B40000C  li r26, 0xc
	ctx.r[26].s64 = 12;
	// 825C0518: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 825C051C: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 825C0520: 80810024  lwz r4, 0x24(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C0524: 83E10014  lwz r31, 0x14(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0528: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C052C: 7D5F5850  subf r10, r31, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[31].s64;
	// 825C0530: 7D3F2050  subf r9, r31, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[31].s64;
	// 825C0534: 7CCAD3D7  divw. r6, r10, r26
	ctx.r[6].s32 = ctx.r[10].s32 / ctx.r[26].s32;
	ctx.cr[0].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 825C0538: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825C053C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825C0540: 7D254B78  mr r5, r9
	ctx.r[5].u64 = ctx.r[9].u64;
	// 825C0544: 4182001C  beq 0x825c0560
	if ctx.cr[0].eq {
	pc = 0x825C0560; continue 'dispatch;
	}
	pc = 0x825C0548; continue 'dispatch;
            }
            0x825C0548 => {
    //   block [0x825C0548..0x825C0560)
	// 825C0548: 7D455BD6  divw r10, r5, r11
	ctx.r[10].s32 = ctx.r[5].s32 / ctx.r[11].s32;
	// 825C054C: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825C0550: 7D482851  subf. r10, r8, r5
	ctx.r[10].s64 = ctx.r[5].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C0554: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 825C0558: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C055C: 4082FFEC  bne 0x825c0548
	if !ctx.cr[0].eq {
	pc = 0x825C0548; continue 'dispatch;
	}
	pc = 0x825C0560; continue 'dispatch;
            }
            0x825C0560 => {
    //   block [0x825C0560..0x825C058C)
	// 825C0560: 7F054800  cmpw cr6, r5, r9
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C0564: 40980124  bge cr6, 0x825c0688
	if !ctx.cr[6].lt {
	pc = 0x825C0688; continue 'dispatch;
	}
	// 825C0568: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825C056C: 4099011C  ble cr6, 0x825c0688
	if !ctx.cr[6].gt {
	pc = 0x825C0688; continue 'dispatch;
	}
	// 825C0570: 54AB083C  slwi r11, r5, 1
	ctx.r[11].u32 = ctx.r[5].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0574: 54CA083C  slwi r10, r6, 1
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C0578: 7D655A14  add r11, r5, r11
	ctx.r[11].u64 = ctx.r[5].u64 + ctx.r[11].u64;
	// 825C057C: 7D465214  add r10, r6, r10
	ctx.r[10].u64 = ctx.r[6].u64 + ctx.r[10].u64;
	// 825C0580: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0584: 555E103A  slwi r30, r10, 2
	ctx.r[30].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 825C0588: 7CEBFA14  add r7, r11, r31
	ctx.r[7].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	pc = 0x825C058C; continue 'dispatch;
            }
            0x825C058C => {
    //   block [0x825C058C..0x825C05BC)
	// 825C058C: F861FF98  std r3, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[3].u64 ) };
	// 825C0590: 7D67F214  add r11, r7, r30
	ctx.r[11].u64 = ctx.r[7].u64 + ctx.r[30].u64;
	// 825C0594: 90E1FF9C  stw r7, -0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-100 as u32), ctx.r[7].u32 ) };
	// 825C0598: E941FF98  ld r10, -0x68(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-104 as u32) ) };
	// 825C059C: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 825C05A0: 83A70000  lwz r29, 0(r7)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C05A4: 83870004  lwz r28, 4(r7)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C05A8: 83670008  lwz r27, 8(r7)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C05AC: F941FF98  std r10, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[10].u64 ) };
	// 825C05B0: 409A000C  bne cr6, 0x825c05bc
	if !ctx.cr[6].eq {
	pc = 0x825C05BC; continue 'dispatch;
	}
	// 825C05B4: 39410010  addi r10, r1, 0x10
	ctx.r[10].s64 = ctx.r[1].s64 + 16;
	// 825C05B8: 48000018  b 0x825c05d0
	pc = 0x825C05D0; continue 'dispatch;
            }
            0x825C05BC => {
    //   block [0x825C05BC..0x825C05D0)
	// 825C05BC: F941FF90  std r10, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[10].u64 ) };
	// 825C05C0: 3941FFA0  addi r10, r1, -0x60
	ctx.r[10].s64 = ctx.r[1].s64 + -96;
	// 825C05C4: 9161FF94  stw r11, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[11].u32 ) };
	// 825C05C8: E961FF90  ld r11, -0x70(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 825C05CC: F961FFA0  std r11, -0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.r[11].u64 ) };
	pc = 0x825C05D0; continue 'dispatch;
            }
            0x825C05D0 => {
    //   block [0x825C05D0..0x825C05E4)
	// 825C05D0: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C05D4: F901FF90  std r8, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[8].u64 ) };
	// 825C05D8: 8161FF94  lwz r11, -0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-108 as u32) ) } as u64;
	// 825C05DC: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C05E0: 419A008C  beq cr6, 0x825c066c
	if ctx.cr[6].eq {
	pc = 0x825C066C; continue 'dispatch;
	}
	pc = 0x825C05E4; continue 'dispatch;
            }
            0x825C05E4 => {
    //   block [0x825C05E4..0x825C0630)
	// 825C05E4: 8141FF9C  lwz r10, -0x64(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-100 as u32) ) } as u64;
	// 825C05E8: 7D2B2050  subf r9, r11, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[11].s64;
	// 825C05EC: 832B0000  lwz r25, 0(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C05F0: 7D29D3D6  divw r9, r9, r26
	ctx.r[9].s32 = ctx.r[9].s32 / ctx.r[26].s32;
	// 825C05F4: F901FF98  std r8, -0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-104 as u32), ctx.r[8].u64 ) };
	// 825C05F8: 7F064800  cmpw cr6, r6, r9
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C05FC: 932A0000  stw r25, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 825C0600: 832B0004  lwz r25, 4(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0604: 932A0004  stw r25, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[25].u32 ) };
	// 825C0608: 832B0008  lwz r25, 8(r11)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C060C: 932A0008  stw r25, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[25].u32 ) };
	// 825C0610: 40980020  bge cr6, 0x825c0630
	if !ctx.cr[6].lt {
	pc = 0x825C0630; continue 'dispatch;
	}
	// 825C0614: 7D7E5A14  add r11, r30, r11
	ctx.r[11].u64 = ctx.r[30].u64 + ctx.r[11].u64;
	// 825C0618: F901FF90  std r8, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[8].u64 ) };
	// 825C061C: 3941FFA8  addi r10, r1, -0x58
	ctx.r[10].s64 = ctx.r[1].s64 + -88;
	// 825C0620: 9161FF94  stw r11, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[11].u32 ) };
	// 825C0624: E921FF90  ld r9, -0x70(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 825C0628: F921FFA8  std r9, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.r[9].u64 ) };
	// 825C062C: 4800002C  b 0x825c0658
	pc = 0x825C0658; continue 'dispatch;
            }
            0x825C0630 => {
    //   block [0x825C0630..0x825C0658)
	// 825C0630: F861FF90  std r3, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[3].u64 ) };
	// 825C0634: 7D693050  subf r11, r9, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[9].s64;
	// 825C0638: 3941FFB0  addi r10, r1, -0x50
	ctx.r[10].s64 = ctx.r[1].s64 + -80;
	// 825C063C: 5569083C  slwi r9, r11, 1
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 825C0640: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 825C0644: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0648: 7D2BFA14  add r9, r11, r31
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C064C: 9121FF94  stw r9, -0x6c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-108 as u32), ctx.r[9].u32 ) };
	// 825C0650: E901FF90  ld r8, -0x70(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) };
	// 825C0654: F901FFB0  std r8, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[8].u64 ) };
	pc = 0x825C0658; continue 'dispatch;
            }
            0x825C0658 => {
    //   block [0x825C0658..0x825C066C)
	// 825C0658: E90A0000  ld r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C065C: F901FF90  std r8, -0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[8].u64 ) };
	// 825C0660: 8161FF94  lwz r11, -0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-108 as u32) ) } as u64;
	// 825C0664: 7F0B3840  cmplw cr6, r11, r7
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[7].u32, &mut ctx.xer);
	// 825C0668: 409AFF7C  bne cr6, 0x825c05e4
	if !ctx.cr[6].eq {
	pc = 0x825C05E4; continue 'dispatch;
	}
	pc = 0x825C066C; continue 'dispatch;
            }
            0x825C066C => {
    //   block [0x825C066C..0x825C0688)
	// 825C066C: 8161FF9C  lwz r11, -0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-100 as u32) ) } as u64;
	// 825C0670: 34A5FFFF  addic. r5, r5, -1
	ctx.xer.ca = (ctx.r[5].u32 > (!(-1 as u32)));
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 825C0674: 38E7FFF4  addi r7, r7, -0xc
	ctx.r[7].s64 = ctx.r[7].s64 + -12;
	// 825C0678: 93AB0000  stw r29, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825C067C: 938B0004  stw r28, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825C0680: 936B0008  stw r27, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[27].u32 ) };
	// 825C0684: 4181FF08  bgt 0x825c058c
	if ctx.cr[0].gt {
	pc = 0x825C058C; continue 'dispatch;
	}
	pc = 0x825C0688; continue 'dispatch;
            }
            0x825C0688 => {
    //   block [0x825C0688..0x825C068C)
	// 825C0688: 486E8DC4  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0690(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C0690 size=312
    let mut pc: u32 = 0x825C0690;
    'dispatch: loop {
        match pc {
            0x825C0690 => {
    //   block [0x825C0690..0x825C06B0)
	// 825C0690: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 825C0694: 3964FFFF  addi r11, r4, -1
	ctx.r[11].s64 = ctx.r[4].s64 + -1;
	// 825C0698: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825C069C: 80E10014  lwz r7, 0x14(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C06A0: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825C06A4: 7D6A0E70  srawi r10, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C06A8: 7D2A0194  addze r9, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[9].s64 = tmp.s64;
	// 825C06AC: 409800A4  bge cr6, 0x825c0750
	if !ctx.cr[6].lt {
	pc = 0x825C0750; continue 'dispatch;
	}
	pc = 0x825C06B0; continue 'dispatch;
            }
            0x825C06B0 => {
    //   block [0x825C06B0..0x825C0750)
	// 825C06B0: 552B2834  slwi r11, r9, 5
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C06B4: 81460000  lwz r10, 0(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C06B8: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825C06BC: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C06C0: 7F085040  cmplw cr6, r8, r10
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[10].u32, &mut ctx.xer);
	// 825C06C4: 4098008C  bge cr6, 0x825c0750
	if !ctx.cr[6].lt {
	pc = 0x825C0750; continue 'dispatch;
	}
	// 825C06C8: 548A2834  slwi r10, r4, 5
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C06CC: 5503003E  slwi r3, r8, 0
	ctx.r[3].u32 = ctx.r[8].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 825C06D0: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 825C06D4: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825C06D8: 3BE9FFFF  addi r31, r9, -1
	ctx.r[31].s64 = ctx.r[9].s64 + -1;
	// 825C06DC: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 825C06E0: 390A0004  addi r8, r10, 4
	ctx.r[8].s64 = ctx.r[10].s64 + 4;
	// 825C06E4: 906A0000  stw r3, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 825C06E8: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 825C06EC: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C06F0: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 825C06F4: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 825C06F8: 7FE30E70  srawi r3, r31, 1
	ctx.xer.ca = (ctx.r[31].s32 < 0) && ((ctx.r[31].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[3].s64 = (ctx.r[31].s32 >> 1) as i64;
	// 825C06FC: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0700: 7D230194  addze r9, r3
	tmp.s64 = ctx.r[3].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[3].u32);
	ctx.r[9].s64 = tmp.s64;
	// 825C0704: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825C0708: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C070C: D00A000C  stfs f0, 0xc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0710: 886B0010  lbz r3, 0x10(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0714: 986A0010  stb r3, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[3].u8 ) };
	// 825C0718: 7F052000  cmpw cr6, r5, r4
	ctx.cr[6].compare_i32(ctx.r[5].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825C071C: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0720: 990A0011  stb r8, 0x11(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(17 as u32), ctx.r[8].u8 ) };
	// 825C0724: 886B0012  lbz r3, 0x12(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C0728: 986A0012  stb r3, 0x12(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[3].u8 ) };
	// 825C072C: 890B0013  lbz r8, 0x13(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0730: 990A0013  stb r8, 0x13(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825C0734: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0738: D1AA0014  stfs f13, 0x14(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C073C: 806B0018  lwz r3, 0x18(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0740: 906A0018  stw r3, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[3].u32 ) };
	// 825C0744: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C0748: 996A001C  stb r11, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 825C074C: 4198FF64  blt cr6, 0x825c06b0
	if ctx.cr[6].lt {
	pc = 0x825C06B0; continue 'dispatch;
	}
	pc = 0x825C0750; continue 'dispatch;
            }
            0x825C0750 => {
    //   block [0x825C0750..0x825C07C8)
	// 825C0750: 548B2834  slwi r11, r4, 5
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0754: 81260000  lwz r9, 0(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0758: 39460004  addi r10, r6, 4
	ctx.r[10].s64 = ctx.r[6].s64 + 4;
	// 825C075C: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 825C0760: 390A000C  addi r8, r10, 0xc
	ctx.r[8].s64 = ctx.r[10].s64 + 12;
	// 825C0764: 394B0004  addi r10, r11, 4
	ctx.r[10].s64 = ctx.r[11].s64 + 4;
	// 825C0768: 38EA000C  addi r7, r10, 0xc
	ctx.r[7].s64 = ctx.r[10].s64 + 12;
	// 825C076C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 825C0770: 80A60004  lwz r5, 4(r6)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0774: 90AB0004  stw r5, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[5].u32 ) };
	// 825C0778: 80860008  lwz r4, 8(r6)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C077C: 908B0008  stw r4, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[4].u32 ) };
	// 825C0780: C006000C  lfs f0, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0784: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0788: 88660010  lbz r3, 0x10(r6)
	ctx.r[3].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C078C: 986B0010  stb r3, 0x10(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[3].u8 ) };
	// 825C0790: 89460011  lbz r10, 0x11(r6)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0794: 994B0011  stb r10, 0x11(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 825C0798: 89260012  lbz r9, 0x12(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C079C: 992B0012  stb r9, 0x12(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(18 as u32), ctx.r[9].u8 ) };
	// 825C07A0: 89060013  lbz r8, 0x13(r6)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C07A4: 990B0013  stb r8, 0x13(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825C07A8: C1A60014  lfs f13, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C07AC: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C07B0: 80E60018  lwz r7, 0x18(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C07B4: 90EB0018  stw r7, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[7].u32 ) };
	// 825C07B8: 88C6001C  lbz r6, 0x1c(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C07BC: 98CB001C  stb r6, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[6].u8 ) };
	// 825C07C0: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 825C07C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C07C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C07C8 size=516
    let mut pc: u32 = 0x825C07C8;
    'dispatch: loop {
        match pc {
            0x825C07C8 => {
    //   block [0x825C07C8..0x825C0804)
	// 825C07C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C07CC: 486E8C25  bl 0x82ca93f0
	ctx.lr = 0x825C07D0;
	sub_82CA93D0(ctx, base);
	// 825C07D0: F8610010  std r3, 0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(16 as u32), ctx.r[3].u64 ) };
	// 825C07D4: F8A10020  std r5, 0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(32 as u32), ctx.r[5].u64 ) };
	// 825C07D8: 83E10024  lwz r31, 0x24(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C07DC: F8810018  std r4, 0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(24 as u32), ctx.r[4].u64 ) };
	// 825C07E0: 82E10014  lwz r23, 0x14(r1)
	ctx.r[23].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C07E4: 8161001C  lwz r11, 0x1c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C07E8: 7D575850  subf r10, r23, r11
	ctx.r[10].s64 = ctx.r[11].s64 - ctx.r[23].s64;
	// 825C07EC: 7D37F850  subf r9, r23, r31
	ctx.r[9].s64 = ctx.r[31].s64 - ctx.r[23].s64;
	// 825C07F0: 7D442E71  srawi. r4, r10, 5
	ctx.xer.ca = (ctx.r[10].s32 < 0) && ((ctx.r[10].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[4].s64 = (ctx.r[10].s32 >> 5) as i64;
	ctx.cr[0].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 825C07F4: 7D292E70  srawi r9, r9, 5
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[9].s32 >> 5) as i64;
	// 825C07F8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 825C07FC: 7D3E4B78  mr r30, r9
	ctx.r[30].u64 = ctx.r[9].u64;
	// 825C0800: 4182001C  beq 0x825c081c
	if ctx.cr[0].eq {
	pc = 0x825C081C; continue 'dispatch;
	}
	pc = 0x825C0804; continue 'dispatch;
            }
            0x825C0804 => {
    //   block [0x825C0804..0x825C081C)
	// 825C0804: 7D5E5BD6  divw r10, r30, r11
	ctx.r[10].s32 = ctx.r[30].s32 / ctx.r[11].s32;
	// 825C0808: 7D0A59D6  mullw r8, r10, r11
	ctx.r[8].s32 = ((ctx.r[10].s32 as i64 * ctx.r[11].s32 as i64) as i32);
	ctx.r[8].s64 = ctx.r[8].s32 as i64;
	// 825C080C: 7D48F051  subf. r10, r8, r30
	ctx.r[10].s64 = ctx.r[30].s64 - ctx.r[8].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C0810: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 825C0814: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 825C0818: 4082FFEC  bne 0x825c0804
	if !ctx.cr[0].eq {
	pc = 0x825C0804; continue 'dispatch;
	}
	pc = 0x825C081C; continue 'dispatch;
            }
            0x825C081C => {
    //   block [0x825C081C..0x825C0838)
	// 825C081C: 7F1E4800  cmpw cr6, r30, r9
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[9].s32, &mut ctx.xer);
	// 825C0820: 409801A8  bge cr6, 0x825c09c8
	if !ctx.cr[6].lt {
	pc = 0x825C09C8; continue 'dispatch;
	}
	// 825C0824: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825C0828: 409901A0  ble cr6, 0x825c09c8
	if !ctx.cr[6].gt {
	pc = 0x825C09C8; continue 'dispatch;
	}
	// 825C082C: 57CB2834  slwi r11, r30, 5
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 825C0830: 549D2834  slwi r29, r4, 5
	ctx.r[29].u32 = ctx.r[4].u32.wrapping_shl(5);
	ctx.r[29].u64 = ctx.r[29].u32 as u64;
	// 825C0834: 7D2BBA14  add r9, r11, r23
	ctx.r[9].u64 = ctx.r[11].u64 + ctx.r[23].u64;
	pc = 0x825C0838; continue 'dispatch;
            }
            0x825C0838 => {
    //   block [0x825C0838..0x825C089C)
	// 825C0838: 89090012  lbz r8, 0x12(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C083C: 7D69EA14  add r11, r9, r29
	ctx.r[11].u64 = ctx.r[9].u64 + ctx.r[29].u64;
	// 825C0840: 88E90011  lbz r7, 0x11(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0844: 39490004  addi r10, r9, 4
	ctx.r[10].s64 = ctx.r[9].s64 + 4;
	// 825C0848: 88C90010  lbz r6, 0x10(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C084C: C009000C  lfs f0, 0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0850: 88A90013  lbz r5, 0x13(r9)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0854: C1A90014  lfs f13, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0858: F861FF58  std r3, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[3].u64 ) };
	// 825C085C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 825C0860: 9121FF5C  stw r9, -0xa4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-164 as u32), ctx.r[9].u32 ) };
	// 825C0864: E941FF58  ld r10, -0xa8(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-168 as u32) ) };
	// 825C0868: 83890000  lwz r28, 0(r9)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C086C: 83690004  lwz r27, 4(r9)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0870: 83490008  lwz r26, 8(r9)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0874: 83290018  lwz r25, 0x18(r9)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0878: 8B09001C  lbz r24, 0x1c(r9)
	ctx.r[24].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C087C: 9901FF92  stb r8, -0x6e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-110 as u32), ctx.r[8].u8 ) };
	// 825C0880: 98E1FF91  stb r7, -0x6f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-111 as u32), ctx.r[7].u8 ) };
	// 825C0884: 98C1FF90  stb r6, -0x70(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-112 as u32), ctx.r[6].u8 ) };
	// 825C0888: 98A1FF93  stb r5, -0x6d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-109 as u32), ctx.r[5].u8 ) };
	// 825C088C: F941FF58  std r10, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[10].u64 ) };
	// 825C0890: 409A000C  bne cr6, 0x825c089c
	if !ctx.cr[6].eq {
	pc = 0x825C089C; continue 'dispatch;
	}
	// 825C0894: 39410010  addi r10, r1, 0x10
	ctx.r[10].s64 = ctx.r[1].s64 + 16;
	// 825C0898: 48000018  b 0x825c08b0
	pc = 0x825C08B0; continue 'dispatch;
            }
            0x825C089C => {
    //   block [0x825C089C..0x825C08B0)
	// 825C089C: F941FF50  std r10, -0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[10].u64 ) };
	// 825C08A0: 3941FF60  addi r10, r1, -0xa0
	ctx.r[10].s64 = ctx.r[1].s64 + -160;
	// 825C08A4: 9161FF54  stw r11, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[11].u32 ) };
	// 825C08A8: E961FF50  ld r11, -0xb0(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 825C08AC: F961FF60  std r11, -0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.r[11].u64 ) };
	pc = 0x825C08B0; continue 'dispatch;
            }
            0x825C08B0 => {
    //   block [0x825C08B0..0x825C08C4)
	// 825C08B0: E8EA0000  ld r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 825C08B4: F8E1FF50  std r7, -0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u64 ) };
	// 825C08B8: 8161FF54  lwz r11, -0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-172 as u32) ) } as u64;
	// 825C08BC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C08C0: 419A00D4  beq cr6, 0x825c0994
	if ctx.cr[6].eq {
	pc = 0x825C0994; continue 'dispatch;
	}
	pc = 0x825C08C4; continue 'dispatch;
            }
            0x825C08C4 => {
    //   block [0x825C08C4..0x825C0960)
	// 825C08C4: 8141FF5C  lwz r10, -0xa4(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-164 as u32) ) } as u64;
	// 825C08C8: 38CB0004  addi r6, r11, 4
	ctx.r[6].s64 = ctx.r[11].s64 + 4;
	// 825C08CC: 82CB0000  lwz r22, 0(r11)
	ctx.r[22].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C08D0: 7D0BF850  subf r8, r11, r31
	ctx.r[8].s64 = ctx.r[31].s64 - ctx.r[11].s64;
	// 825C08D4: 38C6000C  addi r6, r6, 0xc
	ctx.r[6].s64 = ctx.r[6].s64 + 12;
	// 825C08D8: F8E1FF58  std r7, -0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-168 as u32), ctx.r[7].u64 ) };
	// 825C08DC: 38AA0004  addi r5, r10, 4
	ctx.r[5].s64 = ctx.r[10].s64 + 4;
	// 825C08E0: 7D082E70  srawi r8, r8, 5
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[8].s32 >> 5) as i64;
	// 825C08E4: 38A5000C  addi r5, r5, 0xc
	ctx.r[5].s64 = ctx.r[5].s64 + 12;
	// 825C08E8: 92CA0000  stw r22, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[22].u32 ) };
	// 825C08EC: 7F044000  cmpw cr6, r4, r8
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[8].s32, &mut ctx.xer);
	// 825C08F0: 80CB0004  lwz r6, 4(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C08F4: 90CA0004  stw r6, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[6].u32 ) };
	// 825C08F8: 80AB0008  lwz r5, 8(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C08FC: 90AA0008  stw r5, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[5].u32 ) };
	// 825C0900: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C0904: D18A000C  stfs f12, 0xc(r10)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0908: 88CB0010  lbz r6, 0x10(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C090C: 98CA0010  stb r6, 0x10(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[6].u8 ) };
	// 825C0910: 88AB0011  lbz r5, 0x11(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0914: 98AA0011  stb r5, 0x11(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(17 as u32), ctx.r[5].u8 ) };
	// 825C0918: 88CB0012  lbz r6, 0x12(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C091C: 98CA0012  stb r6, 0x12(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(18 as u32), ctx.r[6].u8 ) };
	// 825C0920: 88AB0013  lbz r5, 0x13(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0924: 98AA0013  stb r5, 0x13(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(19 as u32), ctx.r[5].u8 ) };
	// 825C0928: C16B0014  lfs f11, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C092C: D16A0014  stfs f11, 0x14(r10)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C0930: 80CB0018  lwz r6, 0x18(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0934: 90CA0018  stw r6, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[6].u32 ) };
	// 825C0938: 88AB001C  lbz r5, 0x1c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C093C: 98AA001C  stb r5, 0x1c(r10)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[5].u8 ) };
	// 825C0940: 40980020  bge cr6, 0x825c0960
	if !ctx.cr[6].lt {
	pc = 0x825C0960; continue 'dispatch;
	}
	// 825C0944: F8E1FF50  std r7, -0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u64 ) };
	// 825C0948: 7D5D5A14  add r10, r29, r11
	ctx.r[10].u64 = ctx.r[29].u64 + ctx.r[11].u64;
	// 825C094C: 3961FF68  addi r11, r1, -0x98
	ctx.r[11].s64 = ctx.r[1].s64 + -152;
	// 825C0950: 9141FF54  stw r10, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[10].u32 ) };
	// 825C0954: E901FF50  ld r8, -0xb0(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 825C0958: F901FF68  std r8, -0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-152 as u32), ctx.r[8].u64 ) };
	// 825C095C: 48000024  b 0x825c0980
	pc = 0x825C0980; continue 'dispatch;
            }
            0x825C0960 => {
    //   block [0x825C0960..0x825C0980)
	// 825C0960: 7D482050  subf r10, r8, r4
	ctx.r[10].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 825C0964: F861FF50  std r3, -0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[3].u64 ) };
	// 825C0968: 3961FF70  addi r11, r1, -0x90
	ctx.r[11].s64 = ctx.r[1].s64 + -144;
	// 825C096C: 554A2834  slwi r10, r10, 5
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 825C0970: 7D0ABA14  add r8, r10, r23
	ctx.r[8].u64 = ctx.r[10].u64 + ctx.r[23].u64;
	// 825C0974: 9101FF54  stw r8, -0xac(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-172 as u32), ctx.r[8].u32 ) };
	// 825C0978: E8E1FF50  ld r7, -0xb0(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-176 as u32) ) };
	// 825C097C: F8E1FF70  std r7, -0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.r[7].u64 ) };
	pc = 0x825C0980; continue 'dispatch;
            }
            0x825C0980 => {
    //   block [0x825C0980..0x825C0994)
	// 825C0980: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 825C0984: F8E1FF50  std r7, -0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-176 as u32), ctx.r[7].u64 ) };
	// 825C0988: 8161FF54  lwz r11, -0xac(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-172 as u32) ) } as u64;
	// 825C098C: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 825C0990: 409AFF34  bne cr6, 0x825c08c4
	if !ctx.cr[6].eq {
	pc = 0x825C08C4; continue 'dispatch;
	}
	pc = 0x825C0994; continue 'dispatch;
            }
            0x825C0994 => {
    //   block [0x825C0994..0x825C09C8)
	// 825C0994: 8161FF5C  lwz r11, -0xa4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-164 as u32) ) } as u64;
	// 825C0998: 37DEFFFF  addic. r30, r30, -1
	ctx.xer.ca = (ctx.r[30].u32 > (!(-1 as u32)));
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	ctx.cr[0].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825C099C: 8141FF90  lwz r10, -0x70(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-112 as u32) ) } as u64;
	// 825C09A0: 3929FFE0  addi r9, r9, -0x20
	ctx.r[9].s64 = ctx.r[9].s64 + -32;
	// 825C09A4: 938B0000  stw r28, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 825C09A8: D00B000C  stfs f0, 0xc(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C09AC: D1AB0014  stfs f13, 0x14(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C09B0: 936B0004  stw r27, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 825C09B4: 934B0008  stw r26, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[26].u32 ) };
	// 825C09B8: 932B0018  stw r25, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[25].u32 ) };
	// 825C09BC: 914B0010  stw r10, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 825C09C0: 9B0B001C  stb r24, 0x1c(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[24].u8 ) };
	// 825C09C4: 4181FE74  bgt 0x825c0838
	if ctx.cr[0].gt {
	pc = 0x825C0838; continue 'dispatch;
	}
	pc = 0x825C09C8; continue 'dispatch;
            }
            0x825C09C8 => {
    //   block [0x825C09C8..0x825C09CC)
	// 825C09C8: 486E8A78  b 0x82ca9440
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C09D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C09D0 size=284
    let mut pc: u32 = 0x825C09D0;
    'dispatch: loop {
        match pc {
            0x825C09D0 => {
    //   block [0x825C09D0..0x825C0AEC)
	// 825C09D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C09D4: 486E8A31  bl 0x82ca9404
	ctx.lr = 0x825C09D8;
	sub_82CA93D0(ctx, base);
	// 825C09D8: 81440000  lwz r10, 0(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C09DC: 39630010  addi r11, r3, 0x10
	ctx.r[11].s64 = ctx.r[3].s64 + 16;
	// 825C09E0: 39630014  addi r11, r3, 0x14
	ctx.r[11].s64 = ctx.r[3].s64 + 20;
	// 825C09E4: 89230012  lbz r9, 0x12(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C09E8: 39640010  addi r11, r4, 0x10
	ctx.r[11].s64 = ctx.r[4].s64 + 16;
	// 825C09EC: 89030011  lbz r8, 0x11(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C09F0: 39640014  addi r11, r4, 0x14
	ctx.r[11].s64 = ctx.r[4].s64 + 20;
	// 825C09F4: 88E30010  lbz r7, 0x10(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C09F8: 88C30013  lbz r6, 0x13(r3)
	ctx.r[6].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C09FC: C0030008  lfs f0, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0A00: 88A30016  lbz r5, 0x16(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C0A04: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0A08: 8BE30015  lbz r31, 0x15(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C0A0C: C1830020  lfs f12, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C0A10: 89630014  lbz r11, 0x14(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0A14: 8BC30017  lbz r30, 0x17(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(23 as u32) ) } as u64;
	// 825C0A18: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0A1C: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 825C0A20: 81440004  lwz r10, 4(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0A24: 83830004  lwz r28, 4(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0A28: 91430004  stw r10, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 825C0A2C: C1640008  lfs f11, 8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C0A30: D1630008  stfs f11, 8(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825C0A34: 8144000C  lwz r10, 0xc(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C0A38: 8363000C  lwz r27, 0xc(r3)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C0A3C: 9143000C  stw r10, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 825C0A40: 89440010  lbz r10, 0x10(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0A44: 99430010  stb r10, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u8 ) };
	// 825C0A48: 89440011  lbz r10, 0x11(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0A4C: 99430011  stb r10, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[10].u8 ) };
	// 825C0A50: 89440012  lbz r10, 0x12(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C0A54: 99430012  stb r10, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[10].u8 ) };
	// 825C0A58: 89440013  lbz r10, 0x13(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0A5C: 99430013  stb r10, 0x13(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(19 as u32), ctx.r[10].u8 ) };
	// 825C0A60: 89440014  lbz r10, 0x14(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(20 as u32) ) } as u64;
	// 825C0A64: 99430014  stb r10, 0x14(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[10].u8 ) };
	// 825C0A68: 89440015  lbz r10, 0x15(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(21 as u32) ) } as u64;
	// 825C0A6C: 99430015  stb r10, 0x15(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(21 as u32), ctx.r[10].u8 ) };
	// 825C0A70: 89440016  lbz r10, 0x16(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(22 as u32) ) } as u64;
	// 825C0A74: 99430016  stb r10, 0x16(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(22 as u32), ctx.r[10].u8 ) };
	// 825C0A78: 89440017  lbz r10, 0x17(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(23 as u32) ) } as u64;
	// 825C0A7C: 99430017  stb r10, 0x17(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(23 as u32), ctx.r[10].u8 ) };
	// 825C0A80: C1440018  lfs f10, 0x18(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(24 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 825C0A84: 9901FFB1  stb r8, -0x4f(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-79 as u32), ctx.r[8].u8 ) };
	// 825C0A88: D1430018  stfs f10, 0x18(r3)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825C0A8C: 98E1FFB0  stb r7, -0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.r[7].u8 ) };
	// 825C0A90: 98C1FFB3  stb r6, -0x4d(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-77 as u32), ctx.r[6].u8 ) };
	// 825C0A94: 9921FFB2  stb r9, -0x4e(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-78 as u32), ctx.r[9].u8 ) };
	// 825C0A98: 98A1FFB6  stb r5, -0x4a(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-74 as u32), ctx.r[5].u8 ) };
	// 825C0A9C: 9BE1FFB5  stb r31, -0x4b(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-75 as u32), ctx.r[31].u8 ) };
	// 825C0AA0: 9961FFB4  stb r11, -0x4c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-76 as u32), ctx.r[11].u8 ) };
	// 825C0AA4: 9BC1FFB7  stb r30, -0x49(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(-73 as u32), ctx.r[30].u8 ) };
	// 825C0AA8: 8121FFB0  lwz r9, -0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) } as u64;
	// 825C0AAC: 8101FFB4  lwz r8, -0x4c(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-76 as u32) ) } as u64;
	// 825C0AB0: 80E3001C  lwz r7, 0x1c(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C0AB4: 80C4001C  lwz r6, 0x1c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C0AB8: 90C3001C  stw r6, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[6].u32 ) };
	// 825C0ABC: C1240020  lfs f9, 0x20(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(32 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 825C0AC0: D1230020  stfs f9, 0x20(r3)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825C0AC4: 93A40000  stw r29, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[29].u32 ) };
	// 825C0AC8: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 825C0ACC: 93840004  stw r28, 4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), ctx.r[28].u32 ) };
	// 825C0AD0: D1A40018  stfs f13, 0x18(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825C0AD4: 9364000C  stw r27, 0xc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), ctx.r[27].u32 ) };
	// 825C0AD8: 91240010  stw r9, 0x10(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 825C0ADC: 91040014  stw r8, 0x14(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	// 825C0AE0: 90E4001C  stw r7, 0x1c(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), ctx.r[7].u32 ) };
	// 825C0AE4: D1840020  stfs f12, 0x20(r4)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825C0AE8: 486E896C  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0AF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C0AF0 size=264
    let mut pc: u32 = 0x825C0AF0;
    'dispatch: loop {
        match pc {
            0x825C0AF0 => {
    //   block [0x825C0AF0..0x825C0BF8)
	// 825C0AF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C0AF4: 486E8911  bl 0x82ca9404
	ctx.lr = 0x825C0AF8;
	sub_82CA93D0(ctx, base);
	// 825C0AF8: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0AFC: F86100B0  std r3, 0xb0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), ctx.r[3].u64 ) };
	// 825C0B00: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 825C0B04: F8A100C0  std r5, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[5].u64 ) };
	// 825C0B08: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 825C0B0C: 812100C4  lwz r9, 0xc4(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) } as u64;
	// 825C0B10: 396A0004  addi r11, r10, 4
	ctx.r[11].s64 = ctx.r[10].s64 + 4;
	// 825C0B14: 816100B4  lwz r11, 0xb4(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(180 as u32) ) } as u64;
	// 825C0B18: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 825C0B1C: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0B20: 3BE90004  addi r31, r9, 4
	ctx.r[31].s64 = ctx.r[9].s64 + 4;
	// 825C0B24: 3908000C  addi r8, r8, 0xc
	ctx.r[8].s64 = ctx.r[8].s64 + 12;
	// 825C0B28: F88100B8  std r4, 0xb8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), ctx.r[4].u64 ) };
	// 825C0B2C: 391F000C  addi r8, r31, 0xc
	ctx.r[8].s64 = ctx.r[31].s64 + 12;
	// 825C0B30: 80A100BC  lwz r5, 0xbc(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(188 as u32) ) } as u64;
	// 825C0B34: 7CAB2850  subf r5, r11, r5
	ctx.r[5].s64 = ctx.r[5].s64 - ctx.r[11].s64;
	// 825C0B38: 93C90000  stw r30, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 825C0B3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 825C0B40: 810B0004  lwz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0B44: 7CA52E70  srawi r5, r5, 5
	ctx.xer.ca = (ctx.r[5].s32 < 0) && ((ctx.r[5].u32 & ((1u32 << 5) - 1)) != 0);
	ctx.r[5].s64 = (ctx.r[5].s32 >> 5) as i64;
	// 825C0B48: 91090004  stw r8, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 825C0B4C: 810B0008  lwz r8, 8(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0B50: 91090008  stw r8, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 825C0B54: C00B000C  lfs f0, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0B58: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 825C0B5C: 890B0010  lbz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0B60: 99090010  stb r8, 0x10(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), ctx.r[8].u8 ) };
	// 825C0B64: 890B0011  lbz r8, 0x11(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0B68: 99090011  stb r8, 0x11(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(17 as u32), ctx.r[8].u8 ) };
	// 825C0B6C: 890B0012  lbz r8, 0x12(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C0B70: 99090012  stb r8, 0x12(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(18 as u32), ctx.r[8].u8 ) };
	// 825C0B74: 890B0013  lbz r8, 0x13(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0B78: 99090013  stb r8, 0x13(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(19 as u32), ctx.r[8].u8 ) };
	// 825C0B7C: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C0B80: D1A90014  stfs f13, 0x14(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C0B84: 810B0018  lwz r8, 0x18(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0B88: 91090018  stw r8, 0x18(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 825C0B8C: 896B001C  lbz r11, 0x1c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C0B90: 9969001C  stb r11, 0x1c(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 825C0B94: C18A0014  lfs f12, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 825C0B98: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0B9C: C16A000C  lfs f11, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 825C0BA0: 810A0004  lwz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C0BA4: D161005C  stfs f11, 0x5c(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 825C0BA8: 896A0011  lbz r11, 0x11(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C0BAC: D1810064  stfs f12, 0x64(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 825C0BB0: 8BEA0010  lbz r31, 0x10(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C0BB4: 8BCA0013  lbz r30, 0x13(r10)
	ctx.r[30].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(19 as u32) ) } as u64;
	// 825C0BB8: 83AA0018  lwz r29, 0x18(r10)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(24 as u32) ) } as u64;
	// 825C0BBC: 8B8A001C  lbz r28, 0x1c(r10)
	ctx.r[28].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C0BC0: 8B6A0012  lbz r27, 0x12(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C0BC4: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C0BC8: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 825C0BCC: 91010054  stw r8, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[8].u32 ) };
	// 825C0BD0: 99610061  stb r11, 0x61(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(97 as u32), ctx.r[11].u8 ) };
	// 825C0BD4: 9BE10060  stb r31, 0x60(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u8 ) };
	// 825C0BD8: 9BC10063  stb r30, 0x63(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(99 as u32), ctx.r[30].u8 ) };
	// 825C0BDC: 93A10068  stw r29, 0x68(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 825C0BE0: 9B81006C  stb r28, 0x6c(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), ctx.r[28].u8 ) };
	// 825C0BE4: 9B610062  stb r27, 0x62(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[27].u8 ) };
	// 825C0BE8: 91410058  stw r10, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 825C0BEC: 4BFFF04D  bl 0x825bfc38
	ctx.lr = 0x825C0BF0;
	sub_825BFC38(ctx, base);
	// 825C0BF0: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C0BF4: 486E8860  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0BF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C0BF8 size=8
    let mut pc: u32 = 0x825C0BF8;
    'dispatch: loop {
        match pc {
            0x825C0BF8 => {
    //   block [0x825C0BF8..0x825C0C00)
	// 825C0BF8: 3863FFF4  addi r3, r3, -0xc
	ctx.r[3].s64 = ctx.r[3].s64 + -12;
	// 825C0BFC: 4BFF351C  b 0x825b4118
	sub_825B4118(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0C00(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C0C00 size=60
    let mut pc: u32 = 0x825C0C00;
    'dispatch: loop {
        match pc {
            0x825C0C00 => {
    //   block [0x825C0C00..0x825C0C3C)
	// 825C0C00: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C0C04: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C0C08: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C0C0C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0C10: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0C14: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C0C18: 388B57B0  addi r4, r11, 0x57b0
	ctx.r[4].s64 = ctx.r[11].s64 + 22448;
	// 825C0C1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C0C20: 4BC6C2B1  bl 0x8222ced0
	ctx.lr = 0x825C0C24;
	sub_8222CED0(ctx, base);
	// 825C0C24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0C28: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C0C2C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C0C30: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C0C34: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C0C38: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0C40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C0C40 size=124
    let mut pc: u32 = 0x825C0C40;
    'dispatch: loop {
        match pc {
            0x825C0C40 => {
    //   block [0x825C0C40..0x825C0C68)
	// 825C0C40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C0C44: 486E87C9  bl 0x82ca940c
	ctx.lr = 0x825C0C48;
	sub_82CA93D0(ctx, base);
	// 825C0C48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0C4C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C0C50: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 825C0C54: 3BDF0074  addi r30, r31, 0x74
	ctx.r[30].s64 = ctx.r[31].s64 + 116;
	// 825C0C58: 807F0078  lwz r3, 0x78(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 825C0C5C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0C60: 419A0008  beq cr6, 0x825c0c68
	if ctx.cr[6].eq {
	pc = 0x825C0C68; continue 'dispatch;
	}
	// 825C0C64: 4BC5B0D5  bl 0x8221bd38
	ctx.lr = 0x825C0C68;
	sub_8221BD38(ctx, base);
	pc = 0x825C0C68; continue 'dispatch;
            }
            0x825C0C68 => {
    //   block [0x825C0C68..0x825C0C84)
	// 825C0C68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C0C6C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825C0C70: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 825C0C74: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 825C0C78: 917E000C  stw r11, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 825C0C7C: 419A0008  beq cr6, 0x825c0c84
	if ctx.cr[6].eq {
	pc = 0x825C0C84; continue 'dispatch;
	}
	// 825C0C80: 397F000C  addi r11, r31, 0xc
	ctx.r[11].s64 = ctx.r[31].s64 + 12;
	pc = 0x825C0C84; continue 'dispatch;
            }
            0x825C0C84 => {
    //   block [0x825C0C84..0x825C0CB4)
	// 825C0C84: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825C0C88: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825C0C8C: 390A388C  addi r8, r10, 0x388c
	ctx.r[8].s64 = ctx.r[10].s64 + 14476;
	// 825C0C90: 38E92850  addi r7, r9, 0x2850
	ctx.r[7].s64 = ctx.r[9].s64 + 10320;
	// 825C0C94: 57A607FE  clrlwi r6, r29, 0x1f
	ctx.r[6].u64 = ctx.r[29].u32 as u64 & 0x00000001u64;
	// 825C0C98: 910B0000  stw r8, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 825C0C9C: 90FF0000  stw r7, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 825C0CA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0CA4: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 825C0CA8: 419A000C  beq cr6, 0x825c0cb4
	if ctx.cr[6].eq {
	pc = 0x825C0CB4; continue 'dispatch;
	}
	// 825C0CAC: 4BC5B08D  bl 0x8221bd38
	ctx.lr = 0x825C0CB0;
	sub_8221BD38(ctx, base);
	// 825C0CB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x825C0CB4; continue 'dispatch;
            }
            0x825C0CB4 => {
    //   block [0x825C0CB4..0x825C0CBC)
	// 825C0CB4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C0CB8: 486E87A4  b 0x82ca945c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C0CC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C0CC0 size=2040
    let mut pc: u32 = 0x825C0CC0;
    'dispatch: loop {
        match pc {
            0x825C0CC0 => {
    //   block [0x825C0CC0..0x825C0D38)
	// 825C0CC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C0CC4: 486E873D  bl 0x82ca9400
	ctx.lr = 0x825C0CC8;
	sub_82CA93D0(ctx, base);
	// 825C0CC8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 825C0CCC: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C0CD0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 825C0CD4: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825C0CD8: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 825C0CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 825C0CE0: 419A06A8  beq cr6, 0x825c1388
	if ctx.cr[6].eq {
	pc = 0x825C1388; continue 'dispatch;
	}
	// 825C0CE4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825C0CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0CEC: 388BABC4  addi r4, r11, -0x543c
	ctx.r[4].s64 = ctx.r[11].s64 + -21564;
	// 825C0CF0: 4BCE8CF9  bl 0x822a99e8
	ctx.lr = 0x825C0CF4;
	sub_822A99E8(ctx, base);
	// 825C0CF4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 825C0CF8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 825C0CFC: 419A003C  beq cr6, 0x825c0d38
	if ctx.cr[6].eq {
	pc = 0x825C0D38; continue 'dispatch;
	}
	// 825C0D00: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 825C0D04: 388BABCC  addi r4, r11, -0x5434
	ctx.r[4].s64 = ctx.r[11].s64 + -21556;
	// 825C0D08: 4BDFEB19  bl 0x823bf820
	ctx.lr = 0x825C0D0C;
	sub_823BF820(ctx, base);
	// 825C0D0C: 987C0012  stb r3, 0x12(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(18 as u32), ctx.r[3].u8 ) };
	// 825C0D10: 3D20820B  lis r9, -0x7df5
	ctx.r[9].s64 = -2113208320;
	// 825C0D14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C0D18: 3889ABD0  addi r4, r9, -0x5430
	ctx.r[4].s64 = ctx.r[9].s64 + -21552;
	// 825C0D1C: 4BDFEB05  bl 0x823bf820
	ctx.lr = 0x825C0D20;
	sub_823BF820(ctx, base);
	// 825C0D20: 987C0011  stb r3, 0x11(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(17 as u32), ctx.r[3].u8 ) };
	// 825C0D24: 3CE0820B  lis r7, -0x7df5
	ctx.r[7].s64 = -2113208320;
	// 825C0D28: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C0D2C: 3887ABD8  addi r4, r7, -0x5428
	ctx.r[4].s64 = ctx.r[7].s64 + -21544;
	// 825C0D30: 4BDFEAF1  bl 0x823bf820
	ctx.lr = 0x825C0D34;
	sub_823BF820(ctx, base);
	// 825C0D34: 987C0010  stb r3, 0x10(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(16 as u32), ctx.r[3].u8 ) };
	pc = 0x825C0D38; continue 'dispatch;
            }
            0x825C0D38 => {
    //   block [0x825C0D38..0x825C0DC4)
	// 825C0D38: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0D3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0D40: 388B8E24  addi r4, r11, -0x71dc
	ctx.r[4].s64 = ctx.r[11].s64 + -29148;
	// 825C0D44: 4BBD5E3D  bl 0x82196b80
	ctx.lr = 0x825C0D48;
	sub_82196B80(ctx, base);
	// 825C0D48: D03C0018  stfs f1, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825C0D4C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825C0D50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0D54: 388A57CC  addi r4, r10, 0x57cc
	ctx.r[4].s64 = ctx.r[10].s64 + 22476;
	// 825C0D58: 4BDFEAC9  bl 0x823bf820
	ctx.lr = 0x825C0D5C;
	sub_823BF820(ctx, base);
	// 825C0D5C: 907C001C  stw r3, 0x1c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(28 as u32), ctx.r[3].u32 ) };
	// 825C0D60: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825C0D64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0D68: 388957D8  addi r4, r9, 0x57d8
	ctx.r[4].s64 = ctx.r[9].s64 + 22488;
	// 825C0D6C: 4BBD5E15  bl 0x82196b80
	ctx.lr = 0x825C0D70;
	sub_82196B80(ctx, base);
	// 825C0D70: 3D008210  lis r8, -0x7df0
	ctx.r[8].s64 = -2112880640;
	// 825C0D74: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0D78: 3CE0811C  lis r7, -0x7ee4
	ctx.r[7].s64 = -2128871424;
	// 825C0D7C: 3BAB57EC  addi r29, r11, 0x57ec
	ctx.r[29].s64 = ctx.r[11].s64 + 22508;
	// 825C0D80: 60FE9DC5  ori r30, r7, 0x9dc5
	ctx.r[30].u64 = ctx.r[7].u64 | 40389;
	// 825C0D84: C0080ED4  lfs f0, 0xed4(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(3796 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C0D88: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0D8C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 825C0D90: D01C0020  stfs f0, 0x20(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 825C0D94: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0D98: 4BC32FC1  bl 0x821f3d58
	ctx.lr = 0x825C0D9C;
	sub_821F3D58(ctx, base);
	// 825C0D9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0DA4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0DA8: 4843F921  bl 0x82a006c8
	ctx.lr = 0x825C0DAC;
	sub_82A006C8(ctx, base);
	// 825C0DAC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0DB0: 419A0014  beq cr6, 0x825c0dc4
	if ctx.cr[6].eq {
	pc = 0x825C0DC4; continue 'dispatch;
	}
	// 825C0DB4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0DB8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0DBC: 4BBD5DC5  bl 0x82196b80
	ctx.lr = 0x825C0DC0;
	sub_82196B80(ctx, base);
	// 825C0DC0: D03C0014  stfs f1, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x825C0DC4; continue 'dispatch;
            }
            0x825C0DC4 => {
    //   block [0x825C0DC4..0x825C0E00)
	// 825C0DC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0DC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0DCC: 3BAB57F8  addi r29, r11, 0x57f8
	ctx.r[29].s64 = ctx.r[11].s64 + 22520;
	// 825C0DD0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0DD4: 4BC32F85  bl 0x821f3d58
	ctx.lr = 0x825C0DD8;
	sub_821F3D58(ctx, base);
	// 825C0DD8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0DE0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0DE4: 4843F8E5  bl 0x82a006c8
	ctx.lr = 0x825C0DE8;
	sub_82A006C8(ctx, base);
	// 825C0DE8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0DEC: 419A0014  beq cr6, 0x825c0e00
	if ctx.cr[6].eq {
	pc = 0x825C0E00; continue 'dispatch;
	}
	// 825C0DF0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0DF8: 4BBD5D89  bl 0x82196b80
	ctx.lr = 0x825C0DFC;
	sub_82196B80(ctx, base);
	// 825C0DFC: D03C0028  stfs f1, 0x28(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x825C0E00; continue 'dispatch;
            }
            0x825C0E00 => {
    //   block [0x825C0E00..0x825C0E3C)
	// 825C0E00: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0E04: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0E08: 3BAB5808  addi r29, r11, 0x5808
	ctx.r[29].s64 = ctx.r[11].s64 + 22536;
	// 825C0E0C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0E10: 4BC32F49  bl 0x821f3d58
	ctx.lr = 0x825C0E14;
	sub_821F3D58(ctx, base);
	// 825C0E14: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0E18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0E1C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0E20: 4843F8A9  bl 0x82a006c8
	ctx.lr = 0x825C0E24;
	sub_82A006C8(ctx, base);
	// 825C0E24: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0E28: 419A0014  beq cr6, 0x825c0e3c
	if ctx.cr[6].eq {
	pc = 0x825C0E3C; continue 'dispatch;
	}
	// 825C0E2C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0E30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0E34: 4BBD5D4D  bl 0x82196b80
	ctx.lr = 0x825C0E38;
	sub_82196B80(ctx, base);
	// 825C0E38: D03C002C  stfs f1, 0x2c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(44 as u32), tmp.u32 ) };
	pc = 0x825C0E3C; continue 'dispatch;
            }
            0x825C0E3C => {
    //   block [0x825C0E3C..0x825C0E78)
	// 825C0E3C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0E40: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0E44: 3BAB5814  addi r29, r11, 0x5814
	ctx.r[29].s64 = ctx.r[11].s64 + 22548;
	// 825C0E48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0E4C: 4BC32F0D  bl 0x821f3d58
	ctx.lr = 0x825C0E50;
	sub_821F3D58(ctx, base);
	// 825C0E50: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0E54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0E58: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0E5C: 4843F86D  bl 0x82a006c8
	ctx.lr = 0x825C0E60;
	sub_82A006C8(ctx, base);
	// 825C0E60: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0E64: 419A0014  beq cr6, 0x825c0e78
	if ctx.cr[6].eq {
	pc = 0x825C0E78; continue 'dispatch;
	}
	// 825C0E68: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0E6C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0E70: 4BBD5D11  bl 0x82196b80
	ctx.lr = 0x825C0E74;
	sub_82196B80(ctx, base);
	// 825C0E74: D03C0040  stfs f1, 0x40(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x825C0E78; continue 'dispatch;
            }
            0x825C0E78 => {
    //   block [0x825C0E78..0x825C0EB4)
	// 825C0E78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0E7C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0E80: 3BAB5830  addi r29, r11, 0x5830
	ctx.r[29].s64 = ctx.r[11].s64 + 22576;
	// 825C0E84: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0E88: 4BC32ED1  bl 0x821f3d58
	ctx.lr = 0x825C0E8C;
	sub_821F3D58(ctx, base);
	// 825C0E8C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0E90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0E94: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0E98: 4843F831  bl 0x82a006c8
	ctx.lr = 0x825C0E9C;
	sub_82A006C8(ctx, base);
	// 825C0E9C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0EA0: 419A0014  beq cr6, 0x825c0eb4
	if ctx.cr[6].eq {
	pc = 0x825C0EB4; continue 'dispatch;
	}
	// 825C0EA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0EA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0EAC: 4BBD5CD5  bl 0x82196b80
	ctx.lr = 0x825C0EB0;
	sub_82196B80(ctx, base);
	// 825C0EB0: D03C0044  stfs f1, 0x44(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x825C0EB4; continue 'dispatch;
            }
            0x825C0EB4 => {
    //   block [0x825C0EB4..0x825C0EF0)
	// 825C0EB4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0EB8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0EBC: 3BAB5848  addi r29, r11, 0x5848
	ctx.r[29].s64 = ctx.r[11].s64 + 22600;
	// 825C0EC0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0EC4: 4BC32E95  bl 0x821f3d58
	ctx.lr = 0x825C0EC8;
	sub_821F3D58(ctx, base);
	// 825C0EC8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0ED0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0ED4: 4843F7F5  bl 0x82a006c8
	ctx.lr = 0x825C0ED8;
	sub_82A006C8(ctx, base);
	// 825C0ED8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0EDC: 419A0014  beq cr6, 0x825c0ef0
	if ctx.cr[6].eq {
	pc = 0x825C0EF0; continue 'dispatch;
	}
	// 825C0EE0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0EE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0EE8: 4BBD5C99  bl 0x82196b80
	ctx.lr = 0x825C0EEC;
	sub_82196B80(ctx, base);
	// 825C0EEC: D03C0048  stfs f1, 0x48(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x825C0EF0; continue 'dispatch;
            }
            0x825C0EF0 => {
    //   block [0x825C0EF0..0x825C0F2C)
	// 825C0EF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0EF4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0EF8: 3BAB5858  addi r29, r11, 0x5858
	ctx.r[29].s64 = ctx.r[11].s64 + 22616;
	// 825C0EFC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0F00: 4BC32E59  bl 0x821f3d58
	ctx.lr = 0x825C0F04;
	sub_821F3D58(ctx, base);
	// 825C0F04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0F08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0F0C: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0F10: 4843F7B9  bl 0x82a006c8
	ctx.lr = 0x825C0F14;
	sub_82A006C8(ctx, base);
	// 825C0F14: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0F18: 419A0014  beq cr6, 0x825c0f2c
	if ctx.cr[6].eq {
	pc = 0x825C0F2C; continue 'dispatch;
	}
	// 825C0F1C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0F24: 4BBD5C5D  bl 0x82196b80
	ctx.lr = 0x825C0F28;
	sub_82196B80(ctx, base);
	// 825C0F28: D03C0050  stfs f1, 0x50(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x825C0F2C; continue 'dispatch;
            }
            0x825C0F2C => {
    //   block [0x825C0F2C..0x825C0F68)
	// 825C0F2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0F30: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0F34: 3BAB586C  addi r29, r11, 0x586c
	ctx.r[29].s64 = ctx.r[11].s64 + 22636;
	// 825C0F38: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0F3C: 4BC32E1D  bl 0x821f3d58
	ctx.lr = 0x825C0F40;
	sub_821F3D58(ctx, base);
	// 825C0F40: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0F44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0F48: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0F4C: 4843F77D  bl 0x82a006c8
	ctx.lr = 0x825C0F50;
	sub_82A006C8(ctx, base);
	// 825C0F50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0F54: 419A0014  beq cr6, 0x825c0f68
	if ctx.cr[6].eq {
	pc = 0x825C0F68; continue 'dispatch;
	}
	// 825C0F58: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0F5C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0F60: 4BBD5C21  bl 0x82196b80
	ctx.lr = 0x825C0F64;
	sub_82196B80(ctx, base);
	// 825C0F64: D03C004C  stfs f1, 0x4c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x825C0F68; continue 'dispatch;
            }
            0x825C0F68 => {
    //   block [0x825C0F68..0x825C0FAC)
	// 825C0F68: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0F6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0F70: 3BAB5878  addi r29, r11, 0x5878
	ctx.r[29].s64 = ctx.r[11].s64 + 22648;
	// 825C0F74: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0F78: 4BC32DE1  bl 0x821f3d58
	ctx.lr = 0x825C0F7C;
	sub_821F3D58(ctx, base);
	// 825C0F7C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0F80: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0F84: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0F88: 4843F741  bl 0x82a006c8
	ctx.lr = 0x825C0F8C;
	sub_82A006C8(ctx, base);
	// 825C0F8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0F90: 419A001C  beq cr6, 0x825c0fac
	if ctx.cr[6].eq {
	pc = 0x825C0FAC; continue 'dispatch;
	}
	// 825C0F94: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825C0F98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C0F9C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C0FA0: 481C2479  bl 0x82783418
	ctx.lr = 0x825C0FA4;
	sub_82783418(ctx, base);
	// 825C0FA4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C0FA8: 917C0064  stw r11, 0x64(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	pc = 0x825C0FAC; continue 'dispatch;
            }
            0x825C0FAC => {
    //   block [0x825C0FAC..0x825C0FEC)
	// 825C0FAC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0FB0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0FB4: 3BAB5884  addi r29, r11, 0x5884
	ctx.r[29].s64 = ctx.r[11].s64 + 22660;
	// 825C0FB8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0FBC: 4BC32D9D  bl 0x821f3d58
	ctx.lr = 0x825C0FC0;
	sub_821F3D58(ctx, base);
	// 825C0FC0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C0FC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0FC8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C0FCC: 4843F6FD  bl 0x82a006c8
	ctx.lr = 0x825C0FD0;
	sub_82A006C8(ctx, base);
	// 825C0FD0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C0FD4: 419A0018  beq cr6, 0x825c0fec
	if ctx.cr[6].eq {
	pc = 0x825C0FEC; continue 'dispatch;
	}
	// 825C0FD8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C0FDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C0FE0: 4BBD5BA1  bl 0x82196b80
	ctx.lr = 0x825C0FE4;
	sub_82196B80(ctx, base);
	// 825C0FE4: FC000850  fneg f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 825C0FE8: D01C0068  stfs f0, 0x68(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x825C0FEC; continue 'dispatch;
            }
            0x825C0FEC => {
    //   block [0x825C0FEC..0x825C102C)
	// 825C0FEC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C0FF0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C0FF4: 3BAB5894  addi r29, r11, 0x5894
	ctx.r[29].s64 = ctx.r[11].s64 + 22676;
	// 825C0FF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C0FFC: 4BC32D5D  bl 0x821f3d58
	ctx.lr = 0x825C1000;
	sub_821F3D58(ctx, base);
	// 825C1000: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1004: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1008: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C100C: 4843F6BD  bl 0x82a006c8
	ctx.lr = 0x825C1010;
	sub_82A006C8(ctx, base);
	// 825C1010: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1014: 419A0018  beq cr6, 0x825c102c
	if ctx.cr[6].eq {
	pc = 0x825C102C; continue 'dispatch;
	}
	// 825C1018: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C101C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1020: 4BBD5B61  bl 0x82196b80
	ctx.lr = 0x825C1024;
	sub_82196B80(ctx, base);
	// 825C1024: FC000850  fneg f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = ctx.f[1].u64 ^ 0x8000_0000_0000_0000u64;
	// 825C1028: D01C006C  stfs f0, 0x6c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), tmp.u32 ) };
	pc = 0x825C102C; continue 'dispatch;
            }
            0x825C102C => {
    //   block [0x825C102C..0x825C1068)
	// 825C102C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1030: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1034: 3BAB58B0  addi r29, r11, 0x58b0
	ctx.r[29].s64 = ctx.r[11].s64 + 22704;
	// 825C1038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C103C: 4BC32D1D  bl 0x821f3d58
	ctx.lr = 0x825C1040;
	sub_821F3D58(ctx, base);
	// 825C1040: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1044: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1048: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C104C: 4843F67D  bl 0x82a006c8
	ctx.lr = 0x825C1050;
	sub_82A006C8(ctx, base);
	// 825C1050: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1054: 419A0014  beq cr6, 0x825c1068
	if ctx.cr[6].eq {
	pc = 0x825C1068; continue 'dispatch;
	}
	// 825C1058: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C105C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1060: 4BBD5B21  bl 0x82196b80
	ctx.lr = 0x825C1064;
	sub_82196B80(ctx, base);
	// 825C1064: D03C0070  stfs f1, 0x70(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x825C1068; continue 'dispatch;
            }
            0x825C1068 => {
    //   block [0x825C1068..0x825C10A4)
	// 825C1068: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C106C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1070: 3BAB58C8  addi r29, r11, 0x58c8
	ctx.r[29].s64 = ctx.r[11].s64 + 22728;
	// 825C1074: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1078: 4BC32CE1  bl 0x821f3d58
	ctx.lr = 0x825C107C;
	sub_821F3D58(ctx, base);
	// 825C107C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1080: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1084: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C1088: 4843F641  bl 0x82a006c8
	ctx.lr = 0x825C108C;
	sub_82A006C8(ctx, base);
	// 825C108C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1090: 419A0014  beq cr6, 0x825c10a4
	if ctx.cr[6].eq {
	pc = 0x825C10A4; continue 'dispatch;
	}
	// 825C1094: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C1098: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C109C: 4BBD5AE5  bl 0x82196b80
	ctx.lr = 0x825C10A0;
	sub_82196B80(ctx, base);
	// 825C10A0: D03C0054  stfs f1, 0x54(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x825C10A4; continue 'dispatch;
            }
            0x825C10A4 => {
    //   block [0x825C10A4..0x825C10E0)
	// 825C10A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C10A8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C10AC: 3BAB58E8  addi r29, r11, 0x58e8
	ctx.r[29].s64 = ctx.r[11].s64 + 22760;
	// 825C10B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C10B4: 4BC32CA5  bl 0x821f3d58
	ctx.lr = 0x825C10B8;
	sub_821F3D58(ctx, base);
	// 825C10B8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C10BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C10C0: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C10C4: 4843F605  bl 0x82a006c8
	ctx.lr = 0x825C10C8;
	sub_82A006C8(ctx, base);
	// 825C10C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C10CC: 419A0014  beq cr6, 0x825c10e0
	if ctx.cr[6].eq {
	pc = 0x825C10E0; continue 'dispatch;
	}
	// 825C10D0: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C10D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C10D8: 4BBD5AA9  bl 0x82196b80
	ctx.lr = 0x825C10DC;
	sub_82196B80(ctx, base);
	// 825C10DC: D03C0060  stfs f1, 0x60(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x825C10E0; continue 'dispatch;
            }
            0x825C10E0 => {
    //   block [0x825C10E0..0x825C111C)
	// 825C10E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C10E4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C10E8: 3BAB590C  addi r29, r11, 0x590c
	ctx.r[29].s64 = ctx.r[11].s64 + 22796;
	// 825C10EC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C10F0: 4BC32C69  bl 0x821f3d58
	ctx.lr = 0x825C10F4;
	sub_821F3D58(ctx, base);
	// 825C10F4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C10F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C10FC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C1100: 4843F5C9  bl 0x82a006c8
	ctx.lr = 0x825C1104;
	sub_82A006C8(ctx, base);
	// 825C1104: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1108: 419A0014  beq cr6, 0x825c111c
	if ctx.cr[6].eq {
	pc = 0x825C111C; continue 'dispatch;
	}
	// 825C110C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C1110: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1114: 4BBD5A6D  bl 0x82196b80
	ctx.lr = 0x825C1118;
	sub_82196B80(ctx, base);
	// 825C1118: D03C0058  stfs f1, 0x58(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x825C111C; continue 'dispatch;
            }
            0x825C111C => {
    //   block [0x825C111C..0x825C1158)
	// 825C111C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1120: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1124: 3BAB5928  addi r29, r11, 0x5928
	ctx.r[29].s64 = ctx.r[11].s64 + 22824;
	// 825C1128: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C112C: 4BC32C2D  bl 0x821f3d58
	ctx.lr = 0x825C1130;
	sub_821F3D58(ctx, base);
	// 825C1130: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1134: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1138: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C113C: 4843F58D  bl 0x82a006c8
	ctx.lr = 0x825C1140;
	sub_82A006C8(ctx, base);
	// 825C1140: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1144: 419A0014  beq cr6, 0x825c1158
	if ctx.cr[6].eq {
	pc = 0x825C1158; continue 'dispatch;
	}
	// 825C1148: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C114C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1150: 4BBD5A31  bl 0x82196b80
	ctx.lr = 0x825C1154;
	sub_82196B80(ctx, base);
	// 825C1154: D03C005C  stfs f1, 0x5c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(92 as u32), tmp.u32 ) };
	pc = 0x825C1158; continue 'dispatch;
            }
            0x825C1158 => {
    //   block [0x825C1158..0x825C11C4)
	// 825C1158: 815C001C  lwz r10, 0x1c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C115C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C1160: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 825C1164: 3B6B9490  addi r27, r11, -0x6b70
	ctx.r[27].s64 = ctx.r[11].s64 + -27504;
	// 825C1168: 409A00B0  bne cr6, 0x825c1218
	if !ctx.cr[6].eq {
	pc = 0x825C1218; continue 'dispatch;
	}
	// 825C116C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1170: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C1174: 38AB5940  addi r5, r11, 0x5940
	ctx.r[5].s64 = ctx.r[11].s64 + 22848;
	// 825C1178: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C117C: 481C229D  bl 0x82783418
	ctx.lr = 0x825C1180;
	sub_82783418(ctx, base);
	// 825C1180: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1184: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1188: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C118C: 3BAB5954  addi r29, r11, 0x5954
	ctx.r[29].s64 = ctx.r[11].s64 + 22868;
	// 825C1190: 915C0024  stw r10, 0x24(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 825C1194: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1198: 4BC32BC1  bl 0x821f3d58
	ctx.lr = 0x825C119C;
	sub_821F3D58(ctx, base);
	// 825C119C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C11A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C11A4: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C11A8: 4843F521  bl 0x82a006c8
	ctx.lr = 0x825C11AC;
	sub_82A006C8(ctx, base);
	// 825C11AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C11B0: 419A0014  beq cr6, 0x825c11c4
	if ctx.cr[6].eq {
	pc = 0x825C11C4; continue 'dispatch;
	}
	// 825C11B4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C11B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C11BC: 4BD4F0D5  bl 0x82310290
	ctx.lr = 0x825C11C0;
	sub_82310290(ctx, base);
	// 825C11C0: 987C0085  stb r3, 0x85(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(133 as u32), ctx.r[3].u8 ) };
	pc = 0x825C11C4; continue 'dispatch;
            }
            0x825C11C4 => {
    //   block [0x825C11C4..0x825C11DC)
	// 825C11C4: C1BC0018  lfs f13, 0x18(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C11C8: C01B5D38  lfs f0, 0x5d38(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(23864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C11CC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 825C11D0: 4099000C  ble cr6, 0x825c11dc
	if !ctx.cr[6].gt {
	pc = 0x825C11DC; continue 'dispatch;
	}
	// 825C11D4: 9B5C0086  stb r26, 0x86(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(134 as u32), ctx.r[26].u8 ) };
	// 825C11D8: 48000040  b 0x825c1218
	pc = 0x825C1218; continue 'dispatch;
            }
            0x825C11DC => {
    //   block [0x825C11DC..0x825C1218)
	// 825C11DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C11E0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C11E4: 3BAB5960  addi r29, r11, 0x5960
	ctx.r[29].s64 = ctx.r[11].s64 + 22880;
	// 825C11E8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C11EC: 4BC32B6D  bl 0x821f3d58
	ctx.lr = 0x825C11F0;
	sub_821F3D58(ctx, base);
	// 825C11F0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C11F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C11F8: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C11FC: 4843F4CD  bl 0x82a006c8
	ctx.lr = 0x825C1200;
	sub_82A006C8(ctx, base);
	// 825C1200: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1204: 419A0014  beq cr6, 0x825c1218
	if ctx.cr[6].eq {
	pc = 0x825C1218; continue 'dispatch;
	}
	// 825C1208: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C120C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1210: 4BD4F081  bl 0x82310290
	ctx.lr = 0x825C1214;
	sub_82310290(ctx, base);
	// 825C1214: 987C0086  stb r3, 0x86(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(134 as u32), ctx.r[3].u8 ) };
	pc = 0x825C1218; continue 'dispatch;
            }
            0x825C1218 => {
    //   block [0x825C1218..0x825C1254)
	// 825C1218: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C121C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1220: 3BAB5978  addi r29, r11, 0x5978
	ctx.r[29].s64 = ctx.r[11].s64 + 22904;
	// 825C1224: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1228: 4BC32B31  bl 0x821f3d58
	ctx.lr = 0x825C122C;
	sub_821F3D58(ctx, base);
	// 825C122C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1230: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1234: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C1238: 4843F491  bl 0x82a006c8
	ctx.lr = 0x825C123C;
	sub_82A006C8(ctx, base);
	// 825C123C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C1240: 419A0014  beq cr6, 0x825c1254
	if ctx.cr[6].eq {
	pc = 0x825C1254; continue 'dispatch;
	}
	// 825C1244: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C1248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C124C: 4BD4F045  bl 0x82310290
	ctx.lr = 0x825C1250;
	sub_82310290(ctx, base);
	// 825C1250: 987C0087  stb r3, 0x87(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(135 as u32), ctx.r[3].u8 ) };
	pc = 0x825C1254; continue 'dispatch;
            }
            0x825C1254 => {
    //   block [0x825C1254..0x825C1290)
	// 825C1254: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1258: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C125C: 3BAB5984  addi r29, r11, 0x5984
	ctx.r[29].s64 = ctx.r[11].s64 + 22916;
	// 825C1260: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1264: 4BC32AF5  bl 0x821f3d58
	ctx.lr = 0x825C1268;
	sub_821F3D58(ctx, base);
	// 825C1268: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C126C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1270: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C1274: 4843F455  bl 0x82a006c8
	ctx.lr = 0x825C1278;
	sub_82A006C8(ctx, base);
	// 825C1278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C127C: 419A0014  beq cr6, 0x825c1290
	if ctx.cr[6].eq {
	pc = 0x825C1290; continue 'dispatch;
	}
	// 825C1280: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C1284: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1288: 4BD4F009  bl 0x82310290
	ctx.lr = 0x825C128C;
	sub_82310290(ctx, base);
	// 825C128C: 987C0084  stb r3, 0x84(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(132 as u32), ctx.r[3].u8 ) };
	pc = 0x825C1290; continue 'dispatch;
            }
            0x825C1290 => {
    //   block [0x825C1290..0x825C12CC)
	// 825C1290: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1294: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1298: 3BCB599C  addi r30, r11, 0x599c
	ctx.r[30].s64 = ctx.r[11].s64 + 22940;
	// 825C129C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C12A0: 4BC32AB9  bl 0x821f3d58
	ctx.lr = 0x825C12A4;
	sub_821F3D58(ctx, base);
	// 825C12A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C12A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C12AC: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 825C12B0: 4843F419  bl 0x82a006c8
	ctx.lr = 0x825C12B4;
	sub_82A006C8(ctx, base);
	// 825C12B4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 825C12B8: 419A0014  beq cr6, 0x825c12cc
	if ctx.cr[6].eq {
	pc = 0x825C12CC; continue 'dispatch;
	}
	// 825C12BC: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C12C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C12C4: 4BD4EFCD  bl 0x82310290
	ctx.lr = 0x825C12C8;
	sub_82310290(ctx, base);
	// 825C12C8: 987C008A  stb r3, 0x8a(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(138 as u32), ctx.r[3].u8 ) };
	pc = 0x825C12CC; continue 'dispatch;
            }
            0x825C12CC => {
    //   block [0x825C12CC..0x825C1380)
	// 825C12CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C12D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C12D4: 388B59AC  addi r4, r11, 0x59ac
	ctx.r[4].s64 = ctx.r[11].s64 + 22956;
	// 825C12D8: 4BBD58A9  bl 0x82196b80
	ctx.lr = 0x825C12DC;
	sub_82196B80(ctx, base);
	// 825C12DC: 3D408332  lis r10, -0x7cce
	ctx.r[10].s64 = -2093875200;
	// 825C12E0: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825C12E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C12E8: 388959C0  addi r4, r9, 0x59c0
	ctx.r[4].s64 = ctx.r[9].s64 + 22976;
	// 825C12EC: CBEA9660  lfd f31, -0x69a0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(-27040 as u32) ) };
	// 825C12F0: FC0107F2  fmul f0, f1, f31
	ctx.f[0].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 825C12F4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 825C12F8: FD806E5C  fctid f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64 as i64 };
	// 825C12FC: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 825C1300: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C1304: FD20501E  fctiwz f9, f10
	ctx.f[9].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 825C1308: 39800030  li r12, 0x30
	ctx.r[12].s64 = 48;
	// 825C130C: 7D3C67AE  stfiwx f9, r28, r12
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[12].u32), tmp.u32) };
	// 825C1310: 4BBD5871  bl 0x82196b80
	ctx.lr = 0x825C1314;
	sub_82196B80(ctx, base);
	// 825C1314: FD0107F2  fmul f8, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = ctx.f[1].f64 * ctx.f[31].f64;
	// 825C1318: 39000034  li r8, 0x34
	ctx.r[8].s64 = 52;
	// 825C131C: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825C1320: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1324: 388759D8  addi r4, r7, 0x59d8
	ctx.r[4].s64 = ctx.r[7].s64 + 23000;
	// 825C1328: FCE04018  frsp f7, f8
	ctx.f[7].f64 = (ctx.f[8].f64 as f32) as f64;
	// 825C132C: FCC03E5C  fctid f6, f7
	ctx.f[6].s64 = if ctx.f[7].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[7].f64 as i64 };
	// 825C1330: FCA0369C  fcfid f5, f6
	ctx.f[5].f64 = (ctx.f[6].s64 as f64);
	// 825C1334: FC802818  frsp f4, f5
	ctx.f[4].f64 = (ctx.f[5].f64 as f32) as f64;
	// 825C1338: FC60201E  fctiwz f3, f4
	ctx.f[3].s64 = if ctx.f[4].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[4].f64.trunc() as i32 as i64 };
	// 825C133C: 7C7C47AE  stfiwx f3, r28, r8
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[8].u32), tmp.u32) };
	// 825C1340: 4BD4EF51  bl 0x82310290
	ctx.lr = 0x825C1344;
	sub_82310290(ctx, base);
	// 825C1344: 987C0088  stb r3, 0x88(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(136 as u32), ctx.r[3].u8 ) };
	// 825C1348: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825C134C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1350: 388659E8  addi r4, r6, 0x59e8
	ctx.r[4].s64 = ctx.r[6].s64 + 23016;
	// 825C1354: 4BD4EF3D  bl 0x82310290
	ctx.lr = 0x825C1358;
	sub_82310290(ctx, base);
	// 825C1358: 5465063E  clrlwi r5, r3, 0x18
	ctx.r[5].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825C135C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825C1360: 419A0020  beq cr6, 0x825c1380
	if ctx.cr[6].eq {
	pc = 0x825C1380; continue 'dispatch;
	}
	// 825C1364: 897C0088  lbz r11, 0x88(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[28].u32.wrapping_add(136 as u32) ) } as u64;
	// 825C1368: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C136C: 419A0014  beq cr6, 0x825c1380
	if ctx.cr[6].eq {
	pc = 0x825C1380; continue 'dispatch;
	}
	// 825C1370: 817C0030  lwz r11, 0x30(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C1374: C01BFFF4  lfs f0, -0xc(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1378: 917C0038  stw r11, 0x38(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825C137C: 48000008  b 0x825c1384
	pc = 0x825C1384; continue 'dispatch;
            }
            0x825C1380 => {
    //   block [0x825C1380..0x825C1384)
	// 825C1380: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x825C1384; continue 'dispatch;
            }
            0x825C1384 => {
    //   block [0x825C1384..0x825C1388)
	// 825C1384: D01C003C  stfs f0, 0x3c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x825C1388; continue 'dispatch;
            }
            0x825C1388 => {
    //   block [0x825C1388..0x825C13C4)
	// 825C1388: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C138C: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	// 825C1390: 812B0024  lwz r9, 0x24(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C1394: 5528EFFE  rlwinm r8, r9, 0x1d, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[9].u32 as u64 & 0x00000007u64;
	// 825C1398: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 825C139C: 419A00D4  beq cr6, 0x825c1470
	if ctx.cr[6].eq {
	pc = 0x825C1470; continue 'dispatch;
	}
	// 825C13A0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825C13A4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C13A8: 419A001C  beq cr6, 0x825c13c4
	if ctx.cr[6].eq {
	pc = 0x825C13C4; continue 'dispatch;
	}
	// 825C13AC: 892A0003  lbz r9, 3(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C13B0: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C13B4: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825C13B8: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C13BC: 81480004  lwz r10, 4(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C13C0: 480000B0  b 0x825c1470
	pc = 0x825C1470; continue 'dispatch;
            }
            0x825C13C4 => {
    //   block [0x825C13C4..0x825C13E0)
	// 825C13C4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C13C8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C13CC: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 825C13D0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825C13D4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C13D8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C13DC: 40810054  ble 0x825c1430
	if !ctx.cr[0].gt {
	pc = 0x825C1430; continue 'dispatch;
	}
	pc = 0x825C13E0; continue 'dispatch;
            }
            0x825C13E0 => {
    //   block [0x825C13E0..0x825C1400)
	// 825C13E0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C13E4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C13E8: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 825C13EC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C13F0: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825C13F4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825C13F8: 41980008  blt cr6, 0x825c1400
	if ctx.cr[6].lt {
	pc = 0x825C1400; continue 'dispatch;
	}
	// 825C13FC: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	pc = 0x825C1400; continue 'dispatch;
            }
            0x825C1400 => {
    //   block [0x825C1400..0x825C141C)
	// 825C1400: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825C1404: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825C1408: 419A0014  beq cr6, 0x825c141c
	if ctx.cr[6].eq {
	pc = 0x825C141C; continue 'dispatch;
	}
	// 825C140C: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825C1410: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825C1414: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C1418: 4800000C  b 0x825c1424
	pc = 0x825C1424; continue 'dispatch;
            }
            0x825C141C => {
    //   block [0x825C141C..0x825C1424)
	// 825C141C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825C1420: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825C1424; continue 'dispatch;
            }
            0x825C1424 => {
    //   block [0x825C1424..0x825C1430)
	// 825C1424: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1428: 4199FFB8  bgt cr6, 0x825c13e0
	if ctx.cr[6].gt {
	pc = 0x825C13E0; continue 'dispatch;
	}
	// 825C142C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825C1430; continue 'dispatch;
            }
            0x825C1430 => {
    //   block [0x825C1430..0x825C144C)
	// 825C1430: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C1434: 419A0034  beq cr6, 0x825c1468
	if ctx.cr[6].eq {
	pc = 0x825C1468; continue 'dispatch;
	}
	// 825C1438: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C143C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C1440: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1444: 41990008  bgt cr6, 0x825c144c
	if ctx.cr[6].gt {
	pc = 0x825C144C; continue 'dispatch;
	}
	// 825C1448: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x825C144C; continue 'dispatch;
            }
            0x825C144C => {
    //   block [0x825C144C..0x825C1468)
	// 825C144C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C1450: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1454: 409A0014  bne cr6, 0x825c1468
	if !ctx.cr[6].eq {
	pc = 0x825C1468; continue 'dispatch;
	}
	// 825C1458: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C145C: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 825C1460: 8161005C  lwz r11, 0x5c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 825C1464: 48000008  b 0x825c146c
	pc = 0x825C146C; continue 'dispatch;
            }
            0x825C1468 => {
    //   block [0x825C1468..0x825C146C)
	// 825C1468: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825C146C; continue 'dispatch;
            }
            0x825C146C => {
    //   block [0x825C146C..0x825C1470)
	// 825C146C: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825C1470; continue 'dispatch;
            }
            0x825C1470 => {
    //   block [0x825C1470..0x825C14AC)
	// 825C1470: 397C000C  addi r11, r28, 0xc
	ctx.r[11].s64 = ctx.r[28].s64 + 12;
	// 825C1474: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C1478: 386A000C  addi r3, r10, 0xc
	ctx.r[3].s64 = ctx.r[10].s64 + 12;
	// 825C147C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825C1480: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 825C1484: 90610058  stw r3, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[3].u32 ) };
	// 825C1488: 9121005C  stw r9, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[9].u32 ) };
	// 825C148C: E8810058  ld r4, 0x58(r1)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 825C1490: 484D5ED9  bl 0x82a97368
	ctx.lr = 0x825C1494;
	sub_82A97368(ctx, base);
	// 825C1494: 811C0038  lwz r8, 0x38(r28)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1498: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825C149C: 40990010  ble cr6, 0x825c14ac
	if !ctx.cr[6].gt {
	pc = 0x825C14AC; continue 'dispatch;
	}
	// 825C14A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C14A4: 807C0004  lwz r3, 4(r28)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C14A8: 4BDCC011  bl 0x8238d4b8
	ctx.lr = 0x825C14AC;
	sub_8238D4B8(ctx, base);
	pc = 0x825C14AC; continue 'dispatch;
            }
            0x825C14AC => {
    //   block [0x825C14AC..0x825C14B8)
	// 825C14AC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C14B0: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 825C14B4: 486E7F9C  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C14B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C14B8 size=1192
    let mut pc: u32 = 0x825C14B8;
    'dispatch: loop {
        match pc {
            0x825C14B8 => {
    //   block [0x825C14B8..0x825C1534)
	// 825C14B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C14BC: 486E7F49  bl 0x82ca9404
	ctx.lr = 0x825C14C0;
	sub_82CA93D0(ctx, base);
	// 825C14C0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C14C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C14C8: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 825C14CC: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 825C14D0: 2F050001  cmpwi cr6, r5, 1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 1, &mut ctx.xer);
	// 825C14D4: 409A0484  bne cr6, 0x825c1958
	if !ctx.cr[6].eq {
	pc = 0x825C1958; continue 'dispatch;
	}
	// 825C14D8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C14DC: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C14E0: 388B1068  addi r4, r11, 0x1068
	ctx.r[4].s64 = ctx.r[11].s64 + 4200;
	// 825C14E4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C14E8: 4BC6B9E9  bl 0x8222ced0
	ctx.lr = 0x825C14EC;
	sub_8222CED0(ctx, base);
	// 825C14EC: 38BF0010  addi r5, r31, 0x10
	ctx.r[5].s64 = ctx.r[31].s64 + 16;
	// 825C14F0: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C14F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C14F8: 4845BD49  bl 0x82a1d240
	ctx.lr = 0x825C14FC;
	sub_82A1D240(ctx, base);
	// 825C14FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1500: 4BC538D9  bl 0x82214dd8
	ctx.lr = 0x825C1504;
	sub_82214DD8(ctx, base);
	// 825C1504: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825C1508: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C150C: 388A59FC  addi r4, r10, 0x59fc
	ctx.r[4].s64 = ctx.r[10].s64 + 23036;
	// 825C1510: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1514: 4BC6B9BD  bl 0x8222ced0
	ctx.lr = 0x825C1518;
	sub_8222CED0(ctx, base);
	// 825C1518: 3D608209  lis r11, -0x7df7
	ctx.r[11].s64 = -2113339392;
	// 825C151C: 3B8BFFDF  addi r28, r11, -0x21
	ctx.r[28].s64 = ctx.r[11].s64 + -33;
	// 825C1520: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1524: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1528: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C152C: 419A0008  beq cr6, 0x825c1534
	if ctx.cr[6].eq {
	pc = 0x825C1534; continue 'dispatch;
	}
	// 825C1530: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1534; continue 'dispatch;
            }
            0x825C1534 => {
    //   block [0x825C1534..0x825C1570)
	// 825C1534: 38BF0014  addi r5, r31, 0x14
	ctx.r[5].s64 = ctx.r[31].s64 + 20;
	// 825C1538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C153C: 4BEBF315  bl 0x82480850
	ctx.lr = 0x825C1540;
	sub_82480850(ctx, base);
	// 825C1540: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1544: 4BC53895  bl 0x82214dd8
	ctx.lr = 0x825C1548;
	sub_82214DD8(ctx, base);
	// 825C1548: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C154C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1550: 388B5A0C  addi r4, r11, 0x5a0c
	ctx.r[4].s64 = ctx.r[11].s64 + 23052;
	// 825C1554: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1558: 4BC6B979  bl 0x8222ced0
	ctx.lr = 0x825C155C;
	sub_8222CED0(ctx, base);
	// 825C155C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1560: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1564: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1568: 419A0008  beq cr6, 0x825c1570
	if ctx.cr[6].eq {
	pc = 0x825C1570; continue 'dispatch;
	}
	// 825C156C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1570; continue 'dispatch;
            }
            0x825C1570 => {
    //   block [0x825C1570..0x825C15B4)
	// 825C1570: 38BF0018  addi r5, r31, 0x18
	ctx.r[5].s64 = ctx.r[31].s64 + 24;
	// 825C1574: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C1578: 4BEBF2D9  bl 0x82480850
	ctx.lr = 0x825C157C;
	sub_82480850(ctx, base);
	// 825C157C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1580: 4BC53859  bl 0x82214dd8
	ctx.lr = 0x825C1584;
	sub_82214DD8(ctx, base);
	// 825C1584: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1588: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C158C: 388B57CC  addi r4, r11, 0x57cc
	ctx.r[4].s64 = ctx.r[11].s64 + 22476;
	// 825C1590: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1594: 4BC6B93D  bl 0x8222ced0
	ctx.lr = 0x825C1598;
	sub_8222CED0(ctx, base);
	// 825C1598: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 825C159C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C15A0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C15A4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C15A8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C15AC: 419A0008  beq cr6, 0x825c15b4
	if ctx.cr[6].eq {
	pc = 0x825C15B4; continue 'dispatch;
	}
	// 825C15B0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C15B4; continue 'dispatch;
            }
            0x825C15B4 => {
    //   block [0x825C15B4..0x825C15F8)
	// 825C15B4: 38A10054  addi r5, r1, 0x54
	ctx.r[5].s64 = ctx.r[1].s64 + 84;
	// 825C15B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C15BC: 4BEBF20D  bl 0x824807c8
	ctx.lr = 0x825C15C0;
	sub_824807C8(ctx, base);
	// 825C15C0: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C15C4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C15C8: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 825C15CC: 4BC5380D  bl 0x82214dd8
	ctx.lr = 0x825C15D0;
	sub_82214DD8(ctx, base);
	// 825C15D0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825C15D4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C15D8: 388A5A18  addi r4, r10, 0x5a18
	ctx.r[4].s64 = ctx.r[10].s64 + 23064;
	// 825C15DC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C15E0: 4BC6B8F1  bl 0x8222ced0
	ctx.lr = 0x825C15E4;
	sub_8222CED0(ctx, base);
	// 825C15E4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C15E8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C15EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C15F0: 419A0008  beq cr6, 0x825c15f8
	if ctx.cr[6].eq {
	pc = 0x825C15F8; continue 'dispatch;
	}
	// 825C15F4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C15F8; continue 'dispatch;
            }
            0x825C15F8 => {
    //   block [0x825C15F8..0x825C1634)
	// 825C15F8: 38BF0020  addi r5, r31, 0x20
	ctx.r[5].s64 = ctx.r[31].s64 + 32;
	// 825C15FC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C1600: 4BEBF251  bl 0x82480850
	ctx.lr = 0x825C1604;
	sub_82480850(ctx, base);
	// 825C1604: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1608: 4BC537D1  bl 0x82214dd8
	ctx.lr = 0x825C160C;
	sub_82214DD8(ctx, base);
	// 825C160C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1610: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1614: 388B57F8  addi r4, r11, 0x57f8
	ctx.r[4].s64 = ctx.r[11].s64 + 22520;
	// 825C1618: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C161C: 4BC6B8B5  bl 0x8222ced0
	ctx.lr = 0x825C1620;
	sub_8222CED0(ctx, base);
	// 825C1620: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1624: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1628: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C162C: 419A0008  beq cr6, 0x825c1634
	if ctx.cr[6].eq {
	pc = 0x825C1634; continue 'dispatch;
	}
	// 825C1630: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1634; continue 'dispatch;
            }
            0x825C1634 => {
    //   block [0x825C1634..0x825C1670)
	// 825C1634: 38BF0028  addi r5, r31, 0x28
	ctx.r[5].s64 = ctx.r[31].s64 + 40;
	// 825C1638: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C163C: 4BEBF215  bl 0x82480850
	ctx.lr = 0x825C1640;
	sub_82480850(ctx, base);
	// 825C1640: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1644: 4BC53795  bl 0x82214dd8
	ctx.lr = 0x825C1648;
	sub_82214DD8(ctx, base);
	// 825C1648: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C164C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1650: 388B5808  addi r4, r11, 0x5808
	ctx.r[4].s64 = ctx.r[11].s64 + 22536;
	// 825C1654: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1658: 4BC6B879  bl 0x8222ced0
	ctx.lr = 0x825C165C;
	sub_8222CED0(ctx, base);
	// 825C165C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1660: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1664: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1668: 419A0008  beq cr6, 0x825c1670
	if ctx.cr[6].eq {
	pc = 0x825C1670; continue 'dispatch;
	}
	// 825C166C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1670; continue 'dispatch;
            }
            0x825C1670 => {
    //   block [0x825C1670..0x825C16AC)
	// 825C1670: 38BF002C  addi r5, r31, 0x2c
	ctx.r[5].s64 = ctx.r[31].s64 + 44;
	// 825C1674: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C1678: 4BEBF1D9  bl 0x82480850
	ctx.lr = 0x825C167C;
	sub_82480850(ctx, base);
	// 825C167C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1680: 4BC53759  bl 0x82214dd8
	ctx.lr = 0x825C1684;
	sub_82214DD8(ctx, base);
	// 825C1684: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1688: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C168C: 388B5A2C  addi r4, r11, 0x5a2c
	ctx.r[4].s64 = ctx.r[11].s64 + 23084;
	// 825C1690: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1694: 4BC6B83D  bl 0x8222ced0
	ctx.lr = 0x825C1698;
	sub_8222CED0(ctx, base);
	// 825C1698: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C169C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C16A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C16A4: 419A0008  beq cr6, 0x825c16ac
	if ctx.cr[6].eq {
	pc = 0x825C16AC; continue 'dispatch;
	}
	// 825C16A8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C16AC; continue 'dispatch;
            }
            0x825C16AC => {
    //   block [0x825C16AC..0x825C16E8)
	// 825C16AC: 38BF0030  addi r5, r31, 0x30
	ctx.r[5].s64 = ctx.r[31].s64 + 48;
	// 825C16B0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C16B4: 4BEBF115  bl 0x824807c8
	ctx.lr = 0x825C16B8;
	sub_824807C8(ctx, base);
	// 825C16B8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C16BC: 4BC5371D  bl 0x82214dd8
	ctx.lr = 0x825C16C0;
	sub_82214DD8(ctx, base);
	// 825C16C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C16C4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C16C8: 388B5A3C  addi r4, r11, 0x5a3c
	ctx.r[4].s64 = ctx.r[11].s64 + 23100;
	// 825C16CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C16D0: 4BC6B801  bl 0x8222ced0
	ctx.lr = 0x825C16D4;
	sub_8222CED0(ctx, base);
	// 825C16D4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C16D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C16DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C16E0: 419A0008  beq cr6, 0x825c16e8
	if ctx.cr[6].eq {
	pc = 0x825C16E8; continue 'dispatch;
	}
	// 825C16E4: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C16E8; continue 'dispatch;
            }
            0x825C16E8 => {
    //   block [0x825C16E8..0x825C1724)
	// 825C16E8: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 825C16EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C16F0: 4BEBF0D9  bl 0x824807c8
	ctx.lr = 0x825C16F4;
	sub_824807C8(ctx, base);
	// 825C16F4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C16F8: 4BC536E1  bl 0x82214dd8
	ctx.lr = 0x825C16FC;
	sub_82214DD8(ctx, base);
	// 825C16FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1700: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1704: 388B5A4C  addi r4, r11, 0x5a4c
	ctx.r[4].s64 = ctx.r[11].s64 + 23116;
	// 825C1708: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C170C: 4BC6B7C5  bl 0x8222ced0
	ctx.lr = 0x825C1710;
	sub_8222CED0(ctx, base);
	// 825C1710: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1714: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1718: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C171C: 419A0008  beq cr6, 0x825c1724
	if ctx.cr[6].eq {
	pc = 0x825C1724; continue 'dispatch;
	}
	// 825C1720: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1724; continue 'dispatch;
            }
            0x825C1724 => {
    //   block [0x825C1724..0x825C1764)
	// 825C1724: 3BBF0038  addi r29, r31, 0x38
	ctx.r[29].s64 = ctx.r[31].s64 + 56;
	// 825C1728: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C172C: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 825C1730: 4BEBF099  bl 0x824807c8
	ctx.lr = 0x825C1734;
	sub_824807C8(ctx, base);
	// 825C1734: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1738: 4BC536A1  bl 0x82214dd8
	ctx.lr = 0x825C173C;
	sub_82214DD8(ctx, base);
	// 825C173C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1740: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1744: 388B5A60  addi r4, r11, 0x5a60
	ctx.r[4].s64 = ctx.r[11].s64 + 23136;
	// 825C1748: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C174C: 4BC6B785  bl 0x8222ced0
	ctx.lr = 0x825C1750;
	sub_8222CED0(ctx, base);
	// 825C1750: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1754: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1758: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C175C: 419A0008  beq cr6, 0x825c1764
	if ctx.cr[6].eq {
	pc = 0x825C1764; continue 'dispatch;
	}
	// 825C1760: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1764; continue 'dispatch;
            }
            0x825C1764 => {
    //   block [0x825C1764..0x825C17A0)
	// 825C1764: 38BF003C  addi r5, r31, 0x3c
	ctx.r[5].s64 = ctx.r[31].s64 + 60;
	// 825C1768: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C176C: 4BEBF0E5  bl 0x82480850
	ctx.lr = 0x825C1770;
	sub_82480850(ctx, base);
	// 825C1770: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1774: 4BC53665  bl 0x82214dd8
	ctx.lr = 0x825C1778;
	sub_82214DD8(ctx, base);
	// 825C1778: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C177C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1780: 388B5A78  addi r4, r11, 0x5a78
	ctx.r[4].s64 = ctx.r[11].s64 + 23160;
	// 825C1784: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1788: 4BC6B749  bl 0x8222ced0
	ctx.lr = 0x825C178C;
	sub_8222CED0(ctx, base);
	// 825C178C: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1790: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C1794: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1798: 419A0008  beq cr6, 0x825c17a0
	if ctx.cr[6].eq {
	pc = 0x825C17A0; continue 'dispatch;
	}
	// 825C179C: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C17A0; continue 'dispatch;
            }
            0x825C17A0 => {
    //   block [0x825C17A0..0x825C17DC)
	// 825C17A0: 38BF0040  addi r5, r31, 0x40
	ctx.r[5].s64 = ctx.r[31].s64 + 64;
	// 825C17A4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C17A8: 4BEBF0A9  bl 0x82480850
	ctx.lr = 0x825C17AC;
	sub_82480850(ctx, base);
	// 825C17AC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C17B0: 4BC53629  bl 0x82214dd8
	ctx.lr = 0x825C17B4;
	sub_82214DD8(ctx, base);
	// 825C17B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C17B8: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C17BC: 388B5A94  addi r4, r11, 0x5a94
	ctx.r[4].s64 = ctx.r[11].s64 + 23188;
	// 825C17C0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C17C4: 4BC6B70D  bl 0x8222ced0
	ctx.lr = 0x825C17C8;
	sub_8222CED0(ctx, base);
	// 825C17C8: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C17CC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C17D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C17D4: 419A0008  beq cr6, 0x825c17dc
	if ctx.cr[6].eq {
	pc = 0x825C17DC; continue 'dispatch;
	}
	// 825C17D8: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C17DC; continue 'dispatch;
            }
            0x825C17DC => {
    //   block [0x825C17DC..0x825C1818)
	// 825C17DC: 38BF0044  addi r5, r31, 0x44
	ctx.r[5].s64 = ctx.r[31].s64 + 68;
	// 825C17E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C17E4: 4BEBF06D  bl 0x82480850
	ctx.lr = 0x825C17E8;
	sub_82480850(ctx, base);
	// 825C17E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C17EC: 4BC535ED  bl 0x82214dd8
	ctx.lr = 0x825C17F0;
	sub_82214DD8(ctx, base);
	// 825C17F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C17F4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C17F8: 388B5AAC  addi r4, r11, 0x5aac
	ctx.r[4].s64 = ctx.r[11].s64 + 23212;
	// 825C17FC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1800: 4BC6B6D1  bl 0x8222ced0
	ctx.lr = 0x825C1804;
	sub_8222CED0(ctx, base);
	// 825C1804: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 825C1808: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 825C180C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1810: 419A0008  beq cr6, 0x825c1818
	if ctx.cr[6].eq {
	pc = 0x825C1818; continue 'dispatch;
	}
	// 825C1814: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x825C1818; continue 'dispatch;
            }
            0x825C1818 => {
    //   block [0x825C1818..0x825C1958)
	// 825C1818: 38BF0048  addi r5, r31, 0x48
	ctx.r[5].s64 = ctx.r[31].s64 + 72;
	// 825C181C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 825C1820: 4BEBF031  bl 0x82480850
	ctx.lr = 0x825C1824;
	sub_82480850(ctx, base);
	// 825C1824: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1828: 4BC535B1  bl 0x82214dd8
	ctx.lr = 0x825C182C;
	sub_82214DD8(ctx, base);
	// 825C182C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 825C1830: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1834: 388B5984  addi r4, r11, 0x5984
	ctx.r[4].s64 = ctx.r[11].s64 + 22916;
	// 825C1838: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C183C: 4BC6B695  bl 0x8222ced0
	ctx.lr = 0x825C1840;
	sub_8222CED0(ctx, base);
	// 825C1840: 38BF0084  addi r5, r31, 0x84
	ctx.r[5].s64 = ctx.r[31].s64 + 132;
	// 825C1844: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1848: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C184C: 4845B5FD  bl 0x82a1ce48
	ctx.lr = 0x825C1850;
	sub_82A1CE48(ctx, base);
	// 825C1850: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1854: 4BC53585  bl 0x82214dd8
	ctx.lr = 0x825C1858;
	sub_82214DD8(ctx, base);
	// 825C1858: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 825C185C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1860: 388A5954  addi r4, r10, 0x5954
	ctx.r[4].s64 = ctx.r[10].s64 + 22868;
	// 825C1864: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1868: 4BC6B669  bl 0x8222ced0
	ctx.lr = 0x825C186C;
	sub_8222CED0(ctx, base);
	// 825C186C: 38BF0085  addi r5, r31, 0x85
	ctx.r[5].s64 = ctx.r[31].s64 + 133;
	// 825C1870: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1874: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1878: 4845B5D1  bl 0x82a1ce48
	ctx.lr = 0x825C187C;
	sub_82A1CE48(ctx, base);
	// 825C187C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1880: 4BC53559  bl 0x82214dd8
	ctx.lr = 0x825C1884;
	sub_82214DD8(ctx, base);
	// 825C1884: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 825C1888: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C188C: 38895978  addi r4, r9, 0x5978
	ctx.r[4].s64 = ctx.r[9].s64 + 22904;
	// 825C1890: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1894: 4BC6B63D  bl 0x8222ced0
	ctx.lr = 0x825C1898;
	sub_8222CED0(ctx, base);
	// 825C1898: 38BF0087  addi r5, r31, 0x87
	ctx.r[5].s64 = ctx.r[31].s64 + 135;
	// 825C189C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C18A0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18A4: 4845B5A5  bl 0x82a1ce48
	ctx.lr = 0x825C18A8;
	sub_82A1CE48(ctx, base);
	// 825C18A8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18AC: 4BC5352D  bl 0x82214dd8
	ctx.lr = 0x825C18B0;
	sub_82214DD8(ctx, base);
	// 825C18B0: 3D00820C  lis r8, -0x7df4
	ctx.r[8].s64 = -2113142784;
	// 825C18B4: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C18B8: 3888CE8C  addi r4, r8, -0x3174
	ctx.r[4].s64 = ctx.r[8].s64 + -12660;
	// 825C18BC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18C0: 4BC6B611  bl 0x8222ced0
	ctx.lr = 0x825C18C4;
	sub_8222CED0(ctx, base);
	// 825C18C4: 38BF0088  addi r5, r31, 0x88
	ctx.r[5].s64 = ctx.r[31].s64 + 136;
	// 825C18C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C18CC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18D0: 4845B579  bl 0x82a1ce48
	ctx.lr = 0x825C18D4;
	sub_82A1CE48(ctx, base);
	// 825C18D4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18D8: 4BC53501  bl 0x82214dd8
	ctx.lr = 0x825C18DC;
	sub_82214DD8(ctx, base);
	// 825C18DC: 3CE0820C  lis r7, -0x7df4
	ctx.r[7].s64 = -2113142784;
	// 825C18E0: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C18E4: 38875AC0  addi r4, r7, 0x5ac0
	ctx.r[4].s64 = ctx.r[7].s64 + 23232;
	// 825C18E8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18EC: 4BC6B5E5  bl 0x8222ced0
	ctx.lr = 0x825C18F0;
	sub_8222CED0(ctx, base);
	// 825C18F0: 38BF0089  addi r5, r31, 0x89
	ctx.r[5].s64 = ctx.r[31].s64 + 137;
	// 825C18F4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C18F8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C18FC: 4845B54D  bl 0x82a1ce48
	ctx.lr = 0x825C1900;
	sub_82A1CE48(ctx, base);
	// 825C1900: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1904: 4BC534D5  bl 0x82214dd8
	ctx.lr = 0x825C1908;
	sub_82214DD8(ctx, base);
	// 825C1908: 3CC0820C  lis r6, -0x7df4
	ctx.r[6].s64 = -2113142784;
	// 825C190C: 38A0FFFF  li r5, -1
	ctx.r[5].s64 = -1;
	// 825C1910: 3886599C  addi r4, r6, 0x599c
	ctx.r[4].s64 = ctx.r[6].s64 + 22940;
	// 825C1914: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1918: 4BC6B5B9  bl 0x8222ced0
	ctx.lr = 0x825C191C;
	sub_8222CED0(ctx, base);
	// 825C191C: 38BF008A  addi r5, r31, 0x8a
	ctx.r[5].s64 = ctx.r[31].s64 + 138;
	// 825C1920: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 825C1924: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1928: 4845B521  bl 0x82a1ce48
	ctx.lr = 0x825C192C;
	sub_82A1CE48(ctx, base);
	// 825C192C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 825C1930: 4BC534A9  bl 0x82214dd8
	ctx.lr = 0x825C1934;
	sub_82214DD8(ctx, base);
	// 825C1934: 5765063E  clrlwi r5, r27, 0x18
	ctx.r[5].u64 = ctx.r[27].u32 as u64 & 0x000000FFu64;
	// 825C1938: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 825C193C: 409A001C  bne cr6, 0x825c1958
	if !ctx.cr[6].eq {
	pc = 0x825C1958; continue 'dispatch;
	}
	// 825C1940: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1944: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1948: 40990010  ble cr6, 0x825c1958
	if !ctx.cr[6].gt {
	pc = 0x825C1958; continue 'dispatch;
	}
	// 825C194C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C1950: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1954: 4BDCBB65  bl 0x8238d4b8
	ctx.lr = 0x825C1958;
	sub_8238D4B8(ctx, base);
	pc = 0x825C1958; continue 'dispatch;
            }
            0x825C1958 => {
    //   block [0x825C1958..0x825C1960)
	// 825C1958: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825C195C: 486E7AF8  b 0x82ca9454
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C1960 size=196
    let mut pc: u32 = 0x825C1960;
    'dispatch: loop {
        match pc {
            0x825C1960 => {
    //   block [0x825C1960..0x825C1998)
	// 825C1960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C1964: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C1968: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C196C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C1970: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 825C1974: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C197C: 4099005C  ble cr6, 0x825c19d8
	if !ctx.cr[6].gt {
	pc = 0x825C19D8; continue 'dispatch;
	}
	// 825C1980: 895F0089  lbz r10, 0x89(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 825C1984: C01F003C  lfs f0, 0x3c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(60 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1988: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C198C: 419A000C  beq cr6, 0x825c1998
	if ctx.cr[6].eq {
	pc = 0x825C1998; continue 'dispatch;
	}
	// 825C1990: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 825C1994: 48000010  b 0x825c19a4
	pc = 0x825C19A4; continue 'dispatch;
            }
            0x825C1998 => {
    //   block [0x825C1998..0x825C19A4)
	// 825C1998: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825C199C: C1AA9490  lfs f13, -0x6b70(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 825C19A0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x825C19A4; continue 'dispatch;
            }
            0x825C19A4 => {
    //   block [0x825C19A4..0x825C19D8)
	// 825C19A4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 825C19A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C19AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825C19B0: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C19B4: FD60669C  fcfid f11, f12
	ctx.f[11].f64 = (ctx.f[12].s64 as f64);
	// 825C19B8: FD405818  frsp f10, f11
	ctx.f[10].f64 = (ctx.f[11].f64 as f32) as f64;
	// 825C19BC: ED2D5024  fdivs f9, f13, f10
	ctx.f[9].f64 = ((ctx.f[13].f64 / ctx.f[10].f64) as f32) as f64;
	// 825C19C0: ED09002A  fadds f8, f9, f0
	ctx.f[8].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 825C19C4: D11F003C  stfs f8, 0x3c(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 825C19C8: 48000A11  bl 0x825c23d8
	ctx.lr = 0x825C19CC;
	sub_825C23D8(ctx, base);
	// 825C19CC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C19D0: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 825C19D4: 915F0038  stw r10, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u32 ) };
	pc = 0x825C19D8; continue 'dispatch;
            }
            0x825C19D8 => {
    //   block [0x825C19D8..0x825C1A04)
	// 825C19D8: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C19DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C19E0: 41990030  bgt cr6, 0x825c1a10
	if ctx.cr[6].gt {
	pc = 0x825C1A10; continue 'dispatch;
	}
	// 825C19E4: 897F0089  lbz r11, 0x89(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[31].u32.wrapping_add(137 as u32) ) } as u64;
	// 825C19E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C19EC: 419A0018  beq cr6, 0x825c1a04
	if ctx.cr[6].eq {
	pc = 0x825C1A04; continue 'dispatch;
	}
	// 825C19F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C19F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C19F8: 997F0088  stb r11, 0x88(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u8 ) };
	// 825C19FC: 997F0089  stb r11, 0x89(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(137 as u32), ctx.r[11].u8 ) };
	// 825C1A00: 480003C1  bl 0x825c1dc0
	ctx.lr = 0x825C1A04;
	sub_825C1DC0(ctx, base);
	pc = 0x825C1A04; continue 'dispatch;
            }
            0x825C1A04 => {
    //   block [0x825C1A04..0x825C1A10)
	// 825C1A04: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 825C1A08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1A0C: 4BDCBC35  bl 0x8238d640
	ctx.lr = 0x825C1A10;
	sub_8238D640(ctx, base);
	pc = 0x825C1A10; continue 'dispatch;
            }
            0x825C1A10 => {
    //   block [0x825C1A10..0x825C1A24)
	// 825C1A10: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C1A14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C1A18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C1A1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C1A20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x825C1A30 size=560
    let mut pc: u32 = 0x825C1A30;
    'dispatch: loop {
        match pc {
            0x825C1A30 => {
    //   block [0x825C1A30..0x825C1A64)
	// 825C1A30: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C1A34: 486E79CD  bl 0x82ca9400
	ctx.lr = 0x825C1A38;
	sub_82CA93D0(ctx, base);
	// 825C1A38: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C1A3C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 825C1A40: 549A063E  clrlwi r26, r4, 0x18
	ctx.r[26].u64 = ctx.r[4].u32 as u64 & 0x000000FFu64;
	// 825C1A44: 897D0088  lbz r11, 0x88(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 825C1A48: 7F0BD040  cmplw cr6, r11, r26
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[26].u32, &mut ctx.xer);
	// 825C1A4C: 409A0018  bne cr6, 0x825c1a64
	if !ctx.cr[6].eq {
	pc = 0x825C1A64; continue 'dispatch;
	}
	// 825C1A50: 897D0089  lbz r11, 0x89(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[29].u32.wrapping_add(137 as u32) ) } as u64;
	// 825C1A54: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1A58: 419A0200  beq cr6, 0x825c1c58
	if ctx.cr[6].eq {
	pc = 0x825C1C58; continue 'dispatch;
	}
	// 825C1A5C: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825C1A60: 419A01F8  beq cr6, 0x825c1c58
	if ctx.cr[6].eq {
	pc = 0x825C1C58; continue 'dispatch;
	}
	pc = 0x825C1A64; continue 'dispatch;
            }
            0x825C1A64 => {
    //   block [0x825C1A64..0x825C1AA8)
	// 825C1A64: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1A68: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 825C1A6C: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 825C1A70: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	// 825C1A74: 814B0024  lwz r10, 0x24(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 825C1A78: 5549EFFE  rlwinm r9, r10, 0x1d, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x00000007u64;
	// 825C1A7C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825C1A80: 419A00D4  beq cr6, 0x825c1b54
	if ctx.cr[6].eq {
	pc = 0x825C1B54; continue 'dispatch;
	}
	// 825C1A84: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825C1A88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C1A8C: 419A001C  beq cr6, 0x825c1aa8
	if ctx.cr[6].eq {
	pc = 0x825C1AA8; continue 'dispatch;
	}
	// 825C1A90: 894A0003  lbz r10, 3(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(3 as u32) ) } as u64;
	// 825C1A94: 816B0048  lwz r11, 0x48(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1A98: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825C1A9C: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C1AA0: 83E90004  lwz r31, 4(r9)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1AA4: 480000B0  b 0x825c1b54
	pc = 0x825C1B54; continue 'dispatch;
            }
            0x825C1AA8 => {
    //   block [0x825C1AA8..0x825C1AC4)
	// 825C1AA8: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1AAC: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C1AB0: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	// 825C1AB4: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825C1AB8: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C1ABC: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1AC0: 40810054  ble 0x825c1b14
	if !ctx.cr[0].gt {
	pc = 0x825C1B14; continue 'dispatch;
	}
	pc = 0x825C1AC4; continue 'dispatch;
            }
            0x825C1AC4 => {
    //   block [0x825C1AC4..0x825C1AE4)
	// 825C1AC4: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C1AC8: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1ACC: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825C1AD0: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1AD4: 2F070003  cmpwi cr6, r7, 3
	ctx.cr[6].compare_i32(ctx.r[7].s32, 3, &mut ctx.xer);
	// 825C1AD8: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 825C1ADC: 41980008  blt cr6, 0x825c1ae4
	if ctx.cr[6].lt {
	pc = 0x825C1AE4; continue 'dispatch;
	}
	// 825C1AE0: 7F87E378  mr r7, r28
	ctx.r[7].u64 = ctx.r[28].u64;
	pc = 0x825C1AE4; continue 'dispatch;
            }
            0x825C1AE4 => {
    //   block [0x825C1AE4..0x825C1B00)
	// 825C1AE4: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825C1AE8: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825C1AEC: 419A0014  beq cr6, 0x825c1b00
	if ctx.cr[6].eq {
	pc = 0x825C1B00; continue 'dispatch;
	}
	// 825C1AF0: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825C1AF4: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825C1AF8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C1AFC: 4800000C  b 0x825c1b08
	pc = 0x825C1B08; continue 'dispatch;
            }
            0x825C1B00 => {
    //   block [0x825C1B00..0x825C1B08)
	// 825C1B00: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825C1B04: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825C1B08; continue 'dispatch;
            }
            0x825C1B08 => {
    //   block [0x825C1B08..0x825C1B14)
	// 825C1B08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1B0C: 4199FFB8  bgt cr6, 0x825c1ac4
	if ctx.cr[6].gt {
	pc = 0x825C1AC4; continue 'dispatch;
	}
	// 825C1B10: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825C1B14; continue 'dispatch;
            }
            0x825C1B14 => {
    //   block [0x825C1B14..0x825C1B30)
	// 825C1B14: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C1B18: 419A0034  beq cr6, 0x825c1b4c
	if ctx.cr[6].eq {
	pc = 0x825C1B4C; continue 'dispatch;
	}
	// 825C1B1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1B20: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 825C1B24: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 825C1B28: 41990008  bgt cr6, 0x825c1b30
	if ctx.cr[6].gt {
	pc = 0x825C1B30; continue 'dispatch;
	}
	// 825C1B2C: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x825C1B30; continue 'dispatch;
            }
            0x825C1B30 => {
    //   block [0x825C1B30..0x825C1B4C)
	// 825C1B30: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C1B34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1B38: 409A0014  bne cr6, 0x825c1b4c
	if !ctx.cr[6].eq {
	pc = 0x825C1B4C; continue 'dispatch;
	}
	// 825C1B3C: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C1B40: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825C1B44: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C1B48: 48000008  b 0x825c1b50
	pc = 0x825C1B50; continue 'dispatch;
            }
            0x825C1B4C => {
    //   block [0x825C1B4C..0x825C1B50)
	// 825C1B4C: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x825C1B50; continue 'dispatch;
            }
            0x825C1B50 => {
    //   block [0x825C1B50..0x825C1B54)
	// 825C1B50: 83EB0004  lwz r31, 4(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x825C1B54; continue 'dispatch;
            }
            0x825C1B54 => {
    //   block [0x825C1B54..0x825C1B6C)
	// 825C1B54: 83DF0090  lwz r30, 0x90(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825C1B58: 57CB0630  rlwinm r11, r30, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0xFFFFFFFFu64;
	// 825C1B5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1B60: 409A000C  bne cr6, 0x825c1b6c
	if !ctx.cr[6].eq {
	pc = 0x825C1B6C; continue 'dispatch;
	}
	// 825C1B64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1B68: 4BFB0D81  bl 0x825728e8
	ctx.lr = 0x825C1B6C;
	sub_825728E8(ctx, base);
	pc = 0x825C1B6C; continue 'dispatch;
            }
            0x825C1B6C => {
    //   block [0x825C1B6C..0x825C1BA0)
	// 825C1B6C: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 825C1B70: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 825C1B74: 616A0080  ori r10, r11, 0x80
	ctx.r[10].u64 = ctx.r[11].u64 | 128;
	// 825C1B78: 915F0090  stw r10, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 825C1B7C: 409A0024  bne cr6, 0x825c1ba0
	if !ctx.cr[6].eq {
	pc = 0x825C1BA0; continue 'dispatch;
	}
	// 825C1B80: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825C1B84: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1B88: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825C1B8C: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C1B90: 812A0058  lwz r9, 0x58(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(88 as u32) ) } as u64;
	// 825C1B94: 81090004  lwz r8, 4(r9)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1B98: 80680000  lwz r3, 0(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1B9C: 4BC4F47D  bl 0x82211018
	ctx.lr = 0x825C1BA0;
	sub_82211018(ctx, base);
	pc = 0x825C1BA0; continue 'dispatch;
            }
            0x825C1BA0 => {
    //   block [0x825C1BA0..0x825C1BE8)
	// 825C1BA0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1BA4: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 825C1BA8: 894B0090  lbz r10, 0x90(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 825C1BAC: 61490001  ori r9, r10, 1
	ctx.r[9].u64 = ctx.r[10].u64 | 1;
	// 825C1BB0: 992B0090  stb r9, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[9].u8 ) };
	// 825C1BB4: 419A0044  beq cr6, 0x825c1bf8
	if ctx.cr[6].eq {
	pc = 0x825C1BF8; continue 'dispatch;
	}
	// 825C1BB8: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 825C1BBC: 9B7D0088  stb r27, 0x88(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), ctx.r[27].u8 ) };
	// 825C1BC0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1BC4: 9B9D0089  stb r28, 0x89(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(137 as u32), ctx.r[28].u8 ) };
	// 825C1BC8: 40990020  ble cr6, 0x825c1be8
	if !ctx.cr[6].gt {
	pc = 0x825C1BE8; continue 'dispatch;
	}
	// 825C1BCC: 815D0038  lwz r10, 0x38(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1BD0: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 825C1BD4: 41990014  bgt cr6, 0x825c1be8
	if ctx.cr[6].gt {
	pc = 0x825C1BE8; continue 'dispatch;
	}
	// 825C1BD8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 825C1BDC: 392A9490  addi r9, r10, -0x6b70
	ctx.r[9].s64 = ctx.r[10].s64 + -27504;
	// 825C1BE0: C009FFF4  lfs f0, -0xc(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1BE4: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x825C1BE8; continue 'dispatch;
            }
            0x825C1BE8 => {
    //   block [0x825C1BE8..0x825C1BF8)
	// 825C1BE8: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 825C1BEC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1BF0: 480001D1  bl 0x825c1dc0
	ctx.lr = 0x825C1BF4;
	sub_825C1DC0(ctx, base);
	// 825C1BF4: 48000044  b 0x825c1c38
	pc = 0x825C1C38; continue 'dispatch;
            }
            0x825C1BF8 => {
    //   block [0x825C1BF8..0x825C1C1C)
	// 825C1BF8: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C1BFC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1C00: 40990024  ble cr6, 0x825c1c24
	if !ctx.cr[6].gt {
	pc = 0x825C1C24; continue 'dispatch;
	}
	// 825C1C04: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1C08: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1C0C: 41990010  bgt cr6, 0x825c1c1c
	if ctx.cr[6].gt {
	pc = 0x825C1C1C; continue 'dispatch;
	}
	// 825C1C10: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 825C1C14: C00B9490  lfs f0, -0x6b70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-27504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1C18: D01D003C  stfs f0, 0x3c(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(60 as u32), tmp.u32 ) };
	pc = 0x825C1C1C; continue 'dispatch;
            }
            0x825C1C1C => {
    //   block [0x825C1C1C..0x825C1C24)
	// 825C1C1C: 9B7D0089  stb r27, 0x89(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(137 as u32), ctx.r[27].u8 ) };
	// 825C1C20: 48000010  b 0x825c1c30
	pc = 0x825C1C30; continue 'dispatch;
            }
            0x825C1C24 => {
    //   block [0x825C1C24..0x825C1C30)
	// 825C1C24: 9B9D0088  stb r28, 0x88(r29)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), ctx.r[28].u8 ) };
	// 825C1C28: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1C2C: 48000195  bl 0x825c1dc0
	ctx.lr = 0x825C1C30;
	sub_825C1DC0(ctx, base);
	pc = 0x825C1C30; continue 'dispatch;
            }
            0x825C1C30 => {
    //   block [0x825C1C30..0x825C1C38)
	// 825C1C30: 817D0034  lwz r11, 0x34(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) } as u64;
	// 825C1C34: 917D0038  stw r11, 0x38(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	pc = 0x825C1C38; continue 'dispatch;
            }
            0x825C1C38 => {
    //   block [0x825C1C38..0x825C1C50)
	// 825C1C38: 817D0038  lwz r11, 0x38(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) } as u64;
	// 825C1C3C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1C40: 40990010  ble cr6, 0x825c1c50
	if !ctx.cr[6].gt {
	pc = 0x825C1C50; continue 'dispatch;
	}
	// 825C1C44: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 825C1C48: 807D0004  lwz r3, 4(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1C4C: 4BDCB86D  bl 0x8238d4b8
	ctx.lr = 0x825C1C50;
	sub_8238D4B8(ctx, base);
	pc = 0x825C1C50; continue 'dispatch;
            }
            0x825C1C50 => {
    //   block [0x825C1C50..0x825C1C58)
	// 825C1C50: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 825C1C54: 4800000D  bl 0x825c1c60
	ctx.lr = 0x825C1C58;
	sub_825C1C60(ctx, base);
	pc = 0x825C1C58; continue 'dispatch;
            }
            0x825C1C58 => {
    //   block [0x825C1C58..0x825C1C60)
	// 825C1C58: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 825C1C5C: 486E77F4  b 0x82ca9450
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1C60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C1C60 size=348
    let mut pc: u32 = 0x825C1C60;
    'dispatch: loop {
        match pc {
            0x825C1C60 => {
    //   block [0x825C1C60..0x825C1CB4)
	// 825C1C60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C1C64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C1C68: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C1C6C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825C1C70: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 825C1C74: 81650004  lwz r11, 4(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1C78: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1C7C: 554957FE  rlwinm r9, r10, 0xa, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x003FFFFFu64;
	// 825C1C80: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825C1C84: 419A00F4  beq cr6, 0x825c1d78
	if ctx.cr[6].eq {
	pc = 0x825C1D78; continue 'dispatch;
	}
	// 825C1C88: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 825C1C8C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C1C90: 419A0024  beq cr6, 0x825c1cb4
	if ctx.cr[6].eq {
	pc = 0x825C1CB4; continue 'dispatch;
	}
	// 825C1C94: 892A0056  lbz r9, 0x56(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[10].u32.wrapping_add(86 as u32) ) } as u64;
	// 825C1C98: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1C9C: 552B183E  rotlwi r11, r9, 3
	ctx.r[11].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 825C1CA0: 7D0B5214  add r8, r11, r10
	ctx.r[8].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 825C1CA4: 81680004  lwz r11, 4(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1CA8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825C1CAC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1CB0: 480000CC  b 0x825c1d7c
	pc = 0x825C1D7C; continue 'dispatch;
            }
            0x825C1CB4 => {
    //   block [0x825C1CB4..0x825C1CD0)
	// 825C1CB4: 814B0048  lwz r10, 0x48(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1CB8: 80CB004C  lwz r6, 0x4c(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C1CBC: 90610050  stw r3, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[3].u32 ) };
	// 825C1CC0: 7D6A3050  subf r11, r10, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825C1CC4: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C1CC8: 7D6B1E71  srawi. r11, r11, 3
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1CCC: 40810054  ble 0x825c1d20
	if !ctx.cr[0].gt {
	pc = 0x825C1D20; continue 'dispatch;
	}
	pc = 0x825C1CD0; continue 'dispatch;
            }
            0x825C1CD0 => {
    //   block [0x825C1CD0..0x825C1CF0)
	// 825C1CD0: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C1CD4: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1CD8: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825C1CDC: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1CE0: 2F070056  cmpwi cr6, r7, 0x56
	ctx.cr[6].compare_i32(ctx.r[7].s32, 86, &mut ctx.xer);
	// 825C1CE4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825C1CE8: 41980008  blt cr6, 0x825c1cf0
	if ctx.cr[6].lt {
	pc = 0x825C1CF0; continue 'dispatch;
	}
	// 825C1CEC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	pc = 0x825C1CF0; continue 'dispatch;
            }
            0x825C1CF0 => {
    //   block [0x825C1CF0..0x825C1D0C)
	// 825C1CF0: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825C1CF4: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825C1CF8: 419A0014  beq cr6, 0x825c1d0c
	if ctx.cr[6].eq {
	pc = 0x825C1D0C; continue 'dispatch;
	}
	// 825C1CFC: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825C1D00: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825C1D04: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C1D08: 4800000C  b 0x825c1d14
	pc = 0x825C1D14; continue 'dispatch;
            }
            0x825C1D0C => {
    //   block [0x825C1D0C..0x825C1D14)
	// 825C1D0C: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825C1D10: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825C1D14; continue 'dispatch;
            }
            0x825C1D14 => {
    //   block [0x825C1D14..0x825C1D20)
	// 825C1D14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1D18: 4199FFB8  bgt cr6, 0x825c1cd0
	if ctx.cr[6].gt {
	pc = 0x825C1CD0; continue 'dispatch;
	}
	// 825C1D1C: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825C1D20; continue 'dispatch;
            }
            0x825C1D20 => {
    //   block [0x825C1D20..0x825C1D3C)
	// 825C1D20: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C1D24: 419A0040  beq cr6, 0x825c1d64
	if ctx.cr[6].eq {
	pc = 0x825C1D64; continue 'dispatch;
	}
	// 825C1D28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1D2C: 2F0B0056  cmpwi cr6, r11, 0x56
	ctx.cr[6].compare_i32(ctx.r[11].s32, 86, &mut ctx.xer);
	// 825C1D30: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1D34: 41990008  bgt cr6, 0x825c1d3c
	if ctx.cr[6].gt {
	pc = 0x825C1D3C; continue 'dispatch;
	}
	// 825C1D38: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x825C1D3C; continue 'dispatch;
            }
            0x825C1D3C => {
    //   block [0x825C1D3C..0x825C1D64)
	// 825C1D3C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C1D40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1D44: 409A0020  bne cr6, 0x825c1d64
	if !ctx.cr[6].eq {
	pc = 0x825C1D64; continue 'dispatch;
	}
	// 825C1D48: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C1D4C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825C1D50: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C1D54: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1D58: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825C1D5C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1D60: 4800001C  b 0x825c1d7c
	pc = 0x825C1D7C; continue 'dispatch;
            }
            0x825C1D64 => {
    //   block [0x825C1D64..0x825C1D78)
	// 825C1D64: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825C1D68: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1D6C: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825C1D70: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1D74: 48000008  b 0x825c1d7c
	pc = 0x825C1D7C; continue 'dispatch;
            }
            0x825C1D78 => {
    //   block [0x825C1D78..0x825C1D7C)
	// 825C1D78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	pc = 0x825C1D7C; continue 'dispatch;
            }
            0x825C1D7C => {
    //   block [0x825C1D7C..0x825C1DA8)
	// 825C1D7C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C1D80: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1D84: 419A0028  beq cr6, 0x825c1dac
	if ctx.cr[6].eq {
	pc = 0x825C1DAC; continue 'dispatch;
	}
	// 825C1D88: 89650088  lbz r11, 0x88(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[5].u32.wrapping_add(136 as u32) ) } as u64;
	// 825C1D8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1D90: 419A0018  beq cr6, 0x825c1da8
	if ctx.cr[6].eq {
	pc = 0x825C1DA8; continue 'dispatch;
	}
	// 825C1D94: 481A425D  bl 0x82765ff0
	ctx.lr = 0x825C1D98;
	sub_82765FF0(ctx, base);
	// 825C1D98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C1D9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C1DA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C1DA4: 4E800020  blr
	return;
            }
            0x825C1DA8 => {
    //   block [0x825C1DA8..0x825C1DAC)
	// 825C1DA8: 481A4929  bl 0x827666d0
	ctx.lr = 0x825C1DAC;
	sub_827666D0(ctx, base);
	pc = 0x825C1DAC; continue 'dispatch;
            }
            0x825C1DAC => {
    //   block [0x825C1DAC..0x825C1DBC)
	// 825C1DAC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 825C1DB0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C1DB4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C1DB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1DC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C1DC0 size=392
    let mut pc: u32 = 0x825C1DC0;
    'dispatch: loop {
        match pc {
            0x825C1DC0 => {
    //   block [0x825C1DC0..0x825C1E14)
	// 825C1DC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C1DC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 825C1DC8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 825C1DCC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C1DD0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 825C1DD4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C1DD8: 80A40004  lwz r5, 4(r4)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1DDC: 8145002C  lwz r10, 0x2c(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(44 as u32) ) } as u64;
	// 825C1DE0: 55492FFE  rlwinm r9, r10, 5, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[10].u32 as u64 & 0x07FFFFFFu64;
	// 825C1DE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 825C1DE8: 419A00EC  beq cr6, 0x825c1ed4
	if ctx.cr[6].eq {
	pc = 0x825C1ED4; continue 'dispatch;
	}
	// 825C1DEC: 8165008C  lwz r11, 0x8c(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(140 as u32) ) } as u64;
	// 825C1DF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1DF4: 419A0020  beq cr6, 0x825c1e14
	if ctx.cr[6].eq {
	pc = 0x825C1E14; continue 'dispatch;
	}
	// 825C1DF8: 894B005B  lbz r10, 0x5b(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(91 as u32) ) } as u64;
	// 825C1DFC: 81650048  lwz r11, 0x48(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1E00: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 825C1E04: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 825C1E08: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825C1E0C: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1E10: 480000C8  b 0x825c1ed8
	pc = 0x825C1ED8; continue 'dispatch;
            }
            0x825C1E14 => {
    //   block [0x825C1E14..0x825C1E34)
	// 825C1E14: 81450048  lwz r10, 0x48(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(72 as u32) ) } as u64;
	// 825C1E18: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 825C1E1C: 80C5004C  lwz r6, 0x4c(r5)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(76 as u32) ) } as u64;
	// 825C1E20: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 825C1E24: 7D2A3050  subf r9, r10, r6
	ctx.r[9].s64 = ctx.r[6].s64 - ctx.r[10].s64;
	// 825C1E28: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	// 825C1E2C: 7D2B1E71  srawi. r11, r9, 3
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 3) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[9].s32 >> 3) as i64;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1E30: 40810054  ble 0x825c1e84
	if !ctx.cr[0].gt {
	pc = 0x825C1E84; continue 'dispatch;
	}
	pc = 0x825C1E34; continue 'dispatch;
            }
            0x825C1E34 => {
    //   block [0x825C1E34..0x825C1E54)
	// 825C1E34: 7D690E70  srawi r9, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[9].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 825C1E38: 55281838  slwi r8, r9, 3
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C1E3C: 7D485214  add r10, r8, r10
	ctx.r[10].u64 = ctx.r[8].u64 + ctx.r[10].u64;
	// 825C1E40: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1E44: 2F07005B  cmpwi cr6, r7, 0x5b
	ctx.cr[6].compare_i32(ctx.r[7].s32, 91, &mut ctx.xer);
	// 825C1E48: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 825C1E4C: 41980008  blt cr6, 0x825c1e54
	if ctx.cr[6].lt {
	pc = 0x825C1E54; continue 'dispatch;
	}
	// 825C1E50: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	pc = 0x825C1E54; continue 'dispatch;
            }
            0x825C1E54 => {
    //   block [0x825C1E54..0x825C1E70)
	// 825C1E54: 54E7063E  clrlwi r7, r7, 0x18
	ctx.r[7].u64 = ctx.r[7].u32 as u64 & 0x000000FFu64;
	// 825C1E58: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 825C1E5C: 419A0014  beq cr6, 0x825c1e70
	if ctx.cr[6].eq {
	pc = 0x825C1E70; continue 'dispatch;
	}
	// 825C1E60: 7D695850  subf r11, r9, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[9].s64;
	// 825C1E64: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 825C1E68: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 825C1E6C: 4800000C  b 0x825c1e78
	pc = 0x825C1E78; continue 'dispatch;
            }
            0x825C1E70 => {
    //   block [0x825C1E70..0x825C1E78)
	// 825C1E70: 7D485050  subf r10, r8, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[8].s64;
	// 825C1E74: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	pc = 0x825C1E78; continue 'dispatch;
            }
            0x825C1E78 => {
    //   block [0x825C1E78..0x825C1E84)
	// 825C1E78: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 825C1E7C: 4199FFB8  bgt cr6, 0x825c1e34
	if ctx.cr[6].gt {
	pc = 0x825C1E34; continue 'dispatch;
	}
	// 825C1E80: 91410054  stw r10, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u32 ) };
	pc = 0x825C1E84; continue 'dispatch;
            }
            0x825C1E84 => {
    //   block [0x825C1E84..0x825C1EA0)
	// 825C1E84: 7F0A3040  cmplw cr6, r10, r6
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[6].u32, &mut ctx.xer);
	// 825C1E88: 419A003C  beq cr6, 0x825c1ec4
	if ctx.cr[6].eq {
	pc = 0x825C1EC4; continue 'dispatch;
	}
	// 825C1E8C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C1E90: 2F0B005B  cmpwi cr6, r11, 0x5b
	ctx.cr[6].compare_i32(ctx.r[11].s32, 91, &mut ctx.xer);
	// 825C1E94: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 825C1E98: 41990008  bgt cr6, 0x825c1ea0
	if ctx.cr[6].gt {
	pc = 0x825C1EA0; continue 'dispatch;
	}
	// 825C1E9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x825C1EA0; continue 'dispatch;
            }
            0x825C1EA0 => {
    //   block [0x825C1EA0..0x825C1EC4)
	// 825C1EA0: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 825C1EA4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1EA8: 409A001C  bne cr6, 0x825c1ec4
	if !ctx.cr[6].eq {
	pc = 0x825C1EC4; continue 'dispatch;
	}
	// 825C1EAC: E9610050  ld r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 825C1EB0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825C1EB4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 825C1EB8: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 825C1EBC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1EC0: 48000018  b 0x825c1ed8
	pc = 0x825C1ED8; continue 'dispatch;
            }
            0x825C1EC4 => {
    //   block [0x825C1EC4..0x825C1ED4)
	// 825C1EC4: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	// 825C1EC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 825C1ECC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1ED0: 48000008  b 0x825c1ed8
	pc = 0x825C1ED8; continue 'dispatch;
            }
            0x825C1ED4 => {
    //   block [0x825C1ED4..0x825C1ED8)
	// 825C1ED4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x825C1ED8; continue 'dispatch;
            }
            0x825C1ED8 => {
    //   block [0x825C1ED8..0x825C1F34)
	// 825C1ED8: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 825C1EDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 825C1EE0: 419A0054  beq cr6, 0x825c1f34
	if ctx.cr[6].eq {
	pc = 0x825C1F34; continue 'dispatch;
	}
	// 825C1EE4: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 825C1EE8: 4BC52C11  bl 0x82214af8
	ctx.lr = 0x825C1EEC;
	sub_82214AF8(ctx, base);
	// 825C1EEC: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 825C1EF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C1EF4: 419A0040  beq cr6, 0x825c1f34
	if ctx.cr[6].eq {
	pc = 0x825C1F34; continue 'dispatch;
	}
	// 825C1EF8: 3D608349  lis r11, -0x7cb7
	ctx.r[11].s64 = -2092367872;
	// 825C1EFC: 89440088  lbz r10, 0x88(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 825C1F00: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 825C1F04: 7CA32B78  mr r3, r5
	ctx.r[3].u64 = ctx.r[5].u64;
	// 825C1F08: 3909633C  addi r8, r9, 0x633c
	ctx.r[8].s64 = ctx.r[9].s64 + 25404;
	// 825C1F0C: 816B6AB8  lwz r11, 0x6ab8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(27320 as u32) ) } as u64;
	// 825C1F10: 99410054  stb r10, 0x54(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[10].u8 ) };
	// 825C1F14: 91010050  stw r8, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u32 ) };
	// 825C1F18: 80EB000C  lwz r7, 0xc(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 825C1F1C: 83E7008C  lwz r31, 0x8c(r7)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(140 as u32) ) } as u64;
	// 825C1F20: 4BBF0471  bl 0x821b2390
	ctx.lr = 0x825C1F24;
	sub_821B2390(ctx, base);
	// 825C1F24: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 825C1F28: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825C1F2C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 825C1F30: 4BFEAB01  bl 0x825aca30
	ctx.lr = 0x825C1F34;
	sub_825ACA30(ctx, base);
	pc = 0x825C1F34; continue 'dispatch;
            }
            0x825C1F34 => {
    //   block [0x825C1F34..0x825C1F48)
	// 825C1F34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 825C1F38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 825C1F3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 825C1F40: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 825C1F44: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1F48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C1F48 size=52
    let mut pc: u32 = 0x825C1F48;
    'dispatch: loop {
        match pc {
            0x825C1F48 => {
    //   block [0x825C1F48..0x825C1F6C)
	// 825C1F48: 89630012  lbz r11, 0x12(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(18 as u32) ) } as u64;
	// 825C1F4C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 825C1F50: 409A001C  bne cr6, 0x825c1f6c
	if !ctx.cr[6].eq {
	pc = 0x825C1F6C; continue 'dispatch;
	}
	// 825C1F54: 89630011  lbz r11, 0x11(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(17 as u32) ) } as u64;
	// 825C1F58: 7F0B2800  cmpw cr6, r11, r5
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[5].s32, &mut ctx.xer);
	// 825C1F5C: 409A0010  bne cr6, 0x825c1f6c
	if !ctx.cr[6].eq {
	pc = 0x825C1F6C; continue 'dispatch;
	}
	// 825C1F60: 89630010  lbz r11, 0x10(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) } as u64;
	// 825C1F64: 7F0B3000  cmpw cr6, r11, r6
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[6].s32, &mut ctx.xer);
	// 825C1F68: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x825C1F6C; continue 'dispatch;
            }
            0x825C1F6C => {
    //   block [0x825C1F6C..0x825C1F7C)
	// 825C1F6C: 98830012  stb r4, 0x12(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(18 as u32), ctx.r[4].u8 ) };
	// 825C1F70: 98A30011  stb r5, 0x11(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(17 as u32), ctx.r[5].u8 ) };
	// 825C1F74: 98C30010  stb r6, 0x10(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[6].u8 ) };
	// 825C1F78: 48000460  b 0x825c23d8
	sub_825C23D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1F7C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C1F7C size=4
    let mut pc: u32 = 0x825C1F7C;
    'dispatch: loop {
        match pc {
            0x825C1F7C => {
    //   block [0x825C1F7C..0x825C1F80)
	// 825C1F7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C1F80 size=20
    let mut pc: u32 = 0x825C1F80;
    'dispatch: loop {
        match pc {
            0x825C1F80 => {
    //   block [0x825C1F80..0x825C1F94)
	// 825C1F80: C0030018  lfs f0, 0x18(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1F84: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 825C1F88: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825C1F8C: D0230018  stfs f1, 0x18(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 825C1F90: 48000448  b 0x825c23d8
	sub_825C23D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1F94(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C1F94 size=4
    let mut pc: u32 = 0x825C1F94;
    'dispatch: loop {
        match pc {
            0x825C1F94 => {
    //   block [0x825C1F94..0x825C1F98)
	// 825C1F94: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x825C1F98 size=20
    let mut pc: u32 = 0x825C1F98;
    'dispatch: loop {
        match pc {
            0x825C1F98 => {
    //   block [0x825C1F98..0x825C1FAC)
	// 825C1F98: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 825C1F9C: FF000800  fcmpu cr6, f0, f1
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[1].f64);
	// 825C1FA0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 825C1FA4: D0230014  stfs f1, 0x14(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 825C1FA8: 48000430  b 0x825c23d8
	sub_825C23D8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1FAC(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C1FAC size=4
    let mut pc: u32 = 0x825C1FAC;
    'dispatch: loop {
        match pc {
            0x825C1FAC => {
    //   block [0x825C1FAC..0x825C1FB0)
	// 825C1FAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C1FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C1FB0 size=172
    let mut pc: u32 = 0x825C1FB0;
    'dispatch: loop {
        match pc {
            0x825C1FB0 => {
    //   block [0x825C1FB0..0x825C1FE0)
	// 825C1FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C1FB4: 486E7455  bl 0x82ca9408
	ctx.lr = 0x825C1FB8;
	sub_82CA93D0(ctx, base);
	// 825C1FB8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C1FBC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 825C1FC0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C1FC4: 3BDC0068  addi r30, r28, 0x68
	ctx.r[30].s64 = ctx.r[28].s64 + 104;
	// 825C1FC8: 817C0070  lwz r11, 0x70(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(112 as u32) ) } as u64;
	// 825C1FCC: 815C006C  lwz r10, 0x6c(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 825C1FD0: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825C1FD4: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825C1FD8: 41820034  beq 0x825c200c
	if ctx.cr[0].eq {
	pc = 0x825C200C; continue 'dispatch;
	}
	// 825C1FDC: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x825C1FE0; continue 'dispatch;
            }
            0x825C1FE0 => {
    //   block [0x825C1FE0..0x825C200C)
	// 825C1FE0: 817C006C  lwz r11, 0x6c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) } as u64;
	// 825C1FE4: 7C6BFA14  add r3, r11, r31
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 825C1FE8: 4BC2C2D1  bl 0x821ee2b8
	ctx.lr = 0x825C1FEC;
	sub_821EE2B8(ctx, base);
	// 825C1FEC: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C1FF0: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C1FF4: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C1FF8: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 825C1FFC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825C2000: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825C2004: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C2008: 4198FFD8  blt cr6, 0x825c1fe0
	if ctx.cr[6].lt {
	pc = 0x825C1FE0; continue 'dispatch;
	}
	pc = 0x825C200C; continue 'dispatch;
            }
            0x825C200C => {
    //   block [0x825C200C..0x825C203C)
	// 825C200C: 813E0004  lwz r9, 4(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C2010: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C2014: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C2018: 419A003C  beq cr6, 0x825c2054
	if ctx.cr[6].eq {
	pc = 0x825C2054; continue 'dispatch;
	}
	// 825C201C: 7D0B5850  subf r8, r11, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[11].s64;
	// 825C2020: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 825C2024: 7D071670  srawi r7, r8, 2
	ctx.xer.ca = (ctx.r[8].s32 < 0) && ((ctx.r[8].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[7].s64 = (ctx.r[8].s32 >> 2) as i64;
	// 825C2028: 7F0B5840  cmplw cr6, r11, r11
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C202C: 54E8103A  slwi r8, r7, 2
	ctx.r[8].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 825C2030: 7D084A14  add r8, r8, r9
	ctx.r[8].u64 = ctx.r[8].u64 + ctx.r[9].u64;
	// 825C2034: 419A001C  beq cr6, 0x825c2050
	if ctx.cr[6].eq {
	pc = 0x825C2050; continue 'dispatch;
	}
	// 825C2038: 7D2B4850  subf r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	pc = 0x825C203C; continue 'dispatch;
            }
            0x825C203C => {
    //   block [0x825C203C..0x825C2050)
	// 825C203C: 80EA0000  lwz r7, 0(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 825C2040: 7CE9512E  stwx r7, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 825C2044: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 825C2048: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 825C204C: 409AFFF0  bne cr6, 0x825c203c
	if !ctx.cr[6].eq {
	pc = 0x825C203C; continue 'dispatch;
	}
	pc = 0x825C2050; continue 'dispatch;
            }
            0x825C2050 => {
    //   block [0x825C2050..0x825C2054)
	// 825C2050: 911E0008  stw r8, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	pc = 0x825C2054; continue 'dispatch;
            }
            0x825C2054 => {
    //   block [0x825C2054..0x825C205C)
	// 825C2054: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 825C2058: 486E7400  b 0x82ca9458
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2060(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x825C2060 size=164
    let mut pc: u32 = 0x825C2060;
    'dispatch: loop {
        match pc {
            0x825C2060 => {
    //   block [0x825C2060..0x825C2084)
	// 825C2060: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C2064: 486E7399  bl 0x82ca93fc
	ctx.lr = 0x825C2068;
	sub_82CA93D0(ctx, base);
	// 825C2068: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 825C206C: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 825C2070: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 825C2074: 897A007E  lbz r11, 0x7e(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(126 as u32) ) } as u64;
	// 825C2078: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 825C207C: 419A0008  beq cr6, 0x825c2084
	if ctx.cr[6].eq {
	pc = 0x825C2084; continue 'dispatch;
	}
	// 825C2080: 3B200000  li r25, 0
	ctx.r[25].s64 = 0;
	pc = 0x825C2084; continue 'dispatch;
            }
            0x825C2084 => {
    //   block [0x825C2084..0x825C20B4)
	// 825C2084: 817A0070  lwz r11, 0x70(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(112 as u32) ) } as u64;
	// 825C2088: 3BFA0068  addi r31, r26, 0x68
	ctx.r[31].s64 = ctx.r[26].s64 + 104;
	// 825C208C: 815A006C  lwz r10, 0x6c(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(108 as u32) ) } as u64;
	// 825C2090: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 825C2094: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825C2098: 7D281671  srawi. r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 825C209C: 41820060  beq 0x825c20fc
	if ctx.cr[0].eq {
	pc = 0x825C20FC; continue 'dispatch;
	}
	// 825C20A0: 3D40820F  lis r10, -0x7df1
	ctx.r[10].s64 = -2112946176;
	// 825C20A4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 825C20A8: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 825C20AC: 3B8A44B0  addi r28, r10, 0x44b0
	ctx.r[28].s64 = ctx.r[10].s64 + 17584;
	// 825C20B0: 3B6B113C  addi r27, r11, 0x113c
	ctx.r[27].s64 = ctx.r[11].s64 + 4412;
	pc = 0x825C20B4; continue 'dispatch;
            }
            0x825C20B4 => {
    //   block [0x825C20B4..0x825C20DC)
	// 825C20B4: 817A006C  lwz r11, 0x6c(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(108 as u32) ) } as u64;
	// 825C20B8: 7C6BF02E  lwzx r3, r11, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 825C20BC: 2F03FFFF  cmpwi cr6, r3, -1
	ctx.cr[6].compare_i32(ctx.r[3].s32, -1, &mut ctx.xer);
	// 825C20C0: 419A001C  beq cr6, 0x825c20dc
	if ctx.cr[6].eq {
	pc = 0x825C20DC; continue 'dispatch;
	}
	// 825C20C4: 93210054  stw r25, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[25].u32 ) };
	// 825C20C8: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 825C20CC: 93610050  stw r27, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u32 ) };
	// 825C20D0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 825C20D4: 4BC689F5  bl 0x8222aac8
	ctx.lr = 0x825C20D8;
	sub_8222AAC8(ctx, base);
	// 825C20D8: 93810050  stw r28, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[28].u32 ) };
	pc = 0x825C20DC; continue 'dispatch;
            }
            0x825C20DC => {
    //   block [0x825C20DC..0x825C20FC)
	// 825C20DC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 825C20E0: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 825C20E4: 815F0004  lwz r10, 4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 825C20E8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 825C20EC: 7D2A5850  subf r9, r10, r11
	ctx.r[9].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 825C20F0: 7D281670  srawi r8, r9, 2
	ctx.xer.ca = (ctx.r[9].s32 < 0) && ((ctx.r[9].u32 & ((1u32 << 2) - 1)) != 0);
	ctx.r[8].s64 = (ctx.r[9].s32 >> 2) as i64;
	// 825C20F4: 7F1D4040  cmplw cr6, r29, r8
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[8].u32, &mut ctx.xer);
	// 825C20F8: 4198FFBC  blt cr6, 0x825c20b4
	if ctx.cr[6].lt {
	pc = 0x825C20B4; continue 'dispatch;
	}
	pc = 0x825C20FC; continue 'dispatch;
            }
            0x825C20FC => {
    //   block [0x825C20FC..0x825C2104)
	// 825C20FC: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 825C2100: 486E734C  b 0x82ca944c
	sub_82CA9420(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_825C2108(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x825C2108 size=720
    let mut pc: u32 = 0x825C2108;
    'dispatch: loop {
        match pc {
            0x825C2108 => {
    //   block [0x825C2108..0x825C23D8)
	// 825C2108: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 825C210C: 486E72F9  bl 0x82ca9404
	ctx.lr = 0x825C2110;
	sub_82CA93D0(ctx, base);
	// 825C2110: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


