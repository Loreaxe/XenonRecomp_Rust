pub fn sub_82189638(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82189638 size=8
    let mut pc: u32 = 0x82189638;
    'dispatch: loop {
        match pc {
            0x82189638 => {
    //   block [0x82189638..0x82189640)
	// 82189638: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218963C: 481F6BC4  b 0x82380200
	sub_82380200(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189640(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82189640 size=12
    let mut pc: u32 = 0x82189640;
    'dispatch: loop {
        match pc {
            0x82189640 => {
    //   block [0x82189640..0x8218964C)
	// 82189640: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189644: 386B0480  addi r3, r11, 0x480
	ctx.r[3].s64 = ctx.r[11].s64 + 1152;
	// 82189648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82189650 size=12
    let mut pc: u32 = 0x82189650;
    'dispatch: loop {
        match pc {
            0x82189650 => {
    //   block [0x82189650..0x8218965C)
	// 82189650: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189654: 386B0490  addi r3, r11, 0x490
	ctx.r[3].s64 = ctx.r[11].s64 + 1168;
	// 82189658: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189660 size=60
    let mut pc: u32 = 0x82189660;
    'dispatch: loop {
        match pc {
            0x82189660 => {
    //   block [0x82189660..0x8218969C)
	// 82189660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189668: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218966C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189670: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189674: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189678: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218967C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189680: 4E800421  bctrl
	ctx.lr = 0x82189684;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189684: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 82189688: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218968C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189694: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189698: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896A0 size=8
    let mut pc: u32 = 0x821896A0;
    'dispatch: loop {
        match pc {
            0x821896A0 => {
    //   block [0x821896A0..0x821896A8)
	// 821896A0: 38600017  li r3, 0x17
	ctx.r[3].s64 = 23;
	// 821896A4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896A8 size=8
    let mut pc: u32 = 0x821896A8;
    'dispatch: loop {
        match pc {
            0x821896A8 => {
    //   block [0x821896A8..0x821896B0)
	// 821896A8: 3860000E  li r3, 0xe
	ctx.r[3].s64 = 14;
	// 821896AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896B0 size=8
    let mut pc: u32 = 0x821896B0;
    'dispatch: loop {
        match pc {
            0x821896B0 => {
    //   block [0x821896B0..0x821896B8)
	// 821896B0: 3860000F  li r3, 0xf
	ctx.r[3].s64 = 15;
	// 821896B4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896B8 size=8
    let mut pc: u32 = 0x821896B8;
    'dispatch: loop {
        match pc {
            0x821896B8 => {
    //   block [0x821896B8..0x821896C0)
	// 821896B8: 38600012  li r3, 0x12
	ctx.r[3].s64 = 18;
	// 821896BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896C0 size=8
    let mut pc: u32 = 0x821896C0;
    'dispatch: loop {
        match pc {
            0x821896C0 => {
    //   block [0x821896C0..0x821896C8)
	// 821896C0: 38600011  li r3, 0x11
	ctx.r[3].s64 = 17;
	// 821896C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896C8 size=8
    let mut pc: u32 = 0x821896C8;
    'dispatch: loop {
        match pc {
            0x821896C8 => {
    //   block [0x821896C8..0x821896D0)
	// 821896C8: 38630240  addi r3, r3, 0x240
	ctx.r[3].s64 = ctx.r[3].s64 + 576;
	// 821896CC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821896D0 size=8
    let mut pc: u32 = 0x821896D0;
    'dispatch: loop {
        match pc {
            0x821896D0 => {
    //   block [0x821896D0..0x821896D8)
	// 821896D0: 38600015  li r3, 0x15
	ctx.r[3].s64 = 21;
	// 821896D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821896D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821896D8 size=140
    let mut pc: u32 = 0x821896D8;
    'dispatch: loop {
        match pc {
            0x821896D8 => {
    //   block [0x821896D8..0x82189704)
	// 821896D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821896DC: 483AB9E1  bl 0x825350bc
	ctx.lr = 0x821896E0;
	sub_82535080(ctx, base);
	// 821896E0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821896E4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821896E8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821896EC: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 821896F0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821896F4: 409A0010  bne cr6, 0x82189704
	if !ctx.cr[6].eq {
	pc = 0x82189704; continue 'dispatch;
	}
	// 821896F8: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821896FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189700: 483ABA0C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189704 => {
    //   block [0x82189704..0x82189764)
	// 82189704: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 82189708: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218970C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189710: 483ABAC1  bl 0x825351d0
	ctx.lr = 0x82189714;
	sub_825351D0(ctx, base);
	// 82189714: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189718: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8218971C: 396B0770  addi r11, r11, 0x770
	ctx.r[11].s64 = ctx.r[11].s64 + 1904;
	// 82189720: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82189724: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189728: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 8218972C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189730: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82189734: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189738: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218973C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189740: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82189744: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189748: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218974C: 4E800421  bctrl
	ctx.lr = 0x82189750;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189750: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82189754: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82189758: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218975C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189760: 483AB9AC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189768(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189768 size=152
    let mut pc: u32 = 0x82189768;
    'dispatch: loop {
        match pc {
            0x82189768 => {
    //   block [0x82189768..0x82189794)
	// 82189768: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218976C: 483AB951  bl 0x825350bc
	ctx.lr = 0x82189770;
	sub_82535080(ctx, base);
	// 82189770: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189774: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189778: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218977C: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82189780: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189784: 409A0010  bne cr6, 0x82189794
	if !ctx.cr[6].eq {
	pc = 0x82189794; continue 'dispatch;
	}
	// 82189788: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8218978C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189790: 483AB97C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189794 => {
    //   block [0x82189794..0x82189800)
	// 82189794: 38A00250  li r5, 0x250
	ctx.r[5].s64 = 592;
	// 82189798: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218979C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821897A0: 483ABA31  bl 0x825351d0
	ctx.lr = 0x821897A4;
	sub_825351D0(ctx, base);
	// 821897A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821897A8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821897AC: 396B0828  addi r11, r11, 0x828
	ctx.r[11].s64 = ctx.r[11].s64 + 2088;
	// 821897B0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821897B4: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821897B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821897BC: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 821897C0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821897C4: 915F0240  stw r10, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[10].u32 ) };
	// 821897C8: 915F0244  stw r10, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[10].u32 ) };
	// 821897CC: 913F0004  stw r9, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821897D0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821897D4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821897D8: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821897DC: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821897E0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821897E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821897E8: 4E800421  bctrl
	ctx.lr = 0x821897EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821897EC: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 821897F0: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 821897F4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821897F8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821897FC: 483AB910  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189800 size=140
    let mut pc: u32 = 0x82189800;
    'dispatch: loop {
        match pc {
            0x82189800 => {
    //   block [0x82189800..0x8218982C)
	// 82189800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189804: 483AB8B9  bl 0x825350bc
	ctx.lr = 0x82189808;
	sub_82535080(ctx, base);
	// 82189808: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218980C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189810: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82189814: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82189818: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218981C: 409A0010  bne cr6, 0x8218982c
	if !ctx.cr[6].eq {
	pc = 0x8218982C; continue 'dispatch;
	}
	// 82189820: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189824: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189828: 483AB8E4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8218982C => {
    //   block [0x8218982C..0x8218988C)
	// 8218982C: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 82189830: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189834: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189838: 483AB999  bl 0x825351d0
	ctx.lr = 0x8218983C;
	sub_825351D0(ctx, base);
	// 8218983C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189840: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82189844: 396B0788  addi r11, r11, 0x788
	ctx.r[11].s64 = ctx.r[11].s64 + 1928;
	// 82189848: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8218984C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189850: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82189854: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189858: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8218985C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189860: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189864: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189868: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8218986C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189870: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189874: 4E800421  bctrl
	ctx.lr = 0x82189878;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189878: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 8218987C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82189880: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189884: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189888: 483AB884  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189890(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189890 size=140
    let mut pc: u32 = 0x82189890;
    'dispatch: loop {
        match pc {
            0x82189890 => {
    //   block [0x82189890..0x821898BC)
	// 82189890: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189894: 483AB829  bl 0x825350bc
	ctx.lr = 0x82189898;
	sub_82535080(ctx, base);
	// 82189898: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218989C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821898A0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821898A4: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 821898A8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821898AC: 409A0010  bne cr6, 0x821898bc
	if !ctx.cr[6].eq {
	pc = 0x821898BC; continue 'dispatch;
	}
	// 821898B0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821898B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821898B8: 483AB854  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821898BC => {
    //   block [0x821898BC..0x8218991C)
	// 821898BC: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 821898C0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821898C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821898C8: 483AB909  bl 0x825351d0
	ctx.lr = 0x821898CC;
	sub_825351D0(ctx, base);
	// 821898CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821898D0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821898D4: 396B07A0  addi r11, r11, 0x7a0
	ctx.r[11].s64 = ctx.r[11].s64 + 1952;
	// 821898D8: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821898DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821898E0: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 821898E4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821898E8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821898EC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821898F0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821898F4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821898F8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821898FC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189900: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189904: 4E800421  bctrl
	ctx.lr = 0x82189908;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189908: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 8218990C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82189910: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189914: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189918: 483AB7F4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189920(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189920 size=140
    let mut pc: u32 = 0x82189920;
    'dispatch: loop {
        match pc {
            0x82189920 => {
    //   block [0x82189920..0x8218994C)
	// 82189920: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189924: 483AB799  bl 0x825350bc
	ctx.lr = 0x82189928;
	sub_82535080(ctx, base);
	// 82189928: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218992C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189930: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82189934: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82189938: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218993C: 409A0010  bne cr6, 0x8218994c
	if !ctx.cr[6].eq {
	pc = 0x8218994C; continue 'dispatch;
	}
	// 82189940: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189948: 483AB7C4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8218994C => {
    //   block [0x8218994C..0x821899AC)
	// 8218994C: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 82189950: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189954: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189958: 483AB879  bl 0x825351d0
	ctx.lr = 0x8218995C;
	sub_825351D0(ctx, base);
	// 8218995C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189960: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82189964: 396B07D0  addi r11, r11, 0x7d0
	ctx.r[11].s64 = ctx.r[11].s64 + 2000;
	// 82189968: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8218996C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189970: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82189974: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189978: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8218997C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189980: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189984: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189988: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8218998C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189990: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189994: 4E800421  bctrl
	ctx.lr = 0x82189998;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189998: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 8218999C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 821899A0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821899A4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821899A8: 483AB764  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821899B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821899B0 size=140
    let mut pc: u32 = 0x821899B0;
    'dispatch: loop {
        match pc {
            0x821899B0 => {
    //   block [0x821899B0..0x821899DC)
	// 821899B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821899B4: 483AB709  bl 0x825350bc
	ctx.lr = 0x821899B8;
	sub_82535080(ctx, base);
	// 821899B8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821899BC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821899C0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821899C4: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 821899C8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821899CC: 409A0010  bne cr6, 0x821899dc
	if !ctx.cr[6].eq {
	pc = 0x821899DC; continue 'dispatch;
	}
	// 821899D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821899D4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821899D8: 483AB734  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821899DC => {
    //   block [0x821899DC..0x82189A3C)
	// 821899DC: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 821899E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821899E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821899E8: 483AB7E9  bl 0x825351d0
	ctx.lr = 0x821899EC;
	sub_825351D0(ctx, base);
	// 821899EC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821899F0: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 821899F4: 396B07B8  addi r11, r11, 0x7b8
	ctx.r[11].s64 = ctx.r[11].s64 + 1976;
	// 821899F8: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821899FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189A00: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82189A04: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189A08: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82189A0C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189A10: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189A14: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189A18: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82189A1C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189A20: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189A24: 4E800421  bctrl
	ctx.lr = 0x82189A28;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189A28: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82189A2C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82189A30: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189A34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189A38: 483AB6D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189A40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189A40 size=140
    let mut pc: u32 = 0x82189A40;
    'dispatch: loop {
        match pc {
            0x82189A40 => {
    //   block [0x82189A40..0x82189A6C)
	// 82189A40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189A44: 483AB679  bl 0x825350bc
	ctx.lr = 0x82189A48;
	sub_82535080(ctx, base);
	// 82189A48: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189A4C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189A50: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82189A54: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82189A58: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189A5C: 409A0010  bne cr6, 0x82189a6c
	if !ctx.cr[6].eq {
	pc = 0x82189A6C; continue 'dispatch;
	}
	// 82189A60: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189A64: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189A68: 483AB6A4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189A6C => {
    //   block [0x82189A6C..0x82189ACC)
	// 82189A6C: 38A001D0  li r5, 0x1d0
	ctx.r[5].s64 = 464;
	// 82189A70: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189A74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189A78: 483AB759  bl 0x825351d0
	ctx.lr = 0x82189A7C;
	sub_825351D0(ctx, base);
	// 82189A7C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189A80: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82189A84: 396B0758  addi r11, r11, 0x758
	ctx.r[11].s64 = ctx.r[11].s64 + 1880;
	// 82189A88: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82189A8C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189A90: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82189A94: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189A98: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82189A9C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189AA0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189AA4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189AA8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82189AAC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189AB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189AB4: 4E800421  bctrl
	ctx.lr = 0x82189AB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189AB8: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82189ABC: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82189AC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189AC4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189AC8: 483AB644  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189AD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189AD0 size=140
    let mut pc: u32 = 0x82189AD0;
    'dispatch: loop {
        match pc {
            0x82189AD0 => {
    //   block [0x82189AD0..0x82189AFC)
	// 82189AD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189AD4: 483AB5E9  bl 0x825350bc
	ctx.lr = 0x82189AD8;
	sub_82535080(ctx, base);
	// 82189AD8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189ADC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189AE0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82189AE4: 3BEB0B90  addi r31, r11, 0xb90
	ctx.r[31].s64 = ctx.r[11].s64 + 2960;
	// 82189AE8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189AEC: 409A0010  bne cr6, 0x82189afc
	if !ctx.cr[6].eq {
	pc = 0x82189AFC; continue 'dispatch;
	}
	// 82189AF0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189AF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189AF8: 483AB614  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189AFC => {
    //   block [0x82189AFC..0x82189B5C)
	// 82189AFC: 38A001B0  li r5, 0x1b0
	ctx.r[5].s64 = 432;
	// 82189B00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189B04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189B08: 483AB6C9  bl 0x825351d0
	ctx.lr = 0x82189B0C;
	sub_825351D0(ctx, base);
	// 82189B0C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189B10: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82189B14: 396B0810  addi r11, r11, 0x810
	ctx.r[11].s64 = ctx.r[11].s64 + 2064;
	// 82189B18: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82189B1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189B20: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82189B24: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189B28: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82189B2C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189B30: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189B34: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82189B38: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82189B3C: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189B40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189B44: 4E800421  bctrl
	ctx.lr = 0x82189B48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189B48: 93BF001C  stw r29, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[29].u32 ) };
	// 82189B4C: 93FE001C  stw r31, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[31].u32 ) };
	// 82189B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189B54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189B58: 483AB5B4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189B60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189B60 size=108
    let mut pc: u32 = 0x82189B60;
    'dispatch: loop {
        match pc {
            0x82189B60 => {
    //   block [0x82189B60..0x82189BB4)
	// 82189B60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189B64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189B68: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189B6C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189B70: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189B74: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189B78: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82189B7C: 419A0038  beq cr6, 0x82189bb4
	if ctx.cr[6].eq {
	pc = 0x82189BB4; continue 'dispatch;
	}
	// 82189B80: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82189B84: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189B88: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82189B8C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189B90: 4E800421  bctrl
	ctx.lr = 0x82189B94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189B94: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 82189B98: 409A001C  bne cr6, 0x82189bb4
	if !ctx.cr[6].eq {
	pc = 0x82189BB4; continue 'dispatch;
	}
	// 82189B9C: 807F0028  lwz r3, 0x28(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189BA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82189BA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189BA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189BAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189BB0: 4E800020  blr
	return;
            }
            0x82189BB4 => {
    //   block [0x82189BB4..0x82189BCC)
	// 82189BB4: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189BB8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82189BBC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189BC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189BC4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189BC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189BD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189BD0 size=116
    let mut pc: u32 = 0x82189BD0;
    'dispatch: loop {
        match pc {
            0x82189BD0 => {
    //   block [0x82189BD0..0x82189C28)
	// 82189BD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189BD4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189BD8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82189BDC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189BE0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189BE4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189BE8: 2B040008  cmplwi cr6, r4, 8
	ctx.cr[6].compare_u32(ctx.r[4].u32, 8 as u32, &mut ctx.xer);
	// 82189BEC: 4199003C  bgt cr6, 0x82189c28
	if ctx.cr[6].gt {
	pc = 0x82189C28; continue 'dispatch;
	}
	// 82189BF0: 39640002  addi r11, r4, 2
	ctx.r[11].s64 = ctx.r[4].s64 + 2;
	// 82189BF4: 557F103A  slwi r31, r11, 2
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 82189BF8: 7D7FF02E  lwzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82189BFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82189C00: 419A0028  beq cr6, 0x82189c28
	if ctx.cr[6].eq {
	pc = 0x82189C28; continue 'dispatch;
	}
	// 82189C04: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82189C08: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189C0C: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82189C10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189C14: 4E800421  bctrl
	ctx.lr = 0x82189C18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189C18: 2F03000C  cmpwi cr6, r3, 0xc
	ctx.cr[6].compare_i32(ctx.r[3].s32, 12, &mut ctx.xer);
	// 82189C1C: 409A000C  bne cr6, 0x82189c28
	if !ctx.cr[6].eq {
	pc = 0x82189C28; continue 'dispatch;
	}
	// 82189C20: 7C7FF02E  lwzx r3, r31, r30
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 82189C24: 48000008  b 0x82189c2c
	pc = 0x82189C2C; continue 'dispatch;
            }
            0x82189C28 => {
    //   block [0x82189C28..0x82189C2C)
	// 82189C28: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82189C2C; continue 'dispatch;
            }
            0x82189C2C => {
    //   block [0x82189C2C..0x82189C44)
	// 82189C2C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189C30: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189C34: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189C38: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82189C3C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189C40: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189C48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189C48 size=108
    let mut pc: u32 = 0x82189C48;
    'dispatch: loop {
        match pc {
            0x82189C48 => {
    //   block [0x82189C48..0x82189C9C)
	// 82189C48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189C4C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189C50: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189C54: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189C58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189C5C: 817F0014  lwz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82189C60: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82189C64: 419A0038  beq cr6, 0x82189c9c
	if ctx.cr[6].eq {
	pc = 0x82189C9C; continue 'dispatch;
	}
	// 82189C68: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 82189C6C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189C70: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82189C74: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189C78: 4E800421  bctrl
	ctx.lr = 0x82189C7C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189C7C: 2F030014  cmpwi cr6, r3, 0x14
	ctx.cr[6].compare_i32(ctx.r[3].s32, 20, &mut ctx.xer);
	// 82189C80: 409A001C  bne cr6, 0x82189c9c
	if !ctx.cr[6].eq {
	pc = 0x82189C9C; continue 'dispatch;
	}
	// 82189C84: 807F0014  lwz r3, 0x14(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 82189C88: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82189C8C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189C90: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189C94: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189C98: 4E800020  blr
	return;
            }
            0x82189C9C => {
    //   block [0x82189C9C..0x82189CB4)
	// 82189C9C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82189CA0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82189CA4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189CA8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189CAC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189CB0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189CB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82189CB8 size=180
    let mut pc: u32 = 0x82189CB8;
    'dispatch: loop {
        match pc {
            0x82189CB8 => {
    //   block [0x82189CB8..0x82189D54)
	// 82189CB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189CBC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189CC0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82189CC4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189CC8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189CCC: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82189CD0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82189CD4: 481F0625  bl 0x8237a2f8
	ctx.lr = 0x82189CD8;
	sub_8237A2F8(ctx, base);
	// 82189CD8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189CDC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189CE0: 419A0074  beq cr6, 0x82189d54
	if ctx.cr[6].eq {
	pc = 0x82189D54; continue 'dispatch;
	}
	// 82189CE4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189CE8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189CEC: 396B04B0  addi r11, r11, 0x4b0
	ctx.r[11].s64 = ctx.r[11].s64 + 1200;
	// 82189CF0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189CF4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189CF8: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82189CFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189D00: 4E800421  bctrl
	ctx.lr = 0x82189D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189D04: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189D08: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189D0C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82189D10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189D14: 4E800421  bctrl
	ctx.lr = 0x82189D18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189D18: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189D1C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189D20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189D24: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82189D28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189D2C: 4E800421  bctrl
	ctx.lr = 0x82189D30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189D30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82189D34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189D38: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82189D3C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82189D40: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82189D44: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82189D48: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82189D4C: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189D50: 93EB0260  stw r31, 0x260(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(608 as u32), ctx.r[31].u32 ) };
            }
            0x82189D54 => {
    //   block [0x82189D54..0x82189D6C)
	// 82189D54: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189D58: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189D5C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189D60: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82189D64: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189D68: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189D70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82189D70 size=176
    let mut pc: u32 = 0x82189D70;
    'dispatch: loop {
        match pc {
            0x82189D70 => {
    //   block [0x82189D70..0x82189D9C)
	// 82189D70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189D74: 483AB349  bl 0x825350bc
	ctx.lr = 0x82189D78;
	sub_82535080(ctx, base);
	// 82189D78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189D7C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82189D80: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82189D84: 481F0575  bl 0x8237a2f8
	ctx.lr = 0x82189D88;
	sub_8237A2F8(ctx, base);
	// 82189D88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189D8C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189D90: 409A000C  bne cr6, 0x82189d9c
	if !ctx.cr[6].eq {
	pc = 0x82189D9C; continue 'dispatch;
	}
	// 82189D94: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189D98: 483AB374  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189D9C => {
    //   block [0x82189D9C..0x82189E14)
	// 82189D9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189DA4: 396B05B8  addi r11, r11, 0x5b8
	ctx.r[11].s64 = ctx.r[11].s64 + 1464;
	// 82189DA8: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189DAC: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189DB0: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82189DB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189DB8: 4E800421  bctrl
	ctx.lr = 0x82189DBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189DBC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189DC4: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82189DC8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189DCC: 4E800421  bctrl
	ctx.lr = 0x82189DD0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189DD0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189DD4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189DD8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189DDC: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82189DE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189DE4: 4E800421  bctrl
	ctx.lr = 0x82189DE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82189DEC: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 82189DF0: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82189DF4: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82189DF8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82189DFC: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82189E00: 41990014  bgt cr6, 0x82189e14
	if ctx.cr[6].gt {
	pc = 0x82189E14; continue 'dispatch;
	}
	// 82189E04: 397E0094  addi r11, r30, 0x94
	ctx.r[11].s64 = ctx.r[30].s64 + 148;
	// 82189E08: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189E0C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189E10: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
            }
            0x82189E14 => {
    //   block [0x82189E14..0x82189E20)
	// 82189E14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189E18: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189E1C: 483AB2F0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189E20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82189E20 size=176
    let mut pc: u32 = 0x82189E20;
    'dispatch: loop {
        match pc {
            0x82189E20 => {
    //   block [0x82189E20..0x82189E4C)
	// 82189E20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189E24: 483AB299  bl 0x825350bc
	ctx.lr = 0x82189E28;
	sub_82535080(ctx, base);
	// 82189E28: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189E2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82189E30: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82189E34: 481F04C5  bl 0x8237a2f8
	ctx.lr = 0x82189E38;
	sub_8237A2F8(ctx, base);
	// 82189E38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189E3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189E40: 409A000C  bne cr6, 0x82189e4c
	if !ctx.cr[6].eq {
	pc = 0x82189E4C; continue 'dispatch;
	}
	// 82189E44: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189E48: 483AB2C4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189E4C => {
    //   block [0x82189E4C..0x82189EC4)
	// 82189E4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189E50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189E54: 396B0638  addi r11, r11, 0x638
	ctx.r[11].s64 = ctx.r[11].s64 + 1592;
	// 82189E58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189E5C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189E60: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82189E64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189E68: 4E800421  bctrl
	ctx.lr = 0x82189E6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189E6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189E70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189E74: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82189E78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189E7C: 4E800421  bctrl
	ctx.lr = 0x82189E80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189E80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189E84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189E88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189E8C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82189E90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189E94: 4E800421  bctrl
	ctx.lr = 0x82189E98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189E98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82189E9C: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 82189EA0: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82189EA4: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82189EA8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82189EAC: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82189EB0: 41990014  bgt cr6, 0x82189ec4
	if ctx.cr[6].gt {
	pc = 0x82189EC4; continue 'dispatch;
	}
	// 82189EB4: 397E0094  addi r11, r30, 0x94
	ctx.r[11].s64 = ctx.r[30].s64 + 148;
	// 82189EB8: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189EBC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189EC0: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
            }
            0x82189EC4 => {
    //   block [0x82189EC4..0x82189ED0)
	// 82189EC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189EC8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189ECC: 483AB240  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189ED0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82189ED0 size=176
    let mut pc: u32 = 0x82189ED0;
    'dispatch: loop {
        match pc {
            0x82189ED0 => {
    //   block [0x82189ED0..0x82189EFC)
	// 82189ED0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189ED4: 483AB1E9  bl 0x825350bc
	ctx.lr = 0x82189ED8;
	sub_82535080(ctx, base);
	// 82189ED8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189EDC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82189EE0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82189EE4: 481F0415  bl 0x8237a2f8
	ctx.lr = 0x82189EE8;
	sub_8237A2F8(ctx, base);
	// 82189EE8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82189EEC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189EF0: 409A000C  bne cr6, 0x82189efc
	if !ctx.cr[6].eq {
	pc = 0x82189EFC; continue 'dispatch;
	}
	// 82189EF4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189EF8: 483AB214  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x82189EFC => {
    //   block [0x82189EFC..0x82189F74)
	// 82189EFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82189F00: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189F04: 396B06B8  addi r11, r11, 0x6b8
	ctx.r[11].s64 = ctx.r[11].s64 + 1720;
	// 82189F08: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82189F0C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189F10: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82189F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189F18: 4E800421  bctrl
	ctx.lr = 0x82189F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189F1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189F20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189F24: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82189F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189F2C: 4E800421  bctrl
	ctx.lr = 0x82189F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189F30: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189F34: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82189F38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189F3C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82189F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189F44: 4E800421  bctrl
	ctx.lr = 0x82189F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189F48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82189F4C: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 82189F50: 93DF0140  stw r30, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[30].u32 ) };
	// 82189F54: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82189F58: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82189F5C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82189F60: 41990014  bgt cr6, 0x82189f74
	if ctx.cr[6].gt {
	pc = 0x82189F74; continue 'dispatch;
	}
	// 82189F64: 397E0094  addi r11, r30, 0x94
	ctx.r[11].s64 = ctx.r[30].s64 + 148;
	// 82189F68: 815D0028  lwz r10, 0x28(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189F6C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189F70: 7FEB512E  stwx r31, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[31].u32) };
            }
            0x82189F74 => {
    //   block [0x82189F74..0x82189F80)
	// 82189F74: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189F78: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82189F7C: 483AB190  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189F80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189F80 size=104
    let mut pc: u32 = 0x82189F80;
    'dispatch: loop {
        match pc {
            0x82189F80 => {
    //   block [0x82189F80..0x82189FD0)
	// 82189F80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189F84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189F88: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189F8C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189F90: 2B040007  cmplwi cr6, r4, 7
	ctx.cr[6].compare_u32(ctx.r[4].u32, 7 as u32, &mut ctx.xer);
	// 82189F94: 4199003C  bgt cr6, 0x82189fd0
	if ctx.cr[6].gt {
	pc = 0x82189FD0; continue 'dispatch;
	}
	// 82189F98: 39640094  addi r11, r4, 0x94
	ctx.r[11].s64 = ctx.r[4].s64 + 148;
	// 82189F9C: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82189FA0: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82189FA4: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82189FA8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82189FAC: 419A0024  beq cr6, 0x82189fd0
	if ctx.cr[6].eq {
	pc = 0x82189FD0; continue 'dispatch;
	}
	// 82189FB0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82189FB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189FB8: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82189FBC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82189FC0: 4E800421  bctrl
	ctx.lr = 0x82189FC4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82189FC4: 2F030004  cmpwi cr6, r3, 4
	ctx.cr[6].compare_i32(ctx.r[3].s32, 4, &mut ctx.xer);
	// 82189FC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82189FCC: 419A0008  beq cr6, 0x82189fd4
	if ctx.cr[6].eq {
	pc = 0x82189FD4; continue 'dispatch;
	}
            }
            0x82189FD0 => {
    //   block [0x82189FD0..0x82189FD4)
	// 82189FD0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x82189FD4; continue 'dispatch;
            }
            0x82189FD4 => {
    //   block [0x82189FD4..0x82189FE8)
	// 82189FD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82189FD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82189FDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82189FE0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82189FE4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82189FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82189FE8 size=104
    let mut pc: u32 = 0x82189FE8;
    'dispatch: loop {
        match pc {
            0x82189FE8 => {
    //   block [0x82189FE8..0x8218A038)
	// 82189FE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82189FEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82189FF0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82189FF4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82189FF8: 2B040007  cmplwi cr6, r4, 7
	ctx.cr[6].compare_u32(ctx.r[4].u32, 7 as u32, &mut ctx.xer);
	// 82189FFC: 4199003C  bgt cr6, 0x8218a038
	if ctx.cr[6].gt {
	pc = 0x8218A038; continue 'dispatch;
	}
	// 8218A000: 39640094  addi r11, r4, 0x94
	ctx.r[11].s64 = ctx.r[4].s64 + 148;
	// 8218A004: 81430028  lwz r10, 0x28(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A008: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218A00C: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218A010: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218A014: 419A0024  beq cr6, 0x8218a038
	if ctx.cr[6].eq {
	pc = 0x8218A038; continue 'dispatch;
	}
	// 8218A018: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A01C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A020: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8218A024: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A028: 4E800421  bctrl
	ctx.lr = 0x8218A02C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A02C: 2F030007  cmpwi cr6, r3, 7
	ctx.cr[6].compare_i32(ctx.r[3].s32, 7, &mut ctx.xer);
	// 8218A030: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A034: 419A0008  beq cr6, 0x8218a03c
	if ctx.cr[6].eq {
	pc = 0x8218A03C; continue 'dispatch;
	}
            }
            0x8218A038 => {
    //   block [0x8218A038..0x8218A03C)
	// 8218A038: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	pc = 0x8218A03C; continue 'dispatch;
            }
            0x8218A03C => {
    //   block [0x8218A03C..0x8218A050)
	// 8218A03C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218A040: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A044: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A048: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218A04C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218A050 size=212
    let mut pc: u32 = 0x8218A050;
    'dispatch: loop {
        match pc {
            0x8218A050 => {
    //   block [0x8218A050..0x8218A0CC)
	// 8218A050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A054: 483AB069  bl 0x825350bc
	ctx.lr = 0x8218A058;
	sub_82535080(ctx, base);
	// 8218A058: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8218A05C: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8218A060: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A064: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A068: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8218A06C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8218A070: 2B060007  cmplwi cr6, r6, 7
	ctx.cr[6].compare_u32(ctx.r[6].u32, 7 as u32, &mut ctx.xer);
	// 8218A074: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218A078: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 8218A07C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218A080: 4199004C  bgt cr6, 0x8218a0cc
	if ctx.cr[6].gt {
	pc = 0x8218A0CC; continue 'dispatch;
	}
	// 8218A084: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A088: 39460094  addi r10, r6, 0x94
	ctx.r[10].s64 = ctx.r[6].s64 + 148;
	// 8218A08C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218A090: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A094: 7FEA582E  lwzx r31, r10, r11
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A098: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218A09C: 419A0030  beq cr6, 0x8218a0cc
	if ctx.cr[6].eq {
	pc = 0x8218A0CC; continue 'dispatch;
	}
	// 8218A0A0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A0A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A0A8: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8218A0AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A0B0: 4E800421  bctrl
	ctx.lr = 0x8218A0B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A0B4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A0B8: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8218A0BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A0C0: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8218A0C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A0C8: 4E800421  bctrl
	ctx.lr = 0x8218A0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218A0CC => {
    //   block [0x8218A0CC..0x8218A114)
	// 8218A0CC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218A0D0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8218A0D4: 616A9BA0  ori r10, r11, 0x9ba0
	ctx.r[10].u64 = ctx.r[11].u64 | 39840;
	// 8218A0D8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218A0DC: 616B9BA8  ori r11, r11, 0x9ba8
	ctx.r[11].u64 = ctx.r[11].u64 | 39848;
	// 8218A0E0: 7C1D542E  lfsx f0, r29, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A0E4: ED5E0028  fsubs f10, f30, f0
	ctx.f[10].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A0E8: 7D7E542E  lfsx f11, r30, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218A0EC: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A0F0: 7DBD5C2E  lfsx f13, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A0F4: 7D9E5C2E  lfsx f12, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218A0F8: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218A0FC: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218A100: ED8C02B2  fmuls f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[10].f64) as f32) as f64);
	// 8218A104: EC006378  fmsubs f0, f0, f13, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218A108: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218A10C: 41990008  bgt cr6, 0x8218a114
	if ctx.cr[6].gt {
	pc = 0x8218A114; continue 'dispatch;
	}
	// 8218A110: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x8218A114; continue 'dispatch;
            }
            0x8218A114 => {
    //   block [0x8218A114..0x8218A124)
	// 8218A114: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218A118: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218A11C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218A120: 483AAFEC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A128(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8218A128 size=216
    let mut pc: u32 = 0x8218A128;
    'dispatch: loop {
        match pc {
            0x8218A128 => {
    //   block [0x8218A128..0x8218A158)
	// 8218A128: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A12C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218A130: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218A134: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218A138: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A13C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218A140: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218A144: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A148: 409A0010  bne cr6, 0x8218a158
	if !ctx.cr[6].eq {
	pc = 0x8218A158; continue 'dispatch;
	}
	// 8218A14C: 386014D0  li r3, 0x14d0
	ctx.r[3].s64 = 5328;
	// 8218A150: 481DCD81  bl 0x82366ed0
	ctx.lr = 0x8218A154;
	sub_82366ED0(ctx, base);
	// 8218A154: 907E0004  stw r3, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	pc = 0x8218A158; continue 'dispatch;
            }
            0x8218A158 => {
    //   block [0x8218A158..0x8218A15C)
	// 8218A158: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x8218A15C; continue 'dispatch;
            }
            0x8218A15C => {
    //   block [0x8218A15C..0x8218A194)
	// 8218A15C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218A160: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218A164: 4800009D  bl 0x8218a200
	ctx.lr = 0x8218A168;
	sub_8218A200(ctx, base);
	// 8218A168: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8218A16C: 2B1F0009  cmplwi cr6, r31, 9
	ctx.cr[6].compare_u32(ctx.r[31].u32, 9 as u32, &mut ctx.xer);
	// 8218A170: 4198FFEC  blt cr6, 0x8218a15c
	if ctx.cr[6].lt {
	pc = 0x8218A15C; continue 'dispatch;
	}
	// 8218A174: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218A178: 3BEB1280  addi r31, r11, 0x1280
	ctx.r[31].s64 = ctx.r[11].s64 + 4736;
	// 8218A17C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218A180: 409A0014  bne cr6, 0x8218a194
	if !ctx.cr[6].eq {
	pc = 0x8218A194; continue 'dispatch;
	}
	// 8218A184: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218A188: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8218A18C: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8218A190: 48000058  b 0x8218a1e8
	pc = 0x8218A1E8; continue 'dispatch;
            }
            0x8218A194 => {
    //   block [0x8218A194..0x8218A1E8)
	// 8218A194: 38A000B4  li r5, 0xb4
	ctx.r[5].s64 = 180;
	// 8218A198: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218A19C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A1A0: 483AB031  bl 0x825351d0
	ctx.lr = 0x8218A1A4;
	sub_825351D0(ctx, base);
	// 8218A1A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218A1A8: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8218A1AC: 396B0748  addi r11, r11, 0x748
	ctx.r[11].s64 = ctx.r[11].s64 + 1864;
	// 8218A1B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A1B4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8218A1B8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 8218A1BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A1C0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A1C4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8218A1C8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8218A1CC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A1D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A1D4: 4E800421  bctrl
	ctx.lr = 0x8218A1D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A1D8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218A1DC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218A1E0: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 8218A1E4: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
            }
            0x8218A1E8 => {
    //   block [0x8218A1E8..0x8218A200)
	// 8218A1E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218A1EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A1F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A1F4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218A1F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218A1FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8218A200 size=164
    let mut pc: u32 = 0x8218A200;
    'dispatch: loop {
        match pc {
            0x8218A200 => {
    //   block [0x8218A200..0x8218A230)
	// 8218A200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A204: 483AAEB9  bl 0x825350bc
	ctx.lr = 0x8218A208;
	sub_82535080(ctx, base);
	// 8218A208: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A20C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8218A210: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218A214: 2B1D0009  cmplwi cr6, r29, 9
	ctx.cr[6].compare_u32(ctx.r[29].u32, 9 as u32, &mut ctx.xer);
	// 8218A218: 40980018  bge cr6, 0x8218a230
	if !ctx.cr[6].lt {
	pc = 0x8218A230; continue 'dispatch;
	}
	// 8218A21C: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218A220: 1D7D0250  mulli r11, r29, 0x250
	ctx.r[11].s32 = ((ctx.r[29].s32 as i64 * 592 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218A224: 7FEB5214  add r31, r11, r10
	ctx.r[31].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218A228: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218A22C: 409A0014  bne cr6, 0x8218a240
	if !ctx.cr[6].eq {
	pc = 0x8218A240; continue 'dispatch;
	}
	pc = 0x8218A230; continue 'dispatch;
            }
            0x8218A230 => {
    //   block [0x8218A230..0x8218A240)
	// 8218A230: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218A234: 916B001C  stw r11, 0x1c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218A238: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218A23C: 483AAED0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8218A240 => {
    //   block [0x8218A240..0x8218A2A4)
	// 8218A240: 38A00020  li r5, 0x20
	ctx.r[5].s64 = 32;
	// 8218A244: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218A248: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A24C: 483AAF85  bl 0x825351d0
	ctx.lr = 0x8218A250;
	sub_825351D0(ctx, base);
	// 8218A250: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218A254: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A258: 396B0738  addi r11, r11, 0x738
	ctx.r[11].s64 = ctx.r[11].s64 + 1848;
	// 8218A25C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8218A260: 93BF0004  stw r29, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[29].u32 ) };
	// 8218A264: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A268: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A26C: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8218A270: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8218A274: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A278: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A27C: 4E800421  bctrl
	ctx.lr = 0x8218A280;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A280: 397D0002  addi r11, r29, 2
	ctx.r[11].s64 = ctx.r[29].s64 + 2;
	// 8218A284: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8218A288: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218A28C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8218A290: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8218A294: 7FEBF12E  stwx r31, r11, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32), ctx.r[31].u32) };
	// 8218A298: 913F001C  stw r9, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8218A29C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218A2A0: 483AAE6C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A2A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8218A2A8 size=240
    let mut pc: u32 = 0x8218A2A8;
    'dispatch: loop {
        match pc {
            0x8218A2A8 => {
    //   block [0x8218A2A8..0x8218A2D0)
	// 8218A2A8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A2AC: 483AAE05  bl 0x825350b0
	ctx.lr = 0x8218A2B0;
	sub_82535080(ctx, base);
	// 8218A2B0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A2B4: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8218A2B8: 837A0000  lwz r27, 0(r26)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A2BC: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8218A2C0: 419A00D0  beq cr6, 0x8218a390
	if ctx.cr[6].eq {
	pc = 0x8218A390; continue 'dispatch;
	}
	// 8218A2C4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8218A2C8: 3BC00250  li r30, 0x250
	ctx.r[30].s64 = 592;
	// 8218A2CC: 3B9AFDB8  addi r28, r26, -0x248
	ctx.r[28].s64 = ctx.r[26].s64 + -584;
	pc = 0x8218A2D0; continue 'dispatch;
            }
            0x8218A2D0 => {
    //   block [0x8218A2D0..0x8218A31C)
	// 8218A2D0: 2B1D0007  cmplwi cr6, r29, 7
	ctx.cr[6].compare_u32(ctx.r[29].u32, 7 as u32, &mut ctx.xer);
	// 8218A2D4: 41990068  bgt cr6, 0x8218a33c
	if ctx.cr[6].gt {
	pc = 0x8218A33C; continue 'dispatch;
	}
	// 8218A2D8: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A2DC: 7D6BF02E  lwzx r11, r11, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218A2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A2E4: 419A0058  beq cr6, 0x8218a33c
	if ctx.cr[6].eq {
	pc = 0x8218A33C; continue 'dispatch;
	}
	// 8218A2E8: 7FFCF02E  lwzx r31, r28, r30
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218A2EC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A2F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A2F4: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218A2F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A2FC: 4E800421  bctrl
	ctx.lr = 0x8218A300;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A300: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8218A304: 419A0038  beq cr6, 0x8218a33c
	if ctx.cr[6].eq {
	pc = 0x8218A33C; continue 'dispatch;
	}
	// 8218A308: 817F0018  lwz r11, 0x18(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8218A30C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A310: 419A000C  beq cr6, 0x8218a31c
	if ctx.cr[6].eq {
	pc = 0x8218A31C; continue 'dispatch;
	}
	// 8218A314: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8218A318: 917F0018  stw r11, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
            }
            0x8218A31C => {
    //   block [0x8218A31C..0x8218A33C)
	// 8218A31C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218A320: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A324: 419A0018  beq cr6, 0x8218a33c
	if ctx.cr[6].eq {
	pc = 0x8218A33C; continue 'dispatch;
	}
	// 8218A328: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A32C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218A330: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218A334: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A338: 4E800421  bctrl
	ctx.lr = 0x8218A33C;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218A33C => {
    //   block [0x8218A33C..0x8218A374)
	// 8218A33C: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8218A340: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8218A344: 2F1E0270  cmpwi cr6, r30, 0x270
	ctx.cr[6].compare_i32(ctx.r[30].s32, 624, &mut ctx.xer);
	// 8218A348: 4198FF88  blt cr6, 0x8218a2d0
	if ctx.cr[6].lt {
	pc = 0x8218A2D0; continue 'dispatch;
	}
	// 8218A34C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218A350: 4800B671  bl 0x821959c0
	ctx.lr = 0x8218A354;
	sub_821959C0(ctx, base);
	// 8218A354: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218A358: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8218A35C: 4BFFF805  bl 0x82189b60
	ctx.lr = 0x8218A360;
	sub_82189B60(ctx, base);
	// 8218A360: 81630018  lwz r11, 0x18(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) } as u64;
	// 8218A364: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A368: 419A000C  beq cr6, 0x8218a374
	if ctx.cr[6].eq {
	pc = 0x8218A374; continue 'dispatch;
	}
	// 8218A36C: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8218A370: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	pc = 0x8218A374; continue 'dispatch;
            }
            0x8218A374 => {
    //   block [0x8218A374..0x8218A390)
	// 8218A374: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218A378: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A37C: 419A0014  beq cr6, 0x8218a390
	if ctx.cr[6].eq {
	pc = 0x8218A390; continue 'dispatch;
	}
	// 8218A380: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A384: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218A388: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A38C: 4E800421  bctrl
	ctx.lr = 0x8218A390;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218A390 => {
    //   block [0x8218A390..0x8218A398)
	// 8218A390: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218A394: 483AAD6C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218A398 size=340
    let mut pc: u32 = 0x8218A398;
    'dispatch: loop {
        match pc {
            0x8218A398 => {
    //   block [0x8218A398..0x8218A440)
	// 8218A398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A39C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218A3A0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A3A4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218A3A8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218A3AC: 390BBFF0  addi r8, r11, -0x4010
	ctx.r[8].s64 = ctx.r[11].s64 + -16400;
	// 8218A3B0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A3B4: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218A3B8: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218A3BC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8218A3C0: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218A3C4: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A3C8: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218A3CC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A3D0: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218A3D4: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A3D8: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218A3DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A3E0: 409A00FC  bne cr6, 0x8218a4dc
	if !ctx.cr[6].eq {
	pc = 0x8218A4DC; continue 'dispatch;
	}
	// 8218A3E4: C009008C  lfs f0, 0x8c(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A3E8: 80690094  lwz r3, 0x94(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(148 as u32) ) } as u64;
	// 8218A3EC: C1A90090  lfs f13, 0x90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A3F0: 80890088  lwz r4, 0x88(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 8218A3F4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A3F8: C1890084  lfs f12, 0x84(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218A3FC: C1690080  lfs f11, 0x80(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218A400: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 8218A404: EC2D02FA  fmadds f1, f13, f11, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218A408: 481EFF59  bl 0x8237a360
	ctx.lr = 0x8218A40C;
	sub_8237A360(ctx, base);
	// 8218A40C: 8163002C  lwz r11, 0x2c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(44 as u32) ) } as u64;
	// 8218A410: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8218A414: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8218A418: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A41C: 3CE0830F  lis r7, -0x7cf1
	ctx.r[7].s64 = -2096168960;
	// 8218A420: 419A0040  beq cr6, 0x8218a460
	if ctx.cr[6].eq {
	pc = 0x8218A460; continue 'dispatch;
	}
	// 8218A424: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8218A428: 419A0018  beq cr6, 0x8218a440
	if ctx.cr[6].eq {
	pc = 0x8218A440; continue 'dispatch;
	}
	// 8218A42C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8218A430: 409A001C  bne cr6, 0x8218a44c
	if !ctx.cr[6].eq {
	pc = 0x8218A44C; continue 'dispatch;
	}
	// 8218A434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A438: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218A43C: 48000008  b 0x8218a444
	pc = 0x8218A444; continue 'dispatch;
            }
            0x8218A440 => {
    //   block [0x8218A440..0x8218A444)
	// 8218A440: C0290090  lfs f1, 0x90(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(144 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x8218A444; continue 'dispatch;
            }
            0x8218A444 => {
    //   block [0x8218A444..0x8218A44C)
	// 8218A444: 80890088  lwz r4, 0x88(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(136 as u32) ) } as u64;
	// 8218A448: 481EFF19  bl 0x8237a360
	ctx.lr = 0x8218A44C;
	sub_8237A360(ctx, base);
	pc = 0x8218A44C; continue 'dispatch;
            }
            0x8218A44C => {
    //   block [0x8218A44C..0x8218A460)
	// 8218A44C: 8167FAC0  lwz r11, -0x540(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8218A450: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8218A454: 409A000C  bne cr6, 0x8218a460
	if !ctx.cr[6].eq {
	pc = 0x8218A460; continue 'dispatch;
	}
	// 8218A458: 98A90019  stb r5, 0x19(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(25 as u32), ctx.r[5].u8 ) };
	// 8218A45C: 98C90025  stb r6, 0x25(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	pc = 0x8218A460; continue 'dispatch;
            }
            0x8218A460 => {
    //   block [0x8218A460..0x8218A4C8)
	// 8218A460: C1A90080  lfs f13, 0x80(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A464: C0090084  lfs f0, 0x84(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A468: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218A46C: 4099005C  ble cr6, 0x8218a4c8
	if !ctx.cr[6].gt {
	pc = 0x8218A4C8; continue 'dispatch;
	}
	// 8218A470: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A474: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218A478: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218A47C: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218A480: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A484: 7D48502E  lwzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218A488: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218A48C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A490: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218A494: 7D68582E  lwzx r11, r8, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A498: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218A49C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A4A0: 409A003C  bne cr6, 0x8218a4dc
	if !ctx.cr[6].eq {
	pc = 0x8218A4DC; continue 'dispatch;
	}
	// 8218A4A4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A4A8: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 8218A4AC: 7C085C2E  lfsx f0, r8, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A4B0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218A4B4: D0090080  stfs f0, 0x80(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8218A4B8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218A4BC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A4C0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A4C4: 4E800020  blr
	return;
            }
            0x8218A4C8 => {
    //   block [0x8218A4C8..0x8218A4DC)
	// 8218A4C8: 8167FAC0  lwz r11, -0x540(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8218A4CC: 7F0B4840  cmplw cr6, r11, r9
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8218A4D0: 409A000C  bne cr6, 0x8218a4dc
	if !ctx.cr[6].eq {
	pc = 0x8218A4DC; continue 'dispatch;
	}
	// 8218A4D4: 98A90019  stb r5, 0x19(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(25 as u32), ctx.r[5].u8 ) };
	// 8218A4D8: 98C90025  stb r6, 0x25(r9)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[9].u32.wrapping_add(37 as u32), ctx.r[6].u8 ) };
	pc = 0x8218A4DC; continue 'dispatch;
            }
            0x8218A4DC => {
    //   block [0x8218A4DC..0x8218A4EC)
	// 8218A4DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218A4E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A4E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A4E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A4F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218A4F0 size=296
    let mut pc: u32 = 0x8218A4F0;
    'dispatch: loop {
        match pc {
            0x8218A4F0 => {
    //   block [0x8218A4F0..0x8218A544)
	// 8218A4F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A4F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218A4F8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218A4FC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218A500: DBC1FFD8  stfd f30, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[30].u64 ) };
	// 8218A504: DBE1FFE0  stfd f31, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218A508: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A50C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A510: FFC00890  fmr f30, f1
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8218A514: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8218A518: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218A51C: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 8218A520: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218A524: 41990020  bgt cr6, 0x8218a544
	if ctx.cr[6].gt {
	pc = 0x8218A544; continue 'dispatch;
	}
	// 8218A528: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A52C: 395E0094  addi r10, r30, 0x94
	ctx.r[10].s64 = ctx.r[30].s64 + 148;
	// 8218A530: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218A534: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A538: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A53C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A540: 409A000C  bne cr6, 0x8218a54c
	if !ctx.cr[6].eq {
	pc = 0x8218A54C; continue 'dispatch;
	}
	pc = 0x8218A544; continue 'dispatch;
            }
            0x8218A544 => {
    //   block [0x8218A544..0x8218A54C)
	// 8218A544: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218A548: 48000008  b 0x8218a550
	pc = 0x8218A550; continue 'dispatch;
            }
            0x8218A54C => {
    //   block [0x8218A54C..0x8218A550)
	// 8218A54C: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A550; continue 'dispatch;
            }
            0x8218A550 => {
    //   block [0x8218A550..0x8218A5D0)
	// 8218A550: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8218A554: 419A00A4  beq cr6, 0x8218a5f8
	if ctx.cr[6].eq {
	pc = 0x8218A5F8; continue 'dispatch;
	}
	// 8218A558: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218A55C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8218A560: 38EB04A4  addi r7, r11, 0x4a4
	ctx.r[7].s64 = ctx.r[11].s64 + 1188;
	// 8218A564: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8218A568: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218A56C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8218A570: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8218A574: 915F0084  stw r10, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8218A578: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8218A57C: 481DFF15  bl 0x8236a490
	ctx.lr = 0x8218A580;
	sub_8236A490(ctx, base);
	// 8218A580: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218A584: 419A0074  beq cr6, 0x8218a5f8
	if ctx.cr[6].eq {
	pc = 0x8218A5F8; continue 'dispatch;
	}
	// 8218A588: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A58C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8218A590: 81430030  lwz r10, 0x30(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218A594: 39290860  addi r9, r9, 0x860
	ctx.r[9].s64 = ctx.r[9].s64 + 2144;
	// 8218A598: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 8218A59C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 8218A5A0: 91230000  stw r9, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8218A5A4: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8218A5A8: 409A0050  bne cr6, 0x8218a5f8
	if !ctx.cr[6].eq {
	pc = 0x8218A5F8; continue 'dispatch;
	}
	// 8218A5AC: 2B1E0007  cmplwi cr6, r30, 7
	ctx.cr[6].compare_u32(ctx.r[30].u32, 7 as u32, &mut ctx.xer);
	// 8218A5B0: 41990020  bgt cr6, 0x8218a5d0
	if ctx.cr[6].gt {
	pc = 0x8218A5D0; continue 'dispatch;
	}
	// 8218A5B4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A5B8: 395E0094  addi r10, r30, 0x94
	ctx.r[10].s64 = ctx.r[30].s64 + 148;
	// 8218A5BC: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218A5C0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A5C4: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A5C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A5CC: 409A000C  bne cr6, 0x8218a5d8
	if !ctx.cr[6].eq {
	pc = 0x8218A5D8; continue 'dispatch;
	}
	pc = 0x8218A5D0; continue 'dispatch;
            }
            0x8218A5D0 => {
    //   block [0x8218A5D0..0x8218A5D8)
	// 8218A5D0: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218A5D4: 48000008  b 0x8218a5dc
	pc = 0x8218A5DC; continue 'dispatch;
            }
            0x8218A5D8 => {
    //   block [0x8218A5D8..0x8218A5DC)
	// 8218A5D8: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A5DC; continue 'dispatch;
            }
            0x8218A5DC => {
    //   block [0x8218A5DC..0x8218A5F8)
	// 8218A5DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218A5E0: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8218A5E4: D3C30090  stfs f30, 0x90(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8218A5E8: 93C30088  stw r30, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[30].u32 ) };
	// 8218A5EC: D3E30080  stfs f31, 0x80(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8218A5F0: C00BBA44  lfs f0, -0x45bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17852 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A5F4: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	pc = 0x8218A5F8; continue 'dispatch;
            }
            0x8218A5F8 => {
    //   block [0x8218A5F8..0x8218A618)
	// 8218A5F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218A5FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A600: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A604: CBC1FFD8  lfd f30, -0x28(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218A608: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218A60C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218A610: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218A614: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A618(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218A618 size=112
    let mut pc: u32 = 0x8218A618;
    'dispatch: loop {
        match pc {
            0x8218A618 => {
    //   block [0x8218A618..0x8218A660)
	// 8218A618: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218A61C: 90830078  stw r4, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[4].u32 ) };
	// 8218A620: 2B040007  cmplwi cr6, r4, 7
	ctx.cr[6].compare_u32(ctx.r[4].u32, 7 as u32, &mut ctx.xer);
	// 8218A624: 90A30068  stw r5, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[5].u32 ) };
	// 8218A628: C1ABBA38  lfs f13, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A62C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A630: EC0D0828  fsubs f0, f13, f1
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[1].f64) as f32) as f64);
	// 8218A634: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218A638: FC000B6E  fsel f0, f0, f13, f1
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[1].f64 };
	// 8218A63C: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8218A640: 41990020  bgt cr6, 0x8218a660
	if ctx.cr[6].gt {
	pc = 0x8218A660; continue 'dispatch;
	}
	// 8218A644: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A648: 39440094  addi r10, r4, 0x94
	ctx.r[10].s64 = ctx.r[4].s64 + 148;
	// 8218A64C: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218A650: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A654: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A658: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A65C: 409A000C  bne cr6, 0x8218a668
	if !ctx.cr[6].eq {
	pc = 0x8218A668; continue 'dispatch;
	}
	pc = 0x8218A660; continue 'dispatch;
            }
            0x8218A660 => {
    //   block [0x8218A660..0x8218A668)
	// 8218A660: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 8218A664: 48000008  b 0x8218a66c
	pc = 0x8218A66C; continue 'dispatch;
            }
            0x8218A668 => {
    //   block [0x8218A668..0x8218A66C)
	// 8218A668: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A66C; continue 'dispatch;
            }
            0x8218A66C => {
    //   block [0x8218A66C..0x8218A688)
	// 8218A66C: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8218A670: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A674: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8218A678: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218A67C: D1830014  stfs f12, 0x14(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218A680: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8218A684: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A688(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218A688 size=236
    let mut pc: u32 = 0x8218A688;
    'dispatch: loop {
        match pc {
            0x8218A688 => {
    //   block [0x8218A688..0x8218A704)
	// 8218A688: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A68C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218A690: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218A694: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218A698: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A69C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218A6A0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218A6A4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218A6A8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218A6AC: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218A6B0: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218A6B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218A6B8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218A6BC: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218A6C0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8218A6C4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218A6C8: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8218A6CC: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218A6D0: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218A6D4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A6D8: 409A0084  bne cr6, 0x8218a75c
	if !ctx.cr[6].eq {
	pc = 0x8218A75C; continue 'dispatch;
	}
	// 8218A6DC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218A6E0: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A6E4: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218A6E8: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 8218A6EC: 40990060  ble cr6, 0x8218a74c
	if !ctx.cr[6].gt {
	pc = 0x8218A74C; continue 'dispatch;
	}
	// 8218A6F0: C19F0014  lfs f12, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218A6F4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8218A6F8: 4198000C  blt cr6, 0x8218a704
	if ctx.cr[6].lt {
	pc = 0x8218A704; continue 'dispatch;
	}
	// 8218A6FC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218A700: 48000034  b 0x8218a734
	pc = 0x8218A734; continue 'dispatch;
            }
            0x8218A704 => {
    //   block [0x8218A704..0x8218A734)
	// 8218A704: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A708: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A70C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A710: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218A714: EDAC0024  fdivs f13, f12, f0
	ctx.f[13].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 8218A718: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A71C: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218A720: 4BFC8B99  bl 0x821532b8
	ctx.lr = 0x8218A724;
	sub_821532B8(ctx, base);
	// 8218A724: EDA1F82A  fadds f13, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218A728: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A72C: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A730: EC0DF83C  fnmsubs f0, f13, f0, f31
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x8218A734; continue 'dispatch;
            }
            0x8218A734 => {
    //   block [0x8218A734..0x8218A74C)
	// 8218A734: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218A738: C19F0074  lfs f12, 0x74(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(116 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218A73C: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218A740: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8218A744: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A748: 48000010  b 0x8218a758
	pc = 0x8218A758; continue 'dispatch;
            }
            0x8218A74C => {
    //   block [0x8218A74C..0x8218A758)
	// 8218A74C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A750: D3FF006C  stfs f31, 0x6c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8218A754: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A758; continue 'dispatch;
            }
            0x8218A758 => {
    //   block [0x8218A758..0x8218A75C)
	// 8218A758: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x8218A75C; continue 'dispatch;
            }
            0x8218A75C => {
    //   block [0x8218A75C..0x8218A774)
	// 8218A75C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218A760: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218A764: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218A768: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218A76C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218A770: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218A778(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218A778 size=1728
    let mut pc: u32 = 0x8218A778;
    'dispatch: loop {
        match pc {
            0x8218A778 => {
    //   block [0x8218A778..0x8218A7E8)
	// 8218A778: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218A77C: 483AA941  bl 0x825350bc
	ctx.lr = 0x8218A780;
	sub_82535080(ctx, base);
	// 8218A780: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8218A784: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8218A788: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218A78C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218A790: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8218A794: 3BABBFF0  addi r29, r11, -0x4010
	ctx.r[29].s64 = ctx.r[11].s64 + -16400;
	// 8218A798: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218A7A0: 616B8654  ori r11, r11, 0x8654
	ctx.r[11].u64 = ctx.r[11].u64 | 34388;
	// 8218A7A4: C3CABA38  lfs f30, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218A7A8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A7AC: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8218A7B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A7B4: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218A7B8: 409A0194  bne cr6, 0x8218a94c
	if !ctx.cr[6].eq {
	pc = 0x8218A94C; continue 'dispatch;
	}
	// 8218A7BC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A7C0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A7C4: 806B0250  lwz r3, 0x250(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218A7C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218A7CC: 419A001C  beq cr6, 0x8218a7e8
	if ctx.cr[6].eq {
	pc = 0x8218A7E8; continue 'dispatch;
	}
	// 8218A7D0: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A7D4: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8218A7D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A7DC: 4E800421  bctrl
	ctx.lr = 0x8218A7E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A7E0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218A7E4: 4800000C  b 0x8218a7f0
	pc = 0x8218A7F0; continue 'dispatch;
            }
            0x8218A7E8 => {
    //   block [0x8218A7E8..0x8218A7F0)
	// 8218A7E8: 3FC00000  lis r30, 0
	ctx.r[30].s64 = 0;
	// 8218A7EC: 63DE8765  ori r30, r30, 0x8765
	ctx.r[30].u64 = ctx.r[30].u64 | 34661;
	pc = 0x8218A7F0; continue 'dispatch;
            }
            0x8218A7F0 => {
    //   block [0x8218A7F0..0x8218A818)
	// 8218A7F0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A7F4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A7F8: 806B0254  lwz r3, 0x254(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218A7FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218A800: 419A0018  beq cr6, 0x8218a818
	if ctx.cr[6].eq {
	pc = 0x8218A818; continue 'dispatch;
	}
	// 8218A804: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218A808: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 8218A80C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218A810: 4E800421  bctrl
	ctx.lr = 0x8218A814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218A814: 4800000C  b 0x8218a820
	pc = 0x8218A820; continue 'dispatch;
            }
            0x8218A818 => {
    //   block [0x8218A818..0x8218A820)
	// 8218A818: 3C600000  lis r3, 0
	ctx.r[3].s64 = 0;
	// 8218A81C: 60638765  ori r3, r3, 0x8765
	ctx.r[3].u64 = ctx.r[3].u64 | 34661;
	pc = 0x8218A820; continue 'dispatch;
            }
            0x8218A820 => {
    //   block [0x8218A820..0x8218A84C)
	// 8218A820: 2F1E0000  cmpwi cr6, r30, 0
	ctx.cr[6].compare_i32(ctx.r[30].s32, 0, &mut ctx.xer);
	// 8218A824: 409A0128  bne cr6, 0x8218a94c
	if !ctx.cr[6].eq {
	pc = 0x8218A94C; continue 'dispatch;
	}
	// 8218A828: 2F030006  cmpwi cr6, r3, 6
	ctx.cr[6].compare_i32(ctx.r[3].s32, 6, &mut ctx.xer);
	// 8218A82C: 409A0120  bne cr6, 0x8218a94c
	if !ctx.cr[6].eq {
	pc = 0x8218A94C; continue 'dispatch;
	}
	// 8218A830: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A834: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A838: 812B0250  lwz r9, 0x250(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218A83C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218A840: 409A000C  bne cr6, 0x8218a84c
	if !ctx.cr[6].eq {
	pc = 0x8218A84C; continue 'dispatch;
	}
	// 8218A844: FCE0F890  fmr f7, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[7].f64 = ctx.f[31].f64;
	// 8218A848: 48000008  b 0x8218a850
	pc = 0x8218A850; continue 'dispatch;
            }
            0x8218A84C => {
    //   block [0x8218A84C..0x8218A850)
	// 8218A84C: C0E9009C  lfs f7, 0x9c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(156 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	pc = 0x8218A850; continue 'dispatch;
            }
            0x8218A850 => {
    //   block [0x8218A850..0x8218A864)
	// 8218A850: 814B0254  lwz r10, 0x254(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218A854: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A858: 409A000C  bne cr6, 0x8218a864
	if !ctx.cr[6].eq {
	pc = 0x8218A864; continue 'dispatch;
	}
	// 8218A85C: FD00F890  fmr f8, f31
	ctx.f[8].f64 = ctx.f[31].f64;
	// 8218A860: 48000008  b 0x8218a868
	pc = 0x8218A868; continue 'dispatch;
            }
            0x8218A864 => {
    //   block [0x8218A864..0x8218A868)
	// 8218A864: C10A009C  lfs f8, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	pc = 0x8218A868; continue 'dispatch;
            }
            0x8218A868 => {
    //   block [0x8218A868..0x8218A87C)
	// 8218A868: 814B0258  lwz r10, 0x258(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(600 as u32) ) } as u64;
	// 8218A86C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A870: 409A000C  bne cr6, 0x8218a87c
	if !ctx.cr[6].eq {
	pc = 0x8218A87C; continue 'dispatch;
	}
	// 8218A874: FD20F890  fmr f9, f31
	ctx.f[9].f64 = ctx.f[31].f64;
	// 8218A878: 48000008  b 0x8218a880
	pc = 0x8218A880; continue 'dispatch;
            }
            0x8218A87C => {
    //   block [0x8218A87C..0x8218A880)
	// 8218A87C: C12A009C  lfs f9, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x8218A880; continue 'dispatch;
            }
            0x8218A880 => {
    //   block [0x8218A880..0x8218A894)
	// 8218A880: 814B025C  lwz r10, 0x25c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 8218A884: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A888: 409A000C  bne cr6, 0x8218a894
	if !ctx.cr[6].eq {
	pc = 0x8218A894; continue 'dispatch;
	}
	// 8218A88C: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	// 8218A890: 48000008  b 0x8218a898
	pc = 0x8218A898; continue 'dispatch;
            }
            0x8218A894 => {
    //   block [0x8218A894..0x8218A898)
	// 8218A894: C14A009C  lfs f10, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	pc = 0x8218A898; continue 'dispatch;
            }
            0x8218A898 => {
    //   block [0x8218A898..0x8218A8AC)
	// 8218A898: 814B0260  lwz r10, 0x260(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 8218A89C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A8A0: 409A000C  bne cr6, 0x8218a8ac
	if !ctx.cr[6].eq {
	pc = 0x8218A8AC; continue 'dispatch;
	}
	// 8218A8A4: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 8218A8A8: 48000008  b 0x8218a8b0
	pc = 0x8218A8B0; continue 'dispatch;
            }
            0x8218A8AC => {
    //   block [0x8218A8AC..0x8218A8B0)
	// 8218A8AC: C16A009C  lfs f11, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	pc = 0x8218A8B0; continue 'dispatch;
            }
            0x8218A8B0 => {
    //   block [0x8218A8B0..0x8218A8C4)
	// 8218A8B0: 814B0264  lwz r10, 0x264(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8218A8B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A8B8: 409A000C  bne cr6, 0x8218a8c4
	if !ctx.cr[6].eq {
	pc = 0x8218A8C4; continue 'dispatch;
	}
	// 8218A8BC: FD80F890  fmr f12, f31
	ctx.f[12].f64 = ctx.f[31].f64;
	// 8218A8C0: 48000008  b 0x8218a8c8
	pc = 0x8218A8C8; continue 'dispatch;
            }
            0x8218A8C4 => {
    //   block [0x8218A8C4..0x8218A8C8)
	// 8218A8C4: C18A009C  lfs f12, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x8218A8C8; continue 'dispatch;
            }
            0x8218A8C8 => {
    //   block [0x8218A8C8..0x8218A8DC)
	// 8218A8C8: 814B0268  lwz r10, 0x268(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(616 as u32) ) } as u64;
	// 8218A8CC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218A8D0: 409A000C  bne cr6, 0x8218a8dc
	if !ctx.cr[6].eq {
	pc = 0x8218A8DC; continue 'dispatch;
	}
	// 8218A8D4: FDA0F890  fmr f13, f31
	ctx.f[13].f64 = ctx.f[31].f64;
	// 8218A8D8: 48000008  b 0x8218a8e0
	pc = 0x8218A8E0; continue 'dispatch;
            }
            0x8218A8DC => {
    //   block [0x8218A8DC..0x8218A8E0)
	// 8218A8DC: C1AA009C  lfs f13, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8218A8E0; continue 'dispatch;
            }
            0x8218A8E0 => {
    //   block [0x8218A8E0..0x8218A8F4)
	// 8218A8E0: 816B026C  lwz r11, 0x26c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 8218A8E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A8E8: 409A000C  bne cr6, 0x8218a8f4
	if !ctx.cr[6].eq {
	pc = 0x8218A8F4; continue 'dispatch;
	}
	// 8218A8EC: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218A8F0: 48000008  b 0x8218a8f8
	pc = 0x8218A8F8; continue 'dispatch;
            }
            0x8218A8F4 => {
    //   block [0x8218A8F4..0x8218A8F8)
	// 8218A8F4: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A8F8; continue 'dispatch;
            }
            0x8218A8F8 => {
    //   block [0x8218A8F8..0x8218A94C)
	// 8218A8F8: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218A8FC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8218A900: EC00582A  fadds f0, f0, f11
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64;
	// 8218A904: EC00502A  fadds f0, f0, f10
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64;
	// 8218A908: EC00482A  fadds f0, f0, f9
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64;
	// 8218A90C: EC00402A  fadds f0, f0, f8
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64;
	// 8218A910: EDA0382A  fadds f13, f0, f7
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64;
	// 8218A914: FF0DF000  fcmpu cr6, f13, f30
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[30].f64);
	// 8218A918: 40990034  ble cr6, 0x8218a94c
	if !ctx.cr[6].gt {
	pc = 0x8218A94C; continue 'dispatch;
	}
	// 8218A91C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218A920: 419A002C  beq cr6, 0x8218a94c
	if ctx.cr[6].eq {
	pc = 0x8218A94C; continue 'dispatch;
	}
	// 8218A924: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218A928: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A92C: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8218A930: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218A934: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218A938: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 8218A93C: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 8218A940: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8218A944: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218A948: D009009C  stfs f0, 0x9c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218A94C; continue 'dispatch;
            }
            0x8218A94C => {
    //   block [0x8218A94C..0x8218A9BC)
	// 8218A94C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A950: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218A954: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218A958: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218A95C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A960: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218A964: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218A968: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218A96C: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218A970: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218A974: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218A978: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218A97C: 409A04AC  bne cr6, 0x8218ae28
	if !ctx.cr[6].eq {
	pc = 0x8218AE28; continue 'dispatch;
	}
	// 8218A980: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8218A984: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8218A988: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8218A98C: 41990438  bgt cr6, 0x8218adc4
	if ctx.cr[6].gt {
	pc = 0x8218ADC4; continue 'dispatch;
	}
	// 8218A990: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218A994: 398CA9A8  addi r12, r12, -0x5658
	ctx.r[12].s64 = ctx.r[12].s64 + -22104;
	// 8218A998: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218A99C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218A9A0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218A9A4: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8218A9BC; continue 'dispatch;
		},
		1 => {
	pc = 0x8218A9BC; continue 'dispatch;
		},
		2 => {
	pc = 0x8218A9C4; continue 'dispatch;
		},
		3 => {
	pc = 0x8218A9C4; continue 'dispatch;
		},
		4 => {
	pc = 0x8218AD18; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218A9A8: 8218A9BC  lwz r16, -0x5644(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-22084 as u32) ) } as u64;
	// 8218A9AC: 8218A9BC  lwz r16, -0x5644(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-22084 as u32) ) } as u64;
	// 8218A9B0: 8218A9C4  lwz r16, -0x563c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-22076 as u32) ) } as u64;
	// 8218A9B4: 8218A9C4  lwz r16, -0x563c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-22076 as u32) ) } as u64;
	// 8218A9B8: 8218AD18  lwz r16, -0x52e8(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-21224 as u32) ) } as u64;
            }
            0x8218A9BC => {
    //   block [0x8218A9BC..0x8218A9C4)
	// 8218A9BC: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218A9C0: 48000404  b 0x8218adc4
	pc = 0x8218ADC4; continue 'dispatch;
            }
            0x8218A9C4 => {
    //   block [0x8218A9C4..0x8218A9F0)
	// 8218A9C4: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218A9C8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218A9CC: 409A0188  bne cr6, 0x8218ab54
	if !ctx.cr[6].eq {
	pc = 0x8218AB54; continue 'dispatch;
	}
	// 8218A9D0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A9D4: D3FF0020  stfs f31, 0x20(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218A9D8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218A9DC: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218A9E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218A9E4: 409A000C  bne cr6, 0x8218a9f0
	if !ctx.cr[6].eq {
	pc = 0x8218A9F0; continue 'dispatch;
	}
	// 8218A9E8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218A9EC: 48000008  b 0x8218a9f4
	pc = 0x8218A9F4; continue 'dispatch;
            }
            0x8218A9F0 => {
    //   block [0x8218A9F0..0x8218A9F4)
	// 8218A9F0: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218A9F4; continue 'dispatch;
            }
            0x8218A9F4 => {
    //   block [0x8218A9F4..0x8218AA20)
	// 8218A9F4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218A9F8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218A9FC: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AA00: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AA04: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AA08: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AA0C: 816B0254  lwz r11, 0x254(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218AA10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AA14: 409A000C  bne cr6, 0x8218aa20
	if !ctx.cr[6].eq {
	pc = 0x8218AA20; continue 'dispatch;
	}
	// 8218AA18: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AA1C: 48000008  b 0x8218aa24
	pc = 0x8218AA24; continue 'dispatch;
            }
            0x8218AA20 => {
    //   block [0x8218AA20..0x8218AA24)
	// 8218AA20: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AA24; continue 'dispatch;
            }
            0x8218AA24 => {
    //   block [0x8218AA24..0x8218AA50)
	// 8218AA24: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218AA28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AA2C: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AA30: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AA34: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AA38: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AA3C: 816B0258  lwz r11, 0x258(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(600 as u32) ) } as u64;
	// 8218AA40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AA44: 409A000C  bne cr6, 0x8218aa50
	if !ctx.cr[6].eq {
	pc = 0x8218AA50; continue 'dispatch;
	}
	// 8218AA48: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AA4C: 48000008  b 0x8218aa54
	pc = 0x8218AA54; continue 'dispatch;
            }
            0x8218AA50 => {
    //   block [0x8218AA50..0x8218AA54)
	// 8218AA50: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AA54; continue 'dispatch;
            }
            0x8218AA54 => {
    //   block [0x8218AA54..0x8218AA80)
	// 8218AA54: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218AA58: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AA5C: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AA60: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AA64: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AA68: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AA6C: 816B025C  lwz r11, 0x25c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 8218AA70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AA74: 409A000C  bne cr6, 0x8218aa80
	if !ctx.cr[6].eq {
	pc = 0x8218AA80; continue 'dispatch;
	}
	// 8218AA78: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AA7C: 48000008  b 0x8218aa84
	pc = 0x8218AA84; continue 'dispatch;
            }
            0x8218AA80 => {
    //   block [0x8218AA80..0x8218AA84)
	// 8218AA80: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AA84; continue 'dispatch;
            }
            0x8218AA84 => {
    //   block [0x8218AA84..0x8218AAB0)
	// 8218AA84: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218AA88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AA8C: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AA90: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AA94: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AA98: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AA9C: 816B0260  lwz r11, 0x260(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 8218AAA0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AAA4: 409A000C  bne cr6, 0x8218aab0
	if !ctx.cr[6].eq {
	pc = 0x8218AAB0; continue 'dispatch;
	}
	// 8218AAA8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AAAC: 48000008  b 0x8218aab4
	pc = 0x8218AAB4; continue 'dispatch;
            }
            0x8218AAB0 => {
    //   block [0x8218AAB0..0x8218AAB4)
	// 8218AAB0: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AAB4; continue 'dispatch;
            }
            0x8218AAB4 => {
    //   block [0x8218AAB4..0x8218AAE0)
	// 8218AAB4: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218AAB8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AABC: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AAC0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AAC4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AAC8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AACC: 816B0264  lwz r11, 0x264(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8218AAD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AAD4: 409A000C  bne cr6, 0x8218aae0
	if !ctx.cr[6].eq {
	pc = 0x8218AAE0; continue 'dispatch;
	}
	// 8218AAD8: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AADC: 48000008  b 0x8218aae4
	pc = 0x8218AAE4; continue 'dispatch;
            }
            0x8218AAE0 => {
    //   block [0x8218AAE0..0x8218AAE4)
	// 8218AAE0: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AAE4; continue 'dispatch;
            }
            0x8218AAE4 => {
    //   block [0x8218AAE4..0x8218AB10)
	// 8218AAE4: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218AAE8: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AAEC: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AAF0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AAF4: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AAF8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AAFC: 816B0268  lwz r11, 0x268(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(616 as u32) ) } as u64;
	// 8218AB00: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AB04: 409A000C  bne cr6, 0x8218ab10
	if !ctx.cr[6].eq {
	pc = 0x8218AB10; continue 'dispatch;
	}
	// 8218AB08: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AB0C: 48000008  b 0x8218ab14
	pc = 0x8218AB14; continue 'dispatch;
            }
            0x8218AB10 => {
    //   block [0x8218AB10..0x8218AB14)
	// 8218AB10: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AB14; continue 'dispatch;
            }
            0x8218AB14 => {
    //   block [0x8218AB14..0x8218AB40)
	// 8218AB14: D01F003C  stfs f0, 0x3c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8218AB18: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AB1C: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AB20: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AB24: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8218AB28: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AB2C: 816B026C  lwz r11, 0x26c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 8218AB30: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AB34: 409A000C  bne cr6, 0x8218ab40
	if !ctx.cr[6].eq {
	pc = 0x8218AB40; continue 'dispatch;
	}
	// 8218AB38: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8218AB3C: 48000008  b 0x8218ab44
	pc = 0x8218AB44; continue 'dispatch;
            }
            0x8218AB40 => {
    //   block [0x8218AB40..0x8218AB44)
	// 8218AB40: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218AB44; continue 'dispatch;
            }
            0x8218AB44 => {
    //   block [0x8218AB44..0x8218AB54)
	// 8218AB44: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218AB48: C1BF0020  lfs f13, 0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AB4C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AB50: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x8218AB54; continue 'dispatch;
            }
            0x8218AB54 => {
    //   block [0x8218AB54..0x8218AB74)
	// 8218AB54: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218AB58: 4BFFFB31  bl 0x8218a688
	ctx.lr = 0x8218AB5C;
	sub_8218A688(ctx, base);
	// 8218AB5C: C03F006C  lfs f1, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218AB60: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AB64: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AB68: 481EF7F9  bl 0x8237a360
	ctx.lr = 0x8218AB6C;
	sub_8237A360(ctx, base);
	// 8218AB6C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8218AB70: 393F0024  addi r9, r31, 0x24
	ctx.r[9].s64 = ctx.r[31].s64 + 36;
	pc = 0x8218AB74; continue 'dispatch;
            }
            0x8218AB74 => {
    //   block [0x8218AB74..0x8218AB9C)
	// 8218AB74: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AB78: 7F045800  cmpw cr6, r4, r11
	ctx.cr[6].compare_i32(ctx.r[4].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8218AB7C: 419A0020  beq cr6, 0x8218ab9c
	if ctx.cr[6].eq {
	pc = 0x8218AB9C; continue 'dispatch;
	}
	// 8218AB80: C1BF0020  lfs f13, 0x20(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AB84: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AB88: C0090000  lfs f0, 0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218AB8C: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8218AB90: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AB94: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8218AB98: 481EF7C9  bl 0x8237a360
	ctx.lr = 0x8218AB9C;
	sub_8237A360(ctx, base);
	pc = 0x8218AB9C; continue 'dispatch;
            }
            0x8218AB9C => {
    //   block [0x8218AB9C..0x8218AC04)
	// 8218AB9C: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 8218ABA0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8218ABA4: 2F040008  cmpwi cr6, r4, 8
	ctx.cr[6].compare_i32(ctx.r[4].s32, 8, &mut ctx.xer);
	// 8218ABA8: 4198FFCC  blt cr6, 0x8218ab74
	if ctx.cr[6].lt {
	pc = 0x8218AB74; continue 'dispatch;
	}
	// 8218ABAC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218ABB0: C1BF0014  lfs f13, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218ABB4: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 8218ABB8: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218ABBC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218ABC0: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218ABC4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218ABC8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218ABCC: 419801F8  blt cr6, 0x8218adc4
	if ctx.cr[6].lt {
	pc = 0x8218ADC4; continue 'dispatch;
	}
	// 8218ABD0: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218ABD4: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8218ABD8: 409A002C  bne cr6, 0x8218ac04
	if !ctx.cr[6].eq {
	pc = 0x8218AC04; continue 'dispatch;
	}
	// 8218ABDC: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 8218ABE0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8218ABE4: 409A0020  bne cr6, 0x8218ac04
	if !ctx.cr[6].eq {
	pc = 0x8218AC04; continue 'dispatch;
	}
	// 8218ABE8: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ABEC: 4BFAE31D  bl 0x82138f08
	ctx.lr = 0x8218ABF0;
	sub_82138F08(ctx, base);
	// 8218ABF0: 93C30228  stw r30, 0x228(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 8218ABF4: 93C30230  stw r30, 0x230(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), ctx.r[30].u32 ) };
	// 8218ABF8: D3FF0014  stfs f31, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218ABFC: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 8218AC00: 480001C4  b 0x8218adc4
	pc = 0x8218ADC4; continue 'dispatch;
            }
            0x8218AC04 => {
    //   block [0x8218AC04..0x8218AC18)
	// 8218AC04: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AC08: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218AC0C: 481EF755  bl 0x8237a360
	ctx.lr = 0x8218AC10;
	sub_8237A360(ctx, base);
	// 8218AC10: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8218AC14: 39400254  li r10, 0x254
	ctx.r[10].s64 = 596;
	pc = 0x8218AC18; continue 'dispatch;
            }
            0x8218AC18 => {
    //   block [0x8218AC18..0x8218AC4C)
	// 8218AC18: 811F0078  lwz r8, 0x78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AC1C: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218AC20: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8218AC24: 419A0028  beq cr6, 0x8218ac4c
	if ctx.cr[6].eq {
	pc = 0x8218AC4C; continue 'dispatch;
	}
	// 8218AC28: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8218AC2C: 41990020  bgt cr6, 0x8218ac4c
	if ctx.cr[6].gt {
	pc = 0x8218AC4C; continue 'dispatch;
	}
	// 8218AC30: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AC34: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AC38: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218AC3C: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8218AC40: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AC44: 419A0008  beq cr6, 0x8218ac4c
	if ctx.cr[6].eq {
	pc = 0x8218AC4C; continue 'dispatch;
	}
	// 8218AC48: D3EB009C  stfs f31, 0x9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218AC4C; continue 'dispatch;
            }
            0x8218AC4C => {
    //   block [0x8218AC4C..0x8218AC80)
	// 8218AC4C: 817F0078  lwz r11, 0x78(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AC50: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8218AC54: 419A002C  beq cr6, 0x8218ac80
	if ctx.cr[6].eq {
	pc = 0x8218AC80; continue 'dispatch;
	}
	// 8218AC58: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8218AC5C: 41980024  blt cr6, 0x8218ac80
	if ctx.cr[6].lt {
	pc = 0x8218AC80; continue 'dispatch;
	}
	// 8218AC60: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8218AC64: 4098001C  bge cr6, 0x8218ac80
	if !ctx.cr[6].lt {
	pc = 0x8218AC80; continue 'dispatch;
	}
	// 8218AC68: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AC6C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218AC70: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218AC74: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AC78: 419A0008  beq cr6, 0x8218ac80
	if ctx.cr[6].eq {
	pc = 0x8218AC80; continue 'dispatch;
	}
	// 8218AC7C: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218AC80; continue 'dispatch;
            }
            0x8218AC80 => {
    //   block [0x8218AC80..0x8218ACBC)
	// 8218AC80: 811F0078  lwz r8, 0x78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AC84: 39690001  addi r11, r9, 1
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	// 8218AC88: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8218AC8C: 419A0030  beq cr6, 0x8218acbc
	if ctx.cr[6].eq {
	pc = 0x8218ACBC; continue 'dispatch;
	}
	// 8218AC90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218AC94: 41980028  blt cr6, 0x8218acbc
	if ctx.cr[6].lt {
	pc = 0x8218ACBC; continue 'dispatch;
	}
	// 8218AC98: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218AC9C: 40980020  bge cr6, 0x8218acbc
	if !ctx.cr[6].lt {
	pc = 0x8218ACBC; continue 'dispatch;
	}
	// 8218ACA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ACA4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218ACA8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218ACAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218ACB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218ACB4: 419A0008  beq cr6, 0x8218acbc
	if ctx.cr[6].eq {
	pc = 0x8218ACBC; continue 'dispatch;
	}
	// 8218ACB8: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218ACBC; continue 'dispatch;
            }
            0x8218ACBC => {
    //   block [0x8218ACBC..0x8218ACF8)
	// 8218ACBC: 811F0078  lwz r8, 0x78(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218ACC0: 39690002  addi r11, r9, 2
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	// 8218ACC4: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 8218ACC8: 419A0030  beq cr6, 0x8218acf8
	if ctx.cr[6].eq {
	pc = 0x8218ACF8; continue 'dispatch;
	}
	// 8218ACCC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218ACD0: 41980028  blt cr6, 0x8218acf8
	if ctx.cr[6].lt {
	pc = 0x8218ACF8; continue 'dispatch;
	}
	// 8218ACD4: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218ACD8: 40980020  bge cr6, 0x8218acf8
	if !ctx.cr[6].lt {
	pc = 0x8218ACF8; continue 'dispatch;
	}
	// 8218ACDC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ACE0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218ACE4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218ACE8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ACEC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218ACF0: 419A0008  beq cr6, 0x8218acf8
	if ctx.cr[6].eq {
	pc = 0x8218ACF8; continue 'dispatch;
	}
	// 8218ACF4: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218ACF8; continue 'dispatch;
            }
            0x8218ACF8 => {
    //   block [0x8218ACF8..0x8218AD18)
	// 8218ACF8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8218ACFC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8218AD00: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218AD04: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218AD08: 4198FF10  blt cr6, 0x8218ac18
	if ctx.cr[6].lt {
	pc = 0x8218AC18; continue 'dispatch;
	}
	// 8218AD0C: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218AD10: 93DF0084  stw r30, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 8218AD14: 480000B0  b 0x8218adc4
	pc = 0x8218ADC4; continue 'dispatch;
            }
            0x8218AD18 => {
    //   block [0x8218AD18..0x8218AD8C)
	// 8218AD18: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218AD1C: 4BFFF96D  bl 0x8218a688
	ctx.lr = 0x8218AD20;
	sub_8218A688(ctx, base);
	// 8218AD20: C03F006C  lfs f1, 0x6c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218AD24: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218AD28: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AD2C: 481EF635  bl 0x8237a360
	ctx.lr = 0x8218AD30;
	sub_8237A360(ctx, base);
	// 8218AD30: C03F0064  lfs f1, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218AD34: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8218AD38: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AD3C: 481EF625  bl 0x8237a360
	ctx.lr = 0x8218AD40;
	sub_8237A360(ctx, base);
	// 8218AD40: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218AD44: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218AD48: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218AD4C: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218AD50: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218AD54: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218AD58: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218AD5C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218AD60: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218AD64: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218AD68: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218AD6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218AD70: 409A001C  bne cr6, 0x8218ad8c
	if !ctx.cr[6].eq {
	pc = 0x8218AD8C; continue 'dispatch;
	}
	// 8218AD74: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218AD78: C1BF0014  lfs f13, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AD7C: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 8218AD80: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218AD84: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218AD88: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x8218AD8C; continue 'dispatch;
            }
            0x8218AD8C => {
    //   block [0x8218AD8C..0x8218ADC4)
	// 8218AD8C: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218AD90: C1BF0088  lfs f13, 0x88(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AD94: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218AD98: 4198002C  blt cr6, 0x8218adc4
	if ctx.cr[6].lt {
	pc = 0x8218ADC4; continue 'dispatch;
	}
	// 8218AD9C: 809F0078  lwz r4, 0x78(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) } as u64;
	// 8218ADA0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218ADA4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ADA8: 481EF5B9  bl 0x8237a360
	ctx.lr = 0x8218ADAC;
	sub_8237A360(ctx, base);
	// 8218ADAC: 809F0068  lwz r4, 0x68(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) } as u64;
	// 8218ADB0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218ADB4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218ADB8: 481EF5A9  bl 0x8237a360
	ctx.lr = 0x8218ADBC;
	sub_8237A360(ctx, base);
	// 8218ADBC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218ADC0: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	pc = 0x8218ADC4; continue 'dispatch;
            }
            0x8218ADC4 => {
    //   block [0x8218ADC4..0x8218AE04)
	// 8218ADC4: 3CE082C0  lis r7, -0x7d40
	ctx.r[7].s64 = -2101346304;
	// 8218ADC8: 8107B9BC  lwz r8, -0x4644(r7)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17988 as u32) ) } as u64;
	// 8218ADCC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8218ADD0: 419A0058  beq cr6, 0x8218ae28
	if ctx.cr[6].eq {
	pc = 0x8218AE28; continue 'dispatch;
	}
	// 8218ADD4: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8218ADD8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218ADDC: 392A76FC  addi r9, r10, 0x76fc
	ctx.r[9].s64 = ctx.r[10].s64 + 30460;
	// 8218ADE0: 616BEB1C  ori r11, r11, 0xeb1c
	ctx.r[11].u64 = ctx.r[11].u64 | 60188;
	// 8218ADE4: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218ADE8: 7D4A58AE  lbzx r10, r10, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218ADEC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218ADF0: 409A0014  bne cr6, 0x8218ae04
	if !ctx.cr[6].eq {
	pc = 0x8218AE04; continue 'dispatch;
	}
	// 8218ADF4: 2F080001  cmpwi cr6, r8, 1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 1, &mut ctx.xer);
	// 8218ADF8: 409A000C  bne cr6, 0x8218ae04
	if !ctx.cr[6].eq {
	pc = 0x8218AE04; continue 'dispatch;
	}
	// 8218ADFC: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8218AE00: 9107B9BC  stw r8, -0x4644(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-17988 as u32), ctx.r[8].u32 ) };
	pc = 0x8218AE04; continue 'dispatch;
            }
            0x8218AE04 => {
    //   block [0x8218AE04..0x8218AE28)
	// 8218AE04: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 8218AE08: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218AE0C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218AE10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AE14: 409A0014  bne cr6, 0x8218ae28
	if !ctx.cr[6].eq {
	pc = 0x8218AE28; continue 'dispatch;
	}
	// 8218AE18: 2F080002  cmpwi cr6, r8, 2
	ctx.cr[6].compare_i32(ctx.r[8].s32, 2, &mut ctx.xer);
	// 8218AE1C: 409A000C  bne cr6, 0x8218ae28
	if !ctx.cr[6].eq {
	pc = 0x8218AE28; continue 'dispatch;
	}
	// 8218AE20: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 8218AE24: 9167B9BC  stw r11, -0x4644(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(-17988 as u32), ctx.r[11].u32 ) };
	pc = 0x8218AE28; continue 'dispatch;
            }
            0x8218AE28 => {
    //   block [0x8218AE28..0x8218AE38)
	// 8218AE28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218AE2C: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218AE30: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218AE34: 483AA2D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218AE38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218AE38 size=324
    let mut pc: u32 = 0x8218AE38;
    'dispatch: loop {
        match pc {
            0x8218AE38 => {
    //   block [0x8218AE38..0x8218AEF8)
	// 8218AE38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218AE3C: 483AA275  bl 0x825350b0
	ctx.lr = 0x8218AE40;
	sub_82535080(ctx, base);
	// 8218AE40: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218AE44: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218AE48: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218AE4C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218AE50: 614A85F8  ori r10, r10, 0x85f8
	ctx.r[10].u64 = ctx.r[10].u64 | 34296;
	// 8218AE54: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8218AE58: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8218AE5C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8218AE60: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 8218AE64: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218AE68: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218AE6C: 409A0108  bne cr6, 0x8218af74
	if !ctx.cr[6].eq {
	pc = 0x8218AF74; continue 'dispatch;
	}
	// 8218AE70: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218AE74: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 8218AE78: 419A00FC  beq cr6, 0x8218af74
	if ctx.cr[6].eq {
	pc = 0x8218AF74; continue 'dispatch;
	}
	// 8218AE7C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218AE80: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 8218AE84: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 8218AE88: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8218AE8C: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218AE90: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8218AE94: 917EB9BC  stw r11, -0x4644(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17988 as u32), ctx.r[11].u32 ) };
	// 8218AE98: 4BFFE8D1  bl 0x82189768
	ctx.lr = 0x8218AE9C;
	sub_82189768(ctx, base);
	// 8218AE9C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218AEA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218AEA4: 93BF023C  stw r29, 0x23c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), ctx.r[29].u32 ) };
	// 8218AEA8: 939F0238  stw r28, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[28].u32 ) };
	// 8218AEAC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218AEB0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218AEB4: 4E800421  bctrl
	ctx.lr = 0x8218AEB8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218AEB8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8218AEBC: 817EB9BC  lwz r11, -0x4644(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17988 as u32) ) } as u64;
	// 8218AEC0: 576A043E  clrlwi r10, r27, 0x10
	ctx.r[10].u64 = ctx.r[27].u32 as u64 & 0x0000FFFFu64;
	// 8218AEC4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218AEC8: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8218AECC: 419A003C  beq cr6, 0x8218af08
	if ctx.cr[6].eq {
	pc = 0x8218AF08; continue 'dispatch;
	}
	// 8218AED0: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218AED4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AED8: 419A0020  beq cr6, 0x8218aef8
	if ctx.cr[6].eq {
	pc = 0x8218AEF8; continue 'dispatch;
	}
	// 8218AEDC: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8218AEE0: 6108ED84  ori r8, r8, 0xed84
	ctx.r[8].u64 = ctx.r[8].u64 | 60804;
	// 8218AEE4: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8218AEE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218AEEC: 419A000C  beq cr6, 0x8218aef8
	if ctx.cr[6].eq {
	pc = 0x8218AEF8; continue 'dispatch;
	}
	// 8218AEF0: 913F022C  stw r9, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[9].u32 ) };
	// 8218AEF4: 48000014  b 0x8218af08
	pc = 0x8218AF08; continue 'dispatch;
            }
            0x8218AEF8 => {
    //   block [0x8218AEF8..0x8218AF04)
	// 8218AEF8: 2F0A000F  cmpwi cr6, r10, 0xf
	ctx.cr[6].compare_i32(ctx.r[10].s32, 15, &mut ctx.xer);
	// 8218AEFC: 41980008  blt cr6, 0x8218af04
	if ctx.cr[6].lt {
	pc = 0x8218AF04; continue 'dispatch;
	}
	// 8218AF00: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	pc = 0x8218AF04; continue 'dispatch;
            }
            0x8218AF04 => {
    //   block [0x8218AF04..0x8218AF08)
	// 8218AF04: 915F022C  stw r10, 0x22c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(556 as u32), ctx.r[10].u32 ) };
	pc = 0x8218AF08; continue 'dispatch;
            }
            0x8218AF08 => {
    //   block [0x8218AF08..0x8218AF60)
	// 8218AF08: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 8218AF0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218AF10: 41990050  bgt cr6, 0x8218af60
	if ctx.cr[6].gt {
	pc = 0x8218AF60; continue 'dispatch;
	}
	// 8218AF14: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8218AF18: 815F023C  lwz r10, 0x23c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218AF1C: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8218AF20: 6169A9C0  ori r9, r11, 0xa9c0
	ctx.r[9].u64 = ctx.r[11].u64 | 43456;
	// 8218AF24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218AF28: 61089B74  ori r8, r8, 0x9b74
	ctx.r[8].u64 = ctx.r[8].u64 | 39796;
	// 8218AF2C: 7D4A482E  lwzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218AF30: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218AF34: 397F0030  addi r11, r31, 0x30
	ctx.r[11].s64 = ctx.r[31].s64 + 48;
	// 8218AF38: 3D2A0002  addis r9, r10, 2
	ctx.r[9].s64 = ctx.r[10].s64 + 131072;
	// 8218AF3C: 39299BA0  addi r9, r9, -0x6460
	ctx.r[9].s64 = ctx.r[9].s64 + -25696;
	// 8218AF40: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8218AF44: F8EB0000  std r7, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 8218AF48: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8218AF4C: F92B0008  std r9, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8218AF50: 7DAA442E  lfsx f13, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218AF54: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218AF58: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218AF5C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8218AF60; continue 'dispatch;
            }
            0x8218AF60 => {
    //   block [0x8218AF60..0x8218AF74)
	// 8218AF60: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218AF64: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8218AF68: 4BFFEBF9  bl 0x82189b60
	ctx.lr = 0x8218AF6C;
	sub_82189B60(ctx, base);
	// 8218AF6C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218AF70: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	pc = 0x8218AF74; continue 'dispatch;
            }
            0x8218AF74 => {
    //   block [0x8218AF74..0x8218AF7C)
	// 8218AF74: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218AF78: 483AA188  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218AF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218AF80 size=12
    let mut pc: u32 = 0x8218AF80;
    'dispatch: loop {
        match pc {
            0x8218AF80 => {
    //   block [0x8218AF80..0x8218AF8C)
	// 8218AF80: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218AF84: 386B0034  addi r3, r11, 0x34
	ctx.r[3].s64 = ctx.r[11].s64 + 52;
	// 8218AF88: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218AF90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218AF90 size=72
    let mut pc: u32 = 0x8218AF90;
    'dispatch: loop {
        match pc {
            0x8218AF90 => {
    //   block [0x8218AF90..0x8218AFD8)
	// 8218AF90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218AF94: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218AF98: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218AF9C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218AFA0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218AFA4: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218AFA8: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218AFAC: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8218AFB0: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218AFB4: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218AFB8: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218AFBC: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8218AFC0: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218AFC4: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218AFC8: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218AFCC: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218AFD0: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218AFD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218AFD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218AFD8 size=12
    let mut pc: u32 = 0x8218AFD8;
    'dispatch: loop {
        match pc {
            0x8218AFD8 => {
    //   block [0x8218AFD8..0x8218AFE4)
	// 8218AFD8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218AFDC: 386B0040  addi r3, r11, 0x40
	ctx.r[3].s64 = ctx.r[11].s64 + 64;
	// 8218AFE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218AFE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218AFE8 size=180
    let mut pc: u32 = 0x8218AFE8;
    'dispatch: loop {
        match pc {
            0x8218AFE8 => {
    //   block [0x8218AFE8..0x8218B03C)
	// 8218AFE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218AFEC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218AFF0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218AFF4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218AFF8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218AFFC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B000: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218B004: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B008: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B00C: 4BFFEFDD  bl 0x82189fe8
	ctx.lr = 0x8218B010;
	sub_82189FE8(ctx, base);
	// 8218B010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B014: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B018: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218B01C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218B020: 409A001C  bne cr6, 0x8218b03c
	if !ctx.cr[6].eq {
	pc = 0x8218B03C; continue 'dispatch;
	}
	// 8218B024: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B028: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B02C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B030: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B034: 4BFFEE9D  bl 0x82189ed0
	ctx.lr = 0x8218B038;
	sub_82189ED0(ctx, base);
	// 8218B038: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x8218B03C; continue 'dispatch;
            }
            0x8218B03C => {
    //   block [0x8218B03C..0x8218B09C)
	// 8218B03C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B040: D3FF0058  stfs f31, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B044: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218B048: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B04C: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218B050: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218B054: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218B058: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 8218B05C: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218B060: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218B064: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218B068: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B06C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B070: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218B074: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B078: 4E800421  bctrl
	ctx.lr = 0x8218B07C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218B07C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218B080: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218B084: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B088: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B08C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218B090: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218B094: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B098: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B0A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B0A0 size=72
    let mut pc: u32 = 0x8218B0A0;
    'dispatch: loop {
        match pc {
            0x8218B0A0 => {
    //   block [0x8218B0A0..0x8218B0E8)
	// 8218B0A0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B0A4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218B0A8: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B0AC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218B0B0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B0B4: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8218B0B8: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B0BC: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 8218B0C0: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B0C4: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218B0C8: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B0CC: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B0D0: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8218B0D4: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B0D8: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B0DC: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B0E0: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B0E8 size=12
    let mut pc: u32 = 0x8218B0E8;
    'dispatch: loop {
        match pc {
            0x8218B0E8 => {
    //   block [0x8218B0E8..0x8218B0F4)
	// 8218B0E8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218B0EC: 386B004C  addi r3, r11, 0x4c
	ctx.r[3].s64 = ctx.r[11].s64 + 76;
	// 8218B0F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B0F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B0F8 size=72
    let mut pc: u32 = 0x8218B0F8;
    'dispatch: loop {
        match pc {
            0x8218B0F8 => {
    //   block [0x8218B0F8..0x8218B140)
	// 8218B0F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B0FC: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8218B100: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B104: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B108: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B10C: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218B110: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B114: 9143006C  stw r10, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8218B118: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B11C: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B120: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B124: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8218B128: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B12C: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218B130: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B134: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B138: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B13C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B140(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B140 size=12
    let mut pc: u32 = 0x8218B140;
    'dispatch: loop {
        match pc {
            0x8218B140 => {
    //   block [0x8218B140..0x8218B14C)
	// 8218B140: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218B144: 386B0064  addi r3, r11, 0x64
	ctx.r[3].s64 = ctx.r[11].s64 + 100;
	// 8218B148: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B150(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B150 size=148
    let mut pc: u32 = 0x8218B150;
    'dispatch: loop {
        match pc {
            0x8218B150 => {
    //   block [0x8218B150..0x8218B1E4)
	// 8218B150: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B154: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218B158: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218B15C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218B160: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218B164: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B168: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B16C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218B170: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B174: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218B178: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B17C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B180: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B184: 4BFFED4D  bl 0x82189ed0
	ctx.lr = 0x8218B188;
	sub_82189ED0(ctx, base);
	// 8218B188: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B18C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B190: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218B194: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B198: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218B19C: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218B1A0: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218B1A4: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218B1A8: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218B1AC: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218B1B0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B1B4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B1B8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218B1BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B1C0: 4E800421  bctrl
	ctx.lr = 0x8218B1C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218B1C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218B1C8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218B1CC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B1D0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B1D4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218B1D8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218B1DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B1E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B1E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B1E8 size=80
    let mut pc: u32 = 0x8218B1E8;
    'dispatch: loop {
        match pc {
            0x8218B1E8 => {
    //   block [0x8218B1E8..0x8218B238)
	// 8218B1E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B1EC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8218B1F0: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8218B1F4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B1F8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B1FC: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B200: 9143006C  stw r10, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8218B204: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B208: 91230060  stw r9, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 8218B20C: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B210: 9143001C  stw r10, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 8218B214: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B218: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B21C: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8218B220: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B224: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218B228: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B22C: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B230: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B234: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B238 size=12
    let mut pc: u32 = 0x8218B238;
    'dispatch: loop {
        match pc {
            0x8218B238 => {
    //   block [0x8218B238..0x8218B244)
	// 8218B238: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218B23C: 386B0058  addi r3, r11, 0x58
	ctx.r[3].s64 = ctx.r[11].s64 + 88;
	// 8218B240: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B248 size=172
    let mut pc: u32 = 0x8218B248;
    'dispatch: loop {
        match pc {
            0x8218B248 => {
    //   block [0x8218B248..0x8218B29C)
	// 8218B248: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B24C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218B250: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218B254: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218B258: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218B25C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B260: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218B264: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B268: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B26C: 4BFFED7D  bl 0x82189fe8
	ctx.lr = 0x8218B270;
	sub_82189FE8(ctx, base);
	// 8218B270: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B278: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218B27C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218B280: 409A001C  bne cr6, 0x8218b29c
	if !ctx.cr[6].eq {
	pc = 0x8218B29C; continue 'dispatch;
	}
	// 8218B284: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B288: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B28C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B290: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B294: 4BFFEC3D  bl 0x82189ed0
	ctx.lr = 0x8218B298;
	sub_82189ED0(ctx, base);
	// 8218B298: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x8218B29C; continue 'dispatch;
            }
            0x8218B29C => {
    //   block [0x8218B29C..0x8218B2F4)
	// 8218B29C: D3FF0058  stfs f31, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B2A0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218B2A4: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218B2A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B2AC: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218B2B0: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218B2B4: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218B2B8: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218B2BC: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218B2C0: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B2C4: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B2C8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218B2CC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B2D0: 4E800421  bctrl
	ctx.lr = 0x8218B2D4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218B2D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218B2D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218B2DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B2E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B2E4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218B2E8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218B2EC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B2F0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B2F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B2F8 size=84
    let mut pc: u32 = 0x8218B2F8;
    'dispatch: loop {
        match pc {
            0x8218B2F8 => {
    //   block [0x8218B2F8..0x8218B34C)
	// 8218B2F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B2FC: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 8218B300: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 8218B304: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8218B308: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B30C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B310: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B314: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218B318: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B31C: 9123006C  stw r9, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 8218B320: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B324: 9103001C  stw r8, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[8].u32 ) };
	// 8218B328: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B32C: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B330: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8218B334: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B338: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218B33C: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B340: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B344: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B348: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B350 size=12
    let mut pc: u32 = 0x8218B350;
    'dispatch: loop {
        match pc {
            0x8218B350 => {
    //   block [0x8218B350..0x8218B35C)
	// 8218B350: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218B354: 386B007C  addi r3, r11, 0x7c
	ctx.r[3].s64 = ctx.r[11].s64 + 124;
	// 8218B358: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B360(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B360 size=184
    let mut pc: u32 = 0x8218B360;
    'dispatch: loop {
        match pc {
            0x8218B360 => {
    //   block [0x8218B360..0x8218B3B4)
	// 8218B360: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B364: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218B368: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218B36C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218B370: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218B374: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B378: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218B37C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B380: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B384: 4BFFEC65  bl 0x82189fe8
	ctx.lr = 0x8218B388;
	sub_82189FE8(ctx, base);
	// 8218B388: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B38C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B390: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218B394: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218B398: 409A001C  bne cr6, 0x8218b3b4
	if !ctx.cr[6].eq {
	pc = 0x8218B3B4; continue 'dispatch;
	}
	// 8218B39C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B3A0: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B3A4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B3A8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B3AC: 4BFFEB25  bl 0x82189ed0
	ctx.lr = 0x8218B3B0;
	sub_82189ED0(ctx, base);
	// 8218B3B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x8218B3B4; continue 'dispatch;
            }
            0x8218B3B4 => {
    //   block [0x8218B3B4..0x8218B418)
	// 8218B3B4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218B3B8: D3FF0058  stfs f31, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B3BC: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218B3C0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218B3C4: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218B3C8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B3CC: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218B3D0: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218B3D4: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B3D8: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218B3DC: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218B3E0: D01F023C  stfs f0, 0x23c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(572 as u32), tmp.u32 ) };
	// 8218B3E4: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B3E8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B3EC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218B3F0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B3F4: 4E800421  bctrl
	ctx.lr = 0x8218B3F8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218B3F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218B3FC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218B400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B408: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218B40C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218B410: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B414: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B418 size=104
    let mut pc: u32 = 0x8218B418;
    'dispatch: loop {
        match pc {
            0x8218B418 => {
    //   block [0x8218B418..0x8218B480)
	// 8218B418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B41C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8218B420: 39000007  li r8, 7
	ctx.r[8].s64 = 7;
	// 8218B424: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218B428: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B42C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218B430: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B434: 9123006C  stw r9, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 8218B438: 91030060  stw r8, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[8].u32 ) };
	// 8218B43C: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B440: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B444: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B448: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B44C: D1A3004C  stfs f13, 0x4c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8218B450: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B454: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B458: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B45C: D1A3003C  stfs f13, 0x3c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8218B460: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B464: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218B468: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B46C: D1A3005C  stfs f13, 0x5c(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8218B470: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8218B474: 91430074  stw r10, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8218B478: 9123001C  stw r9, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8218B47C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B480(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B480 size=12
    let mut pc: u32 = 0x8218B480;
    'dispatch: loop {
        match pc {
            0x8218B480 => {
    //   block [0x8218B480..0x8218B48C)
	// 8218B480: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218B484: 386B0088  addi r3, r11, 0x88
	ctx.r[3].s64 = ctx.r[11].s64 + 136;
	// 8218B488: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B490(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B490 size=76
    let mut pc: u32 = 0x8218B490;
    'dispatch: loop {
        match pc {
            0x8218B490 => {
    //   block [0x8218B490..0x8218B4DC)
	// 8218B490: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B494: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8218B498: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8218B49C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B4A0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B4A4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218B4A8: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218B4AC: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218B4B0: 9123006C  stw r9, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 8218B4B4: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218B4B8: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218B4BC: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B4C0: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8218B4C4: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B4C8: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218B4CC: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B4D0: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218B4D4: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B4D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B4E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B4E0 size=104
    let mut pc: u32 = 0x8218B4E0;
    'dispatch: loop {
        match pc {
            0x8218B4E0 => {
    //   block [0x8218B4E0..0x8218B548)
	// 8218B4E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B4E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218B4E8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218B4EC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B4F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B4F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B4F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B4FC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B500: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B504: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218B508: 4BFDA599  bl 0x82165aa0
	ctx.lr = 0x8218B50C;
	sub_82165AA0(ctx, base);
	// 8218B50C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218B510: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218B514: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B518: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B51C: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8218B520: D003008C  stfs f0, 0x8c(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8218B524: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8218B528: C1AB2780  lfs f13, 0x2780(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B52C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218B530: D1AB0070  stfs f13, 0x70(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218B534: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218B538: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B53C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B540: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B544: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B548(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B548 size=40
    let mut pc: u32 = 0x8218B548;
    'dispatch: loop {
        match pc {
            0x8218B548 => {
    //   block [0x8218B548..0x8218B570)
	// 8218B548: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B54C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218B550: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B554: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218B558: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218B55C: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218B560: 91630028  stw r11, 0x28(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 8218B564: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218B568: 91630024  stw r11, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 8218B56C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B570(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218B570 size=456
    let mut pc: u32 = 0x8218B570;
    'dispatch: loop {
        match pc {
            0x8218B570 => {
    //   block [0x8218B570..0x8218B630)
	// 8218B570: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8218B574: 8169001C  lwz r11, 0x1c(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218B578: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218B57C: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8218B580: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218B584: C1A90030  lfs f13, 0x30(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B588: 80690020  lwz r3, 0x20(r9)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218B58C: 616B9BA0  ori r11, r11, 0x9ba0
	ctx.r[11].u64 = ctx.r[11].u64 | 39840;
	// 8218B590: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8218B594: 7D675B78  mr r7, r11
	ctx.r[7].u64 = ctx.r[11].u64;
	// 8218B598: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218B59C: 616B9BA4  ori r11, r11, 0x9ba4
	ctx.r[11].u64 = ctx.r[11].u64 | 39844;
	// 8218B5A0: 7D665B78  mr r6, r11
	ctx.r[6].u64 = ctx.r[11].u64;
	// 8218B5A4: 7D655B78  mr r5, r11
	ctx.r[5].u64 = ctx.r[11].u64;
	// 8218B5A8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218B5AC: 616A9BA8  ori r10, r11, 0x9ba8
	ctx.r[10].u64 = ctx.r[11].u64 | 39848;
	// 8218B5B0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218B5B4: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8218B5B8: 808B0004  lwz r4, 4(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B5BC: 7C04442E  lfsx f0, r4, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B5C0: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B5C4: 7D883C2E  lfsx f12, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B5C8: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 8218B5CC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8218B5D0: 7D88342E  lfsx f12, r8, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B5D4: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B5D8: 7D682C2E  lfsx f11, r8, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B5DC: 7C882378  mr r8, r4
	ctx.r[8].u64 = ctx.r[4].u64;
	// 8218B5E0: ED8C582A  fadds f12, f12, f11
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64;
	// 8218B5E4: 7D48542E  lfsx f10, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218B5E8: 810B0000  lwz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B5EC: 7D68542E  lfsx f11, r8, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B5F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B5F4: ED2A582A  fadds f9, f10, f11
	ctx.f[9].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 8218B5F8: C16ABFFC  lfs f11, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B5FC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8218B600: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218B604: ED4C02F2  fmuls f10, f12, f11
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218B608: ED0902F2  fmuls f8, f9, f11
	ctx.f[8].f64 = (((ctx.f[9].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218B60C: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B610: C00AD560  lfs f0, -0x2aa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B614: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B618: FD206210  fabs f9, f12
	ctx.f[9].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 8218B61C: FF090000  fcmpu cr6, f9, f0
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[0].f64);
	// 8218B620: C12AD6C8  lfs f9, -0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218B624: 4099000C  ble cr6, 0x8218b630
	if !ctx.cr[6].gt {
	pc = 0x8218B630; continue 'dispatch;
	}
	// 8218B628: EDAC6A7A  fmadds f13, f12, f9, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B62C: D1A90030  stfs f13, 0x30(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x8218B630; continue 'dispatch;
            }
            0x8218B630 => {
    //   block [0x8218B630..0x8218B64C)
	// 8218B630: C1A90034  lfs f13, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B634: ED8A6828  fsubs f12, f10, f13
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B638: FD406210  fabs f10, f12
	ctx.f[10].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 8218B63C: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 8218B640: 4099000C  ble cr6, 0x8218b64c
	if !ctx.cr[6].gt {
	pc = 0x8218B64C; continue 'dispatch;
	}
	// 8218B644: EDAC6A7A  fmadds f13, f12, f9, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B648: D1A90034  stfs f13, 0x34(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x8218B64C; continue 'dispatch;
            }
            0x8218B64C => {
    //   block [0x8218B64C..0x8218B668)
	// 8218B64C: C1A90038  lfs f13, 0x38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B650: ED886828  fsubs f12, f8, f13
	ctx.f[12].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B654: FD406210  fabs f10, f12
	ctx.f[10].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 8218B658: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 8218B65C: 4099000C  ble cr6, 0x8218b668
	if !ctx.cr[6].gt {
	pc = 0x8218B668; continue 'dispatch;
	}
	// 8218B660: EDAC6A7A  fmadds f13, f12, f9, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B664: D1A90038  stfs f13, 0x38(r9)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(56 as u32), tmp.u32 ) };
	pc = 0x8218B668; continue 'dispatch;
            }
            0x8218B668 => {
    //   block [0x8218B668..0x8218B6BC)
	// 8218B668: 81490024  lwz r10, 0x24(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218B66C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218B670: 419A004C  beq cr6, 0x8218b6bc
	if ctx.cr[6].eq {
	pc = 0x8218B6BC; continue 'dispatch;
	}
	// 8218B674: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B678: C1A30050  lfs f13, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B67C: C18A2090  lfs f12, 0x2090(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8336 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B680: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218B684: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B688: FDAA6B2E  fsel f13, f10, f12, f13
	ctx.f[13].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[13].f64 };
	// 8218B68C: C18A2144  lfs f12, 0x2144(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8516 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B690: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8218B694: ED4C6828  fsubs f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B698: FDAA636E  fsel f13, f10, f13, f12
	ctx.f[13].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[12].f64 };
	// 8218B69C: D1A30050  stfs f13, 0x50(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B6A0: C1A90034  lfs f13, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B6A4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B6A8: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218B6AC: C1AAD5B0  lfs f13, -0x2a50(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B6B0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218B6B4: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218B6B8: D0090034  stfs f0, 0x34(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(52 as u32), tmp.u32 ) };
	pc = 0x8218B6BC; continue 'dispatch;
            }
            0x8218B6BC => {
    //   block [0x8218B6BC..0x8218B71C)
	// 8218B6BC: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B6C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218B6C4: 419A0058  beq cr6, 0x8218b71c
	if ctx.cr[6].eq {
	pc = 0x8218B71C; continue 'dispatch;
	}
	// 8218B6C8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218B6D0: 419A004C  beq cr6, 0x8218b71c
	if ctx.cr[6].eq {
	pc = 0x8218B71C; continue 'dispatch;
	}
	// 8218B6D4: 81690028  lwz r11, 0x28(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218B6D8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218B6DC: 419A0040  beq cr6, 0x8218b71c
	if ctx.cr[6].eq {
	pc = 0x8218B71C; continue 'dispatch;
	}
	// 8218B6E0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218B6E4: C0030070  lfs f0, 0x70(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B6E8: 616BE9DC  ori r11, r11, 0xe9dc
	ctx.r[11].u64 = ctx.r[11].u64 | 59868;
	// 8218B6EC: 7D8A5C2E  lfsx f12, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B6F0: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8218B6F4: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B6F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B6FC: EDAC6AFA  fmadds f13, f12, f11, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B700: C18B228C  lfs f12, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B704: ED6C0028  fsubs f11, f12, f0
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218B708: ED4D0028  fsubs f10, f13, f0
	ctx.f[10].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218B70C: FD8B032E  fsel f12, f11, f12, f0
	ctx.f[12].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 8218B710: D18301AC  stfs f12, 0x1ac(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(428 as u32), tmp.u32 ) };
	// 8218B714: FC0A682E  fsel f0, f10, f0, f13
	ctx.f[0].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218B718: D00301A8  stfs f0, 0x1a8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(424 as u32), tmp.u32 ) };
	pc = 0x8218B71C; continue 'dispatch;
            }
            0x8218B71C => {
    //   block [0x8218B71C..0x8218B738)
	// 8218B71C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B720: C0690038  lfs f3, 0x38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8218B724: C0490034  lfs f2, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218B728: C0290030  lfs f1, 0x30(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218B72C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218B730: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B734: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218B738 size=4
    let mut pc: u32 = 0x8218B738;
    'dispatch: loop {
        match pc {
            0x8218B738 => {
    //   block [0x8218B738..0x8218B73C)
	// 8218B738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B740 size=192
    let mut pc: u32 = 0x8218B740;
    'dispatch: loop {
        match pc {
            0x8218B740 => {
    //   block [0x8218B740..0x8218B790)
	// 8218B740: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B744: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218B748: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218B74C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218B750: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B754: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B758: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B75C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B760: 4BFFDDD1  bl 0x82189530
	ctx.lr = 0x8218B764;
	sub_82189530(ctx, base);
	// 8218B764: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218B768: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218B76C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218B770: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218B774: 409A001C  bne cr6, 0x8218b790
	if !ctx.cr[6].eq {
	pc = 0x8218B790; continue 'dispatch;
	}
	// 8218B778: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B77C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218B780: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B784: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B788: 4BFDA319  bl 0x82165aa0
	ctx.lr = 0x8218B78C;
	sub_82165AA0(ctx, base);
	// 8218B78C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	pc = 0x8218B790; continue 'dispatch;
            }
            0x8218B790 => {
    //   block [0x8218B790..0x8218B7E8)
	// 8218B790: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218B794: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218B798: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B79C: 914B0148  stw r10, 0x148(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 8218B7A0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B7A4: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218B7A8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218B7AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218B7B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218B7B4: 4E800421  bctrl
	ctx.lr = 0x8218B7B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218B7B8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218B7BC: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B7C0: 4BFAD749  bl 0x82138f08
	ctx.lr = 0x8218B7C4;
	sub_82138F08(ctx, base);
	// 8218B7C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218B7C8: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8218B7CC: 409A001C  bne cr6, 0x8218b7e8
	if !ctx.cr[6].eq {
	pc = 0x8218B7E8; continue 'dispatch;
	}
	// 8218B7D0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218B7D4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218B7D8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218B7DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218B7E0: 48007F91  bl 0x82193770
	ctx.lr = 0x8218B7E4;
	sub_82193770(ctx, base);
	// 8218B7E4: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
            }
            0x8218B7E8 => {
    //   block [0x8218B7E8..0x8218B800)
	// 8218B7E8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218B7EC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218B7F0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218B7F4: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218B7F8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218B7FC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218B800(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218B800 size=872
    let mut pc: u32 = 0x8218B800;
    'dispatch: loop {
        match pc {
            0x8218B800 => {
    //   block [0x8218B800..0x8218B86C)
	// 8218B800: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218B804: 483A98B5  bl 0x825350b8
	ctx.lr = 0x8218B808;
	sub_82535080(ctx, base);
	// 8218B808: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218B80C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218B810: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218B814: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218B818: 419A0348  beq cr6, 0x8218bb60
	if ctx.cr[6].eq {
	pc = 0x8218BB60; continue 'dispatch;
	}
	// 8218B81C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218B820: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218B824: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B828: 394BBFF0  addi r10, r11, -0x4010
	ctx.r[10].s64 = ctx.r[11].s64 + -16400;
	// 8218B82C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218B830: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218B834: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218B838: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218B83C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218B840: 7D684B78  or r8, r11, r9
	ctx.r[8].u64 = ctx.r[11].u64 | ctx.r[9].u64;
	// 8218B844: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218B848: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B84C: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8218B850: 7D2A482E  lwzx r9, r10, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218B854: 7D094B78  or r9, r8, r9
	ctx.r[9].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8218B858: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8218B85C: 409A0010  bne cr6, 0x8218b86c
	if !ctx.cr[6].eq {
	pc = 0x8218B86C; continue 'dispatch;
	}
	// 8218B860: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218B864: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8218B868: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	pc = 0x8218B86C; continue 'dispatch;
            }
            0x8218B86C => {
    //   block [0x8218B86C..0x8218B8AC)
	// 8218B86C: 813F0058  lwz r9, 0x58(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8218B870: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8218B874: 2B090005  cmplwi cr6, r9, 5
	ctx.cr[6].compare_u32(ctx.r[9].u32, 5 as u32, &mut ctx.xer);
	// 8218B878: 41990198  bgt cr6, 0x8218ba10
	if ctx.cr[6].gt {
	pc = 0x8218BA10; continue 'dispatch;
	}
	// 8218B87C: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218B880: 398CB894  addi r12, r12, -0x476c
	ctx.r[12].s64 = ctx.r[12].s64 + -18284;
	// 8218B884: 5520103A  slwi r0, r9, 2
	ctx.r[0].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218B888: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218B88C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218B890: 4E800420  bctr
	match ctx.r[9].u64 {
		0 => {
	pc = 0x8218B8AC; continue 'dispatch;
		},
		1 => {
	pc = 0x8218B8AC; continue 'dispatch;
		},
		2 => {
	pc = 0x8218B8AC; continue 'dispatch;
		},
		3 => {
	pc = 0x8218B8AC; continue 'dispatch;
		},
		4 => {
	pc = 0x8218B95C; continue 'dispatch;
		},
		5 => {
	pc = 0x8218B95C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218B894: 8218B8AC  lwz r16, -0x4754(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 8218B898: 8218B8AC  lwz r16, -0x4754(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 8218B89C: 8218B8AC  lwz r16, -0x4754(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 8218B8A0: 8218B8AC  lwz r16, -0x4754(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18260 as u32) ) } as u64;
	// 8218B8A4: 8218B95C  lwz r16, -0x46a4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18084 as u32) ) } as u64;
	// 8218B8A8: 8218B95C  lwz r16, -0x46a4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-18084 as u32) ) } as u64;
            }
            0x8218B8AC => {
    //   block [0x8218B8AC..0x8218B95C)
	// 8218B8AC: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218B8B0: 2F090078  cmpwi cr6, r9, 0x78
	ctx.cr[6].compare_i32(ctx.r[9].s32, 120, &mut ctx.xer);
	// 8218B8B4: 4098015C  bge cr6, 0x8218ba10
	if !ctx.cr[6].lt {
	pc = 0x8218BA10; continue 'dispatch;
	}
	// 8218B8B8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B8BC: C00B0070  lfs f0, 0x70(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B8C0: C13F0044  lfs f9, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218B8C4: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8218B8C8: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B8CC: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B8D0: C18B0054  lfs f12, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B8D4: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B8D8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8218B8DC: C14927A8  lfs f10, 0x27a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10152 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218B8E0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B8E4: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218B8E8: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B8EC: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 8218B8F0: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218B8F4: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218B8F8: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B8FC: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B900: C15F0048  lfs f10, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218B904: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B908: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B90C: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B910: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 8218B914: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B918: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218B91C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218B920: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218B924: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B928: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B92C: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B930: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218B934: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B938: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B93C: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218B940: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218B944: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218B948: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218B94C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218B950: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B954: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218B958: 480000B0  b 0x8218ba08
	pc = 0x8218BA08; continue 'dispatch;
            }
            0x8218B95C => {
    //   block [0x8218B95C..0x8218BA08)
	// 8218B95C: 813F0010  lwz r9, 0x10(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218B960: 2F090078  cmpwi cr6, r9, 0x78
	ctx.cr[6].compare_i32(ctx.r[9].s32, 120, &mut ctx.xer);
	// 8218B964: 409800AC  bge cr6, 0x8218ba10
	if !ctx.cr[6].lt {
	pc = 0x8218BA10; continue 'dispatch;
	}
	// 8218B968: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B96C: C00B0070  lfs f0, 0x70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B970: C13F0044  lfs f9, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218B974: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8218B978: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B97C: C1AB0050  lfs f13, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B980: C18B0058  lfs f12, 0x58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218B984: 7D6A4C2E  lfsx f11, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B988: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8218B98C: C14927A8  lfs f10, 0x27a8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10152 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218B990: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B994: ED4A0028  fsubs f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218B998: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B99C: ED4A0272  fmuls f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[9].f64) as f32) as f64);
	// 8218B9A0: EC0A02FA  fmadds f0, f10, f11, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218B9A4: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218B9A8: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B9AC: ED6B6828  fsubs f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B9B0: C15F0048  lfs f10, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218B9B4: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B9B8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218B9BC: 612985D4  ori r9, r9, 0x85d4
	ctx.r[9].u64 = ctx.r[9].u64 | 34260;
	// 8218B9C0: ED6B02B2  fmuls f11, f11, f10
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 8218B9C4: EC0B683A  fmadds f0, f11, f0, f13
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218B9C8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218B9CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218B9D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218B9D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218B9D8: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218B9DC: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218B9E0: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218B9E4: C17F0048  lfs f11, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218B9E8: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218B9EC: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218B9F0: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218B9F4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218B9F8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218B9FC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218BA00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218BA04: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x8218BA08; continue 'dispatch;
            }
            0x8218BA08 => {
    //   block [0x8218BA08..0x8218BA10)
	// 8218BA08: 911E0230  stw r8, 0x230(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(560 as u32), ctx.r[8].u32 ) };
	// 8218BA0C: 939E0228  stw r28, 0x228(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(552 as u32), ctx.r[28].u32 ) };
	pc = 0x8218BA10; continue 'dispatch;
            }
            0x8218BA10 => {
    //   block [0x8218BA10..0x8218BAA8)
	// 8218BA10: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218BA14: 2F0B003C  cmpwi cr6, r11, 0x3c
	ctx.cr[6].compare_i32(ctx.r[11].s32, 60, &mut ctx.xer);
	// 8218BA18: 409A00B4  bne cr6, 0x8218bacc
	if !ctx.cr[6].eq {
	pc = 0x8218BACC; continue 'dispatch;
	}
	// 8218BA1C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218BA20: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218BA24: 4BFFE13D  bl 0x82189b60
	ctx.lr = 0x8218BA28;
	sub_82189B60(ctx, base);
	// 8218BA28: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BA2C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8218BA30: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218BA34: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8218BA38: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BA3C: 4E800421  bctrl
	ctx.lr = 0x8218BA40;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BA40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218BA44: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8218BA48: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8218BA4C: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 8218BA50: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218BA54: 917E02F0  stw r11, 0x2f0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 8218BA58: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BA5C: 939E029C  stw r28, 0x29c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), ctx.r[28].u32 ) };
	// 8218BA60: 917E02F4  stw r11, 0x2f4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 8218BA64: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BA68: 913D0078  stw r9, 0x78(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(120 as u32), ctx.r[9].u32 ) };
	// 8218BA6C: 80680028  lwz r3, 0x28(r8)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BA70: 481EC819  bl 0x82378288
	ctx.lr = 0x8218BA74;
	sub_82378288(ctx, base);
	// 8218BA74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BA78: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218BA7C: C00B2054  lfs f0, 0x2054(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BA80: 81630140  lwz r11, 0x140(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(320 as u32) ) } as u64;
	// 8218BA84: D01D0088  stfs f0, 0x88(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8218BA88: C18A1FF8  lfs f12, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218BA8C: 917D0068  stw r11, 0x68(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8218BA90: 81680028  lwz r11, 0x28(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BA94: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218BA98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BA9C: 409A000C  bne cr6, 0x8218baa8
	if !ctx.cr[6].eq {
	pc = 0x8218BAA8; continue 'dispatch;
	}
	// 8218BAA0: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 8218BAA4: 48000008  b 0x8218baac
	pc = 0x8218BAAC; continue 'dispatch;
            }
            0x8218BAA8 => {
    //   block [0x8218BAA8..0x8218BAAC)
	// 8218BAA8: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218BAAC; continue 'dispatch;
            }
            0x8218BAAC => {
    //   block [0x8218BAAC..0x8218BACC)
	// 8218BAAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218BAB0: D01D0074  stfs f0, 0x74(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8218BAB4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8218BAB8: D19D0014  stfs f12, 0x14(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218BABC: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BAC0: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218BAC4: 915D0084  stw r10, 0x84(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8218BAC8: D1BD0070  stfs f13, 0x70(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(112 as u32), tmp.u32 ) };
	pc = 0x8218BACC; continue 'dispatch;
            }
            0x8218BACC => {
    //   block [0x8218BACC..0x8218BAF0)
	// 8218BACC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BAD0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218BAD4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BAD8: C80A2008  lfd f0, 0x2008(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 8218BADC: 816B0254  lwz r11, 0x254(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218BAE0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BAE4: 419A000C  beq cr6, 0x8218baf0
	if ctx.cr[6].eq {
	pc = 0x8218BAF0; continue 'dispatch;
	}
	// 8218BAE8: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BAEC: D1AB009C  stfs f13, 0x9c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218BAF0; continue 'dispatch;
            }
            0x8218BAF0 => {
    //   block [0x8218BAF0..0x8218BB0C)
	// 8218BAF0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BAF4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BAF8: 816B0258  lwz r11, 0x258(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(600 as u32) ) } as u64;
	// 8218BAFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BB00: 419A000C  beq cr6, 0x8218bb0c
	if ctx.cr[6].eq {
	pc = 0x8218BB0C; continue 'dispatch;
	}
	// 8218BB04: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BB08: D1AB009C  stfs f13, 0x9c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218BB0C; continue 'dispatch;
            }
            0x8218BB0C => {
    //   block [0x8218BB0C..0x8218BB28)
	// 8218BB0C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BB10: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BB14: 816B0260  lwz r11, 0x260(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 8218BB18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BB1C: 419A000C  beq cr6, 0x8218bb28
	if ctx.cr[6].eq {
	pc = 0x8218BB28; continue 'dispatch;
	}
	// 8218BB20: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BB24: D1AB009C  stfs f13, 0x9c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218BB28; continue 'dispatch;
            }
            0x8218BB28 => {
    //   block [0x8218BB28..0x8218BB44)
	// 8218BB28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BB2C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BB30: 816B0264  lwz r11, 0x264(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8218BB34: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BB38: 419A000C  beq cr6, 0x8218bb44
	if ctx.cr[6].eq {
	pc = 0x8218BB44; continue 'dispatch;
	}
	// 8218BB3C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BB40: D1AB009C  stfs f13, 0x9c(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218BB44; continue 'dispatch;
            }
            0x8218BB44 => {
    //   block [0x8218BB44..0x8218BB60)
	// 8218BB44: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BB48: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218BB4C: 816B0268  lwz r11, 0x268(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(616 as u32) ) } as u64;
	// 8218BB50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218BB54: 419A000C  beq cr6, 0x8218bb60
	if ctx.cr[6].eq {
	pc = 0x8218BB60; continue 'dispatch;
	}
	// 8218BB58: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BB5C: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218BB60; continue 'dispatch;
            }
            0x8218BB60 => {
    //   block [0x8218BB60..0x8218BB68)
	// 8218BB60: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218BB64: 483A95A4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218BB68(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218BB68 size=108
    let mut pc: u32 = 0x8218BB68;
    'dispatch: loop {
        match pc {
            0x8218BB68 => {
    //   block [0x8218BB68..0x8218BBD4)
	// 8218BB68: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218BB6C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218BB70: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218BB74: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218BB78: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218BB7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BB80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218BB84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218BB88: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218BB8C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218BB90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BB94: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BB98: 4BFFE289  bl 0x82189e20
	ctx.lr = 0x8218BB9C;
	sub_82189E20(ctx, base);
	// 8218BB9C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8218BBA0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BBA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BBA8: 909F0020  stw r4, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[4].u32 ) };
	// 8218BBAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BBB0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218BBB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BBB8: 4E800421  bctrl
	ctx.lr = 0x8218BBBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BBBC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218BBC0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218BBC4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218BBC8: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218BBCC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218BBD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218BBD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218BBD8 size=664
    let mut pc: u32 = 0x8218BBD8;
    'dispatch: loop {
        match pc {
            0x8218BBD8 => {
    //   block [0x8218BBD8..0x8218BC20)
	// 8218BBD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218BBDC: 483A94E1  bl 0x825350bc
	ctx.lr = 0x8218BBE0;
	sub_82535080(ctx, base);
	// 8218BBE0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8218BBE4: 483AA3FD  bl 0x82535fe0
	ctx.lr = 0x8218BBE8;
	sub_82535FB0(ctx, base);
	// 8218BBE8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218BBEC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218BBF0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218BBF4: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8218BBF8: 614AEB33  ori r10, r10, 0xeb33
	ctx.r[10].u64 = ctx.r[10].u64 | 60211;
	// 8218BBFC: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8218BC00: 93BF00D4  stw r29, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 8218BC04: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BC08: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218BC0C: 419A0014  beq cr6, 0x8218bc20
	if ctx.cr[6].eq {
	pc = 0x8218BC20; continue 'dispatch;
	}
	// 8218BC10: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8218BC14: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 8218BC18: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BC1C: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	pc = 0x8218BC20; continue 'dispatch;
            }
            0x8218BC20 => {
    //   block [0x8218BC20..0x8218BC90)
	// 8218BC20: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8218BC24: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218BC28: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218BC2C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218BC30: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BC34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BC38: 4E800421  bctrl
	ctx.lr = 0x8218BC3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BC3C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218BC40: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8218BC44: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8218BC48: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8218BC4C: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 8218BC50: 61299BA0  ori r9, r9, 0x9ba0
	ctx.r[9].u64 = ctx.r[9].u64 | 39840;
	// 8218BC54: 61089BA8  ori r8, r8, 0x9ba8
	ctx.r[8].u64 = ctx.r[8].u64 | 39848;
	// 8218BC58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218BC5C: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BC60: 7F8B4C2E  lfsx f28, r11, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8218BC64: 7F6B442E  lfsx f27, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8218BC68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BC6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218BC70: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218BC74: 614A9410  ori r10, r10, 0x9410
	ctx.r[10].u64 = ctx.r[10].u64 | 37904;
	// 8218BC78: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8218BC7C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218BC80: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218BC84: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BC88: 409A0008  bne cr6, 0x8218bc90
	if !ctx.cr[6].eq {
	pc = 0x8218BC90; continue 'dispatch;
	}
	// 8218BC8C: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
            }
            0x8218BC90 => {
    //   block [0x8218BC90..0x8218BD3C)
	// 8218BC90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BC94: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8218BC98: D39F0070  stfs f28, 0x70(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218BC9C: D37F0078  stfs f27, 0x78(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218BCA0: C3AB2490  lfs f29, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8218BCA4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 8218BCA8: EFC00772  fmuls f30, f0, f29
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8218BCAC: C3EB2934  lfs f31, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218BCB0: D3FF0060  stfs f31, 0x60(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218BCB4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218BCB8: 4BFC7601  bl 0x821532b8
	ctx.lr = 0x8218BCBC;
	sub_821532B8(ctx, base);
	// 8218BCBC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218BCC0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218BCC4: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218BCC8: EC00E7FA  fmadds f0, f0, f31, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64);
	// 8218BCCC: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218BCD0: C1BE0034  lfs f13, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BCD4: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BCD8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 8218BCDC: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218BCE0: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BCE4: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218BCE8: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218BCEC: D01F0034  stfs f0, 0x34(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218BCF0: 4BF917D9  bl 0x8211d4c8
	ctx.lr = 0x8218BCF4;
	sub_8211D4C8(ctx, base);
	// 8218BCF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BCF8: C00B20C8  lfs f0, 0x20c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BCFC: D01F00A0  stfs f0, 0xa0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8218BD00: EC01DFFA  fmadds f0, f1, f31, f27
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64);
	// 8218BD04: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218BD08: 483A7509  bl 0x82533210
	ctx.lr = 0x8218BD0C;
	sub_82533210(ctx, base);
	// 8218BD0C: 546B047E  clrlwi r11, r3, 0x11
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x00007FFFu64;
	// 8218BD10: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218BD14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BD18: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218BD1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8218BD20: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218BD24: C00B206C  lfs f0, 0x206c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8300 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BD28: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218BD2C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 8218BD30: 4098000C  bge cr6, 0x8218bd3c
	if !ctx.cr[6].lt {
	pc = 0x8218BD3C; continue 'dispatch;
	}
	// 8218BD34: 93BF00D4  stw r29, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[29].u32 ) };
	// 8218BD38: 4800000C  b 0x8218bd44
	pc = 0x8218BD44; continue 'dispatch;
            }
            0x8218BD3C => {
    //   block [0x8218BD3C..0x8218BD44)
	// 8218BD3C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218BD40: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x8218BD44; continue 'dispatch;
            }
            0x8218BD44 => {
    //   block [0x8218BD44..0x8218BD8C)
	// 8218BD44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BD48: C1BF00AC  lfs f13, 0xac(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BD4C: 815F00D4  lwz r10, 0xd4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8218BD50: C3DF00A0  lfs f30, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218BD54: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218BD58: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BD5C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218BD60: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8218BD64: EFE00772  fmuls f31, f0, f29
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8218BD68: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BD6C: 409A0020  bne cr6, 0x8218bd8c
	if !ctx.cr[6].eq {
	pc = 0x8218BD8C; continue 'dispatch;
	}
	// 8218BD70: 4BFC7549  bl 0x821532b8
	ctx.lr = 0x8218BD74;
	sub_821532B8(ctx, base);
	// 8218BD74: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218BD78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BD7C: EFE007B2  fmuls f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BD80: 4BF91749  bl 0x8211d4c8
	ctx.lr = 0x8218BD84;
	sub_8211D4C8(ctx, base);
	// 8218BD84: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BD88: 48000024  b 0x8218bdac
	pc = 0x8218BDAC; continue 'dispatch;
            }
            0x8218BD8C => {
    //   block [0x8218BD8C..0x8218BDAC)
	// 8218BD8C: 4BFC752D  bl 0x821532b8
	ctx.lr = 0x8218BD90;
	sub_821532B8(ctx, base);
	// 8218BD90: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218BD94: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BD98: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BD9C: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218BDA0: 4BF91729  bl 0x8211d4c8
	ctx.lr = 0x8218BDA4;
	sub_8211D4C8(ctx, base);
	// 8218BDA4: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BDA8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x8218BDAC; continue 'dispatch;
            }
            0x8218BDAC => {
    //   block [0x8218BDAC..0x8218BE70)
	// 8218BDAC: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BDB0: 83BF0020  lwz r29, 0x20(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218BDB4: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218BDB8: EC2DF82A  fadds f1, f13, f31
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218BDBC: EC6C002A  fadds f3, f12, f0
	ctx.f[3].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218BDC0: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BDC4: C19F0078  lfs f12, 0x78(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218BDC8: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218BDCC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218BDD0: D1BF0070  stfs f13, 0x70(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218BDD4: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218BDD8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218BDDC: D03F0030  stfs f1, 0x30(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218BDE0: D07F0038  stfs f3, 0x38(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218BDE4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BDE8: C05F0034  lfs f2, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218BDEC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218BDF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BDF4: 4E800421  bctrl
	ctx.lr = 0x8218BDF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BDF8: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BDFC: C07E0038  lfs f3, 0x38(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8218BE00: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218BE04: C05E0034  lfs f2, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218BE08: C03E0030  lfs f1, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218BE0C: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218BE10: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BE14: 4E800421  bctrl
	ctx.lr = 0x8218BE18;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BE18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BE1C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BE20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BE24: D01F00A4  stfs f0, 0xa4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8218BE28: C1AB27A4  lfs f13, 0x27a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10148 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BE2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BE30: D1BF00A8  stfs f13, 0xa8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8218BE34: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BE38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BE3C: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8218BE40: C1AB2754  lfs f13, 0x2754(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BE44: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8218BE48: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BE4C: D01F00C0  stfs f0, 0xc0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8218BE50: C01E0034  lfs f0, 0x34(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BE54: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8218BE58: C01E0038  lfs f0, 0x38(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BE5C: D01F00C8  stfs f0, 0xc8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8218BE60: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8218BE64: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8218BE68: 483AA1C5  bl 0x8253602c
	ctx.lr = 0x8218BE6C;
	sub_82535FFC(ctx, base);
	// 8218BE6C: 483A92A0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218BE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218BE70 size=612
    let mut pc: u32 = 0x8218BE70;
    'dispatch: loop {
        match pc {
            0x8218BE70 => {
    //   block [0x8218BE70..0x8218BEA8)
	// 8218BE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218BE74: 483A9245  bl 0x825350b8
	ctx.lr = 0x8218BE78;
	sub_82535080(ctx, base);
	// 8218BE78: DBA1FFC0  stfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[29].u64 ) };
	// 8218BE7C: DBC1FFC8  stfd f30, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[30].u64 ) };
	// 8218BE80: DBE1FFD0  stfd f31, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8218BE84: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218BE88: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218BE8C: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218BE90: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218BE94: 409A0014  bne cr6, 0x8218bea8
	if !ctx.cr[6].eq {
	pc = 0x8218BEA8; continue 'dispatch;
	}
	// 8218BE98: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BE9C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BEA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BEA4: 4E800421  bctrl
	ctx.lr = 0x8218BEA8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218BEA8 => {
    //   block [0x8218BEA8..0x8218BF00)
	// 8218BEA8: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218BEAC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8218BEB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218BEB4: 419A020C  beq cr6, 0x8218c0c0
	if ctx.cr[6].eq {
	pc = 0x8218C0C0; continue 'dispatch;
	}
	// 8218BEB8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218BEBC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218BEC0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218BEC4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218BEC8: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218BECC: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218BED0: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218BED4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BED8: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8218BEDC: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218BEE0: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8218BEE4: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218BEE8: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218BEEC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218BEF0: 409A0010  bne cr6, 0x8218bf00
	if !ctx.cr[6].eq {
	pc = 0x8218BF00; continue 'dispatch;
	}
	// 8218BEF4: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218BEF8: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8218BEFC: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x8218BF00; continue 'dispatch;
            }
            0x8218BF00 => {
    //   block [0x8218BF00..0x8218BF50)
	// 8218BF00: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218BF04: 817F00D0  lwz r11, 0xd0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8218BF08: 614AEB33  ori r10, r10, 0xeb33
	ctx.r[10].u64 = ctx.r[10].u64 | 60211;
	// 8218BF0C: 7D4B50AE  lbzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BF10: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218BF14: 419A003C  beq cr6, 0x8218bf50
	if ctx.cr[6].eq {
	pc = 0x8218BF50; continue 'dispatch;
	}
	// 8218BF18: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8218BF1C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218BF20: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218BF24: 614AA9C0  ori r10, r10, 0xa9c0
	ctx.r[10].u64 = ctx.r[10].u64 | 43456;
	// 8218BF28: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218BF2C: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BF30: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 8218BF34: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218BF38: 4E800421  bctrl
	ctx.lr = 0x8218BF3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BF3C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218BF40: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8218BF44: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8218BF48: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218BF4C: 483A91BC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8218BF50 => {
    //   block [0x8218BF50..0x8218BF78)
	// 8218BF50: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218BF54: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218BF58: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218BF5C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218BF60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218BF64: 4E800421  bctrl
	ctx.lr = 0x8218BF68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218BF68: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8218BF6C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8218BF70: 409A0008  bne cr6, 0x8218bf78
	if !ctx.cr[6].eq {
	pc = 0x8218BF78; continue 'dispatch;
	}
	// 8218BF74: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
            }
            0x8218BF78 => {
    //   block [0x8218BF78..0x8218BFFC)
	// 8218BF78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218BF7C: C19F00AC  lfs f12, 0xac(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(172 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218BF80: C01F0060  lfs f0, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BF84: C1BF00A8  lfs f13, 0xa8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BF88: EFC06828  fsubs f30, f0, f13
	ctx.f[30].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218BF8C: D3DF0060  stfs f30, 0x60(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218BF90: C3EB2490  lfs f31, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218BF94: EFAC07F2  fmuls f29, f12, f31
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[31].f64) as f32) as f64);
	// 8218BF98: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8218BF9C: 4BFC731D  bl 0x821532b8
	ctx.lr = 0x8218BFA0;
	sub_821532B8(ctx, base);
	// 8218BFA0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218BFA4: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218BFA8: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8218BFAC: EC006FBA  fmadds f0, f0, f30, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218BFB0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218BFB4: 4BF91515  bl 0x8211d4c8
	ctx.lr = 0x8218BFB8;
	sub_8211D4C8(ctx, base);
	// 8218BFB8: C01F0078  lfs f0, 0x78(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BFBC: EC0107BA  fmadds f0, f1, f30, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218BFC0: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218BFC4: C01F00B0  lfs f0, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218BFC8: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8218BFCC: EFE007F2  fmuls f31, f0, f31
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8218BFD0: C3DF00A0  lfs f30, 0xa0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218BFD4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218BFD8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BFDC: 409A0020  bne cr6, 0x8218bffc
	if !ctx.cr[6].eq {
	pc = 0x8218BFFC; continue 'dispatch;
	}
	// 8218BFE0: 4BFC72D9  bl 0x821532b8
	ctx.lr = 0x8218BFE4;
	sub_821532B8(ctx, base);
	// 8218BFE4: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218BFE8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218BFEC: EFE007B2  fmuls f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BFF0: 4BF914D9  bl 0x8211d4c8
	ctx.lr = 0x8218BFF4;
	sub_8211D4C8(ctx, base);
	// 8218BFF4: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218BFF8: 48000024  b 0x8218c01c
	pc = 0x8218C01C; continue 'dispatch;
            }
            0x8218BFFC => {
    //   block [0x8218BFFC..0x8218C01C)
	// 8218BFFC: 4BFC72BD  bl 0x821532b8
	ctx.lr = 0x8218C000;
	sub_821532B8(ctx, base);
	// 8218C000: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8218C004: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C008: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218C00C: FFE00050  fneg f31, f0
	ctx.f[31].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C010: 4BF914B9  bl 0x8211d4c8
	ctx.lr = 0x8218C014;
	sub_8211D4C8(ctx, base);
	// 8218C014: EC0107B2  fmuls f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218C018: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	pc = 0x8218C01C; continue 'dispatch;
            }
            0x8218C01C => {
    //   block [0x8218C01C..0x8218C0A0)
	// 8218C01C: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C020: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C024: C19F0038  lfs f12, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C028: EDADF82A  fadds f13, f13, f31
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218C02C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218C030: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218C034: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218C038: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8218C03C: 409A0064  bne cr6, 0x8218c0a0
	if !ctx.cr[6].eq {
	pc = 0x8218C0A0; continue 'dispatch;
	}
	// 8218C040: C15D0030  lfs f10, 0x30(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218C044: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C048: C1BF00C0  lfs f13, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C04C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218C050: ED4A6828  fsubs f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218C054: C19F00C4  lfs f12, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C058: C17F00C8  lfs f11, 0xc8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218C05C: C00B27A0  lfs f0, 0x27a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C060: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218C064: D1BF00C0  stfs f13, 0xc0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8218C068: C1BD0034  lfs f13, 0x34(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C06C: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218C070: C03F00C0  lfs f1, 0xc0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218C074: EDAD603A  fmadds f13, f13, f0, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218C078: D1BF00C4  stfs f13, 0xc4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8218C07C: C1BD0038  lfs f13, 0x38(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C080: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218C084: C05F00C4  lfs f2, 0xc4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(196 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218C088: EC6D583A  fmadds f3, f13, f0, f11
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218C08C: D07F00C8  stfs f3, 0xc8(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8218C090: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C094: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218C098: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C09C: 4E800421  bctrl
	ctx.lr = 0x8218C0A0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218C0A0 => {
    //   block [0x8218C0A0..0x8218C0C0)
	// 8218C0A0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C0A4: C07F0038  lfs f3, 0x38(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8218C0A8: C05F0034  lfs f2, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218C0AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218C0B0: C03F0030  lfs f1, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218C0B4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C0B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C0BC: 4E800421  bctrl
	ctx.lr = 0x8218C0C0;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218C0C0 => {
    //   block [0x8218C0C0..0x8218C0D4)
	// 8218C0C0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218C0C4: CBA1FFC0  lfd f29, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8218C0C8: CBC1FFC8  lfd f30, -0x38(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8218C0CC: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218C0D0: 483A9038  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C0D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C0D8 size=144
    let mut pc: u32 = 0x8218C0D8;
    'dispatch: loop {
        match pc {
            0x8218C0D8 => {
    //   block [0x8218C0D8..0x8218C168)
	// 8218C0D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C0DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218C0E0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218C0E4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218C0E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C0EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C0F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218C0F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218C0F8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C0FC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218C100: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C104: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C108: 4BFD9999  bl 0x82165aa0
	ctx.lr = 0x8218C10C;
	sub_82165AA0(ctx, base);
	// 8218C10C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218C110: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218C114: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218C118: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C11C: 91430148  stw r10, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 8218C120: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C124: C00BD4D4  lfs f0, -0x2b2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C128: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8218C12C: D00A0078  stfs f0, 0x78(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218C130: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C134: 916A0074  stw r11, 0x74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218C138: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C13C: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C140: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C144: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218C148: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C14C: 4E800421  bctrl
	ctx.lr = 0x8218C150;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C150: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218C154: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218C158: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218C15C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218C160: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218C164: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C168(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C168 size=300
    let mut pc: u32 = 0x8218C168;
    'dispatch: loop {
        match pc {
            0x8218C168 => {
    //   block [0x8218C168..0x8218C1D8)
	// 8218C168: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C16C: 483A8F49  bl 0x825350b4
	ctx.lr = 0x8218C170;
	sub_82535080(ctx, base);
	// 8218C170: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8218C174: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8218C178: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C17C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218C180: 83BF0028  lwz r29, 0x28(r31)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218C184: 83DF0024  lwz r30, 0x24(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218C188: 3B7D0030  addi r27, r29, 0x30
	ctx.r[27].s64 = ctx.r[29].s64 + 48;
	// 8218C18C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218C190: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C194: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C198: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C19C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C1A0: 4E800421  bctrl
	ctx.lr = 0x8218C1A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C1A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218C1A8: C01E002C  lfs f0, 0x2c(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C1AC: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8218C1B0: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 8218C1B4: C3FE0024  lfs f31, 0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C1B8: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218C1BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218C1C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C1C4: C1AB2414  lfs f13, 0x2414(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9236 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C1C8: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218C1CC: FFCC682E  fsel f30, f12, f0, f13
	ctx.f[30].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218C1D0: 419A0008  beq cr6, 0x8218c1d8
	if ctx.cr[6].eq {
	pc = 0x8218C1D8; continue 'dispatch;
	}
	// 8218C1D4: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
            }
            0x8218C1D8 => {
    //   block [0x8218C1D8..0x8218C27C)
	// 8218C1D8: 83FF0020  lwz r31, 0x20(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C1DC: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C1E0: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218C1E4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218C1E8: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218C1EC: C01C0030  lfs f0, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C1F0: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218C1F4: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C1F8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C1FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C200: 4E800421  bctrl
	ctx.lr = 0x8218C204;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C204: C1A30034  lfs f13, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C208: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C20C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218C210: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C214: C19E001C  lfs f12, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C218: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 8218C21C: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8218C220: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8218C224: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218C228: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C22C: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218C230: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C234: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218C238: EDA0F82A  fadds f13, f0, f31
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218C23C: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C240: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C244: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218C248: FD806E5E  fctidz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218C24C: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218C250: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218C254: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218C258: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218C25C: FD806E5E  fctidz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218C260: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218C264: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218C268: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218C26C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C270: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8218C274: 40990008  ble cr6, 0x8218c27c
	if !ctx.cr[6].gt {
	pc = 0x8218C27C; continue 'dispatch;
	}
	// 8218C278: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
            }
            0x8218C27C => {
    //   block [0x8218C27C..0x8218C294)
	// 8218C27C: D1BF0054  stfs f13, 0x54(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218C280: D3DF0050  stfs f30, 0x50(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218C284: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218C288: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8218C28C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8218C290: 483A8E74  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C298(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C298 size=780
    let mut pc: u32 = 0x8218C298;
    'dispatch: loop {
        match pc {
            0x8218C298 => {
    //   block [0x8218C298..0x8218C2CC)
	// 8218C298: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C29C: 483A8E19  bl 0x825350b4
	ctx.lr = 0x8218C2A0;
	sub_82535080(ctx, base);
	// 8218C2A0: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 8218C2A4: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8218C2A8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C2AC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218C2B0: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218C2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C2B8: 409A0014  bne cr6, 0x8218c2cc
	if !ctx.cr[6].eq {
	pc = 0x8218C2CC; continue 'dispatch;
	}
	// 8218C2BC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C2C0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C2C4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C2C8: 4E800421  bctrl
	ctx.lr = 0x8218C2CC;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218C2CC => {
    //   block [0x8218C2CC..0x8218C320)
	// 8218C2CC: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218C2D0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C2D4: 419A02C0  beq cr6, 0x8218c594
	if ctx.cr[6].eq {
	pc = 0x8218C594; continue 'dispatch;
	}
	// 8218C2D8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218C2DC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218C2E0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218C2E4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218C2E8: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218C2EC: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218C2F0: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218C2F4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218C2F8: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8218C2FC: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218C300: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8218C304: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218C308: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218C30C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C310: 409A0010  bne cr6, 0x8218c320
	if !ctx.cr[6].eq {
	pc = 0x8218C320; continue 'dispatch;
	}
	// 8218C314: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218C318: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8218C31C: 917E0010  stw r11, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	pc = 0x8218C320; continue 'dispatch;
            }
            0x8218C320 => {
    //   block [0x8218C320..0x8218C3C4)
	// 8218C320: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218C324: 83FE0020  lwz r31, 0x20(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C328: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8218C32C: C00BD4D4  lfs f0, -0x2b2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C330: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218C334: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8218C338: 83BE0028  lwz r29, 0x28(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218C33C: 83DE0024  lwz r30, 0x24(r30)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218C340: 3B7D0030  addi r27, r29, 0x30
	ctx.r[27].s64 = ctx.r[29].s64 + 48;
	// 8218C344: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218C348: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C34C: 809E0000  lwz r4, 0(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C350: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C354: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C358: 4E800421  bctrl
	ctx.lr = 0x8218C35C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C35C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C360: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 8218C364: C3FE0028  lfs f31, 0x28(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C368: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218C36C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218C370: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C374: C3DC0030  lfs f30, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218C378: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C37C: 4E800421  bctrl
	ctx.lr = 0x8218C380;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C380: C1A30034  lfs f13, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C384: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C388: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218C38C: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C390: C19E0020  lfs f12, 0x20(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C394: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 8218C398: C0DC0038  lfs f6, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8218C39C: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218C3A0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218C3A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C3A8: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8218C3AC: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 8218C3B0: C18B2068  lfs f12, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C3B4: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C3B8: FCAD602E  fsel f5, f13, f0, f12
	ctx.f[5].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8218C3BC: 419A0008  beq cr6, 0x8218c3c4
	if ctx.cr[6].eq {
	pc = 0x8218C3C4; continue 'dispatch;
	}
	// 8218C3C0: FFE0F850  fneg f31, f31
	ctx.f[31].u64 = ctx.f[31].u64 ^ 0x8000_0000_0000_0000u64;
            }
            0x8218C3C4 => {
    //   block [0x8218C3C4..0x8218C43C)
	// 8218C3C4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218C3C8: C11F0054  lfs f8, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8218C3CC: C17E000C  lfs f11, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218C3D0: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 8218C3D4: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C3D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C3DC: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218C3E0: ED404028  fsubs f10, f0, f8
	ctx.f[10].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 8218C3E4: C00B209C  lfs f0, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C3E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218C3EC: ED2B0032  fmuls f9, f11, f0
	ctx.f[9].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218C3F0: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C3F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C3F8: EC0A682A  fadds f0, f10, f13
	ctx.f[0].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218C3FC: C0EB22A4  lfs f7, 0x22a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8218C400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C404: ED4901F2  fmuls f10, f9, f7
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[7].f64) as f32) as f64);
	// 8218C408: FD20065E  fctidz f9, f0
	ctx.f[9].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C40C: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8218C410: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8218C414: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 8218C418: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218C41C: FD20065E  fctidz f9, f0
	ctx.f[9].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C420: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8218C424: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8218C428: EC004828  fsubs f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 8218C42C: C12BBFFC  lfs f9, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218C430: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 8218C434: 40990008  ble cr6, 0x8218c43c
	if !ctx.cr[6].gt {
	pc = 0x8218C43C; continue 'dispatch;
	}
	// 8218C438: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8218C43C; continue 'dispatch;
            }
            0x8218C43C => {
    //   block [0x8218C43C..0x8218C478)
	// 8218C43C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8218C440: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C444: ED6C5028  fsubs f11, f12, f10
	ctx.f[11].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 8218C448: FD8B532E  fsel f12, f11, f12, f10
	ctx.f[12].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[10].f64 };
	// 8218C44C: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218C450: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C454: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8218C458: C14B2250  lfs f10, 0x2250(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8784 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218C45C: 4098001C  bge cr6, 0x8218c478
	if !ctx.cr[6].lt {
	pc = 0x8218C478; continue 'dispatch;
	}
	// 8218C460: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C464: EC8C0028  fsubs f4, f12, f0
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C468: FC04032E  fsel f0, f4, f12, f0
	ctx.f[0].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 8218C46C: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C470: FC0C502E  fsel f0, f12, f0, f10
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 8218C474: 48000014  b 0x8218c488
	pc = 0x8218C488; continue 'dispatch;
            }
            0x8218C478 => {
    //   block [0x8218C478..0x8218C488)
	// 8218C478: EC8C0028  fsubs f4, f12, f0
	ctx.f[4].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C47C: FC04602E  fsel f0, f4, f0, f12
	ctx.f[0].f64 = if ctx.f[4].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8218C480: FD800050  fneg f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C484: FC0C02EE  fsel f0, f12, f11, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	pc = 0x8218C488; continue 'dispatch;
            }
            0x8218C488 => {
    //   block [0x8218C488..0x8218C4E0)
	// 8218C488: EC08002A  fadds f0, f8, f0
	ctx.f[0].f64 = ((ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218C48C: C19F0050  lfs f12, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C490: FD00065E  fctidz f8, f0
	ctx.f[8].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C494: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8218C498: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8218C49C: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 8218C4A0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218C4A4: C01E0030  lfs f0, 0x30(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C4A8: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218C4AC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218C4B0: FD00065E  fctidz f8, f0
	ctx.f[8].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C4B4: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8218C4B8: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8218C4BC: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 8218C4C0: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218C4C4: FD00065E  fctidz f8, f0
	ctx.f[8].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C4C8: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8218C4CC: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8218C4D0: EC004028  fsubs f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[8].f64) as f32) as f64);
	// 8218C4D4: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 8218C4D8: 40990008  ble cr6, 0x8218c4e0
	if !ctx.cr[6].gt {
	pc = 0x8218C4E0; continue 'dispatch;
	}
	// 8218C4DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8218C4E0; continue 'dispatch;
            }
            0x8218C4E0 => {
    //   block [0x8218C4E0..0x8218C50C)
	// 8218C4E0: C1BE0010  lfs f13, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C4E4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218C4E8: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8218C4EC: 40980020  bge cr6, 0x8218c50c
	if !ctx.cr[6].lt {
	pc = 0x8218C50C; continue 'dispatch;
	}
	// 8218C4F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C4F4: C1AB2410  lfs f13, 0x2410(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9232 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C4F8: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C4FC: FC0B036E  fsel f0, f11, f13, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8218C500: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C504: FC0D502E  fsel f0, f13, f0, f10
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[10].f64 };
	// 8218C508: 48000014  b 0x8218c51c
	pc = 0x8218C51C; continue 'dispatch;
            }
            0x8218C50C => {
    //   block [0x8218C50C..0x8218C51C)
	// 8218C50C: EDA70028  fsubs f13, f7, f0
	ctx.f[13].f64 = (((ctx.f[7].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C510: FC0D382E  fsel f0, f13, f0, f7
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[7].f64 };
	// 8218C514: FDA00050  fneg f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218C518: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	pc = 0x8218C51C; continue 'dispatch;
            }
            0x8218C51C => {
    //   block [0x8218C51C..0x8218C594)
	// 8218C51C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218C520: C17F0064  lfs f11, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218C524: ECE55828  fsubs f7, f5, f11
	ctx.f[7].f64 = (((ctx.f[5].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218C528: C1BF0070  lfs f13, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C52C: C19F0060  lfs f12, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C530: ED1E6028  fsubs f8, f30, f12
	ctx.f[8].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218C534: C15F0068  lfs f10, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218C538: ECC65028  fsubs f6, f6, f10
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[10].f64) as f32) as f64);
	// 8218C53C: FCA0065E  fctidz f5, f0
	ctx.f[5].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C540: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 8218C544: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 8218C548: EC002828  fsubs f0, f0, f5
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[5].f64) as f32) as f64);
	// 8218C54C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218C550: C01E0018  lfs f0, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C554: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218C558: C0BE0008  lfs f5, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8218C55C: EC00697A  fmadds f0, f0, f5, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218C560: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218C564: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C568: EC08603A  fmadds f0, f8, f0, f12
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218C56C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218C570: C01E0004  lfs f0, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C574: EC07583A  fmadds f0, f7, f0, f11
	ctx.f[0].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218C578: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218C57C: C1BE0004  lfs f13, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C580: EDA6537A  fmadds f13, f6, f13, f10
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 8218C584: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218C588: EDA04828  fsubs f13, f0, f9
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[9].f64) as f32) as f64);
	// 8218C58C: FC0D482E  fsel f0, f13, f0, f9
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 8218C590: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x8218C594; continue 'dispatch;
            }
            0x8218C594 => {
    //   block [0x8218C594..0x8218C5A4)
	// 8218C594: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218C598: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8218C59C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8218C5A0: 483A8B64  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C5A8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218C5A8 size=12
    let mut pc: u32 = 0x8218C5A8;
    'dispatch: loop {
        match pc {
            0x8218C5A8 => {
    //   block [0x8218C5A8..0x8218C5B4)
	// 8218C5A8: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218C5AC: 386B0094  addi r3, r11, 0x94
	ctx.r[3].s64 = ctx.r[11].s64 + 148;
	// 8218C5B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C5B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C5B8 size=188
    let mut pc: u32 = 0x8218C5B8;
    'dispatch: loop {
        match pc {
            0x8218C5B8 => {
    //   block [0x8218C5B8..0x8218C60C)
	// 8218C5B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C5BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218C5C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218C5C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218C5C8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218C5CC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C5D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218C5D4: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218C5D8: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C5DC: 4BFFDA0D  bl 0x82189fe8
	ctx.lr = 0x8218C5E0;
	sub_82189FE8(ctx, base);
	// 8218C5E0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C5E4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218C5E8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218C5EC: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C5F0: 409A001C  bne cr6, 0x8218c60c
	if !ctx.cr[6].eq {
	pc = 0x8218C60C; continue 'dispatch;
	}
	// 8218C5F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218C5F8: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218C5FC: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C600: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C604: 4BFFD8CD  bl 0x82189ed0
	ctx.lr = 0x8218C608;
	sub_82189ED0(ctx, base);
	// 8218C608: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	pc = 0x8218C60C; continue 'dispatch;
            }
            0x8218C60C => {
    //   block [0x8218C60C..0x8218C674)
	// 8218C60C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218C610: D3FF01C8  stfs f31, 0x1c8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 8218C614: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218C618: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218C61C: D3FF0138  stfs f31, 0x138(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 8218C620: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C624: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218C628: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218C62C: 917F01C0  stw r11, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[11].u32 ) };
	// 8218C630: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218C634: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218C638: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218C63C: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218C640: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C644: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C648: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218C64C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C650: 4E800421  bctrl
	ctx.lr = 0x8218C654;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C654: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218C658: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218C65C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218C660: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218C664: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218C668: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218C66C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218C670: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C678(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218C678 size=76
    let mut pc: u32 = 0x8218C678;
    'dispatch: loop {
        match pc {
            0x8218C678 => {
    //   block [0x8218C678..0x8218C6C4)
	// 8218C678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C67C: 39400009  li r10, 9
	ctx.r[10].s64 = 9;
	// 8218C680: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8218C684: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C688: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218C68C: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218C690: 91430060  stw r10, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218C694: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218C698: 9123006C  stw r9, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[9].u32 ) };
	// 8218C69C: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218C6A0: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218C6A4: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218C6A8: 91630078  stw r11, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	// 8218C6AC: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218C6B0: 91630074  stw r11, 0x74(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218C6B4: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218C6B8: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218C6BC: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218C6C0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C6C8 size=164
    let mut pc: u32 = 0x8218C6C8;
    'dispatch: loop {
        match pc {
            0x8218C6C8 => {
    //   block [0x8218C6C8..0x8218C754)
	// 8218C6C8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C6CC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218C6D0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218C6D4: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218C6D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C6DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C6E0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218C6E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218C6E8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C6EC: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218C6F0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C6F4: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C6F8: 4BFD93A9  bl 0x82165aa0
	ctx.lr = 0x8218C6FC;
	sub_82165AA0(ctx, base);
	// 8218C6FC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218C700: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218C704: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C708: 91630148  stw r11, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 8218C70C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C710: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C714: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C718: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218C71C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C720: 4E800421  bctrl
	ctx.lr = 0x8218C724;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218C728: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C72C: 4BFAC7DD  bl 0x82138f08
	ctx.lr = 0x8218C730;
	sub_82138F08(ctx, base);
	// 8218C730: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218C734: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8218C738: 409A001C  bne cr6, 0x8218c754
	if !ctx.cr[6].eq {
	pc = 0x8218C754; continue 'dispatch;
	}
	// 8218C73C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218C740: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C744: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218C748: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218C74C: 48007025  bl 0x82193770
	ctx.lr = 0x8218C750;
	sub_82193770(ctx, base);
	// 8218C750: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
            }
            0x8218C754 => {
    //   block [0x8218C754..0x8218C76C)
	// 8218C754: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218C758: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218C75C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218C760: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218C764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218C768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C770 size=176
    let mut pc: u32 = 0x8218C770;
    'dispatch: loop {
        match pc {
            0x8218C770 => {
    //   block [0x8218C770..0x8218C7FC)
	// 8218C770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C774: 483A8941  bl 0x825350b4
	ctx.lr = 0x8218C778;
	sub_82535080(ctx, base);
	// 8218C778: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C77C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218C780: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8218C784: 616BEB32  ori r11, r11, 0xeb32
	ctx.r[11].u64 = ctx.r[11].u64 | 60210;
	// 8218C788: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8218C78C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 8218C790: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218C794: 83DD0020  lwz r30, 0x20(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C798: 83FD0024  lwz r31, 0x24(r29)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218C79C: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8218C7A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218C7A4: C01F0050  lfs f0, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C7A8: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C7AC: C03F0060  lfs f1, 0x60(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218C7B0: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218C7B4: C05F0064  lfs f2, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218C7B8: C07F0068  lfs f3, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8218C7BC: 7F8A48AE  lbzx r28, r10, r9
	ctx.r[28].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218C7C0: 7F6B40AE  lbzx r27, r11, r8
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8218C7C4: D01E0050  stfs f0, 0x50(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218C7C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C7CC: C01F0054  lfs f0, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C7D0: D01E0054  stfs f0, 0x54(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218C7D4: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218C7D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C7DC: 4E800421  bctrl
	ctx.lr = 0x8218C7E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C7E0: 2F1C0000  cmpwi cr6, r28, 0
	ctx.cr[6].compare_i32(ctx.r[28].s32, 0, &mut ctx.xer);
	// 8218C7E4: 409A0018  bne cr6, 0x8218c7fc
	if !ctx.cr[6].eq {
	pc = 0x8218C7FC; continue 'dispatch;
	}
	// 8218C7E8: 2F1B0000  cmpwi cr6, r27, 0
	ctx.cr[6].compare_i32(ctx.r[27].s32, 0, &mut ctx.xer);
	// 8218C7EC: 409A0010  bne cr6, 0x8218c7fc
	if !ctx.cr[6].eq {
	pc = 0x8218C7FC; continue 'dispatch;
	}
	// 8218C7F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C7F4: C00B20AC  lfs f0, 0x20ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C7F8: 4800000C  b 0x8218c804
	pc = 0x8218C804; continue 'dispatch;
            }
            0x8218C7FC => {
    //   block [0x8218C7FC..0x8218C804)
	// 8218C7FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C800: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218C804; continue 'dispatch;
            }
            0x8218C804 => {
    //   block [0x8218C804..0x8218C820)
	// 8218C804: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218C808: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218C80C: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C810: D01E0070  stfs f0, 0x70(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218C814: 917D001C  stw r11, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218C818: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218C81C: 483A88E8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C820(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C820 size=172
    let mut pc: u32 = 0x8218C820;
    'dispatch: loop {
        match pc {
            0x8218C820 => {
    //   block [0x8218C820..0x8218C854)
	// 8218C820: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C824: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218C828: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218C82C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218C830: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C834: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218C838: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218C83C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C840: 409A0014  bne cr6, 0x8218c854
	if !ctx.cr[6].eq {
	pc = 0x8218C854; continue 'dispatch;
	}
	// 8218C844: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C848: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C84C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C850: 4E800421  bctrl
	ctx.lr = 0x8218C854;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218C854 => {
    //   block [0x8218C854..0x8218C8B4)
	// 8218C854: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218C858: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C85C: 419A0058  beq cr6, 0x8218c8b4
	if ctx.cr[6].eq {
	pc = 0x8218C8B4; continue 'dispatch;
	}
	// 8218C860: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218C864: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C868: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8218C86C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218C870: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218C874: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C878: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8218C87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C880: 4E800421  bctrl
	ctx.lr = 0x8218C884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C884: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218C888: C00BD5B0  lfs f0, -0x2a50(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C88C: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8218C890: 40980024  bge cr6, 0x8218c8b4
	if !ctx.cr[6].lt {
	pc = 0x8218C8B4; continue 'dispatch;
	}
	// 8218C894: C1BE0050  lfs f13, 0x50(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C898: C01F0030  lfs f0, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C89C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218C8A0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218C8A4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218C8A8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218C8AC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218C8B0: D01E0050  stfs f0, 0x50(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
            }
            0x8218C8B4 => {
    //   block [0x8218C8B4..0x8218C8CC)
	// 8218C8B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218C8B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218C8BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218C8C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218C8C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218C8C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C8D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C8D0 size=208
    let mut pc: u32 = 0x8218C8D0;
    'dispatch: loop {
        match pc {
            0x8218C8D0 => {
    //   block [0x8218C8D0..0x8218C990)
	// 8218C8D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C8D4: 483A87E9  bl 0x825350bc
	ctx.lr = 0x8218C8D8;
	sub_82535080(ctx, base);
	// 8218C8D8: DBC1FFD0  stfd f30, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8218C8DC: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8218C8E0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C8E4: 83E30024  lwz r31, 0x24(r3)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218C8E8: 83C30020  lwz r30, 0x20(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218C8EC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8218C8F0: 419A00A0  beq cr6, 0x8218c990
	if ctx.cr[6].eq {
	pc = 0x8218C990; continue 'dispatch;
	}
	// 8218C8F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C8F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218C8FC: 3BBF0030  addi r29, r31, 0x30
	ctx.r[29].s64 = ctx.r[31].s64 + 48;
	// 8218C900: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218C904: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C908: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218C90C: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8218C910: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C914: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218C918: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C91C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C920: 4E800421  bctrl
	ctx.lr = 0x8218C924;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C924: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C928: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8218C92C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218C930: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218C934: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C938: C3CA0030  lfs f30, 0x30(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218C93C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C940: 4E800421  bctrl
	ctx.lr = 0x8218C944;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C944: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218C948: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218C94C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218C950: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218C954: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C958: C3EB0034  lfs f31, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218C95C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218C960: 4E800421  bctrl
	ctx.lr = 0x8218C964;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218C964: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218C968: C1830038  lfs f12, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218C96C: D3DE0060  stfs f30, 0x60(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218C970: D19E0068  stfs f12, 0x68(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218C974: C00BD468  lfs f0, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218C978: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218C97C: ED7F0028  fsubs f11, f31, f0
	ctx.f[11].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218C980: C1AB2070  lfs f13, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218C984: D1BE0070  stfs f13, 0x70(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218C988: FC0B07EE  fsel f0, f11, f31, f0
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 8218C98C: D01E0064  stfs f0, 0x64(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), tmp.u32 ) };
            }
            0x8218C990 => {
    //   block [0x8218C990..0x8218C9A0)
	// 8218C990: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218C994: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218C998: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218C99C: 483A8770  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218C9A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218C9A0 size=588
    let mut pc: u32 = 0x8218C9A0;
    'dispatch: loop {
        match pc {
            0x8218C9A0 => {
    //   block [0x8218C9A0..0x8218C9D8)
	// 8218C9A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218C9A4: 483A8719  bl 0x825350bc
	ctx.lr = 0x8218C9A8;
	sub_82535080(ctx, base);
	// 8218C9A8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 8218C9AC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 8218C9B0: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8218C9B4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218C9B8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218C9BC: 817E0010  lwz r11, 0x10(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218C9C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C9C4: 409A0014  bne cr6, 0x8218c9d8
	if !ctx.cr[6].eq {
	pc = 0x8218C9D8; continue 'dispatch;
	}
	// 8218C9C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218C9CC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218C9D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218C9D4: 4E800421  bctrl
	ctx.lr = 0x8218C9D8;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8218C9D8 => {
    //   block [0x8218C9D8..0x8218CA50)
	// 8218C9D8: 817E001C  lwz r11, 0x1c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218C9DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218C9E0: 419A01F8  beq cr6, 0x8218cbd8
	if ctx.cr[6].eq {
	pc = 0x8218CBD8; continue 'dispatch;
	}
	// 8218C9E4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218C9E8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218C9EC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218C9F0: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218C9F4: 7D0B502E  lwzx r8, r11, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218C9F8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218C9FC: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218CA00: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218CA04: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218CA08: 614A860C  ori r10, r10, 0x860c
	ctx.r[10].u64 = ctx.r[10].u64 | 34316;
	// 8218CA0C: 7D074B78  or r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8218CA10: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218CA14: 7CE75378  or r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[10].u64;
	// 8218CA18: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8218CA1C: 409A0034  bne cr6, 0x8218ca50
	if !ctx.cr[6].eq {
	pc = 0x8218CA50; continue 'dispatch;
	}
	// 8218CA20: 815E0010  lwz r10, 0x10(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218CA24: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218CA28: 3D000003  lis r8, 3
	ctx.r[8].s64 = 196608;
	// 8218CA2C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8218CA30: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218CA34: 61088600  ori r8, r8, 0x8600
	ctx.r[8].u64 = ctx.r[8].u64 | 34304;
	// 8218CA38: 915E0010  stw r10, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8218CA3C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218CA40: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218CA44: 614A860C  ori r10, r10, 0x860c
	ctx.r[10].u64 = ctx.r[10].u64 | 34316;
	// 8218CA48: 7D0B402E  lwzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8218CA4C: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	pc = 0x8218CA50; continue 'dispatch;
            }
            0x8218CA50 => {
    //   block [0x8218CA50..0x8218CA84)
	// 8218CA50: 83BE0024  lwz r29, 0x24(r30)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218CA54: 83FE0020  lwz r31, 0x20(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218CA58: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8218CA5C: 419A017C  beq cr6, 0x8218cbd8
	if ctx.cr[6].eq {
	pc = 0x8218CBD8; continue 'dispatch;
	}
	// 8218CA60: 7D0B4B78  or r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8218CA64: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218CA68: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218CA6C: 409A0018  bne cr6, 0x8218ca84
	if !ctx.cr[6].eq {
	pc = 0x8218CA84; continue 'dispatch;
	}
	// 8218CA70: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218CA74: C1BE0014  lfs f13, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CA78: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CA7C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218CA80: D01E0014  stfs f0, 0x14(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x8218CA84; continue 'dispatch;
            }
            0x8218CA84 => {
    //   block [0x8218CA84..0x8218CAF4)
	// 8218CA84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CA88: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CA8C: C1AB2298  lfs f13, 0x2298(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8856 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CA90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CA94: C00B2698  lfs f0, 0x2698(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9880 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CA98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CA9C: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218CAA0: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218CAA4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218CAA8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218CAAC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218CAB0: C18B279C  lfs f12, 0x279c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10140 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CAB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CAB8: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218CABC: C01E0014  lfs f0, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CAC0: EC200332  fmuls f1, f0, f12
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8218CAC4: C18B20B0  lfs f12, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CAC8: EFC0637A  fmadds f30, f0, f13, f12
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218CACC: 4BF909FD  bl 0x8211d4c8
	ctx.lr = 0x8218CAD0;
	sub_8211D4C8(ctx, base);
	// 8218CAD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CAD4: C3EB2238  lfs f31, 0x2238(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CAD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CADC: EC01F7FC  fnmsubs f0, f1, f31, f30
	ctx.f[0].f64 = -(((ctx.f[1].f64 * ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 8218CAE0: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218CAE4: C1AB2584  lfs f13, 0x2584(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CAE8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218CAEC: 40980008  bge cr6, 0x8218caf4
	if !ctx.cr[6].lt {
	pc = 0x8218CAF4; continue 'dispatch;
	}
	// 8218CAF0: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8218CAF4; continue 'dispatch;
            }
            0x8218CAF4 => {
    //   block [0x8218CAF4..0x8218CB0C)
	// 8218CAF4: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218CAF8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CAFC: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CB00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8218CB04: 40990008  ble cr6, 0x8218cb0c
	if !ctx.cr[6].gt {
	pc = 0x8218CB0C; continue 'dispatch;
	}
	// 8218CB08: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8218CB0C; continue 'dispatch;
            }
            0x8218CB0C => {
    //   block [0x8218CB0C..0x8218CBD8)
	// 8218CB0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CB10: C1BE0014  lfs f13, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CB14: C00B2798  lfs f0, 0x2798(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10136 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CB18: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218CB1C: 4BF909AD  bl 0x8211d4c8
	ctx.lr = 0x8218CB20;
	sub_8211D4C8(ctx, base);
	// 8218CB20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CB24: 3BDD0030  addi r30, r29, 0x30
	ctx.r[30].s64 = ctx.r[29].s64 + 48;
	// 8218CB28: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218CB2C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218CB30: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CB34: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218CB38: 814B0008  lwz r10, 8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CB3C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218CB40: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CB44: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218CB48: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218CB4C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218CB50: 4E800421  bctrl
	ctx.lr = 0x8218CB54;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218CB54: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218CB58: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8218CB5C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218CB60: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218CB64: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CB68: C3AA0030  lfs f29, 0x30(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8218CB6C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218CB70: 4E800421  bctrl
	ctx.lr = 0x8218CB74;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218CB74: 815D0030  lwz r10, 0x30(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218CB78: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218CB7C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218CB80: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8218CB84: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CB88: C3CB0034  lfs f30, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218CB8C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218CB90: 4E800421  bctrl
	ctx.lr = 0x8218CB94;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218CB94: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218CB98: C01F0060  lfs f0, 0x60(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CB9C: C19F0064  lfs f12, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CBA0: C1430038  lfs f10, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218CBA4: C17F0068  lfs f11, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CBA8: ED4A5828  fsubs f10, f10, f11
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218CBAC: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CBB0: ED3E6828  fsubs f9, f30, f13
	ctx.f[9].f64 = (((ctx.f[30].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218CBB4: FDA96FAE  fsel f13, f9, f30, f13
	ctx.f[13].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[30].f64 } else { ctx.f[13].f64 };
	// 8218CBB8: ED3D0028  fsubs f9, f29, f0
	ctx.f[9].f64 = (((ctx.f[29].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218CBBC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218CBC0: EC0907FA  fmadds f0, f9, f31, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218CBC4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218CBC8: EC0D67FA  fmadds f0, f13, f31, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 8218CBCC: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218CBD0: EC0A5FFA  fmadds f0, f10, f31, f11
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218CBD4: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            0x8218CBD8 => {
    //   block [0x8218CBD8..0x8218CBEC)
	// 8218CBD8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218CBDC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8218CBE0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8218CBE4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218CBE8: 483A8524  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218CBF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218CBF0 size=144
    let mut pc: u32 = 0x8218CBF0;
    'dispatch: loop {
        match pc {
            0x8218CBF0 => {
    //   block [0x8218CBF0..0x8218CC40)
	// 8218CBF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218CBF4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218CBF8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218CBFC: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218CC00: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218CC04: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218CC08: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CC0C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CC10: 4BFFC921  bl 0x82189530
	ctx.lr = 0x8218CC14;
	sub_82189530(ctx, base);
	// 8218CC14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CC18: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218CC1C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218CC20: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CC24: 409A001C  bne cr6, 0x8218cc40
	if !ctx.cr[6].eq {
	pc = 0x8218CC40; continue 'dispatch;
	}
	// 8218CC28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218CC2C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CC30: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CC34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218CC38: 4BFD8E69  bl 0x82165aa0
	ctx.lr = 0x8218CC3C;
	sub_82165AA0(ctx, base);
	// 8218CC3C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	pc = 0x8218CC40; continue 'dispatch;
            }
            0x8218CC40 => {
    //   block [0x8218CC40..0x8218CC80)
	// 8218CC40: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218CC44: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218CC48: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218CC4C: 914B0148  stw r10, 0x148(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 8218CC50: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218CC54: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218CC58: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218CC5C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218CC60: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218CC64: 4E800421  bctrl
	ctx.lr = 0x8218CC68;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218CC68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218CC6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218CC70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218CC74: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218CC78: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218CC7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218CC80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218CC80 size=212
    let mut pc: u32 = 0x8218CC80;
    'dispatch: loop {
        match pc {
            0x8218CC80 => {
    //   block [0x8218CC80..0x8218CD54)
	// 8218CC80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218CC84: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218CC88: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218CC8C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218CC90: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218CC94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CC98: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218CC9C: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CCA0: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218CCA4: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218CCA8: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218CCAC: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218CCB0: 481DA899  bl 0x82367548
	ctx.lr = 0x8218CCB4;
	sub_82367548(ctx, base);
	// 8218CCB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CCB8: C00B240C  lfs f0, 0x240c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CCBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CCC0: C1AB2408  lfs f13, 0x2408(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CCC4: EC016838  fmsubs f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218CCC8: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218CCCC: C19E0054  lfs f12, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CCD0: 481DA879  bl 0x82367548
	ctx.lr = 0x8218CCD4;
	sub_82367548(ctx, base);
	// 8218CCD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CCD8: C00BD6C8  lfs f0, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CCDC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218CCE0: C1ABD4DC  lfs f13, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CCE4: EDAC6828  fsubs f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218CCE8: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218CCEC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218CCF0: 481DA859  bl 0x82367548
	ctx.lr = 0x8218CCF4;
	sub_82367548(ctx, base);
	// 8218CCF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CCF8: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CCFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218CD00: C1ABCFEC  lfs f13, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CD04: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218CD08: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218CD0C: 481DA83D  bl 0x82367548
	ctx.lr = 0x8218CD10;
	sub_82367548(ctx, base);
	// 8218CD10: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218CD14: 394000B4  li r10, 0xb4
	ctx.r[10].s64 = 180;
	// 8218CD18: C00BD560  lfs f0, -0x2aa0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CD1C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218CD20: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 8218CD24: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8218CD28: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218CD2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CD30: C1AB2090  lfs f13, 0x2090(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8336 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CD34: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218CD38: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218CD3C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218CD40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218CD44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218CD48: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218CD4C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218CD50: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218CD58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218CD58 size=1972
    let mut pc: u32 = 0x8218CD58;
    'dispatch: loop {
        match pc {
            0x8218CD58 => {
    //   block [0x8218CD58..0x8218CE08)
	// 8218CD58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218CD5C: 483A8351  bl 0x825350ac
	ctx.lr = 0x8218CD60;
	sub_82535080(ctx, base);
	// 8218CD60: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 8218CD64: 483A9281  bl 0x82535fe4
	ctx.lr = 0x8218CD68;
	sub_82535FB0(ctx, base);
	// 8218CD68: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218CD6C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218CD70: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218CD74: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218CD78: 419A0784  beq cr6, 0x8218d4fc
	if ctx.cr[6].eq {
	pc = 0x8218D4FC; continue 'dispatch;
	}
	// 8218CD7C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218CD80: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218CD84: 3B2BBFF0  addi r25, r11, -0x4010
	ctx.r[25].s64 = ctx.r[11].s64 + -16400;
	// 8218CD88: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218CD8C: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218CD90: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218CD94: 7D59502E  lwzx r10, r25, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218CD98: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218CD9C: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218CDA0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218CDA4: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218CDA8: 7D79582E  lwzx r11, r25, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218CDAC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218CDB0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218CDB4: 409A0748  bne cr6, 0x8218d4fc
	if !ctx.cr[6].eq {
	pc = 0x8218D4FC; continue 'dispatch;
	}
	// 8218CDB8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218CDBC: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8218CDC0: 837F0020  lwz r27, 0x20(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218CDC4: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8218CDC8: 614A85F4  ori r10, r10, 0x85f4
	ctx.r[10].u64 = ctx.r[10].u64 | 34292;
	// 8218CDCC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8218CDD0: 7C99502E  lwzx r4, r25, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218CDD4: 41990034  bgt cr6, 0x8218ce08
	if ctx.cr[6].gt {
	pc = 0x8218CE08; continue 'dispatch;
	}
	// 8218CDD8: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218CDDC: 813F0034  lwz r9, 0x34(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) } as u64;
	// 8218CDE0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8218CDE4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8218CDE8: 915F0010  stw r10, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8218CDEC: 4099001C  ble cr6, 0x8218ce08
	if !ctx.cr[6].gt {
	pc = 0x8218CE08; continue 'dispatch;
	}
	// 8218CDF0: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 8218CDF4: 935F0010  stw r26, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8218CDF8: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8218CDFC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8218CE00: 4BFAC3B1  bl 0x821391b0
	ctx.lr = 0x8218CE04;
	sub_821391B0(ctx, base);
	// 8218CE04: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	pc = 0x8218CE08; continue 'dispatch;
            }
            0x8218CE08 => {
    //   block [0x8218CE08..0x8218CE1C)
	// 8218CE08: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8218CE0C: 7F0B2000  cmpw cr6, r11, r4
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[4].s32, &mut ctx.xer);
	// 8218CE10: 419A000C  beq cr6, 0x8218ce1c
	if ctx.cr[6].eq {
	pc = 0x8218CE1C; continue 'dispatch;
	}
	// 8218CE14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218CE18: 480007C1  bl 0x8218d5d8
	ctx.lr = 0x8218CE1C;
	sub_8218D5D8(ctx, base);
	pc = 0x8218CE1C; continue 'dispatch;
            }
            0x8218CE1C => {
    //   block [0x8218CE1C..0x8218CE8C)
	// 8218CE1C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218CE20: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8218CE24: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8218CE28: 615D9BA0  ori r29, r10, 0x9ba0
	ctx.r[29].u64 = ctx.r[10].u64 | 39840;
	// 8218CE2C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218CE30: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8218CE34: 615E9BA8  ori r30, r10, 0x9ba8
	ctx.r[30].u64 = ctx.r[10].u64 | 39848;
	// 8218CE38: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8218CE3C: C369D28C  lfs f27, -0x2d74(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8218CE40: 3B8A76FC  addi r28, r10, 0x76fc
	ctx.r[28].s64 = ctx.r[10].s64 + 30460;
	// 8218CE44: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218CE48: C38A1FF8  lfs f28, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8218CE4C: 419903EC  bgt cr6, 0x8218d238
	if ctx.cr[6].gt {
	pc = 0x8218D238; continue 'dispatch;
	}
	// 8218CE50: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218CE54: 398CCE68  addi r12, r12, -0x3198
	ctx.r[12].s64 = ctx.r[12].s64 + -12696;
	// 8218CE58: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218CE5C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218CE60: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218CE64: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8218CE8C; continue 'dispatch;
		},
		1 => {
	pc = 0x8218CED4; continue 'dispatch;
		},
		2 => {
	pc = 0x8218CEF8; continue 'dispatch;
		},
		3 => {
	pc = 0x8218CF1C; continue 'dispatch;
		},
		4 => {
	pc = 0x8218CF9C; continue 'dispatch;
		},
		5 => {
	pc = 0x8218D01C; continue 'dispatch;
		},
		6 => {
	pc = 0x8218D3C4; continue 'dispatch;
		},
		7 => {
	pc = 0x8218D3F0; continue 'dispatch;
		},
		8 => {
	pc = 0x8218D41C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218CE68: 8218CE8C  lwz r16, -0x3174(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12660 as u32) ) } as u64;
	// 8218CE6C: 8218CED4  lwz r16, -0x312c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12588 as u32) ) } as u64;
	// 8218CE70: 8218CEF8  lwz r16, -0x3108(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12552 as u32) ) } as u64;
	// 8218CE74: 8218CF1C  lwz r16, -0x30e4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12516 as u32) ) } as u64;
	// 8218CE78: 8218CF9C  lwz r16, -0x3064(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12388 as u32) ) } as u64;
	// 8218CE7C: 8218D01C  lwz r16, -0x2fe4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-12260 as u32) ) } as u64;
	// 8218CE80: 8218D3C4  lwz r16, -0x2c3c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-11324 as u32) ) } as u64;
	// 8218CE84: 8218D3F0  lwz r16, -0x2c10(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-11280 as u32) ) } as u64;
	// 8218CE88: 8218D41C  lwz r16, -0x2be4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-11236 as u32) ) } as u64;
            }
            0x8218CE8C => {
    //   block [0x8218CE8C..0x8218CED4)
	// 8218CE8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CE90: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218CE94: C00B2994  lfs f0, 0x2994(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CE98: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218CE9C: 7D6AEC2E  lfsx f11, r10, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CEA0: C18BD478  lfs f12, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CEA4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CEA8: 7DABEC2E  lfsx f13, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CEAC: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 8218CEB0: 7D4BF42E  lfsx f10, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218CEB4: 7D6AF42E  lfsx f11, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CEB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CEBC: ED6A582A  fadds f11, f10, f11
	ctx.f[11].f64 = ((ctx.f[10].f64 + ctx.f[11].f64) as f32) as f64;
	// 8218CEC0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218CEC4: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CEC8: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218CECC: EDAB0032  fmuls f13, f11, f0
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218CED0: 48000374  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218CED4 => {
    //   block [0x8218CED4..0x8218CEF8)
	// 8218CED4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CED8: C00B2994  lfs f0, 0x2994(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CEDC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218CEE0: C18BD478  lfs f12, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CEE4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218CEE8: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CEEC: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CEF0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218CEF4: 48000350  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218CEF8 => {
    //   block [0x8218CEF8..0x8218CF1C)
	// 8218CEF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CEFC: C00B2994  lfs f0, 0x2994(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10644 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CF00: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218CF04: C18BD478  lfs f12, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CF08: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CF0C: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CF10: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CF14: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218CF18: 4800032C  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218CF1C => {
    //   block [0x8218CF1C..0x8218CF9C)
	// 8218CF1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CF20: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218CF24: 214A003C  subfic r10, r10, 0x3c
	ctx.xer.ca = ctx.r[10].u32 <= 60 as u32;
	ctx.r[10].s64 = (60 as i64) - ctx.r[10].s64;
	// 8218CF28: C00B22A4  lfs f0, 0x22a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CF2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CF30: C16B2068  lfs f11, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CF34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CF38: C14B2794  lfs f10, 0x2794(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218CF3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CF40: C18B2170  lfs f12, 0x2170(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8560 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CF44: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218CF48: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218CF4C: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 8218CF50: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218CF54: 614A9B74  ori r10, r10, 0x9b74
	ctx.r[10].u64 = ctx.r[10].u64 | 39796;
	// 8218CF58: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CF5C: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8218CF60: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CF64: D15F0024  stfs f10, 0x24(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218CF68: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8218CF6C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8218CF70: D17F002C  stfs f11, 0x2c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218CF74: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218CF78: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CF7C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8218CF80: EC2A583C  fnmsubs f1, f10, f0, f11
	ctx.f[1].f64 = -(((ctx.f[10].f64 * ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218CF84: 481DAC1D  bl 0x82367ba0
	ctx.lr = 0x8218CF88;
	sub_82367BA0(ctx, base);
	// 8218CF88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CF8C: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218CF90: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CF94: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218CF98: 480002AC  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218CF9C => {
    //   block [0x8218CF9C..0x8218D01C)
	// 8218CF9C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CFA0: 815F0010  lwz r10, 0x10(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218CFA4: 214A003C  subfic r10, r10, 0x3c
	ctx.xer.ca = ctx.r[10].u32 <= 60 as u32;
	ctx.r[10].s64 = (60 as i64) - ctx.r[10].s64;
	// 8218CFA8: C00B22A4  lfs f0, 0x22a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218CFAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CFB0: C16B2068  lfs f11, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CFB4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CFB8: C14B2794  lfs f10, 0x2794(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10132 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218CFBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218CFC0: C18B2170  lfs f12, 0x2170(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8560 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218CFC4: 554B083C  slwi r11, r10, 1
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218CFC8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218CFCC: 7D6907B4  extsw r9, r11
	ctx.r[9].s64 = ctx.r[11].s32 as i64;
	// 8218CFD0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CFD4: 614A9B74  ori r10, r10, 0x9b74
	ctx.r[10].u64 = ctx.r[10].u64 | 39796;
	// 8218CFD8: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218CFDC: F9210058  std r9, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[9].u64 ) };
	// 8218CFE0: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218CFE4: D15F0024  stfs f10, 0x24(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218CFE8: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8218CFEC: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8218CFF0: D17F002C  stfs f11, 0x2c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218CFF4: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218CFF8: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218CFFC: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8218D000: EC2A583A  fmadds f1, f10, f0, f11
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218D004: 481DAB9D  bl 0x82367ba0
	ctx.lr = 0x8218D008;
	sub_82367BA0(ctx, base);
	// 8218D008: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D00C: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D010: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D014: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D018: 4800022C  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218D01C => {
    //   block [0x8218D01C..0x8218D06C)
	// 8218D01C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218D020: 616B9410  ori r11, r11, 0x9410
	ctx.r[11].u64 = ctx.r[11].u64 | 37904;
	// 8218D024: 7C195C2E  lfsx f0, r25, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D028: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D02C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8218D030: C3ABBFFC  lfs f29, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8218D034: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218D038: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218D03C: FF0DE800  fcmpu cr6, f13, f29
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[29].f64);
	// 8218D040: 4198006C  blt cr6, 0x8218d0ac
	if ctx.cr[6].lt {
	pc = 0x8218D0AC; continue 'dispatch;
	}
	// 8218D044: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D048: C1AB2048  lfs f13, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D04C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D050: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 8218D054: 4098003C  bge cr6, 0x8218d090
	if !ctx.cr[6].lt {
	pc = 0x8218D090; continue 'dispatch;
	}
	// 8218D058: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218D05C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218D060: 4098000C  bge cr6, 0x8218d06c
	if !ctx.cr[6].lt {
	pc = 0x8218D06C; continue 'dispatch;
	}
	// 8218D064: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D068: 48000040  b 0x8218d0a8
	pc = 0x8218D0A8; continue 'dispatch;
            }
            0x8218D06C => {
    //   block [0x8218D06C..0x8218D090)
	// 8218D06C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D070: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D074: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D078: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D07C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D080: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218D084: 41980024  blt cr6, 0x8218d0a8
	if ctx.cr[6].lt {
	pc = 0x8218D0A8; continue 'dispatch;
	}
	// 8218D088: FC00E090  fmr f0, f28
	ctx.f[0].f64 = ctx.f[28].f64;
	// 8218D08C: 4800001C  b 0x8218d0a8
	pc = 0x8218D0A8; continue 'dispatch;
            }
            0x8218D090 => {
    //   block [0x8218D090..0x8218D0A8)
	// 8218D090: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218D094: 41980014  blt cr6, 0x8218d0a8
	if ctx.cr[6].lt {
	pc = 0x8218D0A8; continue 'dispatch;
	}
	// 8218D098: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D09C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D0A0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D0A4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8218D0A8; continue 'dispatch;
            }
            0x8218D0A8 => {
    //   block [0x8218D0A8..0x8218D0AC)
	// 8218D0A8: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	pc = 0x8218D0AC; continue 'dispatch;
            }
            0x8218D0AC => {
    //   block [0x8218D0AC..0x8218D114)
	// 8218D0AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D0B0: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8218D0B4: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8218D0B8: C3CB2490  lfs f30, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218D0BC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218D0C0: 4BF84D11  bl 0x82111dd0
	ctx.lr = 0x8218D0C4;
	sub_82111DD0(ctx, base);
	// 8218D0C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D0C8: 817F0010  lwz r11, 0x10(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218D0CC: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8218D0D0: C00A2990  lfs f0, 0x2990(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D0D4: 7D6A07B4  extsw r10, r11
	ctx.r[10].s64 = ctx.r[11].s32 as i64;
	// 8218D0D8: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218D0DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D0E0: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 8218D0E4: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8218D0E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D0EC: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D0F0: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D0F4: EC0C6838  fmsubs f0, f12, f0, f13
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D0F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218D0FC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8218D100: 40980014  bge cr6, 0x8218d114
	if !ctx.cr[6].lt {
	pc = 0x8218D114; continue 'dispatch;
	}
	// 8218D104: 4BF903C5  bl 0x8211d4c8
	ctx.lr = 0x8218D108;
	sub_8211D4C8(ctx, base);
	// 8218D108: EC01F82A  fadds f0, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[31].f64) as f32) as f64;
	// 8218D10C: EFC00772  fmuls f30, f0, f29
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8218D110: 48000034  b 0x8218d144
	pc = 0x8218D144; continue 'dispatch;
            }
            0x8218D114 => {
    //   block [0x8218D114..0x8218D12C)
	// 8218D114: 4BF903B5  bl 0x8211d4c8
	ctx.lr = 0x8218D118;
	sub_8211D4C8(ctx, base);
	// 8218D118: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 8218D11C: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 8218D120: 409A000C  bne cr6, 0x8218d12c
	if !ctx.cr[6].eq {
	pc = 0x8218D12C; continue 'dispatch;
	}
	// 8218D124: FFE0E090  fmr f31, f28
	ctx.f[31].f64 = ctx.f[28].f64;
	// 8218D128: 4800001C  b 0x8218d144
	pc = 0x8218D144; continue 'dispatch;
            }
            0x8218D12C => {
    //   block [0x8218D12C..0x8218D144)
	// 8218D12C: FC20F210  fabs f1, f30
	ctx.f[1].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 8218D130: 483A5EA9  bl 0x82532fd8
	ctx.lr = 0x8218D134;
	sub_82532FD8(ctx, base);
	// 8218D134: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8218D138: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8218D13C: 483A635D  bl 0x82533498
	ctx.lr = 0x8218D140;
	sub_82533498(ctx, base);
	// 8218D140: FFE00818  frsp f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x8218D144; continue 'dispatch;
            }
            0x8218D144 => {
    //   block [0x8218D144..0x8218D154)
	// 8218D144: FF1EE000  fcmpu cr6, f30, f28
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[28].f64);
	// 8218D148: 409A000C  bne cr6, 0x8218d154
	if !ctx.cr[6].eq {
	pc = 0x8218D154; continue 'dispatch;
	}
	// 8218D14C: FDA0E090  fmr f13, f28
	ctx.f[13].f64 = ctx.f[28].f64;
	// 8218D150: 4800001C  b 0x8218d16c
	pc = 0x8218D16C; continue 'dispatch;
            }
            0x8218D154 => {
    //   block [0x8218D154..0x8218D16C)
	// 8218D154: FC20F210  fabs f1, f30
	ctx.f[1].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 8218D158: 483A5E81  bl 0x82532fd8
	ctx.lr = 0x8218D15C;
	sub_82532FD8(ctx, base);
	// 8218D15C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8218D160: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 8218D164: 483A6335  bl 0x82533498
	ctx.lr = 0x8218D168;
	sub_82533498(ctx, base);
	// 8218D168: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	pc = 0x8218D16C; continue 'dispatch;
            }
            0x8218D16C => {
    //   block [0x8218D16C..0x8218D238)
	// 8218D16C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D170: C1810050  lfs f12, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D174: C1210058  lfs f9, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218D178: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218D17C: C17F0040  lfs f11, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218D180: C15F0048  lfs f10, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218D184: C00B298C  lfs f0, 0x298c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D188: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218D18C: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218D190: ED8C5B7A  fmadds f12, f12, f13, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218D194: D19F0040  stfs f12, 0x40(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218D198: EC00537A  fmadds f0, f0, f13, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64);
	// 8218D19C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218D1A0: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D1A4: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218D1A8: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218D1AC: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218D1B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D1B4: 4E800421  bctrl
	ctx.lr = 0x8218D1B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D1B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D1BC: C19F0044  lfs f12, 0x44(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D1C0: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8218D1C4: C11F0024  lfs f8, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8218D1C8: C13F0028  lfs f9, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218D1CC: C0FF002C  lfs f7, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8218D1D0: C00A2090  lfs f0, 0x2090(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8336 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D1D4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D1D8: C1AA2988  lfs f13, 0x2988(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10632 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D1DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D1E0: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8218D1E4: C1AA2984  lfs f13, 0x2984(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10628 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D1E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D1EC: ED3F4B7C  fnmsubs f9, f31, f13, f9
	ctx.f[9].f64 = -(((ctx.f[31].f64 * ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 8218D1F0: C18A2980  lfs f12, 0x2980(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10624 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D1F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D1F8: ED9F433A  fmadds f12, f31, f12, f8
	ctx.f[12].f64 = (((ctx.f[31].f64 * ctx.f[12].f64 + ctx.f[8].f64) as f32) as f64);
	// 8218D1FC: C1030034  lfs f8, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8218D200: D13F0028  stfs f9, 0x28(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D204: D19F0024  stfs f12, 0x24(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D208: C16A297C  lfs f11, 0x297c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10620 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218D20C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D210: ED7F3AFC  fnmsubs f11, f31, f11, f7
	ctx.f[11].f64 = -(((ctx.f[31].f64 * ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 8218D214: D17F002C  stfs f11, 0x2c(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D218: C1AA2760  lfs f13, 0x2760(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10080 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D21C: E95F0048  ld r10, 0x48(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	// 8218D220: EDA86828  fsubs f13, f8, f13
	ctx.f[13].f64 = (((ctx.f[8].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D224: EC0D503A  fmadds f0, f13, f0, f10
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8218D228: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218D22C: E93F0040  ld r9, 0x40(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	// 8218D230: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8218D234: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
            }
            0x8218D238 => {
    //   block [0x8218D238..0x8218D244)
	// 8218D238: C3E10060  lfs f31, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218D23C: C1810064  lfs f12, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D240: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218D244 => {
    //   block [0x8218D244..0x8218D2D0)
	// 8218D244: C17F0040  lfs f11, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218D248: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D24C: C15F0044  lfs f10, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218D250: ED1F5828  fsubs f8, f31, f11
	ctx.f[8].f64 = (((ctx.f[31].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218D254: C13F0048  lfs f9, 0x48(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(72 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218D258: ED8C5028  fsubs f12, f12, f10
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[10].f64) as f32) as f64);
	// 8218D25C: EDAD4828  fsubs f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[9].f64) as f32) as f64);
	// 8218D260: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218D264: C00B21DC  lfs f0, 0x21dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D268: EC28583A  fmadds f1, f8, f0, f11
	ctx.f[1].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8218D26C: D03F0040  stfs f1, 0x40(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218D270: EC4C503A  fmadds f2, f12, f0, f10
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8218D274: D05F0044  stfs f2, 0x44(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218D278: EC6D483A  fmadds f3, f13, f0, f9
	ctx.f[3].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 8218D27C: D07F0048  stfs f3, 0x48(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218D280: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218D284: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218D288: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D28C: 4E800421  bctrl
	ctx.lr = 0x8218D290;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D290: C1BB0050  lfs f13, 0x50(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D294: C01F0024  lfs f0, 0x24(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D298: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218D29C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D2A0: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D2A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218D2A8: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8218D2AC: EFE00372  fmuls f31, f0, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8218D2B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D2B4: 4E800421  bctrl
	ctx.lr = 0x8218D2B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D2B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D2BC: C00B2524  lfs f0, 0x2524(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D2C0: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8218D2C4: 4099000C  ble cr6, 0x8218d2d0
	if !ctx.cr[6].gt {
	pc = 0x8218D2D0; continue 'dispatch;
	}
	// 8218D2C8: FF1FE000  fcmpu cr6, f31, f28
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[28].f64);
	// 8218D2CC: 41990020  bgt cr6, 0x8218d2ec
	if ctx.cr[6].gt {
	pc = 0x8218D2EC; continue 'dispatch;
	}
            }
            0x8218D2D0 => {
    //   block [0x8218D2D0..0x8218D2EC)
	// 8218D2D0: C01B0050  lfs f0, 0x50(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D2D4: EC1F002A  fadds f0, f31, f0
	ctx.f[0].f64 = ((ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D2D8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D2DC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D2E0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D2E4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D2E8: D01B0050  stfs f0, 0x50(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8218D2EC; continue 'dispatch;
            }
            0x8218D2EC => {
    //   block [0x8218D2EC..0x8218D388)
	// 8218D2EC: C01B0054  lfs f0, 0x54(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D2F0: C19F0028  lfs f12, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D2F4: ED8C0028  fsubs f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D2F8: C17F0030  lfs f11, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218D2FC: C1BB0070  lfs f13, 0x70(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D300: EC0C02FA  fmadds f0, f12, f11, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64);
	// 8218D304: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D308: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218D30C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218D310: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218D314: D01B0054  stfs f0, 0x54(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218D318: C01F002C  lfs f0, 0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(44 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D31C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D320: C19F0030  lfs f12, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D324: EC006B3A  fmadds f0, f0, f12, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218D328: D01B0070  stfs f0, 0x70(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218D32C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218D330: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218D334: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8218D338: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218D33C: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8218D340: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D344: 4E800421  bctrl
	ctx.lr = 0x8218D348;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D348: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218D34C: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8218D350: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218D354: 386B0010  addi r3, r11, 0x10
	ctx.r[3].s64 = ctx.r[11].s64 + 16;
	// 8218D358: 816B0010  lwz r11, 0x10(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218D35C: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8218D360: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D364: 4E800421  bctrl
	ctx.lr = 0x8218D368;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D368: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D36C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8218D370: 6165BEB8  ori r5, r11, 0xbeb8
	ctx.r[5].u64 = ctx.r[11].u64 | 48824;
	// 8218D374: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D378: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8218D37C: 61669C00  ori r6, r11, 0x9c00
	ctx.r[6].u64 = ctx.r[11].u64 | 39936;
	// 8218D380: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D384: 6167EB2B  ori r7, r11, 0xeb2b
	ctx.r[7].u64 = ctx.r[11].u64 | 60203;
            }
            0x8218D388 => {
    //   block [0x8218D388..0x8218D3C4)
	// 8218D388: 552B103A  slwi r11, r9, 2
	ctx.r[11].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218D38C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 8218D390: 7DABF42E  lfsx f13, r11, r30
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D394: EDA16828  fsubs f13, f1, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D398: 7C0BEC2E  lfsx f0, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D39C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D3A0: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 8218D3A4: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218D3A8: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8218D3AC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 8218D3B0: 409800B0  bge cr6, 0x8218d460
	if !ctx.cr[6].lt {
	pc = 0x8218D460; continue 'dispatch;
	}
	// 8218D3B4: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8218D3B8: 934B0014  stw r26, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 8218D3BC: 934B0018  stw r26, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 8218D3C0: 48000130  b 0x8218d4f0
	pc = 0x8218D4F0; continue 'dispatch;
            }
            0x8218D3C4 => {
    //   block [0x8218D3C4..0x8218D3F0)
	// 8218D3C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D3C8: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D3CC: C00B2978  lfs f0, 0x2978(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D3D0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D3D4: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D3D8: C18BD478  lfs f12, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D3DC: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D3E0: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218D3E4: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D3E8: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D3EC: 4BFFFE58  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218D3F0 => {
    //   block [0x8218D3F0..0x8218D41C)
	// 8218D3F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D3F4: C1BF0028  lfs f13, 0x28(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D3F8: C00B2978  lfs f0, 0x2978(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D3FC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D400: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D404: C18BD478  lfs f12, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D408: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218D40C: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218D410: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D414: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D418: 4BFFFE2C  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218D41C => {
    //   block [0x8218D41C..0x8218D460)
	// 8218D41C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218D420: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218D424: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218D428: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218D42C: 7FEBEC2E  lfsx f31, r11, r29
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218D430: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218D434: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218D438: 4E800421  bctrl
	ctx.lr = 0x8218D43C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D43C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D440: C1BF0028  lfs f13, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D444: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D448: C00B2978  lfs f0, 0x2978(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D44C: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218D450: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D454: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D458: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D45C: 4BFFFDE8  b 0x8218d244
	pc = 0x8218D244; continue 'dispatch;
            }
            0x8218D460 => {
    //   block [0x8218D460..0x8218D490)
	// 8218D460: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218D464: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8218D468: 614A8654  ori r10, r10, 0x8654
	ctx.r[10].u64 = ctx.r[10].u64 | 34388;
	// 8218D46C: 7D59502E  lwzx r10, r25, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[25].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218D470: 409A0020  bne cr6, 0x8218d490
	if !ctx.cr[6].eq {
	pc = 0x8218D490; continue 'dispatch;
	}
	// 8218D474: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 8218D478: 409A0018  bne cr6, 0x8218d490
	if !ctx.cr[6].eq {
	pc = 0x8218D490; continue 'dispatch;
	}
	// 8218D47C: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D480: 934B0010  stw r26, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[26].u32 ) };
	// 8218D484: 934B0014  stw r26, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[26].u32 ) };
	// 8218D488: 934B0018  stw r26, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[26].u32 ) };
	// 8218D48C: 48000064  b 0x8218d4f0
	pc = 0x8218D4F0; continue 'dispatch;
            }
            0x8218D490 => {
    //   block [0x8218D490..0x8218D4CC)
	// 8218D490: 7C8B2A2E  lhzx r4, r11, r5
	ctx.r[4].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[5].u32)) } as u64;
	// 8218D494: 2B040025  cmplwi cr6, r4, 0x25
	ctx.cr[6].compare_u32(ctx.r[4].u32, 37 as u32, &mut ctx.xer);
	// 8218D498: 409A004C  bne cr6, 0x8218d4e4
	if !ctx.cr[6].eq {
	pc = 0x8218D4E4; continue 'dispatch;
	}
	// 8218D49C: 2B0A0005  cmplwi cr6, r10, 5
	ctx.cr[6].compare_u32(ctx.r[10].u32, 5 as u32, &mut ctx.xer);
	// 8218D4A0: 409A0044  bne cr6, 0x8218d4e4
	if !ctx.cr[6].eq {
	pc = 0x8218D4E4; continue 'dispatch;
	}
	// 8218D4A4: 7D4B302E  lwzx r10, r11, r6
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 8218D4A8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218D4AC: 419A0020  beq cr6, 0x8218d4cc
	if ctx.cr[6].eq {
	pc = 0x8218D4CC; continue 'dispatch;
	}
	// 8218D4B0: 814B0014  lwz r10, 0x14(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218D4B4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218D4B8: 419A0014  beq cr6, 0x8218d4cc
	if ctx.cr[6].eq {
	pc = 0x8218D4CC; continue 'dispatch;
	}
	// 8218D4BC: 7D4B38AE  lbzx r10, r11, r7
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 8218D4C0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218D4C4: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 8218D4C8: 419A0008  beq cr6, 0x8218d4d0
	if ctx.cr[6].eq {
	pc = 0x8218D4D0; continue 'dispatch;
	}
	pc = 0x8218D4CC; continue 'dispatch;
            }
            0x8218D4CC => {
    //   block [0x8218D4CC..0x8218D4D0)
	// 8218D4CC: 7F4AD378  mr r10, r26
	ctx.r[10].u64 = ctx.r[26].u64;
	pc = 0x8218D4D0; continue 'dispatch;
            }
            0x8218D4D0 => {
    //   block [0x8218D4D0..0x8218D4DC)
	// 8218D4D0: 2F0AFFFF  cmpwi cr6, r10, -1
	ctx.cr[6].compare_i32(ctx.r[10].s32, -1, &mut ctx.xer);
	// 8218D4D4: 409A0008  bne cr6, 0x8218d4dc
	if !ctx.cr[6].eq {
	pc = 0x8218D4DC; continue 'dispatch;
	}
	// 8218D4D8: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	pc = 0x8218D4DC; continue 'dispatch;
            }
            0x8218D4DC => {
    //   block [0x8218D4DC..0x8218D4E4)
	// 8218D4DC: 914B0014  stw r10, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[10].u32 ) };
	// 8218D4E0: 48000008  b 0x8218d4e8
	pc = 0x8218D4E8; continue 'dispatch;
            }
            0x8218D4E4 => {
    //   block [0x8218D4E4..0x8218D4E8)
	// 8218D4E4: 910B0014  stw r8, 0x14(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), ctx.r[8].u32 ) };
	pc = 0x8218D4E8; continue 'dispatch;
            }
            0x8218D4E8 => {
    //   block [0x8218D4E8..0x8218D4F0)
	// 8218D4E8: 910B0018  stw r8, 0x18(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), ctx.r[8].u32 ) };
	// 8218D4EC: 910B0010  stw r8, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[8].u32 ) };
	pc = 0x8218D4F0; continue 'dispatch;
            }
            0x8218D4F0 => {
    //   block [0x8218D4F0..0x8218D4FC)
	// 8218D4F0: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 8218D4F4: 2F090002  cmpwi cr6, r9, 2
	ctx.cr[6].compare_i32(ctx.r[9].s32, 2, &mut ctx.xer);
	// 8218D4F8: 4198FE90  blt cr6, 0x8218d388
	if ctx.cr[6].lt {
	pc = 0x8218D388; continue 'dispatch;
	}
	pc = 0x8218D4FC; continue 'dispatch;
            }
            0x8218D4FC => {
    //   block [0x8218D4FC..0x8218D50C)
	// 8218D4FC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8218D500: 3981FFC0  addi r12, r1, -0x40
	ctx.r[12].s64 = ctx.r[1].s64 + -64;
	// 8218D504: 483A8B2D  bl 0x82536030
	ctx.lr = 0x8218D508;
	sub_82535FFC(ctx, base);
	// 8218D508: 483A7BF4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218D510(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218D510 size=200
    let mut pc: u32 = 0x8218D510;
    'dispatch: loop {
        match pc {
            0x8218D510 => {
    //   block [0x8218D510..0x8218D5D8)
	// 8218D510: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218D514: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218D518: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218D51C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218D520: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218D524: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218D528: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218D52C: 481DA01D  bl 0x82367548
	ctx.lr = 0x8218D530;
	sub_82367548(ctx, base);
	// 8218D530: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D534: C00B240C  lfs f0, 0x240c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9228 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D538: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D53C: C1AB2408  lfs f13, 0x2408(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D540: EC016838  fmsubs f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D544: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D548: C19E0054  lfs f12, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D54C: 481D9FFD  bl 0x82367548
	ctx.lr = 0x8218D550;
	sub_82367548(ctx, base);
	// 8218D550: EC01602A  fadds f0, f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[12].f64) as f32) as f64;
	// 8218D554: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D558: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D55C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D560: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D564: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D568: 481D9FE1  bl 0x82367548
	ctx.lr = 0x8218D56C;
	sub_82367548(ctx, base);
	// 8218D56C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D570: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D574: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218D578: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D57C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218D580: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D584: C1ABD564  lfs f13, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D588: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8218D58C: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D590: 481D9FB9  bl 0x82367548
	ctx.lr = 0x8218D594;
	sub_82367548(ctx, base);
	// 8218D594: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218D598: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8218D59C: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218D5A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D5A4: C00B25E4  lfs f0, 0x25e4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9700 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D5A8: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218D5AC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8218D5B0: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 8218D5B4: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8218D5B8: 216B005A  subfic r11, r11, 0x5a
	ctx.xer.ca = ctx.r[11].u32 <= 90 as u32;
	ctx.r[11].s64 = (90 as i64) - ctx.r[11].s64;
	// 8218D5BC: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8218D5C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218D5C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218D5C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218D5CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218D5D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218D5D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218D5D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218D5D8 size=1024
    let mut pc: u32 = 0x8218D5D8;
    'dispatch: loop {
        match pc {
            0x8218D5D8 => {
    //   block [0x8218D5D8..0x8218D640)
	// 8218D5D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218D5DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218D5E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218D5E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218D5E8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218D5EC: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8218D5F0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218D5F4: 397E0001  addi r11, r30, 1
	ctx.r[11].s64 = ctx.r[30].s64 + 1;
	// 8218D5F8: 2B0B0009  cmplwi cr6, r11, 9
	ctx.cr[6].compare_u32(ctx.r[11].u32, 9 as u32, &mut ctx.xer);
	// 8218D5FC: 419903B8  bgt cr6, 0x8218d9b4
	if ctx.cr[6].gt {
	pc = 0x8218D9B4; continue 'dispatch;
	}
	// 8218D600: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218D604: 398CD618  addi r12, r12, -0x29e8
	ctx.r[12].s64 = ctx.r[12].s64 + -10728;
	// 8218D608: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218D60C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218D610: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218D614: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8218D640; continue 'dispatch;
		},
		1 => {
	pc = 0x8218D9B4; continue 'dispatch;
		},
		2 => {
	pc = 0x8218D9B4; continue 'dispatch;
		},
		3 => {
	pc = 0x8218D9B4; continue 'dispatch;
		},
		4 => {
	pc = 0x8218D668; continue 'dispatch;
		},
		5 => {
	pc = 0x8218D700; continue 'dispatch;
		},
		6 => {
	pc = 0x8218D79C; continue 'dispatch;
		},
		7 => {
	pc = 0x8218D908; continue 'dispatch;
		},
		8 => {
	pc = 0x8218D960; continue 'dispatch;
		},
		9 => {
	pc = 0x8218D960; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218D618: 8218D640  lwz r16, -0x29c0(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-10688 as u32) ) } as u64;
	// 8218D61C: 8218D9B4  lwz r16, -0x264c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9804 as u32) ) } as u64;
	// 8218D620: 8218D9B4  lwz r16, -0x264c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9804 as u32) ) } as u64;
	// 8218D624: 8218D9B4  lwz r16, -0x264c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9804 as u32) ) } as u64;
	// 8218D628: 8218D668  lwz r16, -0x2998(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-10648 as u32) ) } as u64;
	// 8218D62C: 8218D700  lwz r16, -0x2900(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-10496 as u32) ) } as u64;
	// 8218D630: 8218D79C  lwz r16, -0x2864(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-10340 as u32) ) } as u64;
	// 8218D634: 8218D908  lwz r16, -0x26f8(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9976 as u32) ) } as u64;
	// 8218D638: 8218D960  lwz r16, -0x26a0(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9888 as u32) ) } as u64;
	// 8218D63C: 8218D960  lwz r16, -0x26a0(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-9888 as u32) ) } as u64;
            }
            0x8218D640 => {
    //   block [0x8218D640..0x8218D668)
	// 8218D640: 817F0038  lwz r11, 0x38(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) } as u64;
	// 8218D644: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8218D648: 40990378  ble cr6, 0x8218d9c0
	if !ctx.cr[6].gt {
	pc = 0x8218D9C0; continue 'dispatch;
	}
	// 8218D64C: 396BFFFD  addi r11, r11, -3
	ctx.r[11].s64 = ctx.r[11].s64 + -3;
	// 8218D650: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8218D654: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8218D658: 4BFABB59  bl 0x821391b0
	ctx.lr = 0x8218D65C;
	sub_821391B0(ctx, base);
	// 8218D65C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218D660: 917F0038  stw r11, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 8218D664: 48000354  b 0x8218d9b8
	pc = 0x8218D9B8; continue 'dispatch;
            }
            0x8218D668 => {
    //   block [0x8218D668..0x8218D700)
	// 8218D668: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D66C: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8218D670: C00B2170  lfs f0, 0x2170(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D674: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D678: 61699BA0  ori r9, r11, 0x9ba0
	ctx.r[9].u64 = ctx.r[11].u64 | 39840;
	// 8218D67C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D680: C1AB2794  lfs f13, 0x2794(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D684: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D688: 61689BA8  ori r8, r11, 0x9ba8
	ctx.r[8].u64 = ctx.r[11].u64 | 39848;
	// 8218D68C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D690: 61679B74  ori r7, r11, 0x9b74
	ctx.r[7].u64 = ctx.r[11].u64 | 39796;
	// 8218D694: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D698: 814B76FC  lwz r10, 0x76fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D69C: 7D8A4C2E  lfsx f12, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D6A0: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218D6A4: D19F0040  stfs f12, 0x40(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218D6A8: 814B76FC  lwz r10, 0x76fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D6AC: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D6B0: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218D6B4: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D6B8: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D6BC: 7DAB3C2E  lfsx f13, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D6C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D6C4: C00B2128  lfs f0, 0x2128(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D6C8: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D6CC: 481DA4D5  bl 0x82367ba0
	ctx.lr = 0x8218D6D0;
	sub_82367BA0(ctx, base);
	// 8218D6D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D6D4: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D6D8: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 8218D6DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8218D6E0: C00B2070  lfs f0, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D6E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218D6E8: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D6EC: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 8218D6F0: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8218D6F4: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D6F8: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D6FC: 480002C4  b 0x8218d9c0
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D700 => {
    //   block [0x8218D700..0x8218D79C)
	// 8218D700: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D704: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8218D708: C00B2170  lfs f0, 0x2170(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8560 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D70C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D710: 61699BA0  ori r9, r11, 0x9ba0
	ctx.r[9].u64 = ctx.r[11].u64 | 39840;
	// 8218D714: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D718: C1AB2794  lfs f13, 0x2794(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D71C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D720: 61689BA8  ori r8, r11, 0x9ba8
	ctx.r[8].u64 = ctx.r[11].u64 | 39848;
	// 8218D724: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D728: 61679B74  ori r7, r11, 0x9b74
	ctx.r[7].u64 = ctx.r[11].u64 | 39796;
	// 8218D72C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D730: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8218D734: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D738: 7D8A4C2E  lfsx f12, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D73C: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218D740: D19F0040  stfs f12, 0x40(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218D744: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D748: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D74C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218D750: D1BF0024  stfs f13, 0x24(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D754: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D758: 7DAB3C2E  lfsx f13, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D75C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D760: C00B2128  lfs f0, 0x2128(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D764: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D768: 481DA439  bl 0x82367ba0
	ctx.lr = 0x8218D76C;
	sub_82367BA0(ctx, base);
	// 8218D76C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D770: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D774: 3940003C  li r10, 0x3c
	ctx.r[10].s64 = 60;
	// 8218D778: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8218D77C: C00B2070  lfs f0, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D780: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218D784: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D788: 915F0034  stw r10, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[10].u32 ) };
	// 8218D78C: 913F0010  stw r9, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8218D790: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D794: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D798: 48000228  b 0x8218d9c0
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D79C => {
    //   block [0x8218D79C..0x8218D834)
	// 8218D79C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D7A0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218D7A4: 614A9410  ori r10, r10, 0x9410
	ctx.r[10].u64 = ctx.r[10].u64 | 37904;
	// 8218D7A8: C00B2790  lfs f0, 0x2790(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D7AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D7B0: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D7B4: C00B278C  lfs f0, 0x278c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D7B8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218D7BC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218D7C0: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D7C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218D7C8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D7CC: D01F0028  stfs f0, 0x28(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D7D0: C00A2068  lfs f0, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D7D4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8218D7D8: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D7DC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D7E0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218D7E4: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D7E8: 614A9410  ori r10, r10, 0x9410
	ctx.r[10].u64 = ctx.r[10].u64 | 37904;
	// 8218D7EC: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D7F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D7F4: FD800210  fabs f12, f0
	ctx.f[12].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8218D7F8: C16BBFFC  lfs f11, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218D7FC: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 8218D800: 41980074  blt cr6, 0x8218d874
	if ctx.cr[6].lt {
	pc = 0x8218D874; continue 'dispatch;
	}
	// 8218D804: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D808: C18B2048  lfs f12, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D80C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D810: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218D814: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218D818: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8218D81C: 4098003C  bge cr6, 0x8218d858
	if !ctx.cr[6].lt {
	pc = 0x8218D858; continue 'dispatch;
	}
	// 8218D820: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8218D824: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218D828: 4098000C  bge cr6, 0x8218d834
	if !ctx.cr[6].lt {
	pc = 0x8218D834; continue 'dispatch;
	}
	// 8218D82C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D830: 48000040  b 0x8218d870
	pc = 0x8218D870; continue 'dispatch;
            }
            0x8218D834 => {
    //   block [0x8218D834..0x8218D858)
	// 8218D834: FD40065E  fctidz f10, f0
	ctx.f[10].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D838: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8218D83C: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8218D840: EC005028  fsubs f0, f0, f10
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8218D844: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D848: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218D84C: 41980024  blt cr6, 0x8218d870
	if ctx.cr[6].lt {
	pc = 0x8218D870; continue 'dispatch;
	}
	// 8218D850: FC006090  fmr f0, f12
	ctx.f[0].f64 = ctx.f[12].f64;
	// 8218D854: 4800001C  b 0x8218d870
	pc = 0x8218D870; continue 'dispatch;
            }
            0x8218D858 => {
    //   block [0x8218D858..0x8218D870)
	// 8218D858: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218D85C: 41980014  blt cr6, 0x8218d870
	if ctx.cr[6].lt {
	pc = 0x8218D870; continue 'dispatch;
	}
	// 8218D860: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8218D864: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218D868: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218D86C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8218D870; continue 'dispatch;
            }
            0x8218D870 => {
    //   block [0x8218D870..0x8218D874)
	// 8218D870: EC005828  fsubs f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x8218D874; continue 'dispatch;
            }
            0x8218D874 => {
    //   block [0x8218D874..0x8218D908)
	// 8218D874: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D878: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8218D87C: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8218D880: C1AB2490  lfs f13, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D884: EC200372  fmuls f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8218D888: 4BF84549  bl 0x82111dd0
	ctx.lr = 0x8218D88C;
	sub_82111DD0(ctx, base);
	// 8218D88C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D890: C1A10050  lfs f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D894: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8218D898: 61699BA0  ori r9, r11, 0x9ba0
	ctx.r[9].u64 = ctx.r[11].u64 | 39840;
	// 8218D89C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D8A0: 61689BA8  ori r8, r11, 0x9ba8
	ctx.r[8].u64 = ctx.r[11].u64 | 39848;
	// 8218D8A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D8A8: 814B76FC  lwz r10, 0x76fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D8AC: 7C0A4C2E  lfsx f0, r10, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D8B0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D8B4: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218D8B8: 814B76FC  lwz r10, 0x76fc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D8BC: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D8C0: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D8C4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218D8C8: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218D8CC: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D8D0: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218D8D4: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218D8D8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218D8DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218D8E0: 4E800421  bctrl
	ctx.lr = 0x8218D8E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218D8E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218D8E8: C1A30034  lfs f13, 0x34(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D8EC: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8218D8F0: 917F0010  stw r11, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 8218D8F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D8F8: C00B2458  lfs f0, 0x2458(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D8FC: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D900: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218D904: 480000BC  b 0x8218d9c0
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D908 => {
    //   block [0x8218D908..0x8218D960)
	// 8218D908: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D90C: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 8218D910: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D914: C00B276C  lfs f0, 0x276c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D918: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D91C: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D920: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8218D924: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218D928: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D92C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D930: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D934: EC2D0028  fsubs f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218D938: 481DA269  bl 0x82367ba0
	ctx.lr = 0x8218D93C;
	sub_82367BA0(ctx, base);
	// 8218D93C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D940: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D944: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8218D948: C00B2070  lfs f0, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D94C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218D950: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D954: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D958: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D95C: 48000064  b 0x8218d9c0
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D960 => {
    //   block [0x8218D960..0x8218D9B4)
	// 8218D960: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218D964: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 8218D968: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D96C: C00B276C  lfs f0, 0x276c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10092 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D970: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218D974: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8218D978: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 8218D97C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D980: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D984: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D988: EC2D002A  fadds f1, f13, f0
	ctx.f[1].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218D98C: 481DA215  bl 0x82367ba0
	ctx.lr = 0x8218D990;
	sub_82367BA0(ctx, base);
	// 8218D990: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D994: D03F0028  stfs f1, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 8218D998: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	// 8218D99C: C00B2528  lfs f0, 0x2528(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218D9A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D9A4: D01F002C  stfs f0, 0x2c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8218D9A8: C1AB209C  lfs f13, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218D9AC: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218D9B0: 48000010  b 0x8218d9c0
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D9B4 => {
    //   block [0x8218D9B4..0x8218D9B8)
	// 8218D9B4: 93DF0038  stw r30, 0x38(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[30].u32 ) };
	pc = 0x8218D9B8; continue 'dispatch;
            }
            0x8218D9B8 => {
    //   block [0x8218D9B8..0x8218D9C0)
	// 8218D9B8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218D9BC: 4BFFFB55  bl 0x8218d510
	ctx.lr = 0x8218D9C0;
	sub_8218D510(ctx, base);
	pc = 0x8218D9C0; continue 'dispatch;
            }
            0x8218D9C0 => {
    //   block [0x8218D9C0..0x8218D9D8)
	// 8218D9C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218D9C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218D9C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218D9CC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218D9D0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218D9D4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218D9D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218D9D8 size=252
    let mut pc: u32 = 0x8218D9D8;
    'dispatch: loop {
        match pc {
            0x8218D9D8 => {
    //   block [0x8218D9D8..0x8218DAB4)
	// 8218D9D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218D9DC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218D9E0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218D9E4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218D9E8: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218D9EC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218D9F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218D9F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8218D9F8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218D9FC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8218DA00: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218DA04: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DA08: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218DA0C: 4BFFC4C5  bl 0x82189ed0
	ctx.lr = 0x8218DA10;
	sub_82189ED0(ctx, base);
	// 8218DA10: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218DA14: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218DA18: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218DA1C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8218DA20: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218DA24: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218DA28: D3FF00E0  stfs f31, 0xe0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8218DA2C: D3FF00E4  stfs f31, 0xe4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8218DA30: D3FF00E8  stfs f31, 0xe8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8218DA34: C00BD6D0  lfs f0, -0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DA38: D3FF0238  stfs f31, 0x238(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8218DA3C: D3FF0234  stfs f31, 0x234(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 8218DA40: D3FF0230  stfs f31, 0x230(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 8218DA44: 915F0074  stw r10, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 8218DA48: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218DA4C: 809E0004  lwz r4, 4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218DA50: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DA54: 4BFD804D  bl 0x82165aa0
	ctx.lr = 0x8218DA58;
	sub_82165AA0(ctx, base);
	// 8218DA58: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218DA5C: 907E01A0  stw r3, 0x1a0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(416 as u32), ctx.r[3].u32 ) };
	// 8218DA60: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218DA64: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218DA68: 91430148  stw r10, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[10].u32 ) };
	// 8218DA6C: 815E01A0  lwz r10, 0x1a0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(416 as u32) ) } as u64;
	// 8218DA70: C00BD4D4  lfs f0, -0x2b2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DA74: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8218DA78: D00A0078  stfs f0, 0x78(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218DA7C: 815E01A0  lwz r10, 0x1a0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(416 as u32) ) } as u64;
	// 8218DA80: 916A0074  stw r11, 0x74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218DA84: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DA88: 4BFAB481  bl 0x82138f08
	ctx.lr = 0x8218DA8C;
	sub_82138F08(ctx, base);
	// 8218DA8C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218DA90: 907E01A4  stw r3, 0x1a4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(420 as u32), ctx.r[3].u32 ) };
	// 8218DA94: 409A0020  bne cr6, 0x8218dab4
	if !ctx.cr[6].eq {
	pc = 0x8218DAB4; continue 'dispatch;
	}
	// 8218DA98: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218DA9C: 807E0008  lwz r3, 8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DAA0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218DAA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218DAA8: 48005CC9  bl 0x82193770
	ctx.lr = 0x8218DAAC;
	sub_82193770(ctx, base);
	// 8218DAAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218DAB0: 917E01A4  stw r11, 0x1a4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	pc = 0x8218DAB4; continue 'dispatch;
            }
            0x8218DAB4 => {
    //   block [0x8218DAB4..0x8218DAD4)
	// 8218DAB4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218DAB8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218DABC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218DAC0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218DAC4: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218DAC8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218DACC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218DAD0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218DAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218DAD8 size=204
    let mut pc: u32 = 0x8218DAD8;
    'dispatch: loop {
        match pc {
            0x8218DAD8 => {
    //   block [0x8218DAD8..0x8218DB60)
	// 8218DAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218DADC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218DAE0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218DAE4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218DAE8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218DAEC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218DAF0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218DAF4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218DAF8: 614A85F8  ori r10, r10, 0x85f8
	ctx.r[10].u64 = ctx.r[10].u64 | 34296;
	// 8218DAFC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218DB00: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218DB04: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DB08: 409A0084  bne cr6, 0x8218db8c
	if !ctx.cr[6].eq {
	pc = 0x8218DB8C; continue 'dispatch;
	}
	// 8218DB0C: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218DB10: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218DB14: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8218DB18: 419A0074  beq cr6, 0x8218db8c
	if ctx.cr[6].eq {
	pc = 0x8218DB8C; continue 'dispatch;
	}
	// 8218DB1C: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 8218DB20: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218DB24: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 8218DB28: 7FCAF378  mr r10, r30
	ctx.r[10].u64 = ctx.r[30].u64;
	// 8218DB2C: 914949EC  stw r10, 0x49ec(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(18924 as u32), ctx.r[10].u32 ) };
	// 8218DB30: 716A8003  andi. r10, r11, 0x8003
	ctx.r[10].u64 = ctx.r[11].u64 & 32771;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218DB34: 2B0A8003  cmplwi cr6, r10, 0x8003
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32771 as u32, &mut ctx.xer);
	// 8218DB38: 409A0034  bne cr6, 0x8218db6c
	if !ctx.cr[6].eq {
	pc = 0x8218DB6C; continue 'dispatch;
	}
	// 8218DB3C: 481D9A0D  bl 0x82367548
	ctx.lr = 0x8218DB40;
	sub_82367548(ctx, base);
	// 8218DB40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218DB44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218DB48: C00B2094  lfs f0, 0x2094(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DB4C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218DB50: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218DB54: C00B2428  lfs f0, 0x2428(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9256 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DB58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8218DB5C: 40980020  bge cr6, 0x8218db7c
	if !ctx.cr[6].lt {
	pc = 0x8218DB7C; continue 'dispatch;
	}
	pc = 0x8218DB60; continue 'dispatch;
            }
            0x8218DB60 => {
    //   block [0x8218DB60..0x8218DB6C)
	// 8218DB60: 48000049  bl 0x8218dba8
	ctx.lr = 0x8218DB64;
	sub_8218DBA8(ctx, base);
	// 8218DB64: 93DF0218  stw r30, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[30].u32 ) };
	// 8218DB68: 48000020  b 0x8218db88
	pc = 0x8218DB88; continue 'dispatch;
            }
            0x8218DB6C => {
    //   block [0x8218DB6C..0x8218DB7C)
	// 8218DB6C: 556B043E  clrlwi r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 8218DB70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218DB74: 2B0B8001  cmplwi cr6, r11, 0x8001
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32769 as u32, &mut ctx.xer);
	// 8218DB78: 419AFFE8  beq cr6, 0x8218db60
	if ctx.cr[6].eq {
	pc = 0x8218DB60; continue 'dispatch;
	}
	pc = 0x8218DB7C; continue 'dispatch;
            }
            0x8218DB7C => {
    //   block [0x8218DB7C..0x8218DB88)
	// 8218DB7C: 480002F5  bl 0x8218de70
	ctx.lr = 0x8218DB80;
	sub_8218DE70(ctx, base);
	// 8218DB80: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218DB84: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	pc = 0x8218DB88; continue 'dispatch;
            }
            0x8218DB88 => {
    //   block [0x8218DB88..0x8218DB8C)
	// 8218DB88: 93DF001C  stw r30, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
	pc = 0x8218DB8C; continue 'dispatch;
            }
            0x8218DB8C => {
    //   block [0x8218DB8C..0x8218DBA4)
	// 8218DB8C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218DB90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218DB94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218DB98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218DB9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218DBA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218DBA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218DBA8 size=712
    let mut pc: u32 = 0x8218DBA8;
    'dispatch: loop {
        match pc {
            0x8218DBA8 => {
    //   block [0x8218DBA8..0x8218DBD0)
	// 8218DBA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218DBAC: 483A750D  bl 0x825350b8
	ctx.lr = 0x8218DBB0;
	sub_82535080(ctx, base);
	// 8218DBB0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218DBB4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218DBB8: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8218DBBC: 614A7DF4  ori r10, r10, 0x7df4
	ctx.r[10].u64 = ctx.r[10].u64 | 32244;
	// 8218DBC0: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218DBC4: 7FCB502E  lwzx r30, r11, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218DBC8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8218DBCC: 409A0014  bne cr6, 0x8218dbe0
	if !ctx.cr[6].eq {
	pc = 0x8218DBE0; continue 'dispatch;
	}
	pc = 0x8218DBD0; continue 'dispatch;
            }
            0x8218DBD0 => {
    //   block [0x8218DBD0..0x8218DBE0)
	// 8218DBD0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8218DBD4: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 8218DBD8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218DBDC: 483A752C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8218DBE0 => {
    //   block [0x8218DBE0..0x8218DBF8)
	// 8218DBE0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218DBE4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8218DBE8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DBEC: 4199000C  bgt cr6, 0x8218dbf8
	if ctx.cr[6].gt {
	pc = 0x8218DBF8; continue 'dispatch;
	}
	// 8218DBF0: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8218DBF4: 48000020  b 0x8218dc14
	pc = 0x8218DC14; continue 'dispatch;
            }
            0x8218DBF8 => {
    //   block [0x8218DBF8..0x8218DC10)
	// 8218DBF8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218DBFC: 815E0008  lwz r10, 8(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DC00: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218DC04: 4082000C  bne 0x8218dc10
	if !ctx.cr[0].eq {
	pc = 0x8218DC10; continue 'dispatch;
	}
	// 8218DC08: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8218DC0C: 48000008  b 0x8218dc14
	pc = 0x8218DC14; continue 'dispatch;
            }
            0x8218DC10 => {
    //   block [0x8218DC10..0x8218DC14)
	// 8218DC10: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x8218DC14; continue 'dispatch;
            }
            0x8218DC14 => {
    //   block [0x8218DC14..0x8218DC2C)
	// 8218DC14: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	// 8218DC18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218DC1C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8218DC20: 4199000C  bgt cr6, 0x8218dc2c
	if ctx.cr[6].gt {
	pc = 0x8218DC2C; continue 'dispatch;
	}
	// 8218DC24: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8218DC28: 4800001C  b 0x8218dc44
	pc = 0x8218DC44; continue 'dispatch;
            }
            0x8218DC2C => {
    //   block [0x8218DC2C..0x8218DC44)
	// 8218DC2C: 817E0008  lwz r11, 8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218DC30: 815E000C  lwz r10, 0xc(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218DC34: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218DC38: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8218DC3C: 41820008  beq 0x8218dc44
	if ctx.cr[0].eq {
	pc = 0x8218DC44; continue 'dispatch;
	}
	// 8218DC40: 7D4BF214  add r10, r11, r30
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x8218DC44; continue 'dispatch;
            }
            0x8218DC44 => {
    //   block [0x8218DC44..0x8218DC8C)
	// 8218DC44: A17F0238  lhz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218DC48: 915F01AC  stw r10, 0x1ac(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(428 as u32), ctx.r[10].u32 ) };
	// 8218DC4C: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 8218DC50: A12A0002  lhz r9, 2(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(2 as u32) ) } as u64;
	// 8218DC54: 7F095800  cmpw cr6, r9, r11
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8218DC58: 4198FF78  blt cr6, 0x8218dbd0
	if ctx.cr[6].lt {
	pc = 0x8218DBD0; continue 'dispatch;
	}
	// 8218DC5C: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8218DC60: 7F9DE378  mr r29, r28
	ctx.r[29].u64 = ctx.r[28].u64;
	// 8218DC64: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8218DC68: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DC6C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218DC70: A16B0018  lhz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8218DC74: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 8218DC78: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218DC7C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218DC80: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218DC84: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8218DC88: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x8218DC8C; continue 'dispatch;
            }
            0x8218DC8C => {
    //   block [0x8218DC8C..0x8218DD38)
	// 8218DC8C: 481D98BD  bl 0x82367548
	ctx.lr = 0x8218DC90;
	sub_82367548(ctx, base);
	// 8218DC90: EC010332  fmuls f0, f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[12].f64) as f32) as f64);
	// 8218DC94: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8218DC98: 817F0234  lwz r11, 0x234(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(564 as u32) ) } as u64;
	// 8218DC9C: 80FF01A4  lwz r7, 0x1a4(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 8218DCA0: 80DF023C  lwz r6, 0x23c(r31)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218DCA4: 811F01AC  lwz r8, 0x1ac(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(428 as u32) ) } as u64;
	// 8218DCA8: 815F01A8  lwz r10, 0x1a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 8218DCAC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8218DCB0: 7C004FAE  stfiwx f0, 0, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 8218DCB4: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8218DCB8: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8218DCBC: 5569103A  slwi r9, r11, 2
	ctx.r[9].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8218DCC0: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8218DCC4: 7D295A14  add r9, r9, r11
	ctx.r[9].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 8218DCC8: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 8218DCCC: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 8218DCD0: 816702F0  lwz r11, 0x2f0(r7)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(752 as u32) ) } as u64;
	// 8218DCD4: 5529083C  slwi r9, r9, 1
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(1);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8218DCD8: 7D6B3050  subf r11, r11, r6
	ctx.r[11].s64 = ctx.r[6].s64 - ctx.r[11].s64;
	// 8218DCDC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8218DCE0: 7D29422E  lhzx r9, r9, r8
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8218DCE4: 5568DFFE  rlwinm r8, r11, 0x1b, 0x1f, 0x1f
	ctx.r[8].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8218DCE8: 1D69007C  mulli r11, r9, 0x7c
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 124 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218DCEC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218DCF0: A14B0036  lhz r10, 0x36(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(54 as u32) ) } as u64;
	// 8218DCF4: A16B0034  lhz r11, 0x34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) } as u64;
	// 8218DCF8: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8218DCFC: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8218DD00: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8218DD04: 5567DFFE  rlwinm r7, r11, 0x1b, 0x1f, 0x1f
	ctx.r[7].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 8218DD08: 694B0001  xori r11, r10, 1
	ctx.r[11].u64 = ctx.r[10].u64 ^ 1;
	// 8218DD0C: 7F083840  cmplw cr6, r8, r7
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[7].u32, &mut ctx.xer);
	// 8218DD10: 419A0028  beq cr6, 0x8218dd38
	if ctx.cr[6].eq {
	pc = 0x8218DD38; continue 'dispatch;
	}
	// 8218DD14: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DD18: 409A0028  bne cr6, 0x8218dd40
	if !ctx.cr[6].eq {
	pc = 0x8218DD40; continue 'dispatch;
	}
	// 8218DD1C: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8218DD20: 2F1D0064  cmpwi cr6, r29, 0x64
	ctx.cr[6].compare_i32(ctx.r[29].s32, 100, &mut ctx.xer);
	// 8218DD24: 4198FF68  blt cr6, 0x8218dc8c
	if ctx.cr[6].lt {
	pc = 0x8218DC8C; continue 'dispatch;
	}
	// 8218DD28: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8218DD2C: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 8218DD30: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218DD34: 483A73D4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8218DD38 => {
    //   block [0x8218DD38..0x8218DD40)
	// 8218DD38: 939F0078  stw r28, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[28].u32 ) };
	// 8218DD3C: 4800000C  b 0x8218dd48
	pc = 0x8218DD48; continue 'dispatch;
            }
            0x8218DD40 => {
    //   block [0x8218DD40..0x8218DD48)
	// 8218DD40: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218DD44: 917F0078  stw r11, 0x78(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), ctx.r[11].u32 ) };
	pc = 0x8218DD48; continue 'dispatch;
            }
            0x8218DD48 => {
    //   block [0x8218DD48..0x8218DD60)
	// 8218DD48: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218DD4C: 39690002  addi r11, r9, 2
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	// 8218DD50: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8218DD54: 4199000C  bgt cr6, 0x8218dd60
	if ctx.cr[6].gt {
	pc = 0x8218DD60; continue 'dispatch;
	}
	// 8218DD58: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8218DD5C: 48000030  b 0x8218dd8c
	pc = 0x8218DD8C; continue 'dispatch;
            }
            0x8218DD60 => {
    //   block [0x8218DD60..0x8218DD88)
	// 8218DD60: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 8218DD64: 390B0002  addi r8, r11, 2
	ctx.r[8].s64 = ctx.r[11].s64 + 2;
	// 8218DD68: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218DD6C: 5508103A  slwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8218DD70: 7D4AF02E  lwzx r10, r10, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218DD74: 7D08F02E  lwzx r8, r8, r30
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218DD78: 7D0A4051  subf. r8, r10, r8
	ctx.r[8].s64 = ctx.r[8].s64 - ctx.r[10].s64;
	ctx.cr[0].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8218DD7C: 4082000C  bne 0x8218dd88
	if !ctx.cr[0].eq {
	pc = 0x8218DD88; continue 'dispatch;
	}
	// 8218DD80: 7F8AE378  mr r10, r28
	ctx.r[10].u64 = ctx.r[28].u64;
	// 8218DD84: 48000008  b 0x8218dd8c
	pc = 0x8218DD8C; continue 'dispatch;
            }
            0x8218DD88 => {
    //   block [0x8218DD88..0x8218DD8C)
	// 8218DD88: 7D4AF214  add r10, r10, r30
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[30].u64;
	pc = 0x8218DD8C; continue 'dispatch;
            }
            0x8218DD8C => {
    //   block [0x8218DD8C..0x8218DDA8)
	// 8218DD8C: 915F0244  stw r10, 0x244(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(580 as u32), ctx.r[10].u32 ) };
	// 8218DD90: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8218DD94: 939F0240  stw r28, 0x240(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(576 as u32), ctx.r[28].u32 ) };
	// 8218DD98: 915F0248  stw r10, 0x248(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(584 as u32), ctx.r[10].u32 ) };
	// 8218DD9C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218DDA0: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8218DDA4: 4199000C  bgt cr6, 0x8218ddb0
	if ctx.cr[6].gt {
	pc = 0x8218DDB0; continue 'dispatch;
	}
	pc = 0x8218DDA8; continue 'dispatch;
            }
            0x8218DDA8 => {
    //   block [0x8218DDA8..0x8218DDB0)
	// 8218DDA8: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8218DDAC: 48000028  b 0x8218ddd4
	pc = 0x8218DDD4; continue 'dispatch;
            }
            0x8218DDB0 => {
    //   block [0x8218DDB0..0x8218DDD4)
	// 8218DDB0: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 8218DDB4: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 8218DDB8: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8218DDBC: 5568103A  slwi r8, r11, 2
	ctx.r[8].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8218DDC0: 7D6AF02E  lwzx r11, r10, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218DDC4: 7D48F02E  lwzx r10, r8, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8218DDC8: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218DDCC: 4182FFDC  beq 0x8218dda8
	if ctx.cr[0].eq {
	pc = 0x8218DDA8; continue 'dispatch;
	}
	// 8218DDD0: 7D6BF214  add r11, r11, r30
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	pc = 0x8218DDD4; continue 'dispatch;
            }
            0x8218DDD4 => {
    //   block [0x8218DDD4..0x8218DE70)
	// 8218DDD4: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218DDD8: 1D69007C  mulli r11, r9, 0x7c
	ctx.r[11].s32 = ((ctx.r[9].s32 as i64 * 124 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218DDDC: 7D4807B4  extsw r8, r10
	ctx.r[8].s64 = ctx.r[10].s32 as i64;
	// 8218DDE0: 815F01A8  lwz r10, 0x1a8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 8218DDE4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8218DDE8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218DDEC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 8218DDF0: F9010050  std r8, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[8].u64 ) };
	// 8218DDF4: 390B003E  addi r8, r11, 0x3e
	ctx.r[8].s64 = ctx.r[11].s64 + 62;
	// 8218DDF8: C0091FF8  lfs f0, 0x1ff8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DDFC: 392B003C  addi r9, r11, 0x3c
	ctx.r[9].s64 = ctx.r[11].s64 + 60;
	// 8218DE00: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218DE04: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218DE08: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218DE0C: D1BF0204  stfs f13, 0x204(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), tmp.u32 ) };
	// 8218DE10: A0EB0038  lhz r7, 0x38(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) } as u64;
	// 8218DE14: 7CE707B4  extsw r7, r7
	ctx.r[7].s64 = ctx.r[7].s32 as i64;
	// 8218DE18: F8E10050  std r7, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[7].u64 ) };
	// 8218DE1C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218DE20: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218DE24: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218DE28: D1BF021C  stfs f13, 0x21c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(540 as u32), tmp.u32 ) };
	// 8218DE2C: A16B003A  lhz r11, 0x3a(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(58 as u32) ) } as u64;
	// 8218DE30: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218DE34: 913F007C  stw r9, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[9].u32 ) };
	// 8218DE38: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218DE3C: 911F0080  stw r8, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 8218DE40: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 8218DE44: 915F006C  stw r10, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[10].u32 ) };
	// 8218DE48: 939F0074  stw r28, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[28].u32 ) };
	// 8218DE4C: 939F0010  stw r28, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[28].u32 ) };
	// 8218DE50: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218DE54: 939F0228  stw r28, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[28].u32 ) };
	// 8218DE58: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218DE5C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8218DE60: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218DE64: D01F0220  stfs f0, 0x220(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(544 as u32), tmp.u32 ) };
	// 8218DE68: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218DE6C: 483A729C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218DE70(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218DE70 size=2236
    let mut pc: u32 = 0x8218DE70;
    'dispatch: loop {
        match pc {
            0x8218DE70 => {
    //   block [0x8218DE70..0x8218DEEC)
	// 8218DE70: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218DE74: 483A7239  bl 0x825350ac
	ctx.lr = 0x8218DE78;
	sub_82535080(ctx, base);
	// 8218DE78: DBE1FFB8  stfd f31, -0x48(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8218DE7C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218DE80: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218DE84: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8218DE88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218DE8C: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8218DE90: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8218DE94: 839F01A0  lwz r28, 0x1a0(r31)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 8218DE98: 935F0208  stw r26, 0x208(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(520 as u32), ctx.r[26].u32 ) };
	// 8218DE9C: 935F020C  stw r26, 0x20c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(524 as u32), ctx.r[26].u32 ) };
	// 8218DEA0: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DEA4: 935F0210  stw r26, 0x210(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(528 as u32), ctx.r[26].u32 ) };
	// 8218DEA8: D01C0078  stfs f0, 0x78(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218DEAC: 913C0074  stw r9, 0x74(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 8218DEB0: 817F01A4  lwz r11, 0x1a4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 8218DEB4: 815F023C  lwz r10, 0x23c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218DEB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218DEBC: 836B02F0  lwz r27, 0x2f0(r11)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(752 as u32) ) } as u64;
	// 8218DEC0: C18B0050  lfs f12, 0x50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218DEC4: C00B0054  lfs f0, 0x54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218DEC8: C16B0070  lfs f11, 0x70(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218DECC: C14B0060  lfs f10, 0x60(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218DED0: C04B0064  lfs f2, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8218DED4: C06B0068  lfs f3, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8218DED8: 419A0018  beq cr6, 0x8218def0
	if ctx.cr[6].eq {
	pc = 0x8218DEF0; continue 'dispatch;
	}
	// 8218DEDC: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8218DEE0: 409A000C  bne cr6, 0x8218deec
	if !ctx.cr[6].eq {
	pc = 0x8218DEEC; continue 'dispatch;
	}
	// 8218DEE4: 935F0214  stw r26, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[26].u32 ) };
	// 8218DEE8: 48000008  b 0x8218def0
	pc = 0x8218DEF0; continue 'dispatch;
            }
            0x8218DEEC => {
    //   block [0x8218DEEC..0x8218DEF0)
	// 8218DEEC: 93BF0214  stw r29, 0x214(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(532 as u32), ctx.r[29].u32 ) };
	pc = 0x8218DEF0; continue 'dispatch;
            }
            0x8218DEF0 => {
    //   block [0x8218DEF0..0x8218DF24)
	// 8218DEF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218DEF4: 815F0238  lwz r10, 0x238(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218DEF8: D19F01C8  stfs f12, 0x1c8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 8218DEFC: 7F5ED378  mr r30, r26
	ctx.r[30].u64 = ctx.r[26].u64;
	// 8218DF00: D01F01CC  stfs f0, 0x1cc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 8218DF04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218DF08: D17F01D0  stfs f11, 0x1d0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 8218DF0C: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 8218DF10: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218DF14: D3FF01F8  stfs f31, 0x1f8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 8218DF18: D3FF0200  stfs f31, 0x200(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 8218DF1C: 409A0008  bne cr6, 0x8218df24
	if !ctx.cr[6].eq {
	pc = 0x8218DF24; continue 'dispatch;
	}
	// 8218DF20: 7FBEEB78  mr r30, r29
	ctx.r[30].u64 = ctx.r[29].u64;
	pc = 0x8218DF24; continue 'dispatch;
            }
            0x8218DF24 => {
    //   block [0x8218DF24..0x8218DF4C)
	// 8218DF24: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8218DF28: 3B200004  li r25, 4
	ctx.r[25].s64 = 4;
	// 8218DF2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DF30: 419A011C  beq cr6, 0x8218e04c
	if ctx.cr[6].eq {
	pc = 0x8218E04C; continue 'dispatch;
	}
	// 8218DF34: 554B07BC  rlwinm r11, r10, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DF38: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8218DF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DF40: 419A000C  beq cr6, 0x8218df4c
	if ctx.cr[6].eq {
	pc = 0x8218DF4C; continue 'dispatch;
	}
	// 8218DF44: 93410050  stw r26, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[26].u32 ) };
	// 8218DF48: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	pc = 0x8218DF4C; continue 'dispatch;
            }
            0x8218DF4C => {
    //   block [0x8218DF4C..0x8218DF68)
	// 8218DF4C: 554B077A  rlwinm r11, r10, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DF50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DF54: 419A0014  beq cr6, 0x8218df68
	if ctx.cr[6].eq {
	pc = 0x8218DF68; continue 'dispatch;
	}
	// 8218DF58: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DF5C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8218DF60: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DF64: 7FAB412E  stwx r29, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[29].u32) };
	pc = 0x8218DF68; continue 'dispatch;
            }
            0x8218DF68 => {
    //   block [0x8218DF68..0x8218DF88)
	// 8218DF68: 554B0738  rlwinm r11, r10, 0, 0x1c, 0x1c
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DF6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DF70: 419A0018  beq cr6, 0x8218df88
	if ctx.cr[6].eq {
	pc = 0x8218DF88; continue 'dispatch;
	}
	// 8218DF74: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DF78: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8218DF7C: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	// 8218DF80: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DF84: 7CEB412E  stwx r7, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	pc = 0x8218DF88; continue 'dispatch;
            }
            0x8218DF88 => {
    //   block [0x8218DF88..0x8218DFA4)
	// 8218DF88: 554B06F6  rlwinm r11, r10, 0, 0x1b, 0x1b
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DF8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DF90: 419A0014  beq cr6, 0x8218dfa4
	if ctx.cr[6].eq {
	pc = 0x8218DFA4; continue 'dispatch;
	}
	// 8218DF94: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DF98: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8218DF9C: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DFA0: 7D2B412E  stwx r9, r11, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32), ctx.r[9].u32) };
	pc = 0x8218DFA4; continue 'dispatch;
            }
            0x8218DFA4 => {
    //   block [0x8218DFA4..0x8218DFC0)
	// 8218DFA4: 554B06B4  rlwinm r11, r10, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DFA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DFAC: 419A0014  beq cr6, 0x8218dfc0
	if ctx.cr[6].eq {
	pc = 0x8218DFC0; continue 'dispatch;
	}
	// 8218DFB0: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DFB4: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8218DFB8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DFBC: 7F2B492E  stwx r25, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[25].u32) };
	pc = 0x8218DFC0; continue 'dispatch;
            }
            0x8218DFC0 => {
    //   block [0x8218DFC0..0x8218DFE0)
	// 8218DFC0: 554B0672  rlwinm r11, r10, 0, 0x19, 0x19
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DFC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DFC8: 419A0018  beq cr6, 0x8218dfe0
	if ctx.cr[6].eq {
	pc = 0x8218DFE0; continue 'dispatch;
	}
	// 8218DFCC: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DFD0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8218DFD4: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 8218DFD8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DFDC: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	pc = 0x8218DFE0; continue 'dispatch;
            }
            0x8218DFE0 => {
    //   block [0x8218DFE0..0x8218E000)
	// 8218DFE0: 554B0630  rlwinm r11, r10, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218DFE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218DFE8: 419A0018  beq cr6, 0x8218e000
	if ctx.cr[6].eq {
	pc = 0x8218E000; continue 'dispatch;
	}
	// 8218DFEC: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218DFF0: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 8218DFF4: 39000006  li r8, 6
	ctx.r[8].s64 = 6;
	// 8218DFF8: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218DFFC: 7D0B492E  stwx r8, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[8].u32) };
	pc = 0x8218E000; continue 'dispatch;
            }
            0x8218E000 => {
    //   block [0x8218E000..0x8218E020)
	// 8218E000: 554B05EE  rlwinm r11, r10, 0, 0x17, 0x17
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E004: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E008: 419A0018  beq cr6, 0x8218e020
	if ctx.cr[6].eq {
	pc = 0x8218E020; continue 'dispatch;
	}
	// 8218E00C: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218E010: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8218E014: 39200007  li r9, 7
	ctx.r[9].s64 = 7;
	// 8218E018: 38630001  addi r3, r3, 1
	ctx.r[3].s64 = ctx.r[3].s64 + 1;
	// 8218E01C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	pc = 0x8218E020; continue 'dispatch;
            }
            0x8218E020 => {
    //   block [0x8218E020..0x8218E04C)
	// 8218E020: 4BFAB191  bl 0x821391b0
	ctx.lr = 0x8218E024;
	sub_821391B0(ctx, base);
	// 8218E024: 5468103A  slwi r8, r3, 2
	ctx.r[8].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8218E028: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 8218E02C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218E030: 3D2082C0  lis r9, -0x7d40
	ctx.r[9].s64 = -2101346304;
	// 8218E034: 394B6560  addi r10, r11, 0x6560
	ctx.r[10].s64 = ctx.r[11].s64 + 25952;
	// 8218E038: 7D68382E  lwzx r11, r8, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 8218E03C: 9169B9C8  stw r11, -0x4638(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(-17976 as u32), ctx.r[11].u32 ) };
	// 8218E040: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8218E044: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218E048: 48000360  b 0x8218e3a8
	pc = 0x8218E3A8; continue 'dispatch;
            }
            0x8218E04C => {
    //   block [0x8218E04C..0x8218E090)
	// 8218E04C: 554B06FC  rlwinm r11, r10, 0, 0x1b, 0x1e
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E050: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E054: 409A006C  bne cr6, 0x8218e0c0
	if !ctx.cr[6].eq {
	pc = 0x8218E0C0; continue 'dispatch;
	}
	// 8218E058: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8218E05C: 4BFAB155  bl 0x821391b0
	ctx.lr = 0x8218E060;
	sub_821391B0(ctx, base);
	// 8218E060: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E064: 4199005C  bgt cr6, 0x8218e0c0
	if ctx.cr[6].gt {
	pc = 0x8218E0C0; continue 'dispatch;
	}
	// 8218E068: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218E06C: 398CE080  addi r12, r12, -0x1f80
	ctx.r[12].s64 = ctx.r[12].s64 + -8064;
	// 8218E070: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218E074: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218E078: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218E07C: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x8218E090; continue 'dispatch;
		},
		1 => {
	pc = 0x8218E09C; continue 'dispatch;
		},
		2 => {
	pc = 0x8218E0A8; continue 'dispatch;
		},
		3 => {
	pc = 0x8218E0B4; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218E080: 8218E090  lwz r16, -0x1f70(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-8048 as u32) ) } as u64;
	// 8218E084: 8218E09C  lwz r16, -0x1f64(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-8036 as u32) ) } as u64;
	// 8218E088: 8218E0A8  lwz r16, -0x1f58(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-8024 as u32) ) } as u64;
	// 8218E08C: 8218E0B4  lwz r16, -0x1f4c(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-8012 as u32) ) } as u64;
            }
            0x8218E090 => {
    //   block [0x8218E090..0x8218E09C)
	// 8218E090: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E094: 616B0002  ori r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 2;
	// 8218E098: 48000024  b 0x8218e0bc
	pc = 0x8218E0BC; continue 'dispatch;
            }
            0x8218E09C => {
    //   block [0x8218E09C..0x8218E0A8)
	// 8218E09C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E0A0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8218E0A4: 48000018  b 0x8218e0bc
	pc = 0x8218E0BC; continue 'dispatch;
            }
            0x8218E0A8 => {
    //   block [0x8218E0A8..0x8218E0B4)
	// 8218E0A8: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E0AC: 616B0008  ori r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 8;
	// 8218E0B0: 4800000C  b 0x8218e0bc
	pc = 0x8218E0BC; continue 'dispatch;
            }
            0x8218E0B4 => {
    //   block [0x8218E0B4..0x8218E0BC)
	// 8218E0B4: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E0B8: 616B0010  ori r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 16;
	pc = 0x8218E0BC; continue 'dispatch;
            }
            0x8218E0BC => {
    //   block [0x8218E0BC..0x8218E0C0)
	// 8218E0BC: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E0C0; continue 'dispatch;
            }
            0x8218E0C0 => {
    //   block [0x8218E0C0..0x8218E108)
	// 8218E0C0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E0C4: 556B05F4  rlwinm r11, r11, 0, 0x17, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E0C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E0CC: 409A006C  bne cr6, 0x8218e138
	if !ctx.cr[6].eq {
	pc = 0x8218E138; continue 'dispatch;
	}
	// 8218E0D0: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8218E0D4: 4BFAB0DD  bl 0x821391b0
	ctx.lr = 0x8218E0D8;
	sub_821391B0(ctx, base);
	// 8218E0D8: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E0DC: 4199005C  bgt cr6, 0x8218e138
	if ctx.cr[6].gt {
	pc = 0x8218E138; continue 'dispatch;
	}
	// 8218E0E0: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218E0E4: 398CE0F8  addi r12, r12, -0x1f08
	ctx.r[12].s64 = ctx.r[12].s64 + -7944;
	// 8218E0E8: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218E0EC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218E0F0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218E0F4: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x8218E108; continue 'dispatch;
		},
		1 => {
	pc = 0x8218E114; continue 'dispatch;
		},
		2 => {
	pc = 0x8218E120; continue 'dispatch;
		},
		3 => {
	pc = 0x8218E12C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218E0F8: 8218E108  lwz r16, -0x1ef8(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7928 as u32) ) } as u64;
	// 8218E0FC: 8218E114  lwz r16, -0x1eec(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7916 as u32) ) } as u64;
	// 8218E100: 8218E120  lwz r16, -0x1ee0(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7904 as u32) ) } as u64;
	// 8218E104: 8218E12C  lwz r16, -0x1ed4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7892 as u32) ) } as u64;
            }
            0x8218E108 => {
    //   block [0x8218E108..0x8218E114)
	// 8218E108: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E10C: 616B0020  ori r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 32;
	// 8218E110: 48000024  b 0x8218e134
	pc = 0x8218E134; continue 'dispatch;
            }
            0x8218E114 => {
    //   block [0x8218E114..0x8218E120)
	// 8218E114: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E118: 616B0040  ori r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 64;
	// 8218E11C: 48000018  b 0x8218e134
	pc = 0x8218E134; continue 'dispatch;
            }
            0x8218E120 => {
    //   block [0x8218E120..0x8218E12C)
	// 8218E120: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E124: 616B0080  ori r11, r11, 0x80
	ctx.r[11].u64 = ctx.r[11].u64 | 128;
	// 8218E128: 4800000C  b 0x8218e134
	pc = 0x8218E134; continue 'dispatch;
            }
            0x8218E12C => {
    //   block [0x8218E12C..0x8218E134)
	// 8218E12C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E130: 616B0100  ori r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 256;
	pc = 0x8218E134; continue 'dispatch;
            }
            0x8218E134 => {
    //   block [0x8218E134..0x8218E138)
	// 8218E134: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E138; continue 'dispatch;
            }
            0x8218E138 => {
    //   block [0x8218E138..0x8218E170)
	// 8218E138: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E13C: 556B052C  rlwinm r11, r11, 0, 0x14, 0x16
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E140: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E144: 409A0044  bne cr6, 0x8218e188
	if !ctx.cr[6].eq {
	pc = 0x8218E188; continue 'dispatch;
	}
	// 8218E148: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8218E14C: 4BFAB065  bl 0x821391b0
	ctx.lr = 0x8218E150;
	sub_821391B0(ctx, base);
	// 8218E150: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E154: 41980028  blt cr6, 0x8218e17c
	if ctx.cr[6].lt {
	pc = 0x8218E17C; continue 'dispatch;
	}
	// 8218E158: 419A0018  beq cr6, 0x8218e170
	if ctx.cr[6].eq {
	pc = 0x8218E170; continue 'dispatch;
	}
	// 8218E15C: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E160: 40980028  bge cr6, 0x8218e188
	if !ctx.cr[6].lt {
	pc = 0x8218E188; continue 'dispatch;
	}
	// 8218E164: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E168: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 8218E16C: 48000018  b 0x8218e184
	pc = 0x8218E184; continue 'dispatch;
            }
            0x8218E170 => {
    //   block [0x8218E170..0x8218E17C)
	// 8218E170: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E174: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 8218E178: 4800000C  b 0x8218e184
	pc = 0x8218E184; continue 'dispatch;
            }
            0x8218E17C => {
    //   block [0x8218E17C..0x8218E184)
	// 8218E17C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E180: 616B0200  ori r11, r11, 0x200
	ctx.r[11].u64 = ctx.r[11].u64 | 512;
	pc = 0x8218E184; continue 'dispatch;
            }
            0x8218E184 => {
    //   block [0x8218E184..0x8218E188)
	// 8218E184: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E188; continue 'dispatch;
            }
            0x8218E188 => {
    //   block [0x8218E188..0x8218E1CC)
	// 8218E188: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E18C: 556A0424  rlwinm r10, r11, 0, 0x10, 0x12
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E190: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E194: 409A0050  bne cr6, 0x8218e1e4
	if !ctx.cr[6].eq {
	pc = 0x8218E1E4; continue 'dispatch;
	}
	// 8218E198: 556B06B4  rlwinm r11, r11, 0, 0x1a, 0x1a
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E19C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E1A0: 409A0044  bne cr6, 0x8218e1e4
	if !ctx.cr[6].eq {
	pc = 0x8218E1E4; continue 'dispatch;
	}
	// 8218E1A4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8218E1A8: 4BFAB009  bl 0x821391b0
	ctx.lr = 0x8218E1AC;
	sub_821391B0(ctx, base);
	// 8218E1AC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E1B0: 41980028  blt cr6, 0x8218e1d8
	if ctx.cr[6].lt {
	pc = 0x8218E1D8; continue 'dispatch;
	}
	// 8218E1B4: 419A0018  beq cr6, 0x8218e1cc
	if ctx.cr[6].eq {
	pc = 0x8218E1CC; continue 'dispatch;
	}
	// 8218E1B8: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E1BC: 40980028  bge cr6, 0x8218e1e4
	if !ctx.cr[6].lt {
	pc = 0x8218E1E4; continue 'dispatch;
	}
	// 8218E1C0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E1C4: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 8218E1C8: 48000018  b 0x8218e1e0
	pc = 0x8218E1E0; continue 'dispatch;
            }
            0x8218E1CC => {
    //   block [0x8218E1CC..0x8218E1D8)
	// 8218E1CC: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E1D0: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 8218E1D4: 4800000C  b 0x8218e1e0
	pc = 0x8218E1E0; continue 'dispatch;
            }
            0x8218E1D8 => {
    //   block [0x8218E1D8..0x8218E1E0)
	// 8218E1D8: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E1DC: 616B2000  ori r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 8192;
	pc = 0x8218E1E0; continue 'dispatch;
            }
            0x8218E1E0 => {
    //   block [0x8218E1E0..0x8218E1E4)
	// 8218E1E0: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E1E4; continue 'dispatch;
            }
            0x8218E1E4 => {
    //   block [0x8218E1E4..0x8218E21C)
	// 8218E1E4: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E1E8: 556B035E  rlwinm r11, r11, 0, 0xd, 0xf
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E1EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E1F0: 409A0044  bne cr6, 0x8218e234
	if !ctx.cr[6].eq {
	pc = 0x8218E234; continue 'dispatch;
	}
	// 8218E1F4: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 8218E1F8: 4BFAAFB9  bl 0x821391b0
	ctx.lr = 0x8218E1FC;
	sub_821391B0(ctx, base);
	// 8218E1FC: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E200: 41980028  blt cr6, 0x8218e228
	if ctx.cr[6].lt {
	pc = 0x8218E228; continue 'dispatch;
	}
	// 8218E204: 419A0018  beq cr6, 0x8218e21c
	if ctx.cr[6].eq {
	pc = 0x8218E21C; continue 'dispatch;
	}
	// 8218E208: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E20C: 40980028  bge cr6, 0x8218e234
	if !ctx.cr[6].lt {
	pc = 0x8218E234; continue 'dispatch;
	}
	// 8218E210: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E214: 656B0004  oris r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 262144;
	// 8218E218: 48000018  b 0x8218e230
	pc = 0x8218E230; continue 'dispatch;
            }
            0x8218E21C => {
    //   block [0x8218E21C..0x8218E228)
	// 8218E21C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E220: 656B0002  oris r11, r11, 2
	ctx.r[11].u64 = ctx.r[11].u64 | 131072;
	// 8218E224: 4800000C  b 0x8218e230
	pc = 0x8218E230; continue 'dispatch;
            }
            0x8218E228 => {
    //   block [0x8218E228..0x8218E230)
	// 8218E228: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E22C: 656B0001  oris r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 65536;
	pc = 0x8218E230; continue 'dispatch;
            }
            0x8218E230 => {
    //   block [0x8218E230..0x8218E234)
	// 8218E230: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E234; continue 'dispatch;
            }
            0x8218E234 => {
    //   block [0x8218E234..0x8218E274)
	// 8218E234: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E238: 556A02D8  rlwinm r10, r11, 0, 0xb, 0xc
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E23C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E240: 409A0040  bne cr6, 0x8218e280
	if !ctx.cr[6].eq {
	pc = 0x8218E280; continue 'dispatch;
	}
	// 8218E244: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E248: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E24C: 409A0034  bne cr6, 0x8218e280
	if !ctx.cr[6].eq {
	pc = 0x8218E280; continue 'dispatch;
	}
	// 8218E250: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8218E254: 4BFAAF5D  bl 0x821391b0
	ctx.lr = 0x8218E258;
	sub_821391B0(ctx, base);
	// 8218E258: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8218E25C: 419A0018  beq cr6, 0x8218e274
	if ctx.cr[6].eq {
	pc = 0x8218E274; continue 'dispatch;
	}
	// 8218E260: 2F030002  cmpwi cr6, r3, 2
	ctx.cr[6].compare_i32(ctx.r[3].s32, 2, &mut ctx.xer);
	// 8218E264: 409A001C  bne cr6, 0x8218e280
	if !ctx.cr[6].eq {
	pc = 0x8218E280; continue 'dispatch;
	}
	// 8218E268: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E26C: 656B0010  oris r11, r11, 0x10
	ctx.r[11].u64 = ctx.r[11].u64 | 1048576;
	// 8218E270: 4800000C  b 0x8218e27c
	pc = 0x8218E27C; continue 'dispatch;
            }
            0x8218E274 => {
    //   block [0x8218E274..0x8218E27C)
	// 8218E274: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E278: 656B0008  oris r11, r11, 8
	ctx.r[11].u64 = ctx.r[11].u64 | 524288;
	pc = 0x8218E27C; continue 'dispatch;
            }
            0x8218E27C => {
    //   block [0x8218E27C..0x8218E280)
	// 8218E27C: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E280; continue 'dispatch;
            }
            0x8218E280 => {
    //   block [0x8218E280..0x8218E2B0)
	// 8218E280: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E284: 556B0214  rlwinm r11, r11, 0, 8, 0xa
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E28C: 409A0030  bne cr6, 0x8218e2bc
	if !ctx.cr[6].eq {
	pc = 0x8218E2BC; continue 'dispatch;
	}
	// 8218E290: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8218E294: 4BFAAF1D  bl 0x821391b0
	ctx.lr = 0x8218E298;
	sub_821391B0(ctx, base);
	// 8218E298: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E29C: 41980014  blt cr6, 0x8218e2b0
	if ctx.cr[6].lt {
	pc = 0x8218E2B0; continue 'dispatch;
	}
	// 8218E2A0: 409A001C  bne cr6, 0x8218e2bc
	if !ctx.cr[6].eq {
	pc = 0x8218E2BC; continue 'dispatch;
	}
	// 8218E2A4: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E2A8: 656B0040  oris r11, r11, 0x40
	ctx.r[11].u64 = ctx.r[11].u64 | 4194304;
	// 8218E2AC: 4800000C  b 0x8218e2b8
	pc = 0x8218E2B8; continue 'dispatch;
            }
            0x8218E2B0 => {
    //   block [0x8218E2B0..0x8218E2B8)
	// 8218E2B0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E2B4: 656B0020  oris r11, r11, 0x20
	ctx.r[11].u64 = ctx.r[11].u64 | 2097152;
	pc = 0x8218E2B8; continue 'dispatch;
            }
            0x8218E2B8 => {
    //   block [0x8218E2B8..0x8218E2BC)
	// 8218E2B8: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E2BC; continue 'dispatch;
            }
            0x8218E2BC => {
    //   block [0x8218E2BC..0x8218E304)
	// 8218E2BC: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E2C0: 556B010E  rlwinm r11, r11, 0, 4, 7
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E2C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E2C8: 409A006C  bne cr6, 0x8218e334
	if !ctx.cr[6].eq {
	pc = 0x8218E334; continue 'dispatch;
	}
	// 8218E2CC: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 8218E2D0: 4BFAAEE1  bl 0x821391b0
	ctx.lr = 0x8218E2D4;
	sub_821391B0(ctx, base);
	// 8218E2D4: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 8218E2D8: 4199005C  bgt cr6, 0x8218e334
	if ctx.cr[6].gt {
	pc = 0x8218E334; continue 'dispatch;
	}
	// 8218E2DC: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8218E2E0: 398CE2F4  addi r12, r12, -0x1d0c
	ctx.r[12].s64 = ctx.r[12].s64 + -7436;
	// 8218E2E4: 5460103A  slwi r0, r3, 2
	ctx.r[0].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8218E2E8: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8218E2EC: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8218E2F0: 4E800420  bctr
	match ctx.r[3].u64 {
		0 => {
	pc = 0x8218E304; continue 'dispatch;
		},
		1 => {
	pc = 0x8218E310; continue 'dispatch;
		},
		2 => {
	pc = 0x8218E31C; continue 'dispatch;
		},
		3 => {
	pc = 0x8218E328; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8218E2F4: 8218E304  lwz r16, -0x1cfc(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7420 as u32) ) } as u64;
	// 8218E2F8: 8218E310  lwz r16, -0x1cf0(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7408 as u32) ) } as u64;
	// 8218E2FC: 8218E31C  lwz r16, -0x1ce4(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7396 as u32) ) } as u64;
	// 8218E300: 8218E328  lwz r16, -0x1cd8(r24)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-7384 as u32) ) } as u64;
            }
            0x8218E304 => {
    //   block [0x8218E304..0x8218E310)
	// 8218E304: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E308: 656B0100  oris r11, r11, 0x100
	ctx.r[11].u64 = ctx.r[11].u64 | 16777216;
	// 8218E30C: 48000024  b 0x8218e330
	pc = 0x8218E330; continue 'dispatch;
            }
            0x8218E310 => {
    //   block [0x8218E310..0x8218E31C)
	// 8218E310: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E314: 656B0200  oris r11, r11, 0x200
	ctx.r[11].u64 = ctx.r[11].u64 | 33554432;
	// 8218E318: 48000018  b 0x8218e330
	pc = 0x8218E330; continue 'dispatch;
            }
            0x8218E31C => {
    //   block [0x8218E31C..0x8218E328)
	// 8218E31C: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E320: 656B0400  oris r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 67108864;
	// 8218E324: 4800000C  b 0x8218e330
	pc = 0x8218E330; continue 'dispatch;
            }
            0x8218E328 => {
    //   block [0x8218E328..0x8218E330)
	// 8218E328: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E32C: 656B0800  oris r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 134217728;
	pc = 0x8218E330; continue 'dispatch;
            }
            0x8218E330 => {
    //   block [0x8218E330..0x8218E334)
	// 8218E330: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E334; continue 'dispatch;
            }
            0x8218E334 => {
    //   block [0x8218E334..0x8218E364)
	// 8218E334: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E338: 556B0086  rlwinm r11, r11, 0, 2, 3
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E340: 409A0030  bne cr6, 0x8218e370
	if !ctx.cr[6].eq {
	pc = 0x8218E370; continue 'dispatch;
	}
	// 8218E344: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8218E348: 4BFAAE69  bl 0x821391b0
	ctx.lr = 0x8218E34C;
	sub_821391B0(ctx, base);
	// 8218E34C: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E350: 41980014  blt cr6, 0x8218e364
	if ctx.cr[6].lt {
	pc = 0x8218E364; continue 'dispatch;
	}
	// 8218E354: 409A001C  bne cr6, 0x8218e370
	if !ctx.cr[6].eq {
	pc = 0x8218E370; continue 'dispatch;
	}
	// 8218E358: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E35C: 656B2000  oris r11, r11, 0x2000
	ctx.r[11].u64 = ctx.r[11].u64 | 536870912;
	// 8218E360: 4800000C  b 0x8218e36c
	pc = 0x8218E36C; continue 'dispatch;
            }
            0x8218E364 => {
    //   block [0x8218E364..0x8218E36C)
	// 8218E364: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E368: 656B1000  oris r11, r11, 0x1000
	ctx.r[11].u64 = ctx.r[11].u64 | 268435456;
	pc = 0x8218E36C; continue 'dispatch;
            }
            0x8218E36C => {
    //   block [0x8218E36C..0x8218E370)
	// 8218E36C: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E370; continue 'dispatch;
            }
            0x8218E370 => {
    //   block [0x8218E370..0x8218E3A0)
	// 8218E370: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E374: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E378: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E37C: 409A0030  bne cr6, 0x8218e3ac
	if !ctx.cr[6].eq {
	pc = 0x8218E3AC; continue 'dispatch;
	}
	// 8218E380: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8218E384: 4BFAAE2D  bl 0x821391b0
	ctx.lr = 0x8218E388;
	sub_821391B0(ctx, base);
	// 8218E388: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 8218E38C: 41980014  blt cr6, 0x8218e3a0
	if ctx.cr[6].lt {
	pc = 0x8218E3A0; continue 'dispatch;
	}
	// 8218E390: 409A001C  bne cr6, 0x8218e3ac
	if !ctx.cr[6].eq {
	pc = 0x8218E3AC; continue 'dispatch;
	}
	// 8218E394: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E398: 656B8000  oris r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 2147483648;
	// 8218E39C: 4800000C  b 0x8218e3a8
	pc = 0x8218E3A8; continue 'dispatch;
            }
            0x8218E3A0 => {
    //   block [0x8218E3A0..0x8218E3A8)
	// 8218E3A0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E3A4: 656B4000  oris r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 1073741824;
	pc = 0x8218E3A8; continue 'dispatch;
            }
            0x8218E3A8 => {
    //   block [0x8218E3A8..0x8218E3AC)
	// 8218E3A8: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E3AC; continue 'dispatch;
            }
            0x8218E3AC => {
    //   block [0x8218E3AC..0x8218E3E0)
	// 8218E3AC: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 8218E3B0: 409A0030  bne cr6, 0x8218e3e0
	if !ctx.cr[6].eq {
	pc = 0x8218E3E0; continue 'dispatch;
	}
	// 8218E3B4: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E3B8: 556A0212  rlwinm r10, r11, 0, 8, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E3BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E3C0: 419A0020  beq cr6, 0x8218e3e0
	if ctx.cr[6].eq {
	pc = 0x8218E3E0; continue 'dispatch;
	}
	// 8218E3C4: 756A0009  andis. r10, r11, 9
	ctx.r[10].u64 = ctx.r[11].u64 & 589824;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218E3C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E3CC: 419A0014  beq cr6, 0x8218e3e0
	if ctx.cr[6].eq {
	pc = 0x8218E3E0; continue 'dispatch;
	}
	// 8218E3D0: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 8218E3D4: 514B8B9E  rlwimi r11, r10, 0x11, 0xe, 0xf
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(17) as u64) & 0x0000000000030000) | (ctx.r[11].u64 & 0xFFFFFFFFFFFCFFFF);
	// 8218E3D8: 514B8B18  rlwimi r11, r10, 0x11, 0xc, 0xc
	ctx.r[11].u64 = (((ctx.r[10].u32).rotate_left(17) as u64) & 0x0000000000080000) | (ctx.r[11].u64 & 0xFFFFFFFFFFF7FFFF);
	// 8218E3DC: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	pc = 0x8218E3E0; continue 'dispatch;
            }
            0x8218E3E0 => {
    //   block [0x8218E3E0..0x8218E464)
	// 8218E3E0: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E3E4: 3D40829A  lis r10, -0x7d66
	ctx.r[10].s64 = -2103836672;
	// 8218E3E8: 394A45E4  addi r10, r10, 0x45e4
	ctx.r[10].s64 = ctx.r[10].s64 + 17892;
	// 8218E3EC: 556906FC  rlwinm r9, r11, 0, 0x1b, 0x1e
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E3F0: 912A000C  stw r9, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[9].u32 ) };
	// 8218E3F4: 556905F4  rlwinm r9, r11, 0, 0x17, 0x1a
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E3F8: 912A0010  stw r9, 0x10(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(16 as u32), ctx.r[9].u32 ) };
	// 8218E3FC: 5569052C  rlwinm r9, r11, 0, 0x14, 0x16
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E400: 912A0028  stw r9, 0x28(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(40 as u32), ctx.r[9].u32 ) };
	// 8218E404: 55690424  rlwinm r9, r11, 0, 0x10, 0x12
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E408: 912A001C  stw r9, 0x1c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(28 as u32), ctx.r[9].u32 ) };
	// 8218E40C: 5569035E  rlwinm r9, r11, 0, 0xd, 0xf
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E410: 912A0024  stw r9, 0x24(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(36 as u32), ctx.r[9].u32 ) };
	// 8218E414: 556902D8  rlwinm r9, r11, 0, 0xb, 0xc
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E418: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8218E41C: 55690214  rlwinm r9, r11, 0, 8, 0xa
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E420: 912A002C  stw r9, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8218E424: 5569010E  rlwinm r9, r11, 0, 4, 7
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E428: 912A0014  stw r9, 0x14(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[9].u32 ) };
	// 8218E42C: 55690086  rlwinm r9, r11, 0, 2, 3
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E430: 556B0002  rlwinm r11, r11, 0, 0, 1
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E434: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8218E438: 916A0008  stw r11, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 8218E43C: D19F01F8  stfs f12, 0x1f8(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 8218E440: 817F0238  lwz r11, 0x238(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 8218E444: D3FF01D4  stfs f31, 0x1d4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 8218E448: D3FF01D8  stfs f31, 0x1d8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 8218E44C: 556A00C6  rlwinm r10, r11, 0, 3, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E450: D17F0200  stfs f11, 0x200(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 8218E454: D3FF01DC  stfs f31, 0x1dc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	// 8218E458: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E45C: 419A0008  beq cr6, 0x8218e464
	if ctx.cr[6].eq {
	pc = 0x8218E464; continue 'dispatch;
	}
	// 8218E460: 935F01C0  stw r26, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[26].u32 ) };
	pc = 0x8218E464; continue 'dispatch;
            }
            0x8218E464 => {
    //   block [0x8218E464..0x8218E474)
	// 8218E464: 556A0084  rlwinm r10, r11, 0, 2, 2
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E468: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E46C: 419A0008  beq cr6, 0x8218e474
	if ctx.cr[6].eq {
	pc = 0x8218E474; continue 'dispatch;
	}
	// 8218E470: 93BF01C0  stw r29, 0x1c0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(448 as u32), ctx.r[29].u32 ) };
	pc = 0x8218E474; continue 'dispatch;
            }
            0x8218E474 => {
    //   block [0x8218E474..0x8218E484)
	// 8218E474: 556A0042  rlwinm r10, r11, 0, 1, 1
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E478: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E47C: 419A0008  beq cr6, 0x8218e484
	if ctx.cr[6].eq {
	pc = 0x8218E484; continue 'dispatch;
	}
	// 8218E480: 935F01C4  stw r26, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[26].u32 ) };
	pc = 0x8218E484; continue 'dispatch;
            }
            0x8218E484 => {
    //   block [0x8218E484..0x8218E494)
	// 8218E484: 556A0000  rlwinm r10, r11, 0, 0, 0
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E488: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E48C: 419A0008  beq cr6, 0x8218e494
	if ctx.cr[6].eq {
	pc = 0x8218E494; continue 'dispatch;
	}
	// 8218E490: 93BF01C4  stw r29, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[29].u32 ) };
	pc = 0x8218E494; continue 'dispatch;
            }
            0x8218E494 => {
    //   block [0x8218E494..0x8218E4AC)
	// 8218E494: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E498: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E49C: 419A0010  beq cr6, 0x8218e4ac
	if ctx.cr[6].eq {
	pc = 0x8218E4AC; continue 'dispatch;
	}
	// 8218E4A0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E4A4: C00A20AC  lfs f0, 0x20ac(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8364 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E4A8: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	pc = 0x8218E4AC; continue 'dispatch;
            }
            0x8218E4AC => {
    //   block [0x8218E4AC..0x8218E4C4)
	// 8218E4AC: 556A0738  rlwinm r10, r11, 0, 0x1c, 0x1c
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E4B0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E4B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E4B8: C1AA2238  lfs f13, 0x2238(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E4BC: 419A0008  beq cr6, 0x8218e4c4
	if ctx.cr[6].eq {
	pc = 0x8218E4C4; continue 'dispatch;
	}
	// 8218E4C0: D1BF01D4  stfs f13, 0x1d4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	pc = 0x8218E4C4; continue 'dispatch;
            }
            0x8218E4C4 => {
    //   block [0x8218E4C4..0x8218E4DC)
	// 8218E4C4: 556A06F6  rlwinm r10, r11, 0, 0x1b, 0x1b
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E4C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E4CC: 419A0010  beq cr6, 0x8218e4dc
	if ctx.cr[6].eq {
	pc = 0x8218E4DC; continue 'dispatch;
	}
	// 8218E4D0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E4D4: C00A25E0  lfs f0, 0x25e0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9696 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E4D8: D01F01D4  stfs f0, 0x1d4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	pc = 0x8218E4DC; continue 'dispatch;
            }
            0x8218E4DC => {
    //   block [0x8218E4DC..0x8218E4EC)
	// 8218E4DC: 556A0672  rlwinm r10, r11, 0, 0x19, 0x19
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E4E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E4E4: 419A0008  beq cr6, 0x8218e4ec
	if ctx.cr[6].eq {
	pc = 0x8218E4EC; continue 'dispatch;
	}
	// 8218E4E8: D1BF01D8  stfs f13, 0x1d8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x8218E4EC; continue 'dispatch;
            }
            0x8218E4EC => {
    //   block [0x8218E4EC..0x8218E504)
	// 8218E4EC: 556A0630  rlwinm r10, r11, 0, 0x18, 0x18
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E4F0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E4F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E4F8: C1AA21A4  lfs f13, 0x21a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8612 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E4FC: 419A0008  beq cr6, 0x8218e504
	if ctx.cr[6].eq {
	pc = 0x8218E504; continue 'dispatch;
	}
	// 8218E500: D1BF01D8  stfs f13, 0x1d8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x8218E504; continue 'dispatch;
            }
            0x8218E504 => {
    //   block [0x8218E504..0x8218E51C)
	// 8218E504: 556A05EE  rlwinm r10, r11, 0, 0x17, 0x17
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E508: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E50C: 419A0010  beq cr6, 0x8218e51c
	if ctx.cr[6].eq {
	pc = 0x8218E51C; continue 'dispatch;
	}
	// 8218E510: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E514: C00A25DC  lfs f0, 0x25dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9692 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E518: D01F01D8  stfs f0, 0x1d8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x8218E51C; continue 'dispatch;
            }
            0x8218E51C => {
    //   block [0x8218E51C..0x8218E548)
	// 8218E51C: 556A05AC  rlwinm r10, r11, 0, 0x16, 0x16
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E520: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E524: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E528: C00A25D8  lfs f0, 0x25d8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9688 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E52C: 419A0024  beq cr6, 0x8218e550
	if ctx.cr[6].eq {
	pc = 0x8218E550; continue 'dispatch;
	}
	// 8218E530: 815F023C  lwz r10, 0x23c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218E534: C13F01FC  lfs f9, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218E538: 7F1B5040  cmplw cr6, r27, r10
	ctx.cr[6].compare_u32(ctx.r[27].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8218E53C: 409A000C  bne cr6, 0x8218e548
	if !ctx.cr[6].eq {
	pc = 0x8218E548; continue 'dispatch;
	}
	// 8218E540: ED290028  fsubs f9, f9, f0
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218E544: 48000008  b 0x8218e54c
	pc = 0x8218E54C; continue 'dispatch;
            }
            0x8218E548 => {
    //   block [0x8218E548..0x8218E54C)
	// 8218E548: ED29002A  fadds f9, f9, f0
	ctx.f[9].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x8218E54C; continue 'dispatch;
            }
            0x8218E54C => {
    //   block [0x8218E54C..0x8218E550)
	// 8218E54C: D13F01FC  stfs f9, 0x1fc(r31)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	pc = 0x8218E550; continue 'dispatch;
            }
            0x8218E550 => {
    //   block [0x8218E550..0x8218E584)
	// 8218E550: 556A0528  rlwinm r10, r11, 0, 0x14, 0x14
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E554: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E558: 419A0034  beq cr6, 0x8218e58c
	if ctx.cr[6].eq {
	pc = 0x8218E58C; continue 'dispatch;
	}
	// 8218E55C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218E560: 813F023C  lwz r9, 0x23c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218E564: C13F01FC  lfs f9, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8218E568: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 8218E56C: 7D2950AE  lbzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218E570: 7D5B50AE  lbzx r10, r27, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218E574: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8218E578: 409A000C  bne cr6, 0x8218e584
	if !ctx.cr[6].eq {
	pc = 0x8218E584; continue 'dispatch;
	}
	// 8218E57C: EC09002A  fadds f0, f9, f0
	ctx.f[0].f64 = ((ctx.f[9].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218E580: 48000008  b 0x8218e588
	pc = 0x8218E588; continue 'dispatch;
            }
            0x8218E584 => {
    //   block [0x8218E584..0x8218E588)
	// 8218E584: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x8218E588; continue 'dispatch;
            }
            0x8218E588 => {
    //   block [0x8218E588..0x8218E58C)
	// 8218E588: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	pc = 0x8218E58C; continue 'dispatch;
            }
            0x8218E58C => {
    //   block [0x8218E58C..0x8218E5A8)
	// 8218E58C: 556A03DE  rlwinm r10, r11, 0, 0xf, 0xf
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E590: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E594: 419A0014  beq cr6, 0x8218e5a8
	if ctx.cr[6].eq {
	pc = 0x8218E5A8; continue 'dispatch;
	}
	// 8218E598: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E59C: C00A20CC  lfs f0, 0x20cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E5A0: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218E5A4: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	pc = 0x8218E5A8; continue 'dispatch;
            }
            0x8218E5A8 => {
    //   block [0x8218E5A8..0x8218E5C4)
	// 8218E5A8: 556A035A  rlwinm r10, r11, 0, 0xd, 0xd
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E5AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E5B0: 419A0014  beq cr6, 0x8218e5c4
	if ctx.cr[6].eq {
	pc = 0x8218E5C4; continue 'dispatch;
	}
	// 8218E5B4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E5B8: C00A24CC  lfs f0, 0x24cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E5BC: EC0C002A  fadds f0, f12, f0
	ctx.f[0].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218E5C0: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	pc = 0x8218E5C4; continue 'dispatch;
            }
            0x8218E5C4 => {
    //   block [0x8218E5C4..0x8218E5D4)
	// 8218E5C4: 556A0294  rlwinm r10, r11, 0, 0xa, 0xa
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E5C8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E5CC: 419A0008  beq cr6, 0x8218e5d4
	if ctx.cr[6].eq {
	pc = 0x8218E5D4; continue 'dispatch;
	}
	// 8218E5D0: D17F0200  stfs f11, 0x200(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	pc = 0x8218E5D4; continue 'dispatch;
            }
            0x8218E5D4 => {
    //   block [0x8218E5D4..0x8218E5F0)
	// 8218E5D4: 556A0252  rlwinm r10, r11, 0, 9, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E5D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E5DC: 419A0014  beq cr6, 0x8218e5f0
	if ctx.cr[6].eq {
	pc = 0x8218E5F0; continue 'dispatch;
	}
	// 8218E5E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E5E4: C00A2068  lfs f0, 0x2068(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E5E8: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218E5EC: D01F0200  stfs f0, 0x200(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	pc = 0x8218E5F0; continue 'dispatch;
            }
            0x8218E5F0 => {
    //   block [0x8218E5F0..0x8218E608)
	// 8218E5F0: 556A0210  rlwinm r10, r11, 0, 8, 8
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E5F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E5F8: 419A0010  beq cr6, 0x8218e608
	if ctx.cr[6].eq {
	pc = 0x8218E608; continue 'dispatch;
	}
	// 8218E5FC: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8218E600: C00A2934  lfs f0, 0x2934(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E604: D01F0200  stfs f0, 0x200(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	pc = 0x8218E608; continue 'dispatch;
            }
            0x8218E608 => {
    //   block [0x8218E608..0x8218E618)
	// 8218E608: 556A01CE  rlwinm r10, r11, 0, 7, 7
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E60C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E610: 419A0008  beq cr6, 0x8218e618
	if ctx.cr[6].eq {
	pc = 0x8218E618; continue 'dispatch;
	}
	// 8218E614: D3FF01DC  stfs f31, 0x1dc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	pc = 0x8218E618; continue 'dispatch;
            }
            0x8218E618 => {
    //   block [0x8218E618..0x8218E628)
	// 8218E618: 556A018C  rlwinm r10, r11, 0, 6, 6
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E61C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E620: 419A0008  beq cr6, 0x8218e628
	if ctx.cr[6].eq {
	pc = 0x8218E628; continue 'dispatch;
	}
	// 8218E624: D1BF01DC  stfs f13, 0x1dc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	pc = 0x8218E628; continue 'dispatch;
            }
            0x8218E628 => {
    //   block [0x8218E628..0x8218E640)
	// 8218E628: 556A014A  rlwinm r10, r11, 0, 5, 5
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E62C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E630: 419A0010  beq cr6, 0x8218e640
	if ctx.cr[6].eq {
	pc = 0x8218E640; continue 'dispatch;
	}
	// 8218E634: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218E638: C00A2468  lfs f0, 0x2468(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E63C: D01F01DC  stfs f0, 0x1dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	pc = 0x8218E640; continue 'dispatch;
            }
            0x8218E640 => {
    //   block [0x8218E640..0x8218E658)
	// 8218E640: 556B0108  rlwinm r11, r11, 0, 4, 4
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8218E644: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E648: 419A0010  beq cr6, 0x8218e658
	if ctx.cr[6].eq {
	pc = 0x8218E658; continue 'dispatch;
	}
	// 8218E64C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E650: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E654: D01F01DC  stfs f0, 0x1dc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(476 as u32), tmp.u32 ) };
	pc = 0x8218E658; continue 'dispatch;
            }
            0x8218E658 => {
    //   block [0x8218E658..0x8218E71C)
	// 8218E658: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E65C: C19F01F8  lfs f12, 0x1f8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218E660: FC205090  fmr f1, f10
	ctx.f[1].f64 = ctx.f[10].f64;
	// 8218E664: C17F0200  lfs f11, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218E668: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8218E66C: C00B25D4  lfs f0, 0x25d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9684 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E670: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E674: ED206028  fsubs f9, f0, f12
	ctx.f[9].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218E678: D01F01E0  stfs f0, 0x1e0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 8218E67C: C1AB25D0  lfs f13, 0x25d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9680 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E680: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E684: D1BF01EC  stfs f13, 0x1ec(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(492 as u32), tmp.u32 ) };
	// 8218E688: C14B25CC  lfs f10, 0x25cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9676 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8218E68C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E690: ED0A5828  fsubs f8, f10, f11
	ctx.f[8].f64 = (((ctx.f[10].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218E694: FC09602E  fsel f0, f9, f0, f12
	ctx.f[0].f64 = if ctx.f[9].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[12].f64 };
	// 8218E698: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 8218E69C: FD8852EE  fsel f12, f8, f11, f10
	ctx.f[12].f64 = if ctx.f[8].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[10].f64 };
	// 8218E6A0: C16B2528  lfs f11, 0x2528(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9512 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218E6A4: ED4B6028  fsubs f10, f11, f12
	ctx.f[10].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218E6A8: FD8A62EE  fsel f12, f10, f11, f12
	ctx.f[12].f64 = if ctx.f[10].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[12].f64 };
	// 8218E6AC: D19F0200  stfs f12, 0x200(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	// 8218E6B0: ED8D0028  fsubs f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218E6B4: FC0C682E  fsel f0, f12, f0, f13
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 8218E6B8: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 8218E6BC: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E6C0: D01C0050  stfs f0, 0x50(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218E6C4: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E6C8: D01C0054  stfs f0, 0x54(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218E6CC: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E6D0: D01C0070  stfs f0, 0x70(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218E6D4: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8218E6D8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218E6DC: 4E800421  bctrl
	ctx.lr = 0x8218E6E0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218E6E0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218E6E4: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218E6E8: 614AF330  ori r10, r10, 0xf330
	ctx.r[10].u64 = ctx.r[10].u64 | 62256;
	// 8218E6EC: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E6F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E6F4: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8218E6F8: D01F0204  stfs f0, 0x204(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(516 as u32), tmp.u32 ) };
	// 8218E6FC: D3FF0014  stfs f31, 0x14(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8218E700: C00B2140  lfs f0, 0x2140(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E704: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8218E708: 40980014  bge cr6, 0x8218e71c
	if !ctx.cr[6].lt {
	pc = 0x8218E71C; continue 'dispatch;
	}
	// 8218E70C: 933F0228  stw r25, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[25].u32 ) };
	// 8218E710: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8218E714: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218E718: 483A69E4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8218E71C => {
    //   block [0x8218E71C..0x8218E72C)
	// 8218E71C: 935F0228  stw r26, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[26].u32 ) };
	// 8218E720: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8218E724: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218E728: 483A69D4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218E730(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8218E730 size=216
    let mut pc: u32 = 0x8218E730;
    'dispatch: loop {
        match pc {
            0x8218E730 => {
    //   block [0x8218E730..0x8218E7B4)
	// 8218E730: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218E734: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218E738: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218E73C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218E740: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218E744: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218E748: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218E74C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218E750: 4BFFB411  bl 0x82189b60
	ctx.lr = 0x8218E754;
	sub_82189B60(ctx, base);
	// 8218E754: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 8218E758: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218E75C: 419A0094  beq cr6, 0x8218e7f0
	if ctx.cr[6].eq {
	pc = 0x8218E7F0; continue 'dispatch;
	}
	// 8218E760: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218E764: 816B49EC  lwz r11, 0x49ec(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(18924 as u32) ) } as u64;
	// 8218E768: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218E76C: 419A0084  beq cr6, 0x8218e7f0
	if ctx.cr[6].eq {
	pc = 0x8218E7F0; continue 'dispatch;
	}
	// 8218E770: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218E774: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218E778: 419A0078  beq cr6, 0x8218e7f0
	if ctx.cr[6].eq {
	pc = 0x8218E7F0; continue 'dispatch;
	}
	// 8218E77C: 3FC08287  lis r30, -0x7d79
	ctx.r[30].s64 = -2105081856;
	// 8218E780: 807E03D8  lwz r3, 0x3d8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 8218E784: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E788: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8218E78C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218E790: 4E800421  bctrl
	ctx.lr = 0x8218E794;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218E794: 817F0224  lwz r11, 0x224(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) } as u64;
	// 8218E798: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8218E79C: 419A0018  beq cr6, 0x8218e7b4
	if ctx.cr[6].eq {
	pc = 0x8218E7B4; continue 'dispatch;
	}
	// 8218E7A0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8218E7A4: 409A0010  bne cr6, 0x8218e7b4
	if !ctx.cr[6].eq {
	pc = 0x8218E7B4; continue 'dispatch;
	}
	// 8218E7A8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218E7AC: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218E7B0: 48000040  b 0x8218e7f0
	pc = 0x8218E7F0; continue 'dispatch;
            }
            0x8218E7B4 => {
    //   block [0x8218E7B4..0x8218E7E8)
	// 8218E7B4: 807E03D8  lwz r3, 0x3d8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 8218E7B8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E7BC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8218E7C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218E7C4: 4E800421  bctrl
	ctx.lr = 0x8218E7C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218E7C8: 817F0218  lwz r11, 0x218(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 8218E7CC: 907F0224  stw r3, 0x224(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(548 as u32), ctx.r[3].u32 ) };
	// 8218E7D0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8218E7D4: 41980014  blt cr6, 0x8218e7e8
	if ctx.cr[6].lt {
	pc = 0x8218E7E8; continue 'dispatch;
	}
	// 8218E7D8: 409A0018  bne cr6, 0x8218e7f0
	if !ctx.cr[6].eq {
	pc = 0x8218E7F0; continue 'dispatch;
	}
	// 8218E7DC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218E7E0: 48000F59  bl 0x8218f738
	ctx.lr = 0x8218E7E4;
	sub_8218F738(ctx, base);
	// 8218E7E4: 4800000C  b 0x8218e7f0
	pc = 0x8218E7F0; continue 'dispatch;
            }
            0x8218E7E8 => {
    //   block [0x8218E7E8..0x8218E7F0)
	// 8218E7E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218E7EC: 48001A1D  bl 0x82190208
	ctx.lr = 0x8218E7F0;
	sub_82190208(ctx, base);
	pc = 0x8218E7F0; continue 'dispatch;
            }
            0x8218E7F0 => {
    //   block [0x8218E7F0..0x8218E808)
	// 8218E7F0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218E7F4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218E7F8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218E7FC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218E800: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218E804: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218E808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218E808 size=224
    let mut pc: u32 = 0x8218E808;
    'dispatch: loop {
        match pc {
            0x8218E808 => {
    //   block [0x8218E808..0x8218E8C4)
	// 8218E808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218E80C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218E810: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218E814: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218E818: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218E81C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218E820: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218E824: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218E828: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218E82C: 614A85F8  ori r10, r10, 0x85f8
	ctx.r[10].u64 = ctx.r[10].u64 | 34296;
	// 8218E830: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218E834: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218E838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218E83C: 409A0090  bne cr6, 0x8218e8cc
	if !ctx.cr[6].eq {
	pc = 0x8218E8CC; continue 'dispatch;
	}
	// 8218E840: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218E844: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218E848: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8218E84C: 419A0080  beq cr6, 0x8218e8cc
	if ctx.cr[6].eq {
	pc = 0x8218E8CC; continue 'dispatch;
	}
	// 8218E850: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E854: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218E858: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218E85C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218E860: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218E864: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218E868: 4BFD7239  bl 0x82165aa0
	ctx.lr = 0x8218E86C;
	sub_82165AA0(ctx, base);
	// 8218E86C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8218E870: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218E874: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218E878: 93C30148  stw r30, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 8218E87C: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218E880: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218E884: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E888: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218E88C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218E890: 4E800421  bctrl
	ctx.lr = 0x8218E894;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218E894: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218E898: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218E89C: 4BFAA66D  bl 0x82138f08
	ctx.lr = 0x8218E8A0;
	sub_82138F08(ctx, base);
	// 8218E8A0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218E8A4: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8218E8A8: 409A001C  bne cr6, 0x8218e8c4
	if !ctx.cr[6].eq {
	pc = 0x8218E8C4; continue 'dispatch;
	}
	// 8218E8AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218E8B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218E8B4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218E8B8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218E8BC: 48004EB5  bl 0x82193770
	ctx.lr = 0x8218E8C0;
	sub_82193770(ctx, base);
	// 8218E8C0: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
            }
            0x8218E8C4 => {
    //   block [0x8218E8C4..0x8218E8CC)
	// 8218E8C4: D3FF0064  stfs f31, 0x64(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218E8C8: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	pc = 0x8218E8CC; continue 'dispatch;
            }
            0x8218E8CC => {
    //   block [0x8218E8CC..0x8218E8E8)
	// 8218E8CC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218E8D0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218E8D4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218E8D8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218E8DC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218E8E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218E8E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218E8F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218E8F8 size=1616
    let mut pc: u32 = 0x8218E8F8;
    'dispatch: loop {
        match pc {
            0x8218E8F8 => {
    //   block [0x8218E8F8..0x8218E934)
	// 8218E8F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218E8FC: 483A67B5  bl 0x825350b0
	ctx.lr = 0x8218E900;
	sub_82535080(ctx, base);
	// 8218E900: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 8218E904: 483A76E1  bl 0x82535fe4
	ctx.lr = 0x8218E908;
	sub_82535FB0(ctx, base);
	// 8218E908: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218E90C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E910: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218E914: C38B1FF8  lfs f28, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8218E918: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218E91C: C01F0064  lfs f0, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E920: FF00E000  fcmpu cr6, f0, f28
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[28].f64);
	// 8218E924: 396B534C  addi r11, r11, 0x534c
	ctx.r[11].s64 = ctx.r[11].s64 + 21324;
	// 8218E928: 4199000C  bgt cr6, 0x8218e934
	if ctx.cr[6].gt {
	pc = 0x8218E934; continue 'dispatch;
	}
	// 8218E92C: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E930: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x8218E934; continue 'dispatch;
            }
            0x8218E934 => {
    //   block [0x8218E934..0x8218E948)
	// 8218E934: 815F0060  lwz r10, 0x60(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 8218E938: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E93C: 409A000C  bne cr6, 0x8218e948
	if !ctx.cr[6].eq {
	pc = 0x8218E948; continue 'dispatch;
	}
	// 8218E940: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E944: 915F0060  stw r10, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	pc = 0x8218E948; continue 'dispatch;
            }
            0x8218E948 => {
    //   block [0x8218E948..0x8218E988)
	// 8218E948: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8218E94C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218E950: 409A0038  bne cr6, 0x8218e988
	if !ctx.cr[6].eq {
	pc = 0x8218E988; continue 'dispatch;
	}
	// 8218E954: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8218E958: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E95C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218E960: 814B0018  lwz r10, 0x18(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8218E964: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E968: C00922A4  lfs f0, 0x22a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E96C: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218E970: C1AB0010  lfs f13, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E974: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218E978: C1AB0014  lfs f13, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218E97C: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218E980: 915F0058  stw r10, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[10].u32 ) };
	// 8218E984: 48000080  b 0x8218ea04
	pc = 0x8218EA04; continue 'dispatch;
            }
            0x8218E988 => {
    //   block [0x8218E988..0x8218EA04)
	// 8218E988: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218E98C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218E990: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E994: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218E998: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8218E99C: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218E9A0: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E9A4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218E9A8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218E9AC: 816A0010  lwz r11, 0x10(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218E9B0: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8218E9B4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218E9B8: 812A0008  lwz r9, 8(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218E9BC: 814A000C  lwz r10, 0xc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218E9C0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218E9C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218E9C8: F9210060  std r9, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[9].u64 ) };
	// 8218E9CC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8218E9D0: F9410070  std r10, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[10].u64 ) };
	// 8218E9D4: C9810070  lfd f12, 0x70(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8218E9D8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218E9DC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218E9E0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218E9E4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218E9E8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218E9EC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8218E9F0: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218E9F4: C00B22A4  lfs f0, 0x22a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218E9F8: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218E9FC: EFAC0032  fmuls f29, f12, f0
	ctx.f[29].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218EA00: EFEB0032  fmuls f31, f11, f0
	ctx.f[31].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8218EA04; continue 'dispatch;
            }
            0x8218EA04 => {
    //   block [0x8218EA04..0x8218EF48)
	// 8218EA04: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218EA08: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218EA0C: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8218EA10: C00BD6D0  lfs f0, -0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA14: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8218EA18: 916A0074  stw r11, 0x74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218EA1C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218EA20: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218EA24: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218EA28: D39F0054  stfs f28, 0x54(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218EA2C: 3BCB76FC  addi r30, r11, 0x76fc
	ctx.r[30].s64 = ctx.r[11].s64 + 30460;
	// 8218EA30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218EA34: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218EA38: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218EA3C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218EA40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218EA44: 4E800421  bctrl
	ctx.lr = 0x8218EA48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218EA48: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218EA4C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218EA50: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 8218EA54: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8218EA58: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218EA5C: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA60: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218EA64: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA68: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8218EA6C: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA70: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218EA74: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218EA78: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218EA7C: 4E800421  bctrl
	ctx.lr = 0x8218EA80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218EA80: 39610070  addi r11, r1, 0x70
	ctx.r[11].s64 = ctx.r[1].s64 + 112;
	// 8218EA84: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218EA88: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA8C: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218EA90: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218EA94: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218EF48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218EF48 size=664
    let mut pc: u32 = 0x8218EF48;
    'dispatch: loop {
        match pc {
            0x8218EF48 => {
    //   block [0x8218EF48..0x8218EFE4)
	// 8218EF48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218EF4C: 483A6171  bl 0x825350bc
	ctx.lr = 0x8218EF50;
	sub_82535080(ctx, base);
	// 8218EF50: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8218EF54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218EF58: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218EF5C: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8218EF60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218EF64: 419A0270  beq cr6, 0x8218f1d4
	if ctx.cr[6].eq {
	pc = 0x8218F1D4; continue 'dispatch;
	}
	// 8218EF68: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218EF6C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218EF70: 3BABBFF0  addi r29, r11, -0x4010
	ctx.r[29].s64 = ctx.r[11].s64 + -16400;
	// 8218EF74: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218EF78: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218EF7C: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218EF80: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218EF84: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218EF88: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218EF8C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218EF90: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218EF94: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218EF98: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218EF9C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218EFA0: 409A0234  bne cr6, 0x8218f1d4
	if !ctx.cr[6].eq {
	pc = 0x8218F1D4; continue 'dispatch;
	}
	// 8218EFA4: 3FC08287  lis r30, -0x7d79
	ctx.r[30].s64 = -2105081856;
	// 8218EFA8: 807E03D8  lwz r3, 0x3d8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 8218EFAC: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218EFB0: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8218EFB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218EFB8: 4E800421  bctrl
	ctx.lr = 0x8218EFBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218EFBC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8218EFC0: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8218EFC4: 419A0020  beq cr6, 0x8218efe4
	if ctx.cr[6].eq {
	pc = 0x8218EFE4; continue 'dispatch;
	}
	// 8218EFC8: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8218EFCC: 409A0018  bne cr6, 0x8218efe4
	if !ctx.cr[6].eq {
	pc = 0x8218EFE4; continue 'dispatch;
	}
	// 8218EFD0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218EFD4: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218EFD8: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8218EFDC: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218EFE0: 483A612C  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8218EFE4 => {
    //   block [0x8218EFE4..0x8218F030)
	// 8218EFE4: 807E03D8  lwz r3, 0x3d8(r30)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(984 as u32) ) } as u64;
	// 8218EFE8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218EFEC: 816B002C  lwz r11, 0x2c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8218EFF0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218EFF4: 4E800421  bctrl
	ctx.lr = 0x8218EFF8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218EFF8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218EFFC: 907F006C  stw r3, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[3].u32 ) };
	// 8218F000: 616AEB33  ori r10, r11, 0xeb33
	ctx.r[10].u64 = ctx.r[11].u64 | 60211;
	// 8218F004: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218F008: 3BCB76FC  addi r30, r11, 0x76fc
	ctx.r[30].s64 = ctx.r[11].s64 + 30460;
	// 8218F00C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F010: 7D2B50AE  lbzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F014: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218F018: 409A0018  bne cr6, 0x8218f030
	if !ctx.cr[6].eq {
	pc = 0x8218F030; continue 'dispatch;
	}
	// 8218F01C: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 8218F020: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F024: 7D4A48AE  lbzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218F028: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218F02C: 419A003C  beq cr6, 0x8218f068
	if ctx.cr[6].eq {
	pc = 0x8218F068; continue 'dispatch;
	}
            }
            0x8218F030 => {
    //   block [0x8218F030..0x8218F060)
	// 8218F030: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218F034: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218F038: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F03C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218F040: 91690230  stw r11, 0x230(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 8218F044: 814A0028  lwz r10, 0x28(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218F048: 816A0250  lwz r11, 0x250(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218F04C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F050: 419A0010  beq cr6, 0x8218f060
	if ctx.cr[6].eq {
	pc = 0x8218F060; continue 'dispatch;
	}
	// 8218F054: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8218F058: C009BA38  lfs f0, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F05C: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218F060; continue 'dispatch;
            }
            0x8218F060 => {
    //   block [0x8218F060..0x8218F068)
	// 8218F060: 816A0254  lwz r11, 0x254(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218F064: 48000158  b 0x8218f1bc
	pc = 0x8218F1BC; continue 'dispatch;
            }
            0x8218F068 => {
    //   block [0x8218F068..0x8218F16C)
	// 8218F068: 815F0058  lwz r10, 0x58(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8218F06C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218F070: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8218F074: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218F078: 419A00F4  beq cr6, 0x8218f16c
	if ctx.cr[6].eq {
	pc = 0x8218F16C; continue 'dispatch;
	}
	// 8218F07C: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218F080: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218F084: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8218F088: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F08C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218F090: 4E800421  bctrl
	ctx.lr = 0x8218F094;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218F094: 815E0004  lwz r10, 4(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F098: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8218F09C: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 8218F0A0: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 8218F0A4: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218F0A8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F0AC: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F0B0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F0B4: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F0B8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F0BC: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F0C0: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F0C4: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8218F0C8: 4E800421  bctrl
	ctx.lr = 0x8218F0CC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218F0CC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8218F0D0: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8218F0D4: C1A30030  lfs f13, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F0D8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218F0DC: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8218F0E0: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F0E4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218F0E8: C009BFFC  lfs f0, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F0EC: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8218F0F0: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F0F4: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218F0F8: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
            }
            0x8218F16C => {
    //   block [0x8218F16C..0x8218F1BC)
	// 8218F16C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F170: C1BF0054  lfs f13, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F174: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 8218F178: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F17C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F180: C1BF0064  lfs f13, 0x64(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F184: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F188: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218F18C: 40990048  ble cr6, 0x8218f1d4
	if !ctx.cr[6].gt {
	pc = 0x8218F1D4; continue 'dispatch;
	}
	// 8218F190: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218F194: 813F0024  lwz r9, 0x24(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218F198: 815F0008  lwz r10, 8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F19C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8218F1A0: 91690230  stw r11, 0x230(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 8218F1A4: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218F1A8: 814B0250  lwz r10, 0x250(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218F1AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218F1B0: 419A0008  beq cr6, 0x8218f1b8
	if ctx.cr[6].eq {
	pc = 0x8218F1B8; continue 'dispatch;
	}
	// 8218F1B4: D3EA009C  stfs f31, 0x9c(r10)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8218F1B8: 816B0254  lwz r11, 0x254(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	pc = 0x8218F1BC; continue 'dispatch;
            }
            0x8218F1BC => {
    //   block [0x8218F1BC..0x8218F1D4)
	// 8218F1BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F1C0: 419A0014  beq cr6, 0x8218f1d4
	if ctx.cr[6].eq {
	pc = 0x8218F1D4; continue 'dispatch;
	}
	// 8218F1C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218F1C8: C80A2008  lfd f0, 0x2008(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 8218F1CC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8218F1D0: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218F1D4; continue 'dispatch;
            }
            0x8218F1D4 => {
    //   block [0x8218F1D4..0x8218F1E0)
	// 8218F1D4: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8218F1D8: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218F1DC: 483A5F30  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F1E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218F1E0 size=232
    let mut pc: u32 = 0x8218F1E0;
    'dispatch: loop {
        match pc {
            0x8218F1E0 => {
    //   block [0x8218F1E0..0x8218F29C)
	// 8218F1E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218F1E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218F1E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8218F1EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218F1F0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 8218F1F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218F1F8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218F1FC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F200: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218F204: 614A85F8  ori r10, r10, 0x85f8
	ctx.r[10].u64 = ctx.r[10].u64 | 34296;
	// 8218F208: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218F20C: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F210: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F214: 409A0098  bne cr6, 0x8218f2ac
	if !ctx.cr[6].eq {
	pc = 0x8218F2AC; continue 'dispatch;
	}
	// 8218F218: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218F21C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218F220: 2F0B0013  cmpwi cr6, r11, 0x13
	ctx.cr[6].compare_i32(ctx.r[11].s32, 19, &mut ctx.xer);
	// 8218F224: 419A0088  beq cr6, 0x8218f2ac
	if ctx.cr[6].eq {
	pc = 0x8218F2AC; continue 'dispatch;
	}
	// 8218F228: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F22C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F230: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218F234: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F238: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218F23C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218F240: 4BFD6861  bl 0x82165aa0
	ctx.lr = 0x8218F244;
	sub_82165AA0(ctx, base);
	// 8218F244: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8218F248: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218F24C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218F250: 93C30148  stw r30, 0x148(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 8218F254: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F258: 809F0020  lwz r4, 0x20(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F25C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F260: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8218F264: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218F268: 4E800421  bctrl
	ctx.lr = 0x8218F26C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218F26C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218F270: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F274: 4BFA9C95  bl 0x82138f08
	ctx.lr = 0x8218F278;
	sub_82138F08(ctx, base);
	// 8218F278: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218F27C: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8218F280: 409A001C  bne cr6, 0x8218f29c
	if !ctx.cr[6].eq {
	pc = 0x8218F29C; continue 'dispatch;
	}
	// 8218F284: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218F288: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F28C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218F290: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218F294: 480044DD  bl 0x82193770
	ctx.lr = 0x8218F298;
	sub_82193770(ctx, base);
	// 8218F298: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
            }
            0x8218F29C => {
    //   block [0x8218F29C..0x8218F2AC)
	// 8218F29C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218F2A0: D3FF0068  stfs f31, 0x68(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218F2A4: 93DF005C  stw r30, 0x5c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8218F2A8: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	pc = 0x8218F2AC; continue 'dispatch;
            }
            0x8218F2AC => {
    //   block [0x8218F2AC..0x8218F2C8)
	// 8218F2AC: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8218F2B0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218F2B4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218F2B8: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218F2BC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218F2C0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218F2C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F2C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218F2C8 size=136
    let mut pc: u32 = 0x8218F2C8;
    'dispatch: loop {
        match pc {
            0x8218F2C8 => {
    //   block [0x8218F2C8..0x8218F344)
	// 8218F2C8: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 8218F2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F2D0: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8218F2D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218F2D8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F2DC: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218F2E0: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8218F2E4: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8218F2E8: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218F2EC: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218F2F0: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F2F4: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8218F2F8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8218F2FC: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8218F300: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218F304: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218F308: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218F30C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8218F310: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8218F314: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218F318: 394A76FC  addi r10, r10, 0x76fc
	ctx.r[10].s64 = ctx.r[10].s64 + 30460;
	// 8218F31C: 616BEB33  ori r11, r11, 0xeb33
	ctx.r[11].u64 = ctx.r[11].u64 | 60211;
	// 8218F320: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F324: 7D2958AE  lbzx r9, r9, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218F328: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218F32C: 409A0018  bne cr6, 0x8218f344
	if !ctx.cr[6].eq {
	pc = 0x8218F344; continue 'dispatch;
	}
	// 8218F330: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8218F334: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F338: 7D6B48AE  lbzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218F33C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F340: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	pc = 0x8218F344; continue 'dispatch;
            }
            0x8218F344 => {
    //   block [0x8218F344..0x8218F350)
	// 8218F344: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8218F348: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8218F34C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F350(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8218F350 size=4
    let mut pc: u32 = 0x8218F350;
    'dispatch: loop {
        match pc {
            0x8218F350 => {
    //   block [0x8218F350..0x8218F354)
	// 8218F350: 48000008  b 0x8218f358
	sub_8218F358(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F358(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218F358 size=544
    let mut pc: u32 = 0x8218F358;
    'dispatch: loop {
        match pc {
            0x8218F358 => {
    //   block [0x8218F358..0x8218F39C)
	// 8218F358: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218F35C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218F360: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218F364: DBA1FFD8  stfd f29, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[29].u64 ) };
	// 8218F368: DBC1FFE0  stfd f30, -0x20(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[30].u64 ) };
	// 8218F36C: DBE1FFE8  stfd f31, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8218F370: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218F374: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F378: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218F37C: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8218F380: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218F384: C01F0068  lfs f0, 0x68(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F388: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 8218F38C: 396B53B4  addi r11, r11, 0x53b4
	ctx.r[11].s64 = ctx.r[11].s64 + 21428;
	// 8218F390: 4199000C  bgt cr6, 0x8218f39c
	if ctx.cr[6].gt {
	pc = 0x8218F39C; continue 'dispatch;
	}
	// 8218F394: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F398: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	pc = 0x8218F39C; continue 'dispatch;
            }
            0x8218F39C => {
    //   block [0x8218F39C..0x8218F3D0)
	// 8218F39C: 815F005C  lwz r10, 0x5c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(92 as u32) ) } as u64;
	// 8218F3A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218F3A4: 409A002C  bne cr6, 0x8218f3d0
	if !ctx.cr[6].eq {
	pc = 0x8218F3D0; continue 'dispatch;
	}
	// 8218F3A8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8218F3AC: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F3B0: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F3B4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8218F3B8: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F3BC: C00A22A4  lfs f0, 0x22a4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8868 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F3C0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218F3C4: C1AB000C  lfs f13, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F3C8: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8218F3CC: 48000018  b 0x8218f3e4
	pc = 0x8218F3E4; continue 'dispatch;
            }
            0x8218F3D0 => {
    //   block [0x8218F3D0..0x8218F3E4)
	// 8218F3D0: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F3D4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F3D8: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F3DC: C3EA0008  lfs f31, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218F3E0: C3CA000C  lfs f30, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x8218F3E4; continue 'dispatch;
            }
            0x8218F3E4 => {
    //   block [0x8218F3E4..0x8218F3F8)
	// 8218F3E4: 2B090001  cmplwi cr6, r9, 1
	ctx.cr[6].compare_u32(ctx.r[9].u32, 1 as u32, &mut ctx.xer);
	// 8218F3E8: 41980020  blt cr6, 0x8218f408
	if ctx.cr[6].lt {
	pc = 0x8218F408; continue 'dispatch;
	}
	// 8218F3EC: 419A000C  beq cr6, 0x8218f3f8
	if ctx.cr[6].eq {
	pc = 0x8218F3F8; continue 'dispatch;
	}
	// 8218F3F0: 2B090003  cmplwi cr6, r9, 3
	ctx.cr[6].compare_u32(ctx.r[9].u32, 3 as u32, &mut ctx.xer);
	// 8218F3F4: 4198000C  blt cr6, 0x8218f400
	if ctx.cr[6].lt {
	pc = 0x8218F400; continue 'dispatch;
	}
	pc = 0x8218F3F8; continue 'dispatch;
            }
            0x8218F3F8 => {
    //   block [0x8218F3F8..0x8218F400)
	// 8218F3F8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8218F3FC: 48000010  b 0x8218f40c
	pc = 0x8218F40C; continue 'dispatch;
            }
            0x8218F400 => {
    //   block [0x8218F400..0x8218F408)
	// 8218F400: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 8218F404: 48000008  b 0x8218f40c
	pc = 0x8218F40C; continue 'dispatch;
            }
            0x8218F408 => {
    //   block [0x8218F408..0x8218F40C)
	// 8218F408: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	pc = 0x8218F40C; continue 'dispatch;
            }
            0x8218F40C => {
    //   block [0x8218F40C..0x8218F510)
	// 8218F40C: 917F0058  stw r11, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8218F410: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8218F414: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F418: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 8218F41C: C00BD6D0  lfs f0, -0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F420: 912A0074  stw r9, 0x74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 8218F424: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F428: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218F42C: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8218F430: D3BF0054  stfs f29, 0x54(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F434: 809F0058  lwz r4, 0x58(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) } as u64;
	// 8218F438: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8218F43C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8218F440: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F444: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218F448: 4E800421  bctrl
	ctx.lr = 0x8218F44C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218F44C: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8218F450: C1A30030  lfs f13, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F454: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8218F458: 61279B74  ori r7, r9, 0x9b74
	ctx.r[7].u64 = ctx.r[9].u64 | 39796;
	// 8218F45C: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F460: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8218F464: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F468: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F46C: 811F006C  lwz r8, 0x6c(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 8218F470: C1A30038  lfs f13, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F474: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F478: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F47C: D3BF0040  stfs f29, 0x40(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218F480: C009BA38  lfs f0, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F484: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8218F488: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8218F48C: F93F0030  std r9, 0x30(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[9].u64 ) };
	// 8218F490: F95F0038  std r10, 0x38(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), ctx.r[10].u64 ) };
	// 8218F494: 7DA83C2E  lfsx f13, r8, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F498: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218F49C: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 8218F4A0: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218F4A4: D3FF0040  stfs f31, 0x40(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218F4A8: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F4AC: D1AB0060  stfs f13, 0x60(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218F4B0: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F4B4: D1AB0064  stfs f13, 0x64(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218F4B8: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F4BC: D1AB0068  stfs f13, 0x68(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218F4C0: D00B006C  stfs f0, 0x6c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8218F4C4: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F4C8: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F4CC: D1AB0070  stfs f13, 0x70(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218F4D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F4D4: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F4D8: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F4DC: FD806E5E  fctidz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218F4E0: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218F4E4: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218F4E8: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218F4EC: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F4F0: FD806E5E  fctidz f12, f13
	ctx.f[12].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218F4F4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8218F4F8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8218F4FC: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8218F500: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218F504: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8218F508: 40990008  ble cr6, 0x8218f510
	if !ctx.cr[6].gt {
	pc = 0x8218F510; continue 'dispatch;
	}
	// 8218F50C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
            }
            0x8218F510 => {
    //   block [0x8218F510..0x8218F550)
	// 8218F510: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F514: D1AB0054  stfs f13, 0x54(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F518: C1BF0040  lfs f13, 0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F51C: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F520: FD606E5E  fctidz f11, f13
	ctx.f[11].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218F524: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8218F528: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8218F52C: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218F530: EDAD002A  fadds f13, f13, f0
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F534: FD606E5E  fctidz f11, f13
	ctx.f[11].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8218F538: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8218F53C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8218F540: EDAD5828  fsubs f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[11].f64) as f32) as f64);
	// 8218F544: FF0D6000  fcmpu cr6, f13, f12
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[12].f64);
	// 8218F548: 40990008  ble cr6, 0x8218f550
	if !ctx.cr[6].gt {
	pc = 0x8218F550; continue 'dispatch;
	}
	// 8218F54C: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x8218F550; continue 'dispatch;
            }
            0x8218F550 => {
    //   block [0x8218F550..0x8218F578)
	// 8218F550: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F554: D1AB0050  stfs f13, 0x50(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F558: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8218F55C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218F560: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218F564: CBA1FFD8  lfd f29, -0x28(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8218F568: CBC1FFE0  lfd f30, -0x20(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8218F56C: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8218F570: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218F574: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F578(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218F578 size=120
    let mut pc: u32 = 0x8218F578;
    'dispatch: loop {
        match pc {
            0x8218F578 => {
    //   block [0x8218F578..0x8218F5C0)
	// 8218F578: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218F57C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8218F580: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8218F584: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218F588: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218F58C: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F590: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F594: 4BFFA9ED  bl 0x82189f80
	ctx.lr = 0x8218F598;
	sub_82189F80(ctx, base);
	// 8218F598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218F59C: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	// 8218F5A0: 409A0020  bne cr6, 0x8218f5c0
	if !ctx.cr[6].eq {
	pc = 0x8218F5C0; continue 'dispatch;
	}
	// 8218F5A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F5A8: 809F0004  lwz r4, 4(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F5AC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8218F5B0: 807F0008  lwz r3, 8(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F5B4: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218F5B8: 4BFFA7B9  bl 0x82189d70
	ctx.lr = 0x8218F5BC;
	sub_82189D70(ctx, base);
	// 8218F5BC: 907F0020  stw r3, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[3].u32 ) };
	pc = 0x8218F5C0; continue 'dispatch;
            }
            0x8218F5C0 => {
    //   block [0x8218F5C0..0x8218F5F0)
	// 8218F5C0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8218F5C4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F5C8: C00BD4D4  lfs f0, -0x2b2c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F5CC: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8218F5D0: D00A0078  stfs f0, 0x78(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218F5D4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F5D8: 916A0074  stw r11, 0x74(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 8218F5DC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8218F5E0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8218F5E4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8218F5E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8218F5EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F5F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218F5F0 size=92
    let mut pc: u32 = 0x8218F5F0;
    'dispatch: loop {
        match pc {
            0x8218F5F0 => {
    //   block [0x8218F5F0..0x8218F64C)
	// 8218F5F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F5F4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218F5F8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F5FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F600: D0030038  stfs f0, 0x38(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8218F604: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 8218F608: D0030030  stfs f0, 0x30(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8218F60C: D0030048  stfs f0, 0x48(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8218F610: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218F614: C1AB21C8  lfs f13, 0x21c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8648 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F618: D0030040  stfs f0, 0x40(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8218F61C: D0030058  stfs f0, 0x58(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F620: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F624: D0030050  stfs f0, 0x50(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F628: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8218F62C: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8218F630: D0030060  stfs f0, 0x60(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8218F634: D0030078  stfs f0, 0x78(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8218F638: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8218F63C: D0030070  stfs f0, 0x70(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8218F640: D0030080  stfs f0, 0x80(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8218F644: D1A30034  stfs f13, 0x34(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218F648: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F650(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8218F650 size=80
    let mut pc: u32 = 0x8218F650;
    'dispatch: loop {
        match pc {
            0x8218F650 => {
    //   block [0x8218F650..0x8218F6A0)
	// 8218F650: 81430024  lwz r10, 0x24(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) } as u64;
	// 8218F654: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F658: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8218F65C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8218F660: C0030038  lfs f0, 0x38(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F664: C1A30034  lfs f13, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F668: C1830030  lfs f12, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218F66C: D1AB00F4  stfs f13, 0xf4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 8218F670: D18B00F0  stfs f12, 0xf0(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 8218F674: D00B00F8  stfs f0, 0xf8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 8218F678: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F67C: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F680: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F684: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218F688: 4C980020  bgelr cr6
	if !ctx.cr[6].lt { return; }
	// 8218F68C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F690: C1AB21C4  lfs f13, 0x21c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8644 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F694: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218F698: D0030034  stfs f0, 0x34(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8218F69C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F6A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8218F6A0 size=152
    let mut pc: u32 = 0x8218F6A0;
    'dispatch: loop {
        match pc {
            0x8218F6A0 => {
    //   block [0x8218F6A0..0x8218F6C0)
	// 8218F6A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218F6A4: 483A5A11  bl 0x825350b4
	ctx.lr = 0x8218F6A8;
	sub_82535080(ctx, base);
	// 8218F6A8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218F6AC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8218F6B0: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8218F6B4: 3BDD0008  addi r30, r29, 8
	ctx.r[30].s64 = ctx.r[29].s64 + 8;
	// 8218F6B8: 7F7FDB78  mr r31, r27
	ctx.r[31].u64 = ctx.r[27].u64;
	// 8218F6BC: 3F8082C0  lis r28, -0x7d40
	ctx.r[28].s64 = -2101346304;
	pc = 0x8218F6C0; continue 'dispatch;
            }
            0x8218F6C0 => {
    //   block [0x8218F6C0..0x8218F720)
	// 8218F6C0: 2B1F0008  cmplwi cr6, r31, 8
	ctx.cr[6].compare_u32(ctx.r[31].u32, 8 as u32, &mut ctx.xer);
	// 8218F6C4: 4199005C  bgt cr6, 0x8218f720
	if ctx.cr[6].gt {
	pc = 0x8218F720; continue 'dispatch;
	}
	// 8218F6C8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F6CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F6D0: 419A0050  beq cr6, 0x8218f720
	if ctx.cr[6].eq {
	pc = 0x8218F720; continue 'dispatch;
	}
	// 8218F6D4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8218F6D8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F6DC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218F6E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8218F6E4: 4E800421  bctrl
	ctx.lr = 0x8218F6E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8218F6E8: 2F03000C  cmpwi cr6, r3, 0xc
	ctx.cr[6].compare_i32(ctx.r[3].s32, 12, &mut ctx.xer);
	// 8218F6EC: 409A0034  bne cr6, 0x8218f720
	if !ctx.cr[6].eq {
	pc = 0x8218F720; continue 'dispatch;
	}
	// 8218F6F0: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F6F4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F6F8: 419A0028  beq cr6, 0x8218f720
	if ctx.cr[6].eq {
	pc = 0x8218F720; continue 'dispatch;
	}
	// 8218F6FC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8218F700: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218F704: 4BFFA4CD  bl 0x82189bd0
	ctx.lr = 0x8218F708;
	sub_82189BD0(ctx, base);
	// 8218F708: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218F70C: 8063000C  lwz r3, 0xc(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218F710: 4BFFA451  bl 0x82189b60
	ctx.lr = 0x8218F714;
	sub_82189B60(ctx, base);
	// 8218F714: 7F6BDB78  mr r11, r27
	ctx.r[11].u64 = ctx.r[27].u64;
	// 8218F718: 93630094  stw r27, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[27].u32 ) };
	// 8218F71C: 917CB9BC  stw r11, -0x4644(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(-17988 as u32), ctx.r[11].u32 ) };
            }
            0x8218F720 => {
    //   block [0x8218F720..0x8218F738)
	// 8218F720: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8218F724: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 8218F728: 2F1F0009  cmpwi cr6, r31, 9
	ctx.cr[6].compare_i32(ctx.r[31].s32, 9, &mut ctx.xer);
	// 8218F72C: 4198FF94  blt cr6, 0x8218f6c0
	if ctx.cr[6].lt {
	pc = 0x8218F6C0; continue 'dispatch;
	}
	// 8218F730: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8218F734: 483A59D0  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8218F738(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8218F738 size=2768
    let mut pc: u32 = 0x8218F738;
    'dispatch: loop {
        match pc {
            0x8218F738 => {
    //   block [0x8218F738..0x8218F88C)
	// 8218F738: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8218F73C: 483A5971  bl 0x825350ac
	ctx.lr = 0x8218F740;
	sub_82535080(ctx, base);
	// 8218F740: DBC1FFB0  stfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[30].u64 ) };
	// 8218F744: DBE1FFB8  stfd f31, -0x48(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), ctx.f[31].u64 ) };
	// 8218F748: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8218F74C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8218F750: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F754: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 8218F758: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F75C: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218F760: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218F764: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8218F768: 7D5E502E  lwzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F76C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218F770: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218F774: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F778: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218F77C: 7D7E582E  lwzx r11, r30, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218F780: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8218F784: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218F788: 409A0A70  bne cr6, 0x821901f8
	if !ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F78C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218F790: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218F794: 4BFFA3CD  bl 0x82189b60
	ctx.lr = 0x8218F798;
	sub_82189B60(ctx, base);
	// 8218F798: 3F2082C0  lis r25, -0x7d40
	ctx.r[25].s64 = -2101346304;
	// 8218F79C: 837F0008  lwz r27, 8(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218F7A0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8218F7A4: 835F01A4  lwz r26, 0x1a4(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 8218F7A8: 8179B9BC  lwz r11, -0x4644(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-17988 as u32) ) } as u64;
	// 8218F7AC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218F7B0: 409A00DC  bne cr6, 0x8218f88c
	if !ctx.cr[6].eq {
	pc = 0x8218F88C; continue 'dispatch;
	}
	// 8218F7B4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8218F7B8: 616AED84  ori r10, r11, 0xed84
	ctx.r[10].u64 = ctx.r[11].u64 | 60804;
	// 8218F7BC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8218F7C0: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8218F7C4: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F7C8: 7D29522E  lhzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F7CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218F7D0: 409A00BC  bne cr6, 0x8218f88c
	if !ctx.cr[6].eq {
	pc = 0x8218F88C; continue 'dispatch;
	}
	// 8218F7D4: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	// 8218F7D8: 814B0004  lwz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F7DC: 7D4A4A2E  lhzx r10, r10, r9
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8218F7E0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218F7E4: 409A00A8  bne cr6, 0x8218f88c
	if !ctx.cr[6].eq {
	pc = 0x8218F88C; continue 'dispatch;
	}
	// 8218F7E8: 815F0228  lwz r10, 0x228(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218F7EC: 2F0A0004  cmpwi cr6, r10, 4
	ctx.cr[6].compare_i32(ctx.r[10].s32, 4, &mut ctx.xer);
	// 8218F7F0: 419A0A08  beq cr6, 0x821901f8
	if ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F7F4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 8218F7F8: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218F7FC: 614AEDBE  ori r10, r10, 0xedbe
	ctx.r[10].u64 = ctx.r[10].u64 | 60862;
	// 8218F800: 913F0228  stw r9, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[9].u32 ) };
	// 8218F804: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8218F808: 7D2950AE  lbzx r9, r9, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F80C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8218F810: 409A09E8  bne cr6, 0x821901f8
	if !ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F814: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218F818: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F81C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218F820: 409A09D8  bne cr6, 0x821901f8
	if !ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F824: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218F828: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8218F82C: 3BCBBA38  addi r30, r11, -0x45c8
	ctx.r[30].s64 = ctx.r[11].s64 + -17864;
	// 8218F830: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F834: 915B002C  stw r10, 0x2c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 8218F838: C3FE000C  lfs f31, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218F83C: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218F840: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218F844: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8218F848: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218F84C: 808B0140  lwz r4, 0x140(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 8218F850: 4BFFACA1  bl 0x8218a4f0
	ctx.lr = 0x8218F854;
	sub_8218A4F0(ctx, base);
	// 8218F854: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8218F858: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8218F85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218F860: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218F864: 4BFFAC8D  bl 0x8218a4f0
	ctx.lr = 0x8218F868;
	sub_8218A4F0(ctx, base);
	// 8218F868: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8218F86C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8218F870: C03E0000  lfs f1, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218F874: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8218F878: 4BFFAC79  bl 0x8218a4f0
	ctx.lr = 0x8218F87C;
	sub_8218A4F0(ctx, base);
	// 8218F87C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8218F880: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8218F884: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218F888: 483A5874  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8218F88C => {
    //   block [0x8218F88C..0x8218F904)
	// 8218F88C: 817D0094  lwz r11, 0x94(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(148 as u32) ) } as u64;
	// 8218F890: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218F894: 419A0964  beq cr6, 0x821901f8
	if ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F898: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218F89C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8218F8A0: 419A0958  beq cr6, 0x821901f8
	if ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 8218F8A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218F8A8: 48003849  bl 0x821930f0
	ctx.lr = 0x8218F8AC;
	sub_821930F0(ctx, base);
	// 8218F8AC: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8218F8B0: 815F023C  lwz r10, 0x23c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218F8B4: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F8B8: 617DA9C0  ori r29, r11, 0xa9c0
	ctx.r[29].u64 = ctx.r[11].u64 | 43456;
	// 8218F8BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218F8C0: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8218F8C4: 7D6AE82E  lwzx r11, r10, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8218F8C8: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 8218F8CC: 409A0038  bne cr6, 0x8218f904
	if !ctx.cr[6].eq {
	pc = 0x8218F904; continue 'dispatch;
	}
	// 8218F8D0: 3D2B0002  addis r9, r11, 2
	ctx.r[9].s64 = ctx.r[11].s64 + 131072;
	// 8218F8D4: 395F0030  addi r10, r31, 0x30
	ctx.r[10].s64 = ctx.r[31].s64 + 48;
	// 8218F8D8: 39299BA0  addi r9, r9, -0x6460
	ctx.r[9].s64 = ctx.r[9].s64 + -25696;
	// 8218F8DC: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8218F8E0: 61089B74  ori r8, r8, 0x9b74
	ctx.r[8].u64 = ctx.r[8].u64 | 39796;
	// 8218F8E4: E8E90000  ld r7, 0(r9)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8218F8E8: F8EA0000  std r7, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 8218F8EC: E9290008  ld r9, 8(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8218F8F0: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8218F8F4: 7C0B442E  lfsx f0, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F8F8: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8218F8FC: D3DF0058  stfs f30, 0x58(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F900: D3DF0050  stfs f30, 0x50(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8218F904; continue 'dispatch;
            }
            0x8218F904 => {
    //   block [0x8218F904..0x8218F9D4)
	// 8218F904: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F908: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8218F90C: 7D1E502E  lwzx r8, r30, r10
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F910: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F914: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 8218F918: 7D3E502E  lwzx r9, r30, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F91C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8218F920: 614A860C  ori r10, r10, 0x860c
	ctx.r[10].u64 = ctx.r[10].u64 | 34316;
	// 8218F924: 7D074B78  or r7, r8, r9
	ctx.r[7].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8218F928: 7D5E502E  lwzx r10, r30, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218F92C: 7CE75378  or r7, r7, r10
	ctx.r[7].u64 = ctx.r[7].u64 | ctx.r[10].u64;
	// 8218F930: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8218F934: 409A00A0  bne cr6, 0x8218f9d4
	if !ctx.cr[6].eq {
	pc = 0x8218F9D4; continue 'dispatch;
	}
	// 8218F938: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8218F93C: C01F0050  lfs f0, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F940: 3D200005  lis r9, 5
	ctx.r[9].s64 = 327680;
	// 8218F944: C1BF0058  lfs f13, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F948: 614A923C  ori r10, r10, 0x923c
	ctx.r[10].u64 = ctx.r[10].u64 | 37436;
	// 8218F94C: C19F0054  lfs f12, 0x54(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218F950: 61299240  ori r9, r9, 0x9240
	ctx.r[9].u64 = ctx.r[9].u64 | 37440;
	// 8218F954: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8218F958: 3CE00001  lis r7, 1
	ctx.r[7].s64 = 65536;
	// 8218F95C: 61089C20  ori r8, r8, 0x9c20
	ctx.r[8].u64 = ctx.r[8].u64 | 39968;
	// 8218F960: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8218F964: 60E79C24  ori r7, r7, 0x9c24
	ctx.r[7].u64 = ctx.r[7].u64 | 39972;
	// 8218F968: EC0B002A  fadds f0, f11, f0
	ctx.f[0].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 8218F96C: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F970: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F974: 3CC00001  lis r6, 1
	ctx.r[6].s64 = 65536;
	// 8218F978: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218F97C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F980: 7C0B442E  lfsx f0, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F984: 60C69C28  ori r6, r6, 0x9c28
	ctx.r[6].u64 = ctx.r[6].u64 | 39976;
	// 8218F988: C1BF0050  lfs f13, 0x50(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F98C: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218F990: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8218F994: 7C0B3C2E  lfsx f0, r11, r7
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[7].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F998: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8218F99C: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8218F9A0: 7DAB342E  lfsx f13, r11, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218F9A4: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F9A8: C01F0058  lfs f0, 0x58(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F9AC: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8218F9B0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218F9B4: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8218F9B8: 7D5E582E  lwzx r10, r30, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218F9BC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F9C0: 616B8608  ori r11, r11, 0x8608
	ctx.r[11].u64 = ctx.r[11].u64 | 34312;
	// 8218F9C4: 7D3E582E  lwzx r9, r30, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8218F9C8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8218F9CC: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 8218F9D0: 7D1E582E  lwzx r8, r30, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x8218F9D4; continue 'dispatch;
            }
            0x8218F9D4 => {
    //   block [0x8218F9D4..0x8218F9EC)
	// 8218F9D4: 7D0B4B78  or r11, r8, r9
	ctx.r[11].u64 = ctx.r[8].u64 | ctx.r[9].u64;
	// 8218F9D8: 7D6B5378  or r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 8218F9DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218F9E0: 409A000C  bne cr6, 0x8218f9ec
	if !ctx.cr[6].eq {
	pc = 0x8218F9EC; continue 'dispatch;
	}
	// 8218F9E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218F9E8: 48001D59  bl 0x82191740
	ctx.lr = 0x8218F9EC;
	sub_82191740(ctx, base);
	pc = 0x8218F9EC; continue 'dispatch;
            }
            0x8218F9EC => {
    //   block [0x8218F9EC..0x8218FA4C)
	// 8218F9EC: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 8218F9F0: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218F9F4: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8218F9F8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8218F9FC: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8218FA00: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8218FA04: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8218FA08: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218FA0C: 419800F4  blt cr6, 0x8218fb00
	if ctx.cr[6].lt {
	pc = 0x8218FB00; continue 'dispatch;
	}
	// 8218FA10: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218FA14: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FA18: 409A00E8  bne cr6, 0x8218fb00
	if !ctx.cr[6].eq {
	pc = 0x8218FB00; continue 'dispatch;
	}
	// 8218FA1C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218FA20: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218FA24: 614AEB1C  ori r10, r10, 0xeb1c
	ctx.r[10].u64 = ctx.r[10].u64 | 60188;
	// 8218FA28: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218FA2C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FA30: 409A001C  bne cr6, 0x8218fa4c
	if !ctx.cr[6].eq {
	pc = 0x8218FA4C; continue 'dispatch;
	}
	// 8218FA34: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8218FA38: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 8218FA3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8218FA40: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8218FA44: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218FA48: 483A56B4  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8218FA4C => {
    //   block [0x8218FA4C..0x8218FA78)
	// 8218FA4C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8218FA50: 815F01C0  lwz r10, 0x1c0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 8218FA54: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8218FA58: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 8218FA5C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8218FA60: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218FA64: 419A005C  beq cr6, 0x8218fac0
	if ctx.cr[6].eq {
	pc = 0x8218FAC0; continue 'dispatch;
	}
	// 8218FA68: C01F021C  lfs f0, 0x21c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218FA6C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218FA70: 40990050  ble cr6, 0x8218fac0
	if !ctx.cr[6].gt {
	pc = 0x8218FAC0; continue 'dispatch;
	}
	// 8218FA74: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	pc = 0x8218FA78; continue 'dispatch;
            }
            0x8218FA78 => {
    //   block [0x8218FA78..0x8218FAC0)
	// 8218FA78: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8218FA7C: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8218FA80: 481EA8E1  bl 0x8237a360
	ctx.lr = 0x8218FA84;
	sub_8237A360(ctx, base);
	// 8218FA84: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 8218FA88: 2F040008  cmpwi cr6, r4, 8
	ctx.cr[6].compare_i32(ctx.r[4].s32, 8, &mut ctx.xer);
	// 8218FA8C: 4198FFEC  blt cr6, 0x8218fa78
	if ctx.cr[6].lt {
	pc = 0x8218FA78; continue 'dispatch;
	}
	// 8218FA90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218FA94: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218FA98: 4BFFA0C9  bl 0x82189b60
	ctx.lr = 0x8218FA9C;
	sub_82189B60(ctx, base);
	// 8218FA9C: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218FAA0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8218FAA4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8218FAA8: 808B0140  lwz r4, 0x140(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 8218FAAC: 4BFFAB6D  bl 0x8218a618
	ctx.lr = 0x8218FAB0;
	sub_8218A618(ctx, base);
	// 8218FAB0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8218FAB4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8218FAB8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218FABC: 483A5640  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8218FAC0 => {
    //   block [0x8218FAC0..0x8218FAE0)
	// 8218FAC0: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218FAC4: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218FAC8: 4BFFA099  bl 0x82189b60
	ctx.lr = 0x8218FACC;
	sub_82189B60(ctx, base);
	// 8218FACC: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 8218FAD0: C03F021C  lfs f1, 0x21c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(540 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8218FAD4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8218FAD8: 41990008  bgt cr6, 0x8218fae0
	if ctx.cr[6].gt {
	pc = 0x8218FAE0; continue 'dispatch;
	}
	// 8218FADC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	pc = 0x8218FAE0; continue 'dispatch;
            }
            0x8218FAE0 => {
    //   block [0x8218FAE0..0x8218FB00)
	// 8218FAE0: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218FAE4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8218FAE8: 808B0140  lwz r4, 0x140(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 8218FAEC: 4BFFAB2D  bl 0x8218a618
	ctx.lr = 0x8218FAF0;
	sub_8218A618(ctx, base);
	// 8218FAF0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8218FAF4: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8218FAF8: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 8218FAFC: 483A5600  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            0x8218FB00 => {
    //   block [0x8218FB00..0x8218FB3C)
	// 8218FB00: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218FB04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8218FB08: 3B800001  li r28, 1
	ctx.r[28].s64 = 1;
	// 8218FB0C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FB10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218FB14: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8218FB18: C18B20B0  lfs f12, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8218FB1C: 409A0200  bne cr6, 0x8218fd1c
	if !ctx.cr[6].eq {
	pc = 0x8218FD1C; continue 'dispatch;
	}
	// 8218FB20: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FB24: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FB28: 814B0250  lwz r10, 0x250(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218FB2C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FB30: 409A000C  bne cr6, 0x8218fb3c
	if !ctx.cr[6].eq {
	pc = 0x8218FB3C; continue 'dispatch;
	}
	// 8218FB34: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FB38: 48000008  b 0x8218fb40
	pc = 0x8218FB40; continue 'dispatch;
            }
            0x8218FB3C => {
    //   block [0x8218FB3C..0x8218FB40)
	// 8218FB3C: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FB40; continue 'dispatch;
            }
            0x8218FB40 => {
    //   block [0x8218FB40..0x8218FB58)
	// 8218FB40: 814B0254  lwz r10, 0x254(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218FB44: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8218FB48: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FB4C: 409A000C  bne cr6, 0x8218fb58
	if !ctx.cr[6].eq {
	pc = 0x8218FB58; continue 'dispatch;
	}
	// 8218FB50: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FB54: 48000008  b 0x8218fb5c
	pc = 0x8218FB5C; continue 'dispatch;
            }
            0x8218FB58 => {
    //   block [0x8218FB58..0x8218FB5C)
	// 8218FB58: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FB5C; continue 'dispatch;
            }
            0x8218FB5C => {
    //   block [0x8218FB5C..0x8218FB74)
	// 8218FB5C: 814B0258  lwz r10, 0x258(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(600 as u32) ) } as u64;
	// 8218FB60: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FB64: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FB68: 409A000C  bne cr6, 0x8218fb74
	if !ctx.cr[6].eq {
	pc = 0x8218FB74; continue 'dispatch;
	}
	// 8218FB6C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FB70: 48000008  b 0x8218fb78
	pc = 0x8218FB78; continue 'dispatch;
            }
            0x8218FB74 => {
    //   block [0x8218FB74..0x8218FB78)
	// 8218FB74: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FB78; continue 'dispatch;
            }
            0x8218FB78 => {
    //   block [0x8218FB78..0x8218FB90)
	// 8218FB78: 814B025C  lwz r10, 0x25c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 8218FB7C: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FB80: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FB84: 409A000C  bne cr6, 0x8218fb90
	if !ctx.cr[6].eq {
	pc = 0x8218FB90; continue 'dispatch;
	}
	// 8218FB88: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FB8C: 48000008  b 0x8218fb94
	pc = 0x8218FB94; continue 'dispatch;
            }
            0x8218FB90 => {
    //   block [0x8218FB90..0x8218FB94)
	// 8218FB90: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FB94; continue 'dispatch;
            }
            0x8218FB94 => {
    //   block [0x8218FB94..0x8218FBAC)
	// 8218FB94: 814B0260  lwz r10, 0x260(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 8218FB98: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FB9C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FBA0: 409A000C  bne cr6, 0x8218fbac
	if !ctx.cr[6].eq {
	pc = 0x8218FBAC; continue 'dispatch;
	}
	// 8218FBA4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FBA8: 48000008  b 0x8218fbb0
	pc = 0x8218FBB0; continue 'dispatch;
            }
            0x8218FBAC => {
    //   block [0x8218FBAC..0x8218FBB0)
	// 8218FBAC: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FBB0; continue 'dispatch;
            }
            0x8218FBB0 => {
    //   block [0x8218FBB0..0x8218FBC8)
	// 8218FBB0: 814B0264  lwz r10, 0x264(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8218FBB4: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FBB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FBBC: 409A000C  bne cr6, 0x8218fbc8
	if !ctx.cr[6].eq {
	pc = 0x8218FBC8; continue 'dispatch;
	}
	// 8218FBC0: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FBC4: 48000008  b 0x8218fbcc
	pc = 0x8218FBCC; continue 'dispatch;
            }
            0x8218FBC8 => {
    //   block [0x8218FBC8..0x8218FBCC)
	// 8218FBC8: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FBCC; continue 'dispatch;
            }
            0x8218FBCC => {
    //   block [0x8218FBCC..0x8218FBE4)
	// 8218FBCC: 814B0268  lwz r10, 0x268(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(616 as u32) ) } as u64;
	// 8218FBD0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FBD4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FBD8: 409A000C  bne cr6, 0x8218fbe4
	if !ctx.cr[6].eq {
	pc = 0x8218FBE4; continue 'dispatch;
	}
	// 8218FBDC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FBE0: 48000008  b 0x8218fbe8
	pc = 0x8218FBE8; continue 'dispatch;
            }
            0x8218FBE4 => {
    //   block [0x8218FBE4..0x8218FBE8)
	// 8218FBE4: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FBE8; continue 'dispatch;
            }
            0x8218FBE8 => {
    //   block [0x8218FBE8..0x8218FC00)
	// 8218FBE8: 816B026C  lwz r11, 0x26c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 8218FBEC: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FBF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FBF4: 409A000C  bne cr6, 0x8218fc00
	if !ctx.cr[6].eq {
	pc = 0x8218FC00; continue 'dispatch;
	}
	// 8218FBF8: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FBFC: 48000008  b 0x8218fc04
	pc = 0x8218FC04; continue 'dispatch;
            }
            0x8218FC00 => {
    //   block [0x8218FC00..0x8218FC04)
	// 8218FC00: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FC04; continue 'dispatch;
            }
            0x8218FC04 => {
    //   block [0x8218FC04..0x8218FC20)
	// 8218FC04: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FC08: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8218FC0C: 41980014  blt cr6, 0x8218fc20
	if ctx.cr[6].lt {
	pc = 0x8218FC20; continue 'dispatch;
	}
	// 8218FC10: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8218FC14: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8218FC18: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8218FC1C: 40990100  ble cr6, 0x8218fd1c
	if !ctx.cr[6].gt {
	pc = 0x8218FD1C; continue 'dispatch;
	}
	pc = 0x8218FC20; continue 'dispatch;
            }
            0x8218FC20 => {
    //   block [0x8218FC20..0x8218FC28)
	// 8218FC20: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 8218FC24: 39400254  li r10, 0x254
	ctx.r[10].s64 = 596;
	pc = 0x8218FC28; continue 'dispatch;
            }
            0x8218FC28 => {
    //   block [0x8218FC28..0x8218FC50)
	// 8218FC28: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218FC2C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8218FC30: 41990020  bgt cr6, 0x8218fc50
	if ctx.cr[6].gt {
	pc = 0x8218FC50; continue 'dispatch;
	}
	// 8218FC34: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FC38: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FC3C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FC40: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8218FC44: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FC48: 419A0008  beq cr6, 0x8218fc50
	if ctx.cr[6].eq {
	pc = 0x8218FC50; continue 'dispatch;
	}
	// 8218FC4C: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FC50; continue 'dispatch;
            }
            0x8218FC50 => {
    //   block [0x8218FC50..0x8218FC78)
	// 8218FC50: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8218FC54: 41980024  blt cr6, 0x8218fc78
	if ctx.cr[6].lt {
	pc = 0x8218FC78; continue 'dispatch;
	}
	// 8218FC58: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8218FC5C: 4098001C  bge cr6, 0x8218fc78
	if !ctx.cr[6].lt {
	pc = 0x8218FC78; continue 'dispatch;
	}
	// 8218FC60: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FC64: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FC68: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218FC6C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FC70: 419A0008  beq cr6, 0x8218fc78
	if ctx.cr[6].eq {
	pc = 0x8218FC78; continue 'dispatch;
	}
	// 8218FC74: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FC78; continue 'dispatch;
            }
            0x8218FC78 => {
    //   block [0x8218FC78..0x8218FCA4)
	// 8218FC78: 35690001  addic. r11, r9, 1
	ctx.xer.ca = (ctx.r[9].u32 > (!(1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FC7C: 41800028  blt 0x8218fca4
	if ctx.cr[0].lt {
	pc = 0x8218FCA4; continue 'dispatch;
	}
	// 8218FC80: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FC84: 40980020  bge cr6, 0x8218fca4
	if !ctx.cr[6].lt {
	pc = 0x8218FCA4; continue 'dispatch;
	}
	// 8218FC88: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FC8C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FC90: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FC94: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218FC98: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FC9C: 419A0008  beq cr6, 0x8218fca4
	if ctx.cr[6].eq {
	pc = 0x8218FCA4; continue 'dispatch;
	}
	// 8218FCA0: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FCA4; continue 'dispatch;
            }
            0x8218FCA4 => {
    //   block [0x8218FCA4..0x8218FCD0)
	// 8218FCA4: 35690002  addic. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].u32 > (!(2 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FCA8: 41800028  blt 0x8218fcd0
	if ctx.cr[0].lt {
	pc = 0x8218FCD0; continue 'dispatch;
	}
	// 8218FCAC: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FCB0: 40980020  bge cr6, 0x8218fcd0
	if !ctx.cr[6].lt {
	pc = 0x8218FCD0; continue 'dispatch;
	}
	// 8218FCB4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FCB8: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FCBC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FCC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FCC4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FCC8: 419A0008  beq cr6, 0x8218fcd0
	if ctx.cr[6].eq {
	pc = 0x8218FCD0; continue 'dispatch;
	}
	// 8218FCCC: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FCD0; continue 'dispatch;
            }
            0x8218FCD0 => {
    //   block [0x8218FCD0..0x8218FD0C)
	// 8218FCD0: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8218FCD4: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8218FCD8: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218FCDC: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FCE0: 4198FF48  blt cr6, 0x8218fc28
	if ctx.cr[6].lt {
	pc = 0x8218FC28; continue 'dispatch;
	}
	// 8218FCE4: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FCE8: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FCEC: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8218FCF0: 481E8599  bl 0x82378288
	ctx.lr = 0x8218FCF4;
	sub_82378288(ctx, base);
	// 8218FCF4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218FCF8: 419A0014  beq cr6, 0x8218fd0c
	if ctx.cr[6].eq {
	pc = 0x8218FD0C; continue 'dispatch;
	}
	// 8218FCFC: D3E30084  stfs f31, 0x84(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8218FD00: D3E3008C  stfs f31, 0x8c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8218FD04: D3E30088  stfs f31, 0x88(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8218FD08: 48000014  b 0x8218fd1c
	pc = 0x8218FD1C; continue 'dispatch;
            }
            0x8218FD0C => {
    //   block [0x8218FD0C..0x8218FD1C)
	// 8218FD0C: 81680250  lwz r11, 0x250(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218FD10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FD14: 419A0008  beq cr6, 0x8218fd1c
	if ctx.cr[6].eq {
	pc = 0x8218FD1C; continue 'dispatch;
	}
	// 8218FD18: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FD1C; continue 'dispatch;
            }
            0x8218FD1C => {
    //   block [0x8218FD1C..0x8218FD44)
	// 8218FD1C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218FD20: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8218FD24: 409A02A0  bne cr6, 0x8218ffc4
	if !ctx.cr[6].eq {
	pc = 0x8218FFC4; continue 'dispatch;
	}
	// 8218FD28: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FD2C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FD30: 814B0250  lwz r10, 0x250(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8218FD34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FD38: 409A000C  bne cr6, 0x8218fd44
	if !ctx.cr[6].eq {
	pc = 0x8218FD44; continue 'dispatch;
	}
	// 8218FD3C: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FD40: 48000008  b 0x8218fd48
	pc = 0x8218FD48; continue 'dispatch;
            }
            0x8218FD44 => {
    //   block [0x8218FD44..0x8218FD48)
	// 8218FD44: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FD48; continue 'dispatch;
            }
            0x8218FD48 => {
    //   block [0x8218FD48..0x8218FD60)
	// 8218FD48: 814B0254  lwz r10, 0x254(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(596 as u32) ) } as u64;
	// 8218FD4C: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8218FD50: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FD54: 409A000C  bne cr6, 0x8218fd60
	if !ctx.cr[6].eq {
	pc = 0x8218FD60; continue 'dispatch;
	}
	// 8218FD58: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FD5C: 48000008  b 0x8218fd64
	pc = 0x8218FD64; continue 'dispatch;
            }
            0x8218FD60 => {
    //   block [0x8218FD60..0x8218FD64)
	// 8218FD60: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FD64; continue 'dispatch;
            }
            0x8218FD64 => {
    //   block [0x8218FD64..0x8218FD7C)
	// 8218FD64: 814B0258  lwz r10, 0x258(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(600 as u32) ) } as u64;
	// 8218FD68: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FD6C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FD70: 409A000C  bne cr6, 0x8218fd7c
	if !ctx.cr[6].eq {
	pc = 0x8218FD7C; continue 'dispatch;
	}
	// 8218FD74: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FD78: 48000008  b 0x8218fd80
	pc = 0x8218FD80; continue 'dispatch;
            }
            0x8218FD7C => {
    //   block [0x8218FD7C..0x8218FD80)
	// 8218FD7C: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FD80; continue 'dispatch;
            }
            0x8218FD80 => {
    //   block [0x8218FD80..0x8218FD98)
	// 8218FD80: 814B025C  lwz r10, 0x25c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 8218FD84: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FD88: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FD8C: 409A000C  bne cr6, 0x8218fd98
	if !ctx.cr[6].eq {
	pc = 0x8218FD98; continue 'dispatch;
	}
	// 8218FD90: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FD94: 48000008  b 0x8218fd9c
	pc = 0x8218FD9C; continue 'dispatch;
            }
            0x8218FD98 => {
    //   block [0x8218FD98..0x8218FD9C)
	// 8218FD98: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FD9C; continue 'dispatch;
            }
            0x8218FD9C => {
    //   block [0x8218FD9C..0x8218FDB4)
	// 8218FD9C: 814B0260  lwz r10, 0x260(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(608 as u32) ) } as u64;
	// 8218FDA0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FDA4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FDA8: 409A000C  bne cr6, 0x8218fdb4
	if !ctx.cr[6].eq {
	pc = 0x8218FDB4; continue 'dispatch;
	}
	// 8218FDAC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FDB0: 48000008  b 0x8218fdb8
	pc = 0x8218FDB8; continue 'dispatch;
            }
            0x8218FDB4 => {
    //   block [0x8218FDB4..0x8218FDB8)
	// 8218FDB4: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FDB8; continue 'dispatch;
            }
            0x8218FDB8 => {
    //   block [0x8218FDB8..0x8218FDD0)
	// 8218FDB8: 814B0264  lwz r10, 0x264(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8218FDBC: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FDC0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FDC4: 409A000C  bne cr6, 0x8218fdd0
	if !ctx.cr[6].eq {
	pc = 0x8218FDD0; continue 'dispatch;
	}
	// 8218FDC8: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FDCC: 48000008  b 0x8218fdd4
	pc = 0x8218FDD4; continue 'dispatch;
            }
            0x8218FDD0 => {
    //   block [0x8218FDD0..0x8218FDD4)
	// 8218FDD0: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FDD4; continue 'dispatch;
            }
            0x8218FDD4 => {
    //   block [0x8218FDD4..0x8218FDEC)
	// 8218FDD4: 814B0268  lwz r10, 0x268(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(616 as u32) ) } as u64;
	// 8218FDD8: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FDDC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8218FDE0: 409A000C  bne cr6, 0x8218fdec
	if !ctx.cr[6].eq {
	pc = 0x8218FDEC; continue 'dispatch;
	}
	// 8218FDE4: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FDE8: 48000008  b 0x8218fdf0
	pc = 0x8218FDF0; continue 'dispatch;
            }
            0x8218FDEC => {
    //   block [0x8218FDEC..0x8218FDF0)
	// 8218FDEC: C00A009C  lfs f0, 0x9c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FDF0; continue 'dispatch;
            }
            0x8218FDF0 => {
    //   block [0x8218FDF0..0x8218FE08)
	// 8218FDF0: 816B026C  lwz r11, 0x26c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 8218FDF4: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FDF8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FDFC: 409A000C  bne cr6, 0x8218fe08
	if !ctx.cr[6].eq {
	pc = 0x8218FE08; continue 'dispatch;
	}
	// 8218FE00: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 8218FE04: 48000008  b 0x8218fe0c
	pc = 0x8218FE0C; continue 'dispatch;
            }
            0x8218FE08 => {
    //   block [0x8218FE08..0x8218FE0C)
	// 8218FE08: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8218FE0C; continue 'dispatch;
            }
            0x8218FE0C => {
    //   block [0x8218FE0C..0x8218FE38)
	// 8218FE0C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8218FE10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218FE14: C1AB2420  lfs f13, 0x2420(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218FE18: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8218FE1C: 4198001C  blt cr6, 0x8218fe38
	if ctx.cr[6].lt {
	pc = 0x8218FE38; continue 'dispatch;
	}
	// 8218FE20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8218FE24: C1AB2278  lfs f13, 0x2278(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8824 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218FE28: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218FE2C: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8218FE30: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8218FE34: 40990114  ble cr6, 0x8218ff48
	if !ctx.cr[6].gt {
	pc = 0x8218FF48; continue 'dispatch;
	}
	pc = 0x8218FE38; continue 'dispatch;
            }
            0x8218FE38 => {
    //   block [0x8218FE38..0x8218FE40)
	// 8218FE38: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 8218FE3C: 39400254  li r10, 0x254
	ctx.r[10].s64 = 596;
	pc = 0x8218FE40; continue 'dispatch;
            }
            0x8218FE40 => {
    //   block [0x8218FE40..0x8218FE68)
	// 8218FE40: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218FE44: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 8218FE48: 41990020  bgt cr6, 0x8218fe68
	if ctx.cr[6].gt {
	pc = 0x8218FE68; continue 'dispatch;
	}
	// 8218FE4C: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FE50: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FE54: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FE58: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 8218FE5C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FE60: 419A0008  beq cr6, 0x8218fe68
	if ctx.cr[6].eq {
	pc = 0x8218FE68; continue 'dispatch;
	}
	// 8218FE64: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FE68; continue 'dispatch;
            }
            0x8218FE68 => {
    //   block [0x8218FE68..0x8218FE90)
	// 8218FE68: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8218FE6C: 41980024  blt cr6, 0x8218fe90
	if ctx.cr[6].lt {
	pc = 0x8218FE90; continue 'dispatch;
	}
	// 8218FE70: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8218FE74: 4098001C  bge cr6, 0x8218fe90
	if !ctx.cr[6].lt {
	pc = 0x8218FE90; continue 'dispatch;
	}
	// 8218FE78: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FE7C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FE80: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218FE84: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FE88: 419A0008  beq cr6, 0x8218fe90
	if ctx.cr[6].eq {
	pc = 0x8218FE90; continue 'dispatch;
	}
	// 8218FE8C: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FE90; continue 'dispatch;
            }
            0x8218FE90 => {
    //   block [0x8218FE90..0x8218FEBC)
	// 8218FE90: 35690001  addic. r11, r9, 1
	ctx.xer.ca = (ctx.r[9].u32 > (!(1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FE94: 41800028  blt 0x8218febc
	if ctx.cr[0].lt {
	pc = 0x8218FEBC; continue 'dispatch;
	}
	// 8218FE98: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FE9C: 40980020  bge cr6, 0x8218febc
	if !ctx.cr[6].lt {
	pc = 0x8218FEBC; continue 'dispatch;
	}
	// 8218FEA0: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FEA4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FEA8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FEAC: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8218FEB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FEB4: 419A0008  beq cr6, 0x8218febc
	if ctx.cr[6].eq {
	pc = 0x8218FEBC; continue 'dispatch;
	}
	// 8218FEB8: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FEBC; continue 'dispatch;
            }
            0x8218FEBC => {
    //   block [0x8218FEBC..0x8218FEE8)
	// 8218FEBC: 35690002  addic. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].u32 > (!(2 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FEC0: 41800028  blt 0x8218fee8
	if ctx.cr[0].lt {
	pc = 0x8218FEE8; continue 'dispatch;
	}
	// 8218FEC4: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FEC8: 40980020  bge cr6, 0x8218fee8
	if !ctx.cr[6].lt {
	pc = 0x8218FEE8; continue 'dispatch;
	}
	// 8218FECC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FED0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FED4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8218FED8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FEDC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FEE0: 419A0008  beq cr6, 0x8218fee8
	if ctx.cr[6].eq {
	pc = 0x8218FEE8; continue 'dispatch;
	}
	// 8218FEE4: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FEE8; continue 'dispatch;
            }
            0x8218FEE8 => {
    //   block [0x8218FEE8..0x8218FF24)
	// 8218FEE8: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 8218FEEC: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 8218FEF0: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8218FEF4: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 8218FEF8: 4198FF48  blt cr6, 0x8218fe40
	if ctx.cr[6].lt {
	pc = 0x8218FE40; continue 'dispatch;
	}
	// 8218FEFC: 817F0008  lwz r11, 8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8218FF00: 810B0028  lwz r8, 0x28(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8218FF04: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8218FF08: 481E8381  bl 0x82378288
	ctx.lr = 0x8218FF0C;
	sub_82378288(ctx, base);
	// 8218FF0C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218FF10: 419A0014  beq cr6, 0x8218ff24
	if ctx.cr[6].eq {
	pc = 0x8218FF24; continue 'dispatch;
	}
	// 8218FF14: D3E30084  stfs f31, 0x84(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8218FF18: D3E3008C  stfs f31, 0x8c(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8218FF1C: D3E30088  stfs f31, 0x88(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8218FF20: 48000028  b 0x8218ff48
	pc = 0x8218FF48; continue 'dispatch;
            }
            0x8218FF24 => {
    //   block [0x8218FF24..0x8218FF38)
	// 8218FF24: 817F0218  lwz r11, 0x218(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) } as u64;
	// 8218FF28: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8218FF2C: 409A000C  bne cr6, 0x8218ff38
	if !ctx.cr[6].eq {
	pc = 0x8218FF38; continue 'dispatch;
	}
	// 8218FF30: 8168025C  lwz r11, 0x25c(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(604 as u32) ) } as u64;
	// 8218FF34: 48000008  b 0x8218ff3c
	pc = 0x8218FF3C; continue 'dispatch;
            }
            0x8218FF38 => {
    //   block [0x8218FF38..0x8218FF3C)
	// 8218FF38: 81680258  lwz r11, 0x258(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(600 as u32) ) } as u64;
	pc = 0x8218FF3C; continue 'dispatch;
            }
            0x8218FF3C => {
    //   block [0x8218FF3C..0x8218FF48)
	// 8218FF3C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FF40: 419A0008  beq cr6, 0x8218ff48
	if ctx.cr[6].eq {
	pc = 0x8218FF48; continue 'dispatch;
	}
	// 8218FF44: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8218FF48; continue 'dispatch;
            }
            0x8218FF48 => {
    //   block [0x8218FF48..0x8218FF94)
	// 8218FF48: 809F023C  lwz r4, 0x23c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218FF4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8218FF50: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8218FF54: 7CA4E82E  lwzx r5, r4, r29
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8218FF58: 80CB0140  lwz r6, 0x140(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 8218FF5C: 4BFFA0F5  bl 0x8218a050
	ctx.lr = 0x8218FF60;
	sub_8218A050(ctx, base);
	// 8218FF60: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8218FF64: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218FF68: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8218FF6C: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 8218FF70: 419A0024  beq cr6, 0x8218ff94
	if ctx.cr[6].eq {
	pc = 0x8218FF94; continue 'dispatch;
	}
	// 8218FF74: 917A02F0  stw r11, 0x2f0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 8218FF78: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8218FF7C: 939A029C  stw r28, 0x29c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(668 as u32), ctx.r[28].u32 ) };
	// 8218FF80: 917A02F4  stw r11, 0x2f4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 8218FF84: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218FF88: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218FF8C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8218FF90: 48000020  b 0x8218ffb0
	pc = 0x8218FFB0; continue 'dispatch;
            }
            0x8218FF94 => {
    //   block [0x8218FF94..0x8218FFB0)
	// 8218FF94: 917A02F4  stw r11, 0x2f4(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 8218FF98: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8218FF9C: 939A029C  stw r28, 0x29c(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(668 as u32), ctx.r[28].u32 ) };
	// 8218FFA0: 917A02F0  stw r11, 0x2f0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 8218FFA4: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8218FFA8: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8218FFAC: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	pc = 0x8218FFB0; continue 'dispatch;
            }
            0x8218FFB0 => {
    //   block [0x8218FFB0..0x8218FFC0)
	// 8218FFB0: 409A0010  bne cr6, 0x8218ffc0
	if !ctx.cr[6].eq {
	pc = 0x8218FFC0; continue 'dispatch;
	}
	// 8218FFB4: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8218FFB8: 917A0230  stw r11, 0x230(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 8218FFBC: 48000008  b 0x8218ffc4
	pc = 0x8218FFC4; continue 'dispatch;
            }
            0x8218FFC0 => {
    //   block [0x8218FFC0..0x8218FFC4)
	// 8218FFC0: 939A0230  stw r28, 0x230(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(560 as u32), ctx.r[28].u32 ) };
	pc = 0x8218FFC4; continue 'dispatch;
            }
            0x8218FFC4 => {
    //   block [0x8218FFC4..0x8219003C)
	// 8218FFC4: C1BF0220  lfs f13, 0x220(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218FFC8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8218FFCC: C01F0204  lfs f0, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8218FFD0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8218FFD4: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8218FFD8: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8218FFDC: 41980078  blt cr6, 0x82190054
	if ctx.cr[6].lt {
	pc = 0x82190054; continue 'dispatch;
	}
	// 8218FFE0: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8218FFE4: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8218FFE8: 409A006C  bne cr6, 0x82190054
	if !ctx.cr[6].eq {
	pc = 0x82190054; continue 'dispatch;
	}
	// 8218FFEC: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 8218FFF0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8218FFF4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 8218FFF8: 93DF0228  stw r30, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[30].u32 ) };
	// 8218FFFC: 4BFF9B65  bl 0x82189b60
	ctx.lr = 0x82190000;
	sub_82189B60(ctx, base);
	// 82190000: C01F0220  lfs f0, 0x220(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190004: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82190008: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219000C: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 82190010: 816B0140  lwz r11, 0x140(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 82190014: 93A30078  stw r29, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 82190018: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 8219001C: FC0D07EE  fsel f0, f13, f31, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[31].f64 } else { ctx.f[0].f64 };
	// 82190020: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82190024: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190028: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 8219002C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190030: 409A000C  bne cr6, 0x8219003c
	if !ctx.cr[6].eq {
	pc = 0x8219003C; continue 'dispatch;
	}
	// 82190034: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 82190038: 48000008  b 0x82190040
	pc = 0x82190040; continue 'dispatch;
            }
            0x8219003C => {
    //   block [0x8219003C..0x82190040)
	// 8219003C: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82190040; continue 'dispatch;
            }
            0x82190040 => {
    //   block [0x82190040..0x82190054)
	// 82190040: EDBF0028  fsubs f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190044: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82190048: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219004C: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 82190050: D3C30014  stfs f30, 0x14(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82190054; continue 'dispatch;
            }
            0x82190054 => {
    //   block [0x82190054..0x82190070)
	// 82190054: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190058: C1BF0204  lfs f13, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219005C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190060: 40990010  ble cr6, 0x82190070
	if !ctx.cr[6].gt {
	pc = 0x82190070; continue 'dispatch;
	}
	// 82190064: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82190068: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 8219006C: 409A0010  bne cr6, 0x8219007c
	if !ctx.cr[6].eq {
	pc = 0x8219007C; continue 'dispatch;
	}
	pc = 0x82190070; continue 'dispatch;
            }
            0x82190070 => {
    //   block [0x82190070..0x8219007C)
	// 82190070: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82190074: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82190078: 409A0124  bne cr6, 0x8219019c
	if !ctx.cr[6].eq {
	pc = 0x8219019C; continue 'dispatch;
	}
	pc = 0x8219007C; continue 'dispatch;
            }
            0x8219007C => {
    //   block [0x8219007C..0x82190090)
	// 8219007C: 815F01C4  lwz r10, 0x1c4(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82190080: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82190084: 419A000C  beq cr6, 0x82190090
	if ctx.cr[6].eq {
	pc = 0x82190090; continue 'dispatch;
	}
	// 82190088: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219008C: 409A00B8  bne cr6, 0x82190144
	if !ctx.cr[6].eq {
	pc = 0x82190144; continue 'dispatch;
	}
	pc = 0x82190090; continue 'dispatch;
            }
            0x82190090 => {
    //   block [0x82190090..0x82190098)
	// 82190090: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 82190094: 39400254  li r10, 0x254
	ctx.r[10].s64 = 596;
	pc = 0x82190098; continue 'dispatch;
            }
            0x82190098 => {
    //   block [0x82190098..0x821900BC)
	// 82190098: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8219009C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 821900A0: 4199001C  bgt cr6, 0x821900bc
	if ctx.cr[6].gt {
	pc = 0x821900BC; continue 'dispatch;
	}
	// 821900A4: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821900A8: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821900AC: 816BFFFC  lwz r11, -4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 821900B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821900B4: 419A0008  beq cr6, 0x821900bc
	if ctx.cr[6].eq {
	pc = 0x821900BC; continue 'dispatch;
	}
	// 821900B8: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x821900BC; continue 'dispatch;
            }
            0x821900BC => {
    //   block [0x821900BC..0x821900E0)
	// 821900BC: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 821900C0: 41980020  blt cr6, 0x821900e0
	if ctx.cr[6].lt {
	pc = 0x821900E0; continue 'dispatch;
	}
	// 821900C4: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 821900C8: 40980018  bge cr6, 0x821900e0
	if !ctx.cr[6].lt {
	pc = 0x821900E0; continue 'dispatch;
	}
	// 821900CC: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821900D0: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821900D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821900D8: 419A0008  beq cr6, 0x821900e0
	if ctx.cr[6].eq {
	pc = 0x821900E0; continue 'dispatch;
	}
	// 821900DC: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x821900E0; continue 'dispatch;
            }
            0x821900E0 => {
    //   block [0x821900E0..0x82190108)
	// 821900E0: 35690001  addic. r11, r9, 1
	ctx.xer.ca = (ctx.r[9].u32 > (!(1 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 1;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821900E4: 41800024  blt 0x82190108
	if ctx.cr[0].lt {
	pc = 0x82190108; continue 'dispatch;
	}
	// 821900E8: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 821900EC: 4098001C  bge cr6, 0x82190108
	if !ctx.cr[6].lt {
	pc = 0x82190108; continue 'dispatch;
	}
	// 821900F0: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 821900F4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821900F8: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821900FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190100: 419A0008  beq cr6, 0x82190108
	if ctx.cr[6].eq {
	pc = 0x82190108; continue 'dispatch;
	}
	// 82190104: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82190108; continue 'dispatch;
            }
            0x82190108 => {
    //   block [0x82190108..0x82190130)
	// 82190108: 35690002  addic. r11, r9, 2
	ctx.xer.ca = (ctx.r[9].u32 > (!(2 as u32)));
	ctx.r[11].s64 = ctx.r[9].s64 + 2;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219010C: 41800024  blt 0x82190130
	if ctx.cr[0].lt {
	pc = 0x82190130; continue 'dispatch;
	}
	// 82190110: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82190114: 4098001C  bge cr6, 0x82190130
	if !ctx.cr[6].lt {
	pc = 0x82190130; continue 'dispatch;
	}
	// 82190118: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219011C: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82190120: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82190124: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190128: 419A0008  beq cr6, 0x82190130
	if ctx.cr[6].eq {
	pc = 0x82190130; continue 'dispatch;
	}
	// 8219012C: D3CB009C  stfs f30, 0x9c(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82190130; continue 'dispatch;
            }
            0x82190130 => {
    //   block [0x82190130..0x82190144)
	// 82190130: 39290004  addi r9, r9, 4
	ctx.r[9].s64 = ctx.r[9].s64 + 4;
	// 82190134: 394A0010  addi r10, r10, 0x10
	ctx.r[10].s64 = ctx.r[10].s64 + 16;
	// 82190138: 3969FFFF  addi r11, r9, -1
	ctx.r[11].s64 = ctx.r[9].s64 + -1;
	// 8219013C: 2F0B0008  cmpwi cr6, r11, 8
	ctx.cr[6].compare_i32(ctx.r[11].s32, 8, &mut ctx.xer);
	// 82190140: 4198FF58  blt cr6, 0x82190098
	if ctx.cr[6].lt {
	pc = 0x82190098; continue 'dispatch;
	}
	pc = 0x82190144; continue 'dispatch;
            }
            0x82190144 => {
    //   block [0x82190144..0x82190164)
	// 82190144: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82190148: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 8219014C: 93BA0230  stw r29, 0x230(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(560 as u32), ctx.r[29].u32 ) };
	// 82190150: 817B0028  lwz r11, 0x28(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190154: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82190158: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219015C: 419A0008  beq cr6, 0x82190164
	if ctx.cr[6].eq {
	pc = 0x82190164; continue 'dispatch;
	}
	// 82190160: D3EB009C  stfs f31, 0x9c(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82190164; continue 'dispatch;
            }
            0x82190164 => {
    //   block [0x82190164..0x8219019C)
	// 82190164: 817F0020  lwz r11, 0x20(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82190168: 816B0140  lwz r11, 0x140(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(320 as u32) ) } as u64;
	// 8219016C: 2B0B0007  cmplwi cr6, r11, 7
	ctx.cr[6].compare_u32(ctx.r[11].u32, 7 as u32, &mut ctx.xer);
	// 82190170: 4199002C  bgt cr6, 0x8219019c
	if ctx.cr[6].gt {
	pc = 0x8219019C; continue 'dispatch;
	}
	// 82190174: 396B0094  addi r11, r11, 0x94
	ctx.r[11].s64 = ctx.r[11].s64 + 148;
	// 82190178: 815B0028  lwz r10, 0x28(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219017C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82190180: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82190184: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190188: 419A0014  beq cr6, 0x8219019c
	if ctx.cr[6].eq {
	pc = 0x8219019C; continue 'dispatch;
	}
	// 8219018C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82190190: C80A2008  lfd f0, 0x2008(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 82190194: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82190198: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x8219019C; continue 'dispatch;
            }
            0x8219019C => {
    //   block [0x8219019C..0x821901E8)
	// 8219019C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 821901A0: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 821901A4: 409A0054  bne cr6, 0x821901f8
	if !ctx.cr[6].eq {
	pc = 0x821901F8; continue 'dispatch;
	}
	// 821901A8: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 821901AC: 83DF000C  lwz r30, 0xc(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821901B0: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 821901B4: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 821901B8: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821901BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821901C0: 419A0028  beq cr6, 0x821901e8
	if ctx.cr[6].eq {
	pc = 0x821901E8; continue 'dispatch;
	}
	// 821901C4: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 821901C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821901CC: 816B000C  lwz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821901D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821901D4: 4E800421  bctrl
	ctx.lr = 0x821901D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821901D8: 2F030001  cmpwi cr6, r3, 1
	ctx.cr[6].compare_i32(ctx.r[3].s32, 1, &mut ctx.xer);
	// 821901DC: 409A000C  bne cr6, 0x821901e8
	if !ctx.cr[6].eq {
	pc = 0x821901E8; continue 'dispatch;
	}
	// 821901E0: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 821901E4: 48000008  b 0x821901ec
	pc = 0x821901EC; continue 'dispatch;
            }
            0x821901E8 => {
    //   block [0x821901E8..0x821901EC)
	// 821901E8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	pc = 0x821901EC; continue 'dispatch;
            }
            0x821901EC => {
    //   block [0x821901EC..0x821901F8)
	// 821901EC: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	// 821901F0: 93AB0094  stw r29, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 821901F4: 9159B9BC  stw r10, -0x4644(r25)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[25].u32.wrapping_add(-17988 as u32), ctx.r[10].u32 ) };
	pc = 0x821901F8; continue 'dispatch;
            }
            0x821901F8 => {
    //   block [0x821901F8..0x82190208)
	// 821901F8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821901FC: CBC1FFB0  lfd f30, -0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 82190200: CBE1FFB8  lfd f31, -0x48(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-72 as u32) ) };
	// 82190204: 483A4EF8  b 0x825350fc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190208(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82190208 size=2232
    let mut pc: u32 = 0x82190208;
    'dispatch: loop {
        match pc {
            0x82190208 => {
    //   block [0x82190208..0x821902E4)
	// 82190208: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219020C: 483A4EA5  bl 0x825350b0
	ctx.lr = 0x82190210;
	sub_82535080(ctx, base);
	// 82190210: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82190214: 483A5DCD  bl 0x82535fe0
	ctx.lr = 0x82190218;
	sub_82535FB0(ctx, base);
	// 82190218: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219021C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82190220: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82190224: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82190228: 4BFF9939  bl 0x82189b60
	ctx.lr = 0x8219022C;
	sub_82189B60(ctx, base);
	// 8219022C: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82190230: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82190234: 419A087C  beq cr6, 0x82190ab0
	if ctx.cr[6].eq {
	pc = 0x82190AB0; continue 'dispatch;
	}
	// 82190238: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219023C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82190240: 419A0870  beq cr6, 0x82190ab0
	if ctx.cr[6].eq {
	pc = 0x82190AB0; continue 'dispatch;
	}
	// 82190244: 813F0228  lwz r9, 0x228(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82190248: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 8219024C: 419A0864  beq cr6, 0x82190ab0
	if ctx.cr[6].eq {
	pc = 0x82190AB0; continue 'dispatch;
	}
	// 82190250: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82190254: 83DF01A4  lwz r30, 0x1a4(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(420 as u32) ) } as u64;
	// 82190258: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219025C: 837F01A0  lwz r27, 0x1a0(r31)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) } as u64;
	// 82190260: 3BABBFF0  addi r29, r11, -0x4010
	ctx.r[29].s64 = ctx.r[11].s64 + -16400;
	// 82190264: 835F0008  lwz r26, 8(r31)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82190268: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219026C: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 82190270: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 82190274: 811E02F0  lwz r8, 0x2f0(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(752 as u32) ) } as u64;
	// 82190278: C17E0054  lfs f11, 0x54(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219027C: C03E0060  lfs f1, 0x60(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82190280: C05E0064  lfs f2, 0x64(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(100 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82190284: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82190288: C07E0068  lfs f3, 0x68(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(104 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219028C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82190290: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82190294: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82190298: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 8219029C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821902A0: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 821902A4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821902A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821902AC: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821902B0: 409A0258  bne cr6, 0x82190508
	if !ctx.cr[6].eq {
	pc = 0x82190508; continue 'dispatch;
	}
	// 821902B4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 821902B8: 409A0250  bne cr6, 0x82190508
	if !ctx.cr[6].eq {
	pc = 0x82190508; continue 'dispatch;
	}
	// 821902BC: 815F0238  lwz r10, 0x238(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(568 as u32) ) } as u64;
	// 821902C0: 554B039C  rlwinm r11, r10, 0, 0xe, 0xe
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821902C4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821902C8: 554B0318  rlwinm r11, r10, 0, 0xc, 0xc
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821902CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821902D0: 419A0014  beq cr6, 0x821902e4
	if ctx.cr[6].eq {
	pc = 0x821902E4; continue 'dispatch;
	}
	// 821902D4: C01F01F8  lfs f0, 0x1f8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821902D8: C1BF01D4  lfs f13, 0x1d4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821902DC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821902E0: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	pc = 0x821902E4; continue 'dispatch;
            }
            0x821902E4 => {
    //   block [0x821902E4..0x82190300)
	// 821902E4: 554B02D6  rlwinm r11, r10, 0, 0xb, 0xb
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821902E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821902EC: 419A0014  beq cr6, 0x82190300
	if ctx.cr[6].eq {
	pc = 0x82190300; continue 'dispatch;
	}
	// 821902F0: C01F01F8  lfs f0, 0x1f8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821902F4: C1BF01D4  lfs f13, 0x1d4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(468 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821902F8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821902FC: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	pc = 0x82190300; continue 'dispatch;
            }
            0x82190300 => {
    //   block [0x82190300..0x82190350)
	// 82190300: 554B056A  rlwinm r11, r10, 0, 0x15, 0x15
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190304: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190308: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219030C: C18B25D8  lfs f12, 0x25d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9688 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82190310: 419A0114  beq cr6, 0x82190424
	if ctx.cr[6].eq {
	pc = 0x82190424; continue 'dispatch;
	}
	// 82190314: 554B04A4  rlwinm r11, r10, 0, 0x12, 0x12
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190318: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219031C: 419A0050  beq cr6, 0x8219036c
	if ctx.cr[6].eq {
	pc = 0x8219036C; continue 'dispatch;
	}
	// 82190320: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82190324: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190328: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219032C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82190330: 409A0020  bne cr6, 0x82190350
	if !ctx.cr[6].eq {
	pc = 0x82190350; continue 'dispatch;
	}
	// 82190334: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82190338: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219033C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82190340: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82190344: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190348: 41980024  blt cr6, 0x8219036c
	if ctx.cr[6].lt {
	pc = 0x8219036C; continue 'dispatch;
	}
	// 8219034C: 4800001C  b 0x82190368
	pc = 0x82190368; continue 'dispatch;
            }
            0x82190350 => {
    //   block [0x82190350..0x82190368)
	// 82190350: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82190354: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190358: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219035C: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82190360: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190364: 41990008  bgt cr6, 0x8219036c
	if ctx.cr[6].gt {
	pc = 0x8219036C; continue 'dispatch;
	}
	pc = 0x82190368; continue 'dispatch;
            }
            0x82190368 => {
    //   block [0x82190368..0x8219036C)
	// 82190368: D37F01D8  stfs f27, 0x1d8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x8219036C; continue 'dispatch;
            }
            0x8219036C => {
    //   block [0x8219036C..0x821903A8)
	// 8219036C: 554B0462  rlwinm r11, r10, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190370: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190374: 419A0050  beq cr6, 0x821903c4
	if ctx.cr[6].eq {
	pc = 0x821903C4; continue 'dispatch;
	}
	// 82190378: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8219037C: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190380: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190384: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82190388: 409A0020  bne cr6, 0x821903a8
	if !ctx.cr[6].eq {
	pc = 0x821903A8; continue 'dispatch;
	}
	// 8219038C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82190390: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190394: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82190398: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 8219039C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821903A0: 41990024  bgt cr6, 0x821903c4
	if ctx.cr[6].gt {
	pc = 0x821903C4; continue 'dispatch;
	}
	// 821903A4: 4800001C  b 0x821903c0
	pc = 0x821903C0; continue 'dispatch;
            }
            0x821903A8 => {
    //   block [0x821903A8..0x821903C0)
	// 821903A8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821903AC: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821903B0: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 821903B4: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 821903B8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821903BC: 41980008  blt cr6, 0x821903c4
	if ctx.cr[6].lt {
	pc = 0x821903C4; continue 'dispatch;
	}
	pc = 0x821903C0; continue 'dispatch;
            }
            0x821903C0 => {
    //   block [0x821903C0..0x821903C4)
	// 821903C0: D37F01D8  stfs f27, 0x1d8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x821903C4; continue 'dispatch;
            }
            0x821903C4 => {
    //   block [0x821903C4..0x82190408)
	// 821903C4: 554B0420  rlwinm r11, r10, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821903C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821903CC: 419A0058  beq cr6, 0x82190424
	if ctx.cr[6].eq {
	pc = 0x82190424; continue 'dispatch;
	}
	// 821903D0: 817F0214  lwz r11, 0x214(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) } as u64;
	// 821903D4: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821903D8: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821903DC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821903E0: C15F01CC  lfs f10, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821903E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821903E8: 409A0020  bne cr6, 0x82190408
	if !ctx.cr[6].eq {
	pc = 0x82190408; continue 'dispatch;
	}
	// 821903EC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821903F0: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821903F4: EDAA6828  fsubs f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 - ctx.f[13].f64) as f32) as f64);
	// 821903F8: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 821903FC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190400: 41990024  bgt cr6, 0x82190424
	if ctx.cr[6].gt {
	pc = 0x82190424; continue 'dispatch;
	}
	// 82190404: 4800001C  b 0x82190420
	pc = 0x82190420; continue 'dispatch;
            }
            0x82190408 => {
    //   block [0x82190408..0x82190420)
	// 82190408: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8219040C: C1ABBFFC  lfs f13, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190410: EDAA682A  fadds f13, f10, f13
	ctx.f[13].f64 = ((ctx.f[10].f64 + ctx.f[13].f64) as f32) as f64;
	// 82190414: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82190418: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219041C: 41980008  blt cr6, 0x82190424
	if ctx.cr[6].lt {
	pc = 0x82190424; continue 'dispatch;
	}
	pc = 0x82190420; continue 'dispatch;
            }
            0x82190420 => {
    //   block [0x82190420..0x82190424)
	// 82190420: D37F01D8  stfs f27, 0x1d8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x82190424; continue 'dispatch;
            }
            0x82190424 => {
    //   block [0x82190424..0x82190434)
	// 82190424: 554B04E6  rlwinm r11, r10, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190428: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219042C: 419A0008  beq cr6, 0x82190434
	if ctx.cr[6].eq {
	pc = 0x82190434; continue 'dispatch;
	}
	// 82190430: D17F01FC  stfs f11, 0x1fc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	pc = 0x82190434; continue 'dispatch;
            }
            0x82190434 => {
    //   block [0x82190434..0x82190470)
	// 82190434: 554B05AC  rlwinm r11, r10, 0, 0x16, 0x16
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190438: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219043C: 419A0050  beq cr6, 0x8219048c
	if ctx.cr[6].eq {
	pc = 0x8219048C; continue 'dispatch;
	}
	// 82190440: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82190444: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190448: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219044C: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82190450: 409A0020  bne cr6, 0x82190470
	if !ctx.cr[6].eq {
	pc = 0x82190470; continue 'dispatch;
	}
	// 82190454: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82190458: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219045C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82190460: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82190464: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190468: 41980024  blt cr6, 0x8219048c
	if ctx.cr[6].lt {
	pc = 0x8219048C; continue 'dispatch;
	}
	// 8219046C: 4800001C  b 0x82190488
	pc = 0x82190488; continue 'dispatch;
            }
            0x82190470 => {
    //   block [0x82190470..0x82190488)
	// 82190470: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82190474: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190478: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219047C: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 82190480: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82190484: 41990008  bgt cr6, 0x8219048c
	if ctx.cr[6].gt {
	pc = 0x8219048C; continue 'dispatch;
	}
	pc = 0x82190488; continue 'dispatch;
            }
            0x82190488 => {
    //   block [0x82190488..0x8219048C)
	// 82190488: D37F01D8  stfs f27, 0x1d8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x8219048C; continue 'dispatch;
            }
            0x8219048C => {
    //   block [0x8219048C..0x821904C8)
	// 8219048C: 554B0528  rlwinm r11, r10, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 82190490: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190494: 419A0050  beq cr6, 0x821904e4
	if ctx.cr[6].eq {
	pc = 0x821904E4; continue 'dispatch;
	}
	// 82190498: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8219049C: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821904A0: C1BF01D8  lfs f13, 0x1d8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(472 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821904A4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821904A8: 409A0020  bne cr6, 0x821904c8
	if !ctx.cr[6].eq {
	pc = 0x821904C8; continue 'dispatch;
	}
	// 821904AC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821904B0: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821904B4: EDAD6028  fsubs f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 821904B8: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 821904BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821904C0: 41990024  bgt cr6, 0x821904e4
	if ctx.cr[6].gt {
	pc = 0x821904E4; continue 'dispatch;
	}
	// 821904C4: 4800001C  b 0x821904e0
	pc = 0x821904E0; continue 'dispatch;
            }
            0x821904C8 => {
    //   block [0x821904C8..0x821904E0)
	// 821904C8: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821904CC: C1BF01CC  lfs f13, 0x1cc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(460 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821904D0: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 821904D4: D01F01FC  stfs f0, 0x1fc(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(508 as u32), tmp.u32 ) };
	// 821904D8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821904DC: 41980008  blt cr6, 0x821904e4
	if ctx.cr[6].lt {
	pc = 0x821904E4; continue 'dispatch;
	}
	pc = 0x821904E0; continue 'dispatch;
            }
            0x821904E0 => {
    //   block [0x821904E0..0x821904E4)
	// 821904E0: D37F01D8  stfs f27, 0x1d8(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(472 as u32), tmp.u32 ) };
	pc = 0x821904E4; continue 'dispatch;
            }
            0x821904E4 => {
    //   block [0x821904E4..0x82190508)
	// 821904E4: 554B01CE  rlwinm r11, r10, 0, 7, 7
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 821904E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821904EC: 409A001C  bne cr6, 0x82190508
	if !ctx.cr[6].eq {
	pc = 0x82190508; continue 'dispatch;
	}
	// 821904F0: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821904F4: C1BF01D0  lfs f13, 0x1d0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(464 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821904F8: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821904FC: C19F01DC  lfs f12, 0x1dc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(476 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82190500: EC0D033C  fnmsubs f0, f13, f12, f0
	ctx.f[0].f64 = -(((ctx.f[13].f64 * ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190504: D01F0200  stfs f0, 0x200(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(512 as u32), tmp.u32 ) };
	pc = 0x82190508; continue 'dispatch;
            }
            0x82190508 => {
    //   block [0x82190508..0x821905A0)
	// 82190508: C01F01F8  lfs f0, 0x1f8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219050C: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82190510: C1BF01EC  lfs f13, 0x1ec(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(492 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190514: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190518: C19F01E0  lfs f12, 0x1e0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(480 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219051C: FC0B682E  fsel f0, f11, f0, f13
	ctx.f[0].f64 = if ctx.f[11].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 82190520: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 82190524: EDAC0028  fsubs f13, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190528: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 8219052C: D01F01F8  stfs f0, 0x1f8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 82190530: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190534: D01B0050  stfs f0, 0x50(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82190538: C01F01FC  lfs f0, 0x1fc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(508 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219053C: D01B0054  stfs f0, 0x54(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82190540: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190544: D01B0070  stfs f0, 0x70(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82190548: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219054C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190550: 4E800421  bctrl
	ctx.lr = 0x82190554;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190554: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82190558: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219055C: 616B8600  ori r11, r11, 0x8600
	ctx.r[11].u64 = ctx.r[11].u64 | 34304;
	// 82190560: 614A8608  ori r10, r10, 0x8608
	ctx.r[10].u64 = ctx.r[10].u64 | 34312;
	// 82190564: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82190568: 7D5D502E  lwzx r10, r29, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219056C: 7D6A5378  or r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 | ctx.r[10].u64;
	// 82190570: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82190574: 616B860C  ori r11, r11, 0x860c
	ctx.r[11].u64 = ctx.r[11].u64 | 34316;
	// 82190578: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219057C: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 82190580: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82190584: 409A001C  bne cr6, 0x821905a0
	if !ctx.cr[6].eq {
	pc = 0x821905A0; continue 'dispatch;
	}
	// 82190588: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219058C: C1BF0014  lfs f13, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190590: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82190594: 7C1D5C2E  lfsx f0, r29, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190598: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 8219059C: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
            }
            0x821905A0 => {
    //   block [0x821905A0..0x82190600)
	// 821905A0: 817F022C  lwz r11, 0x22c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(556 as u32) ) } as u64;
	// 821905A4: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821905A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821905AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821905B0: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821905B4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821905B8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821905BC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821905C0: 41980158  blt cr6, 0x82190718
	if ctx.cr[6].lt {
	pc = 0x82190718; continue 'dispatch;
	}
	// 821905C4: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 821905C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821905CC: 409A014C  bne cr6, 0x82190718
	if !ctx.cr[6].eq {
	pc = 0x82190718; continue 'dispatch;
	}
	// 821905D0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821905D4: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 821905D8: 614AEB1C  ori r10, r10, 0xeb1c
	ctx.r[10].u64 = ctx.r[10].u64 | 60188;
	// 821905DC: 7D6B50AE  lbzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821905E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821905E4: 409A001C  bne cr6, 0x82190600
	if !ctx.cr[6].eq {
	pc = 0x82190600; continue 'dispatch;
	}
	// 821905E8: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821905EC: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 821905F0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821905F4: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821905F8: 483A5A35  bl 0x8253602c
	ctx.lr = 0x821905FC;
	sub_82535FFC(ctx, base);
	// 821905FC: 483A4B04  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x82190600 => {
    //   block [0x82190600..0x82190658)
	// 82190600: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82190604: 815F01C0  lwz r10, 0x1c0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(448 as u32) ) } as u64;
	// 82190608: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219060C: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82190610: 409A007C  bne cr6, 0x8219068c
	if !ctx.cr[6].eq {
	pc = 0x8219068C; continue 'dispatch;
	}
	// 82190614: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82190618: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219061C: 4BFF9545  bl 0x82189b60
	ctx.lr = 0x82190620;
	sub_82189B60(ctx, base);
	// 82190620: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82190624: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82190628: 81230008  lwz r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219062C: C00BD6E8  lfs f0, -0x2918(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190630: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82190634: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82190638: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8219063C: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82190640: 81690028  lwz r11, 0x28(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190644: 816B025C  lwz r11, 0x25c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 82190648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219064C: 409A000C  bne cr6, 0x82190658
	if !ctx.cr[6].eq {
	pc = 0x82190658; continue 'dispatch;
	}
	// 82190650: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82190654: 48000008  b 0x8219065c
	pc = 0x8219065C; continue 'dispatch;
            }
            0x82190658 => {
    //   block [0x82190658..0x8219065C)
	// 82190658: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8219065C; continue 'dispatch;
            }
            0x8219065C => {
    //   block [0x8219065C..0x8219068C)
	// 8219065C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82190660: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82190664: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82190668: D3630014  stfs f27, 0x14(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219066C: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190670: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190674: 91430084  stw r10, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 82190678: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219067C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82190680: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82190684: 483A59A9  bl 0x8253602c
	ctx.lr = 0x82190688;
	sub_82535FFC(ctx, base);
	// 82190688: 483A4A78  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x8219068C => {
    //   block [0x8219068C..0x82190694)
	// 8219068C: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 82190690: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82190694; continue 'dispatch;
            }
            0x82190694 => {
    //   block [0x82190694..0x821906EC)
	// 82190694: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82190698: FC20D890  fmr f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[27].f64;
	// 8219069C: 481E9CC5  bl 0x8237a360
	ctx.lr = 0x821906A0;
	sub_8237A360(ctx, base);
	// 821906A0: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 821906A4: 2F040008  cmpwi cr6, r4, 8
	ctx.cr[6].compare_i32(ctx.r[4].s32, 8, &mut ctx.xer);
	// 821906A8: 4198FFEC  blt cr6, 0x82190694
	if ctx.cr[6].lt {
	pc = 0x82190694; continue 'dispatch;
	}
	// 821906AC: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821906B0: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821906B4: 4BFF94AD  bl 0x82189b60
	ctx.lr = 0x821906B8;
	sub_82189B60(ctx, base);
	// 821906B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821906BC: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821906C0: 93A30068  stw r29, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[29].u32 ) };
	// 821906C4: C1ABBA38  lfs f13, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821906C8: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821906CC: D1A30088  stfs f13, 0x88(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821906D0: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 821906D4: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821906D8: 816B025C  lwz r11, 0x25c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 821906DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821906E0: 409A000C  bne cr6, 0x821906ec
	if !ctx.cr[6].eq {
	pc = 0x821906EC; continue 'dispatch;
	}
	// 821906E4: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 821906E8: 48000008  b 0x821906f0
	pc = 0x821906F0; continue 'dispatch;
            }
            0x821906EC => {
    //   block [0x821906EC..0x821906F0)
	// 821906EC: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821906F0; continue 'dispatch;
            }
            0x821906F0 => {
    //   block [0x821906F0..0x82190718)
	// 821906F0: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 821906F4: EDAD0028  fsubs f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821906F8: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821906FC: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82190700: D3630014  stfs f27, 0x14(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82190704: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82190708: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219070C: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82190710: 483A591D  bl 0x8253602c
	ctx.lr = 0x82190714;
	sub_82535FFC(ctx, base);
	// 82190714: 483A49EC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x82190718 => {
    //   block [0x82190718..0x8219076C)
	// 82190718: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 8219071C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82190720: 409A0084  bne cr6, 0x821907a4
	if !ctx.cr[6].eq {
	pc = 0x821907A4; continue 'dispatch;
	}
	// 82190724: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 82190728: 809F023C  lwz r4, 0x23c(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8219072C: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 82190730: 617DA9C0  ori r29, r11, 0xa9c0
	ctx.r[29].u64 = ctx.r[11].u64 | 43456;
	// 82190734: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190738: 7CA4E82E  lwzx r5, r4, r29
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 8219073C: 4BFF9915  bl 0x8218a050
	ctx.lr = 0x82190740;
	sub_8218A050(ctx, base);
	// 82190740: 817F023C  lwz r11, 0x23c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 82190744: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82190748: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219074C: 419A0020  beq cr6, 0x8219076c
	if ctx.cr[6].eq {
	pc = 0x8219076C; continue 'dispatch;
	}
	// 82190750: 917E02F0  stw r11, 0x2f0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 82190754: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82190758: 915E029C  stw r10, 0x29c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), ctx.r[10].u32 ) };
	// 8219075C: 917E02F4  stw r11, 0x2f4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 82190760: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82190764: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 82190768: 48000020  b 0x82190788
	pc = 0x82190788; continue 'dispatch;
            }
            0x8219076C => {
    //   block [0x8219076C..0x82190788)
	// 8219076C: 917E02F4  stw r11, 0x2f4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(756 as u32), ctx.r[11].u32 ) };
	// 82190770: 7D6BE82E  lwzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82190774: 915E029C  stw r10, 0x29c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(668 as u32), ctx.r[10].u32 ) };
	// 82190778: 917E02F0  stw r11, 0x2f0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(752 as u32), ctx.r[11].u32 ) };
	// 8219077C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82190780: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 82190784: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	pc = 0x82190788; continue 'dispatch;
            }
            0x82190788 => {
    //   block [0x82190788..0x821907A0)
	// 82190788: 813F023C  lwz r9, 0x23c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(572 as u32) ) } as u64;
	// 8219078C: 7F095840  cmplw cr6, r9, r11
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82190790: 409A0010  bne cr6, 0x821907a0
	if !ctx.cr[6].eq {
	pc = 0x821907A0; continue 'dispatch;
	}
	// 82190794: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82190798: 917E0230  stw r11, 0x230(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 8219079C: 48000008  b 0x821907a4
	pc = 0x821907A4; continue 'dispatch;
            }
            0x821907A0 => {
    //   block [0x821907A0..0x821907A4)
	// 821907A0: 915E0230  stw r10, 0x230(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(560 as u32), ctx.r[10].u32 ) };
	pc = 0x821907A4; continue 'dispatch;
            }
            0x821907A4 => {
    //   block [0x821907A4..0x82190998)
	// 821907A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821907A8: C1BF0204  lfs f13, 0x204(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821907AC: C01F0014  lfs f0, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821907B0: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 821907B4: C3ABD6E8  lfs f29, -0x2918(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10520 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821907B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821907BC: EDADE828  fsubs f13, f13, f29
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[29].f64) as f32) as f64);
	// 821907C0: C38BBA38  lfs f28, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821907C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821907C8: 4198022C  blt cr6, 0x821909f4
	if ctx.cr[6].lt {
	pc = 0x821909F4; continue 'dispatch;
	}
	// 821907CC: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 821907D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821907D4: 409A0220  bne cr6, 0x821909f4
	if !ctx.cr[6].eq {
	pc = 0x821909F4; continue 'dispatch;
	}
	// 821907D8: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821907DC: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821907E0: 939F0228  stw r28, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[28].u32 ) };
	// 821907E4: 409A01B4  bne cr6, 0x82190998
	if !ctx.cr[6].eq {
	pc = 0x82190998; continue 'dispatch;
	}
	// 821907E8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821907EC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821907F0: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 821907F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821907F8: 4E800421  bctrl
	ctx.lr = 0x821907FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821907FC: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190800: FFE00890  fmr f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82190804: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82190808: 816B0050  lwz r11, 0x50(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219080C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190810: 4E800421  bctrl
	ctx.lr = 0x82190814;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190814: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190818: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219081C: EFFF0828  fsubs f31, f31, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[31].f64 - ctx.f[1].f64) as f32) as f64);
	// 82190820: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 82190824: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190828: 4E800421  bctrl
	ctx.lr = 0x8219082C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219082C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190830: FFC00890  fmr f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[1].f64;
	// 82190834: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82190838: 816B0054  lwz r11, 0x54(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219083C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190840: 4E800421  bctrl
	ctx.lr = 0x82190844;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190844: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190848: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219084C: EFDE0828  fsubs f30, f30, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = (((ctx.f[30].f64 - ctx.f[1].f64) as f32) as f64);
	// 82190850: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 82190854: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190858: 4E800421  bctrl
	ctx.lr = 0x8219085C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219085C: 817B0000  lwz r11, 0(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190860: FF400890  fmr f26, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[26].f64 = ctx.f[1].f64;
	// 82190864: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 82190868: 816B0058  lwz r11, 0x58(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219086C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190870: 4E800421  bctrl
	ctx.lr = 0x82190874;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190874: C01E0050  lfs f0, 0x50(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190878: C1BB0050  lfs f13, 0x50(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219087C: FCE0065E  fctidz f7, f0
	ctx.f[7].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82190880: FCC06E5E  fctidz f6, f13
	ctx.f[6].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82190884: C19E0054  lfs f12, 0x54(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82190888: C17B0054  lfs f11, 0x54(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(84 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219088C: FCA0665E  fctidz f5, f12
	ctx.f[5].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82190890: C15E0058  lfs f10, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82190894: FC805E5E  fctidz f4, f11
	ctx.f[4].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82190898: C13B0058  lfs f9, 0x58(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(88 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219089C: FC60565E  fctidz f3, f10
	ctx.f[3].s64 = if ctx.f[10].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[10].f64.trunc() as i64 };
	// 821908A0: FC404E5E  fctidz f2, f9
	ctx.f[2].s64 = if ctx.f[9].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[9].f64.trunc() as i64 };
	// 821908A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821908A8: ED1A0828  fsubs f8, f26, f1
	ctx.f[8].f64 = (((ctx.f[26].f64 - ctx.f[1].f64) as f32) as f64);
	// 821908AC: FCE03E9C  fcfid f7, f7
	ctx.f[7].f64 = (ctx.f[7].s64 as f64);
	// 821908B0: FCC0369C  fcfid f6, f6
	ctx.f[6].f64 = (ctx.f[6].s64 as f64);
	// 821908B4: FCA02E9C  fcfid f5, f5
	ctx.f[5].f64 = (ctx.f[5].s64 as f64);
	// 821908B8: FC80269C  fcfid f4, f4
	ctx.f[4].f64 = (ctx.f[4].s64 as f64);
	// 821908BC: FC601E9C  fcfid f3, f3
	ctx.f[3].f64 = (ctx.f[3].s64 as f64);
	// 821908C0: FC40169C  fcfid f2, f2
	ctx.f[2].f64 = (ctx.f[2].s64 as f64);
	// 821908C4: FCE03818  frsp f7, f7
	ctx.f[7].f64 = (ctx.f[7].f64 as f32) as f64;
	// 821908C8: FCC03018  frsp f6, f6
	ctx.f[6].f64 = (ctx.f[6].f64 as f32) as f64;
	// 821908CC: FCA02818  frsp f5, f5
	ctx.f[5].f64 = (ctx.f[5].f64 as f32) as f64;
	// 821908D0: FC802018  frsp f4, f4
	ctx.f[4].f64 = (ctx.f[4].f64 as f32) as f64;
	// 821908D4: FC601818  frsp f3, f3
	ctx.f[3].f64 = (ctx.f[3].f64 as f32) as f64;
	// 821908D8: FC401018  frsp f2, f2
	ctx.f[2].f64 = (ctx.f[2].f64 as f32) as f64;
	// 821908DC: EC003828  fsubs f0, f0, f7
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[7].f64) as f32) as f64);
	// 821908E0: EDAD3028  fsubs f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[6].f64) as f32) as f64);
	// 821908E4: ED8C2828  fsubs f12, f12, f5
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[5].f64) as f32) as f64);
	// 821908E8: ED6B2028  fsubs f11, f11, f4
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[4].f64) as f32) as f64);
	// 821908EC: ED4A1828  fsubs f10, f10, f3
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[3].f64) as f32) as f64);
	// 821908F0: ED291028  fsubs f9, f9, f2
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[2].f64) as f32) as f64);
	// 821908F4: EDA06828  fsubs f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821908F8: EC1E07B2  fmuls f0, f30, f30
	ctx.f[0].f64 = (((ctx.f[30].f64 * ctx.f[30].f64) as f32) as f64);
	// 821908FC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82190900: ED6A4828  fsubs f11, f10, f9
	ctx.f[11].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82190904: C15E0070  lfs f10, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82190908: EC08023A  fmadds f0, f8, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[0].f64) as f32) as f64);
	// 8219090C: EC1F07FA  fmadds f0, f31, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82190910: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82190914: EC0A0028  fsubs f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190918: FD400210  fabs f10, f0
	ctx.f[10].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 8219091C: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190920: FF0A0000  fcmpu cr6, f10, f0
	ctx.cr[6].compare_f64(ctx.f[10].f64, ctx.f[0].f64);
	// 82190924: 40980074  bge cr6, 0x82190998
	if !ctx.cr[6].lt {
	pc = 0x82190998; continue 'dispatch;
	}
	// 82190928: FC006E5E  fctidz f0, f13
	ctx.f[0].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 8219092C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190930: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82190934: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82190938: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219093C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82190940: C00B2788  lfs f0, 0x2788(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190944: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82190948: 40980050  bge cr6, 0x82190998
	if !ctx.cr[6].lt {
	pc = 0x82190998; continue 'dispatch;
	}
	// 8219094C: FC00665E  fctidz f0, f12
	ctx.f[0].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82190950: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190954: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82190958: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219095C: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190960: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82190964: C00B22AC  lfs f0, 0x22ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190968: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219096C: 4098002C  bge cr6, 0x82190998
	if !ctx.cr[6].lt {
	pc = 0x82190998; continue 'dispatch;
	}
	// 82190970: FC005E5E  fctidz f0, f11
	ctx.f[0].s64 = if ctx.f[11].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[11].f64.trunc() as i64 };
	// 82190974: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190978: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219097C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82190980: EC0B0028  fsubs f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 - ctx.f[0].f64) as f32) as f64);
	// 82190984: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82190988: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219098C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82190990: 40980008  bge cr6, 0x82190998
	if !ctx.cr[6].lt {
	pc = 0x82190998; continue 'dispatch;
	}
	// 82190994: 93BF01C4  stw r29, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[29].u32 ) };
            }
            0x82190998 => {
    //   block [0x82190998..0x821909DC)
	// 82190998: 817F01C4  lwz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 8219099C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821909A0: 409A0054  bne cr6, 0x821909f4
	if !ctx.cr[6].eq {
	pc = 0x821909F4; continue 'dispatch;
	}
	// 821909A4: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821909A8: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821909AC: 4BFF91B5  bl 0x82189b60
	ctx.lr = 0x821909B0;
	sub_82189B60(ctx, base);
	// 821909B0: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 821909B4: 81430008  lwz r10, 8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 821909B8: D3A30088  stfs f29, 0x88(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821909BC: 93A30078  stw r29, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[29].u32 ) };
	// 821909C0: 91630068  stw r11, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 821909C4: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 821909C8: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 821909CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821909D0: 409A000C  bne cr6, 0x821909dc
	if !ctx.cr[6].eq {
	pc = 0x821909DC; continue 'dispatch;
	}
	// 821909D4: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 821909D8: 48000008  b 0x821909e0
	pc = 0x821909E0; continue 'dispatch;
            }
            0x821909DC => {
    //   block [0x821909DC..0x821909E0)
	// 821909DC: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821909E0; continue 'dispatch;
            }
            0x821909E0 => {
    //   block [0x821909E0..0x821909F4)
	// 821909E0: EDBC0028  fsubs f13, f28, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 821909E4: D0030074  stfs f0, 0x74(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821909E8: D1A30070  stfs f13, 0x70(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821909EC: 93830084  stw r28, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[28].u32 ) };
	// 821909F0: D3630014  stfs f27, 0x14(r3)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x821909F4; continue 'dispatch;
            }
            0x821909F4 => {
    //   block [0x821909F4..0x82190A24)
	// 821909F4: C01F0204  lfs f0, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821909F8: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 821909FC: C1BF0014  lfs f13, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190A00: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82190A04: 40990078  ble cr6, 0x82190a7c
	if !ctx.cr[6].gt {
	pc = 0x82190A7C; continue 'dispatch;
	}
	// 82190A08: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82190A0C: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82190A10: 419A006C  beq cr6, 0x82190a7c
	if ctx.cr[6].eq {
	pc = 0x82190A7C; continue 'dispatch;
	}
	// 82190A14: 817F01C4  lwz r11, 0x1c4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(452 as u32) ) } as u64;
	// 82190A18: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82190A1C: 409A0020  bne cr6, 0x82190a3c
	if !ctx.cr[6].eq {
	pc = 0x82190A3C; continue 'dispatch;
	}
	// 82190A20: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	pc = 0x82190A24; continue 'dispatch;
            }
            0x82190A24 => {
    //   block [0x82190A24..0x82190A3C)
	// 82190A24: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 82190A28: FC20D890  fmr f1, f27
	ctx.f[1].f64 = ctx.f[27].f64;
	// 82190A2C: 481E9935  bl 0x8237a360
	ctx.lr = 0x82190A30;
	sub_8237A360(ctx, base);
	// 82190A30: 38840001  addi r4, r4, 1
	ctx.r[4].s64 = ctx.r[4].s64 + 1;
	// 82190A34: 2F040008  cmpwi cr6, r4, 8
	ctx.cr[6].compare_i32(ctx.r[4].s32, 8, &mut ctx.xer);
	// 82190A38: 4198FFEC  blt cr6, 0x82190a24
	if ctx.cr[6].lt {
	pc = 0x82190A24; continue 'dispatch;
	}
	pc = 0x82190A3C; continue 'dispatch;
            }
            0x82190A3C => {
    //   block [0x82190A3C..0x82190A5C)
	// 82190A3C: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 82190A40: 917F0228  stw r11, 0x228(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82190A44: 93BE0230  stw r29, 0x230(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(560 as u32), ctx.r[29].u32 ) };
	// 82190A48: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190A4C: 816B0250  lwz r11, 0x250(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(592 as u32) ) } as u64;
	// 82190A50: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190A54: 419A0008  beq cr6, 0x82190a5c
	if ctx.cr[6].eq {
	pc = 0x82190A5C; continue 'dispatch;
	}
	// 82190A58: D38B009C  stfs f28, 0x9c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82190A5C; continue 'dispatch;
            }
            0x82190A5C => {
    //   block [0x82190A5C..0x82190A7C)
	// 82190A5C: 817A0028  lwz r11, 0x28(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190A60: 816B025C  lwz r11, 0x25c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 82190A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82190A68: 419A0014  beq cr6, 0x82190a7c
	if ctx.cr[6].eq {
	pc = 0x82190A7C; continue 'dispatch;
	}
	// 82190A6C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82190A70: C80A2008  lfd f0, 0x2008(r10)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 82190A74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82190A78: D00B009C  stfs f0, 0x9c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(156 as u32), tmp.u32 ) };
	pc = 0x82190A7C; continue 'dispatch;
            }
            0x82190A7C => {
    //   block [0x82190A7C..0x82190AB0)
	// 82190A7C: 817F0228  lwz r11, 0x228(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) } as u64;
	// 82190A80: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82190A84: 409A002C  bne cr6, 0x82190ab0
	if !ctx.cr[6].eq {
	pc = 0x82190AB0; continue 'dispatch;
	}
	// 82190A88: 3D600000  lis r11, 0
	ctx.r[11].s64 = 0;
	// 82190A8C: 807F000C  lwz r3, 0xc(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 82190A90: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82190A94: 616BFFFF  ori r11, r11, 0xffff
	ctx.r[11].u64 = ctx.r[11].u64 | 65535;
	// 82190A98: 917F0218  stw r11, 0x218(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(536 as u32), ctx.r[11].u32 ) };
	// 82190A9C: 4BFF90C5  bl 0x82189b60
	ctx.lr = 0x82190AA0;
	sub_82189B60(ctx, base);
	// 82190AA0: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82190AA4: 93A30094  stw r29, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 82190AA8: 7FABEB78  mr r11, r29
	ctx.r[11].u64 = ctx.r[29].u64;
	// 82190AAC: 916AB9BC  stw r11, -0x4644(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17988 as u32), ctx.r[11].u32 ) };
	pc = 0x82190AB0; continue 'dispatch;
            }
            0x82190AB0 => {
    //   block [0x82190AB0..0x82190AC0)
	// 82190AB0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82190AB4: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 82190AB8: 483A5575  bl 0x8253602c
	ctx.lr = 0x82190ABC;
	sub_82535FFC(ctx, base);
	// 82190ABC: 483A4644  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190AC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82190AC0 size=340
    let mut pc: u32 = 0x82190AC0;
    'dispatch: loop {
        match pc {
            0x82190AC0 => {
    //   block [0x82190AC0..0x82190BB8)
	// 82190AC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82190AC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82190AC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82190ACC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82190AD0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82190AD4: 483A54F9  bl 0x82535fcc
	ctx.lr = 0x82190AD8;
	sub_82535FB0(ctx, base);
	// 82190AD8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82190ADC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190AE0: 83C30404  lwz r30, 0x404(r3)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82190AE4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82190AE8: FF801090  fmr f28, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[2].f64;
	// 82190AEC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82190AF0: FF601890  fmr f27, f3
	ctx.f[27].f64 = ctx.f[3].f64;
	// 82190AF4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190AF8: FFC02090  fmr f30, f4
	ctx.f[30].f64 = ctx.f[4].f64;
	// 82190AFC: FFA03090  fmr f29, f6
	ctx.f[29].f64 = ctx.f[6].f64;
	// 82190B00: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82190B04: FF404090  fmr f26, f8
	ctx.f[26].f64 = ctx.f[8].f64;
	// 82190B08: FF204890  fmr f25, f9
	ctx.f[25].f64 = ctx.f[9].f64;
	// 82190B0C: FF005090  fmr f24, f10
	ctx.f[24].f64 = ctx.f[10].f64;
	// 82190B10: FEE05890  fmr f23, f11
	ctx.f[23].f64 = ctx.f[11].f64;
	// 82190B14: FEC06090  fmr f22, f12
	ctx.f[22].f64 = ctx.f[12].f64;
	// 82190B18: FEA06890  fmr f21, f13
	ctx.f[21].f64 = ctx.f[13].f64;
	// 82190B1C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190B20: 4BFF9251  bl 0x82189d70
	ctx.lr = 0x82190B24;
	sub_82189D70(ctx, base);
	// 82190B24: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82190B28: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190B2C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82190B30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190B34: 4E800421  bctrl
	ctx.lr = 0x82190B38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190B38: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82190B3C: 81010154  lwz r8, 0x154(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(340 as u32) ) } as u64;
	// 82190B40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82190B44: 392000F0  li r9, 0xf0
	ctx.r[9].s64 = 240;
	// 82190B48: D3DF01D0  stfs f30, 0x1d0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82190B4C: D3DF01D4  stfs f30, 0x1d4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 82190B50: D3BF01E0  stfs f29, 0x1e0(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 82190B54: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190B58: 8141015C  lwz r10, 0x15c(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82190B5C: D3BF01E4  stfs f29, 0x1e4(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 82190B60: 917F0230  stw r11, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	// 82190B64: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82190B68: 913F0234  stw r9, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[9].u32 ) };
	// 82190B6C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82190B70: 917F0148  stw r11, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[11].u32 ) };
	// 82190B74: D39F0050  stfs f28, 0x50(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82190B78: 911F01C8  stw r8, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[8].u32 ) };
	// 82190B7C: D37F0054  stfs f27, 0x54(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82190B80: 2B0A0020  cmplwi cr6, r10, 0x20
	ctx.cr[6].compare_u32(ctx.r[10].u32, 32 as u32, &mut ctx.xer);
	// 82190B84: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82190B88: D35F0070  stfs f26, 0x70(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82190B8C: D33F0180  stfs f25, 0x180(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82190B90: D31F0190  stfs f24, 0x190(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82190B94: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82190B98: D2FF01B0  stfs f23, 0x1b0(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82190B9C: D2DF0184  stfs f22, 0x184(r31)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82190BA0: D2BF0194  stfs f21, 0x194(r31)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82190BA4: D3FF01A4  stfs f31, 0x1a4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82190BA8: D3FF01B4  stfs f31, 0x1b4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82190BAC: 4198000C  blt cr6, 0x82190bb8
	if ctx.cr[6].lt {
	pc = 0x82190BB8; continue 'dispatch;
	}
	// 82190BB0: 3920001F  li r9, 0x1f
	ctx.r[9].s64 = 31;
	// 82190BB4: 913F01C4  stw r9, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[9].u32 ) };
            }
            0x82190BB8 => {
    //   block [0x82190BB8..0x82190C14)
	// 82190BB8: C0010164  lfs f0, 0x164(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190BBC: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82190BC0: C1A1016C  lfs f13, 0x16c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(364 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190BC4: 915F01C4  stw r10, 0x1c4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(452 as u32), ctx.r[10].u32 ) };
	// 82190BC8: C1810174  lfs f12, 0x174(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(372 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82190BCC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190BD0: D01F00F0  stfs f0, 0xf0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 82190BD4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82190BD8: D1BF00F4  stfs f13, 0xf4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 82190BDC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190BE0: D19F00F8  stfs f12, 0xf8(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 82190BE4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190BE8: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82190BEC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190BF0: 4E800421  bctrl
	ctx.lr = 0x82190BF4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190BF4: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 82190BF8: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82190BFC: 483A541D  bl 0x82536018
	ctx.lr = 0x82190C00;
	sub_82535FFC(ctx, base);
	// 82190C00: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82190C04: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82190C08: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82190C0C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82190C10: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190C18(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82190C18 size=316
    let mut pc: u32 = 0x82190C18;
    'dispatch: loop {
        match pc {
            0x82190C18 => {
    //   block [0x82190C18..0x82190D24)
	// 82190C18: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82190C1C: 483A44A1  bl 0x825350bc
	ctx.lr = 0x82190C20;
	sub_82535080(ctx, base);
	// 82190C20: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82190C24: 483A53A5  bl 0x82535fc8
	ctx.lr = 0x82190C28;
	sub_82535FB0(ctx, base);
	// 82190C28: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82190C2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190C30: 83A30404  lwz r29, 0x404(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82190C34: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82190C38: FFC01090  fmr f30, f2
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].f64 = ctx.f[2].f64;
	// 82190C3C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82190C40: FFA01890  fmr f29, f3
	ctx.f[29].f64 = ctx.f[3].f64;
	// 82190C44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82190C48: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82190C4C: FF602890  fmr f27, f5
	ctx.f[27].f64 = ctx.f[5].f64;
	// 82190C50: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82190C54: FF403090  fmr f26, f6
	ctx.f[26].f64 = ctx.f[6].f64;
	// 82190C58: FF203890  fmr f25, f7
	ctx.f[25].f64 = ctx.f[7].f64;
	// 82190C5C: FF004090  fmr f24, f8
	ctx.f[24].f64 = ctx.f[8].f64;
	// 82190C60: FEE04890  fmr f23, f9
	ctx.f[23].f64 = ctx.f[9].f64;
	// 82190C64: FEC05890  fmr f22, f11
	ctx.f[22].f64 = ctx.f[11].f64;
	// 82190C68: FEA06090  fmr f21, f12
	ctx.f[21].f64 = ctx.f[12].f64;
	// 82190C6C: FE806890  fmr f20, f13
	ctx.f[20].f64 = ctx.f[13].f64;
	// 82190C70: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190C74: 4BFF90FD  bl 0x82189d70
	ctx.lr = 0x82190C78;
	sub_82189D70(ctx, base);
	// 82190C78: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82190C7C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190C80: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82190C84: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190C88: 4E800421  bctrl
	ctx.lr = 0x82190C8C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190C8C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82190C90: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190C94: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 82190C98: D3DF0050  stfs f30, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82190C9C: FC60A090  fmr f3, f20
	ctx.f[3].f64 = ctx.f[20].f64;
	// 82190CA0: D3BF0054  stfs f29, 0x54(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82190CA4: FC40A890  fmr f2, f21
	ctx.f[2].f64 = ctx.f[21].f64;
	// 82190CA8: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82190CAC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190CB0: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190CB4: 396000F0  li r11, 0xf0
	ctx.r[11].s64 = 240;
	// 82190CB8: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82190CBC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82190CC0: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82190CC4: 93DF0230  stw r30, 0x230(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(560 as u32), ctx.r[30].u32 ) };
	// 82190CC8: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82190CCC: 93DF0148  stw r30, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[30].u32 ) };
	// 82190CD0: D39F0070  stfs f28, 0x70(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82190CD4: FC20B090  fmr f1, f22
	ctx.f[1].f64 = ctx.f[22].f64;
	// 82190CD8: D37F0180  stfs f27, 0x180(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82190CDC: 917F0234  stw r11, 0x234(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(564 as u32), ctx.r[11].u32 ) };
	// 82190CE0: D35F0190  stfs f26, 0x190(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82190CE4: D3FF01A0  stfs f31, 0x1a0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82190CE8: D33F01B0  stfs f25, 0x1b0(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(432 as u32), tmp.u32 ) };
	// 82190CEC: D31F0184  stfs f24, 0x184(r31)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82190CF0: D2FF0194  stfs f23, 0x194(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 82190CF4: D3FF01A4  stfs f31, 0x1a4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 82190CF8: D3FF01B4  stfs f31, 0x1b4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(436 as u32), tmp.u32 ) };
	// 82190CFC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82190D00: 4E800421  bctrl
	ctx.lr = 0x82190D04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190D04: 8161015C  lwz r11, 0x15c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(348 as u32) ) } as u64;
	// 82190D08: 81410164  lwz r10, 0x164(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(356 as u32) ) } as u64;
	// 82190D0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82190D10: 917F01C8  stw r11, 0x1c8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(456 as u32), ctx.r[11].u32 ) };
	// 82190D14: 419A0010  beq cr6, 0x82190d24
	if ctx.cr[6].eq {
	pc = 0x82190D24; continue 'dispatch;
	}
	// 82190D18: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82190D1C: 917F0238  stw r11, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[11].u32 ) };
	// 82190D20: 48000008  b 0x82190d28
	pc = 0x82190D28; continue 'dispatch;
            }
            0x82190D24 => {
    //   block [0x82190D24..0x82190D28)
	// 82190D24: 93DF0238  stw r30, 0x238(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(568 as u32), ctx.r[30].u32 ) };
	pc = 0x82190D28; continue 'dispatch;
            }
            0x82190D28 => {
    //   block [0x82190D28..0x82190D54)
	// 82190D28: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190D2C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190D30: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82190D34: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82190D38: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82190D3C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190D40: 4E800421  bctrl
	ctx.lr = 0x82190D44;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190D44: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 82190D48: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82190D4C: 483A52C9  bl 0x82536014
	ctx.lr = 0x82190D50;
	sub_82535FFC(ctx, base);
	// 82190D50: 483A43BC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190D58(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82190D58 size=204
    let mut pc: u32 = 0x82190D58;
    'dispatch: loop {
        match pc {
            0x82190D58 => {
    //   block [0x82190D58..0x82190E24)
	// 82190D58: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82190D5C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82190D60: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82190D64: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82190D68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82190D6C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82190D70: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82190D74: 61299428  ori r9, r9, 0x9428
	ctx.r[9].u64 = ctx.r[9].u64 | 37928;
	// 82190D78: 916302CC  stw r11, 0x2cc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(716 as u32), ctx.r[11].u32 ) };
	// 82190D7C: 916A49EC  stw r11, 0x49ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(18924 as u32), ctx.r[11].u32 ) };
	// 82190D80: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82190D84: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82190D88: 3BEB76FC  addi r31, r11, 0x76fc
	ctx.r[31].s64 = ctx.r[11].s64 + 30460;
	// 82190D8C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82190D90: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82190D94: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190D98: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82190D9C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82190DA0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82190DA4: 61299434  ori r9, r9, 0x9434
	ctx.r[9].u64 = ctx.r[9].u64 | 37940;
	// 82190DA8: C00AD6D0  lfs f0, -0x2930(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190DAC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82190DB0: 614A942C  ori r10, r10, 0x942c
	ctx.r[10].u64 = ctx.r[10].u64 | 37932;
	// 82190DB4: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82190DB8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82190DBC: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82190DC0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82190DC4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82190DC8: 61298670  ori r9, r9, 0x8670
	ctx.r[9].u64 = ctx.r[9].u64 | 34416;
	// 82190DCC: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190DD0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82190DD4: 614A94B4  ori r10, r10, 0x94b4
	ctx.r[10].u64 = ctx.r[10].u64 | 38068;
	// 82190DD8: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82190DDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82190DE0: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 82190DE4: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82190DE8: C1AAD47C  lfs f13, -0x2b84(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82190DEC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82190DF0: 614A94B8  ori r10, r10, 0x94b8
	ctx.r[10].u64 = ctx.r[10].u64 | 38072;
	// 82190DF4: 7DAB552E  stfsx f13, r11, r10
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82190DF8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82190DFC: 614A94BC  ori r10, r10, 0x94bc
	ctx.r[10].u64 = ctx.r[10].u64 | 38076;
	// 82190E00: 7C0B552E  stfsx f0, r11, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), tmp.u32) };
	// 82190E04: 4BFA827D  bl 0x82139080
	ctx.lr = 0x82190E08;
	sub_82139080(ctx, base);
	// 82190E08: 807F0004  lwz r3, 4(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) } as u64;
	// 82190E0C: 4BFA8275  bl 0x82139080
	ctx.lr = 0x82190E10;
	sub_82139080(ctx, base);
	// 82190E10: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82190E14: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82190E18: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82190E1C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82190E20: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190E28(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82190E28 size=84
    let mut pc: u32 = 0x82190E28;
    'dispatch: loop {
        match pc {
            0x82190E28 => {
    //   block [0x82190E28..0x82190E7C)
	// 82190E28: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82190E2C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82190E30: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82190E34: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82190E38: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82190E3C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82190E40: 83EBB9AC  lwz r31, -0x4654(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18004 as u32) ) } as u64;
	// 82190E44: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190E48: 4BFFFF11  bl 0x82190d58
	ctx.lr = 0x82190E4C;
	sub_82190D58(ctx, base);
	// 82190E4C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190E50: 481E69A9  bl 0x823777f8
	ctx.lr = 0x82190E54;
	sub_823777F8(ctx, base);
	// 82190E54: 387F0360  addi r3, r31, 0x360
	ctx.r[3].s64 = ctx.r[31].s64 + 864;
	// 82190E58: 4BFF92D1  bl 0x8218a128
	ctx.lr = 0x82190E5C;
	sub_8218A128(ctx, base);
	// 82190E5C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82190E60: 387F02A0  addi r3, r31, 0x2a0
	ctx.r[3].s64 = ctx.r[31].s64 + 672;
	// 82190E64: 481E9395  bl 0x8237a1f8
	ctx.lr = 0x82190E68;
	sub_8237A1F8(ctx, base);
	// 82190E68: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82190E6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82190E70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82190E74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82190E78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82190E80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82190E80 size=1936
    let mut pc: u32 = 0x82190E80;
    'dispatch: loop {
        match pc {
            0x82190E80 => {
    //   block [0x82190E80..0x82190F64)
	// 82190E80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82190E84: 483A4231  bl 0x825350b4
	ctx.lr = 0x82190E88;
	sub_82535080(ctx, base);
	// 82190E88: DBC1FFC0  stfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[30].u64 ) };
	// 82190E8C: DBE1FFC8  stfd f31, -0x38(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 82190E90: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82190E94: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 82190E98: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82190E9C: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82190EA0: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 82190EA4: 398C0EB8  addi r12, r12, 0xeb8
	ctx.r[12].s64 = ctx.r[12].s64 + 3768;
	// 82190EA8: 54C0103A  slwi r0, r6, 2
	ctx.r[0].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82190EAC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82190EB0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82190EB4: 4E800420  bctr
	crate::rt::call_indirect(ctx.ctr.u32);
	return;
	// 82190EB8: 82190ECC  lwz r16, 0xecc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(3788 as u32) ) } as u64;
	// 82190EBC: 82190FE0  lwz r16, 0xfe0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4064 as u32) ) } as u64;
	// 82190EC0: 8219117C  lwz r16, 0x117c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4476 as u32) ) } as u64;
	// 82190EC4: 8219117C  lwz r16, 0x117c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4476 as u32) ) } as u64;
	// 82190EC8: 8219129C  lwz r16, 0x129c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(4764 as u32) ) } as u64;
	// 82190ECC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190ED0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190ED4: 83DF0008  lwz r30, 8(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 82190ED8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190EDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190EE0: 4E800421  bctrl
	ctx.lr = 0x82190EE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190EE4: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82190EE8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82190EEC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190EF0: 483A42E1  bl 0x825351d0
	ctx.lr = 0x82190EF4;
	sub_825351D0(ctx, base);
	// 82190EF4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82190EF8: 419A006C  beq cr6, 0x82190f64
	if ctx.cr[6].eq {
	pc = 0x82190F64; continue 'dispatch;
	}
	// 82190EFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82190F00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190F04: 396BFA10  addi r11, r11, -0x5f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1520;
	// 82190F08: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82190F0C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82190F10: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82190F14: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190F18: 4E800421  bctrl
	ctx.lr = 0x82190F1C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190F1C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190F20: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190F24: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82190F28: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190F2C: 4E800421  bctrl
	ctx.lr = 0x82190F30;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190F30: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190F34: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82190F38: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82190F3C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82190F40: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190F44: 4E800421  bctrl
	ctx.lr = 0x82190F48;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190F48: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82190F4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 82190F50: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190F54: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82190F58: 915E0140  stw r10, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 82190F5C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190F60: 93CB0250  stw r30, 0x250(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(592 as u32), ctx.r[30].u32 ) };
            }
            0x82190F64 => {
    //   block [0x82190F64..0x821910D8)
	// 82190F64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190F68: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82190F6C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 82190F70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190F74: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82190F78: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190F7C: 4BFD2A4D  bl 0x821639c8
	ctx.lr = 0x82190F80;
	sub_821639C8(ctx, base);
	// 82190F80: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82190F84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190F88: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82190F8C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82190F90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82190F94: 83EA0250  lwz r31, 0x250(r10)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(592 as u32) ) } as u64;
	// 82190F98: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190F9C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190FA0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82190FA4: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82190FA8: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82190FAC: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82190FB0: 816B0040  lwz r11, 0x40(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 82190FB4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82190FB8: 4E800421  bctrl
	ctx.lr = 0x82190FBC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82190FBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82190FC0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82190FC4: C00B2094  lfs f0, 0x2094(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82190FC8: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82190FCC: 915B0270  stw r10, 0x270(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(624 as u32), ctx.r[10].u32 ) };
	// 82190FD0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82190FD4: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82190FD8: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82190FDC: 483A4128  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 82190FE0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190FE4: 4BFF85B5  bl 0x82189598
	ctx.lr = 0x82190FE8;
	sub_82189598(ctx, base);
	// 82190FE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82190FEC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82190FF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82190FF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82190FF8: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82190FFC: 48002775  bl 0x82193770
	ctx.lr = 0x82191000;
	sub_82193770(ctx, base);
	// 82191000: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191004: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82191008: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8219100C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191010: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82191014: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82191018: 4BFF8CA1  bl 0x82189cb8
	ctx.lr = 0x8219101C;
	sub_82189CB8(ctx, base);
	// 8219101C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82191020: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82191024: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82191028: 3B800005  li r28, 5
	ctx.r[28].s64 = 5;
	// 8219102C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191030: 814A76FC  lwz r10, 0x76fc(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(30460 as u32) ) } as u64;
	// 82191034: C0092068  lfs f0, 0x2068(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191038: D00B0070  stfs f0, 0x70(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219103C: 938B01CC  stw r28, 0x1cc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(460 as u32), ctx.r[28].u32 ) };
	// 82191040: 914B01D0  stw r10, 0x1d0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(464 as u32), ctx.r[10].u32 ) };
	// 82191044: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191048: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219104C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191050: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191054: 4E800421  bctrl
	ctx.lr = 0x82191058;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191058: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219105C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82191060: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191064: 483A416D  bl 0x825351d0
	ctx.lr = 0x82191068;
	sub_825351D0(ctx, base);
	// 82191068: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219106C: 419A006C  beq cr6, 0x821910d8
	if ctx.cr[6].eq {
	pc = 0x821910D8; continue 'dispatch;
	}
	// 82191070: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82191074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191078: 396BFA10  addi r11, r11, -0x5f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1520;
	// 8219107C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82191080: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191084: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82191088: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219108C: 4E800421  bctrl
	ctx.lr = 0x82191090;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191090: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191094: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191098: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219109C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821910A0: 4E800421  bctrl
	ctx.lr = 0x821910A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821910A4: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821910A8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821910AC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821910B0: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821910B4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821910B8: 4E800421  bctrl
	ctx.lr = 0x821910BC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821910BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821910C0: 939E0140  stw r28, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[28].u32 ) };
	// 821910C4: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 821910C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821910CC: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821910D0: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821910D4: 93CB0264  stw r30, 0x264(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
            }
            0x821910D8 => {
    //   block [0x821910D8..0x82191150)
	// 821910D8: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 821910DC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821910E0: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 821910E4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821910E8: 4BFD28E1  bl 0x821639c8
	ctx.lr = 0x821910EC;
	sub_821639C8(ctx, base);
	// 821910EC: 83BB0408  lwz r29, 0x408(r27)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821910F0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821910F4: 3BCB1030  addi r30, r11, 0x1030
	ctx.r[30].s64 = ctx.r[11].s64 + 4144;
	// 821910F8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821910FC: 419A0054  beq cr6, 0x82191150
	if ctx.cr[6].eq {
	pc = 0x82191150; continue 'dispatch;
	}
	// 82191100: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82191104: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82191108: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219110C: 483A40C5  bl 0x825351d0
	ctx.lr = 0x82191110;
	sub_825351D0(ctx, base);
	// 82191110: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82191114: 39400007  li r10, 7
	ctx.r[10].s64 = 7;
	// 82191118: 396B0800  addi r11, r11, 0x800
	ctx.r[11].s64 = ctx.r[11].s64 + 2048;
	// 8219111C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191120: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82191124: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82191128: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219112C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191130: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82191134: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82191138: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219113C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191140: 4E800421  bctrl
	ctx.lr = 0x82191144;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191144: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82191148: 917E001C  stw r11, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8219114C: 93DD0024  stw r30, 0x24(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(36 as u32), ctx.r[30].u32 ) };
            }
            0x82191150 => {
    //   block [0x82191150..0x8219125C)
	// 82191150: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191154: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82191158: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219115C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191160: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82191164: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191168: 4E800421  bctrl
	ctx.lr = 0x8219116C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219116C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82191170: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82191174: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82191178: 483A3F8C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 8219117C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191180: 4BFF8419  bl 0x82189598
	ctx.lr = 0x82191184;
	sub_82189598(ctx, base);
	// 82191184: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191188: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 8219118C: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 82191190: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191194: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82191198: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219119C: 4BFF8B1D  bl 0x82189cb8
	ctx.lr = 0x821911A0;
	sub_82189CB8(ctx, base);
	// 821911A0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821911A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821911A8: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 821911AC: 3B800005  li r28, 5
	ctx.r[28].s64 = 5;
	// 821911B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821911B4: 816B76FC  lwz r11, 0x76fc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(30460 as u32) ) } as u64;
	// 821911B8: C00A2068  lfs f0, 0x2068(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821911BC: D01B0070  stfs f0, 0x70(r27)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821911C0: 939B01CC  stw r28, 0x1cc(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(460 as u32), ctx.r[28].u32 ) };
	// 821911C4: 917B01D0  stw r11, 0x1d0(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(464 as u32), ctx.r[11].u32 ) };
	// 821911C8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821911CC: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821911D0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821911D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821911D8: 4E800421  bctrl
	ctx.lr = 0x821911DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821911DC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821911E0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821911E4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821911E8: 483A3FE9  bl 0x825351d0
	ctx.lr = 0x821911EC;
	sub_825351D0(ctx, base);
	// 821911EC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821911F0: 419A006C  beq cr6, 0x8219125c
	if ctx.cr[6].eq {
	pc = 0x8219125C; continue 'dispatch;
	}
	// 821911F4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821911F8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821911FC: 396BFA10  addi r11, r11, -0x5f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1520;
	// 82191200: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82191204: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191208: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219120C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191210: 4E800421  bctrl
	ctx.lr = 0x82191214;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191214: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191218: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219121C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82191220: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191224: 4E800421  bctrl
	ctx.lr = 0x82191228;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191228: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219122C: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82191230: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191234: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82191238: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219123C: 4E800421  bctrl
	ctx.lr = 0x82191240;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191240: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191244: 939E0140  stw r28, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[28].u32 ) };
	// 82191248: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8219124C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82191250: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82191254: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191258: 93CB0264  stw r30, 0x264(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
            }
            0x8219125C => {
    //   block [0x8219125C..0x8219135C)
	// 8219125C: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82191260: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82191264: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82191268: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219126C: 4BFD275D  bl 0x821639c8
	ctx.lr = 0x82191270;
	sub_821639C8(ctx, base);
	// 82191270: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191274: 809B0140  lwz r4, 0x140(r27)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(320 as u32) ) } as u64;
	// 82191278: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219127C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191280: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82191284: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191288: 4E800421  bctrl
	ctx.lr = 0x8219128C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219128C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82191290: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82191294: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 82191298: 483A3E6C  b 0x82535104
	sub_825350D0(ctx, base);
	return;
	// 8219129C: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821912A0: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821912A4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821912A8: 938B0250  stw r28, 0x250(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(592 as u32), ctx.r[28].u32 ) };
	// 821912AC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821912B0: 938B0254  stw r28, 0x254(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(596 as u32), ctx.r[28].u32 ) };
	// 821912B4: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821912B8: 938B0260  stw r28, 0x260(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(608 as u32), ctx.r[28].u32 ) };
	// 821912BC: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821912C0: 938B026C  stw r28, 0x26c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(620 as u32), ctx.r[28].u32 ) };
	// 821912C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821912C8: 83DF001C  lwz r30, 0x1c(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821912CC: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821912D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821912D4: 4E800421  bctrl
	ctx.lr = 0x821912D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821912D8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 821912DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821912E0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821912E4: 483A3EED  bl 0x825351d0
	ctx.lr = 0x821912E8;
	sub_825351D0(ctx, base);
	// 821912E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821912EC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821912F0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821912F4: 3B6BFA10  addi r27, r11, -0x5f0
	ctx.r[27].s64 = ctx.r[11].s64 + -1520;
	// 821912F8: CBCA2008  lfd f30, 0x2008(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 821912FC: 419A0060  beq cr6, 0x8219135c
	if ctx.cr[6].eq {
	pc = 0x8219135C; continue 'dispatch;
	}
	// 82191300: 576B003E  slwi r11, r27, 0
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191304: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82191308: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219130C: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82191310: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191314: 4E800421  bctrl
	ctx.lr = 0x82191318;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191318: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219131C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191320: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82191324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191328: 4E800421  bctrl
	ctx.lr = 0x8219132C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219132C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191330: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82191334: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191338: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219133C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191340: 4E800421  bctrl
	ctx.lr = 0x82191344;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191344: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82191348: FC00F018  frsp f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[30].f64 as f32) as f64;
	// 8219134C: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82191350: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82191354: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191358: 93CB0264  stw r30, 0x264(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(612 as u32), ctx.r[30].u32 ) };
            }
            0x8219135C => {
    //   block [0x8219135C..0x82191428)
	// 8219135C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191360: 7FA6EB78  mr r6, r29
	ctx.r[6].u64 = ctx.r[29].u64;
	// 82191364: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82191368: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219136C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82191370: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82191374: 4BFD2655  bl 0x821639c8
	ctx.lr = 0x82191378;
	sub_821639C8(ctx, base);
	// 82191378: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219137C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82191380: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82191384: 614A94C4  ori r10, r10, 0x94c4
	ctx.r[10].u64 = ctx.r[10].u64 | 38084;
	// 82191388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219138C: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82191390: 2B0B0020  cmplwi cr6, r11, 0x20
	ctx.cr[6].compare_u32(ctx.r[11].u32, 32 as u32, &mut ctx.xer);
	// 82191394: 419A0094  beq cr6, 0x82191428
	if ctx.cr[6].eq {
	pc = 0x82191428; continue 'dispatch;
	}
	// 82191398: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219139C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821913A0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821913A4: 4BFF8A7D  bl 0x82189e20
	ctx.lr = 0x821913A8;
	sub_82189E20(ctx, base);
	// 821913A8: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821913AC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821913B0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821913B4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821913B8: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821913BC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821913C0: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821913C4: D3EB01D0  stfs f31, 0x1d0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 821913C8: 938B0148  stw r28, 0x148(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[28].u32 ) };
	// 821913CC: D3EB01D4  stfs f31, 0x1d4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(468 as u32), tmp.u32 ) };
	// 821913D0: 938B01C4  stw r28, 0x1c4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(452 as u32), ctx.r[28].u32 ) };
	// 821913D4: D3EB01D8  stfs f31, 0x1d8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(472 as u32), tmp.u32 ) };
	// 821913D8: D3EB01E0  stfs f31, 0x1e0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 821913DC: D3EB01E4  stfs f31, 0x1e4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 821913E0: D3EB01E8  stfs f31, 0x1e8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 821913E4: D00B0084  stfs f0, 0x84(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821913E8: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821913EC: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821913F0: D3EB00F0  stfs f31, 0xf0(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(240 as u32), tmp.u32 ) };
	// 821913F4: D3EB00F4  stfs f31, 0xf4(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(244 as u32), tmp.u32 ) };
	// 821913F8: D3EB00F8  stfs f31, 0xf8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(248 as u32), tmp.u32 ) };
	// 821913FC: 4BFF8AD5  bl 0x82189ed0
	ctx.lr = 0x82191400;
	sub_82189ED0(ctx, base);
	// 82191400: D3E301C8  stfs f31, 0x1c8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82191404: 938301C0  stw r28, 0x1c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(448 as u32), ctx.r[28].u32 ) };
	// 82191408: D3E30058  stfs f31, 0x58(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219140C: D3E300E0  stfs f31, 0xe0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82191410: D3E300E4  stfs f31, 0xe4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82191414: D3E300E8  stfs f31, 0xe8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82191418: D3E30238  stfs f31, 0x238(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 8219141C: D3E30234  stfs f31, 0x234(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 82191420: D3E30230  stfs f31, 0x230(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 82191424: 48000154  b 0x82191578
	pc = 0x82191578; continue 'dispatch;
            }
            0x82191428 => {
    //   block [0x82191428..0x8219145C)
	// 82191428: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219142C: 83DF0010  lwz r30, 0x10(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) } as u64;
	// 82191430: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191438: 4E800421  bctrl
	ctx.lr = 0x8219143C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219143C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82191440: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82191444: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191448: 483A3D89  bl 0x825351d0
	ctx.lr = 0x8219144C;
	sub_825351D0(ctx, base);
	// 8219144C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82191450: 409A000C  bne cr6, 0x8219145c
	if !ctx.cr[6].eq {
	pc = 0x8219145C; continue 'dispatch;
	}
	// 82191454: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82191458: 48000064  b 0x821914bc
	pc = 0x821914BC; continue 'dispatch;
            }
            0x8219145C => {
    //   block [0x8219145C..0x821914BC)
	// 8219145C: 576B003E  slwi r11, r27, 0
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191460: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82191464: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191468: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219146C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191470: 4E800421  bctrl
	ctx.lr = 0x82191474;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191474: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191478: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219147C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82191480: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191484: 4E800421  bctrl
	ctx.lr = 0x82191488;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191488: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219148C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82191490: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191494: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82191498: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219149C: 4E800421  bctrl
	ctx.lr = 0x821914A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821914A0: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 821914A4: FC00F018  frsp f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[30].f64 as f32) as f64;
	// 821914A8: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821914AC: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821914B0: 915E0140  stw r10, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 821914B4: 815F0028  lwz r10, 0x28(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 821914B8: 93CA0258  stw r30, 0x258(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(600 as u32), ctx.r[30].u32 ) };
            }
            0x821914BC => {
    //   block [0x821914BC..0x82191578)
	// 821914BC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821914C0: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821914C4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821914C8: C00AD560  lfs f0, -0x2aa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821914CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821914D0: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821914D4: 912B0170  stw r9, 0x170(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(368 as u32), ctx.r[9].u32 ) };
	// 821914D8: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 821914DC: C1AA2780  lfs f13, 0x2780(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821914E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821914E4: D1AB0070  stfs f13, 0x70(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821914E8: C00A2038  lfs f0, 0x2038(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821914EC: D00B0174  stfs f0, 0x174(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(372 as u32), tmp.u32 ) };
	// 821914F0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821914F4: 83DF0014  lwz r30, 0x14(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821914F8: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821914FC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191500: 4E800421  bctrl
	ctx.lr = 0x82191504;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191504: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82191508: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219150C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191510: 483A3CC1  bl 0x825351d0
	ctx.lr = 0x82191514;
	sub_825351D0(ctx, base);
	// 82191514: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82191518: 419A0060  beq cr6, 0x82191578
	if ctx.cr[6].eq {
	pc = 0x82191578; continue 'dispatch;
	}
	// 8219151C: 576B003E  slwi r11, r27, 0
	ctx.r[11].u32 = ctx.r[27].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191520: 937E0000  stw r27, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[27].u32 ) };
	// 82191524: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191528: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219152C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191530: 4E800421  bctrl
	ctx.lr = 0x82191534;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191534: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191538: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219153C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82191540: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191544: 4E800421  bctrl
	ctx.lr = 0x82191548;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191548: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219154C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82191550: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82191554: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82191558: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219155C: 4E800421  bctrl
	ctx.lr = 0x82191560;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191560: 39600003  li r11, 3
	ctx.r[11].s64 = 3;
	// 82191564: FC00F018  frsp f0, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[30].f64 as f32) as f64;
	// 82191568: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8219156C: 917E0140  stw r11, 0x140(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82191570: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191574: 93CB025C  stw r30, 0x25c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(604 as u32), ctx.r[30].u32 ) };
            }
            0x82191578 => {
    //   block [0x82191578..0x821915C0)
	// 82191578: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219157C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82191580: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82191584: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191588: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219158C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191590: 4E800421  bctrl
	ctx.lr = 0x82191594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191594: 817F0028  lwz r11, 0x28(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191598: 83EB0264  lwz r31, 0x264(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 8219159C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821915A0: 419A0020  beq cr6, 0x821915c0
	if ctx.cr[6].eq {
	pc = 0x821915C0; continue 'dispatch;
	}
	// 821915A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821915A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821915AC: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 821915B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821915B4: 4E800421  bctrl
	ctx.lr = 0x821915B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821915B8: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821915BC: 419A0008  beq cr6, 0x821915c4
	if ctx.cr[6].eq {
	pc = 0x821915C4; continue 'dispatch;
	}
            }
            0x821915C0 => {
    //   block [0x821915C0..0x821915C4)
	// 821915C0: 7F9FE378  mr r31, r28
	ctx.r[31].u64 = ctx.r[28].u64;
	pc = 0x821915C4; continue 'dispatch;
            }
            0x821915C4 => {
    //   block [0x821915C4..0x82191610)
	// 821915C4: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821915C8: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821915CC: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 821915D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821915D4: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821915D8: C04B9F78  lfs f2, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821915DC: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821915E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821915E4: 4E800421  bctrl
	ctx.lr = 0x821915E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821915E8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821915EC: D3FF0050  stfs f31, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821915F0: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821915F4: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821915F8: C00BD564  lfs f0, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821915FC: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82191600: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82191604: CBC1FFC0  lfd f30, -0x40(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 82191608: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219160C: 483A3AF8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82191610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82191610 size=300
    let mut pc: u32 = 0x82191610;
    'dispatch: loop {
        match pc {
            0x82191610 => {
    //   block [0x82191610..0x82191668)
	// 82191610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82191614: 483A3AA9  bl 0x825350bc
	ctx.lr = 0x82191618;
	sub_82535080(ctx, base);
	// 82191618: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 8219161C: 483A49C1  bl 0x82535fdc
	ctx.lr = 0x82191620;
	sub_82535FB0(ctx, base);
	// 82191620: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82191624: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82191628: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219162C: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82191630: 4BFA78D9  bl 0x82138f08
	ctx.lr = 0x82191634;
	sub_82138F08(ctx, base);
	// 82191634: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82191638: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219163C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191640: 83EB026C  lwz r31, 0x26c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 82191644: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82191648: 419A0020  beq cr6, 0x82191668
	if ctx.cr[6].eq {
	pc = 0x82191668; continue 'dispatch;
	}
	// 8219164C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82191654: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82191658: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219165C: 4E800421  bctrl
	ctx.lr = 0x82191660;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191660: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82191664: 419A0008  beq cr6, 0x8219166c
	if ctx.cr[6].eq {
	pc = 0x8219166C; continue 'dispatch;
	}
            }
            0x82191668 => {
    //   block [0x82191668..0x8219166C)
	// 82191668: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x8219166C; continue 'dispatch;
            }
            0x8219166C => {
    //   block [0x8219166C..0x821916CC)
	// 8219166C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82191670: 419A00BC  beq cr6, 0x8219172c
	if ctx.cr[6].eq {
	pc = 0x8219172C; continue 'dispatch;
	}
	// 82191674: C3FE0130  lfs f31, 0x130(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(304 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82191678: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219167C: C3DE0134  lfs f30, 0x134(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82191680: C3BE0138  lfs f29, 0x138(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(312 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82191684: C39E0120  lfs f28, 0x120(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(288 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82191688: C37E0110  lfs f27, 0x110(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(272 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8219168C: C35E0114  lfs f26, 0x114(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(276 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82191690: C33E0118  lfs f25, 0x118(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(280 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82191694: 419A0098  beq cr6, 0x8219172c
	if ctx.cr[6].eq {
	pc = 0x8219172C; continue 'dispatch;
	}
	// 82191698: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 8219169C: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 821916A0: 83EB026C  lwz r31, 0x26c(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(620 as u32) ) } as u64;
	// 821916A4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821916A8: 419A0024  beq cr6, 0x821916cc
	if ctx.cr[6].eq {
	pc = 0x821916CC; continue 'dispatch;
	}
	// 821916AC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821916B0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821916B4: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 821916B8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821916BC: 4E800421  bctrl
	ctx.lr = 0x821916C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821916C0: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821916C4: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821916C8: 419A0008  beq cr6, 0x821916d0
	if ctx.cr[6].eq {
	pc = 0x821916D0; continue 'dispatch;
	}
            }
            0x821916CC => {
    //   block [0x821916CC..0x821916D0)
	// 821916CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821916D0; continue 'dispatch;
            }
            0x821916D0 => {
    //   block [0x821916D0..0x8219172C)
	// 821916D0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821916D4: D3EB0130  stfs f31, 0x130(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 821916D8: D3CB0134  stfs f30, 0x134(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 821916DC: D3AB0138  stfs f29, 0x138(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 821916E0: D3EB0050  stfs f31, 0x50(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821916E4: D3CB0054  stfs f30, 0x54(r11)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821916E8: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821916EC: D3AB0058  stfs f29, 0x58(r11)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821916F0: D38B0120  stfs f28, 0x120(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 821916F4: D36B0110  stfs f27, 0x110(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821916F8: D34B0114  stfs f26, 0x114(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 821916FC: D32B0118  stfs f25, 0x118(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82191700: D38B0070  stfs f28, 0x70(r11)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82191704: D36B0060  stfs f27, 0x60(r11)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82191708: D34B0064  stfs f26, 0x64(r11)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219170C: D32B0068  stfs f25, 0x68(r11)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82191710: D00B0084  stfs f0, 0x84(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82191714: D00B008C  stfs f0, 0x8c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82191718: D00B0088  stfs f0, 0x88(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219171C: C01E00E0  lfs f0, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191720: D00B00E0  stfs f0, 0xe0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82191724: C01E00E8  lfs f0, 0xe8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(232 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191728: D00B00E8  stfs f0, 0xe8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(232 as u32), tmp.u32 ) };
	pc = 0x8219172C; continue 'dispatch;
            }
            0x8219172C => {
    //   block [0x8219172C..0x8219173C)
	// 8219172C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82191730: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82191734: 483A48F5  bl 0x82536028
	ctx.lr = 0x82191738;
	sub_82535FFC(ctx, base);
	// 82191738: 483A39D4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82191740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82191740 size=300
    let mut pc: u32 = 0x82191740;
    'dispatch: loop {
        match pc {
            0x82191740 => {
    //   block [0x82191740..0x821917C8)
	// 82191740: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82191744: 816BB9C0  lwz r11, -0x4640(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17984 as u32) ) } as u64;
	// 82191748: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219174C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82191750: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82191754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82191758: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8219175C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82191760: 8143018C  lwz r10, 0x18c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(396 as u32) ) } as u64;
	// 82191764: 396B0C40  addi r11, r11, 0xc40
	ctx.r[11].s64 = ctx.r[11].s64 + 3136;
	// 82191768: 816B0688  lwz r11, 0x688(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219176C: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82191770: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 82191774: 9163018C  stw r11, 0x18c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(396 as u32), ctx.r[11].u32 ) };
	// 82191778: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219177C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82191780: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82191784: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 82191788: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219178C: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 82191790: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82191794: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82191798: 7D494B78  or r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219179C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821917A0: 614A860C  ori r10, r10, 0x860c
	ctx.r[10].u64 = ctx.r[10].u64 | 34316;
	// 821917A4: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821917A8: 7D2A5378  or r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 | ctx.r[10].u64;
	// 821917AC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821917B0: 419A0018  beq cr6, 0x821917c8
	if ctx.cr[6].eq {
	pc = 0x821917C8; continue 'dispatch;
	}
	// 821917B4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821917B8: 614A85FC  ori r10, r10, 0x85fc
	ctx.r[10].u64 = ctx.r[10].u64 | 34300;
	// 821917BC: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821917C0: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821917C4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	pc = 0x821917C8; continue 'dispatch;
            }
            0x821917C8 => {
    //   block [0x821917C8..0x82191818)
	// 821917C8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821917CC: 81430194  lwz r10, 0x194(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 821917D0: C1A30014  lfs f13, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821917D4: 612985D8  ori r9, r9, 0x85d8
	ctx.r[9].u64 = ctx.r[9].u64 | 34264;
	// 821917D8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821917DC: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 821917E0: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821917E4: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 821917E8: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 821917EC: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821917F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821917F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821917F8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821917FC: 41980038  blt cr6, 0x82191834
	if ctx.cr[6].lt {
	pc = 0x82191834; continue 'dispatch;
	}
	// 82191800: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 82191804: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82191808: 419A0010  beq cr6, 0x82191818
	if ctx.cr[6].eq {
	pc = 0x82191818; continue 'dispatch;
	}
	// 8219180C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82191810: C00B01D0  lfs f0, 0x1d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(464 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191814: 4800001C  b 0x82191830
	pc = 0x82191830; continue 'dispatch;
            }
            0x82191818 => {
    //   block [0x82191818..0x82191830)
	// 82191818: 396AFFFF  addi r11, r10, -1
	ctx.r[11].s64 = ctx.r[10].s64 + -1;
	// 8219181C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82191820: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82191824: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82191828: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219182C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x82191830; continue 'dispatch;
            }
            0x82191830 => {
    //   block [0x82191830..0x82191834)
	// 82191830: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x82191834; continue 'dispatch;
            }
            0x82191834 => {
    //   block [0x82191834..0x8219185C)
	// 82191834: 81630190  lwz r11, 0x190(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(400 as u32) ) } as u64;
	// 82191838: C1A30014  lfs f13, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219183C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82191840: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82191844: C801FFF0  lfd f0, -0x10(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82191848: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219184C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82191850: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82191854: 40980008  bge cr6, 0x8219185c
	if !ctx.cr[6].lt {
	pc = 0x8219185C; continue 'dispatch;
	}
	// 82191858: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	pc = 0x8219185C; continue 'dispatch;
            }
            0x8219185C => {
    //   block [0x8219185C..0x8219186C)
	// 8219185C: 81630020  lwz r11, 0x20(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82191860: C0030014  lfs f0, 0x14(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191864: D00B01C8  stfs f0, 0x1c8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82191868: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82191870(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82191870 size=236
    let mut pc: u32 = 0x82191870;
    'dispatch: loop {
        match pc {
            0x82191870 => {
    //   block [0x82191870..0x821918F4)
	// 82191870: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82191874: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82191878: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219187C: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82191880: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82191884: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82191888: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8219188C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191890: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82191894: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82191898: 4E800421  bctrl
	ctx.lr = 0x8219189C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219189C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821918A0: 419A00A4  beq cr6, 0x82191944
	if ctx.cr[6].eq {
	pc = 0x82191944; continue 'dispatch;
	}
	// 821918A4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821918A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821918AC: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821918B0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821918B4: 4E800421  bctrl
	ctx.lr = 0x821918B8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821918B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821918BC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821918C0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821918C4: 356A0048  addic. r11, r10, 0x48
	ctx.xer.ca = (ctx.r[10].u32 > (!(72 as u32)));
	ctx.r[11].s64 = ctx.r[10].s64 + 72;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821918C8: 392A004A  addi r9, r10, 0x4a
	ctx.r[9].s64 = ctx.r[10].s64 + 74;
	// 821918CC: 917F007C  stw r11, 0x7c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821918D0: 913F0080  stw r9, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821918D4: 41820070  beq 0x82191944
	if ctx.cr[0].eq {
	pc = 0x82191944; continue 'dispatch;
	}
	// 821918D8: A16B0000  lhz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821918DC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821918E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821918E4: 419A0060  beq cr6, 0x82191944
	if ctx.cr[6].eq {
	pc = 0x82191944; continue 'dispatch;
	}
	// 821918E8: 7D2B4B78  mr r11, r9
	ctx.r[11].u64 = ctx.r[9].u64;
	// 821918EC: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 821918F0: C1A9BA38  lfs f13, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
            }
            0x821918F4 => {
    //   block [0x821918F4..0x82191924)
	// 821918F4: A12B0000  lhz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821918F8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821918FC: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 82191900: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 82191904: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82191908: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219190C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82191910: ED806828  fsubs f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82191914: FF0CF800  fcmpu cr6, f12, f31
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[31].f64);
	// 82191918: 4098000C  bge cr6, 0x82191924
	if !ctx.cr[6].lt {
	pc = 0x82191924; continue 'dispatch;
	}
	// 8219191C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82191920: 40990020  ble cr6, 0x82191940
	if !ctx.cr[6].gt {
	pc = 0x82191940; continue 'dispatch;
	}
	pc = 0x82191924; continue 'dispatch;
            }
            0x82191924 => {
    //   block [0x82191924..0x82191940)
	// 82191924: 813F007C  lwz r9, 0x7c(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(124 as u32) ) } as u64;
	// 82191928: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219192C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82191930: A1290000  lhz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191934: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82191938: 4198FFBC  blt cr6, 0x821918f4
	if ctx.cr[6].lt {
	pc = 0x821918F4; continue 'dispatch;
	}
	// 8219193C: 48000008  b 0x82191944
	pc = 0x82191944; continue 'dispatch;
            }
            0x82191940 => {
    //   block [0x82191940..0x82191944)
	// 82191940: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	pc = 0x82191944; continue 'dispatch;
            }
            0x82191944 => {
    //   block [0x82191944..0x8219195C)
	// 82191944: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82191948: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219194C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82191950: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82191954: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82191958: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82191960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82191960 size=2440
    let mut pc: u32 = 0x82191960;
    'dispatch: loop {
        match pc {
            0x82191960 => {
    //   block [0x82191960..0x82191A24)
	// 82191960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82191964: 483A374D  bl 0x825350b0
	ctx.lr = 0x82191968;
	sub_82535080(ctx, base);
	// 82191968: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 8219196C: 483A4645  bl 0x82535fb0
	ctx.lr = 0x82191970;
	sub_82535FB0(ctx, base);
	// 82191970: 3981FF30  addi r12, r1, -0xd0
	ctx.r[12].s64 = ctx.r[1].s64 + -208;
	// 82191974: 483A7A19  bl 0x8253938c
	ctx.lr = 0x82191978;
	sub_82539130(ctx, base);
	// 82191978: 9421FD80  stwu r1, -0x280(r1)
	ea = ctx.r[1].u32.wrapping_add(-640 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219197C: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 82191980: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82191984: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82191988: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219198C: 4E800421  bctrl
	ctx.lr = 0x82191990;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82191990: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82191994: 419A093C  beq cr6, 0x821922d0
	if ctx.cr[6].eq {
	pc = 0x821922D0; continue 'dispatch;
	}
	// 82191998: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219199C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821919A0: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821919A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821919A8: 4E800421  bctrl
	ctx.lr = 0x821919AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821919AC: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821919B0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821919B4: 419A091C  beq cr6, 0x821922d0
	if ctx.cr[6].eq {
	pc = 0x821922D0; continue 'dispatch;
	}
	// 821919B8: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 821919BC: C01C0014  lfs f0, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821919C0: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821919C4: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 821919C8: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821919CC: 835C0020  lwz r26, 0x20(r28)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(32 as u32) ) } as u64;
	// 821919D0: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 821919D4: 48001BE5  bl 0x821935b8
	ctx.lr = 0x821919D8;
	sub_821935B8(ctx, base);
	// 821919D8: 397D0048  addi r11, r29, 0x48
	ctx.r[11].s64 = ctx.r[29].s64 + 72;
	// 821919DC: 395D004A  addi r10, r29, 0x4a
	ctx.r[10].s64 = ctx.r[29].s64 + 74;
	// 821919E0: 917C007C  stw r11, 0x7c(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821919E4: 915C0080  stw r10, 0x80(r28)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821919E8: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821919EC: 7F035840  cmplw cr6, r3, r11
	ctx.cr[6].compare_u32(ctx.r[3].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821919F0: 409808E0  bge cr6, 0x821922d0
	if !ctx.cr[6].lt {
	pc = 0x821922D0; continue 'dispatch;
	}
	// 821919F4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821919F8: 39430021  addi r10, r3, 0x21
	ctx.r[10].s64 = ctx.r[3].s64 + 33;
	// 821919FC: 906BB9C4  stw r3, -0x463c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17980 as u32), ctx.r[3].u32 ) };
	// 82191A00: 554B103A  slwi r11, r10, 2
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191A04: 81410080  lwz r10, 0x80(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) } as u64;
	// 82191A08: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82191A0C: 7D6BE02E  lwzx r11, r11, r28
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[28].u32)) } as u64;
	// 82191A10: A10B0004  lhz r8, 4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82191A14: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82191A18: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82191A1C: 41980008  blt cr6, 0x82191a24
	if ctx.cr[6].lt {
	pc = 0x82191A24; continue 'dispatch;
	}
	// 82191A20: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
            }
            0x82191A24 => {
    //   block [0x82191A24..0x821920A8)
	// 82191A24: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82191A28: C1BC0014  lfs f13, 0x14(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82191A2C: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 82191A30: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82191A34: 550A2834  slwi r10, r8, 5
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82191A38: 7FE95A14  add r31, r9, r11
	ctx.r[31].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82191A3C: 7FCA5A14  add r30, r10, r11
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82191A40: 39630001  addi r11, r3, 1
	ctx.r[11].s64 = ctx.r[3].s64 + 1;
	// 82191A44: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82191A48: C19F001C  lfs f12, 0x1c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82191A4C: C17E001C  lfs f11, 0x1c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82191A50: C15F000C  lfs f10, 0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82191A54: C13F0010  lfs f9, 0x10(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82191A58: 7D6BEA2E  lhzx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 82191A5C: C11E0010  lfs f8, 0x10(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82191A60: C0FE0014  lfs f7, 0x14(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82191A64: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82191A68: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191A6C: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191A70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191A74: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191A78: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191A7C: C00B2238  lfs f0, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82191A80: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82191A84: EF2A0032  fmuls f25, f10, f0
	ctx.f[25].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191A88: C15F0014  lfs f10, 0x14(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82191A8C: EFAA0032  fmuls f29, f10, f0
	ctx.f[29].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191A90: 3B6BBA44  addi r27, r11, -0x45bc
	ctx.r[27].s64 = ctx.r[11].s64 + -17852;
	// 82191A94: FD406E5E  fctidz f10, f13
	ctx.f[10].s64 = if ctx.f[13].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[13].f64.trunc() as i64 };
	// 82191A98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82191A9C: EF890032  fmuls f28, f9, f0
	ctx.f[28].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AA0: C13E000C  lfs f9, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82191AA4: EEC90032  fmuls f22, f9, f0
	ctx.f[22].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AA8: C13F0000  lfs f9, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82191AAC: EEE80032  fmuls f23, f8, f0
	ctx.f[23].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AB0: C11F0004  lfs f8, 4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82191AB4: EF070032  fmuls f24, f7, f0
	ctx.f[24].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AB8: C0FF0008  lfs f7, 8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82191ABC: EE690032  fmuls f19, f9, f0
	ctx.f[19].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AC0: C13E0000  lfs f9, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82191AC4: EE880032  fmuls f20, f8, f0
	ctx.f[20].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AC8: C11E0004  lfs f8, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82191ACC: EEA70032  fmuls f21, f7, f0
	ctx.f[21].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AD0: C0FE0008  lfs f7, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82191AD4: EE090032  fmuls f16, f9, f0
	ctx.f[16].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AD8: C37BFFF4  lfs f27, -0xc(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-12 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82191ADC: EE280032  fmuls f17, f8, f0
	ctx.f[17].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AE0: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82191AE4: EE470032  fmuls f18, f7, f0
	ctx.f[18].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82191AE8: D3210120  stfs f25, 0x120(r1)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82191AEC: FC00569C  fcfid f0, f10
	ctx.f[0].f64 = (ctx.f[10].s64 as f64);
	// 82191AF0: D3810124  stfs f28, 0x124(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(292 as u32), tmp.u32 ) };
	// 82191AF4: D3A10128  stfs f29, 0x128(r1)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(296 as u32), tmp.u32 ) };
	// 82191AF8: FDE06050  fneg f15, f12
	ctx.f[15].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82191AFC: D2C10100  stfs f22, 0x100(r1)
	tmp.f32 = (ctx.f[22].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(256 as u32), tmp.u32 ) };
	// 82191B00: FDC05850  fneg f14, f11
	ctx.f[14].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82191B04: D2E10104  stfs f23, 0x104(r1)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 82191B08: D3010108  stfs f24, 0x108(r1)
	tmp.f32 = (ctx.f[24].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(264 as u32), tmp.u32 ) };
	// 82191B0C: D26100A0  stfs f19, 0xa0(r1)
	tmp.f32 = (ctx.f[19].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82191B10: D28100A4  stfs f20, 0xa4(r1)
	tmp.f32 = (ctx.f[20].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82191B14: D2A100A8  stfs f21, 0xa8(r1)
	tmp.f32 = (ctx.f[21].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82191B18: D20100B0  stfs f16, 0xb0(r1)
	tmp.f32 = (ctx.f[16].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82191B1C: D22100B4  stfs f17, 0xb4(r1)
	tmp.f32 = (ctx.f[17].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82191B20: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82191B24: D24100B8  stfs f18, 0xb8(r1)
	tmp.f32 = (ctx.f[18].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82191B28: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82191B2C: EFDB0028  fsubs f30, f27, f0
	ctx.f[30].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82191B30: EF5BF028  fsubs f26, f27, f30
	ctx.f[26].f64 = (((ctx.f[27].f64 - ctx.f[30].f64) as f32) as f64);
	// 82191B34: 419A0574  beq cr6, 0x821920a8
	if ctx.cr[6].eq {
	pc = 0x821920A8; continue 'dispatch;
	}
	// 82191B38: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 82191B3C: D3E1005C  stfs f31, 0x5c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82191B40: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	// 82191B44: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82191B48: 396B5C40  addi r11, r11, 0x5c40
	ctx.r[11].s64 = ctx.r[11].s64 + 23616;
	// 82191B4C: D3610054  stfs f27, 0x54(r1)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82191B50: D3E10058  stfs f31, 0x58(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82191B54: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	pc = 0x821920A8; continue 'dispatch;
            }
            0x821920A8 => {
    //   block [0x821920A8..0x821922D0)
	// 821920A8: EDB7E028  fsubs f13, f23, f28
	ctx.f[13].f64 = (((ctx.f[23].f64 - ctx.f[28].f64) as f32) as f64);
	// 821920AC: 817C007C  lwz r11, 0x7c(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(124 as u32) ) } as u64;
	// 821920B0: EC18E828  fsubs f0, f24, f29
	ctx.f[0].f64 = (((ctx.f[24].f64 - ctx.f[29].f64) as f32) as f64);
	// 821920B4: ED96C828  fsubs f12, f22, f25
	ctx.f[12].f64 = (((ctx.f[22].f64 - ctx.f[25].f64) as f32) as f64);
	// 821920B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821920BC: ED71A028  fsubs f11, f17, f20
	ctx.f[11].f64 = (((ctx.f[17].f64 - ctx.f[20].f64) as f32) as f64);
	// 821920C0: D1610130  stfs f11, 0x130(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 821920C4: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 821920C8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821920CC: EDB2A828  fsubs f13, f18, f21
	ctx.f[13].f64 = (((ctx.f[18].f64 - ctx.f[21].f64) as f32) as f64);
	// 821920D0: D1A10110  stfs f13, 0x110(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 821920D4: EDB09828  fsubs f13, f16, f19
	ctx.f[13].f64 = (((ctx.f[16].f64 - ctx.f[19].f64) as f32) as f64);
	// 821920D8: D1A10084  stfs f13, 0x84(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821920DC: EC0C033A  fmadds f0, f12, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 821920E0: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 821920E4: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821920E8: 419A0070  beq cr6, 0x82192158
	if ctx.cr[6].eq {
	pc = 0x82192158; continue 'dispatch;
	}
	// 821920EC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821920F0: C03C0014  lfs f1, 0x14(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(20 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821920F4: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 821920F8: 4BFFF779  bl 0x82191870
	ctx.lr = 0x821920FC;
	sub_82191870(ctx, base);
	// 821920FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192100: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192104: C00B25C4  lfs f0, 0x25c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192108: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219210C: 41990030  bgt cr6, 0x8219213c
	if ctx.cr[6].gt {
	pc = 0x8219213C; continue 'dispatch;
	}
	// 82192110: C1A10130  lfs f13, 0x130(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(304 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192114: ED8D0372  fmuls f12, f13, f13
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192118: C1A10110  lfs f13, 0x110(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(272 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219211C: ED8D637A  fmadds f12, f13, f13, f12
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192120: C1A10084  lfs f13, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192124: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192128: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 8219212C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82192130: 4199000C  bgt cr6, 0x8219213c
	if ctx.cr[6].gt {
	pc = 0x8219213C; continue 'dispatch;
	}
	// 82192134: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82192138: 419A0020  beq cr6, 0x82192158
	if ctx.cr[6].eq {
	pc = 0x82192158; continue 'dispatch;
	}
	// 8219213C: FF1ED000  fcmpu cr6, f30, f26
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[26].f64);
	// 82192140: 40980010  bge cr6, 0x82192150
	if !ctx.cr[6].lt {
	pc = 0x82192150; continue 'dispatch;
	}
	// 82192144: FFC0F890  fmr f30, f31
	ctx.f[30].f64 = ctx.f[31].f64;
	// 82192148: FF40D890  fmr f26, f27
	ctx.f[26].f64 = ctx.f[27].f64;
	// 8219214C: 4800000C  b 0x82192158
	pc = 0x82192158; continue 'dispatch;
	// 82192150: FFC0D890  fmr f30, f27
	ctx.f[30].f64 = ctx.f[27].f64;
	// 82192154: FF40F890  fmr f26, f31
	ctx.f[26].f64 = ctx.f[31].f64;
	// 82192158: EC1907B2  fmuls f0, f25, f30
	ctx.f[0].f64 = (((ctx.f[25].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219215C: 3BBA01E0  addi r29, r26, 0x1e0
	ctx.r[29].s64 = ctx.r[26].s64 + 480;
	// 82192160: EDBC07B2  fmuls f13, f28, f30
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[30].f64) as f32) as f64);
	// 82192164: ED9D07B2  fmuls f12, f29, f30
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[30].f64) as f32) as f64);
	// 82192168: ED7307B2  fmuls f11, f19, f30
	ctx.f[11].f64 = (((ctx.f[19].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219216C: ED5407B2  fmuls f10, f20, f30
	ctx.f[10].f64 = (((ctx.f[20].f64 * ctx.f[30].f64) as f32) as f64);
	// 82192170: ED3507B2  fmuls f9, f21, f30
	ctx.f[9].f64 = (((ctx.f[21].f64 * ctx.f[30].f64) as f32) as f64);
	// 82192174: EC1606BA  fmadds f0, f22, f26, f0
	ctx.f[0].f64 = (((ctx.f[22].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 82192178: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219217C: EDB76EBA  fmadds f13, f23, f26, f13
	ctx.f[13].f64 = (((ctx.f[23].f64 * ctx.f[26].f64 + ctx.f[13].f64) as f32) as f64);
	// 82192180: D1BD0004  stfs f13, 4(r29)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82192184: ED9866BA  fmadds f12, f24, f26, f12
	ctx.f[12].f64 = (((ctx.f[24].f64 * ctx.f[26].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192188: D19D0008  stfs f12, 8(r29)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219218C: ED705EBA  fmadds f11, f16, f26, f11
	ctx.f[11].f64 = (((ctx.f[16].f64 * ctx.f[26].f64 + ctx.f[11].f64) as f32) as f64);
	// 82192190: D17D0010  stfs f11, 0x10(r29)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82192194: ED5156BA  fmadds f10, f17, f26, f10
	ctx.f[10].f64 = (((ctx.f[17].f64 * ctx.f[26].f64 + ctx.f[10].f64) as f32) as f64);
	// 82192198: D15D0014  stfs f10, 0x14(r29)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219219C: ED324EBA  fmadds f9, f18, f26, f9
	ctx.f[9].f64 = (((ctx.f[18].f64 * ctx.f[26].f64 + ctx.f[9].f64) as f32) as f64);
	// 821921A0: D13D0018  stfs f9, 0x18(r29)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 821921A4: 817C0194  lwz r11, 0x194(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(404 as u32) ) } as u64;
	// 821921A8: 917D0020  stw r11, 0x20(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 821921AC: C01F0018  lfs f0, 0x18(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821921B0: EC0007B2  fmuls f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821921B4: C1BE0018  lfs f13, 0x18(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821921B8: EC0D06BA  fmadds f0, f13, f26, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 821921BC: C1BB0000  lfs f13, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821921C0: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821921C4: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821921C8: 40980014  bge cr6, 0x821921dc
	if !ctx.cr[6].lt {
	pc = 0x821921DC; continue 'dispatch;
	}
	// 821921CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821921D0: C1AB2BF0  lfs f13, 0x2bf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821921D4: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821921D8: D01D0030  stfs f0, 0x30(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 821921DC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821921E0: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 821921E4: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821921E8: FC207890  fmr f1, f15
	ctx.f[1].f64 = ctx.f[15].f64;
	// 821921EC: 917D0028  stw r11, 0x28(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 821921F0: 915D002C  stw r10, 0x2c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 821921F4: C01C0030  lfs f0, 0x30(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821921F8: D01D0040  stfs f0, 0x40(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 821921FC: C01C0034  lfs f0, 0x34(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192200: D01D0044  stfs f0, 0x44(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82192204: C01C0038  lfs f0, 0x38(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192208: D01D0048  stfs f0, 0x48(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219220C: C01C0044  lfs f0, 0x44(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192210: D01D0054  stfs f0, 0x54(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82192214: 4BF91AF5  bl 0x82123d08
	ctx.lr = 0x82192218;
	sub_82123D08(ctx, base);
	// 82192218: FC40D890  fmr f2, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[27].f64;
	// 8219221C: 4BF91AED  bl 0x82123d08
	ctx.lr = 0x82192220;
	sub_82123D08(ctx, base);
	// 82192220: FFA00890  fmr f29, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].f64 = ctx.f[1].f64;
	// 82192224: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82192228: FC207090  fmr f1, f14
	ctx.f[1].f64 = ctx.f[14].f64;
	// 8219222C: 4BF91ADD  bl 0x82123d08
	ctx.lr = 0x82192230;
	sub_82123D08(ctx, base);
	// 82192230: FC40D890  fmr f2, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[27].f64;
	// 82192234: 4BF91AD5  bl 0x82123d08
	ctx.lr = 0x82192238;
	sub_82123D08(ctx, base);
	// 82192238: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 8219223C: FF1ED800  fcmpu cr6, f30, f27
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[27].f64);
	// 82192240: 4098007C  bge cr6, 0x821922bc
	if !ctx.cr[6].lt {
	pc = 0x821922BC; continue 'dispatch;
	}
	// 82192244: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82192248: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8219224C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82192250: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 82192254: 481D5FC5  bl 0x82368218
	ctx.lr = 0x82192258;
	sub_82368218(ctx, base);
	// 82192258: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8219225C: 386100B0  addi r3, r1, 0xb0
	ctx.r[3].s64 = ctx.r[1].s64 + 176;
	// 82192260: 481E2141  bl 0x823743a0
	ctx.lr = 0x82192264;
	sub_823743A0(ctx, base);
	// 82192264: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 82192268: FC60F890  fmr f3, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[31].f64;
	// 8219226C: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 82192270: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82192274: 481D5FA5  bl 0x82368218
	ctx.lr = 0x82192278;
	sub_82368218(ctx, base);
	// 82192278: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 8219227C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82192280: 481E2121  bl 0x823743a0
	ctx.lr = 0x82192284;
	sub_823743A0(ctx, base);
	// 82192284: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 82192288: 388100B0  addi r4, r1, 0xb0
	ctx.r[4].s64 = ctx.r[1].s64 + 176;
	// 8219228C: FC20D090  fmr f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[26].f64;
	// 82192290: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 82192294: 481E250D  bl 0x823747a0
	ctx.lr = 0x82192298;
	sub_823747A0(ctx, base);
	// 82192298: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219229C: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 821922A0: 481D6299  bl 0x82368538
	ctx.lr = 0x821922A4;
	sub_82368538(ctx, base);
	// 821922A4: 38C10084  addi r6, r1, 0x84
	ctx.r[6].s64 = ctx.r[1].s64 + 132;
	// 821922A8: 38A10084  addi r5, r1, 0x84
	ctx.r[5].s64 = ctx.r[1].s64 + 132;
	// 821922AC: 389D0058  addi r4, r29, 0x58
	ctx.r[4].s64 = ctx.r[29].s64 + 88;
	// 821922B0: 386100C0  addi r3, r1, 0xc0
	ctx.r[3].s64 = ctx.r[1].s64 + 192;
	// 821922B4: 481D635D  bl 0x82368610
	ctx.lr = 0x821922B8;
	sub_82368610(ctx, base);
	// 821922B8: 48000010  b 0x821922c8
	pc = 0x821922C8; continue 'dispatch;
	// 821922BC: EC1D07B2  fmuls f0, f29, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[29].f64 * ctx.f[30].f64) as f32) as f64);
	// 821922C0: EC1C06BA  fmadds f0, f28, f26, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[26].f64 + ctx.f[0].f64) as f32) as f64);
	// 821922C4: D01D0058  stfs f0, 0x58(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821922C8: D3FD0060  stfs f31, 0x60(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821922CC: D3FD0068  stfs f31, 0x68(r29)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(104 as u32), tmp.u32 ) };
            }
            0x821922D0 => {
    //   block [0x821922D0..0x821922E8)
	// 821922D0: 38210280  addi r1, r1, 0x280
	ctx.r[1].s64 = ctx.r[1].s64 + 640;
	// 821922D4: 3981FF30  addi r12, r1, -0xd0
	ctx.r[12].s64 = ctx.r[1].s64 + -208;
	// 821922D8: 483A734D  bl 0x82539624
	ctx.lr = 0x821922DC;
	sub_825393C8(ctx, base);
	// 821922DC: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821922E0: 483A3D1D  bl 0x82535ffc
	ctx.lr = 0x821922E4;
	sub_82535FFC(ctx, base);
	// 821922E4: 483A2E1C  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821922E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821922E8 size=864
    let mut pc: u32 = 0x821922E8;
    'dispatch: loop {
        match pc {
            0x821922E8 => {
    //   block [0x821922E8..0x8219239C)
	// 821922E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821922EC: 483A2DD1  bl 0x825350bc
	ctx.lr = 0x821922F0;
	sub_82535080(ctx, base);
	// 821922F0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821922F4: 483A3CF1  bl 0x82535fe4
	ctx.lr = 0x821922F8;
	sub_82535FB0(ctx, base);
	// 821922F8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821922FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82192300: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192304: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82192308: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219230C: 4E800421  bctrl
	ctx.lr = 0x82192310;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82192310: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82192314: 419A0324  beq cr6, 0x82192638
	if ctx.cr[6].eq {
	pc = 0x82192638; continue 'dispatch;
	}
	// 82192318: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219231C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82192320: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82192324: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82192328: 4E800421  bctrl
	ctx.lr = 0x8219232C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219232C: 83A30000  lwz r29, 0(r3)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192330: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82192334: 419A0304  beq cr6, 0x82192638
	if ctx.cr[6].eq {
	pc = 0x82192638; continue 'dispatch;
	}
	// 82192338: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8219233C: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192340: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 82192344: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 82192348: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219234C: 83DF0020  lwz r30, 0x20(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82192350: 7C005FAE  stfiwx f0, 0, r11
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32, tmp.u32) };
	// 82192354: 48001265  bl 0x821935b8
	ctx.lr = 0x82192358;
	sub_821935B8(ctx, base);
	// 82192358: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 8219235C: 419802DC  blt cr6, 0x82192638
	if ctx.cr[6].lt {
	pc = 0x82192638; continue 'dispatch;
	}
	// 82192360: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82192364: 7F035800  cmpw cr6, r3, r11
	ctx.cr[6].compare_i32(ctx.r[3].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82192368: 409802D0  bge cr6, 0x82192638
	if !ctx.cr[6].lt {
	pc = 0x82192638; continue 'dispatch;
	}
	// 8219236C: 39430021  addi r10, r3, 0x21
	ctx.r[10].s64 = ctx.r[3].s64 + 33;
	// 82192370: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82192374: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82192378: 906BB9C4  stw r3, -0x463c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17980 as u32), ctx.r[3].u32 ) };
	// 8219237C: 7D4AF82E  lwzx r10, r10, r31
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 82192380: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82192384: 392B0001  addi r9, r11, 1
	ctx.r[9].s64 = ctx.r[11].s64 + 1;
	// 82192388: A10A0004  lhz r8, 4(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219238C: 3908FFFF  addi r8, r8, -1
	ctx.r[8].s64 = ctx.r[8].s64 + -1;
	// 82192390: 7F0B4000  cmpw cr6, r11, r8
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82192394: 41980008  blt cr6, 0x8219239c
	if ctx.cr[6].lt {
	pc = 0x8219239C; continue 'dispatch;
	}
	// 82192398: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
            }
            0x8219239C => {
    //   block [0x8219239C..0x82192540)
	// 8219239C: C01F0014  lfs f0, 0x14(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821923A0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821923A4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821923A8: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821923AC: 556B2834  slwi r11, r11, 5
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(5);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821923B0: 55292834  slwi r9, r9, 5
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821923B4: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821923B8: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821923BC: 39230001  addi r9, r3, 1
	ctx.r[9].s64 = ctx.r[3].s64 + 1;
	// 821923C0: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821923C4: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821923C8: C12B0010  lfs f9, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821923CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821923D0: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821923D4: C0EB0000  lfs f7, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821923D8: C0CB0004  lfs f6, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821923DC: 7D29EA2E  lhzx r9, r9, r29
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[29].u32)) } as u64;
	// 821923E0: C0AB0008  lfs f5, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821923E4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821923E8: C04A000C  lfs f2, 0xc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821923EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821923F0: C06A0010  lfs f3, 0x10(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821923F4: C08A0014  lfs f4, 0x14(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821923F8: C3CA0000  lfs f30, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821923FC: C3EA0004  lfs f31, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82192400: C02A0008  lfs f1, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82192404: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82192408: D1410060  stfs f10, 0x60(r1)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219240C: D1210064  stfs f9, 0x64(r1)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82192410: D1010068  stfs f8, 0x68(r1)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82192414: D0410070  stfs f2, 0x70(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82192418: D0610074  stfs f3, 0x74(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219241C: D0810078  stfs f4, 0x78(r1)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82192420: D0E10080  stfs f7, 0x80(r1)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82192424: D0C10084  stfs f6, 0x84(r1)
	tmp.f32 = (ctx.f[6].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82192428: D0A10088  stfs f5, 0x88(r1)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219242C: D3C10090  stfs f30, 0x90(r1)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82192430: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82192434: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192438: D3E10094  stfs f31, 0x94(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219243C: D0210098  stfs f1, 0x98(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82192440: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192444: EFAD0028  fsubs f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192448: 419A00F8  beq cr6, 0x82192540
	if ctx.cr[6].eq {
	pc = 0x82192540; continue 'dispatch;
	}
	// 8219244C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82192450: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
	pc = 0x82192540; continue 'dispatch;
            }
            0x82192540 => {
    //   block [0x82192540..0x82192638)
	// 82192540: ED834828  fsubs f12, f3, f9
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[9].f64) as f32) as f64);
	// 82192544: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192548: EDA44028  fsubs f13, f4, f8
	ctx.f[13].f64 = (((ctx.f[4].f64 - ctx.f[8].f64) as f32) as f64);
	// 8219254C: ED625028  fsubs f11, f2, f10
	ctx.f[11].f64 = (((ctx.f[2].f64 - ctx.f[10].f64) as f32) as f64);
	// 82192550: EF9F3028  fsubs f28, f31, f6
	ctx.f[28].f64 = (((ctx.f[31].f64 - ctx.f[6].f64) as f32) as f64);
	// 82192554: EF612828  fsubs f27, f1, f5
	ctx.f[27].f64 = (((ctx.f[1].f64 - ctx.f[5].f64) as f32) as f64);
	// 82192558: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 8219255C: EDAD637A  fmadds f13, f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192560: EDAB6AFA  fmadds f13, f11, f11, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64);
	// 82192564: ED7E3828  fsubs f11, f30, f7
	ctx.f[11].f64 = (((ctx.f[30].f64 - ctx.f[7].f64) as f32) as f64);
	// 82192568: ED80682C  fsqrts f12, f13
	ctx.f[12].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 8219256C: C1AB25C4  lfs f13, 0x25c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9668 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192570: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 82192574: 4199001C  bgt cr6, 0x82192590
	if ctx.cr[6].gt {
	pc = 0x82192590; continue 'dispatch;
	}
	// 82192578: ED9C0732  fmuls f12, f28, f28
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[28].f64) as f32) as f64);
	// 8219257C: ED9B66FA  fmadds f12, f27, f27, f12
	ctx.f[12].f64 = (((ctx.f[27].f64 * ctx.f[27].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192580: ED8B62FA  fmadds f12, f11, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192584: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 82192588: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8219258C: 4099001C  ble cr6, 0x821925a8
	if !ctx.cr[6].gt {
	pc = 0x821925A8; continue 'dispatch;
	}
	// 82192590: FD401090  fmr f10, f2
	ctx.f[10].f64 = ctx.f[2].f64;
	// 82192594: FD201890  fmr f9, f3
	ctx.f[9].f64 = ctx.f[3].f64;
	// 82192598: FD002090  fmr f8, f4
	ctx.f[8].f64 = ctx.f[4].f64;
	// 8219259C: FCE0F090  fmr f7, f30
	ctx.f[7].f64 = ctx.f[30].f64;
	// 821925A0: FCC0F890  fmr f6, f31
	ctx.f[6].f64 = ctx.f[31].f64;
	// 821925A4: FCA00890  fmr f5, f1
	ctx.f[5].f64 = ctx.f[1].f64;
	// 821925A8: EDAA0032  fmuls f13, f10, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821925B0: ED890032  fmuls f12, f9, f0
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925B4: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821925B8: ED680032  fmuls f11, f8, f0
	ctx.f[11].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925BC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821925C0: ED470032  fmuls f10, f7, f0
	ctx.f[10].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925C4: ED260032  fmuls f9, f6, f0
	ctx.f[9].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925C8: ED050032  fmuls f8, f5, f0
	ctx.f[8].f64 = (((ctx.f[5].f64 * ctx.f[0].f64) as f32) as f64);
	// 821925CC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821925D0: EDA26F7A  fmadds f13, f2, f29, f13
	ctx.f[13].f64 = (((ctx.f[2].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 821925D4: D1BE01E0  stfs f13, 0x1e0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(480 as u32), tmp.u32 ) };
	// 821925D8: ED83677A  fmadds f12, f3, f29, f12
	ctx.f[12].f64 = (((ctx.f[3].f64 * ctx.f[29].f64 + ctx.f[12].f64) as f32) as f64);
	// 821925DC: D19E01E4  stfs f12, 0x1e4(r30)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(484 as u32), tmp.u32 ) };
	// 821925E0: ED645F7A  fmadds f11, f4, f29, f11
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[29].f64 + ctx.f[11].f64) as f32) as f64);
	// 821925E4: D17E01E8  stfs f11, 0x1e8(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(488 as u32), tmp.u32 ) };
	// 821925E8: ED5E577A  fmadds f10, f30, f29, f10
	ctx.f[10].f64 = (((ctx.f[30].f64 * ctx.f[29].f64 + ctx.f[10].f64) as f32) as f64);
	// 821925EC: D15E01F0  stfs f10, 0x1f0(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(496 as u32), tmp.u32 ) };
	// 821925F0: ED3F4F7A  fmadds f9, f31, f29, f9
	ctx.f[9].f64 = (((ctx.f[31].f64 * ctx.f[29].f64 + ctx.f[9].f64) as f32) as f64);
	// 821925F4: D13E01F4  stfs f9, 0x1f4(r30)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(500 as u32), tmp.u32 ) };
	// 821925F8: ED01477A  fmadds f8, f1, f29, f8
	ctx.f[8].f64 = (((ctx.f[1].f64 * ctx.f[29].f64 + ctx.f[8].f64) as f32) as f64);
	// 821925FC: D11E01F8  stfs f8, 0x1f8(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(504 as u32), tmp.u32 ) };
	// 82192600: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82192604: 915E0208  stw r10, 0x208(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(520 as u32), ctx.r[10].u32 ) };
	// 82192608: 913E020C  stw r9, 0x20c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(524 as u32), ctx.r[9].u32 ) };
	// 8219260C: 917E0200  stw r11, 0x200(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(512 as u32), ctx.r[11].u32 ) };
	// 82192610: C1BF0030  lfs f13, 0x30(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192614: D1BE0220  stfs f13, 0x220(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(544 as u32), tmp.u32 ) };
	// 82192618: C1BF0034  lfs f13, 0x34(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219261C: D1BE0224  stfs f13, 0x224(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(548 as u32), tmp.u32 ) };
	// 82192620: C1BF0038  lfs f13, 0x38(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(56 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82192624: D1BE0228  stfs f13, 0x228(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(552 as u32), tmp.u32 ) };
	// 82192628: C1BF0044  lfs f13, 0x44(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219262C: D1BE0234  stfs f13, 0x234(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 82192630: D01E0240  stfs f0, 0x240(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(576 as u32), tmp.u32 ) };
	// 82192634: D01E0248  stfs f0, 0x248(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(584 as u32), tmp.u32 ) };
	pc = 0x82192638; continue 'dispatch;
            }
            0x82192638 => {
    //   block [0x82192638..0x82192648)
	// 82192638: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8219263C: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82192640: 483A39F1  bl 0x82536030
	ctx.lr = 0x82192644;
	sub_82535FFC(ctx, base);
	// 82192644: 483A2AC8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82192648(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82192648 size=1368
    let mut pc: u32 = 0x82192648;
    'dispatch: loop {
        match pc {
            0x82192648 => {
    //   block [0x82192648..0x8219268C)
	// 82192648: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219264C: 483A2A6D  bl 0x825350b8
	ctx.lr = 0x82192650;
	sub_82535080(ctx, base);
	// 82192650: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82192654: 483A3971  bl 0x82535fc4
	ctx.lr = 0x82192658;
	sub_82535FB0(ctx, base);
	// 82192658: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219265C: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82192660: C3030014  lfs f24, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82192664: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82192668: FC00C01E  fctiwz f0, f24
	ctx.f[0].s64 = if ctx.f[24].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[24].f64.trunc() as i32 as i64 };
	// 8219266C: 83830020  lwz r28, 0x20(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82192670: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82192674: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82192678: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219267C: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82192680: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82192684: 41980008  blt cr6, 0x8219268c
	if ctx.cr[6].lt {
	pc = 0x8219268C; continue 'dispatch;
	}
	// 82192688: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x8219268C; continue 'dispatch;
            }
            0x8219268C => {
    //   block [0x8219268C..0x82192740)
	// 8219268C: FC00C65E  fctidz f0, f24
	ctx.f[0].s64 = if ctx.f[24].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[24].f64.trunc() as i64 };
	// 82192690: 5548103A  slwi r8, r10, 2
	ctx.r[8].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82192694: 81630184  lwz r11, 0x184(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(388 as u32) ) } as u64;
	// 82192698: 7D4A4214  add r10, r10, r8
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[8].u64;
	// 8219269C: 5528103A  slwi r8, r9, 2
	ctx.r[8].u32 = ctx.r[9].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 821926A0: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821926A4: 7D094214  add r8, r9, r8
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[8].u64;
	// 821926A8: 7D2A5A14  add r9, r10, r11
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821926AC: 550A1838  slwi r10, r8, 3
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821926B0: 7D4A5A14  add r10, r10, r11
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 821926B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821926B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821926BC: C1890044  lfs f12, 0x44(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821926C0: 3BCBBA44  addi r30, r11, -0x45bc
	ctx.r[30].s64 = ctx.r[11].s64 + -17852;
	// 821926C4: C0E9002C  lfs f7, 0x2c(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(44 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821926C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821926CC: C0C90030  lfs f6, 0x30(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(48 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821926D0: C16A0044  lfs f11, 0x44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(68 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821926D4: C0A90034  lfs f5, 0x34(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(52 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821926D8: C08A002C  lfs f4, 0x2c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(44 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 821926DC: C13EFFF4  lfs f9, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821926E0: C06A0030  lfs f3, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821926E4: C04A0034  lfs f2, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821926E8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821926EC: C3C90020  lfs f30, 0x20(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(32 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821926F0: C3A90024  lfs f29, 0x24(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(36 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821926F4: C3890028  lfs f28, 0x28(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(40 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821926F8: C36A0020  lfs f27, 0x20(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(32 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821926FC: C34A0024  lfs f26, 0x24(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(36 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82192700: C32A0028  lfs f25, 0x28(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82192704: EC180028  fsubs f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192708: EDA90028  fsubs f13, f9, f0
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219270C: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192710: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192714: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192718: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219271C: C2CB1FF8  lfs f22, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82192720: EFE96828  fsubs f31, f9, f13
	ctx.f[31].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82192724: FF0CB000  fcmpu cr6, f12, f22
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[22].f64);
	// 82192728: 40980030  bge cr6, 0x82192758
	if !ctx.cr[6].lt {
	pc = 0x82192758; continue 'dispatch;
	}
	// 8219272C: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82192730: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192734: 4098000C  bge cr6, 0x82192740
	if !ctx.cr[6].lt {
	pc = 0x82192740; continue 'dispatch;
	}
	// 82192738: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219273C: 48000034  b 0x82192770
	pc = 0x82192770; continue 'dispatch;
            }
            0x82192740 => {
    //   block [0x82192740..0x82192758)
	// 82192740: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192744: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192748: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219274C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82192750: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192754: 4800001C  b 0x82192770
	pc = 0x82192770; continue 'dispatch;
            }
            0x82192758 => {
    //   block [0x82192758..0x82192770)
	// 82192758: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 8219275C: 41980014  blt cr6, 0x82192770
	if ctx.cr[6].lt {
	pc = 0x82192770; continue 'dispatch;
	}
	// 82192760: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192764: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192768: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219276C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82192770; continue 'dispatch;
            }
            0x82192770 => {
    //   block [0x82192770..0x8219278C)
	// 82192770: FF0CB000  fcmpu cr6, f12, f22
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[22].f64);
	// 82192774: 40980030  bge cr6, 0x821927a4
	if !ctx.cr[6].lt {
	pc = 0x821927A4; continue 'dispatch;
	}
	// 82192778: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219277C: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192780: 4098000C  bge cr6, 0x8219278c
	if !ctx.cr[6].lt {
	pc = 0x8219278C; continue 'dispatch;
	}
	// 82192784: EC296028  fsubs f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192788: 4800003C  b 0x821927c4
	pc = 0x821927C4; continue 'dispatch;
            }
            0x8219278C => {
    //   block [0x8219278C..0x821927A4)
	// 8219278C: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192790: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192794: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82192798: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 8219279C: EC296028  fsubs f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 821927A0: 48000024  b 0x821927c4
	pc = 0x821927C4; continue 'dispatch;
            }
            0x821927A4 => {
    //   block [0x821927A4..0x821927B4)
	// 821927A4: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 821927A8: 4098000C  bge cr6, 0x821927b4
	if !ctx.cr[6].lt {
	pc = 0x821927B4; continue 'dispatch;
	}
	// 821927AC: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 821927B0: 48000014  b 0x821927c4
	pc = 0x821927C4; continue 'dispatch;
            }
            0x821927B4 => {
    //   block [0x821927B4..0x821927C4)
	// 821927B4: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 821927B8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 821927BC: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 821927C0: EC2C5828  fsubs f1, f12, f11
	ctx.f[1].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x821927C4; continue 'dispatch;
            }
            0x821927C4 => {
    //   block [0x821927C4..0x821927E0)
	// 821927C4: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 821927C8: 40980030  bge cr6, 0x821927f8
	if !ctx.cr[6].lt {
	pc = 0x821927F8; continue 'dispatch;
	}
	// 821927CC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821927D0: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 821927D4: 4098000C  bge cr6, 0x821927e0
	if !ctx.cr[6].lt {
	pc = 0x821927E0; continue 'dispatch;
	}
	// 821927D8: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 821927DC: 48000034  b 0x82192810
	pc = 0x82192810; continue 'dispatch;
            }
            0x821927E0 => {
    //   block [0x821927E0..0x821927F8)
	// 821927E0: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821927E4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821927E8: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821927EC: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 821927F0: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 821927F4: 4800001C  b 0x82192810
	pc = 0x82192810; continue 'dispatch;
            }
            0x821927F8 => {
    //   block [0x821927F8..0x82192810)
	// 821927F8: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 821927FC: 41980014  blt cr6, 0x82192810
	if ctx.cr[6].lt {
	pc = 0x82192810; continue 'dispatch;
	}
	// 82192800: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192804: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192808: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219280C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82192810; continue 'dispatch;
            }
            0x82192810 => {
    //   block [0x82192810..0x8219282C)
	// 82192810: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82192814: 40980030  bge cr6, 0x82192844
	if !ctx.cr[6].lt {
	pc = 0x82192844; continue 'dispatch;
	}
	// 82192818: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219281C: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192820: 4098000C  bge cr6, 0x8219282c
	if !ctx.cr[6].lt {
	pc = 0x8219282C; continue 'dispatch;
	}
	// 82192824: EEE90028  fsubs f23, f9, f0
	ctx.f[23].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192828: 4800003C  b 0x82192864
	pc = 0x82192864; continue 'dispatch;
            }
            0x8219282C => {
    //   block [0x8219282C..0x82192844)
	// 8219282C: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192830: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192834: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192838: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219283C: EEE90028  fsubs f23, f9, f0
	ctx.f[23].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192840: 48000024  b 0x82192864
	pc = 0x82192864; continue 'dispatch;
            }
            0x82192844 => {
    //   block [0x82192844..0x82192854)
	// 82192844: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192848: 4098000C  bge cr6, 0x82192854
	if !ctx.cr[6].lt {
	pc = 0x82192854; continue 'dispatch;
	}
	// 8219284C: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82192850: 48000014  b 0x82192864
	pc = 0x82192864; continue 'dispatch;
            }
            0x82192854 => {
    //   block [0x82192854..0x82192864)
	// 82192854: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192858: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219285C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192860: EEE06028  fsubs f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82192864; continue 'dispatch;
            }
            0x82192864 => {
    //   block [0x82192864..0x82192920)
	// 82192864: ED833028  fsubs f12, f3, f6
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[6].f64) as f32) as f64);
	// 82192868: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219286C: ED622828  fsubs f11, f2, f5
	ctx.f[11].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82192870: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82192874: ED1AE828  fsubs f8, f26, f29
	ctx.f[8].f64 = (((ctx.f[26].f64 - ctx.f[29].f64) as f32) as f64);
	// 82192878: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 8219287C: ED443828  fsubs f10, f4, f7
	ctx.f[10].f64 = (((ctx.f[4].f64 - ctx.f[7].f64) as f32) as f64);
	// 82192880: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82192884: EEB9E028  fsubs f21, f25, f28
	ctx.f[21].f64 = (((ctx.f[25].f64 - ctx.f[28].f64) as f32) as f64);
	// 82192888: C0082238  lfs f0, 0x2238(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219288C: EE9BF028  fsubs f20, f27, f30
	ctx.f[20].f64 = (((ctx.f[27].f64 - ctx.f[30].f64) as f32) as f64);
	// 82192890: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192894: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192898: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219289C: EE6C0332  fmuls f19, f12, f12
	ctx.f[19].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821928A0: ED880032  fmuls f12, f8, f0
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 821928A4: ED0B9AFA  fmadds f8, f11, f11, f19
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[19].f64) as f32) as f64);
	// 821928A8: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 821928AC: ED750032  fmuls f11, f21, f0
	ctx.f[11].f64 = (((ctx.f[21].f64 * ctx.f[0].f64) as f32) as f64);
	// 821928B0: ED0A42BA  fmadds f8, f10, f10, f8
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64);
	// 821928B4: ED540032  fmuls f10, f20, f0
	ctx.f[10].f64 = (((ctx.f[20].f64 * ctx.f[0].f64) as f32) as f64);
	// 821928B8: ED8B62FA  fmadds f12, f11, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 821928BC: ED00402C  fsqrts f8, f8
	ctx.f[8].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 821928C0: ED8A62BA  fmadds f12, f10, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 821928C4: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 821928C8: 419A0158  beq cr6, 0x82192a20
	if ctx.cr[6].eq {
	pc = 0x82192A20; continue 'dispatch;
	}
	// 821928CC: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821928D0: 3D000003  lis r8, 3
	ctx.r[8].s64 = 196608;
	// 821928D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821928D8: 610885D8  ori r8, r8, 0x85d8
	ctx.r[8].u64 = ctx.r[8].u64 | 34264;
	// 821928DC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821928E0: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821928E4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821928E8: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 821928EC: 7D6B442E  lfsx f11, r11, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821928F0: 419800A0  blt cr6, 0x82192990
	if ctx.cr[6].lt {
	pc = 0x82192990; continue 'dispatch;
	}
	// 821928F4: ED58582A  fadds f10, f24, f11
	ctx.f[10].f64 = ((ctx.f[24].f64 + ctx.f[11].f64) as f32) as f64;
	// 821928F8: 3904FFFC  addi r8, r4, -4
	ctx.r[8].s64 = ctx.r[4].s64 + -4;
	// 821928FC: 38E10050  addi r7, r1, 0x50
	ctx.r[7].s64 = ctx.r[1].s64 + 80;
	// 82192900: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82192904: 5508F0BE  srwi r8, r8, 2
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82192908: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219290C: 38A80001  addi r5, r8, 1
	ctx.r[5].s64 = ctx.r[8].s64 + 1;
	// 82192910: 54A6103A  slwi r6, r5, 2
	ctx.r[6].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 82192914: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82192918: 7D403FAE  stfiwx f10, 0, r7
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 8219291C: 80E10050  lwz r7, 0x50(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82192920; continue 'dispatch;
            }
            0x82192920 => {
    //   block [0x82192920..0x82192938)
	// 82192920: A10BFFFC  lhz r8, -4(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82192924: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82192928: 409A0010  bne cr6, 0x82192938
	if !ctx.cr[6].eq {
	pc = 0x82192938; continue 'dispatch;
	}
	// 8219292C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82192930: 419A0008  beq cr6, 0x82192938
	if ctx.cr[6].eq {
	pc = 0x82192938; continue 'dispatch;
	}
	// 82192934: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192938; continue 'dispatch;
            }
            0x82192938 => {
    //   block [0x82192938..0x82192950)
	// 82192938: A10BFFFE  lhz r8, -2(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 8219293C: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82192940: 409A0010  bne cr6, 0x82192950
	if !ctx.cr[6].eq {
	pc = 0x82192950; continue 'dispatch;
	}
	// 82192944: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82192948: 419A0008  beq cr6, 0x82192950
	if ctx.cr[6].eq {
	pc = 0x82192950; continue 'dispatch;
	}
	// 8219294C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192950; continue 'dispatch;
            }
            0x82192950 => {
    //   block [0x82192950..0x82192968)
	// 82192950: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192954: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82192958: 409A0010  bne cr6, 0x82192968
	if !ctx.cr[6].eq {
	pc = 0x82192968; continue 'dispatch;
	}
	// 8219295C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82192960: 419A0008  beq cr6, 0x82192968
	if ctx.cr[6].eq {
	pc = 0x82192968; continue 'dispatch;
	}
	// 82192964: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192968; continue 'dispatch;
            }
            0x82192968 => {
    //   block [0x82192968..0x82192980)
	// 82192968: A10B0002  lhz r8, 2(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219296C: 7F083800  cmpw cr6, r8, r7
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[7].s32, &mut ctx.xer);
	// 82192970: 409A0010  bne cr6, 0x82192980
	if !ctx.cr[6].eq {
	pc = 0x82192980; continue 'dispatch;
	}
	// 82192974: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 82192978: 419A0008  beq cr6, 0x82192980
	if ctx.cr[6].eq {
	pc = 0x82192980; continue 'dispatch;
	}
	// 8219297C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192980; continue 'dispatch;
            }
            0x82192980 => {
    //   block [0x82192980..0x82192990)
	// 82192980: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82192984: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82192988: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219298C: 409AFF94  bne cr6, 0x82192920
	if !ctx.cr[6].eq {
	pc = 0x82192920; continue 'dispatch;
	}
	pc = 0x82192990; continue 'dispatch;
            }
            0x82192990 => {
    //   block [0x82192990..0x821929BC)
	// 82192990: 7F062000  cmpw cr6, r6, r4
	ctx.cr[6].compare_i32(ctx.r[6].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82192994: 40980050  bge cr6, 0x821929e4
	if !ctx.cr[6].lt {
	pc = 0x821929E4; continue 'dispatch;
	}
	// 82192998: ED78582A  fadds f11, f24, f11
	ctx.f[11].f64 = ((ctx.f[24].f64 + ctx.f[11].f64) as f32) as f64;
	// 8219299C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821929A0: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821929A4: 54CB083C  slwi r11, r6, 1
	ctx.r[11].u32 = ctx.r[6].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821929A8: 7CE62050  subf r7, r6, r4
	ctx.r[7].s64 = ctx.r[4].s64 - ctx.r[6].s64;
	// 821929AC: 7D6B4214  add r11, r11, r8
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[8].u64;
	// 821929B0: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 821929B4: 7D602FAE  stfiwx f11, 0, r5
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 821929B8: 80C10050  lwz r6, 0x50(r1)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x821929BC; continue 'dispatch;
            }
            0x821929BC => {
    //   block [0x821929BC..0x821929D4)
	// 821929BC: A10B0000  lhz r8, 0(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821929C0: 7F083000  cmpw cr6, r8, r6
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[6].s32, &mut ctx.xer);
	// 821929C4: 409A0010  bne cr6, 0x821929d4
	if !ctx.cr[6].eq {
	pc = 0x821929D4; continue 'dispatch;
	}
	// 821929C8: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821929CC: 419A0008  beq cr6, 0x821929d4
	if ctx.cr[6].eq {
	pc = 0x821929D4; continue 'dispatch;
	}
	// 821929D0: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x821929D4; continue 'dispatch;
            }
            0x821929D4 => {
    //   block [0x821929D4..0x821929E4)
	// 821929D4: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 821929D8: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 821929DC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 821929E0: 409AFFDC  bne cr6, 0x821929bc
	if !ctx.cr[6].eq {
	pc = 0x821929BC; continue 'dispatch;
	}
	pc = 0x821929E4; continue 'dispatch;
            }
            0x821929E4 => {
    //   block [0x821929E4..0x82192A04)
	// 821929E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821929E8: C16B25C4  lfs f11, 0x25c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9668 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821929EC: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 821929F0: 41990014  bgt cr6, 0x82192a04
	if ctx.cr[6].gt {
	pc = 0x82192A04; continue 'dispatch;
	}
	// 821929F4: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 821929F8: 4199000C  bgt cr6, 0x82192a04
	if ctx.cr[6].gt {
	pc = 0x82192A04; continue 'dispatch;
	}
	// 821929FC: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82192A00: 419A0020  beq cr6, 0x82192a20
	if ctx.cr[6].eq {
	pc = 0x82192A20; continue 'dispatch;
	}
	pc = 0x82192A04; continue 'dispatch;
            }
            0x82192A04 => {
    //   block [0x82192A04..0x82192A18)
	// 82192A04: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82192A08: 40980010  bge cr6, 0x82192a18
	if !ctx.cr[6].lt {
	pc = 0x82192A18; continue 'dispatch;
	}
	// 82192A0C: FDA0B090  fmr f13, f22
	ctx.f[13].f64 = ctx.f[22].f64;
	// 82192A10: FFE04890  fmr f31, f9
	ctx.f[31].f64 = ctx.f[9].f64;
	// 82192A14: 4800000C  b 0x82192a20
	pc = 0x82192A20; continue 'dispatch;
            }
            0x82192A18 => {
    //   block [0x82192A18..0x82192A20)
	// 82192A18: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	// 82192A1C: FFE0B090  fmr f31, f22
	ctx.f[31].f64 = ctx.f[22].f64;
	pc = 0x82192A20; continue 'dispatch;
            }
            0x82192A20 => {
    //   block [0x82192A20..0x82192AB4)
	// 82192A20: ED870372  fmuls f12, f7, f13
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A24: 3BFC01E0  addi r31, r28, 0x1e0
	ctx.r[31].s64 = ctx.r[28].s64 + 480;
	// 82192A28: ED660372  fmuls f11, f6, f13
	ctx.f[11].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A2C: ED450372  fmuls f10, f5, f13
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A30: ED1E0372  fmuls f8, f30, f13
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A34: ECFD0372  fmuls f7, f29, f13
	ctx.f[7].f64 = (((ctx.f[29].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A38: ECDC0372  fmuls f6, f28, f13
	ctx.f[6].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A3C: ED8467FA  fmadds f12, f4, f31, f12
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192A40: ED635FFA  fmadds f11, f3, f31, f11
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82192A44: ED4257FA  fmadds f10, f2, f31, f10
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82192A48: ED1B47FA  fmadds f8, f27, f31, f8
	ctx.f[8].f64 = (((ctx.f[27].f64 * ctx.f[31].f64 + ctx.f[8].f64) as f32) as f64);
	// 82192A4C: ECFA3FFA  fmadds f7, f26, f31, f7
	ctx.f[7].f64 = (((ctx.f[26].f64 * ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64);
	// 82192A50: ECD937FA  fmadds f6, f25, f31, f6
	ctx.f[6].f64 = (((ctx.f[25].f64 * ctx.f[31].f64 + ctx.f[6].f64) as f32) as f64);
	// 82192A54: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A58: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82192A5C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A60: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82192A64: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A68: D15F0008  stfs f10, 8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82192A6C: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A70: D11F0010  stfs f8, 0x10(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82192A74: ECE70032  fmuls f7, f7, f0
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A78: D0FF0014  stfs f7, 0x14(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82192A7C: EC060032  fmuls f0, f6, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192A80: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82192A84: C0090038  lfs f0, 0x38(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192A88: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192A8C: C18A0038  lfs f12, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192A90: EC0C07FA  fmadds f0, f12, f31, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82192A94: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192A98: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82192A9C: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82192AA0: 40980014  bge cr6, 0x82192ab4
	if !ctx.cr[6].lt {
	pc = 0x82192AB4; continue 'dispatch;
	}
	// 82192AA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192AA8: C18B2BF0  lfs f12, 0x2bf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192AAC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82192AB0: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x82192AB4; continue 'dispatch;
            }
            0x82192AB4 => {
    //   block [0x82192AB4..0x82192B80)
	// 82192AB4: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82192AB8: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 82192ABC: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82192AC0: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82192AC4: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82192AC8: C0030030  lfs f0, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192ACC: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82192AD0: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192AD4: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82192AD8: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192ADC: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82192AE0: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192AE4: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82192AE8: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192AEC: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82192AF0: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192AF4: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82192AF8: 40980088  bge cr6, 0x82192b80
	if !ctx.cr[6].lt {
	pc = 0x82192B80; continue 'dispatch;
	}
	// 82192AFC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82192B00: FC60B090  fmr f3, f22
	ctx.f[3].f64 = ctx.f[22].f64;
	// 82192B04: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82192B08: 481D5711  bl 0x82368218
	ctx.lr = 0x82192B0C;
	sub_82368218(ctx, base);
	// 82192B0C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82192B10: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82192B14: 481E188D  bl 0x823743a0
	ctx.lr = 0x82192B18;
	sub_823743A0(ctx, base);
	// 82192B18: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82192B1C: FC60B090  fmr f3, f22
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[22].f64;
	// 82192B20: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82192B24: FC20B890  fmr f1, f23
	ctx.f[1].f64 = ctx.f[23].f64;
	// 82192B28: 481D56F1  bl 0x82368218
	ctx.lr = 0x82192B2C;
	sub_82368218(ctx, base);
	// 82192B2C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82192B30: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82192B34: 481E186D  bl 0x823743a0
	ctx.lr = 0x82192B38;
	sub_823743A0(ctx, base);
	// 82192B38: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 82192B3C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82192B40: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82192B44: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82192B48: 481E1C59  bl 0x823747a0
	ctx.lr = 0x82192B4C;
	sub_823747A0(ctx, base);
	// 82192B4C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 82192B50: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82192B54: 481D59E5  bl 0x82368538
	ctx.lr = 0x82192B58;
	sub_82368538(ctx, base);
	// 82192B58: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 82192B5C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82192B60: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 82192B64: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82192B68: 481D5AA9  bl 0x82368610
	ctx.lr = 0x82192B6C;
	sub_82368610(ctx, base);
	// 82192B6C: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82192B70: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82192B74: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82192B78: 483A3499  bl 0x82536010
	ctx.lr = 0x82192B7C;
	sub_82535FFC(ctx, base);
	// 82192B7C: 483A258C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x82192B80 => {
    //   block [0x82192B80..0x82192BA0)
	// 82192B80: EC010372  fmuls f0, f1, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192B84: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 82192B88: EC1707FA  fmadds f0, f23, f31, f0
	ctx.f[0].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82192B8C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82192B90: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 82192B94: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82192B98: 483A3479  bl 0x82536010
	ctx.lr = 0x82192B9C;
	sub_82535FFC(ctx, base);
	// 82192B9C: 483A256C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82192BA0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82192BA0 size=1360
    let mut pc: u32 = 0x82192BA0;
    'dispatch: loop {
        match pc {
            0x82192BA0 => {
    //   block [0x82192BA0..0x82192BE4)
	// 82192BA0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82192BA4: 483A2515  bl 0x825350b8
	ctx.lr = 0x82192BA8;
	sub_82535080(ctx, base);
	// 82192BA8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82192BAC: 483A3419  bl 0x82535fc4
	ctx.lr = 0x82192BB0;
	sub_82535FB0(ctx, base);
	// 82192BB0: 9421FEA0  stwu r1, -0x160(r1)
	ea = ctx.r[1].u32.wrapping_add(-352 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82192BB4: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 82192BB8: C3030014  lfs f24, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	// 82192BBC: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82192BC0: FC00C01E  fctiwz f0, f24
	ctx.f[0].s64 = if ctx.f[24].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[24].f64.trunc() as i32 as i64 };
	// 82192BC4: 83830020  lwz r28, 0x20(r3)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 82192BC8: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 82192BCC: 7C0057AE  stfiwx f0, 0, r10
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32, tmp.u32) };
	// 82192BD0: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82192BD4: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 82192BD8: 7F0A5800  cmpw cr6, r10, r11
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[11].s32, &mut ctx.xer);
	// 82192BDC: 41980008  blt cr6, 0x82192be4
	if ctx.cr[6].lt {
	pc = 0x82192BE4; continue 'dispatch;
	}
	// 82192BE0: 7D495378  mr r9, r10
	ctx.r[9].u64 = ctx.r[10].u64;
	pc = 0x82192BE4; continue 'dispatch;
            }
            0x82192BE4 => {
    //   block [0x82192BE4..0x82192C90)
	// 82192BE4: FC00C65E  fctidz f0, f24
	ctx.f[0].s64 = if ctx.f[24].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[24].f64.trunc() as i64 };
	// 82192BE8: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 82192BEC: 39090001  addi r8, r9, 1
	ctx.r[8].s64 = ctx.r[9].s64 + 1;
	// 82192BF0: 81630188  lwz r11, 0x188(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(392 as u32) ) } as u64;
	// 82192BF4: 55492834  slwi r9, r10, 5
	ctx.r[9].u32 = ctx.r[10].u32.wrapping_shl(5);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 82192BF8: 550A2834  slwi r10, r8, 5
	ctx.r[10].u32 = ctx.r[8].u32.wrapping_shl(5);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82192BFC: 7CE95A14  add r7, r9, r11
	ctx.r[7].u64 = ctx.r[9].u64 + ctx.r[11].u64;
	// 82192C00: 7CCA5A14  add r6, r10, r11
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 82192C04: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82192C08: 3BCBBA44  addi r30, r11, -0x45bc
	ctx.r[30].s64 = ctx.r[11].s64 + -17852;
	// 82192C0C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192C10: C187001C  lfs f12, 0x1c(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192C14: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82192C18: C166001C  lfs f11, 0x1c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(28 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82192C1C: C0E7000C  lfs f7, 0xc(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(12 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82192C20: C0C70010  lfs f6, 0x10(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(16 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82192C24: C13EFFF4  lfs f9, -0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-12 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82192C28: C0A70014  lfs f5, 0x14(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(20 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82192C2C: C086000C  lfs f4, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82192C30: C0660010  lfs f3, 0x10(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(16 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82192C34: C0460014  lfs f2, 0x14(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82192C38: C3C70000  lfs f30, 0(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82192C3C: C3A70004  lfs f29, 4(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82192C40: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82192C44: C3870008  lfs f28, 8(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82192C48: C3660000  lfs f27, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82192C4C: C3460004  lfs f26, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82192C50: C3260008  lfs f25, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82192C54: EC180028  fsubs f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192C58: EDA90028  fsubs f13, f9, f0
	ctx.f[13].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192C5C: C00B2200  lfs f0, 0x2200(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8704 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192C60: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192C64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192C68: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192C6C: C2CB1FF8  lfs f22, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82192C70: EFE96828  fsubs f31, f9, f13
	ctx.f[31].f64 = (((ctx.f[9].f64 - ctx.f[13].f64) as f32) as f64);
	// 82192C74: FF0CB000  fcmpu cr6, f12, f22
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[22].f64);
	// 82192C78: 40980030  bge cr6, 0x82192ca8
	if !ctx.cr[6].lt {
	pc = 0x82192CA8; continue 'dispatch;
	}
	// 82192C7C: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82192C80: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192C84: 4098000C  bge cr6, 0x82192c90
	if !ctx.cr[6].lt {
	pc = 0x82192C90; continue 'dispatch;
	}
	// 82192C88: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192C8C: 48000034  b 0x82192cc0
	pc = 0x82192CC0; continue 'dispatch;
            }
            0x82192C90 => {
    //   block [0x82192C90..0x82192CA8)
	// 82192C90: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192C94: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192C98: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82192C9C: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82192CA0: ED896028  fsubs f12, f9, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192CA4: 4800001C  b 0x82192cc0
	pc = 0x82192CC0; continue 'dispatch;
            }
            0x82192CA8 => {
    //   block [0x82192CA8..0x82192CC0)
	// 82192CA8: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192CAC: 41980014  blt cr6, 0x82192cc0
	if ctx.cr[6].lt {
	pc = 0x82192CC0; continue 'dispatch;
	}
	// 82192CB0: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192CB4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192CB8: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82192CBC: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82192CC0; continue 'dispatch;
            }
            0x82192CC0 => {
    //   block [0x82192CC0..0x82192CDC)
	// 82192CC0: FF0CB000  fcmpu cr6, f12, f22
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[22].f64);
	// 82192CC4: 40980030  bge cr6, 0x82192cf4
	if !ctx.cr[6].lt {
	pc = 0x82192CF4; continue 'dispatch;
	}
	// 82192CC8: FD806050  fneg f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82192CCC: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192CD0: 4098000C  bge cr6, 0x82192cdc
	if !ctx.cr[6].lt {
	pc = 0x82192CDC; continue 'dispatch;
	}
	// 82192CD4: EC296028  fsubs f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192CD8: 4800003C  b 0x82192d14
	pc = 0x82192D14; continue 'dispatch;
            }
            0x82192CDC => {
    //   block [0x82192CDC..0x82192CF4)
	// 82192CDC: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192CE0: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192CE4: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82192CE8: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82192CEC: EC296028  fsubs f1, f9, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192CF0: 48000024  b 0x82192d14
	pc = 0x82192D14; continue 'dispatch;
            }
            0x82192CF4 => {
    //   block [0x82192CF4..0x82192D04)
	// 82192CF4: FF0C4800  fcmpu cr6, f12, f9
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[9].f64);
	// 82192CF8: 4098000C  bge cr6, 0x82192d04
	if !ctx.cr[6].lt {
	pc = 0x82192D04; continue 'dispatch;
	}
	// 82192CFC: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 82192D00: 48000014  b 0x82192d14
	pc = 0x82192D14; continue 'dispatch;
            }
            0x82192D04 => {
    //   block [0x82192D04..0x82192D14)
	// 82192D04: FD60665E  fctidz f11, f12
	ctx.f[11].s64 = if ctx.f[12].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[12].f64.trunc() as i64 };
	// 82192D08: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82192D0C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82192D10: EC2C5828  fsubs f1, f12, f11
	ctx.f[1].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	pc = 0x82192D14; continue 'dispatch;
            }
            0x82192D14 => {
    //   block [0x82192D14..0x82192D30)
	// 82192D14: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82192D18: 40980030  bge cr6, 0x82192d48
	if !ctx.cr[6].lt {
	pc = 0x82192D48; continue 'dispatch;
	}
	// 82192D1C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82192D20: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192D24: 4098000C  bge cr6, 0x82192d30
	if !ctx.cr[6].lt {
	pc = 0x82192D30; continue 'dispatch;
	}
	// 82192D28: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192D2C: 48000034  b 0x82192d60
	pc = 0x82192D60; continue 'dispatch;
            }
            0x82192D30 => {
    //   block [0x82192D30..0x82192D48)
	// 82192D30: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192D34: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192D38: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192D3C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192D40: EC090028  fsubs f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192D44: 4800001C  b 0x82192d60
	pc = 0x82192D60; continue 'dispatch;
            }
            0x82192D48 => {
    //   block [0x82192D48..0x82192D60)
	// 82192D48: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192D4C: 41980014  blt cr6, 0x82192d60
	if ctx.cr[6].lt {
	pc = 0x82192D60; continue 'dispatch;
	}
	// 82192D50: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192D54: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192D58: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192D5C: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82192D60; continue 'dispatch;
            }
            0x82192D60 => {
    //   block [0x82192D60..0x82192D7C)
	// 82192D60: FF00B000  fcmpu cr6, f0, f22
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[22].f64);
	// 82192D64: 40980030  bge cr6, 0x82192d94
	if !ctx.cr[6].lt {
	pc = 0x82192D94; continue 'dispatch;
	}
	// 82192D68: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82192D6C: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192D70: 4098000C  bge cr6, 0x82192d7c
	if !ctx.cr[6].lt {
	pc = 0x82192D7C; continue 'dispatch;
	}
	// 82192D74: EEE90028  fsubs f23, f9, f0
	ctx.f[23].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192D78: 4800003C  b 0x82192db4
	pc = 0x82192DB4; continue 'dispatch;
            }
            0x82192D7C => {
    //   block [0x82192D7C..0x82192D94)
	// 82192D7C: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192D80: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192D84: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192D88: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 82192D8C: EEE90028  fsubs f23, f9, f0
	ctx.f[23].f64 = (((ctx.f[9].f64 - ctx.f[0].f64) as f32) as f64);
	// 82192D90: 48000024  b 0x82192db4
	pc = 0x82192DB4; continue 'dispatch;
            }
            0x82192D94 => {
    //   block [0x82192D94..0x82192DA4)
	// 82192D94: FF004800  fcmpu cr6, f0, f9
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[9].f64);
	// 82192D98: 4098000C  bge cr6, 0x82192da4
	if !ctx.cr[6].lt {
	pc = 0x82192DA4; continue 'dispatch;
	}
	// 82192D9C: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82192DA0: 48000014  b 0x82192db4
	pc = 0x82192DB4; continue 'dispatch;
            }
            0x82192DA4 => {
    //   block [0x82192DA4..0x82192DB4)
	// 82192DA4: FD80065E  fctidz f12, f0
	ctx.f[12].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82192DA8: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 82192DAC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 82192DB0: EEE06028  fsubs f23, f0, f12
	ctx.f[23].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	pc = 0x82192DB4; continue 'dispatch;
            }
            0x82192DB4 => {
    //   block [0x82192DB4..0x82192E70)
	// 82192DB4: ED833028  fsubs f12, f3, f6
	ctx.f[12].f64 = (((ctx.f[3].f64 - ctx.f[6].f64) as f32) as f64);
	// 82192DB8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82192DBC: ED622828  fsubs f11, f2, f5
	ctx.f[11].f64 = (((ctx.f[2].f64 - ctx.f[5].f64) as f32) as f64);
	// 82192DC0: 8163007C  lwz r11, 0x7c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(124 as u32) ) } as u64;
	// 82192DC4: ED1AE828  fsubs f8, f26, f29
	ctx.f[8].f64 = (((ctx.f[26].f64 - ctx.f[29].f64) as f32) as f64);
	// 82192DC8: 3BA00001  li r29, 1
	ctx.r[29].s64 = 1;
	// 82192DCC: ED443828  fsubs f10, f4, f7
	ctx.f[10].f64 = (((ctx.f[4].f64 - ctx.f[7].f64) as f32) as f64);
	// 82192DD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82192DD4: EEB9E028  fsubs f21, f25, f28
	ctx.f[21].f64 = (((ctx.f[25].f64 - ctx.f[28].f64) as f32) as f64);
	// 82192DD8: C00A2238  lfs f0, 0x2238(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192DDC: EE9BF028  fsubs f20, f27, f30
	ctx.f[20].f64 = (((ctx.f[27].f64 - ctx.f[30].f64) as f32) as f64);
	// 82192DE0: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192DE4: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192DE8: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192DEC: EE6C0332  fmuls f19, f12, f12
	ctx.f[19].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82192DF0: ED880032  fmuls f12, f8, f0
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192DF4: ED0B9AFA  fmadds f8, f11, f11, f19
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[19].f64) as f32) as f64);
	// 82192DF8: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82192DFC: ED750032  fmuls f11, f21, f0
	ctx.f[11].f64 = (((ctx.f[21].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192E00: ED0A42BA  fmadds f8, f10, f10, f8
	ctx.f[8].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[8].f64) as f32) as f64);
	// 82192E04: ED540032  fmuls f10, f20, f0
	ctx.f[10].f64 = (((ctx.f[20].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192E08: ED8B62FA  fmadds f12, f11, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192E0C: ED00402C  fsqrts f8, f8
	ctx.f[8].f64 = ((ctx.f[8].f64).sqrt() as f32) as f64;
	// 82192E10: ED8A62BA  fmadds f12, f10, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192E14: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 82192E18: 419A0158  beq cr6, 0x82192f70
	if ctx.cr[6].eq {
	pc = 0x82192F70; continue 'dispatch;
	}
	// 82192E1C: A08B0000  lhz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192E20: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82192E24: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82192E28: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 82192E2C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82192E30: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 82192E34: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82192E38: 2F040004  cmpwi cr6, r4, 4
	ctx.cr[6].compare_i32(ctx.r[4].s32, 4, &mut ctx.xer);
	// 82192E3C: 7D6B542E  lfsx f11, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82192E40: 419800A0  blt cr6, 0x82192ee0
	if ctx.cr[6].lt {
	pc = 0x82192EE0; continue 'dispatch;
	}
	// 82192E44: ED58582A  fadds f10, f24, f11
	ctx.f[10].f64 = ((ctx.f[24].f64 + ctx.f[11].f64) as f32) as f64;
	// 82192E48: 3944FFFC  addi r10, r4, -4
	ctx.r[10].s64 = ctx.r[4].s64 + -4;
	// 82192E4C: 39210050  addi r9, r1, 0x50
	ctx.r[9].s64 = ctx.r[1].s64 + 80;
	// 82192E50: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82192E54: 554AF0BE  srwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 82192E58: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 82192E5C: 38AA0001  addi r5, r10, 1
	ctx.r[5].s64 = ctx.r[10].s64 + 1;
	// 82192E60: 54A8103A  slwi r8, r5, 2
	ctx.r[8].u32 = ctx.r[5].u32.wrapping_shl(2);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 82192E64: FD40501E  fctiwz f10, f10
	ctx.f[10].s64 = if ctx.f[10].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[10].f64.trunc() as i32 as i64 };
	// 82192E68: 7D404FAE  stfiwx f10, 0, r9
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32, tmp.u32) };
	// 82192E6C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82192E70; continue 'dispatch;
            }
            0x82192E70 => {
    //   block [0x82192E70..0x82192E88)
	// 82192E70: A14BFFFC  lhz r10, -4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) } as u64;
	// 82192E74: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82192E78: 409A0010  bne cr6, 0x82192e88
	if !ctx.cr[6].eq {
	pc = 0x82192E88; continue 'dispatch;
	}
	// 82192E7C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82192E80: 419A0008  beq cr6, 0x82192e88
	if ctx.cr[6].eq {
	pc = 0x82192E88; continue 'dispatch;
	}
	// 82192E84: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192E88; continue 'dispatch;
            }
            0x82192E88 => {
    //   block [0x82192E88..0x82192EA0)
	// 82192E88: A14BFFFE  lhz r10, -2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(-2 as u32) ) } as u64;
	// 82192E8C: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82192E90: 409A0010  bne cr6, 0x82192ea0
	if !ctx.cr[6].eq {
	pc = 0x82192EA0; continue 'dispatch;
	}
	// 82192E94: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82192E98: 419A0008  beq cr6, 0x82192ea0
	if ctx.cr[6].eq {
	pc = 0x82192EA0; continue 'dispatch;
	}
	// 82192E9C: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192EA0; continue 'dispatch;
            }
            0x82192EA0 => {
    //   block [0x82192EA0..0x82192EB8)
	// 82192EA0: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192EA4: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82192EA8: 409A0010  bne cr6, 0x82192eb8
	if !ctx.cr[6].eq {
	pc = 0x82192EB8; continue 'dispatch;
	}
	// 82192EAC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82192EB0: 419A0008  beq cr6, 0x82192eb8
	if ctx.cr[6].eq {
	pc = 0x82192EB8; continue 'dispatch;
	}
	// 82192EB4: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192EB8; continue 'dispatch;
            }
            0x82192EB8 => {
    //   block [0x82192EB8..0x82192ED0)
	// 82192EB8: A14B0002  lhz r10, 2(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 82192EBC: 7F0A4800  cmpw cr6, r10, r9
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[9].s32, &mut ctx.xer);
	// 82192EC0: 409A0010  bne cr6, 0x82192ed0
	if !ctx.cr[6].eq {
	pc = 0x82192ED0; continue 'dispatch;
	}
	// 82192EC4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82192EC8: 419A0008  beq cr6, 0x82192ed0
	if ctx.cr[6].eq {
	pc = 0x82192ED0; continue 'dispatch;
	}
	// 82192ECC: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192ED0; continue 'dispatch;
            }
            0x82192ED0 => {
    //   block [0x82192ED0..0x82192EE0)
	// 82192ED0: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 82192ED4: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 82192ED8: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82192EDC: 409AFF94  bne cr6, 0x82192e70
	if !ctx.cr[6].eq {
	pc = 0x82192E70; continue 'dispatch;
	}
	pc = 0x82192EE0; continue 'dispatch;
            }
            0x82192EE0 => {
    //   block [0x82192EE0..0x82192F0C)
	// 82192EE0: 7F082000  cmpw cr6, r8, r4
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[4].s32, &mut ctx.xer);
	// 82192EE4: 40980050  bge cr6, 0x82192f34
	if !ctx.cr[6].lt {
	pc = 0x82192F34; continue 'dispatch;
	}
	// 82192EE8: ED78582A  fadds f11, f24, f11
	ctx.f[11].f64 = ((ctx.f[24].f64 + ctx.f[11].f64) as f32) as f64;
	// 82192EEC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82192EF0: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82192EF4: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82192EF8: 7D282050  subf r9, r8, r4
	ctx.r[9].s64 = ctx.r[4].s64 - ctx.r[8].s64;
	// 82192EFC: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 82192F00: FD60581E  fctiwz f11, f11
	ctx.f[11].s64 = if ctx.f[11].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[11].f64.trunc() as i32 as i64 };
	// 82192F04: 7D602FAE  stfiwx f11, 0, r5
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 82192F08: 81010050  lwz r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	pc = 0x82192F0C; continue 'dispatch;
            }
            0x82192F0C => {
    //   block [0x82192F0C..0x82192F24)
	// 82192F0C: A14B0000  lhz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82192F10: 7F0A4000  cmpw cr6, r10, r8
	ctx.cr[6].compare_i32(ctx.r[10].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82192F14: 409A0010  bne cr6, 0x82192f24
	if !ctx.cr[6].eq {
	pc = 0x82192F24; continue 'dispatch;
	}
	// 82192F18: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82192F1C: 419A0008  beq cr6, 0x82192f24
	if ctx.cr[6].eq {
	pc = 0x82192F24; continue 'dispatch;
	}
	// 82192F20: 7FBFEB78  mr r31, r29
	ctx.r[31].u64 = ctx.r[29].u64;
	pc = 0x82192F24; continue 'dispatch;
            }
            0x82192F24 => {
    //   block [0x82192F24..0x82192F34)
	// 82192F24: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 82192F28: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 82192F2C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 82192F30: 409AFFDC  bne cr6, 0x82192f0c
	if !ctx.cr[6].eq {
	pc = 0x82192F0C; continue 'dispatch;
	}
	pc = 0x82192F34; continue 'dispatch;
            }
            0x82192F34 => {
    //   block [0x82192F34..0x82192F54)
	// 82192F34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192F38: C16B25C4  lfs f11, 0x25c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9668 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82192F3C: FF085800  fcmpu cr6, f8, f11
	ctx.cr[6].compare_f64(ctx.f[8].f64, ctx.f[11].f64);
	// 82192F40: 41990014  bgt cr6, 0x82192f54
	if ctx.cr[6].gt {
	pc = 0x82192F54; continue 'dispatch;
	}
	// 82192F44: FF0C5800  fcmpu cr6, f12, f11
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[11].f64);
	// 82192F48: 4199000C  bgt cr6, 0x82192f54
	if ctx.cr[6].gt {
	pc = 0x82192F54; continue 'dispatch;
	}
	// 82192F4C: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 82192F50: 419A0020  beq cr6, 0x82192f70
	if ctx.cr[6].eq {
	pc = 0x82192F70; continue 'dispatch;
	}
	pc = 0x82192F54; continue 'dispatch;
            }
            0x82192F54 => {
    //   block [0x82192F54..0x82192F68)
	// 82192F54: FF0DF800  fcmpu cr6, f13, f31
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[31].f64);
	// 82192F58: 40980010  bge cr6, 0x82192f68
	if !ctx.cr[6].lt {
	pc = 0x82192F68; continue 'dispatch;
	}
	// 82192F5C: FDA0B090  fmr f13, f22
	ctx.f[13].f64 = ctx.f[22].f64;
	// 82192F60: FFE04890  fmr f31, f9
	ctx.f[31].f64 = ctx.f[9].f64;
	// 82192F64: 4800000C  b 0x82192f70
	pc = 0x82192F70; continue 'dispatch;
            }
            0x82192F68 => {
    //   block [0x82192F68..0x82192F70)
	// 82192F68: FDA04890  fmr f13, f9
	ctx.f[13].f64 = ctx.f[9].f64;
	// 82192F6C: FFE0B090  fmr f31, f22
	ctx.f[31].f64 = ctx.f[22].f64;
	pc = 0x82192F70; continue 'dispatch;
            }
            0x82192F70 => {
    //   block [0x82192F70..0x82193004)
	// 82192F70: ED870372  fmuls f12, f7, f13
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F74: 3BFC01E0  addi r31, r28, 0x1e0
	ctx.r[31].s64 = ctx.r[28].s64 + 480;
	// 82192F78: ED660372  fmuls f11, f6, f13
	ctx.f[11].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F7C: ED450372  fmuls f10, f5, f13
	ctx.f[10].f64 = (((ctx.f[5].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F80: ED1E0372  fmuls f8, f30, f13
	ctx.f[8].f64 = (((ctx.f[30].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F84: ECFD0372  fmuls f7, f29, f13
	ctx.f[7].f64 = (((ctx.f[29].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F88: ECDC0372  fmuls f6, f28, f13
	ctx.f[6].f64 = (((ctx.f[28].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192F8C: ED8467FA  fmadds f12, f4, f31, f12
	ctx.f[12].f64 = (((ctx.f[4].f64 * ctx.f[31].f64 + ctx.f[12].f64) as f32) as f64);
	// 82192F90: ED635FFA  fmadds f11, f3, f31, f11
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[31].f64 + ctx.f[11].f64) as f32) as f64);
	// 82192F94: ED4257FA  fmadds f10, f2, f31, f10
	ctx.f[10].f64 = (((ctx.f[2].f64 * ctx.f[31].f64 + ctx.f[10].f64) as f32) as f64);
	// 82192F98: ED1B47FA  fmadds f8, f27, f31, f8
	ctx.f[8].f64 = (((ctx.f[27].f64 * ctx.f[31].f64 + ctx.f[8].f64) as f32) as f64);
	// 82192F9C: ECFA3FFA  fmadds f7, f26, f31, f7
	ctx.f[7].f64 = (((ctx.f[26].f64 * ctx.f[31].f64 + ctx.f[7].f64) as f32) as f64);
	// 82192FA0: ECD937FA  fmadds f6, f25, f31, f6
	ctx.f[6].f64 = (((ctx.f[25].f64 * ctx.f[31].f64 + ctx.f[6].f64) as f32) as f64);
	// 82192FA4: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FA8: D19F0000  stfs f12, 0(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82192FAC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FB0: D17F0004  stfs f11, 4(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82192FB4: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FB8: D15F0008  stfs f10, 8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82192FBC: ED080032  fmuls f8, f8, f0
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FC0: D11F0010  stfs f8, 0x10(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82192FC4: ECE70032  fmuls f7, f7, f0
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FC8: D0FF0014  stfs f7, 0x14(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82192FCC: EC060032  fmuls f0, f6, f0
	ctx.f[0].f64 = (((ctx.f[6].f64 * ctx.f[0].f64) as f32) as f64);
	// 82192FD0: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82192FD4: C0070018  lfs f0, 0x18(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(24 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82192FD8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82192FDC: C1860018  lfs f12, 0x18(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192FE0: EC0C07FA  fmadds f0, f12, f31, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 82192FE4: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192FE8: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82192FEC: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82192FF0: 40980014  bge cr6, 0x82193004
	if !ctx.cr[6].lt {
	pc = 0x82193004; continue 'dispatch;
	}
	// 82192FF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82192FF8: C18B2BF0  lfs f12, 0x2bf0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11248 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82192FFC: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82193000: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	pc = 0x82193004; continue 'dispatch;
            }
            0x82193004 => {
    //   block [0x82193004..0x821930D0)
	// 82193004: 81630194  lwz r11, 0x194(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(404 as u32) ) } as u64;
	// 82193008: FF0D4800  fcmpu cr6, f13, f9
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[9].f64);
	// 8219300C: 917F0020  stw r11, 0x20(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), ctx.r[11].u32 ) };
	// 82193010: 81630078  lwz r11, 0x78(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(120 as u32) ) } as u64;
	// 82193014: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 82193018: C0030030  lfs f0, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219301C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82193020: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193024: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82193028: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219302C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82193030: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193034: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82193038: C0030050  lfs f0, 0x50(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219303C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82193040: C0030058  lfs f0, 0x58(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193044: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82193048: 40980088  bge cr6, 0x821930d0
	if !ctx.cr[6].lt {
	pc = 0x821930D0; continue 'dispatch;
	}
	// 8219304C: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 82193050: FC60B090  fmr f3, f22
	ctx.f[3].f64 = ctx.f[22].f64;
	// 82193054: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82193058: 481D51C1  bl 0x82368218
	ctx.lr = 0x8219305C;
	sub_82368218(ctx, base);
	// 8219305C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82193060: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 82193064: 481E133D  bl 0x823743a0
	ctx.lr = 0x82193068;
	sub_823743A0(ctx, base);
	// 82193068: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219306C: FC60B090  fmr f3, f22
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[22].f64;
	// 82193070: FC40B090  fmr f2, f22
	ctx.f[2].f64 = ctx.f[22].f64;
	// 82193074: FC20B890  fmr f1, f23
	ctx.f[1].f64 = ctx.f[23].f64;
	// 82193078: 481D51A1  bl 0x82368218
	ctx.lr = 0x8219307C;
	sub_82368218(ctx, base);
	// 8219307C: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 82193080: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82193084: 481E131D  bl 0x823743a0
	ctx.lr = 0x82193088;
	sub_823743A0(ctx, base);
	// 82193088: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219308C: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 82193090: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82193094: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 82193098: 481E1709  bl 0x823747a0
	ctx.lr = 0x8219309C;
	sub_823747A0(ctx, base);
	// 8219309C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 821930A0: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821930A4: 481D5495  bl 0x82368538
	ctx.lr = 0x821930A8;
	sub_82368538(ctx, base);
	// 821930A8: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 821930AC: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 821930B0: 389F0058  addi r4, r31, 0x58
	ctx.r[4].s64 = ctx.r[31].s64 + 88;
	// 821930B4: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821930B8: 481D5559  bl 0x82368610
	ctx.lr = 0x821930BC;
	sub_82368610(ctx, base);
	// 821930BC: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 821930C0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821930C4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821930C8: 483A2F49  bl 0x82536010
	ctx.lr = 0x821930CC;
	sub_82535FFC(ctx, base);
	// 821930CC: 483A203C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821930D0 => {
    //   block [0x821930D0..0x821930F0)
	// 821930D0: EC010372  fmuls f0, f1, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[13].f64) as f32) as f64);
	// 821930D4: 93BF0028  stw r29, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[29].u32 ) };
	// 821930D8: EC1707FA  fmadds f0, f23, f31, f0
	ctx.f[0].f64 = (((ctx.f[23].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 821930DC: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821930E0: 38210160  addi r1, r1, 0x160
	ctx.r[1].s64 = ctx.r[1].s64 + 352;
	// 821930E4: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821930E8: 483A2F29  bl 0x82536010
	ctx.lr = 0x821930EC;
	sub_82535FFC(ctx, base);
	// 821930EC: 483A201C  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821930F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821930F0 size=372
    let mut pc: u32 = 0x821930F0;
    'dispatch: loop {
        match pc {
            0x821930F0 => {
    //   block [0x821930F0..0x8219311C)
	// 821930F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821930F4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821930F8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821930FC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82193100: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82193104: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193108: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219310C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193110: 4E800421  bctrl
	ctx.lr = 0x82193114;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193114: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82193118: 409A001C  bne cr6, 0x82193134
	if !ctx.cr[6].eq {
	pc = 0x82193134; continue 'dispatch;
	}
            }
            0x8219311C => {
    //   block [0x8219311C..0x82193134)
	// 8219311C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193120: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82193124: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193128: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219312C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193130: 4E800020  blr
	return;
            }
            0x82193134 => {
    //   block [0x82193134..0x821931A8)
	// 82193134: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193138: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219313C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193140: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193144: 4E800421  bctrl
	ctx.lr = 0x82193148;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193148: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219314C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82193150: 419AFFCC  beq cr6, 0x8219311c
	if ctx.cr[6].eq {
	pc = 0x8219311C; continue 'dispatch;
	}
	// 82193154: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193158: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219315C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193160: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193164: 4E800421  bctrl
	ctx.lr = 0x82193168;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193168: 81630008  lwz r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219316C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82193170: 419A007C  beq cr6, 0x821931ec
	if ctx.cr[6].eq {
	pc = 0x821931EC; continue 'dispatch;
	}
	// 82193174: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 82193178: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8219317C: 4199FFA0  bgt cr6, 0x8219311c
	if ctx.cr[6].gt {
	pc = 0x8219311C; continue 'dispatch;
	}
	// 82193180: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 82193184: 398C3198  addi r12, r12, 0x3198
	ctx.r[12].s64 = ctx.r[12].s64 + 12696;
	// 82193188: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219318C: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82193190: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82193194: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x821931A8; continue 'dispatch;
		},
		1 => {
	pc = 0x821931A8; continue 'dispatch;
		},
		2 => {
	pc = 0x821931B4; continue 'dispatch;
		},
		3 => {
	pc = 0x821931C0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82193198: 821931A8  lwz r16, 0x31a8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12712 as u32) ) } as u64;
	// 8219319C: 821931A8  lwz r16, 0x31a8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12712 as u32) ) } as u64;
	// 821931A0: 821931B4  lwz r16, 0x31b4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12724 as u32) ) } as u64;
	// 821931A4: 821931C0  lwz r16, 0x31c0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12736 as u32) ) } as u64;
            }
            0x821931A8 => {
    //   block [0x821931A8..0x821931B4)
	// 821931A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821931AC: 480000BD  bl 0x82193268
	ctx.lr = 0x821931B0;
	sub_82193268(ctx, base);
	// 821931B0: 48000018  b 0x821931c8
	pc = 0x821931C8; continue 'dispatch;
            }
            0x821931B4 => {
    //   block [0x821931B4..0x821931C0)
	// 821931B4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821931B8: 48000261  bl 0x82193418
	ctx.lr = 0x821931BC;
	sub_82193418(ctx, base);
	// 821931BC: 4800000C  b 0x821931c8
	pc = 0x821931C8; continue 'dispatch;
            }
            0x821931C0 => {
    //   block [0x821931C0..0x821931C8)
	// 821931C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821931C4: 48000325  bl 0x821934e8
	ctx.lr = 0x821931C8;
	sub_821934E8(ctx, base);
	pc = 0x821931C8; continue 'dispatch;
            }
            0x821931C8 => {
    //   block [0x821931C8..0x821931EC)
	// 821931C8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821931CC: 419AFF50  beq cr6, 0x8219311c
	if ctx.cr[6].eq {
	pc = 0x8219311C; continue 'dispatch;
	}
	// 821931D0: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821931D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821931D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821931DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821931E0: 4E800421  bctrl
	ctx.lr = 0x821931E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821931E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821931E8: 91630008  stw r11, 8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
            }
            0x821931EC => {
    //   block [0x821931EC..0x82193220)
	// 821931EC: 817F006C  lwz r11, 0x6c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(108 as u32) ) } as u64;
	// 821931F0: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 821931F4: 41990058  bgt cr6, 0x8219324c
	if ctx.cr[6].gt {
	pc = 0x8219324C; continue 'dispatch;
	}
	// 821931F8: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 821931FC: 398C3210  addi r12, r12, 0x3210
	ctx.r[12].s64 = ctx.r[12].s64 + 12816;
	// 82193200: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82193204: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82193208: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219320C: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x82193220; continue 'dispatch;
		},
		1 => {
	pc = 0x8219322C; continue 'dispatch;
		},
		2 => {
	pc = 0x82193238; continue 'dispatch;
		},
		3 => {
	pc = 0x82193244; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82193210: 82193220  lwz r16, 0x3220(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12832 as u32) ) } as u64;
	// 82193214: 8219322C  lwz r16, 0x322c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12844 as u32) ) } as u64;
	// 82193218: 82193238  lwz r16, 0x3238(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12856 as u32) ) } as u64;
	// 8219321C: 82193244  lwz r16, 0x3244(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(12868 as u32) ) } as u64;
            }
            0x82193220 => {
    //   block [0x82193220..0x8219322C)
	// 82193220: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193224: 4BFFF0C5  bl 0x821922e8
	ctx.lr = 0x82193228;
	sub_821922E8(ctx, base);
	// 82193228: 48000024  b 0x8219324c
	pc = 0x8219324C; continue 'dispatch;
            }
            0x8219322C => {
    //   block [0x8219322C..0x82193238)
	// 8219322C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193230: 4BFFE731  bl 0x82191960
	ctx.lr = 0x82193234;
	sub_82191960(ctx, base);
	// 82193234: 48000018  b 0x8219324c
	pc = 0x8219324C; continue 'dispatch;
            }
            0x82193238 => {
    //   block [0x82193238..0x82193244)
	// 82193238: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219323C: 4BFFF40D  bl 0x82192648
	ctx.lr = 0x82193240;
	sub_82192648(ctx, base);
	// 82193240: 4800000C  b 0x8219324c
	pc = 0x8219324C; continue 'dispatch;
            }
            0x82193244 => {
    //   block [0x82193244..0x8219324C)
	// 82193244: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193248: 4BFFF959  bl 0x82192ba0
	ctx.lr = 0x8219324C;
	sub_82192BA0(ctx, base);
	pc = 0x8219324C; continue 'dispatch;
            }
            0x8219324C => {
    //   block [0x8219324C..0x82193264)
	// 8219324C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82193250: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82193254: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193258: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219325C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82193268 size=432
    let mut pc: u32 = 0x82193268;
    'dispatch: loop {
        match pc {
            0x82193268 => {
    //   block [0x82193268..0x82193300)
	// 82193268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219326C: 483A1E4D  bl 0x825350b8
	ctx.lr = 0x82193270;
	sub_82535080(ctx, base);
	// 82193270: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82193274: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82193278: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219327C: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193280: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193284: 4E800421  bctrl
	ctx.lr = 0x82193288;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193288: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219328C: 419A0180  beq cr6, 0x8219340c
	if ctx.cr[6].eq {
	pc = 0x8219340C; continue 'dispatch;
	}
	// 82193290: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193294: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193298: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219329C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821932A0: 4E800421  bctrl
	ctx.lr = 0x821932A4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821932A4: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821932A8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821932AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821932B0: 814A0014  lwz r10, 0x14(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 821932B4: 83CB0000  lwz r30, 0(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821932B8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 821932BC: 4E800421  bctrl
	ctx.lr = 0x821932C0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821932C0: 80630004  lwz r3, 4(r3)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 821932C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821932C8: 419A0144  beq cr6, 0x8219340c
	if ctx.cr[6].eq {
	pc = 0x8219340C; continue 'dispatch;
	}
	// 821932CC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821932D0: 419A013C  beq cr6, 0x8219340c
	if ctx.cr[6].eq {
	pc = 0x8219340C; continue 'dispatch;
	}
	// 821932D4: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821932D8: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821932DC: 7F88E378  mr r8, r28
	ctx.r[8].u64 = ctx.r[28].u64;
	// 821932E0: 939F0194  stw r28, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[28].u32 ) };
	// 821932E4: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821932E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821932EC: 409900D0  ble cr6, 0x821933bc
	if !ctx.cr[6].gt {
	pc = 0x821933BC; continue 'dispatch;
	}
	// 821932F0: 3BA30008  addi r29, r3, 8
	ctx.r[29].s64 = ctx.r[3].s64 + 8;
	// 821932F4: 38DE000C  addi r6, r30, 0xc
	ctx.r[6].s64 = ctx.r[30].s64 + 12;
	// 821932F8: 38FF0084  addi r7, r31, 0x84
	ctx.r[7].s64 = ctx.r[31].s64 + 132;
	// 821932FC: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
            }
            0x82193300 => {
    //   block [0x82193300..0x82193324)
	// 82193300: 817F0060  lwz r11, 0x60(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(96 as u32) ) } as u64;
	// 82193304: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82193308: 419A001C  beq cr6, 0x82193324
	if ctx.cr[6].eq {
	pc = 0x82193324; continue 'dispatch;
	}
	// 8219330C: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 82193310: 419A0014  beq cr6, 0x82193324
	if ctx.cr[6].eq {
	pc = 0x82193324; continue 'dispatch;
	}
	// 82193314: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 82193318: 419A000C  beq cr6, 0x82193324
	if ctx.cr[6].eq {
	pc = 0x82193324; continue 'dispatch;
	}
	// 8219331C: 7D641A14  add r11, r4, r3
	ctx.r[11].u64 = ctx.r[4].u64 + ctx.r[3].u64;
	// 82193320: 48000064  b 0x82193384
	pc = 0x82193384; continue 'dispatch;
            }
            0x82193324 => {
    //   block [0x82193324..0x82193338)
	// 82193324: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193328: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219332C: 409A000C  bne cr6, 0x82193338
	if !ctx.cr[6].eq {
	pc = 0x82193338; continue 'dispatch;
	}
	// 82193330: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 82193334: 48000020  b 0x82193354
	pc = 0x82193354; continue 'dispatch;
            }
            0x82193338 => {
    //   block [0x82193338..0x82193350)
	// 82193338: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219333C: 813D0000  lwz r9, 0(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193340: 7D2B4851  subf. r9, r11, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82193344: 4082000C  bne 0x82193350
	if !ctx.cr[0].eq {
	pc = 0x82193350; continue 'dispatch;
	}
	// 82193348: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	// 8219334C: 48000008  b 0x82193354
	pc = 0x82193354; continue 'dispatch;
            }
            0x82193350 => {
    //   block [0x82193350..0x82193354)
	// 82193350: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	pc = 0x82193354; continue 'dispatch;
            }
            0x82193354 => {
    //   block [0x82193354..0x82193380)
	// 82193354: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193358: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219335C: 40980024  bge cr6, 0x82193380
	if !ctx.cr[6].lt {
	pc = 0x82193380; continue 'dispatch;
	}
	// 82193360: 39680001  addi r11, r8, 1
	ctx.r[11].s64 = ctx.r[8].s64 + 1;
	// 82193364: 7F0A5840  cmplw cr6, r10, r11
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[11].u32, &mut ctx.xer);
	// 82193368: 40990018  ble cr6, 0x82193380
	if !ctx.cr[6].gt {
	pc = 0x82193380; continue 'dispatch;
	}
	// 8219336C: 81650000  lwz r11, 0(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193370: 81450004  lwz r10, 4(r5)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193374: 7D4B5051  subf. r10, r11, r10
	ctx.r[10].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82193378: 7D6B1A14  add r11, r11, r3
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8219337C: 40820008  bne 0x82193384
	if !ctx.cr[0].eq {
	pc = 0x82193384; continue 'dispatch;
	}
	pc = 0x82193380; continue 'dispatch;
            }
            0x82193380 => {
    //   block [0x82193380..0x82193384)
	// 82193380: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x82193384; continue 'dispatch;
            }
            0x82193384 => {
    //   block [0x82193384..0x821933BC)
	// 82193384: 91670000  stw r11, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82193388: 39080001  addi r8, r8, 1
	ctx.r[8].s64 = ctx.r[8].s64 + 1;
	// 8219338C: A14B0004  lhz r10, 4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193390: 38A50004  addi r5, r5, 4
	ctx.r[5].s64 = ctx.r[5].s64 + 4;
	// 82193394: 813F0194  lwz r9, 0x194(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 82193398: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 8219339C: 81660000  lwz r11, 0(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821933A0: 38C60008  addi r6, r6, 8
	ctx.r[6].s64 = ctx.r[6].s64 + 8;
	// 821933A4: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821933A8: 7C8B2214  add r4, r11, r4
	ctx.r[4].u64 = ctx.r[11].u64 + ctx.r[4].u64;
	// 821933AC: 915F0194  stw r10, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[10].u32 ) };
	// 821933B0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821933B4: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 821933B8: 4198FF48  blt cr6, 0x82193300
	if ctx.cr[6].lt {
	pc = 0x82193300; continue 'dispatch;
	}
	pc = 0x821933BC; continue 'dispatch;
            }
            0x821933BC => {
    //   block [0x821933BC..0x8219340C)
	// 821933BC: 817F0194  lwz r11, 0x194(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) } as u64;
	// 821933C0: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821933C4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821933C8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821933CC: 939F0190  stw r28, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[28].u32 ) };
	// 821933D0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821933D4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821933D8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821933DC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821933E0: D00A01CC  stfs f0, 0x1cc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 821933E4: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 821933E8: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821933EC: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821933F0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821933F4: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821933F8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821933FC: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82193400: D00A01D0  stfs f0, 0x1d0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 82193404: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82193408: 483A1D00  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x8219340C => {
    //   block [0x8219340C..0x82193418)
	// 8219340C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193410: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82193414: 483A1CF4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82193418 size=204
    let mut pc: u32 = 0x82193418;
    'dispatch: loop {
        match pc {
            0x82193418 => {
    //   block [0x82193418..0x82193444)
	// 82193418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219341C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82193420: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82193424: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82193428: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219342C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193430: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193434: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193438: 4E800421  bctrl
	ctx.lr = 0x8219343C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219343C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82193440: 409A001C  bne cr6, 0x8219345c
	if !ctx.cr[6].eq {
	pc = 0x8219345C; continue 'dispatch;
	}
            }
            0x82193444 => {
    //   block [0x82193444..0x8219345C)
	// 82193444: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193448: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219344C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193450: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82193454: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193458: 4E800020  blr
	return;
            }
            0x8219345C => {
    //   block [0x8219345C..0x821934E4)
	// 8219345C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193460: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193464: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193468: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219346C: 4E800421  bctrl
	ctx.lr = 0x82193470;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193470: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193474: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82193478: 419AFFCC  beq cr6, 0x82193444
	if ctx.cr[6].eq {
	pc = 0x82193444; continue 'dispatch;
	}
	// 8219347C: 917F0184  stw r11, 0x184(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), ctx.r[11].u32 ) };
	// 82193480: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82193484: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193488: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219348C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82193490: 913F0190  stw r9, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[9].u32 ) };
	// 82193494: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82193498: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219349C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821934A0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821934A4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821934A8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821934AC: D00A01CC  stfs f0, 0x1cc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 821934B0: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 821934B4: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 821934B8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821934BC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821934C0: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821934C4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821934C8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821934CC: D00A01D0  stfs f0, 0x1d0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 821934D0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821934D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821934D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821934DC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821934E0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821934E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821934E8 size=204
    let mut pc: u32 = 0x821934E8;
    'dispatch: loop {
        match pc {
            0x821934E8 => {
    //   block [0x821934E8..0x82193514)
	// 821934E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821934EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821934F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821934F4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821934F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821934FC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193500: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193504: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193508: 4E800421  bctrl
	ctx.lr = 0x8219350C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219350C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82193510: 409A001C  bne cr6, 0x8219352c
	if !ctx.cr[6].eq {
	pc = 0x8219352C; continue 'dispatch;
	}
            }
            0x82193514 => {
    //   block [0x82193514..0x8219352C)
	// 82193514: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193518: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219351C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193520: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82193524: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193528: 4E800020  blr
	return;
            }
            0x8219352C => {
    //   block [0x8219352C..0x821935B4)
	// 8219352C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193530: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193534: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 82193538: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219353C: 4E800421  bctrl
	ctx.lr = 0x82193540;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193540: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193544: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82193548: 419AFFCC  beq cr6, 0x82193514
	if ctx.cr[6].eq {
	pc = 0x82193514; continue 'dispatch;
	}
	// 8219354C: 917F0188  stw r11, 0x188(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), ctx.r[11].u32 ) };
	// 82193550: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82193554: A16B0004  lhz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193558: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219355C: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82193560: 913F0190  stw r9, 0x190(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), ctx.r[9].u32 ) };
	// 82193564: 917F0194  stw r11, 0x194(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), ctx.r[11].u32 ) };
	// 82193568: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219356C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82193570: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82193574: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82193578: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219357C: D00A01CC  stfs f0, 0x1cc(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(460 as u32), tmp.u32 ) };
	// 82193580: 817F0190  lwz r11, 0x190(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) } as u64;
	// 82193584: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 82193588: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219358C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82193590: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82193594: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82193598: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219359C: D00A01D0  stfs f0, 0x1d0(r10)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(464 as u32), tmp.u32 ) };
	// 821935A0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821935A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821935A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821935AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821935B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821935B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821935B8 size=232
    let mut pc: u32 = 0x821935B8;
    'dispatch: loop {
        match pc {
            0x821935B8 => {
    //   block [0x821935B8..0x82193630)
	// 821935B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821935BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821935C0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821935C4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821935C8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821935CC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821935D0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 821935D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821935D8: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821935DC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821935E0: 4E800421  bctrl
	ctx.lr = 0x821935E4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821935E4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821935E8: 419A00A0  beq cr6, 0x82193688
	if ctx.cr[6].eq {
	pc = 0x82193688; continue 'dispatch;
	}
	// 821935EC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821935F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821935F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 821935F8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821935FC: 4E800421  bctrl
	ctx.lr = 0x82193600;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193600: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193604: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193608: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219360C: 419A007C  beq cr6, 0x82193688
	if ctx.cr[6].eq {
	pc = 0x82193688; continue 'dispatch;
	}
	// 82193610: 80AB0004  lwz r5, 4(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193614: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82193618: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219361C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 82193620: 419A0068  beq cr6, 0x82193688
	if ctx.cr[6].eq {
	pc = 0x82193688; continue 'dispatch;
	}
	// 82193624: 395F0084  addi r10, r31, 0x84
	ctx.r[10].s64 = ctx.r[31].s64 + 132;
	// 82193628: 813E0000  lwz r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219362C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
            }
            0x82193630 => {
    //   block [0x82193630..0x82193658)
	// 82193630: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193634: A0E70004  lhz r7, 4(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[7].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193638: 7D074214  add r8, r7, r8
	ctx.r[8].u64 = ctx.r[7].u64 + ctx.r[8].u64;
	// 8219363C: 7F094000  cmpw cr6, r9, r8
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[8].s32, &mut ctx.xer);
	// 82193640: 41980018  blt cr6, 0x82193658
	if ctx.cr[6].lt {
	pc = 0x82193658; continue 'dispatch;
	}
	// 82193644: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 82193648: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219364C: 7F062840  cmplw cr6, r6, r5
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[5].u32, &mut ctx.xer);
	// 82193650: 4198FFE0  blt cr6, 0x82193630
	if ctx.cr[6].lt {
	pc = 0x82193630; continue 'dispatch;
	}
	// 82193654: 48000034  b 0x82193688
	pc = 0x82193688; continue 'dispatch;
            }
            0x82193658 => {
    //   block [0x82193658..0x82193664)
	// 82193658: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219365C: 419A0028  beq cr6, 0x82193684
	if ctx.cr[6].eq {
	pc = 0x82193684; continue 'dispatch;
	}
	// 82193660: 7CCB3378  mr r11, r6
	ctx.r[11].u64 = ctx.r[6].u64;
	pc = 0x82193664; continue 'dispatch;
            }
            0x82193664 => {
    //   block [0x82193664..0x82193684)
	// 82193664: 810A0000  lwz r8, 0(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193668: 396BFFFF  addi r11, r11, -1
	ctx.r[11].s64 = ctx.r[11].s64 + -1;
	// 8219366C: 394A0004  addi r10, r10, 4
	ctx.r[10].s64 = ctx.r[10].s64 + 4;
	// 82193670: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82193674: A1080004  lhz r8, 4(r8)
	ctx.r[8].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193678: 7D284850  subf r9, r8, r9
	ctx.r[9].s64 = ctx.r[9].s64 - ctx.r[8].s64;
	// 8219367C: 409AFFE8  bne cr6, 0x82193664
	if !ctx.cr[6].eq {
	pc = 0x82193664; continue 'dispatch;
	}
	// 82193680: 913E0000  stw r9, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	pc = 0x82193684; continue 'dispatch;
            }
            0x82193684 => {
    //   block [0x82193684..0x82193688)
	// 82193684: 7CC33378  mr r3, r6
	ctx.r[3].u64 = ctx.r[6].u64;
	pc = 0x82193688; continue 'dispatch;
            }
            0x82193688 => {
    //   block [0x82193688..0x821936A0)
	// 82193688: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219368C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193690: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82193694: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82193698: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219369C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821936A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821936A0 size=72
    let mut pc: u32 = 0x821936A0;
    'dispatch: loop {
        match pc {
            0x821936A0 => {
    //   block [0x821936A0..0x821936D4)
	// 821936A0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821936A4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821936A8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821936AC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821936B0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821936B4: 817F001C  lwz r11, 0x1c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 821936B8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821936BC: 419A0018  beq cr6, 0x821936d4
	if ctx.cr[6].eq {
	pc = 0x821936D4; continue 'dispatch;
	}
	// 821936C0: 4BFFFA31  bl 0x821930f0
	ctx.lr = 0x821936C4;
	sub_821930F0(ctx, base);
	// 821936C4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821936C8: 419A000C  beq cr6, 0x821936d4
	if ctx.cr[6].eq {
	pc = 0x821936D4; continue 'dispatch;
	}
	// 821936CC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821936D0: 4BFFE071  bl 0x82191740
	ctx.lr = 0x821936D4;
	sub_82191740(ctx, base);
	pc = 0x821936D4; continue 'dispatch;
            }
            0x821936D4 => {
    //   block [0x821936D4..0x821936E8)
	// 821936D4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821936D8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821936DC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821936E0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821936E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821936E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821936E8 size=132
    let mut pc: u32 = 0x821936E8;
    'dispatch: loop {
        match pc {
            0x821936E8 => {
    //   block [0x821936E8..0x8219370C)
	// 821936E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821936EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821936F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821936F4: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821936F8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821936FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82193700: 806BB9B0  lwz r3, -0x4650(r11)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 82193704: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82193708: 409A001C  bne cr6, 0x82193724
	if !ctx.cr[6].eq {
	pc = 0x82193724; continue 'dispatch;
	}
	pc = 0x8219370C; continue 'dispatch;
            }
            0x8219370C => {
    //   block [0x8219370C..0x82193724)
	// 8219370C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82193710: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82193714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219371C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193720: 4E800020  blr
	return;
            }
            0x82193724 => {
    //   block [0x82193724..0x82193750)
	// 82193724: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82193728: 4BFA57E1  bl 0x82138f08
	ctx.lr = 0x8219372C;
	sub_82138F08(ctx, base);
	// 8219372C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82193730: 419AFFDC  beq cr6, 0x8219370c
	if ctx.cr[6].eq {
	pc = 0x8219370C; continue 'dispatch;
	}
	// 82193734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82193738: 2F1F0000  cmpwi cr6, r31, 0
	ctx.cr[6].compare_i32(ctx.r[31].s32, 0, &mut ctx.xer);
	// 8219373C: 91630228  stw r11, 0x228(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(552 as u32), ctx.r[11].u32 ) };
	// 82193740: 409A0010  bne cr6, 0x82193750
	if !ctx.cr[6].eq {
	pc = 0x82193750; continue 'dispatch;
	}
	// 82193744: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82193748: 91430230  stw r10, 0x230(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), ctx.r[10].u32 ) };
	// 8219374C: 48000008  b 0x82193754
	pc = 0x82193754; continue 'dispatch;
            }
            0x82193750 => {
    //   block [0x82193750..0x82193754)
	// 82193750: 91630230  stw r11, 0x230(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), ctx.r[11].u32 ) };
	pc = 0x82193754; continue 'dispatch;
            }
            0x82193754 => {
    //   block [0x82193754..0x8219376C)
	// 82193754: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 82193758: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219375C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193760: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82193764: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193768: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193770(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82193770 size=216
    let mut pc: u32 = 0x82193770;
    'dispatch: loop {
        match pc {
            0x82193770 => {
    //   block [0x82193770..0x8219382C)
	// 82193770: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82193774: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82193778: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219377C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82193780: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82193784: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82193788: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219378C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 82193790: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82193794: 481E6B65  bl 0x8237a2f8
	ctx.lr = 0x82193798;
	sub_8237A2F8(ctx, base);
	// 82193798: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219379C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821937A0: 419A008C  beq cr6, 0x8219382c
	if ctx.cr[6].eq {
	pc = 0x8219382C; continue 'dispatch;
	}
	// 821937A4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821937A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821937AC: 396B0538  addi r11, r11, 0x538
	ctx.r[11].s64 = ctx.r[11].s64 + 1336;
	// 821937B0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821937B4: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821937B8: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 821937BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821937C0: 4E800421  bctrl
	ctx.lr = 0x821937C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821937C4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821937C8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821937CC: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 821937D0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821937D4: 4E800421  bctrl
	ctx.lr = 0x821937D8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821937D8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821937DC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821937E0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821937E4: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 821937E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821937EC: 4E800421  bctrl
	ctx.lr = 0x821937F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821937F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821937F4: FC00F890  fmr f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[31].f64;
	// 821937F8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821937FC: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82193800: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193804: C9AB2008  lfd f13, 0x2008(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82193808: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219380C: FC00682E  fsel f0, f0, f0, f13
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	// 82193810: C9AB2000  lfd f13, 0x2000(r11)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8192 as u32) ) };
	// 82193814: FD806828  fsub f12, f0, f13
	ctx.f[12].f64 = ctx.f[0].f64 - ctx.f[13].f64;
	// 82193818: FC0C036E  fsel f0, f12, f13, f0
	ctx.f[0].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[0].f64 };
	// 8219381C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82193820: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82193824: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82193828: 93EB0250  stw r31, 0x250(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(592 as u32), ctx.r[31].u32 ) };
            }
            0x8219382C => {
    //   block [0x8219382C..0x82193848)
	// 8219382C: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82193830: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82193834: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82193838: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 8219383C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82193840: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82193844: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193848(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82193848 size=12
    let mut pc: u32 = 0x82193848;
    'dispatch: loop {
        match pc {
            0x82193848 => {
    //   block [0x82193848..0x82193854)
	// 82193848: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219384C: 386B1160  addi r3, r11, 0x1160
	ctx.r[3].s64 = ctx.r[11].s64 + 4448;
	// 82193850: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193858(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82193858 size=8
    let mut pc: u32 = 0x82193858;
    'dispatch: loop {
        match pc {
            0x82193858 => {
    //   block [0x82193858..0x82193860)
	// 82193858: 38600016  li r3, 0x16
	ctx.r[3].s64 = 22;
	// 8219385C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193860(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82193860 size=8
    let mut pc: u32 = 0x82193860;
    'dispatch: loop {
        match pc {
            0x82193860 => {
    //   block [0x82193860..0x82193868)
	// 82193860: 38600300  li r3, 0x300
	ctx.r[3].s64 = 768;
	// 82193864: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82193868(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82193868 size=7668
    let mut pc: u32 = 0x82193868;
    'dispatch: loop {
        match pc {
            0x82193868 => {
    //   block [0x82193868..0x821938C4)
	// 82193868: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219386C: 483A1835  bl 0x825350a0
	ctx.lr = 0x82193870;
	sub_82535080(ctx, base);
	// 82193870: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82193874: 483A2755  bl 0x82535fc8
	ctx.lr = 0x82193878;
	sub_82535FB0(ctx, base);
	// 82193878: 9421FE30  stwu r1, -0x1d0(r1)
	ea = ctx.r[1].u32.wrapping_add(-464 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219387C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82193880: 906101E4  stw r3, 0x1e4(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(484 as u32), ctx.r[3].u32 ) };
	// 82193884: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 82193888: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 8219388C: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82193890: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 82193894: 83ABB9AC  lwz r29, -0x4654(r11)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18004 as u32) ) } as u64;
	// 82193898: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219389C: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 821938A0: 617BBE64  ori r27, r11, 0xbe64
	ctx.r[27].u64 = ctx.r[11].u64 | 48740;
	// 821938A4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821938A8: 7D164378  mr r22, r8
	ctx.r[22].u64 = ctx.r[8].u64;
	// 821938AC: 7EF8BB78  mr r24, r23
	ctx.r[24].u64 = ctx.r[23].u64;
	// 821938B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821938B4: 3B8B76FC  addi r28, r11, 0x76fc
	ctx.r[28].s64 = ctx.r[11].s64 + 30460;
	// 821938B8: 419A000C  beq cr6, 0x821938c4
	if ctx.cr[6].eq {
	pc = 0x821938C4; continue 'dispatch;
	}
	// 821938BC: 7F1FD8AE  lbzx r24, r31, r27
	ctx.r[24].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 821938C0: 48000008  b 0x821938c8
	pc = 0x821938C8; continue 'dispatch;
            }
            0x821938C4 => {
    //   block [0x821938C4..0x821938C8)
	// 821938C4: 83FC0000  lwz r31, 0(r28)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x821938C8; continue 'dispatch;
            }
            0x821938C8 => {
    //   block [0x821938C8..0x8219395C)
	// 821938C8: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 821938CC: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821938D0: 4BFF6291  bl 0x82189b60
	ctx.lr = 0x821938D4;
	sub_82189B60(ctx, base);
	// 821938D4: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821938D8: 2B1E0017  cmplwi cr6, r30, 0x17
	ctx.cr[6].compare_u32(ctx.r[30].u32, 23 as u32, &mut ctx.xer);
	// 821938DC: 93CB0030  stw r30, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 821938E0: 41991D6C  bgt cr6, 0x8219564c
	if ctx.cr[6].gt {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 821938E4: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 821938E8: 398C38FC  addi r12, r12, 0x38fc
	ctx.r[12].s64 = ctx.r[12].s64 + 14588;
	// 821938EC: 57C0103A  slwi r0, r30, 2
	ctx.r[0].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821938F0: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821938F4: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821938F8: 4E800420  bctr
	match ctx.r[30].u64 {
		0 => {
	pc = 0x8219395C; continue 'dispatch;
		},
		1 => {
	pc = 0x82193974; continue 'dispatch;
		},
		2 => {
	pc = 0x821939A8; continue 'dispatch;
		},
		3 => {
	pc = 0x82194240; continue 'dispatch;
		},
		4 => {
	pc = 0x82194620; continue 'dispatch;
		},
		5 => {
	pc = 0x8219493C; continue 'dispatch;
		},
		6 => {
	pc = 0x8219499C; continue 'dispatch;
		},
		7 => {
	pc = 0x82194128; continue 'dispatch;
		},
		8 => {
	pc = 0x821941CC; continue 'dispatch;
		},
		9 => {
	pc = 0x82194660; continue 'dispatch;
		},
		10 => {
	pc = 0x8219490C; continue 'dispatch;
		},
		11 => {
	pc = 0x82194714; continue 'dispatch;
		},
		12 => {
	pc = 0x82194878; continue 'dispatch;
		},
		13 => {
	pc = 0x8219490C; continue 'dispatch;
		},
		14 => {
	pc = 0x82194A4C; continue 'dispatch;
		},
		15 => {
	pc = 0x82194C04; continue 'dispatch;
		},
		16 => {
	pc = 0x82194C30; continue 'dispatch;
		},
		17 => {
	pc = 0x82194A7C; continue 'dispatch;
		},
		18 => {
	pc = 0x82194C68; continue 'dispatch;
		},
		19 => {
	pc = 0x82194E48; continue 'dispatch;
		},
		20 => {
	pc = 0x82194FAC; continue 'dispatch;
		},
		21 => {
	pc = 0x82195084; continue 'dispatch;
		},
		22 => {
	pc = 0x82195224; continue 'dispatch;
		},
		23 => {
	pc = 0x821952E0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821938FC: 8219395C  lwz r16, 0x395c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(14684 as u32) ) } as u64;
	// 82193900: 82193974  lwz r16, 0x3974(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(14708 as u32) ) } as u64;
	// 82193904: 821939A8  lwz r16, 0x39a8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(14760 as u32) ) } as u64;
	// 82193908: 82194240  lwz r16, 0x4240(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16960 as u32) ) } as u64;
	// 8219390C: 82194620  lwz r16, 0x4620(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17952 as u32) ) } as u64;
	// 82193910: 8219493C  lwz r16, 0x493c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18748 as u32) ) } as u64;
	// 82193914: 8219499C  lwz r16, 0x499c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18844 as u32) ) } as u64;
	// 82193918: 82194128  lwz r16, 0x4128(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16680 as u32) ) } as u64;
	// 8219391C: 821941CC  lwz r16, 0x41cc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(16844 as u32) ) } as u64;
	// 82193920: 82194660  lwz r16, 0x4660(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18016 as u32) ) } as u64;
	// 82193924: 8219490C  lwz r16, 0x490c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18700 as u32) ) } as u64;
	// 82193928: 82194714  lwz r16, 0x4714(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18196 as u32) ) } as u64;
	// 8219392C: 82194878  lwz r16, 0x4878(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18552 as u32) ) } as u64;
	// 82193930: 8219490C  lwz r16, 0x490c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(18700 as u32) ) } as u64;
	// 82193934: 82194A4C  lwz r16, 0x4a4c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(19020 as u32) ) } as u64;
	// 82193938: 82194C04  lwz r16, 0x4c04(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(19460 as u32) ) } as u64;
	// 8219393C: 82194C30  lwz r16, 0x4c30(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(19504 as u32) ) } as u64;
	// 82193940: 82194A7C  lwz r16, 0x4a7c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(19068 as u32) ) } as u64;
	// 82193944: 82194C68  lwz r16, 0x4c68(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(19560 as u32) ) } as u64;
	// 82193948: 82194E48  lwz r16, 0x4e48(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20040 as u32) ) } as u64;
	// 8219394C: 82194FAC  lwz r16, 0x4fac(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20396 as u32) ) } as u64;
	// 82193950: 82195084  lwz r16, 0x5084(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(20612 as u32) ) } as u64;
	// 82193954: 82195224  lwz r16, 0x5224(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21028 as u32) ) } as u64;
	// 82193958: 821952E0  lwz r16, 0x52e0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21216 as u32) ) } as u64;
            }
            0x8219395C => {
    //   block [0x8219395C..0x82193974)
	// 8219395C: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82193960: 4BFF67C9  bl 0x8218a128
	ctx.lr = 0x82193964;
	sub_8218A128(ctx, base);
	// 82193964: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82193968: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219396C: 483A26A9  bl 0x82536014
	ctx.lr = 0x82193970;
	sub_82535FFC(ctx, base);
	// 82193970: 483A1780  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82193974 => {
    //   block [0x82193974..0x821939A8)
	// 82193974: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82193978: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8219397C: 4BFF5D5D  bl 0x821896d8
	ctx.lr = 0x82193980;
	sub_821896D8(ctx, base);
	// 82193980: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82193984: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 82193988: 816BA0CC  lwz r11, -0x5f34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 8219398C: 91430010  stw r10, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82193990: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82193994: 916301A4  stw r11, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82193998: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8219399C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821939A0: 483A2675  bl 0x82536014
	ctx.lr = 0x821939A4;
	sub_82535FFC(ctx, base);
	// 821939A4: 483A174C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821939A8 => {
    //   block [0x821939A8..0x821939E8)
	// 821939A8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821939AC: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821939B0: 4BFF6851  bl 0x8218a200
	ctx.lr = 0x821939B4;
	sub_8218A200(ctx, base);
	// 821939B4: 2F190005  cmpwi cr6, r25, 5
	ctx.cr[6].compare_i32(ctx.r[25].s32, 5, &mut ctx.xer);
	// 821939B8: 409A0034  bne cr6, 0x821939ec
	if !ctx.cr[6].eq {
	pc = 0x821939EC; continue 'dispatch;
	}
	// 821939BC: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821939C0: 616B7E18  ori r11, r11, 0x7e18
	ctx.r[11].u64 = ctx.r[11].u64 | 32280;
	// 821939C4: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821939C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821939CC: 419A001C  beq cr6, 0x821939e8
	if ctx.cr[6].eq {
	pc = 0x821939E8; continue 'dispatch;
	}
	// 821939D0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821939D4: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821939D8: 4BFF6069  bl 0x82189a40
	ctx.lr = 0x821939DC;
	sub_82189A40(ctx, base);
	// 821939DC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821939E0: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 821939E4: 48000008  b 0x821939ec
	pc = 0x821939EC; continue 'dispatch;
            }
            0x821939E8 => {
    //   block [0x821939E8..0x821939EC)
	// 821939E8: 7EF9BB78  mr r25, r23
	ctx.r[25].u64 = ctx.r[23].u64;
	pc = 0x821939EC; continue 'dispatch;
            }
            0x821939EC => {
    //   block [0x821939EC..0x82193A24)
	// 821939EC: 2B190001  cmplwi cr6, r25, 1
	ctx.cr[6].compare_u32(ctx.r[25].u32, 1 as u32, &mut ctx.xer);
	// 821939F0: 419802B4  blt cr6, 0x82193ca4
	if ctx.cr[6].lt {
	pc = 0x82193CA4; continue 'dispatch;
	}
	// 821939F4: 419A0178  beq cr6, 0x82193b6c
	if ctx.cr[6].eq {
	pc = 0x82193B6C; continue 'dispatch;
	}
	// 821939F8: 2B190003  cmplwi cr6, r25, 3
	ctx.cr[6].compare_u32(ctx.r[25].u32, 3 as u32, &mut ctx.xer);
	// 821939FC: 40981C50  bge cr6, 0x8219564c
	if !ctx.cr[6].lt {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 82193A00: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193A04: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82193A08: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 82193A0C: 7DBF5C2E  lfsx f13, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193A10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193A14: C00B2B58  lfs f0, 0x2b58(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11096 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193A18: 409A000C  bne cr6, 0x82193a24
	if !ctx.cr[6].eq {
	pc = 0x82193A24; continue 'dispatch;
	}
	// 82193A1C: EC6D0028  fsubs f3, f13, f0
	ctx.f[3].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82193A20: 48000008  b 0x82193a28
	pc = 0x82193A28; continue 'dispatch;
            }
            0x82193A24 => {
    //   block [0x82193A24..0x82193A28)
	// 82193A24: EC6D002A  fadds f3, f13, f0
	ctx.f[3].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	pc = 0x82193A28; continue 'dispatch;
            }
            0x82193A28 => {
    //   block [0x82193A28..0x82193AF0)
	// 82193A28: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193A2C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193A30: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82193A34: 92E10094  stw r23, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[23].u32 ) };
	// 82193A38: 617E9BA8  ori r30, r11, 0x9ba8
	ctx.r[30].u64 = ctx.r[11].u64 | 39848;
	// 82193A3C: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 82193A40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193A44: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82193A48: 7DAAF42E  lfsx f13, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193A4C: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82193A50: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193A54: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 82193A58: 616B9BA4  ori r11, r11, 0x9ba4
	ctx.r[11].u64 = ctx.r[11].u64 | 39844;
	// 82193A5C: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 82193A60: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 82193A64: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82193A68: FCC05090  fmr f6, f10
	ctx.f[6].f64 = ctx.f[10].f64;
	// 82193A6C: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82193A70: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193A74: 617F9BA0  ori r31, r11, 0x9ba0
	ctx.r[31].u64 = ctx.r[11].u64 | 39840;
	// 82193A78: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193A7C: 7C0BF42E  lfsx f0, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193A80: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82193A84: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82193A88: 7D6BFC2E  lfsx f11, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82193A8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193A90: 7C0A442E  lfsx f0, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193A94: ED8C002A  fadds f12, f12, f0
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64;
	// 82193A98: 7C0AFC2E  lfsx f0, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193A9C: ED6B002A  fadds f11, f11, f0
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 82193AA0: C0AB2B54  lfs f5, 0x2b54(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11092 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82193AA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193AA8: C08B2B50  lfs f4, 0x2b50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11088 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82193AAC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193AB0: C04B2B4C  lfs f2, 0x2b4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11084 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82193AB4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82193AB8: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82193ABC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193AC0: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193AC4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193AC8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193ACC: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193AD0: 4BFFD149  bl 0x82190c18
	ctx.lr = 0x82193AD4;
	sub_82190C18(ctx, base);
	// 82193AD4: 83DD0408  lwz r30, 0x408(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82193AD8: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193ADC: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82193AE0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82193AE4: 409A000C  bne cr6, 0x82193af0
	if !ctx.cr[6].eq {
	pc = 0x82193AF0; continue 'dispatch;
	}
	// 82193AE8: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 82193AEC: 48000058  b 0x82193b44
	pc = 0x82193B44; continue 'dispatch;
            }
            0x82193AF0 => {
    //   block [0x82193AF0..0x82193B44)
	// 82193AF0: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82193AF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82193AF8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193AFC: 483A16D5  bl 0x825351d0
	ctx.lr = 0x82193B00;
	sub_825351D0(ctx, base);
	// 82193B00: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82193B04: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82193B08: 396B092C  addi r11, r11, 0x92c
	ctx.r[11].s64 = ctx.r[11].s64 + 2348;
	// 82193B0C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193B10: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82193B14: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82193B18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193B1C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193B20: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82193B24: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82193B28: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193B2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193B30: 4E800421  bctrl
	ctx.lr = 0x82193B34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193B34: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82193B38: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193B3C: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 82193B40: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
            }
            0x82193B44 => {
    //   block [0x82193B44..0x82193B6C)
	// 82193B44: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193B48: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82193B4C: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 82193B50: 91430024  stw r10, 0x24(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), ctx.r[10].u32 ) };
	// 82193B54: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82193B58: 4E800421  bctrl
	ctx.lr = 0x82193B5C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82193B5C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82193B60: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82193B64: 483A24B1  bl 0x82536014
	ctx.lr = 0x82193B68;
	sub_82535FFC(ctx, base);
	// 82193B68: 483A1588  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82193B6C => {
    //   block [0x82193B6C..0x82193BB4)
	// 82193B6C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193B70: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82193B74: 616B9B74  ori r11, r11, 0x9b74
	ctx.r[11].u64 = ctx.r[11].u64 | 39796;
	// 82193B78: 7DBF5C2E  lfsx f13, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193B7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193B80: C00B2B48  lfs f0, 0x2b48(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11080 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193B84: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193B88: 409A002C  bne cr6, 0x82193bb4
	if !ctx.cr[6].eq {
	pc = 0x82193BB4; continue 'dispatch;
	}
	// 82193B8C: EFED0028  fsubs f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82193B90: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193B94: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193B98: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82193B9C: 4BFBF71D  bl 0x821532b8
	ctx.lr = 0x82193BA0;
	sub_821532B8(ctx, base);
	// 82193BA0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193BA4: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82193BA8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82193BAC: C3CB2284  lfs f30, 0x2284(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8836 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82193BB0: 48000028  b 0x82193bd8
	pc = 0x82193BD8; continue 'dispatch;
            }
            0x82193BB4 => {
    //   block [0x82193BB4..0x82193BD8)
	// 82193BB4: EFED002A  fadds f31, f13, f0
	ctx.f[31].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82193BB8: C00B2490  lfs f0, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193BBC: EFDF0032  fmuls f30, f31, f0
	ctx.f[30].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193BC0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82193BC4: 4BFBF6F5  bl 0x821532b8
	ctx.lr = 0x82193BC8;
	sub_821532B8(ctx, base);
	// 82193BC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193BCC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82193BD0: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82193BD4: C3CB2B44  lfs f30, 0x2b44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11076 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x82193BD8; continue 'dispatch;
            }
            0x82193BD8 => {
    //   block [0x82193BD8..0x82193CA4)
	// 82193BD8: EFA007B2  fmuls f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193BDC: 4BF898ED  bl 0x8211d4c8
	ctx.lr = 0x82193BE0;
	sub_8211D4C8(ctx, base);
	// 82193BE0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193BE4: 93E1008C  stw r31, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82193BE8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82193BEC: EDA107B2  fmuls f13, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193BF0: 616B9BA4  ori r11, r11, 0x9ba4
	ctx.r[11].u64 = ctx.r[11].u64 | 39844;
	// 82193BF4: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82193BF8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82193BFC: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 82193C00: 7D685B78  mr r8, r11
	ctx.r[8].u64 = ctx.r[11].u64;
	// 82193C04: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193C08: C00ABFFC  lfs f0, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193C0C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193C10: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82193C14: 617E9BA8  ori r30, r11, 0x9ba8
	ctx.r[30].u64 = ctx.r[11].u64 | 39848;
	// 82193C18: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193C1C: 7FCA442E  lfsx f30, r10, r8
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[8].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82193C20: 7D0AF42E  lfsx f8, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82193C24: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82193C28: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193C2C: FD205090  fmr f9, f10
	ctx.f[9].f64 = ctx.f[10].f64;
	// 82193C30: 617F9BA0  ori r31, r11, 0x9ba0
	ctx.r[31].u64 = ctx.r[11].u64 | 39840;
	// 82193C34: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82193C38: FCA05090  fmr f5, f10
	ctx.f[5].f64 = ctx.f[10].f64;
	// 82193C3C: 7D6BF42E  lfsx f11, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82193C40: 7CEBFC2E  lfsx f7, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82193C44: ED6B402A  fadds f11, f11, f8
	ctx.f[11].f64 = ((ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64;
	// 82193C48: 7CCAFC2E  lfsx f6, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82193C4C: FD005090  fmr f8, f10
	ctx.f[8].f64 = ctx.f[10].f64;
	// 82193C50: EF87302A  fadds f28, f7, f6
	ctx.f[28].f64 = ((ctx.f[7].f64 + ctx.f[6].f64) as f32) as f64;
	// 82193C54: 7D8B4C2E  lfsx f12, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82193C58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193C5C: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 82193C60: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82193C64: FCC05090  fmr f6, f10
	ctx.f[6].f64 = ctx.f[10].f64;
	// 82193C68: C08B2B40  lfs f4, 0x2b40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11072 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82193C6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193C70: 91210094  stw r9, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 82193C74: EDAB683A  fmadds f13, f11, f0, f13
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82193C78: ED7CE83A  fmadds f11, f28, f0, f29
	ctx.f[11].f64 = (((ctx.f[28].f64 * ctx.f[0].f64 + ctx.f[29].f64) as f32) as f64);
	// 82193C7C: EC1E6028  fsubs f0, f30, f12
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[12].f64) as f32) as f64);
	// 82193C80: C04B2B4C  lfs f2, 0x2b4c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11084 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82193C84: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82193C88: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82193C8C: FD80F32E  fsel f12, f0, f12, f30
	ctx.f[12].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[30].f64 };
	// 82193C90: 4BFFCF89  bl 0x82190c18
	ctx.lr = 0x82193C94;
	sub_82190C18(ctx, base);
	// 82193C94: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82193C98: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82193C9C: 483A2379  bl 0x82536014
	ctx.lr = 0x82193CA0;
	sub_82535FFC(ctx, base);
	// 82193CA0: 483A1450  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82193CA4 => {
    //   block [0x82193CA4..0x82193D1C)
	// 82193CA4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82193CA8: 3FDF0002  addis r30, r31, 2
	ctx.r[30].s64 = ctx.r[31].s64 + 131072;
	// 82193CAC: 3B8BBFF0  addi r28, r11, -0x4010
	ctx.r[28].s64 = ctx.r[11].s64 + -16400;
	// 82193CB0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82193CB4: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82193CB8: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82193CBC: 3BDE9B74  addi r30, r30, -0x648c
	ctx.r[30].s64 = ctx.r[30].s64 + -25740;
	// 82193CC0: 7C1C5C2E  lfsx f0, r28, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193CC4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193CC8: C1AB2B3C  lfs f13, 0x2b3c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11068 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193CCC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193CD0: EEA00372  fmuls f21, f0, f13
	ctx.f[21].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82193CD4: C3CB2400  lfs f30, 0x2400(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9216 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82193CD8: EDB507B2  fmuls f13, f21, f30
	ctx.f[13].f64 = (((ctx.f[21].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193CDC: EE8D0032  fmuls f20, f13, f0
	ctx.f[20].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193CE0: 409A003C  bne cr6, 0x82193d1c
	if !ctx.cr[6].eq {
	pc = 0x82193D1C; continue 'dispatch;
	}
	// 82193CE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193CE8: C1AB2B38  lfs f13, 0x2b38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11064 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193CEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193CF0: EF600372  fmuls f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82193CF4: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193CF8: ED9B07B2  fmuls f12, f27, f30
	ctx.f[12].f64 = (((ctx.f[27].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193CFC: EF2C0032  fmuls f25, f12, f0
	ctx.f[25].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193D00: C00B25C0  lfs f0, 0x25c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193D04: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82193D08: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D0C: C18BD6C8  lfs f12, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82193D10: EECD6028  fsubs f22, f13, f12
	ctx.f[22].f64 = (((ctx.f[13].f64 - ctx.f[12].f64) as f32) as f64);
	// 82193D14: FF000090  fmr f24, f0
	ctx.f[24].f64 = ctx.f[0].f64;
	// 82193D18: 48000038  b 0x82193d50
	pc = 0x82193D50; continue 'dispatch;
            }
            0x82193D1C => {
    //   block [0x82193D1C..0x82193D50)
	// 82193D1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D20: C1AB2B34  lfs f13, 0x2b34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11060 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193D24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D28: EF600372  fmuls f27, f0, f13
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82193D2C: C1BE0000  lfs f13, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193D30: ED9B07B2  fmuls f12, f27, f30
	ctx.f[12].f64 = (((ctx.f[27].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193D34: EF2C0032  fmuls f25, f12, f0
	ctx.f[25].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193D38: C00B25C0  lfs f0, 0x25c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193D3C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 82193D40: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D44: C18BD6C8  lfs f12, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82193D48: EF0D602A  fadds f24, f13, f12
	ctx.f[24].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82193D4C: FEC00090  fmr f22, f0
	ctx.f[22].f64 = ctx.f[0].f64;
	pc = 0x82193D50; continue 'dispatch;
            }
            0x82193D50 => {
    //   block [0x82193D50..0x82193EC4)
	// 82193D50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D54: FEE00090  fmr f23, f0
	ctx.f[23].f64 = ctx.f[0].f64;
	// 82193D58: C01E0000  lfs f0, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193D5C: C3AB2490  lfs f29, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82193D60: EFE00772  fmuls f31, f0, f29
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82193D64: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82193D68: 4BF89761  bl 0x8211d4c8
	ctx.lr = 0x82193D6C;
	sub_8211D4C8(ctx, base);
	// 82193D6C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82193D70: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193D74: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82193D78: C3EBBFFC  lfs f31, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82193D7C: EF8007F2  fmuls f28, f0, f31
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82193D80: 4BFBF539  bl 0x821532b8
	ctx.lr = 0x82193D84;
	sub_821532B8(ctx, base);
	// 82193D84: 38A00003  li r5, 3
	ctx.r[5].s64 = 3;
	// 82193D88: EFE107F2  fmuls f31, f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 * ctx.f[31].f64) as f32) as f64);
	// 82193D8C: 388100D0  addi r4, r1, 0xd0
	ctx.r[4].s64 = ctx.r[1].s64 + 208;
	// 82193D90: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193D94: 4BF94D65  bl 0x82128af8
	ctx.lr = 0x82193D98;
	sub_82128AF8(ctx, base);
	// 82193D98: 38A0000E  li r5, 0xe
	ctx.r[5].s64 = 14;
	// 82193D9C: 388100C0  addi r4, r1, 0xc0
	ctx.r[4].s64 = ctx.r[1].s64 + 192;
	// 82193DA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193DA4: 4BF94D55  bl 0x82128af8
	ctx.lr = 0x82193DA8;
	sub_82128AF8(ctx, base);
	// 82193DA8: 38A0000F  li r5, 0xf
	ctx.r[5].s64 = 15;
	// 82193DAC: 388100E0  addi r4, r1, 0xe0
	ctx.r[4].s64 = ctx.r[1].s64 + 224;
	// 82193DB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193DB4: 4BF94D45  bl 0x82128af8
	ctx.lr = 0x82193DB8;
	sub_82128AF8(ctx, base);
	// 82193DB8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 82193DBC: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82193DC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193DC4: 4BF94D35  bl 0x82128af8
	ctx.lr = 0x82193DC8;
	sub_82128AF8(ctx, base);
	// 82193DC8: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 82193DCC: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82193DD0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82193DD4: 4BF94D25  bl 0x82128af8
	ctx.lr = 0x82193DD8;
	sub_82128AF8(ctx, base);
	// 82193DD8: C16100C4  lfs f11, 0xc4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(196 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82193DDC: C18100D4  lfs f12, 0xd4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(212 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82193DE0: 81760000  lwz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 82193DE4: C0E100E4  lfs f7, 0xe4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(228 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82193DE8: ED8C5828  fsubs f12, f12, f11
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[11].f64) as f32) as f64);
	// 82193DEC: ED6B3828  fsubs f11, f11, f7
	ctx.f[11].f64 = (((ctx.f[11].f64 - ctx.f[7].f64) as f32) as f64);
	// 82193DF0: C1A100C8  lfs f13, 0xc8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193DF4: C00100D8  lfs f0, 0xd8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193DF8: 7D6A8670  srawi r10, r11, 0x10
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 16) - 1)) != 0);
	ctx.r[10].s64 = (ctx.r[11].s32 >> 16) as i64;
	// 82193DFC: C10100E8  lfs f8, 0xe8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(232 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82193E00: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82193E04: C08100F4  lfs f4, 0xf4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(244 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82193E08: EDAD4028  fsubs f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 - ctx.f[8].f64) as f32) as f64);
	// 82193E0C: ECE72028  fsubs f7, f7, f4
	ctx.f[7].f64 = (((ctx.f[7].f64 - ctx.f[4].f64) as f32) as f64);
	// 82193E10: C0A100F8  lfs f5, 0xf8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(248 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 82193E14: C0410108  lfs f2, 0x108(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(264 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82193E18: ED082828  fsubs f8, f8, f5
	ctx.f[8].f64 = (((ctx.f[8].f64 - ctx.f[5].f64) as f32) as f64);
	// 82193E1C: C12100C0  lfs f9, 0xc0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82193E20: ECA51028  fsubs f5, f5, f2
	ctx.f[5].f64 = (((ctx.f[5].f64 - ctx.f[2].f64) as f32) as f64);
	// 82193E24: C14100D0  lfs f10, 0xd0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(208 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82193E28: 5569043E  clrlwi r9, r11, 0x10
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x0000FFFFu64;
	// 82193E2C: C0C100E0  lfs f6, 0xe0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(224 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82193E30: ED4A4828  fsubs f10, f10, f9
	ctx.f[10].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82193E34: ED8C0332  fmuls f12, f12, f12
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[12].f64) as f32) as f64);
	// 82193E38: C0410104  lfs f2, 0x104(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(260 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82193E3C: ED6B02F2  fmuls f11, f11, f11
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 82193E40: C06100F0  lfs f3, 0xf0(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(240 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82193E44: ED293028  fsubs f9, f9, f6
	ctx.f[9].f64 = (((ctx.f[9].f64 - ctx.f[6].f64) as f32) as f64);
	// 82193E48: 7D4A0194  addze r10, r10
	tmp.s64 = ctx.r[10].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[10].u32);
	ctx.r[10].s64 = tmp.s64;
	// 82193E4C: EC841028  fsubs f4, f4, f2
	ctx.f[4].f64 = (((ctx.f[4].f64 - ctx.f[2].f64) as f32) as f64);
	// 82193E50: C0410100  lfs f2, 0x100(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(256 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82193E54: ECC61828  fsubs f6, f6, f3
	ctx.f[6].f64 = (((ctx.f[6].f64 - ctx.f[3].f64) as f32) as f64);
	// 82193E58: EC631028  fsubs f3, f3, f2
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[2].f64) as f32) as f64);
	// 82193E5C: EC00603A  fmadds f0, f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 82193E60: EDAD5B7A  fmadds f13, f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64);
	// 82193E64: ED8701F2  fmuls f12, f7, f7
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[7].f64) as f32) as f64);
	// 82193E68: ED640132  fmuls f11, f4, f4
	ctx.f[11].f64 = (((ctx.f[4].f64 * ctx.f[4].f64) as f32) as f64);
	// 82193E6C: EC0A02BA  fmadds f0, f10, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 82193E70: EDA96A7A  fmadds f13, f9, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[9].f64 + ctx.f[13].f64) as f32) as f64);
	// 82193E74: ED88623A  fmadds f12, f8, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 82193E78: ED65597A  fmadds f11, f5, f5, f11
	ctx.f[11].f64 = (((ctx.f[5].f64 * ctx.f[5].f64 + ctx.f[11].f64) as f32) as f64);
	// 82193E7C: EC00002C  fsqrts f0, f0
	ctx.f[0].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 82193E80: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82193E84: ED8661BA  fmadds f12, f6, f6, f12
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[6].f64 + ctx.f[12].f64) as f32) as f64);
	// 82193E88: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82193E8C: EDA358FA  fmadds f13, f3, f3, f11
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[3].f64 + ctx.f[11].f64) as f32) as f64);
	// 82193E90: ED80602C  fsqrts f12, f12
	ctx.f[12].f64 = ((ctx.f[12].f64).sqrt() as f32) as f64;
	// 82193E94: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193E98: EC00602A  fadds f0, f0, f12
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 82193E9C: EDA0682C  fsqrts f13, f13
	ctx.f[13].f64 = ((ctx.f[13].f64).sqrt() as f32) as f64;
	// 82193EA0: 616BCEC4  ori r11, r11, 0xcec4
	ctx.r[11].u64 = ctx.r[11].u64 | 52932;
	// 82193EA4: EF40682A  fadds f26, f0, f13
	ctx.f[26].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82193EA8: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82193EAC: 2F0B0004  cmpwi cr6, r11, 4
	ctx.cr[6].compare_i32(ctx.r[11].s32, 4, &mut ctx.xer);
	// 82193EB0: 409A0014  bne cr6, 0x82193ec4
	if !ctx.cr[6].eq {
	pc = 0x82193EC4; continue 'dispatch;
	}
	// 82193EB4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82193EB8: 409A00C0  bne cr6, 0x82193f78
	if !ctx.cr[6].eq {
	pc = 0x82193F78; continue 'dispatch;
	}
	// 82193EBC: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82193EC0: 419A00C8  beq cr6, 0x82193f88
	if ctx.cr[6].eq {
	pc = 0x82193F88; continue 'dispatch;
	}
	pc = 0x82193EC4; continue 'dispatch;
            }
            0x82193EC4 => {
    //   block [0x82193EC4..0x82193EDC)
	// 82193EC4: 2F0B000C  cmpwi cr6, r11, 0xc
	ctx.cr[6].compare_i32(ctx.r[11].s32, 12, &mut ctx.xer);
	// 82193EC8: 409A0014  bne cr6, 0x82193edc
	if !ctx.cr[6].eq {
	pc = 0x82193EDC; continue 'dispatch;
	}
	// 82193ECC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82193ED0: 409A01B8  bne cr6, 0x82194088
	if !ctx.cr[6].eq {
	pc = 0x82194088; continue 'dispatch;
	}
	// 82193ED4: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82193ED8: 419A01C0  beq cr6, 0x82194098
	if ctx.cr[6].eq {
	pc = 0x82194098; continue 'dispatch;
	}
	pc = 0x82193EDC; continue 'dispatch;
            }
            0x82193EDC => {
    //   block [0x82193EDC..0x82193F78)
	// 82193EDC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82193EE0: D3E100B4  stfs f31, 0xb4(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82193EE4: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82193EE8: D38100A4  stfs f28, 0xa4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82193EEC: 396BCFF0  addi r11, r11, -0x3010
	ctx.r[11].s64 = ctx.r[11].s64 + -12304;
	// 82193EF0: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82193EF4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82193EF8: FDA0C890  fmr f13, f25
	ctx.f[13].f64 = ctx.f[25].f64;
	// 82193EFC: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 82193F00: FD80A090  fmr f12, f20
	ctx.f[12].f64 = ctx.f[20].f64;
	// 82193F04: FD40D890  fmr f10, f27
	ctx.f[10].f64 = ctx.f[27].f64;
	// 82193F08: FD20A890  fmr f9, f21
	ctx.f[9].f64 = ctx.f[21].f64;
	// 82193F0C: C00B029C  lfs f0, 0x29c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(668 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193F10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193F14: EC1A0032  fmuls f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193F18: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82193F1C: FCE0B090  fmr f7, f22
	ctx.f[7].f64 = ctx.f[22].f64;
	// 82193F20: FCA0C090  fmr f5, f24
	ctx.f[5].f64 = ctx.f[24].f64;
	// 82193F24: FC60B890  fmr f3, f23
	ctx.f[3].f64 = ctx.f[23].f64;
	// 82193F28: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193F2C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82193F30: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82193F34: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82193F38: 7C1C5C2E  lfsx f0, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193F3C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193F40: ED6007B2  fmuls f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193F44: C10B2378  lfs f8, 0x2378(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9080 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82193F48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193F4C: C0CB2B30  lfs f6, 0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11056 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82193F50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193F54: C08B2B2C  lfs f4, 0x2b2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11052 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82193F58: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82193F5C: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 82193F60: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82193F64: 4BFFCB5D  bl 0x82190ac0
	ctx.lr = 0x82193F68;
	sub_82190AC0(ctx, base);
	// 82193F68: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82193F6C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82193F70: 483A20A5  bl 0x82536014
	ctx.lr = 0x82193F74;
	sub_82535FFC(ctx, base);
	// 82193F74: 483A117C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82193F78 => {
    //   block [0x82193F78..0x82193F88)
	// 82193F78: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 82193F7C: 409AFF48  bne cr6, 0x82193ec4
	if !ctx.cr[6].eq {
	pc = 0x82193EC4; continue 'dispatch;
	}
	// 82193F80: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 82193F84: 409AFF40  bne cr6, 0x82193ec4
	if !ctx.cr[6].eq {
	pc = 0x82193EC4; continue 'dispatch;
	}
	pc = 0x82193F88; continue 'dispatch;
            }
            0x82193F88 => {
    //   block [0x82193F88..0x82194014)
	// 82193F88: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193F8C: EFE00772  fmuls f31, f0, f29
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82193F90: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82193F94: 4BF89535  bl 0x8211d4c8
	ctx.lr = 0x82193F98;
	sub_8211D4C8(ctx, base);
	// 82193F98: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193F9C: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82193FA0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82193FA4: 616A9B80  ori r10, r11, 0x9b80
	ctx.r[10].u64 = ctx.r[11].u64 | 39808;
	// 82193FA8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82193FAC: 7DBF542E  lfsx f13, r31, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193FB0: C3AB9F78  lfs f29, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82193FB4: EFE06F7A  fmadds f31, f0, f29, f13
	ctx.f[31].f64 = (((ctx.f[0].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82193FB8: 4BFBF301  bl 0x821532b8
	ctx.lr = 0x82193FBC;
	sub_821532B8(ctx, base);
	// 82193FBC: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82193FC0: C17E0000  lfs f11, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82193FC4: 2F180000  cmpwi cr6, r24, 0
	ctx.cr[6].compare_i32(ctx.r[24].s32, 0, &mut ctx.xer);
	// 82193FC8: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82193FCC: 7C1C5C2E  lfsx f0, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82193FD0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193FD4: C1AB2B28  lfs f13, 0x2b28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11048 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193FD8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82193FDC: ECA00372  fmuls f5, f0, f13
	ctx.f[5].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82193FE0: 616B9B88  ori r11, r11, 0x9b88
	ctx.r[11].u64 = ctx.r[11].u64 | 39816;
	// 82193FE4: 7DBF5C2E  lfsx f13, r31, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82193FE8: EDA16F7A  fmadds f13, f1, f29, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[29].f64 + ctx.f[13].f64) as f32) as f64);
	// 82193FEC: ED8507B2  fmuls f12, f5, f30
	ctx.f[12].f64 = (((ctx.f[5].f64 * ctx.f[30].f64) as f32) as f64);
	// 82193FF0: ED0C0032  fmuls f8, f12, f0
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82193FF4: 409A0020  bne cr6, 0x82194014
	if !ctx.cr[6].eq {
	pc = 0x82194014; continue 'dispatch;
	}
	// 82193FF8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82193FFC: C18B2B24  lfs f12, 0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82194000: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194004: ECC00332  fmuls f6, f0, f12
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82194008: C18B2850  lfs f12, 0x2850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219400C: EC6B6028  fsubs f3, f11, f12
	ctx.f[3].f64 = (((ctx.f[11].f64 - ctx.f[12].f64) as f32) as f64);
	// 82194010: 4800001C  b 0x8219402c
	pc = 0x8219402C; continue 'dispatch;
            }
            0x82194014 => {
    //   block [0x82194014..0x8219402C)
	// 82194014: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194018: C18B2B20  lfs f12, 0x2b20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11040 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219401C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194020: ECC00332  fmuls f6, f0, f12
	ctx.f[6].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82194024: C18B2850  lfs f12, 0x2850(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10320 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82194028: EC6B602A  fadds f3, f11, f12
	ctx.f[3].f64 = ((ctx.f[11].f64 + ctx.f[12].f64) as f32) as f64;
	pc = 0x8219402C; continue 'dispatch;
            }
            0x8219402C => {
    //   block [0x8219402C..0x82194088)
	// 8219402C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194030: ED8607B2  fmuls f12, f6, f30
	ctx.f[12].f64 = (((ctx.f[6].f64 * ctx.f[30].f64) as f32) as f64);
	// 82194034: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82194038: FD60F890  fmr f11, f31
	ctx.f[11].f64 = ctx.f[31].f64;
	// 8219403C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194040: 92E1008C  stw r23, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[23].u32 ) };
	// 82194044: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82194048: ECE007B2  fmuls f7, f0, f30
	ctx.f[7].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219404C: C14B1FF8  lfs f10, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82194050: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194054: 91410094  stw r10, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82194058: C08B2B1C  lfs f4, 0x2b1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11036 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219405C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194060: ED2C0032  fmuls f9, f12, f0
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82194064: FD80D090  fmr f12, f26
	ctx.f[12].f64 = ctx.f[26].f64;
	// 82194068: C04B21DC  lfs f2, 0x21dc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8668 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219406C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82194070: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82194074: 4BFFCBA5  bl 0x82190c18
	ctx.lr = 0x82194078;
	sub_82190C18(ctx, base);
	// 82194078: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8219407C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194080: 483A1F95  bl 0x82536014
	ctx.lr = 0x82194084;
	sub_82535FFC(ctx, base);
	// 82194084: 483A106C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194088 => {
    //   block [0x82194088..0x82194098)
	// 82194088: 2F0A0001  cmpwi cr6, r10, 1
	ctx.cr[6].compare_i32(ctx.r[10].s32, 1, &mut ctx.xer);
	// 8219408C: 409AFE50  bne cr6, 0x82193edc
	if !ctx.cr[6].eq {
	pc = 0x82193EDC; continue 'dispatch;
	}
	// 82194090: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 82194094: 409AFE48  bne cr6, 0x82193edc
	if !ctx.cr[6].eq {
	pc = 0x82193EDC; continue 'dispatch;
	}
	pc = 0x82194098; continue 'dispatch;
            }
            0x82194098 => {
    //   block [0x82194098..0x82194128)
	// 82194098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219409C: D3E100B4  stfs f31, 0xb4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821940A0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821940A4: D38100A4  stfs f28, 0xa4(r1)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821940A8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821940AC: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 821940B0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821940B4: FDA0C890  fmr f13, f25
	ctx.f[13].f64 = ctx.f[25].f64;
	// 821940B8: FD80A090  fmr f12, f20
	ctx.f[12].f64 = ctx.f[20].f64;
	// 821940BC: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821940C0: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821940C4: D00100AC  stfs f0, 0xac(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821940C8: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 821940CC: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 821940D0: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821940D4: FD40D890  fmr f10, f27
	ctx.f[10].f64 = ctx.f[27].f64;
	// 821940D8: FD20A890  fmr f9, f21
	ctx.f[9].f64 = ctx.f[21].f64;
	// 821940DC: FCE0B090  fmr f7, f22
	ctx.f[7].f64 = ctx.f[22].f64;
	// 821940E0: FCA0C090  fmr f5, f24
	ctx.f[5].f64 = ctx.f[24].f64;
	// 821940E4: 7C1C5C2E  lfsx f0, r28, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821940E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821940EC: ED6007B2  fmuls f11, f0, f30
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821940F0: FC60B890  fmr f3, f23
	ctx.f[3].f64 = ctx.f[23].f64;
	// 821940F4: C10B2378  lfs f8, 0x2378(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9080 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821940F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821940FC: C0CB2B30  lfs f6, 0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11056 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82194100: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194104: C08B2B2C  lfs f4, 0x2b2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11052 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82194108: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219410C: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	// 82194110: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82194114: 4BFFC9AD  bl 0x82190ac0
	ctx.lr = 0x82194118;
	sub_82190AC0(ctx, base);
	// 82194118: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8219411C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194120: 483A1EF5  bl 0x82536014
	ctx.lr = 0x82194124;
	sub_82535FFC(ctx, base);
	// 82194124: 483A0FCC  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194128 => {
    //   block [0x82194128..0x8219415C)
	// 82194128: 83BD0408  lwz r29, 0x408(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8219412C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194130: 3BCB06F0  addi r30, r11, 0x6f0
	ctx.r[30].s64 = ctx.r[11].s64 + 1776;
	// 82194134: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82194138: 409A0024  bne cr6, 0x8219415c
	if !ctx.cr[6].eq {
	pc = 0x8219415C; continue 'dispatch;
	}
	// 8219413C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82194140: 93EB0024  stw r31, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 82194144: 932B0028  stw r25, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[25].u32 ) };
	// 82194148: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 8219414C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194150: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194154: 483A1EC1  bl 0x82536014
	ctx.lr = 0x82194158;
	sub_82535FFC(ctx, base);
	// 82194158: 483A0F98  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219415C => {
    //   block [0x8219415C..0x821941CC)
	// 8219415C: 38A0002C  li r5, 0x2c
	ctx.r[5].s64 = 44;
	// 82194160: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194164: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194168: 483A1069  bl 0x825351d0
	ctx.lr = 0x8219416C;
	sub_825351D0(ctx, base);
	// 8219416C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194170: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82194174: 396B097C  addi r11, r11, 0x97c
	ctx.r[11].s64 = ctx.r[11].s64 + 2428;
	// 82194178: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219417C: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82194180: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82194184: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194188: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219418C: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82194190: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82194194: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194198: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219419C: 4E800421  bctrl
	ctx.lr = 0x821941A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821941A0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821941A4: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821941A8: 915E001C  stw r10, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821941AC: 93DD0014  stw r30, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821941B0: 93EB0024  stw r31, 0x24(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), ctx.r[31].u32 ) };
	// 821941B4: 932B0028  stw r25, 0x28(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), ctx.r[25].u32 ) };
	// 821941B8: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 821941BC: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821941C0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821941C4: 483A1E51  bl 0x82536014
	ctx.lr = 0x821941C8;
	sub_82535FFC(ctx, base);
	// 821941C8: 483A0F28  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821941CC => {
    //   block [0x821941CC..0x82194240)
	// 821941CC: 83DD0408  lwz r30, 0x408(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821941D0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821941D4: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 821941D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821941DC: 419A1470  beq cr6, 0x8219564c
	if ctx.cr[6].eq {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 821941E0: 38A00050  li r5, 0x50
	ctx.r[5].s64 = 80;
	// 821941E4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821941E8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821941EC: 483A0FE5  bl 0x825351d0
	ctx.lr = 0x821941F0;
	sub_825351D0(ctx, base);
	// 821941F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821941F4: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821941F8: 396B093C  addi r11, r11, 0x93c
	ctx.r[11].s64 = ctx.r[11].s64 + 2364;
	// 821941FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194200: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82194204: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82194208: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219420C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194210: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82194214: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82194218: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219421C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194220: 4E800421  bctrl
	ctx.lr = 0x82194224;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194224: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82194228: 917F001C  stw r11, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 8219422C: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 82194230: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194234: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194238: 483A1DDD  bl 0x82536014
	ctx.lr = 0x8219423C;
	sub_82535FFC(ctx, base);
	// 8219423C: 483A0EB4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194240 => {
    //   block [0x82194240..0x821942F4)
	// 82194240: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82194244: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194248: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 8219424C: 617F9BA0  ori r31, r11, 0x9ba0
	ctx.r[31].u64 = ctx.r[11].u64 | 39840;
	// 82194250: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82194254: 3B400002  li r26, 2
	ctx.r[26].s64 = 2;
	// 82194258: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 8219425C: 93630084  stw r27, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 82194260: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194264: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82194268: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219426C: 815C0000  lwz r10, 0(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194270: 617E9BA8  ori r30, r11, 0x9ba8
	ctx.r[30].u64 = ctx.r[11].u64 | 39848;
	// 82194274: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194278: 7DAAFC2E  lfsx f13, r10, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219427C: 7C0BFC2E  lfsx f0, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194280: EC406828  fsubs f2, f0, f13
	ctx.f[2].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82194284: 7D8BF42E  lfsx f12, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82194288: 7C0AF42E  lfsx f0, r10, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219428C: EC2C0028  fsubs f1, f12, f0
	ctx.f[1].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 82194290: 4839EC19  bl 0x82532ea8
	ctx.lr = 0x82194294;
	sub_82532EA8(ctx, base);
	// 82194294: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194298: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 8219429C: 7C0BFC2E  lfsx f0, r11, r31
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821942A0: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821942A4: 7DABFC2E  lfsx f13, r11, r31
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821942A8: 817C0004  lwz r11, 4(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821942AC: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 821942B0: 7D8BF42E  lfsx f12, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821942B4: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 821942B8: 7DABF42E  lfsx f13, r11, r30
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[30].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821942BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821942C0: EDAC682A  fadds f13, f12, f13
	ctx.f[13].f64 = ((ctx.f[12].f64 + ctx.f[13].f64) as f32) as f64;
	// 821942C4: FD800818  frsp f12, f1
	ctx.f[12].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821942C8: C3EBBFFC  lfs f31, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821942CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821942D0: EFC007F2  fmuls f30, f0, f31
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821942D4: C00B2254  lfs f0, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821942D8: EFAD07F2  fmuls f29, f13, f31
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 821942DC: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821942E0: FF800050  fneg f28, f0
	ctx.f[28].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821942E4: 409A0010  bne cr6, 0x821942f4
	if !ctx.cr[6].eq {
	pc = 0x821942F4; continue 'dispatch;
	}
	// 821942E8: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 821942EC: 4BFA4EC5  bl 0x821391b0
	ctx.lr = 0x821942F0;
	sub_821391B0(ctx, base);
	// 821942F0: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	pc = 0x821942F4; continue 'dispatch;
            }
            0x821942F4 => {
    //   block [0x821942F4..0x8219431C)
	// 821942F4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821942F8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821942FC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82194300: 614A93E2  ori r10, r10, 0x93e2
	ctx.r[10].u64 = ctx.r[10].u64 | 37858;
	// 82194304: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82194308: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219430C: 409A0010  bne cr6, 0x8219431c
	if !ctx.cr[6].eq {
	pc = 0x8219431C; continue 'dispatch;
	}
	// 82194310: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 82194314: 4BFA4E9D  bl 0x821391b0
	ctx.lr = 0x82194318;
	sub_821391B0(ctx, base);
	// 82194318: 3B430004  addi r26, r3, 4
	ctx.r[26].s64 = ctx.r[3].s64 + 4;
	pc = 0x8219431C; continue 'dispatch;
            }
            0x8219431C => {
    //   block [0x8219431C..0x82194338)
	// 8219431C: 83DD0408  lwz r30, 0x408(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194320: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194324: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82194328: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219432C: 409A000C  bne cr6, 0x82194338
	if !ctx.cr[6].eq {
	pc = 0x82194338; continue 'dispatch;
	}
	// 82194330: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82194334: 48000050  b 0x82194384
	pc = 0x82194384; continue 'dispatch;
            }
            0x82194338 => {
    //   block [0x82194338..0x82194384)
	// 82194338: 38A00060  li r5, 0x60
	ctx.r[5].s64 = 96;
	// 8219433C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194340: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194344: 483A0E8D  bl 0x825351d0
	ctx.lr = 0x82194348;
	sub_825351D0(ctx, base);
	// 82194348: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219434C: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 82194350: 396B091C  addi r11, r11, 0x91c
	ctx.r[11].s64 = ctx.r[11].s64 + 2332;
	// 82194354: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194358: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219435C: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 82194360: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194364: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194368: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 8219436C: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82194370: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194374: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194378: 4E800421  bctrl
	ctx.lr = 0x8219437C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219437C: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82194380: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
            }
            0x82194384 => {
    //   block [0x82194384..0x821943B4)
	// 82194384: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194388: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 8219438C: 83CB025C  lwz r30, 0x25c(r11)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(604 as u32) ) } as u64;
	// 82194390: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82194394: 419A0020  beq cr6, 0x821943b4
	if ctx.cr[6].eq {
	pc = 0x821943B4; continue 'dispatch;
	}
	// 82194398: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219439C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821943A0: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 821943A4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821943A8: 4E800421  bctrl
	ctx.lr = 0x821943AC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821943AC: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 821943B0: 419A0008  beq cr6, 0x821943b8
	if ctx.cr[6].eq {
	pc = 0x821943B8; continue 'dispatch;
	}
            }
            0x821943B4 => {
    //   block [0x821943B4..0x821943B8)
	// 821943B4: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	pc = 0x821943B8; continue 'dispatch;
            }
            0x821943B8 => {
    //   block [0x821943B8..0x821943F0)
	// 821943B8: 2B1A0005  cmplwi cr6, r26, 5
	ctx.cr[6].compare_u32(ctx.r[26].u32, 5 as u32, &mut ctx.xer);
	// 821943BC: 41991290  bgt cr6, 0x8219564c
	if ctx.cr[6].gt {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 821943C0: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 821943C4: 398C43D8  addi r12, r12, 0x43d8
	ctx.r[12].s64 = ctx.r[12].s64 + 17368;
	// 821943C8: 5740103A  slwi r0, r26, 2
	ctx.r[0].u32 = ctx.r[26].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 821943CC: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 821943D0: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 821943D4: 4E800420  bctr
	match ctx.r[26].u64 {
		0 => {
	pc = 0x821943F0; continue 'dispatch;
		},
		1 => {
	pc = 0x821943F0; continue 'dispatch;
		},
		2 => {
	pc = 0x821944B8; continue 'dispatch;
		},
		3 => {
	pc = 0x821944B8; continue 'dispatch;
		},
		4 => {
	pc = 0x82194570; continue 'dispatch;
		},
		5 => {
	pc = 0x82194570; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 821943D8: 821943F0  lwz r16, 0x43f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17392 as u32) ) } as u64;
	// 821943DC: 821943F0  lwz r16, 0x43f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17392 as u32) ) } as u64;
	// 821943E0: 821944B8  lwz r16, 0x44b8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17592 as u32) ) } as u64;
	// 821943E4: 821944B8  lwz r16, 0x44b8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17592 as u32) ) } as u64;
	// 821943E8: 82194570  lwz r16, 0x4570(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17776 as u32) ) } as u64;
	// 821943EC: 82194570  lwz r16, 0x4570(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(17776 as u32) ) } as u64;
            }
            0x821943F0 => {
    //   block [0x821943F0..0x82194464)
	// 821943F0: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821943F4: 813C0004  lwz r9, 4(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) } as u64;
	// 821943F8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821943FC: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 82194400: 616B9194  ori r11, r11, 0x9194
	ctx.r[11].u64 = ctx.r[11].u64 | 37268;
	// 82194404: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82194408: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219440C: 814A0040  lwz r10, 0x40(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82194410: 7C095C2E  lfsx f0, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194414: 813C0000  lwz r9, 0(r28)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194418: 7DA95C2E  lfsx f13, r9, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219441C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 82194420: EC4007F2  fmuls f2, f0, f31
	ctx.f[2].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82194424: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 82194428: 4E800421  bctrl
	ctx.lr = 0x8219442C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219442C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194430: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 82194434: C00B2138  lfs f0, 0x2138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194438: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219443C: D01E0070  stfs f0, 0x70(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82194440: C1AB2B18  lfs f13, 0x2b18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82194444: D1BE0050  stfs f13, 0x50(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82194448: 481EE311  bl 0x82382758
	ctx.lr = 0x8219444C;
	sub_82382758(ctx, base);
	// 8219444C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194450: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 82194454: C00B2B14  lfs f0, 0x2b14(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11028 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194458: 409A000C  bne cr6, 0x82194464
	if !ctx.cr[6].eq {
	pc = 0x82194464; continue 'dispatch;
	}
	// 8219445C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82194460: 48000008  b 0x82194468
	pc = 0x82194468; continue 'dispatch;
            }
            0x82194464 => {
    //   block [0x82194464..0x82194468)
	// 82194464: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82194468; continue 'dispatch;
            }
            0x82194468 => {
    //   block [0x82194468..0x821944B8)
	// 82194468: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219446C: D01E0054  stfs f0, 0x54(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82194470: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194474: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194478: D01E0058  stfs f0, 0x58(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219447C: 935F0058  stw r26, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82194480: D03F0034  stfs f1, 0x34(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82194484: 92FF0010  stw r23, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194488: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8219448C: 92FF0040  stw r23, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[23].u32 ) };
	// 82194490: C1AB2468  lfs f13, 0x2468(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82194494: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194498: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8219449C: C1AB20CC  lfs f13, 0x20cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821944A0: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 821944A4: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821944A8: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821944AC: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821944B0: 483A1B65  bl 0x82536014
	ctx.lr = 0x821944B4;
	sub_82535FFC(ctx, base);
	// 821944B4: 483A0C3C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821944B8 => {
    //   block [0x821944B8..0x82194514)
	// 821944B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821944BC: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821944C0: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 821944C4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821944C8: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 821944CC: C04B22F4  lfs f2, 0x22f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8948 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821944D0: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 821944D4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821944D8: 4E800421  bctrl
	ctx.lr = 0x821944DC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821944DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821944E0: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821944E4: C00B2138  lfs f0, 0x2138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821944E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821944EC: D01E0070  stfs f0, 0x70(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821944F0: C1AB2B18  lfs f13, 0x2b18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11032 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821944F4: D1BE0050  stfs f13, 0x50(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821944F8: 481EE261  bl 0x82382758
	ctx.lr = 0x821944FC;
	sub_82382758(ctx, base);
	// 821944FC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194500: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 82194504: C00B44A8  lfs f0, 0x44a8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17576 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194508: 409A000C  bne cr6, 0x82194514
	if !ctx.cr[6].eq {
	pc = 0x82194514; continue 'dispatch;
	}
	// 8219450C: EC01002A  fadds f0, f1, f0
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[0].f64) as f32) as f64;
	// 82194510: 48000008  b 0x82194518
	pc = 0x82194518; continue 'dispatch;
            }
            0x82194514 => {
    //   block [0x82194514..0x82194518)
	// 82194514: EC010028  fsubs f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 - ctx.f[0].f64) as f32) as f64);
	pc = 0x82194518; continue 'dispatch;
            }
            0x82194518 => {
    //   block [0x82194518..0x82194570)
	// 82194518: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219451C: D01E0054  stfs f0, 0x54(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82194520: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194524: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194528: D01E0058  stfs f0, 0x58(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219452C: 935F0058  stw r26, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 82194530: D01F0038  stfs f0, 0x38(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82194534: 92FF0010  stw r23, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194538: D03F0034  stfs f1, 0x34(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8219453C: 92FF0040  stw r23, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[23].u32 ) };
	// 82194540: C1AB2468  lfs f13, 0x2468(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9320 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82194544: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194548: D1BF0030  stfs f13, 0x30(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8219454C: C1AB2098  lfs f13, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82194550: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194554: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82194558: C00B24D0  lfs f0, 0x24d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219455C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82194560: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194564: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194568: 483A1AAD  bl 0x82536014
	ctx.lr = 0x8219456C;
	sub_82535FFC(ctx, base);
	// 8219456C: 483A0B84  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194570 => {
    //   block [0x82194570..0x821945B8)
	// 82194570: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194574: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194578: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 8219457C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194580: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 82194584: C04B22F4  lfs f2, 0x22f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8948 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82194588: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219458C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194590: 4E800421  bctrl
	ctx.lr = 0x82194594;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194594: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194598: 2F1A0004  cmpwi cr6, r26, 4
	ctx.cr[6].compare_i32(ctx.r[26].s32, 4, &mut ctx.xer);
	// 8219459C: C00B2138  lfs f0, 0x2138(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8504 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821945A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821945A4: D01E0070  stfs f0, 0x70(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821945A8: C14B24D0  lfs f10, 0x24d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9424 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821945AC: 409A000C  bne cr6, 0x821945b8
	if !ctx.cr[6].eq {
	pc = 0x821945B8; continue 'dispatch;
	}
	// 821945B0: D15E0050  stfs f10, 0x50(r30)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821945B4: 48000010  b 0x821945c4
	pc = 0x821945C4; continue 'dispatch;
            }
            0x821945B8 => {
    //   block [0x821945B8..0x821945C4)
	// 821945B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821945BC: C00B2B18  lfs f0, 0x2b18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11032 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821945C0: D01E0050  stfs f0, 0x50(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x821945C4; continue 'dispatch;
            }
            0x821945C4 => {
    //   block [0x821945C4..0x82194620)
	// 821945C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821945C8: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821945CC: 396B1FF8  addi r11, r11, 0x1ff8
	ctx.r[11].s64 = ctx.r[11].s64 + 8184;
	// 821945D0: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821945D4: D17E0058  stfs f11, 0x58(r30)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821945D8: 481EE181  bl 0x82382758
	ctx.lr = 0x821945DC;
	sub_82382758(ctx, base);
	// 821945DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821945E0: D03E0054  stfs f1, 0x54(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821945E4: D03F0034  stfs f1, 0x34(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 821945E8: 935F0058  stw r26, 0x58(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), ctx.r[26].u32 ) };
	// 821945EC: D17F0038  stfs f11, 0x38(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 821945F0: 92FF0010  stw r23, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 821945F4: D15F0048  stfs f10, 0x48(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 821945F8: 92FF0040  stw r23, 0x40(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[23].u32 ) };
	// 821945FC: C00B2468  lfs f0, 0x2468(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9320 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194600: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194604: D01F0030  stfs f0, 0x30(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82194608: C1AB2098  lfs f13, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219460C: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82194610: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194614: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194618: 483A19FD  bl 0x82536014
	ctx.lr = 0x8219461C;
	sub_82535FFC(ctx, base);
	// 8219461C: 483A0AD4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194620 => {
    //   block [0x82194620..0x82194660)
	// 82194620: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194624: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194628: 4BFA48E1  bl 0x82138f08
	ctx.lr = 0x8219462C;
	sub_82138F08(ctx, base);
	// 8219462C: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82194630: 92E30228  stw r23, 0x228(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(552 as u32), ctx.r[23].u32 ) };
	// 82194634: 92E30230  stw r23, 0x230(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), ctx.r[23].u32 ) };
	// 82194638: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8219463C: 4BFF5BC5  bl 0x8218a200
	ctx.lr = 0x82194640;
	sub_8218A200(ctx, base);
	// 82194640: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194644: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194648: 4BFF5121  bl 0x82189768
	ctx.lr = 0x8219464C;
	sub_82189768(ctx, base);
	// 8219464C: 92E3001C  stw r23, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[23].u32 ) };
	// 82194650: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194654: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194658: 483A19BD  bl 0x82536014
	ctx.lr = 0x8219465C;
	sub_82535FFC(ctx, base);
	// 8219465C: 483A0A94  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194660 => {
    //   block [0x82194660..0x821946AC)
	// 82194660: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82194664: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194668: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 8219466C: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194670: 91430078  stw r10, 0x78(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(120 as u32), ctx.r[10].u32 ) };
	// 82194674: D0030088  stfs f0, 0x88(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82194678: 93630084  stw r27, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 8219467C: 83BD0408  lwz r29, 0x408(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194680: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194684: 3BCB06F0  addi r30, r11, 0x6f0
	ctx.r[30].s64 = ctx.r[11].s64 + 1776;
	// 82194688: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219468C: 409A0020  bne cr6, 0x821946ac
	if !ctx.cr[6].eq {
	pc = 0x821946AC; continue 'dispatch;
	}
	// 82194690: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82194694: 93EB00D0  stw r31, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 82194698: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 8219469C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821946A0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821946A4: 483A1971  bl 0x82536014
	ctx.lr = 0x821946A8;
	sub_82535FFC(ctx, base);
	// 821946A8: 483A0A48  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821946AC => {
    //   block [0x821946AC..0x82194714)
	// 821946AC: 38A000E0  li r5, 0xe0
	ctx.r[5].s64 = 224;
	// 821946B0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821946B4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821946B8: 483A0B19  bl 0x825351d0
	ctx.lr = 0x821946BC;
	sub_825351D0(ctx, base);
	// 821946BC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821946C0: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821946C4: 396B094C  addi r11, r11, 0x94c
	ctx.r[11].s64 = ctx.r[11].s64 + 2380;
	// 821946C8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821946CC: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821946D0: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821946D4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821946D8: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821946DC: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821946E0: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821946E4: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821946E8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821946EC: 4E800421  bctrl
	ctx.lr = 0x821946F0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821946F0: 7FCBF378  mr r11, r30
	ctx.r[11].u64 = ctx.r[30].u64;
	// 821946F4: 937E001C  stw r27, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 821946F8: 93DD0014  stw r30, 0x14(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(20 as u32), ctx.r[30].u32 ) };
	// 821946FC: 93EB00D0  stw r31, 0xd0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(208 as u32), ctx.r[31].u32 ) };
	// 82194700: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194704: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194708: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219470C: 483A1909  bl 0x82536014
	ctx.lr = 0x82194710;
	sub_82535FFC(ctx, base);
	// 82194710: 483A09E0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194714 => {
    //   block [0x82194714..0x82194758)
	// 82194714: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 82194718: 409A0040  bne cr6, 0x82194758
	if !ctx.cr[6].eq {
	pc = 0x82194758; continue 'dispatch;
	}
	// 8219471C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 82194720: 616B7E1C  ori r11, r11, 0x7e1c
	ctx.r[11].u64 = ctx.r[11].u64 | 32284;
	// 82194724: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82194728: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219472C: 419A002C  beq cr6, 0x82194758
	if ctx.cr[6].eq {
	pc = 0x82194758; continue 'dispatch;
	}
	// 82194730: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82194734: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194738: 4BFF5399  bl 0x82189ad0
	ctx.lr = 0x8219473C;
	sub_82189AD0(ctx, base);
	// 8219473C: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 82194740: 93E301A0  stw r31, 0x1a0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(416 as u32), ctx.r[31].u32 ) };
	// 82194744: 91630010  stw r11, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u32 ) };
	// 82194748: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8219474C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194750: 483A18C5  bl 0x82536014
	ctx.lr = 0x82194754;
	sub_82535FFC(ctx, base);
	// 82194754: 483A099C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194758 => {
    //   block [0x82194758..0x82194784)
	// 82194758: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 8219475C: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82194760: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82194764: 914B002C  stw r10, 0x2c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(44 as u32), ctx.r[10].u32 ) };
	// 82194768: 83BD0408  lwz r29, 0x408(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8219476C: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194770: 3BCB0B90  addi r30, r11, 0xb90
	ctx.r[30].s64 = ctx.r[11].s64 + 2960;
	// 82194774: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82194778: 409A000C  bne cr6, 0x82194784
	if !ctx.cr[6].eq {
	pc = 0x82194784; continue 'dispatch;
	}
	// 8219477C: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 82194780: 48000050  b 0x821947d0
	pc = 0x821947D0; continue 'dispatch;
            }
            0x82194784 => {
    //   block [0x82194784..0x821947D0)
	// 82194784: 38A00030  li r5, 0x30
	ctx.r[5].s64 = 48;
	// 82194788: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219478C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194790: 483A0A41  bl 0x825351d0
	ctx.lr = 0x82194794;
	sub_825351D0(ctx, base);
	// 82194794: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194798: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 8219479C: 396B095C  addi r11, r11, 0x95c
	ctx.r[11].s64 = ctx.r[11].s64 + 2396;
	// 821947A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821947A4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821947A8: 915E0004  stw r10, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821947AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821947B0: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821947B4: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821947B8: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821947BC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821947C0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821947C4: 4E800421  bctrl
	ctx.lr = 0x821947C8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821947C8: 937E001C  stw r27, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 821947CC: 93DD001C  stw r30, 0x1c(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(28 as u32), ctx.r[30].u32 ) };
            }
            0x821947D0 => {
    //   block [0x821947D0..0x821947FC)
	// 821947D0: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 821947D4: 409A0034  bne cr6, 0x82194808
	if !ctx.cr[6].eq {
	pc = 0x82194808; continue 'dispatch;
	}
	// 821947D8: 38600003  li r3, 3
	ctx.r[3].s64 = 3;
	// 821947DC: 4BFA49D5  bl 0x821391b0
	ctx.lr = 0x821947E0;
	sub_821391B0(ctx, base);
	// 821947E0: 2B030001  cmplwi cr6, r3, 1
	ctx.cr[6].compare_u32(ctx.r[3].u32, 1 as u32, &mut ctx.xer);
	// 821947E4: 41980020  blt cr6, 0x82194804
	if ctx.cr[6].lt {
	pc = 0x82194804; continue 'dispatch;
	}
	// 821947E8: 419A0014  beq cr6, 0x821947fc
	if ctx.cr[6].eq {
	pc = 0x821947FC; continue 'dispatch;
	}
	// 821947EC: 2B030003  cmplwi cr6, r3, 3
	ctx.cr[6].compare_u32(ctx.r[3].u32, 3 as u32, &mut ctx.xer);
	// 821947F0: 40980018  bge cr6, 0x82194808
	if !ctx.cr[6].lt {
	pc = 0x82194808; continue 'dispatch;
	}
	// 821947F4: 3B200009  li r25, 9
	ctx.r[25].s64 = 9;
	// 821947F8: 48000010  b 0x82194808
	pc = 0x82194808; continue 'dispatch;
            }
            0x821947FC => {
    //   block [0x821947FC..0x82194804)
	// 821947FC: 3B200008  li r25, 8
	ctx.r[25].s64 = 8;
	// 82194800: 48000008  b 0x82194808
	pc = 0x82194808; continue 'dispatch;
            }
            0x82194804 => {
    //   block [0x82194804..0x82194808)
	// 82194804: 3B200003  li r25, 3
	ctx.r[25].s64 = 3;
	pc = 0x82194808; continue 'dispatch;
            }
            0x82194808 => {
    //   block [0x82194808..0x8219482C)
	// 82194808: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219480C: 616BCEC4  ori r11, r11, 0xcec4
	ctx.r[11].u64 = ctx.r[11].u64 | 52932;
	// 82194810: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 82194814: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 82194818: 409A0014  bne cr6, 0x8219482c
	if !ctx.cr[6].eq {
	pc = 0x8219482C; continue 'dispatch;
	}
	// 8219481C: 2F190003  cmpwi cr6, r25, 3
	ctx.cr[6].compare_i32(ctx.r[25].s32, 3, &mut ctx.xer);
	// 82194820: 409A000C  bne cr6, 0x8219482c
	if !ctx.cr[6].eq {
	pc = 0x8219482C; continue 'dispatch;
	}
	// 82194824: 3B200009  li r25, 9
	ctx.r[25].s64 = 9;
	// 82194828: 48000010  b 0x82194838
	pc = 0x82194838; continue 'dispatch;
            }
            0x8219482C => {
    //   block [0x8219482C..0x82194838)
	// 8219482C: 2F190013  cmpwi cr6, r25, 0x13
	ctx.cr[6].compare_i32(ctx.r[25].s32, 19, &mut ctx.xer);
	// 82194830: 40990008  ble cr6, 0x82194838
	if !ctx.cr[6].gt {
	pc = 0x82194838; continue 'dispatch;
	}
	// 82194834: 7F79DB78  mr r25, r27
	ctx.r[25].u64 = ctx.r[27].u64;
	pc = 0x82194838; continue 'dispatch;
            }
            0x82194838 => {
    //   block [0x82194838..0x82194848)
	// 82194838: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 8219483C: 419A000C  beq cr6, 0x82194848
	if ctx.cr[6].eq {
	pc = 0x82194848; continue 'dispatch;
	}
	// 82194840: 7ECAB378  mr r10, r22
	ctx.r[10].u64 = ctx.r[22].u64;
	// 82194844: 4800000C  b 0x82194850
	pc = 0x82194850; continue 'dispatch;
            }
            0x82194848 => {
    //   block [0x82194848..0x82194850)
	// 82194848: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219484C: 394B6150  addi r10, r11, 0x6150
	ctx.r[10].s64 = ctx.r[11].s64 + 24912;
	pc = 0x82194850; continue 'dispatch;
            }
            0x82194850 => {
    //   block [0x82194850..0x82194878)
	// 82194850: 1D790034  mulli r11, r25, 0x34
	ctx.r[11].s32 = ((ctx.r[25].s32 as i64 * 52 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82194854: 93FE0028  stw r31, 0x28(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(40 as u32), ctx.r[31].u32 ) };
	// 82194858: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219485C: 933E002C  stw r25, 0x2c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(44 as u32), ctx.r[25].u32 ) };
	// 82194860: 92FE0010  stw r23, 0x10(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194864: 917E0024  stw r11, 0x24(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(36 as u32), ctx.r[11].u32 ) };
	// 82194868: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 8219486C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194870: 483A17A5  bl 0x82536014
	ctx.lr = 0x82194874;
	sub_82535FFC(ctx, base);
	// 82194874: 483A087C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194878 => {
    //   block [0x82194878..0x821948A4)
	// 82194878: 83DD0408  lwz r30, 0x408(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 8219487C: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194880: 3BEB06F0  addi r31, r11, 0x6f0
	ctx.r[31].s64 = ctx.r[11].s64 + 1776;
	// 82194884: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194888: 409A001C  bne cr6, 0x821948a4
	if !ctx.cr[6].eq {
	pc = 0x821948A4; continue 'dispatch;
	}
	// 8219488C: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82194890: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194894: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194898: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219489C: 483A1779  bl 0x82536014
	ctx.lr = 0x821948A0;
	sub_82535FFC(ctx, base);
	// 821948A0: 483A0850  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821948A4 => {
    //   block [0x821948A4..0x8219490C)
	// 821948A4: 38A00034  li r5, 0x34
	ctx.r[5].s64 = 52;
	// 821948A8: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821948AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821948B0: 483A0921  bl 0x825351d0
	ctx.lr = 0x821948B4;
	sub_825351D0(ctx, base);
	// 821948B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821948B8: 39400003  li r10, 3
	ctx.r[10].s64 = 3;
	// 821948BC: 396B096C  addi r11, r11, 0x96c
	ctx.r[11].s64 = ctx.r[11].s64 + 2412;
	// 821948C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821948C4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821948C8: 915F0004  stw r10, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821948CC: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821948D0: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 821948D4: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 821948D8: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821948DC: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821948E0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821948E4: 4E800421  bctrl
	ctx.lr = 0x821948E8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821948E8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821948EC: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 821948F0: 915F001C  stw r10, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u32 ) };
	// 821948F4: 93FE0014  stw r31, 0x14(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[31].u32 ) };
	// 821948F8: 92EB0010  stw r23, 0x10(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 821948FC: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194900: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194904: 483A1711  bl 0x82536014
	ctx.lr = 0x82194908;
	sub_82535FFC(ctx, base);
	// 82194908: 483A07E8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219490C => {
    //   block [0x8219490C..0x8219493C)
	// 8219490C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194910: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194914: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194918: C02B1FF8  lfs f1, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219491C: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194920: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82194924: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194928: 4E800421  bctrl
	ctx.lr = 0x8219492C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219492C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194930: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194934: 483A16E1  bl 0x82536014
	ctx.lr = 0x82194938;
	sub_82535FFC(ctx, base);
	// 82194938: 483A07B8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219493C => {
    //   block [0x8219493C..0x8219496C)
	// 8219493C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82194940: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82194944: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 82194948: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 8219494C: 409A0020  bne cr6, 0x8219496c
	if !ctx.cr[6].eq {
	pc = 0x8219496C; continue 'dispatch;
	}
	// 82194950: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194954: 39400013  li r10, 0x13
	ctx.r[10].s64 = 19;
	// 82194958: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8219495C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194960: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194964: 483A16B1  bl 0x82536014
	ctx.lr = 0x82194968;
	sub_82535FFC(ctx, base);
	// 82194968: 483A0788  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219496C => {
    //   block [0x8219496C..0x8219499C)
	// 8219496C: 5746043E  clrlwi r6, r26, 0x10
	ctx.r[6].u64 = ctx.r[26].u32 as u64 & 0x0000FFFFu64;
	// 82194970: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194974: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 82194978: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219497C: 4BFF64BD  bl 0x8218ae38
	ctx.lr = 0x82194980;
	sub_8218AE38(ctx, base);
	// 82194980: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194984: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 82194988: 914B0030  stw r10, 0x30(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8219498C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194990: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194994: 483A1681  bl 0x82536014
	ctx.lr = 0x82194998;
	sub_82535FFC(ctx, base);
	// 82194998: 483A0758  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219499C => {
    //   block [0x8219499C..0x821949B8)
	// 8219499C: 83BD0408  lwz r29, 0x408(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821949A0: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821949A4: 3BCB0250  addi r30, r11, 0x250
	ctx.r[30].s64 = ctx.r[11].s64 + 592;
	// 821949A8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821949AC: 409A000C  bne cr6, 0x821949b8
	if !ctx.cr[6].eq {
	pc = 0x821949B8; continue 'dispatch;
	}
	// 821949B0: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 821949B4: 48000054  b 0x82194a08
	pc = 0x82194A08; continue 'dispatch;
            }
            0x821949B8 => {
    //   block [0x821949B8..0x82194A08)
	// 821949B8: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 821949BC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 821949C0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821949C4: 483A080D  bl 0x825351d0
	ctx.lr = 0x821949C8;
	sub_825351D0(ctx, base);
	// 821949C8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821949CC: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 821949D0: 396B0840  addi r11, r11, 0x840
	ctx.r[11].s64 = ctx.r[11].s64 + 2112;
	// 821949D4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821949D8: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821949DC: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 821949E0: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821949E4: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 821949E8: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 821949EC: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 821949F0: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821949F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821949F8: 4E800421  bctrl
	ctx.lr = 0x821949FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821949FC: 937E001C  stw r27, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82194A00: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194A04: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
            }
            0x82194A08 => {
    //   block [0x82194A08..0x82194A4C)
	// 82194A08: 7B4B0020  clrldi r11, r26, 0x20
	ctx.r[11].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 82194A0C: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194A10: 93230060  stw r25, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[25].u32 ) };
	// 82194A14: 92C3005C  stw r22, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 82194A18: 93E30068  stw r31, 0x68(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), ctx.r[31].u32 ) };
	// 82194A1C: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 82194A20: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 82194A24: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82194A28: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 82194A2C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82194A30: D0030064  stfs f0, 0x64(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82194A34: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194A38: 4E800421  bctrl
	ctx.lr = 0x82194A3C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194A3C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194A40: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194A44: 483A15D1  bl 0x82536014
	ctx.lr = 0x82194A48;
	sub_82535FFC(ctx, base);
	// 82194A48: 483A06A8  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194A4C => {
    //   block [0x82194A4C..0x82194A7C)
	// 82194A4C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194A50: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194A54: 4BFF4DAD  bl 0x82189800
	ctx.lr = 0x82194A58;
	sub_82189800(ctx, base);
	// 82194A58: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 82194A5C: 816BA0CC  lwz r11, -0x5f34(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24372 as u32) ) } as u64;
	// 82194A60: 92E30010  stw r23, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194A64: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82194A68: 916301A4  stw r11, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[11].u32 ) };
	// 82194A6C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194A70: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194A74: 483A15A1  bl 0x82536014
	ctx.lr = 0x82194A78;
	sub_82535FFC(ctx, base);
	// 82194A78: 483A0678  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194A7C => {
    //   block [0x82194A7C..0x82194B4C)
	// 82194A7C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194A80: 815D0404  lwz r10, 0x404(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194A84: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82194A88: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82194A8C: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82194A90: 816A0028  lwz r11, 0x28(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194A94: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82194A98: 92EB0250  stw r23, 0x250(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(592 as u32), ctx.r[23].u32 ) };
	// 82194A9C: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194AA0: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194AA4: 92EB0254  stw r23, 0x254(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(596 as u32), ctx.r[23].u32 ) };
	// 82194AA8: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194AAC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194AB0: 92EB0260  stw r23, 0x260(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(608 as u32), ctx.r[23].u32 ) };
	// 82194AB4: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194AB8: 4BFCEF11  bl 0x821639c8
	ctx.lr = 0x82194ABC;
	sub_821639C8(ctx, base);
	// 82194ABC: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194AC0: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82194AC4: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 82194AC8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194ACC: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 82194AD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194AD4: 4E800421  bctrl
	ctx.lr = 0x82194AD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194AD8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 82194ADC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194AE0: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194AE4: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82194AE8: 4BFF53E9  bl 0x82189ed0
	ctx.lr = 0x82194AEC;
	sub_82189ED0(ctx, base);
	// 82194AEC: D3E301C8  stfs f31, 0x1c8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(456 as u32), tmp.u32 ) };
	// 82194AF0: D3E30058  stfs f31, 0x58(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82194AF4: 92E301C0  stw r23, 0x1c0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(448 as u32), ctx.r[23].u32 ) };
	// 82194AF8: D3E300E0  stfs f31, 0xe0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 82194AFC: D3E300E4  stfs f31, 0xe4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 82194B00: D3E300E8  stfs f31, 0xe8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 82194B04: 83DD0404  lwz r30, 0x404(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194B08: D3E30238  stfs f31, 0x238(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(568 as u32), tmp.u32 ) };
	// 82194B0C: D3E30234  stfs f31, 0x234(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(564 as u32), tmp.u32 ) };
	// 82194B10: D3E30230  stfs f31, 0x230(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), tmp.u32 ) };
	// 82194B14: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194B18: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194B1C: 83FE001C  lwz r31, 0x1c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82194B20: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194B24: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194B28: 4E800421  bctrl
	ctx.lr = 0x82194B2C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194B2C: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82194B30: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194B34: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194B38: 483A0699  bl 0x825351d0
	ctx.lr = 0x82194B3C;
	sub_825351D0(ctx, base);
	// 82194B3C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194B40: 409A000C  bne cr6, 0x82194b4c
	if !ctx.cr[6].eq {
	pc = 0x82194B4C; continue 'dispatch;
	}
	// 82194B44: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82194B48: 48000070  b 0x82194bb8
	pc = 0x82194BB8; continue 'dispatch;
            }
            0x82194B4C => {
    //   block [0x82194B4C..0x82194BB8)
	// 82194B4C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194B50: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194B54: 396BFA10  addi r11, r11, -0x5f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1520;
	// 82194B58: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82194B5C: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82194B60: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82194B64: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194B68: 4E800421  bctrl
	ctx.lr = 0x82194B6C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194B6C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194B70: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194B74: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194B78: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194B7C: 4E800421  bctrl
	ctx.lr = 0x82194B80;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194B80: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194B84: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194B88: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194B8C: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194B90: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194B94: 4E800421  bctrl
	ctx.lr = 0x82194B98;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194B98: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194B9C: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82194BA0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82194BA4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82194BA8: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82194BAC: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82194BB0: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194BB4: 93EB0264  stw r31, 0x264(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(612 as u32), ctx.r[31].u32 ) };
            }
            0x82194BB8 => {
    //   block [0x82194BB8..0x82194C04)
	// 82194BB8: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 82194BBC: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194BC0: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82194BC4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194BC8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82194BCC: C04B9F78  lfs f2, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82194BD0: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82194BD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194BD8: 4E800421  bctrl
	ctx.lr = 0x82194BDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194BDC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82194BE0: D3FF0050  stfs f31, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82194BE4: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82194BE8: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82194BEC: C00BD564  lfs f0, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194BF0: D01F0070  stfs f0, 0x70(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82194BF4: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194BF8: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194BFC: 483A1419  bl 0x82536014
	ctx.lr = 0x82194C00;
	sub_82535FFC(ctx, base);
	// 82194C00: 483A04F0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194C04 => {
    //   block [0x82194C04..0x82194C30)
	// 82194C04: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C08: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194C0C: 92EB004C  stw r23, 0x4c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(76 as u32), ctx.r[23].u32 ) };
	// 82194C10: 92EB0050  stw r23, 0x50(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), ctx.r[23].u32 ) };
	// 82194C14: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C18: 4BFF4C79  bl 0x82189890
	ctx.lr = 0x82194C1C;
	sub_82189890(ctx, base);
	// 82194C1C: 92E30010  stw r23, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194C20: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194C24: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194C28: 483A13ED  bl 0x82536014
	ctx.lr = 0x82194C2C;
	sub_82535FFC(ctx, base);
	// 82194C2C: 483A04C4  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194C30 => {
    //   block [0x82194C30..0x82194C68)
	// 82194C30: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C34: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194C38: 92EB0064  stw r23, 0x64(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(100 as u32), ctx.r[23].u32 ) };
	// 82194C3C: 92EB0068  stw r23, 0x68(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(104 as u32), ctx.r[23].u32 ) };
	// 82194C40: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C44: 4BFF4D6D  bl 0x821899b0
	ctx.lr = 0x82194C48;
	sub_821899B0(ctx, base);
	// 82194C48: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194C4C: 92E30010  stw r23, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194C50: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194C54: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82194C58: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194C5C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194C60: 483A13B5  bl 0x82536014
	ctx.lr = 0x82194C64;
	sub_82535FFC(ctx, base);
	// 82194C64: 483A048C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194C68 => {
    //   block [0x82194C68..0x82194D0C)
	// 82194C68: 817D0408  lwz r11, 0x408(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C6C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194C70: 92EB0058  stw r23, 0x58(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), ctx.r[23].u32 ) };
	// 82194C74: 92EB005C  stw r23, 0x5c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), ctx.r[23].u32 ) };
	// 82194C78: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194C7C: 4BFF4CA5  bl 0x82189920
	ctx.lr = 0x82194C80;
	sub_82189920(ctx, base);
	// 82194C80: 3D7F0002  addis r11, r31, 2
	ctx.r[11].s64 = ctx.r[31].s64 + 131072;
	// 82194C84: 93E301A4  stw r31, 0x1a4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(420 as u32), ctx.r[31].u32 ) };
	// 82194C88: 92E30010  stw r23, 0x10(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[23].u32 ) };
	// 82194C8C: 39230030  addi r9, r3, 0x30
	ctx.r[9].s64 = ctx.r[3].s64 + 48;
	// 82194C90: 396B9B80  addi r11, r11, -0x6480
	ctx.r[11].s64 = ctx.r[11].s64 + -25728;
	// 82194C94: 3D5F0002  addis r10, r31, 2
	ctx.r[10].s64 = ctx.r[31].s64 + 131072;
	// 82194C98: 39030040  addi r8, r3, 0x40
	ctx.r[8].s64 = ctx.r[3].s64 + 64;
	// 82194C9C: 394A9B70  addi r10, r10, -0x6490
	ctx.r[10].s64 = ctx.r[10].s64 + -25744;
	// 82194CA0: E8EB0000  ld r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82194CA4: F8E90000  std r7, 0(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[7].u64 ) };
	// 82194CA8: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82194CAC: F9690008  std r11, 8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82194CB0: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82194CB4: F9680000  std r11, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82194CB8: E96A0008  ld r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82194CBC: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82194CC0: 83DD0404  lwz r30, 0x404(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194CC4: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194CC8: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194CCC: 83FE001C  lwz r31, 0x1c(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(28 as u32) ) } as u64;
	// 82194CD0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194CD4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194CD8: 4E800421  bctrl
	ctx.lr = 0x82194CDC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194CDC: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82194CE0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194CE4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194CE8: 483A04E9  bl 0x825351d0
	ctx.lr = 0x82194CEC;
	sub_825351D0(ctx, base);
	// 82194CEC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82194CF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194CF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194CF8: 3B8BFA10  addi r28, r11, -0x5f0
	ctx.r[28].s64 = ctx.r[11].s64 + -1520;
	// 82194CFC: CBEA2008  lfd f31, 0x2008(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8200 as u32) ) };
	// 82194D00: 409A000C  bne cr6, 0x82194d0c
	if !ctx.cr[6].eq {
	pc = 0x82194D0C; continue 'dispatch;
	}
	// 82194D04: 7EEBBB78  mr r11, r23
	ctx.r[11].u64 = ctx.r[23].u64;
	// 82194D08: 48000064  b 0x82194d6c
	pc = 0x82194D6C; continue 'dispatch;
            }
            0x82194D0C => {
    //   block [0x82194D0C..0x82194D6C)
	// 82194D0C: 578B003E  slwi r11, r28, 0
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82194D10: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82194D14: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194D18: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82194D1C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194D20: 4E800421  bctrl
	ctx.lr = 0x82194D24;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194D24: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194D28: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194D2C: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194D30: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194D34: 4E800421  bctrl
	ctx.lr = 0x82194D38;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194D38: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194D3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194D40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194D44: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194D48: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194D4C: 4E800421  bctrl
	ctx.lr = 0x82194D50;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194D50: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 82194D54: FC00F818  frsp f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[31].f64 as f32) as f64;
	// 82194D58: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82194D5C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	// 82194D60: 915F0140  stw r10, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[10].u32 ) };
	// 82194D64: 815E0028  lwz r10, 0x28(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194D68: 93EA0264  stw r31, 0x264(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(612 as u32), ctx.r[31].u32 ) };
            }
            0x82194D6C => {
    //   block [0x82194D6C..0x82194DC0)
	// 82194D6C: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 82194D70: 92EB0148  stw r23, 0x148(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(328 as u32), ctx.r[23].u32 ) };
	// 82194D74: C00AD4D4  lfs f0, -0x2b2c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11052 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194D78: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 82194D7C: D00B0078  stfs f0, 0x78(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82194D80: 914B0074  stw r10, 0x74(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(116 as u32), ctx.r[10].u32 ) };
	// 82194D84: 83DD0404  lwz r30, 0x404(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194D88: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194D8C: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194D90: 83FE0024  lwz r31, 0x24(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82194D94: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194D98: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194D9C: 4E800421  bctrl
	ctx.lr = 0x82194DA0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194DA0: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82194DA4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194DA8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194DAC: 483A0425  bl 0x825351d0
	ctx.lr = 0x82194DB0;
	sub_825351D0(ctx, base);
	// 82194DB0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194DB4: 409A000C  bne cr6, 0x82194dc0
	if !ctx.cr[6].eq {
	pc = 0x82194DC0; continue 'dispatch;
	}
	// 82194DB8: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82194DBC: 48000060  b 0x82194e1c
	pc = 0x82194E1C; continue 'dispatch;
            }
            0x82194DC0 => {
    //   block [0x82194DC0..0x82194E1C)
	// 82194DC0: 578B003E  slwi r11, r28, 0
	ctx.r[11].u32 = ctx.r[28].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82194DC4: 939F0000  stw r28, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[28].u32 ) };
	// 82194DC8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194DCC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82194DD0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194DD4: 4E800421  bctrl
	ctx.lr = 0x82194DD8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194DD8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194DDC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194DE0: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194DE4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194DE8: 4E800421  bctrl
	ctx.lr = 0x82194DEC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194DEC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194DF0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194DF4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194DF8: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194DFC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194E00: 4E800421  bctrl
	ctx.lr = 0x82194E04;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194E04: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82194E08: FC00F818  frsp f0, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[31].f64 as f32) as f64;
	// 82194E0C: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82194E10: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82194E14: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194E18: 93EB026C  stw r31, 0x26c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(620 as u32), ctx.r[31].u32 ) };
            }
            0x82194E1C => {
    //   block [0x82194E1C..0x82194E48)
	// 82194E1C: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194E20: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194E24: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194E28: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194E2C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194E30: 4E800421  bctrl
	ctx.lr = 0x82194E34;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194E34: 92FF0148  stw r23, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[23].u32 ) };
	// 82194E38: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194E3C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194E40: 483A11D5  bl 0x82536014
	ctx.lr = 0x82194E44;
	sub_82535FFC(ctx, base);
	// 82194E44: 483A02AC  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194E48 => {
    //   block [0x82194E48..0x82194EC8)
	// 82194E48: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194E4C: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194E50: 4BFA40B9  bl 0x82138f08
	ctx.lr = 0x82194E54;
	sub_82138F08(ctx, base);
	// 82194E54: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 82194E58: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194E5C: 92EB0228  stw r23, 0x228(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(552 as u32), ctx.r[23].u32 ) };
	// 82194E60: C3EB0130  lfs f31, 0x130(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(304 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82194E64: 92EB0230  stw r23, 0x230(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(560 as u32), ctx.r[23].u32 ) };
	// 82194E68: C3CB0134  lfs f30, 0x134(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(308 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82194E6C: C3AB0138  lfs f29, 0x138(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(312 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82194E70: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194E74: C38B0120  lfs f28, 0x120(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(288 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82194E78: C36B0110  lfs f27, 0x110(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(272 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82194E7C: C34B0114  lfs f26, 0x114(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(276 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82194E80: C32B0118  lfs f25, 0x118(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(280 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82194E84: 4BFF48E5  bl 0x82189768
	ctx.lr = 0x82194E88;
	sub_82189768(ctx, base);
	// 82194E88: 92E3001C  stw r23, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[23].u32 ) };
	// 82194E8C: 83DD0404  lwz r30, 0x404(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194E90: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82194E94: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194E98: 83FE0024  lwz r31, 0x24(r30)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(36 as u32) ) } as u64;
	// 82194E9C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194EA0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194EA4: 4E800421  bctrl
	ctx.lr = 0x82194EA8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194EA8: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 82194EAC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194EB0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194EB4: 483A031D  bl 0x825351d0
	ctx.lr = 0x82194EB8;
	sub_825351D0(ctx, base);
	// 82194EB8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194EBC: 409A000C  bne cr6, 0x82194ec8
	if !ctx.cr[6].eq {
	pc = 0x82194EC8; continue 'dispatch;
	}
	// 82194EC0: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	// 82194EC4: 48000070  b 0x82194f34
	pc = 0x82194F34; continue 'dispatch;
            }
            0x82194EC8 => {
    //   block [0x82194EC8..0x82194F34)
	// 82194EC8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82194ECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194ED0: 396BFA10  addi r11, r11, -0x5f0
	ctx.r[11].s64 = ctx.r[11].s64 + -1520;
	// 82194ED4: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82194ED8: 556B003E  slwi r11, r11, 0
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82194EDC: 816B0064  lwz r11, 0x64(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) } as u64;
	// 82194EE0: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194EE4: 4E800421  bctrl
	ctx.lr = 0x82194EE8;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194EE8: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194EEC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194EF0: 816B0068  lwz r11, 0x68(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) } as u64;
	// 82194EF4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194EF8: 4E800421  bctrl
	ctx.lr = 0x82194EFC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194EFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194F00: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194F04: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194F08: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194F0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194F10: 4E800421  bctrl
	ctx.lr = 0x82194F14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194F14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82194F18: C80B2008  lfd f0, 0x2008(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82194F1C: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 82194F20: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82194F24: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82194F28: 917F0140  stw r11, 0x140(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(320 as u32), ctx.r[11].u32 ) };
	// 82194F2C: 817E0028  lwz r11, 0x28(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194F30: 93EB026C  stw r31, 0x26c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(620 as u32), ctx.r[31].u32 ) };
            }
            0x82194F34 => {
    //   block [0x82194F34..0x82194FAC)
	// 82194F34: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82194F38: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194F3C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82194F40: 816B006C  lwz r11, 0x6c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(108 as u32) ) } as u64;
	// 82194F44: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82194F48: 4E800421  bctrl
	ctx.lr = 0x82194F4C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82194F4C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82194F50: D3FF0130  stfs f31, 0x130(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(304 as u32), tmp.u32 ) };
	// 82194F54: 92FF0148  stw r23, 0x148(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(328 as u32), ctx.r[23].u32 ) };
	// 82194F58: D3DF0134  stfs f30, 0x134(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(308 as u32), tmp.u32 ) };
	// 82194F5C: D3BF0138  stfs f29, 0x138(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(312 as u32), tmp.u32 ) };
	// 82194F60: D3FF0050  stfs f31, 0x50(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82194F64: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82194F68: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82194F6C: D01F008C  stfs f0, 0x8c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82194F70: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82194F74: D3DF0054  stfs f30, 0x54(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82194F78: D3BF0058  stfs f29, 0x58(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82194F7C: D39F0120  stfs f28, 0x120(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(288 as u32), tmp.u32 ) };
	// 82194F80: D37F0110  stfs f27, 0x110(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(272 as u32), tmp.u32 ) };
	// 82194F84: D35F0114  stfs f26, 0x114(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(276 as u32), tmp.u32 ) };
	// 82194F88: D33F0118  stfs f25, 0x118(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(280 as u32), tmp.u32 ) };
	// 82194F8C: D39F0070  stfs f28, 0x70(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82194F90: D37F0060  stfs f27, 0x60(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82194F94: D35F0064  stfs f26, 0x64(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82194F98: D33F0068  stfs f25, 0x68(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82194F9C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82194FA0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82194FA4: 483A1071  bl 0x82536014
	ctx.lr = 0x82194FA8;
	sub_82535FFC(ctx, base);
	// 82194FA8: 483A0148  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82194FAC => {
    //   block [0x82194FAC..0x82195018)
	// 82194FAC: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 82194FB0: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194FB4: 4BFF524D  bl 0x8218a200
	ctx.lr = 0x82194FB8;
	sub_8218A200(ctx, base);
	// 82194FB8: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194FBC: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194FC0: 4BFF5241  bl 0x8218a200
	ctx.lr = 0x82194FC4;
	sub_8218A200(ctx, base);
	// 82194FC4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82194FC8: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194FCC: 4BFA3F3D  bl 0x82138f08
	ctx.lr = 0x82194FD0;
	sub_82138F08(ctx, base);
	// 82194FD0: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82194FD4: 92E30228  stw r23, 0x228(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(552 as u32), ctx.r[23].u32 ) };
	// 82194FD8: 92E30230  stw r23, 0x230(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(560 as u32), ctx.r[23].u32 ) };
	// 82194FDC: 807D0408  lwz r3, 0x408(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82194FE0: 4BFF4789  bl 0x82189768
	ctx.lr = 0x82194FE4;
	sub_82189768(ctx, base);
	// 82194FE4: 92E3001C  stw r23, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[23].u32 ) };
	// 82194FE8: 817D0404  lwz r11, 0x404(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82194FEC: 816B0028  lwz r11, 0x28(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) } as u64;
	// 82194FF0: 83EB0264  lwz r31, 0x264(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(612 as u32) ) } as u64;
	// 82194FF4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82194FF8: 419A0020  beq cr6, 0x82195018
	if ctx.cr[6].eq {
	pc = 0x82195018; continue 'dispatch;
	}
	// 82194FFC: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82195000: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195004: 816B0070  lwz r11, 0x70(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(112 as u32) ) } as u64;
	// 82195008: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219500C: 4E800421  bctrl
	ctx.lr = 0x82195010;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82195010: 2F030000  cmpwi cr6, r3, 0
	ctx.cr[6].compare_i32(ctx.r[3].s32, 0, &mut ctx.xer);
	// 82195014: 419A0008  beq cr6, 0x8219501c
	if ctx.cr[6].eq {
	pc = 0x8219501C; continue 'dispatch;
	}
            }
            0x82195018 => {
    //   block [0x82195018..0x8219501C)
	// 82195018: 7EFFBB78  mr r31, r23
	ctx.r[31].u64 = ctx.r[23].u64;
	pc = 0x8219501C; continue 'dispatch;
            }
            0x8219501C => {
    //   block [0x8219501C..0x82195084)
	// 8219501C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195020: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82195024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195028: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219502C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82195030: FC60F890  fmr f3, f31
	ctx.f[3].f64 = ctx.f[31].f64;
	// 82195034: C04BD478  lfs f2, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82195038: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219503C: C02B27B4  lfs f1, 0x27b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10164 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82195040: 816A0040  lwz r11, 0x40(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(64 as u32) ) } as u64;
	// 82195044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82195048: 4E800421  bctrl
	ctx.lr = 0x8219504C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219504C: D3FF0050  stfs f31, 0x50(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82195050: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 82195054: D3FF0054  stfs f31, 0x54(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82195058: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8219505C: D3FF0058  stfs f31, 0x58(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82195060: 807D0404  lwz r3, 0x404(r29)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1028 as u32) ) } as u64;
	// 82195064: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 82195068: 816B0018  lwz r11, 0x18(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219506C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82195070: 4E800421  bctrl
	ctx.lr = 0x82195074;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82195074: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82195078: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219507C: 483A0F99  bl 0x82536014
	ctx.lr = 0x82195080;
	sub_82535FFC(ctx, base);
	// 82195080: 483A0070  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82195084 => {
    //   block [0x82195084..0x82195114)
	// 82195084: 2F1A0001  cmpwi cr6, r26, 1
	ctx.cr[6].compare_i32(ctx.r[26].s32, 1, &mut ctx.xer);
	// 82195088: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219508C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82195090: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82195094: 419A0108  beq cr6, 0x8219519c
	if ctx.cr[6].eq {
	pc = 0x8219519C; continue 'dispatch;
	}
	// 82195098: 2F1A0002  cmpwi cr6, r26, 2
	ctx.cr[6].compare_i32(ctx.r[26].s32, 2, &mut ctx.xer);
	// 8219509C: 419A0078  beq cr6, 0x82195114
	if ctx.cr[6].eq {
	pc = 0x82195114; continue 'dispatch;
	}
	// 821950A0: 61699B74  ori r9, r11, 0x9b74
	ctx.r[9].u64 = ctx.r[11].u64 | 39796;
	// 821950A4: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 821950A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821950AC: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 821950B0: 7C7F4C2E  lfsx f3, r31, r9
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821950B4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821950B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821950BC: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821950C0: 9141009C  stw r10, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[10].u32 ) };
	// 821950C4: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821950C8: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 821950CC: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821950D0: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 821950D4: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821950D8: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821950DC: C10B2068  lfs f8, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821950E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821950E4: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 821950E8: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 821950EC: FCC06890  fmr f6, f13
	ctx.f[6].f64 = ctx.f[13].f64;
	// 821950F0: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 821950F4: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821950F8: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 821950FC: FC406890  fmr f2, f13
	ctx.f[2].f64 = ctx.f[13].f64;
	// 82195100: 4BFFB9C1  bl 0x82190ac0
	ctx.lr = 0x82195104;
	sub_82190AC0(ctx, base);
	// 82195104: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82195108: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219510C: 483A0F09  bl 0x82536014
	ctx.lr = 0x82195110;
	sub_82535FFC(ctx, base);
	// 82195110: 4839FFE0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82195114 => {
    //   block [0x82195114..0x8219519C)
	// 82195114: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 82195118: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 8219511C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195120: 7C7F542E  lfsx f3, r31, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 82195124: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195128: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 8219512C: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82195130: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 82195134: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82195138: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 8219513C: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82195140: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 82195144: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82195148: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 8219514C: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 82195150: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195154: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 82195158: FCC06890  fmr f6, f13
	ctx.f[6].f64 = ctx.f[13].f64;
	// 8219515C: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 82195160: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 82195164: C10B2B10  lfs f8, 0x2b10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11024 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82195168: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219516C: C00B2B0C  lfs f0, 0x2b0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195170: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82195174: EC630028  fsubs f3, f3, f0
	ctx.f[3].f64 = (((ctx.f[3].f64 - ctx.f[0].f64) as f32) as f64);
	// 82195178: 396BCFF0  addi r11, r11, -0x3010
	ctx.r[11].s64 = ctx.r[11].s64 + -12304;
	// 8219517C: C04B0168  lfs f2, 0x168(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82195180: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82195184: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82195188: 4BFFB939  bl 0x82190ac0
	ctx.lr = 0x8219518C;
	sub_82190AC0(ctx, base);
	// 8219518C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82195190: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82195194: 483A0E81  bl 0x82536014
	ctx.lr = 0x82195198;
	sub_82535FFC(ctx, base);
	// 82195198: 4839FF58  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x8219519C => {
    //   block [0x8219519C..0x82195224)
	// 8219519C: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 821951A0: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 821951A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821951A8: 7C7F542E  lfsx f3, r31, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821951AC: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821951B0: 39600004  li r11, 4
	ctx.r[11].s64 = 4;
	// 821951B4: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821951B8: FD806890  fmr f12, f13
	ctx.f[12].f64 = ctx.f[13].f64;
	// 821951BC: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821951C0: FD606890  fmr f11, f13
	ctx.f[11].f64 = ctx.f[13].f64;
	// 821951C4: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821951C8: FD406890  fmr f10, f13
	ctx.f[10].f64 = ctx.f[13].f64;
	// 821951CC: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821951D0: FD206890  fmr f9, f13
	ctx.f[9].f64 = ctx.f[13].f64;
	// 821951D4: 9161009C  stw r11, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[11].u32 ) };
	// 821951D8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821951DC: FCE06890  fmr f7, f13
	ctx.f[7].f64 = ctx.f[13].f64;
	// 821951E0: FCC06890  fmr f6, f13
	ctx.f[6].f64 = ctx.f[13].f64;
	// 821951E4: FCA06890  fmr f5, f13
	ctx.f[5].f64 = ctx.f[13].f64;
	// 821951E8: FC806890  fmr f4, f13
	ctx.f[4].f64 = ctx.f[13].f64;
	// 821951EC: C10B2B10  lfs f8, 0x2b10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11024 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821951F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821951F4: C00B2B0C  lfs f0, 0x2b0c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11020 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821951F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821951FC: EC63002A  fadds f3, f3, f0
	ctx.f[3].f64 = ((ctx.f[3].f64 + ctx.f[0].f64) as f32) as f64;
	// 82195200: 396BCFF0  addi r11, r11, -0x3010
	ctx.r[11].s64 = ctx.r[11].s64 + -12304;
	// 82195204: C04B0168  lfs f2, 0x168(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82195208: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219520C: C02BBA38  lfs f1, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 82195210: 4BFFB8B1  bl 0x82190ac0
	ctx.lr = 0x82195214;
	sub_82190AC0(ctx, base);
	// 82195214: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82195218: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219521C: 483A0DF9  bl 0x82536014
	ctx.lr = 0x82195220;
	sub_82535FFC(ctx, base);
	// 82195220: 4839FED0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x82195224 => {
    //   block [0x82195224..0x82195240)
	// 82195224: 83BD0408  lwz r29, 0x408(r29)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 82195228: 817D0004  lwz r11, 4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219522C: 3BCB0250  addi r30, r11, 0x250
	ctx.r[30].s64 = ctx.r[11].s64 + 592;
	// 82195230: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82195234: 409A000C  bne cr6, 0x82195240
	if !ctx.cr[6].eq {
	pc = 0x82195240; continue 'dispatch;
	}
	// 82195238: 7EE3BB78  mr r3, r23
	ctx.r[3].u64 = ctx.r[23].u64;
	// 8219523C: 48000054  b 0x82195290
	pc = 0x82195290; continue 'dispatch;
            }
            0x82195240 => {
    //   block [0x82195240..0x82195290)
	// 82195240: 38A00070  li r5, 0x70
	ctx.r[5].s64 = 112;
	// 82195244: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82195248: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219524C: 4839FF85  bl 0x825351d0
	ctx.lr = 0x82195250;
	sub_825351D0(ctx, base);
	// 82195250: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82195254: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82195258: 396B0850  addi r11, r11, 0x850
	ctx.r[11].s64 = ctx.r[11].s64 + 2128;
	// 8219525C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82195260: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82195264: 937E0004  stw r27, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82195268: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219526C: 815E0000  lwz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 82195270: 93BE000C  stw r29, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[29].u32 ) };
	// 82195274: 917E0008  stw r11, 8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82195278: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219527C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82195280: 4E800421  bctrl
	ctx.lr = 0x82195284;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82195284: 937E001C  stw r27, 0x1c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82195288: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219528C: 93DD000C  stw r30, 0xc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
            }
            0x82195290 => {
    //   block [0x82195290..0x821952E0)
	// 82195290: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82195294: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82195298: 419A03B4  beq cr6, 0x8219564c
	if ctx.cr[6].eq {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 8219529C: 7B4B0020  clrldi r11, r26, 0x20
	ctx.r[11].u64 = ctx.r[26].u64 & 0x00000000FFFFFFFFu64;
	// 821952A0: 81430000  lwz r10, 0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 821952A4: 93230064  stw r25, 0x64(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(100 as u32), ctx.r[25].u32 ) };
	// 821952A8: 92C3005C  stw r22, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[22].u32 ) };
	// 821952AC: 93E3006C  stw r31, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[31].u32 ) };
	// 821952B0: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821952B4: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821952B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821952BC: 816A0008  lwz r11, 8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 821952C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821952C4: D0030068  stfs f0, 0x68(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821952C8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821952CC: 4E800421  bctrl
	ctx.lr = 0x821952D0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821952D0: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 821952D4: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 821952D8: 483A0D3D  bl 0x82536014
	ctx.lr = 0x821952DC;
	sub_82535FFC(ctx, base);
	// 821952DC: 4839FE14  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            0x821952E0 => {
    //   block [0x821952E0..0x82195324)
	// 821952E0: 7F4B07B4  extsw r11, r26
	ctx.r[11].s64 = ctx.r[26].s32 as i64;
	// 821952E4: 2B160000  cmplwi cr6, r22, 0
	ctx.cr[6].compare_u32(ctx.r[22].u32, 0 as u32, &mut ctx.xer);
	// 821952E8: F96100C0  std r11, 0xc0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(192 as u32), ctx.r[11].u64 ) };
	// 821952EC: C80100C0  lfd f0, 0xc0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(192 as u32) ) };
	// 821952F0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821952F4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821952F8: 419A002C  beq cr6, 0x82195324
	if ctx.cr[6].eq {
	pc = 0x82195324; continue 'dispatch;
	}
	// 821952FC: C1B60000  lfs f13, 0(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195300: 81560008  lwz r10, 8(r22)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(8 as u32) ) } as u64;
	// 82195304: C1960004  lfs f12, 4(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195308: 8116000C  lwz r8, 0xc(r22)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219530C: ED8C6828  fsubs f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 - ctx.f[13].f64) as f32) as f64);
	// 82195310: C1560010  lfs f10, 0x10(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(16 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82195314: C1360014  lfs f9, 0x14(r22)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[22].u32.wrapping_add(20 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82195318: FEA06890  fmr f21, f13
	ctx.f[21].f64 = ctx.f[13].f64;
	// 8219531C: EE8C0024  fdivs f20, f12, f0
	ctx.f[20].f64 = ((ctx.f[12].f64 / ctx.f[0].f64) as f32) as f64;
	// 82195320: 48000044  b 0x82195364
	pc = 0x82195364; continue 'dispatch;
            }
            0x82195324 => {
    //   block [0x82195324..0x82195364)
	// 82195324: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82195328: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219532C: 396B5414  addi r11, r11, 0x5414
	ctx.r[11].s64 = ctx.r[11].s64 + 21524;
	// 82195330: C00B0004  lfs f0, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195334: 814B000C  lwz r10, 0xc(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 82195338: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219533C: FEA00090  fmr f21, f0
	ctx.f[21].f64 = ctx.f[0].f64;
	// 82195340: ED6D0028  fsubs f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 82195344: C18B0014  lfs f12, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195348: C1A922A4  lfs f13, 0x22a4(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8868 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219534C: 810B0010  lwz r8, 0x10(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 82195350: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82195354: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195358: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219535C: ED2C0372  fmuls f9, f12, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82195360: EE8B0024  fdivs f20, f11, f0
	ctx.f[20].f64 = ((ctx.f[11].f64 / ctx.f[0].f64) as f32) as f64;
	pc = 0x82195364; continue 'dispatch;
            }
            0x82195364 => {
    //   block [0x82195364..0x82195398)
	// 82195364: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 82195368: 41990050  bgt cr6, 0x821953b8
	if ctx.cr[6].gt {
	pc = 0x821953B8; continue 'dispatch;
	}
	// 8219536C: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 82195370: 398C5384  addi r12, r12, 0x5384
	ctx.r[12].s64 = ctx.r[12].s64 + 21380;
	// 82195374: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82195378: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219537C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82195380: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x82195398; continue 'dispatch;
		},
		1 => {
	pc = 0x821953B8; continue 'dispatch;
		},
		2 => {
	pc = 0x821953A0; continue 'dispatch;
		},
		3 => {
	pc = 0x821953A8; continue 'dispatch;
		},
		4 => {
	pc = 0x821953B0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82195384: 82195398  lwz r16, 0x5398(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21400 as u32) ) } as u64;
	// 82195388: 821953B8  lwz r16, 0x53b8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21432 as u32) ) } as u64;
	// 8219538C: 821953A0  lwz r16, 0x53a0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21408 as u32) ) } as u64;
	// 82195390: 821953A8  lwz r16, 0x53a8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21416 as u32) ) } as u64;
	// 82195394: 821953B0  lwz r16, 0x53b0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(21424 as u32) ) } as u64;
            }
            0x82195398 => {
    //   block [0x82195398..0x821953A0)
	// 82195398: 39200005  li r9, 5
	ctx.r[9].s64 = 5;
	// 8219539C: 48000020  b 0x821953bc
	pc = 0x821953BC; continue 'dispatch;
            }
            0x821953A0 => {
    //   block [0x821953A0..0x821953A8)
	// 821953A0: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 821953A4: 48000018  b 0x821953bc
	pc = 0x821953BC; continue 'dispatch;
            }
            0x821953A8 => {
    //   block [0x821953A8..0x821953B0)
	// 821953A8: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 821953AC: 48000010  b 0x821953bc
	pc = 0x821953BC; continue 'dispatch;
            }
            0x821953B0 => {
    //   block [0x821953B0..0x821953B8)
	// 821953B0: 3920000E  li r9, 0xe
	ctx.r[9].s64 = 14;
	// 821953B4: 48000008  b 0x821953bc
	pc = 0x821953BC; continue 'dispatch;
            }
            0x821953B8 => {
    //   block [0x821953B8..0x821953BC)
	// 821953B8: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	pc = 0x821953BC; continue 'dispatch;
            }
            0x821953BC => {
    //   block [0x821953BC..0x8219541C)
	// 821953BC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 821953C0: 7D5FD8AE  lbzx r10, r31, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 821953C4: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821953C8: 396B0630  addi r11, r11, 0x630
	ctx.r[11].s64 = ctx.r[11].s64 + 1584;
	// 821953CC: 816B003C  lwz r11, 0x3c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(60 as u32) ) } as u64;
	// 821953D0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821953D4: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 821953D8: 556BDFFE  rlwinm r11, r11, 0x1b, 0x1f, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000001Fu64;
	// 821953DC: 696A0001  xori r10, r11, 1
	ctx.r[10].u64 = ctx.r[11].u64 ^ 1;
	// 821953E0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821953E4: 396BBA38  addi r11, r11, -0x45c8
	ctx.r[11].s64 = ctx.r[11].s64 + -17864;
	// 821953E8: C34B0000  lfs f26, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 821953EC: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821953F0: EDBA0024  fdivs f13, f26, f0
	ctx.f[13].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 821953F4: C18B2934  lfs f12, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821953F8: ED80602A  fadds f12, f0, f12
	ctx.f[12].f64 = ((ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64;
	// 821953FC: 409A0020  bne cr6, 0x8219541c
	if !ctx.cr[6].eq {
	pc = 0x8219541C; continue 'dispatch;
	}
	// 82195400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195404: C32B2644  lfs f25, 0x2644(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9796 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82195408: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219540C: C2EB2B08  lfs f23, 0x2b08(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11016 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82195410: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195414: C00B2B04  lfs f0, 0x2b04(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11012 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195418: 4800001C  b 0x82195434
	pc = 0x82195434; continue 'dispatch;
            }
            0x8219541C => {
    //   block [0x8219541C..0x82195434)
	// 8219541C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195420: C32B2B00  lfs f25, 0x2b00(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11008 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82195424: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195428: C2EB2AFC  lfs f23, 0x2afc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11004 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 8219542C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195430: C00B2AF8  lfs f0, 0x2af8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11000 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x82195434; continue 'dispatch;
            }
            0x82195434 => {
    //   block [0x82195434..0x821954A8)
	// 82195434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195438: ED0D0032  fmuls f8, f13, f0
	ctx.f[8].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219543C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 82195440: 396B2074  addi r11, r11, 0x2074
	ctx.r[11].s64 = ctx.r[11].s64 + 8308;
	// 82195444: C16B0000  lfs f11, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82195448: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219544C: ECEB6024  fdivs f7, f11, f12
	ctx.f[7].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 82195450: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 82195454: ED6B6024  fdivs f11, f11, f12
	ctx.f[11].f64 = ((ctx.f[11].f64 / ctx.f[12].f64) as f32) as f64;
	// 82195458: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219545C: 616B85D8  ori r11, r11, 0x85d8
	ctx.r[11].u64 = ctx.r[11].u64 | 34264;
	// 82195460: 7C1E5C2E  lfsx f0, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195464: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 82195468: EF080032  fmuls f24, f8, f0
	ctx.f[24].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219546C: 616A9B74  ori r10, r11, 0x9b74
	ctx.r[10].u64 = ctx.r[11].u64 | 39796;
	// 82195470: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195474: 7D9F542E  lfsx f12, r31, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195478: ED070632  fmuls f8, f7, f24
	ctx.f[8].f64 = (((ctx.f[7].f64 * ctx.f[24].f64) as f32) as f64);
	// 8219547C: ECEA4828  fsubs f7, f10, f9
	ctx.f[7].f64 = (((ctx.f[10].f64 - ctx.f[9].f64) as f32) as f64);
	// 82195480: EEC80032  fmuls f22, f8, f0
	ctx.f[22].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 82195484: C10BBFFC  lfs f8, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82195488: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219548C: 409A001C  bne cr6, 0x821954a8
	if !ctx.cr[6].eq {
	pc = 0x821954A8; continue 'dispatch;
	}
	// 82195490: EFCA623C  fnmsubs f30, f10, f8, f12
	ctx.f[30].f64 = -(((ctx.f[10].f64 * ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 82195494: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195498: EF69623C  fnmsubs f27, f9, f8, f12
	ctx.f[27].f64 = -(((ctx.f[9].f64 * ctx.f[8].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219549C: C1AB22E8  lfs f13, 0x22e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8936 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821954A0: FF80F090  fmr f28, f30
	ctx.f[28].f64 = ctx.f[30].f64;
	// 821954A4: 48000018  b 0x821954bc
	pc = 0x821954BC; continue 'dispatch;
            }
            0x821954A8 => {
    //   block [0x821954A8..0x821954BC)
	// 821954A8: EF8A623A  fmadds f28, f10, f8, f12
	ctx.f[28].f64 = (((ctx.f[10].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 821954AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821954B0: EFC9623A  fmadds f30, f9, f8, f12
	ctx.f[30].f64 = (((ctx.f[9].f64 * ctx.f[8].f64 + ctx.f[12].f64) as f32) as f64);
	// 821954B4: C1AB2AF4  lfs f13, 0x2af4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10996 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821954B8: FF60E090  fmr f27, f28
	ctx.f[27].f64 = ctx.f[28].f64;
	pc = 0x821954BC; continue 'dispatch;
            }
            0x821954BC => {
    //   block [0x821954BC..0x82195538)
	// 821954BC: EDA70372  fmuls f13, f7, f13
	ctx.f[13].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821954C0: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 821954C4: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821954C8: EDAB07F2  fmuls f13, f11, f31
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[31].f64) as f32) as f64);
	// 821954CC: EFAD0032  fmuls f29, f13, f0
	ctx.f[29].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821954D0: 409A0068  bne cr6, 0x82195538
	if !ctx.cr[6].eq {
	pc = 0x82195538; continue 'dispatch;
	}
	// 821954D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821954D8: 9121009C  stw r9, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 821954DC: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 821954E0: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 821954E4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821954E8: FD80B090  fmr f12, f22
	ctx.f[12].f64 = ctx.f[22].f64;
	// 821954EC: ED600532  fmuls f11, f0, f20
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 821954F0: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	// 821954F4: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821954F8: FD20C090  fmr f9, f24
	ctx.f[9].f64 = ctx.f[24].f64;
	// 821954FC: D1A100B4  stfs f13, 0xb4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82195500: FD00A890  fmr f8, f21
	ctx.f[8].f64 = ctx.f[21].f64;
	// 82195504: D1A100AC  stfs f13, 0xac(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82195508: FCE0D890  fmr f7, f27
	ctx.f[7].f64 = ctx.f[27].f64;
	// 8219550C: D1A100A4  stfs f13, 0xa4(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82195510: FCC0B890  fmr f6, f23
	ctx.f[6].f64 = ctx.f[23].f64;
	// 82195514: D1A1008C  stfs f13, 0x8c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82195518: FCA0F090  fmr f5, f30
	ctx.f[5].f64 = ctx.f[30].f64;
	// 8219551C: FDA0E890  fmr f13, f29
	ctx.f[13].f64 = ctx.f[29].f64;
	// 82195520: FC80C890  fmr f4, f25
	ctx.f[4].f64 = ctx.f[25].f64;
	// 82195524: FC60E090  fmr f3, f28
	ctx.f[3].f64 = ctx.f[28].f64;
	// 82195528: FC40C890  fmr f2, f25
	ctx.f[2].f64 = ctx.f[25].f64;
	// 8219552C: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 82195530: 4BFFB591  bl 0x82190ac0
	ctx.lr = 0x82195534;
	sub_82190AC0(ctx, base);
	// 82195534: 480000B8  b 0x821955ec
	pc = 0x821955EC; continue 'dispatch;
            }
            0x82195538 => {
    //   block [0x82195538..0x821955EC)
	// 82195538: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219553C: 38810100  addi r4, r1, 0x100
	ctx.r[4].s64 = ctx.r[1].s64 + 256;
	// 82195540: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195544: 4BF935B5  bl 0x82128af8
	ctx.lr = 0x82195548;
	sub_82128AF8(ctx, base);
	// 82195548: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	// 8219554C: 388100F0  addi r4, r1, 0xf0
	ctx.r[4].s64 = ctx.r[1].s64 + 240;
	// 82195550: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195554: 4BF935A5  bl 0x82128af8
	ctx.lr = 0x82195558;
	sub_82128AF8(ctx, base);
	// 82195558: 39610100  addi r11, r1, 0x100
	ctx.r[11].s64 = ctx.r[1].s64 + 256;
	// 8219555C: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 82195560: 93E10094  stw r31, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[31].u32 ) };
	// 82195564: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82195568: FDA0E890  fmr f13, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = ctx.f[29].f64;
	// 8219556C: FD80B090  fmr f12, f22
	ctx.f[12].f64 = ctx.f[22].f64;
	// 82195570: 92E1009C  stw r23, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 82195574: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	pc = 0x821955EC; continue 'dispatch;
            }
            0x821955EC => {
    //   block [0x821955EC..0x8219564C)
	// 821955EC: 83DD0408  lwz r30, 0x408(r29)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1032 as u32) ) } as u64;
	// 821955F0: 817E0004  lwz r11, 4(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) } as u64;
	// 821955F4: 3BEB0250  addi r31, r11, 0x250
	ctx.r[31].s64 = ctx.r[11].s64 + 592;
	// 821955F8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821955FC: 419A0050  beq cr6, 0x8219564c
	if ctx.cr[6].eq {
	pc = 0x8219564C; continue 'dispatch;
	}
	// 82195600: 38A00090  li r5, 0x90
	ctx.r[5].s64 = 144;
	// 82195604: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 82195608: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219560C: 4839FBC5  bl 0x825351d0
	ctx.lr = 0x82195610;
	sub_825351D0(ctx, base);
	// 82195610: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82195614: 3B600001  li r27, 1
	ctx.r[27].s64 = 1;
	// 82195618: 396B098C  addi r11, r11, 0x98c
	ctx.r[11].s64 = ctx.r[11].s64 + 2444;
	// 8219561C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195620: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82195624: 937F0004  stw r27, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[27].u32 ) };
	// 82195628: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219562C: 815F0000  lwz r10, 0(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 82195630: 93DF000C  stw r30, 0xc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), ctx.r[30].u32 ) };
	// 82195634: 917F0008  stw r11, 8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), ctx.r[11].u32 ) };
	// 82195638: 816A0000  lwz r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219563C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 82195640: 4E800421  bctrl
	ctx.lr = 0x82195644;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 82195644: 937F001C  stw r27, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[27].u32 ) };
	// 82195648: 93FE000C  stw r31, 0xc(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), ctx.r[31].u32 ) };
            }
            0x8219564C => {
    //   block [0x8219564C..0x8219565C)
	// 8219564C: 382101D0  addi r1, r1, 0x1d0
	ctx.r[1].s64 = ctx.r[1].s64 + 464;
	// 82195650: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 82195654: 483A09C1  bl 0x82536014
	ctx.lr = 0x82195658;
	sub_82535FFC(ctx, base);
	// 82195658: 4839FA98  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195660(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82195660 size=96
    let mut pc: u32 = 0x82195660;
    'dispatch: loop {
        match pc {
            0x82195660 => {
    //   block [0x82195660..0x8219569C)
	// 82195660: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82195664: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82195668: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219566C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82195670: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82195674: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82195678: 481E4D41  bl 0x8237a3b8
	ctx.lr = 0x8219567C;
	sub_8237A3B8(ctx, base);
	// 8219567C: 38800008  li r4, 8
	ctx.r[4].s64 = 8;
	// 82195680: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82195684: 807F0030  lwz r3, 0x30(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 82195688: 4BFF44D9  bl 0x82189b60
	ctx.lr = 0x8219568C;
	sub_82189B60(ctx, base);
	// 8219568C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82195690: 419A000C  beq cr6, 0x8219569c
	if ctx.cr[6].eq {
	pc = 0x8219569C; continue 'dispatch;
	}
	// 82195694: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82195698: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	pc = 0x8219569C; continue 'dispatch;
            }
            0x8219569C => {
    //   block [0x8219569C..0x821956C0)
	// 8219569C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821956A0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821956A4: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 821956A8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821956AC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821956B0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821956B4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821956B8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821956BC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821956C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821956C0 size=48
    let mut pc: u32 = 0x821956C0;
    'dispatch: loop {
        match pc {
            0x821956C0 => {
    //   block [0x821956C0..0x821956F0)
	// 821956C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821956C4: C00B2074  lfs f0, 0x2074(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821956C8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821956CC: 41980068  blt cr6, 0x82195734
	if ctx.cr[6].lt {
		sub_821956F0(ctx, base);
		return;
	}
	// 821956D0: FDA00A10  fabs f13, f1
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821956D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821956D8: C00B23FC  lfs f0, 0x23fc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9212 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821956DC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 821956E0: 41990010  bgt cr6, 0x821956f0
	if ctx.cr[6].gt {
		sub_821956F0(ctx, base);
		return;
	}
	// 821956E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821956E8: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 821956EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821956F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821956F0 size=76
    let mut pc: u32 = 0x821956F0;
    'dispatch: loop {
        match pc {
            0x821956F0 => {
    //   block [0x821956F0..0x8219573C)
	// 821956F0: C0030044  lfs f0, 0x44(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821956F4: FDA00A10  fabs f13, f1
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821956F8: FC000210  fabs f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821956FC: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82195700: 4D980020  bltlr cr6
	if ctx.cr[6].lt { return; }
	// 82195704: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195708: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219570C: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 82195710: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82195718: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219571C: 91430094  stw r10, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 82195720: D0030054  stfs f0, 0x54(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82195724: 912300B0  stw r9, 0xb0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), ctx.r[9].u32 ) };
	// 82195728: 91430098  stw r10, 0x98(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 8219572C: 91630060  stw r11, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82195730: 91630090  stw r11, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82195734: D0430084  stfs f2, 0x84(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82195738: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195740(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82195740 size=636
    let mut pc: u32 = 0x82195740;
    'dispatch: loop {
        match pc {
            0x82195740 => {
    //   block [0x82195740..0x82195798)
	// 82195740: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82195744: 90610014  stw r3, 0x14(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(20 as u32), ctx.r[3].u32 ) };
	// 82195748: 3944FFFF  addi r10, r4, -1
	ctx.r[10].s64 = ctx.r[4].s64 + -1;
	// 8219574C: 2B0A0009  cmplwi cr6, r10, 9
	ctx.cr[6].compare_u32(ctx.r[10].u32, 9 as u32, &mut ctx.xer);
	// 82195750: 816BB9B0  lwz r11, -0x4650(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-18000 as u32) ) } as u64;
	// 82195754: 4D990020  bgtlr cr6
	if ctx.cr[6].gt { return; }
	// 82195758: 3D808219  lis r12, -0x7de7
	ctx.r[12].s64 = -2112290816;
	// 8219575C: 398C5770  addi r12, r12, 0x5770
	ctx.r[12].s64 = ctx.r[12].s64 + 22384;
	// 82195760: 5540103A  slwi r0, r10, 2
	ctx.r[0].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82195764: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82195768: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219576C: 4E800420  bctr
	match ctx.r[10].u64 {
		0 => {
	pc = 0x82195798; continue 'dispatch;
		},
		1 => {
	pc = 0x821957CC; continue 'dispatch;
		},
		2 => {
	pc = 0x821957DC; continue 'dispatch;
		},
		3 => {
	pc = 0x82195810; continue 'dispatch;
		},
		4 => {
	pc = 0x82195824; continue 'dispatch;
		},
		5 => {
	pc = 0x82195858; continue 'dispatch;
		},
		6 => {
	pc = 0x8219589C; continue 'dispatch;
		},
		7 => {
	pc = 0x821958D4; continue 'dispatch;
		},
		8 => {
	pc = 0x8219590C; continue 'dispatch;
		},
		9 => {
	pc = 0x82195950; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82195770: 82195798  lwz r16, 0x5798(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22424 as u32) ) } as u64;
	// 82195774: 821957CC  lwz r16, 0x57cc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22476 as u32) ) } as u64;
	// 82195778: 821957DC  lwz r16, 0x57dc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22492 as u32) ) } as u64;
	// 8219577C: 82195810  lwz r16, 0x5810(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22544 as u32) ) } as u64;
	// 82195780: 82195824  lwz r16, 0x5824(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22564 as u32) ) } as u64;
	// 82195784: 82195858  lwz r16, 0x5858(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22616 as u32) ) } as u64;
	// 82195788: 8219589C  lwz r16, 0x589c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22684 as u32) ) } as u64;
	// 8219578C: 821958D4  lwz r16, 0x58d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22740 as u32) ) } as u64;
	// 82195790: 8219590C  lwz r16, 0x590c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22796 as u32) ) } as u64;
	// 82195794: 82195950  lwz r16, 0x5950(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(22864 as u32) ) } as u64;
            }
            0x82195798 => {
    //   block [0x82195798..0x821957CC)
	// 82195798: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8219579C: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821957A0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821957A4: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 821957A8: C00AD560  lfs f0, -0x2aa0(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821957AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821957B0: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821957B4: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821957B8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821957BC: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821957C0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821957C4: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 821957C8: 480001B8  b 0x82195980
	pc = 0x82195980; continue 'dispatch;
            }
            0x821957CC => {
    //   block [0x821957CC..0x821957DC)
	// 821957CC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 821957D0: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 821957D4: C00AD560  lfs f0, -0x2aa0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821957D8: 48000184  b 0x8219595c
	pc = 0x8219595C; continue 'dispatch;
            }
            0x821957DC => {
    //   block [0x821957DC..0x82195810)
	// 821957DC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821957E0: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 821957E4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821957E8: 38E0001C  li r7, 0x1c
	ctx.r[7].s64 = 28;
	// 821957EC: C00AD5BC  lfs f0, -0x2a44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821957F0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821957F4: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821957F8: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821957FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195800: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195804: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195808: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 8219580C: 48000174  b 0x82195980
	pc = 0x82195980; continue 'dispatch;
            }
            0x82195810 => {
    //   block [0x82195810..0x82195824)
	// 82195810: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 82195814: 39000003  li r8, 3
	ctx.r[8].s64 = 3;
	// 82195818: 38E00014  li r7, 0x14
	ctx.r[7].s64 = 20;
	// 8219581C: C00AD5BC  lfs f0, -0x2a44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195820: 48000140  b 0x82195960
	pc = 0x82195960; continue 'dispatch;
            }
            0x82195824 => {
    //   block [0x82195824..0x82195858)
	// 82195824: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82195828: 39000004  li r8, 4
	ctx.r[8].s64 = 4;
	// 8219582C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82195830: 38E00024  li r7, 0x24
	ctx.r[7].s64 = 36;
	// 82195834: C00AD6D0  lfs f0, -0x2930(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195838: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219583C: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82195840: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195844: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195848: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219584C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195850: 914B00A0  stw r10, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[10].u32 ) };
	// 82195854: 4800012C  b 0x82195980
	pc = 0x82195980; continue 'dispatch;
            }
            0x82195858 => {
    //   block [0x82195858..0x8219589C)
	// 82195858: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219585C: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 82195860: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 82195864: 38C0001E  li r6, 0x1e
	ctx.r[6].s64 = 30;
	// 82195868: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219586C: C00A25C0  lfs f0, 0x25c0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9664 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195870: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195874: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82195878: 910B00A4  stw r8, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[8].u32 ) };
	// 8219587C: 90EB00B4  stw r7, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[7].u32 ) };
	// 82195880: 90CB00B8  stw r6, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[6].u32 ) };
	// 82195884: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 82195888: C1AA253C  lfs f13, 0x253c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9532 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219588C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195890: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195894: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195898: 480000F8  b 0x82195990
	pc = 0x82195990; continue 'dispatch;
            }
            0x8219589C => {
    //   block [0x8219589C..0x821958D4)
	// 8219589C: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821958A0: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821958A4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821958A8: 38E0000E  li r7, 0xe
	ctx.r[7].s64 = 14;
	// 821958AC: C00AD5BC  lfs f0, -0x2a44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821958B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821958B4: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821958B8: 910B00A4  stw r8, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[8].u32 ) };
	// 821958BC: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821958C0: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821958C4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821958C8: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821958CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821958D0: 480000B8  b 0x82195988
	pc = 0x82195988; continue 'dispatch;
            }
            0x821958D4 => {
    //   block [0x821958D4..0x8219590C)
	// 821958D4: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 821958D8: 39000005  li r8, 5
	ctx.r[8].s64 = 5;
	// 821958DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821958E0: 38E00012  li r7, 0x12
	ctx.r[7].s64 = 18;
	// 821958E4: C00AD5BC  lfs f0, -0x2a44(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-10820 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821958E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821958EC: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821958F0: 910B00A4  stw r8, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[8].u32 ) };
	// 821958F4: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 821958F8: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821958FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195900: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195904: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195908: 48000080  b 0x82195988
	pc = 0x82195988; continue 'dispatch;
            }
            0x8219590C => {
    //   block [0x8219590C..0x82195950)
	// 8219590C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195910: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82195914: 38E0000A  li r7, 0xa
	ctx.r[7].s64 = 10;
	// 82195918: 38C00003  li r6, 3
	ctx.r[6].s64 = 3;
	// 8219591C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82195920: C00A24D0  lfs f0, 0x24d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9424 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195924: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195928: C1A922EC  lfs f13, 0x22ec(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219592C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 82195930: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82195934: 90EB00B8  stw r7, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[7].u32 ) };
	// 82195938: 90CB00A4  stw r6, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	// 8219593C: C0081FF8  lfs f0, 0x1ff8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195940: 914B00B0  stw r10, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[10].u32 ) };
	// 82195944: 912B00B4  stw r9, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 82195948: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 8219594C: 48000048  b 0x82195994
	pc = 0x82195994; continue 'dispatch;
            }
            0x82195950 => {
    //   block [0x82195950..0x8219595C)
	// 82195950: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195954: 39000002  li r8, 2
	ctx.r[8].s64 = 2;
	// 82195958: C00A24CC  lfs f0, 0x24cc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9420 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8219595C; continue 'dispatch;
            }
            0x8219595C => {
    //   block [0x8219595C..0x82195960)
	// 8219595C: 38E0000E  li r7, 0xe
	ctx.r[7].s64 = 14;
	pc = 0x82195960; continue 'dispatch;
            }
            0x82195960 => {
    //   block [0x82195960..0x82195980)
	// 82195960: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195964: D00B00A8  stfs f0, 0xa8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82195968: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219596C: C1AA22EC  lfs f13, 0x22ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8940 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195970: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195974: 912B00A0  stw r9, 0xa0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 82195978: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219597C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	pc = 0x82195980; continue 'dispatch;
            }
            0x82195980 => {
    //   block [0x82195980..0x82195988)
	// 82195980: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 82195984: 90CB00A4  stw r6, 0xa4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(164 as u32), ctx.r[6].u32 ) };
	pc = 0x82195988; continue 'dispatch;
            }
            0x82195988 => {
    //   block [0x82195988..0x82195990)
	// 82195988: 912B00B4  stw r9, 0xb4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(180 as u32), ctx.r[9].u32 ) };
	// 8219598C: 90EB00B8  stw r7, 0xb8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(184 as u32), ctx.r[7].u32 ) };
	pc = 0x82195990; continue 'dispatch;
            }
            0x82195990 => {
    //   block [0x82195990..0x82195994)
	// 82195990: 910B00B0  stw r8, 0xb0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(176 as u32), ctx.r[8].u32 ) };
	pc = 0x82195994; continue 'dispatch;
            }
            0x82195994 => {
    //   block [0x82195994..0x821959BC)
	// 82195994: D1AB00AC  stfs f13, 0xac(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82195998: D00B0050  stfs f0, 0x50(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219599C: D00B0054  stfs f0, 0x54(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821959A0: D00B0058  stfs f0, 0x58(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821959A4: D00B005C  stfs f0, 0x5c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821959A8: 914B0090  stw r10, 0x90(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u32 ) };
	// 821959AC: 914B0060  stw r10, 0x60(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(96 as u32), ctx.r[10].u32 ) };
	// 821959B0: 912B0094  stw r9, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[9].u32 ) };
	// 821959B4: 914B0098  stw r10, 0x98(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u32 ) };
	// 821959B8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821959C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821959C0 size=780
    let mut pc: u32 = 0x821959C0;
    'dispatch: loop {
        match pc {
            0x821959C0 => {
    //   block [0x821959C0..0x821959DC)
	// 821959C0: 81630070  lwz r11, 0x70(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(112 as u32) ) } as u64;
	// 821959C4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821959C8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821959CC: 419A0010  beq cr6, 0x821959dc
	if ctx.cr[6].eq {
	pc = 0x821959DC; continue 'dispatch;
	}
	// 821959D0: 81630074  lwz r11, 0x74(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(116 as u32) ) } as u64;
	// 821959D4: 91030070  stw r8, 0x70(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(112 as u32), ctx.r[8].u32 ) };
	// 821959D8: 9163006C  stw r11, 0x6c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	pc = 0x821959DC; continue 'dispatch;
            }
            0x821959DC => {
    //   block [0x821959DC..0x82195A5C)
	// 821959DC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821959E0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821959E4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821959E8: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821959EC: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 821959F0: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 821959F4: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821959F8: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821959FC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82195A00: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82195A04: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 82195A08: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82195A0C: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 82195A10: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82195A14: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 82195A18: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82195A1C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 82195A20: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82195A24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195A28: C16B1FF8  lfs f11, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82195A2C: 419A0030  beq cr6, 0x82195a5c
	if ctx.cr[6].eq {
	pc = 0x82195A5C; continue 'dispatch;
	}
	// 82195A30: E9430050  ld r10, 0x50(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(80 as u32) ) };
	// 82195A34: 39630040  addi r11, r3, 0x40
	ctx.r[11].s64 = ctx.r[3].s64 + 64;
	// 82195A38: E8E30058  ld r7, 0x58(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(88 as u32) ) };
	// 82195A3C: D1630054  stfs f11, 0x54(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82195A40: D1630050  stfs f11, 0x50(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82195A44: 91030090  stw r8, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[8].u32 ) };
	// 82195A48: D1630058  stfs f11, 0x58(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82195A4C: 91030094  stw r8, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[8].u32 ) };
	// 82195A50: 91230060  stw r9, 0x60(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(96 as u32), ctx.r[9].u32 ) };
	// 82195A54: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82195A58: F8EB0008  std r7, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	pc = 0x82195A5C; continue 'dispatch;
            }
            0x82195A5C => {
    //   block [0x82195A5C..0x82195AAC)
	// 82195A5C: 81630060  lwz r11, 0x60(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(96 as u32) ) } as u64;
	// 82195A60: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82195A64: 419A0274  beq cr6, 0x82195cd8
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x82195CD8);
		return;
	}
	// 82195A68: 81630098  lwz r11, 0x98(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(152 as u32) ) } as u64;
	// 82195A6C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82195A70: 409A00FC  bne cr6, 0x82195b6c
	if !ctx.cr[6].eq {
	pc = 0x82195B6C; continue 'dispatch;
	}
	// 82195A74: C1A30040  lfs f13, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195A78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195A7C: FD806A10  fabs f12, f13
	ctx.f[12].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82195A80: C00B2234  lfs f0, 0x2234(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8756 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195A84: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82195A88: 40980024  bge cr6, 0x82195aac
	if !ctx.cr[6].lt {
	pc = 0x82195AAC; continue 'dispatch;
	}
	// 82195A8C: C1830044  lfs f12, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195A90: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82195A94: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82195A98: 40980014  bge cr6, 0x82195aac
	if !ctx.cr[6].lt {
	pc = 0x82195AAC; continue 'dispatch;
	}
	// 82195A9C: C1830048  lfs f12, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195AA0: FD806210  fabs f12, f12
	ctx.f[12].u64 = ctx.f[12].u64 & !0x8000_0000_0000_0000u64;
	// 82195AA4: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 82195AA8: 41980224  blt cr6, 0x82195ccc
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82195CCC);
		return;
	}
	pc = 0x82195AAC; continue 'dispatch;
            }
            0x82195AAC => {
    //   block [0x82195AAC..0x82195AD8)
	// 82195AAC: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82195AB0: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 82195AB4: 4198007C  blt cr6, 0x82195b30
	if ctx.cr[6].lt {
	pc = 0x82195B30; continue 'dispatch;
	}
	// 82195AB8: 8143006C  lwz r10, 0x6c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(108 as u32) ) } as u64;
	// 82195ABC: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82195AC0: 409A0020  bne cr6, 0x82195ae0
	if !ctx.cr[6].eq {
	pc = 0x82195AE0; continue 'dispatch;
	}
	// 82195AC4: 80E30068  lwz r7, 0x68(r3)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82195AC8: 556607FE  clrlwi r6, r11, 0x1f
	ctx.r[6].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82195ACC: 7F063840  cmplw cr6, r6, r7
	ctx.cr[6].compare_u32(ctx.r[6].u32, ctx.r[7].u32, &mut ctx.xer);
	// 82195AD0: 419A0008  beq cr6, 0x82195ad8
	if ctx.cr[6].eq {
	pc = 0x82195AD8; continue 'dispatch;
	}
	// 82195AD4: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x82195AD8; continue 'dispatch;
            }
            0x82195AD8 => {
    //   block [0x82195AD8..0x82195AE0)
	// 82195AD8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82195ADC: 419A0014  beq cr6, 0x82195af0
	if ctx.cr[6].eq {
	pc = 0x82195AF0; continue 'dispatch;
	}
	pc = 0x82195AE0; continue 'dispatch;
            }
            0x82195AE0 => {
    //   block [0x82195AE0..0x82195AF0)
	// 82195AE0: 81430068  lwz r10, 0x68(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(104 as u32) ) } as u64;
	// 82195AE4: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 82195AE8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 82195AEC: 419A000C  beq cr6, 0x82195af8
	if ctx.cr[6].eq {
	pc = 0x82195AF8; continue 'dispatch;
	}
	pc = 0x82195AF0; continue 'dispatch;
            }
            0x82195AF0 => {
    //   block [0x82195AF0..0x82195AF8)
	// 82195AF0: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 82195AF4: 419A003C  beq cr6, 0x82195b30
	if ctx.cr[6].eq {
	pc = 0x82195B30; continue 'dispatch;
	}
	pc = 0x82195AF8; continue 'dispatch;
            }
            0x82195AF8 => {
    //   block [0x82195AF8..0x82195B30)
	// 82195AF8: C1230080  lfs f9, 0x80(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82195AFC: C1830044  lfs f12, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195B00: EDA90372  fmuls f13, f9, f13
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[13].f64) as f32) as f64);
	// 82195B04: C1030084  lfs f8, 0x84(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82195B08: C1430048  lfs f10, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82195B0C: ED880332  fmuls f12, f8, f12
	ctx.f[12].f64 = (((ctx.f[8].f64 * ctx.f[12].f64) as f32) as f64);
	// 82195B10: C1230088  lfs f9, 0x88(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(136 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82195B14: ED4902B2  fmuls f10, f9, f10
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[10].f64) as f32) as f64);
	// 82195B18: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195B1C: D1A30040  stfs f13, 0x40(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82195B20: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195B24: D1A30044  stfs f13, 0x44(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195B28: FDA05050  fneg f13, f10
	ctx.f[13].u64 = ctx.f[10].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195B2C: D1A30048  stfs f13, 0x48(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x82195B30; continue 'dispatch;
            }
            0x82195B30 => {
    //   block [0x82195B30..0x82195B44)
	// 82195B30: C1A30040  lfs f13, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195B34: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82195B38: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82195B3C: 41990008  bgt cr6, 0x82195b44
	if ctx.cr[6].gt {
	pc = 0x82195B44; continue 'dispatch;
	}
	// 82195B40: D1630040  stfs f11, 0x40(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x82195B44; continue 'dispatch;
            }
            0x82195B44 => {
    //   block [0x82195B44..0x82195B58)
	// 82195B44: C1A30044  lfs f13, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195B48: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82195B4C: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82195B50: 41990008  bgt cr6, 0x82195b58
	if ctx.cr[6].gt {
	pc = 0x82195B58; continue 'dispatch;
	}
	// 82195B54: D1630044  stfs f11, 0x44(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	pc = 0x82195B58; continue 'dispatch;
            }
            0x82195B58 => {
    //   block [0x82195B58..0x82195B6C)
	// 82195B58: C1A30048  lfs f13, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195B5C: FDA06A10  fabs f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 & !0x8000_0000_0000_0000u64;
	// 82195B60: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82195B64: 4199012C  bgt cr6, 0x82195c90
	if ctx.cr[6].gt {
	pc = 0x82195C90; continue 'dispatch;
	}
	// 82195B68: 48000124  b 0x82195c8c
	pc = 0x82195C8C; continue 'dispatch;
            }
            0x82195B6C => {
    //   block [0x82195B6C..0x82195C00)
	// 82195B6C: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82195B70: 814300B8  lwz r10, 0xb8(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(184 as u32) ) } as u64;
	// 82195B74: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82195B78: 40980154  bge cr6, 0x82195ccc
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82195CCC);
		return;
	}
	// 82195B7C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195B80: C00300A8  lfs f0, 0xa8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195B84: C1AA2234  lfs f13, 0x2234(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8756 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195B88: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82195B8C: 41980140  blt cr6, 0x82195ccc
	if ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x82195CCC);
		return;
	}
	// 82195B90: 814300B0  lwz r10, 0xb0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) } as u64;
	// 82195B94: 7F0B5000  cmpw cr6, r11, r10
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[10].s32, &mut ctx.xer);
	// 82195B98: 814300A0  lwz r10, 0xa0(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(160 as u32) ) } as u64;
	// 82195B9C: 40980064  bge cr6, 0x82195c00
	if !ctx.cr[6].lt {
	pc = 0x82195C00; continue 'dispatch;
	}
	// 82195BA0: 816300B4  lwz r11, 0xb4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(180 as u32) ) } as u64;
	// 82195BA4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82195BA8: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82195BAC: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82195BB0: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82195BB4: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82195BB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195BBC: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195BC0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82195BC4: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82195BC8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82195BCC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82195BD0: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82195BD4: 419A0098  beq cr6, 0x82195c6c
	if ctx.cr[6].eq {
	pc = 0x82195C6C; continue 'dispatch;
	}
	// 82195BD8: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195BDC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82195BE0: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195BE4: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195BE8: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82195BEC: 4199009C  bgt cr6, 0x82195c88
	if ctx.cr[6].gt {
	pc = 0x82195C88; continue 'dispatch;
	}
	// 82195BF0: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195BF4: 910300A0  stw r8, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 82195BF8: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195BFC: 4800008C  b 0x82195c88
	pc = 0x82195C88; continue 'dispatch;
            }
            0x82195C00 => {
    //   block [0x82195C00..0x82195C6C)
	// 82195C00: 816300A4  lwz r11, 0xa4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(164 as u32) ) } as u64;
	// 82195C04: C1A300AC  lfs f13, 0xac(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195C08: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82195C0C: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 82195C10: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 82195C14: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82195C18: 7D6B0194  addze r11, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[11].s64 = tmp.s64;
	// 82195C1C: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 82195C20: F961FFF0  std r11, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[11].u64 ) };
	// 82195C24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195C28: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195C2C: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 82195C30: C9A1FFF0  lfd f13, -0x10(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82195C34: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82195C38: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82195C3C: EDA06824  fdivs f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82195C40: 419A002C  beq cr6, 0x82195c6c
	if ctx.cr[6].eq {
	pc = 0x82195C6C; continue 'dispatch;
	}
	// 82195C44: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195C48: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82195C4C: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195C50: FDA06050  fneg f13, f12
	ctx.f[13].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195C54: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 82195C58: 41990030  bgt cr6, 0x82195c88
	if ctx.cr[6].gt {
	pc = 0x82195C88; continue 'dispatch;
	}
	// 82195C5C: FC006050  fneg f0, f12
	ctx.f[0].u64 = ctx.f[12].u64 ^ 0x8000_0000_0000_0000u64;
	// 82195C60: 910300A0  stw r8, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[8].u32 ) };
	// 82195C64: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195C68: 48000020  b 0x82195c88
	pc = 0x82195C88; continue 'dispatch;
            }
            0x82195C6C => {
    //   block [0x82195C6C..0x82195C88)
	// 82195C6C: C1430044  lfs f10, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82195C70: EC0D502A  fadds f0, f13, f10
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[10].f64) as f32) as f64;
	// 82195C74: D0030044  stfs f0, 0x44(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195C78: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 82195C7C: 4198000C  blt cr6, 0x82195c88
	if ctx.cr[6].lt {
	pc = 0x82195C88; continue 'dispatch;
	}
	// 82195C80: D1830044  stfs f12, 0x44(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195C84: 912300A0  stw r9, 0xa0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	pc = 0x82195C88; continue 'dispatch;
            }
            0x82195C88 => {
    //   block [0x82195C88..0x82195C8C)
	// 82195C88: D1630040  stfs f11, 0x40(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x82195C8C; continue 'dispatch;
            }
            0x82195C8C => {
    //   block [0x82195C8C..0x82195C90)
	// 82195C8C: D1630048  stfs f11, 0x48(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(72 as u32), tmp.u32 ) };
	pc = 0x82195C90; continue 'dispatch;
            }
            0x82195C90 => {
    //   block [0x82195C90..0x82195CCC)
	// 82195C90: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82195C94: C0030040  lfs f0, 0x40(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(64 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195C98: D00B0280  stfs f0, 0x280(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(640 as u32), tmp.u32 ) };
	// 82195C9C: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82195CA0: C0030044  lfs f0, 0x44(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(68 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195CA4: D00B0284  stfs f0, 0x284(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(644 as u32), tmp.u32 ) };
	// 82195CA8: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82195CAC: C0030048  lfs f0, 0x48(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(72 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195CB0: D00B0288  stfs f0, 0x288(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(648 as u32), tmp.u32 ) };
	// 82195CB4: 81630028  lwz r11, 0x28(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(40 as u32) ) } as u64;
	// 82195CB8: 912B0290  stw r9, 0x290(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(656 as u32), ctx.r[9].u32 ) };
	// 82195CBC: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 82195CC0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 82195CC4: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82195CC8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195CE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82195CE8 size=296
    let mut pc: u32 = 0x82195CE8;
    'dispatch: loop {
        match pc {
            0x82195CE8 => {
    //   block [0x82195CE8..0x82195E10)
	// 82195CE8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82195CEC: 4839F3D1  bl 0x825350bc
	ctx.lr = 0x82195CF0;
	sub_82535080(ctx, base);
	// 82195CF0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82195CF4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82195CF8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82195CFC: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82195D00: 396BE330  addi r11, r11, -0x1cd0
	ctx.r[11].s64 = ctx.r[11].s64 + -7376;
	// 82195D04: 394A0880  addi r10, r10, 0x880
	ctx.r[10].s64 = ctx.r[10].s64 + 2176;
	// 82195D08: 917D0000  stw r11, 0(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82195D0C: 915D0010  stw r10, 0x10(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(16 as u32), ctx.r[10].u32 ) };
	// 82195D10: 481E1AE9  bl 0x823777f8
	ctx.lr = 0x82195D14;
	sub_823777F8(ctx, base);
	// 82195D14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82195D18: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82195D1C: 3BDD0360  addi r30, r29, 0x360
	ctx.r[30].s64 = ctx.r[29].s64 + 864;
	// 82195D20: 3BFD02A0  addi r31, r29, 0x2a0
	ctx.r[31].s64 = ctx.r[29].s64 + 672;
	// 82195D24: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82195D28: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195D2C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82195D30: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195D34: 394B0900  addi r10, r11, 0x900
	ctx.r[10].s64 = ctx.r[11].s64 + 2304;
	// 82195D38: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82195D3C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 82195D40: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 82195D44: 93DF0030  stw r30, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[30].u32 ) };
	// 82195D48: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 82195D4C: D1BF004C  stfs f13, 0x4c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 82195D50: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82195D54: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82195D58: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82195D5C: 917F0028  stw r11, 0x28(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), ctx.r[11].u32 ) };
	// 82195D60: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82195D64: 917F0004  stw r11, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82195D68: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 82195D6C: 917F006C  stw r11, 0x6c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), ctx.r[11].u32 ) };
	// 82195D70: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82195D74: 917F0070  stw r11, 0x70(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82195D78: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82195D7C: 917F0074  stw r11, 0x74(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82195D80: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82195D84: 917F0090  stw r11, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u32 ) };
	// 82195D88: D1BF008C  stfs f13, 0x8c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82195D8C: 917F0060  stw r11, 0x60(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 82195D90: 917E0034  stw r11, 0x34(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 82195D94: 917E0038  stw r11, 0x38(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(56 as u32), ctx.r[11].u32 ) };
	// 82195D98: 917E0040  stw r11, 0x40(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(64 as u32), ctx.r[11].u32 ) };
	// 82195D9C: 917E0044  stw r11, 0x44(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(68 as u32), ctx.r[11].u32 ) };
	// 82195DA0: 917E004C  stw r11, 0x4c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(76 as u32), ctx.r[11].u32 ) };
	// 82195DA4: 917E0050  stw r11, 0x50(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82195DA8: 917E0058  stw r11, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 82195DAC: 917E005C  stw r11, 0x5c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 82195DB0: 917E0064  stw r11, 0x64(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 82195DB4: 917E0068  stw r11, 0x68(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(104 as u32), ctx.r[11].u32 ) };
	// 82195DB8: 917E0070  stw r11, 0x70(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(112 as u32), ctx.r[11].u32 ) };
	// 82195DBC: 917E0074  stw r11, 0x74(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 82195DC0: 917E007C  stw r11, 0x7c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 82195DC4: 917E0080  stw r11, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82195DC8: 917E0088  stw r11, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 82195DCC: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 82195DD0: 917E0094  stw r11, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 82195DD4: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 82195DD8: 93FE0000  stw r31, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[31].u32 ) };
	// 82195DDC: 917E0004  stw r11, 4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), ctx.r[11].u32 ) };
	// 82195DE0: F97D0410  std r11, 0x410(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(1040 as u32), ctx.r[11].u64 ) };
	// 82195DE4: F97D0418  std r11, 0x418(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(1048 as u32), ctx.r[11].u64 ) };
	// 82195DE8: 4BFF4341  bl 0x8218a128
	ctx.lr = 0x82195DEC;
	sub_8218A128(ctx, base);
	// 82195DEC: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 82195DF0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195DF4: 481E4405  bl 0x8237a1f8
	ctx.lr = 0x82195DF8;
	sub_8237A1F8(ctx, base);
	// 82195DF8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 82195DFC: 93FD0404  stw r31, 0x404(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1028 as u32), ctx.r[31].u32 ) };
	// 82195E00: 93DD0408  stw r30, 0x408(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1032 as u32), ctx.r[30].u32 ) };
	// 82195E04: 93BD0400  stw r29, 0x400(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(1024 as u32), ctx.r[29].u32 ) };
	// 82195E08: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 82195E0C: 4839F300  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195E10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82195E10 size=168
    let mut pc: u32 = 0x82195E10;
    'dispatch: loop {
        match pc {
            0x82195E10 => {
    //   block [0x82195E10..0x82195EB8)
	// 82195E10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82195E14: 4839F2A9  bl 0x825350bc
	ctx.lr = 0x82195E18;
	sub_82535080(ctx, base);
	// 82195E18: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82195E1C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82195E20: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 82195E24: 387F0360  addi r3, r31, 0x360
	ctx.r[3].s64 = ctx.r[31].s64 + 864;
	// 82195E28: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 82195E2C: 4BFF447D  bl 0x8218a2a8
	ctx.lr = 0x82195E30;
	sub_8218A2A8(ctx, base);
	// 82195E30: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82195E34: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82195E38: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82195E3C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82195E40: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 82195E44: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 82195E48: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 82195E4C: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82195E50: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 82195E54: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 82195E58: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 82195E5C: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 82195E60: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 82195E64: 7D445B78  or r4, r10, r11
	ctx.r[4].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 82195E68: 481E1FF1  bl 0x82377e58
	ctx.lr = 0x82195E6C;
	sub_82377E58(ctx, base);
	// 82195E6C: 397F0210  addi r11, r31, 0x210
	ctx.r[11].s64 = ctx.r[31].s64 + 528;
	// 82195E70: 39000010  li r8, 0x10
	ctx.r[8].s64 = 16;
	// 82195E74: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 82195E78: 39400030  li r10, 0x30
	ctx.r[10].s64 = 48;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195EB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x82195EB8 size=128
    let mut pc: u32 = 0x82195EB8;
    'dispatch: loop {
        match pc {
            0x82195EB8 => {
    //   block [0x82195EB8..0x82195F38)
	// 82195EB8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 82195EBC: E9230000  ld r9, 0(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82195EC0: 396B6560  addi r11, r11, 0x6560
	ctx.r[11].s64 = ctx.r[11].s64 + 25952;
	// 82195EC4: 7D6A5B78  mr r10, r11
	ctx.r[10].u64 = ctx.r[11].u64;
	// 82195EC8: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82195ECC: E9230008  ld r9, 8(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82195ED0: F92A0008  std r9, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 82195ED4: C1AB0004  lfs f13, 4(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195ED8: EDAD0372  fmuls f13, f13, f13
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[13].f64) as f32) as f64);
	// 82195EDC: C00B0008  lfs f0, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195EE0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82195EE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195EE8: EC00683A  fmadds f0, f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82195EEC: EDAC033A  fmadds f13, f12, f12, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[12].f64 + ctx.f[0].f64) as f32) as f64);
	// 82195EF0: C00A2150  lfs f0, 0x2150(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195EF4: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82195EF8: 40980040  bge cr6, 0x82195f38
	if !ctx.cr[6].lt {
		sub_82195F38(ctx, base);
		return;
	}
	// 82195EFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82195F00: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82195F04: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82195F08: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82195F0C: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82195F10: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82195F14: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82195F18: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82195F1C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 82195F20: 396B6550  addi r11, r11, 0x6550
	ctx.r[11].s64 = ctx.r[11].s64 + 25936;
	// 82195F24: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82195F28: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82195F2C: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82195F30: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82195F34: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82195F38 size=92
    let mut pc: u32 = 0x82195F38;
    'dispatch: loop {
        match pc {
            0x82195F38 => {
    //   block [0x82195F38..0x82195F94)
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195F98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82195F98 size=76
    let mut pc: u32 = 0x82195F98;
    'dispatch: loop {
        match pc {
            0x82195F98 => {
    //   block [0x82195F98..0x82195FD4)
	// 82195F98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82195F9C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82195FA0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82195FA4: 4800004D  bl 0x82195ff0
	ctx.lr = 0x82195FA8;
	sub_82195FF0(ctx, base);
	// 82195FA8: 548B07FE  clrlwi r11, r4, 0x1f
	ctx.r[11].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 82195FAC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82195FB0: 419A0024  beq cr6, 0x82195fd4
	if ctx.cr[6].eq {
	pc = 0x82195FD4; continue 'dispatch;
	}
	// 82195FB4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82195FB8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82195FBC: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82195FC0: 409A0014  bne cr6, 0x82195fd4
	if !ctx.cr[6].eq {
	pc = 0x82195FD4; continue 'dispatch;
	}
	// 82195FC4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82195FC8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82195FCC: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82195FD0: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x82195FD4; continue 'dispatch;
            }
            0x82195FD4 => {
    //   block [0x82195FD4..0x82195FE4)
	// 82195FD4: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82195FD8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82195FDC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82195FE0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195FE8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82195FE8 size=8
    let mut pc: u32 = 0x82195FE8;
    'dispatch: loop {
        match pc {
            0x82195FE8 => {
    //   block [0x82195FE8..0x82195FF0)
	// 82195FE8: 386300A0  addi r3, r3, 0xa0
	ctx.r[3].s64 = ctx.r[3].s64 + 160;
	// 82195FEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82195FF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82195FF0 size=92
    let mut pc: u32 = 0x82195FF0;
    'dispatch: loop {
        match pc {
            0x82195FF0 => {
    //   block [0x82195FF0..0x82196010)
	// 82195FF0: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82195FF4: 81630084  lwz r11, 0x84(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82195FF8: 394A0A1C  addi r10, r10, 0xa1c
	ctx.r[10].s64 = ctx.r[10].s64 + 2588;
	// 82195FFC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82196000: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82196004: 419A000C  beq cr6, 0x82196010
	if ctx.cr[6].eq {
	pc = 0x82196010; continue 'dispatch;
	}
	// 82196008: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219600C: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x82196010; continue 'dispatch;
            }
            0x82196010 => {
    //   block [0x82196010..0x82196024)
	// 82196010: 81630080  lwz r11, 0x80(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82196014: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82196018: 419A000C  beq cr6, 0x82196024
	if ctx.cr[6].eq {
	pc = 0x82196024; continue 'dispatch;
	}
	// 8219601C: 81430084  lwz r10, 0x84(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 82196020: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	pc = 0x82196024; continue 'dispatch;
            }
            0x82196024 => {
    //   block [0x82196024..0x8219603C)
	// 82196024: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 82196028: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219602C: 7F0A1840  cmplw cr6, r10, r3
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[3].u32, &mut ctx.xer);
	// 82196030: 409A000C  bne cr6, 0x8219603c
	if !ctx.cr[6].eq {
	pc = 0x8219603C; continue 'dispatch;
	}
	// 82196034: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 82196038: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x8219603C; continue 'dispatch;
            }
            0x8219603C => {
    //   block [0x8219603C..0x8219604C)
	// 8219603C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82196040: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 82196044: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 82196048: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196050(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196050 size=144
    let mut pc: u32 = 0x82196050;
    'dispatch: loop {
        match pc {
            0x82196050 => {
    //   block [0x82196050..0x82196080)
	// 82196050: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196054: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82196058: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219605C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82196060: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82196064: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82196068: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219606C: C00ABA38  lfs f0, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196070: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82196074: 419A000C  beq cr6, 0x82196080
	if ctx.cr[6].eq {
	pc = 0x82196080; continue 'dispatch;
	}
	// 82196078: C16B0088  lfs f11, 0x88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219607C: 48000008  b 0x82196084
	pc = 0x82196084; continue 'dispatch;
            }
            0x82196080 => {
    //   block [0x82196080..0x82196084)
	// 82196080: FD600090  fmr f11, f0
	ctx.f[11].f64 = ctx.f[0].f64;
	pc = 0x82196084; continue 'dispatch;
            }
            0x82196084 => {
    //   block [0x82196084..0x821960E0)
	// 82196084: 481D10B5  bl 0x82367138
	ctx.lr = 0x82196088;
	sub_82367138(ctx, base);
	// 82196088: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219608C: C1440008  lfs f10, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82196090: C1240004  lfs f9, 4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82196094: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196098: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219609C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821960A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821960A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821960A8: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821960AC: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 821960B0: FCE06018  frsp f7, f12
	ctx.f[7].f64 = (ctx.f[12].f64 as f32) as f64;
	// 821960B4: C18B2280  lfs f12, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821960B8: ED870332  fmuls f12, f7, f12
	ctx.f[12].f64 = (((ctx.f[7].f64 * ctx.f[12].f64) as f32) as f64);
	// 821960BC: EDAC0378  fmsubs f13, f12, f13, f0
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821960C0: EC0D02BA  fmadds f0, f13, f10, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[10].f64 + ctx.f[0].f64) as f32) as f64);
	// 821960C4: EC000272  fmuls f0, f0, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[9].f64) as f32) as f64);
	// 821960C8: EC0042FA  fmadds f0, f0, f11, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64 + ctx.f[8].f64) as f32) as f64);
	// 821960CC: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821960D0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 821960D4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821960D8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821960DC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821960E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821960E0 size=692
    let mut pc: u32 = 0x821960E0;
    'dispatch: loop {
        match pc {
            0x821960E0 => {
    //   block [0x821960E0..0x82196140)
	// 821960E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821960E4: 4839EFD5  bl 0x825350b8
	ctx.lr = 0x821960E8;
	sub_82535080(ctx, base);
	// 821960E8: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821960EC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821960F0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821960F4: 3B8300D0  addi r28, r3, 0xd0
	ctx.r[28].s64 = ctx.r[3].s64 + 208;
	// 821960F8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821960FC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196100: FF02F800  fcmpu cr6, f2, f31
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[31].f64);
	// 82196104: C10B2280  lfs f8, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196108: 40990038  ble cr6, 0x82196140
	if !ctx.cr[6].gt {
	pc = 0x82196140; continue 'dispatch;
	}
	// 8219610C: 481D102D  bl 0x82367138
	ctx.lr = 0x82196110;
	sub_82367138(ctx, base);
	// 82196110: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196114: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82196118: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219611C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82196120: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82196124: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196128: EDA00232  fmuls f13, f0, f8
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 8219612C: C00BD560  lfs f0, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196130: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196134: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196138: D01C0060  stfs f0, 0x60(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219613C: 48000008  b 0x82196144
	pc = 0x82196144; continue 'dispatch;
            }
            0x82196140 => {
    //   block [0x82196140..0x82196144)
	// 82196140: D05C0060  stfs f2, 0x60(r28)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x82196144; continue 'dispatch;
            }
            0x82196144 => {
    //   block [0x82196144..0x82196170)
	// 82196144: FF03F800  fcmpu cr6, f3, f31
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[31].f64);
	// 82196148: 40990028  ble cr6, 0x82196170
	if !ctx.cr[6].gt {
	pc = 0x82196170; continue 'dispatch;
	}
	// 8219614C: 481D0FED  bl 0x82367138
	ctx.lr = 0x82196150;
	sub_82367138(ctx, base);
	// 82196150: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196154: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82196158: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219615C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82196160: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196164: EC000232  fmuls f0, f0, f8
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[8].f64) as f32) as f64);
	// 82196168: D01C0064  stfs f0, 0x64(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219616C: 48000008  b 0x82196174
	pc = 0x82196174; continue 'dispatch;
            }
            0x82196170 => {
    //   block [0x82196170..0x82196174)
	// 82196170: D07C0064  stfs f3, 0x64(r28)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x82196174; continue 'dispatch;
            }
            0x82196174 => {
    //   block [0x82196174..0x821961AC)
	// 82196174: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196178: C04B1FF8  lfs f2, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219617C: FF011000  fcmpu cr6, f1, f2
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[2].f64);
	// 82196180: 4098002C  bge cr6, 0x821961ac
	if !ctx.cr[6].lt {
	pc = 0x821961AC; continue 'dispatch;
	}
	// 82196184: 481D0FB5  bl 0x82367138
	ctx.lr = 0x82196188;
	sub_82367138(ctx, base);
	// 82196188: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219618C: C00B22AC  lfs f0, 0x22ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196190: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196194: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82196198: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219619C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821961A0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821961A4: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 821961A8: EC2DF83A  fmadds f1, f13, f0, f31
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64);
	pc = 0x821961AC; continue 'dispatch;
            }
            0x821961AC => {
    //   block [0x821961AC..0x82196228)
	// 821961AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821961B0: D03C0068  stfs f1, 0x68(r28)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821961B4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821961B8: D3E10050  stfs f31, 0x50(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821961BC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821961C0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821961C4: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 821961C8: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821961CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821961D0: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821961D4: C9682000  lfd f11, 0x2000(r8)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 821961D8: C8C92008  lfd f6, 0x2008(r9)
	ctx.f[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8200 as u32) ) };
	// 821961DC: 3BFC0008  addi r31, r28, 8
	ctx.r[31].s64 = ctx.r[28].s64 + 8;
	// 821961E0: C0EA23D0  lfs f7, 0x23d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9168 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821961E4: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 821961E8: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821961EC: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821961F0: C1ABD564  lfs f13, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821961F4: 3D608200  lis r11, -0x7e00
	ctx.r[11].s64 = -2113929216;
	// 821961F8: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821961FC: C1AB2934  lfs f13, 0x2934(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10548 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196200: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196204: EC61683A  fmadds f3, f1, f0, f13
	ctx.f[3].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82196208: C00B23CC  lfs f0, 0x23cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219620C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196210: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82196214: C18B20B0  lfs f12, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219621C: ED430332  fmuls f10, f3, f12
	ctx.f[10].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196220: C12B2198  lfs f9, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82196224: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	pc = 0x82196228; continue 'dispatch;
            }
            0x82196228 => {
    //   block [0x82196228..0x821962AC)
	// 82196228: 481D0FE1  bl 0x82367208
	ctx.lr = 0x8219622C;
	sub_82367208(ctx, base);
	// 8219622C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196230: EDA001F2  fmuls f13, f0, f7
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[7].f64) as f32) as f64);
	// 82196234: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82196238: C03D0000  lfs f1, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219623C: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82196240: EC210272  fmuls f1, f1, f9
	ctx.f[1].f64 = (((ctx.f[1].f64 * ctx.f[9].f64) as f32) as f64);
	// 82196244: D15F0004  stfs f10, 4(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82196248: D03FFFFC  stfs f1, -4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219624C: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82196250: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82196254: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 82196258: FC0D336E  fsel f0, f13, f13, f6
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[6].f64 };
	// 8219625C: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82196260: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196264: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196268: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 8219626C: D1BFFFF8  stfs f13, -8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82196270: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 82196274: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82196278: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 8219627C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196280: 409AFFA8  bne cr6, 0x82196228
	if !ctx.cr[6].eq {
	pc = 0x82196228; continue 'dispatch;
	}
	// 82196284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196288: EDA30332  fmuls f13, f3, f12
	ctx.f[13].f64 = (((ctx.f[3].f64 * ctx.f[12].f64) as f32) as f64);
	// 8219628C: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 82196290: 389C0024  addi r4, r28, 0x24
	ctx.r[4].s64 = ctx.r[28].s64 + 36;
	// 82196294: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 82196298: C00B2244  lfs f0, 0x2244(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8772 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219629C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821962A0: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 821962A4: EC000332  fmuls f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 821962A8: C18B212C  lfs f12, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	pc = 0x821962AC; continue 'dispatch;
            }
            0x821962AC => {
    //   block [0x821962AC..0x8219630C)
	// 821962AC: 481D0E8D  bl 0x82367138
	ctx.lr = 0x821962B0;
	sub_82367138(ctx, base);
	// 821962B0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821962B4: C15E0000  lfs f10, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821962B8: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821962BC: ED4A0332  fmuls f10, f10, f12
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 821962C0: D1440000  stfs f10, 0(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821962C4: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821962C8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821962CC: D1A40008  stfs f13, 8(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821962D0: FC001090  fmr f0, f2
	ctx.f[0].f64 = ctx.f[2].f64;
	// 821962D4: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821962D8: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821962DC: C9410058  lfd f10, 0x58(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821962E0: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 821962E4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 821962E8: ED4A0232  fmuls f10, f10, f8
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[8].f64) as f32) as f64);
	// 821962EC: D144FFFC  stfs f10, -4(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821962F0: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 821962F4: 409AFFB8  bne cr6, 0x821962ac
	if !ctx.cr[6].eq {
	pc = 0x821962AC; continue 'dispatch;
	}
	// 821962F8: FF041000  fcmpu cr6, f4, f2
	ctx.cr[6].compare_f64(ctx.f[4].f64, ctx.f[2].f64);
	// 821962FC: 41990010  bgt cr6, 0x8219630c
	if ctx.cr[6].gt {
	pc = 0x8219630C; continue 'dispatch;
	}
	// 82196300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196304: C00B23F8  lfs f0, 0x23f8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9208 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196308: 48000010  b 0x82196318
	pc = 0x82196318; continue 'dispatch;
            }
            0x8219630C => {
    //   block [0x8219630C..0x82196318)
	// 8219630C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196310: C00B2054  lfs f0, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196314: EC040032  fmuls f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x82196318; continue 'dispatch;
            }
            0x82196318 => {
    //   block [0x82196318..0x82196338)
	// 82196318: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219631C: ED5F0024  fdivs f10, f31, f0
	ctx.f[10].f64 = ((ctx.f[31].f64 / ctx.f[0].f64) as f32) as f64;
	// 82196320: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82196324: 38BC0044  addi r5, r28, 0x44
	ctx.r[5].s64 = ctx.r[28].s64 + 68;
	// 82196328: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219632C: C18B44A4  lfs f12, 0x44a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17572 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196330: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196334: C12B23F4  lfs f9, 0x23f4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9204 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x82196338; continue 'dispatch;
            }
            0x82196338 => {
    //   block [0x82196338..0x82196394)
	// 82196338: 481D1151  bl 0x82367488
	ctx.lr = 0x8219633C;
	sub_82367488(ctx, base);
	// 8219633C: EC0C01F2  fmuls f0, f12, f7
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[7].f64) as f32) as f64);
	// 82196340: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196344: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82196348: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219634C: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82196350: D1850004  stfs f12, 4(r5)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82196354: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82196358: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219635C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82196360: D1250008  stfs f9, 8(r5)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82196364: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82196368: FC00302E  fsel f0, f0, f0, f6
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[6].f64 };
	// 8219636C: FDA05828  fsub f13, f0, f11
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[11].f64;
	// 82196370: FC0D02EE  fsel f0, f13, f11, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[11].f64 } else { ctx.f[0].f64 };
	// 82196374: FD800018  frsp f12, f0
	ctx.f[12].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196378: 409AFFC0  bne cr6, 0x82196338
	if !ctx.cr[6].eq {
	pc = 0x82196338; continue 'dispatch;
	}
	// 8219637C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196380: C00B23C4  lfs f0, 0x23c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196384: D01C006C  stfs f0, 0x6c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82196388: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219638C: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 82196390: 4839ED78  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196398(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196398 size=532
    let mut pc: u32 = 0x82196398;
    'dispatch: loop {
        match pc {
            0x82196398 => {
    //   block [0x82196398..0x821963F0)
	// 82196398: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219639C: 4839ED1D  bl 0x825350b8
	ctx.lr = 0x821963A0;
	sub_82535080(ctx, base);
	// 821963A0: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821963A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821963A8: 3B8300D0  addi r28, r3, 0xd0
	ctx.r[28].s64 = ctx.r[3].s64 + 208;
	// 821963AC: C1ABD6C8  lfs f13, -0x2938(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821963B0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821963B4: D1BC0060  stfs f13, 0x60(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821963B8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821963BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821963C0: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 821963C4: C14B2280  lfs f10, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821963C8: 40990028  ble cr6, 0x821963f0
	if !ctx.cr[6].gt {
	pc = 0x821963F0; continue 'dispatch;
	}
	// 821963CC: 481D0D6D  bl 0x82367138
	ctx.lr = 0x821963D0;
	sub_82367138(ctx, base);
	// 821963D0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821963D4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821963D8: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821963DC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821963E0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821963E4: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 821963E8: D1BC0064  stfs f13, 0x64(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821963EC: 48000008  b 0x821963f4
	pc = 0x821963F4; continue 'dispatch;
            }
            0x821963F0 => {
    //   block [0x821963F0..0x821963F4)
	// 821963F0: D07C0064  stfs f3, 0x64(r28)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(100 as u32), tmp.u32 ) };
	pc = 0x821963F4; continue 'dispatch;
            }
            0x821963F4 => {
    //   block [0x821963F4..0x8219644C)
	// 821963F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821963F8: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821963FC: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82196400: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82196404: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82196408: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219640C: C1AB23F0  lfs f13, 0x23f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196410: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82196414: D1BC0068  stfs f13, 0x68(r28)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82196418: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8219641C: C9682008  lfd f11, 0x2008(r8)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8200 as u32) ) };
	// 82196420: 3BFC0008  addi r31, r28, 8
	ctx.r[31].s64 = ctx.r[28].s64 + 8;
	// 82196424: C0C923D0  lfs f6, 0x23d0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9168 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82196428: 3BC00002  li r30, 2
	ctx.r[30].s64 = 2;
	// 8219642C: C10A23EC  lfs f8, 0x23ec(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9196 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196430: C00BD564  lfs f0, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196434: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196438: C9872000  lfd f12, 0x2000(r7)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8192 as u32) ) };
	// 8219643C: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 82196440: C1AB23E8  lfs f13, 0x23e8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9192 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196444: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196448: C12B2198  lfs f9, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x8219644C; continue 'dispatch;
            }
            0x8219644C => {
    //   block [0x8219644C..0x821964D4)
	// 8219644C: 481D0DBD  bl 0x82367208
	ctx.lr = 0x82196450;
	sub_82367208(ctx, base);
	// 82196450: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196454: D1BF0000  stfs f13, 0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82196458: EC0D01B2  fmuls f0, f13, f6
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219645C: C0FD0000  lfs f7, 0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82196460: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 82196464: ECE70272  fmuls f7, f7, f9
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[9].f64) as f32) as f64);
	// 82196468: D11F0004  stfs f8, 4(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219646C: D0FFFFFC  stfs f7, -4(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82196470: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 82196474: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82196478: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219647C: FC00582E  fsel f0, f0, f0, f11
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82196480: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82196484: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196488: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219648C: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82196490: D1BFFFF8  stfs f13, -8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82196494: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82196498: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 8219649C: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 821964A0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821964A4: 409AFFA8  bne cr6, 0x8219644c
	if !ctx.cr[6].eq {
	pc = 0x8219644C; continue 'dispatch;
	}
	// 821964A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821964AC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821964B0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821964B4: 3BC10050  addi r30, r1, 0x50
	ctx.r[30].s64 = ctx.r[1].s64 + 80;
	// 821964B8: 389C0024  addi r4, r28, 0x24
	ctx.r[4].s64 = ctx.r[28].s64 + 36;
	// 821964BC: C1AB23E4  lfs f13, 0x23e4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821964C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821964C4: C0E923E0  lfs f7, 0x23e0(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9184 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821964C8: 3BE00002  li r31, 2
	ctx.r[31].s64 = 2;
	// 821964CC: C10A23DC  lfs f8, 0x23dc(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9180 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821964D0: C12B212C  lfs f9, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x821964D4; continue 'dispatch;
            }
            0x821964D4 => {
    //   block [0x821964D4..0x82196554)
	// 821964D4: 481D0C65  bl 0x82367138
	ctx.lr = 0x821964D8;
	sub_82367138(ctx, base);
	// 821964D8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821964DC: D1A40004  stfs f13, 4(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821964E0: EC0D01F2  fmuls f0, f13, f7
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[7].f64) as f32) as f64);
	// 821964E4: C0BE0000  lfs f5, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 821964E8: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 821964EC: ECA50272  fmuls f5, f5, f9
	ctx.f[5].f64 = (((ctx.f[5].f64 * ctx.f[9].f64) as f32) as f64);
	// 821964F0: D1040008  stfs f8, 8(r4)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821964F4: D0A40000  stfs f5, 0(r4)
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821964F8: 3BDE0004  addi r30, r30, 4
	ctx.r[30].s64 = ctx.r[30].s64 + 4;
	// 821964FC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 82196500: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 82196504: FC00582E  fsel f0, f0, f0, f11
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82196508: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219650C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196510: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196514: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82196518: D1A4FFFC  stfs f13, -4(r4)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219651C: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82196520: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 82196524: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82196528: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219652C: 409AFFA8  bne cr6, 0x821964d4
	if !ctx.cr[6].eq {
	pc = 0x821964D4; continue 'dispatch;
	}
	// 82196530: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82196534: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196538: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219653C: 38BC0044  addi r5, r28, 0x44
	ctx.r[5].s64 = ctx.r[28].s64 + 68;
	// 82196540: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82196544: C14B44AC  lfs f10, 0x44ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17580 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82196548: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219654C: C10A2304  lfs f8, 0x2304(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8964 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196550: C12B23C8  lfs f9, 0x23c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	pc = 0x82196554; continue 'dispatch;
            }
            0x82196554 => {
    //   block [0x82196554..0x821965AC)
	// 82196554: 481D0F35  bl 0x82367488
	ctx.lr = 0x82196558;
	sub_82367488(ctx, base);
	// 82196558: EC0A01B2  fmuls f0, f10, f6
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219655C: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196560: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82196564: EDAD0272  fmuls f13, f13, f9
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[9].f64) as f32) as f64);
	// 82196568: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219656C: D1450004  stfs f10, 4(r5)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82196570: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82196574: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82196578: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219657C: D1050008  stfs f8, 8(r5)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82196580: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 82196584: FC00582E  fsel f0, f0, f0, f11
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[11].f64 };
	// 82196588: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 8219658C: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82196590: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196594: 409AFFC0  bne cr6, 0x82196554
	if !ctx.cr[6].eq {
	pc = 0x82196554; continue 'dispatch;
	}
	// 82196598: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219659C: C00B23D8  lfs f0, 0x23d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821965A0: D01C006C  stfs f0, 0x6c(r28)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[28].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821965A4: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821965A8: 4839EB60  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821965B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821965B0 size=888
    let mut pc: u32 = 0x821965B0;
    'dispatch: loop {
        match pc {
            0x821965B0 => {
    //   block [0x821965B0..0x82196614)
	// 821965B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821965B4: 4839EB05  bl 0x825350b8
	ctx.lr = 0x821965B8;
	sub_82535080(ctx, base);
	// 821965B8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821965BC: 4839FA21  bl 0x82535fdc
	ctx.lr = 0x821965C0;
	sub_82535FB0(ctx, base);
	// 821965C0: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821965C4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821965C8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821965CC: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 821965D0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821965D4: 409A0344  bne cr6, 0x82196918
	if !ctx.cr[6].eq {
	pc = 0x82196918; continue 'dispatch;
	}
	// 821965D8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821965DC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821965E0: 3B9E00D0  addi r28, r30, 0xd0
	ctx.r[28].s64 = ctx.r[30].s64 + 208;
	// 821965E4: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 821965E8: 3BFC004C  addi r31, r28, 0x4c
	ctx.r[31].s64 = ctx.r[28].s64 + 76;
	// 821965EC: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 821965F0: C32ABFFC  lfs f25, -0x4004(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 821965F4: C3EB0088  lfs f31, 0x88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821965F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821965FC: C34B1FF8  lfs f26, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82196600: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196604: FFC0D090  fmr f30, f26
	ctx.f[30].f64 = ctx.f[26].f64;
	// 82196608: FFA0D090  fmr f29, f26
	ctx.f[29].f64 = ctx.f[26].f64;
	// 8219660C: FF80D090  fmr f28, f26
	ctx.f[28].f64 = ctx.f[26].f64;
	// 82196610: C36B2490  lfs f27, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	pc = 0x82196614; continue 'dispatch;
            }
            0x82196614 => {
    //   block [0x82196614..0x821966F4)
	// 82196614: 387FFFB4  addi r3, r31, -0x4c
	ctx.r[3].s64 = ctx.r[31].s64 + -76;
	// 82196618: 4BFFFA39  bl 0x82196050
	ctx.lr = 0x8219661C;
	sub_82196050(ctx, base);
	// 8219661C: 387FFFD4  addi r3, r31, -0x2c
	ctx.r[3].s64 = ctx.r[31].s64 + -44;
	// 82196620: 4BFFFA31  bl 0x82196050
	ctx.lr = 0x82196624;
	sub_82196050(ctx, base);
	// 82196624: 387FFFF4  addi r3, r31, -0xc
	ctx.r[3].s64 = ctx.r[31].s64 + -12;
	// 82196628: 4BFFFA29  bl 0x82196050
	ctx.lr = 0x8219662C;
	sub_82196050(ctx, base);
	// 8219662C: C01FFFB4  lfs f0, -0x4c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-76 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196630: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196634: 4BF86E95  bl 0x8211d4c8
	ctx.lr = 0x82196638;
	sub_8211D4C8(ctx, base);
	// 82196638: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8219663C: C1BFFFC0  lfs f13, -0x40(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-64 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196640: C19FFFD4  lfs f12, -0x2c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-44 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196644: EC2C06F2  fmuls f1, f12, f27
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196648: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219664C: EFC0F7FA  fmadds f30, f0, f31, f30
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82196650: 4BF86E79  bl 0x8211d4c8
	ctx.lr = 0x82196654;
	sub_8211D4C8(ctx, base);
	// 82196654: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82196658: C1BFFFE0  lfs f13, -0x20(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219665C: C19FFFF4  lfs f12, -0xc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196660: EC2C06F2  fmuls f1, f12, f27
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196664: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196668: EFA0EFFA  fmadds f29, f0, f31, f29
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 8219666C: 4BF86E5D  bl 0x8211d4c8
	ctx.lr = 0x82196670;
	sub_8211D4C8(ctx, base);
	// 82196670: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82196674: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82196678: C01F0000  lfs f0, 0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219667C: 3BFF0010  addi r31, r31, 0x10
	ctx.r[31].s64 = ctx.r[31].s64 + 16;
	// 82196680: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82196684: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 82196688: EDAD07F2  fmuls f13, f13, f31
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219668C: EFFF0672  fmuls f31, f31, f25
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[25].f64) as f32) as f64);
	// 82196690: EF8DE03A  fmadds f28, f13, f0, f28
	ctx.f[28].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[28].f64) as f32) as f64);
	// 82196694: 409AFF80  bne cr6, 0x82196614
	if !ctx.cr[6].eq {
	pc = 0x82196614; continue 'dispatch;
	}
	// 82196698: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219669C: C00B219C  lfs f0, 0x219c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821966A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821966A4: EDBC0032  fmuls f13, f28, f0
	ctx.f[13].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 821966A8: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821966AC: ED7D0032  fmuls f11, f29, f0
	ctx.f[11].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821966B0: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821966B4: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 821966B8: 4098003C  bge cr6, 0x821966f4
	if !ctx.cr[6].lt {
	pc = 0x821966F4; continue 'dispatch;
	}
	// 821966BC: 481D0B4D  bl 0x82367208
	ctx.lr = 0x821966C0;
	sub_82367208(ctx, base);
	// 821966C0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821966C4: C15C006C  lfs f10, 0x6c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(108 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821966C8: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821966CC: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821966D0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821966D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821966D8: FD200018  frsp f9, f0
	ctx.f[9].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821966DC: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821966E0: EC090032  fmuls f0, f9, f0
	ctx.f[0].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 821966E4: FF005000  fcmpu cr6, f0, f10
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[10].f64);
	// 821966E8: 4098000C  bge cr6, 0x821966f4
	if !ctx.cr[6].lt {
	pc = 0x821966F4; continue 'dispatch;
	}
	// 821966EC: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 821966F0: 48000008  b 0x821966f8
	pc = 0x821966F8; continue 'dispatch;
            }
            0x821966F4 => {
    //   block [0x821966F4..0x821966F8)
	// 821966F4: EC0DF02A  fadds f0, f13, f30
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	pc = 0x821966F8; continue 'dispatch;
            }
            0x821966F8 => {
    //   block [0x821966F8..0x82196760)
	// 821966F8: C1BC0060  lfs f13, 0x60(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821966FC: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82196700: D1BE0180  stfs f13, 0x180(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82196704: C1BC0064  lfs f13, 0x64(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196708: EDAD582A  fadds f13, f13, f11
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[11].f64) as f32) as f64;
	// 8219670C: D1BE0184  stfs f13, 0x184(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82196710: C1BC0068  lfs f13, 0x68(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196714: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196718: D3FE0188  stfs f31, 0x188(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8219671C: FF1FD000  fcmpu cr6, f31, f26
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[26].f64);
	// 82196720: 40990060  ble cr6, 0x82196780
	if !ctx.cr[6].gt {
	pc = 0x82196780; continue 'dispatch;
	}
	// 82196724: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196728: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219672C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82196730: 40980030  bge cr6, 0x82196760
	if !ctx.cr[6].lt {
	pc = 0x82196760; continue 'dispatch;
	}
	// 82196734: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196738: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219673C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196740: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196744: C00B2648  lfs f0, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196748: EC2D06FA  fmadds f1, f13, f27, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 8219674C: 4BF86D7D  bl 0x8211d4c8
	ctx.lr = 0x82196750;
	sub_8211D4C8(ctx, base);
	// 82196750: EC01F02A  fadds f0, f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[30].f64) as f32) as f64;
	// 82196754: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82196758: D01E0188  stfs f0, 0x188(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8219675C: 48000028  b 0x82196784
	pc = 0x82196784; continue 'dispatch;
            }
            0x82196760 => {
    //   block [0x82196760..0x82196780)
	// 82196760: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196764: EC3FF028  fsubs f1, f31, f30
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82196768: C84B2970  lfd f2, 0x2970(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(10608 as u32) ) };
	// 8219676C: 4839D005  bl 0x82533770
	ctx.lr = 0x82196770;
	sub_82533770(ctx, base);
	// 82196770: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82196774: EC00F02A  fadds f0, f0, f30
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[30].f64) as f32) as f64;
	// 82196778: D01E0188  stfs f0, 0x188(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 8219677C: 48000008  b 0x82196784
	pc = 0x82196784; continue 'dispatch;
            }
            0x82196780 => {
    //   block [0x82196780..0x82196784)
	// 82196780: D35E0188  stfs f26, 0x188(r30)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(392 as u32), tmp.u32 ) };
	pc = 0x82196784; continue 'dispatch;
            }
            0x82196784 => {
    //   block [0x82196784..0x821967C0)
	// 82196784: C01E0180  lfs f0, 0x180(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196788: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219678C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82196790: C3FE0184  lfs f31, 0x184(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82196794: C3AB2048  lfs f29, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82196798: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 8219679C: 41980064  blt cr6, 0x82196800
	if ctx.cr[6].lt {
	pc = 0x82196800; continue 'dispatch;
	}
	// 821967A0: EC00E828  fsubs f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 821967A4: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 821967A8: 4098003C  bge cr6, 0x821967e4
	if !ctx.cr[6].lt {
	pc = 0x821967E4; continue 'dispatch;
	}
	// 821967AC: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821967B0: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821967B4: 4098000C  bge cr6, 0x821967c0
	if !ctx.cr[6].lt {
	pc = 0x821967C0; continue 'dispatch;
	}
	// 821967B8: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821967BC: 48000040  b 0x821967fc
	pc = 0x821967FC; continue 'dispatch;
            }
            0x821967C0 => {
    //   block [0x821967C0..0x821967E4)
	// 821967C0: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821967C4: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821967C8: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821967CC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821967D0: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821967D4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821967D8: 41980024  blt cr6, 0x821967fc
	if ctx.cr[6].lt {
	pc = 0x821967FC; continue 'dispatch;
	}
	// 821967DC: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 821967E0: 4800001C  b 0x821967fc
	pc = 0x821967FC; continue 'dispatch;
            }
            0x821967E4 => {
    //   block [0x821967E4..0x821967FC)
	// 821967E4: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 821967E8: 41980014  blt cr6, 0x821967fc
	if ctx.cr[6].lt {
	pc = 0x821967FC; continue 'dispatch;
	}
	// 821967EC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821967F0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821967F4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821967F8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821967FC; continue 'dispatch;
            }
            0x821967FC => {
    //   block [0x821967FC..0x82196800)
	// 821967FC: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	pc = 0x82196800; continue 'dispatch;
            }
            0x82196800 => {
    //   block [0x82196800..0x82196840)
	// 82196800: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82196804: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196808: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219680C: 4BF7B5C5  bl 0x82111dd0
	ctx.lr = 0x82196810;
	sub_82111DD0(ctx, base);
	// 82196810: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82196814: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82196818: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 8219681C: 41980064  blt cr6, 0x82196880
	if ctx.cr[6].lt {
	pc = 0x82196880; continue 'dispatch;
	}
	// 82196820: EC1FE828  fsubs f0, f31, f29
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[29].f64) as f32) as f64);
	// 82196824: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196828: 4098003C  bge cr6, 0x82196864
	if !ctx.cr[6].lt {
	pc = 0x82196864; continue 'dispatch;
	}
	// 8219682C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196830: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82196834: 4098000C  bge cr6, 0x82196840
	if !ctx.cr[6].lt {
	pc = 0x82196840; continue 'dispatch;
	}
	// 82196838: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219683C: 48000040  b 0x8219687c
	pc = 0x8219687C; continue 'dispatch;
            }
            0x82196840 => {
    //   block [0x82196840..0x82196864)
	// 82196840: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196844: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196848: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219684C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196850: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196854: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82196858: 41980024  blt cr6, 0x8219687c
	if ctx.cr[6].lt {
	pc = 0x8219687C; continue 'dispatch;
	}
	// 8219685C: FC00D090  fmr f0, f26
	ctx.f[0].f64 = ctx.f[26].f64;
	// 82196860: 4800001C  b 0x8219687c
	pc = 0x8219687C; continue 'dispatch;
            }
            0x82196864 => {
    //   block [0x82196864..0x8219687C)
	// 82196864: FF00F000  fcmpu cr6, f0, f30
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[30].f64);
	// 82196868: 41980014  blt cr6, 0x8219687c
	if ctx.cr[6].lt {
	pc = 0x8219687C; continue 'dispatch;
	}
	// 8219686C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196870: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196874: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196878: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x8219687C; continue 'dispatch;
            }
            0x8219687C => {
    //   block [0x8219687C..0x82196880)
	// 8219687C: EC00C828  fsubs f0, f0, f25
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[25].f64) as f32) as f64);
	pc = 0x82196880; continue 'dispatch;
            }
            0x82196880 => {
    //   block [0x82196880..0x82196918)
	// 82196880: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82196884: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196888: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219688C: 4BF7B545  bl 0x82111dd0
	ctx.lr = 0x82196890;
	sub_82111DD0(ctx, base);
	// 82196890: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196894: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196898: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219689C: C19E0188  lfs f12, 0x188(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821968A0: C0FE00B4  lfs f7, 0xb4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(180 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821968A4: C1210060  lfs f9, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 821968A8: C11E00B0  lfs f8, 0xb0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 821968AC: C1AB296C  lfs f13, 0x296c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821968B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821968B4: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968B8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821968BC: C0DE00B8  lfs f6, 0xb8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 821968C0: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968C4: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821968C8: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968CC: C00B295C  lfs f0, 0x295c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821968D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821968D4: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 821968D8: C1AB2960  lfs f13, 0x2960(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821968DC: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968E0: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968E4: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821968E8: ECC60372  fmuls f6, f6, f13
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 821968EC: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 821968F0: C15E00BC  lfs f10, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 821968F4: EDAA037A  fmadds f13, f10, f13, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 821968F8: D1BE00BC  stfs f13, 0xbc(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 821968FC: EDA9383A  fmadds f13, f9, f0, f7
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82196900: D1BE00B4  stfs f13, 0xb4(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82196904: EDAB403A  fmadds f13, f11, f0, f8
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82196908: D1BE00B0  stfs f13, 0xb0(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219690C: EC0C303A  fmadds f0, f12, f0, f6
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 82196910: D01E00B8  stfs f0, 0xb8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82196914: D3DE00BC  stfs f30, 0xbc(r30)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(188 as u32), tmp.u32 ) };
	pc = 0x82196918; continue 'dispatch;
            }
            0x82196918 => {
    //   block [0x82196918..0x82196928)
	// 82196918: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8219691C: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82196920: 4839F709  bl 0x82536028
	ctx.lr = 0x82196924;
	sub_82535FFC(ctx, base);
	// 82196924: 4839E7E4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196928(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82196928 size=56
    let mut pc: u32 = 0x82196928;
    'dispatch: loop {
        match pc {
            0x82196928 => {
    //   block [0x82196928..0x82196960)
	// 82196928: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219692C: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 82196930: 386B00A0  addi r3, r11, 0xa0
	ctx.r[3].s64 = ctx.r[11].s64 + 160;
	// 82196934: 396B00B0  addi r11, r11, 0xb0
	ctx.r[11].s64 = ctx.r[11].s64 + 176;
	// 82196938: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219693C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82196940: F9430000  std r10, 0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82196944: F9630008  std r11, 8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82196948: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8219694C: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 82196950: F9660000  std r11, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82196954: E9630008  ld r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82196958: F9660008  std r11, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219695C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196960(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196960 size=208
    let mut pc: u32 = 0x82196960;
    'dispatch: loop {
        match pc {
            0x82196960 => {
    //   block [0x82196960..0x821969A8)
	// 82196960: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196964: 4839E759  bl 0x825350bc
	ctx.lr = 0x82196968;
	sub_82535080(ctx, base);
	// 82196968: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219696C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82196970: C0440008  lfs f2, 8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 82196974: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 82196978: C0240000  lfs f1, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219697C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82196980: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 82196984: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 82196988: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219698C: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 82196990: 48020BA1  bl 0x821b7530
	ctx.lr = 0x82196994;
	sub_821B7530(ctx, base);
	// 82196994: 81610050  lwz r11, 0x50(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 82196998: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219699C: 419A000C  beq cr6, 0x821969a8
	if ctx.cr[6].eq {
	pc = 0x821969A8; continue 'dispatch;
	}
	// 821969A0: 896B000C  lbz r11, 0xc(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821969A4: 556B073E  clrlwi r11, r11, 0x1c
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	pc = 0x821969A8; continue 'dispatch;
            }
            0x821969A8 => {
    //   block [0x821969A8..0x821969DC)
	// 821969A8: 7D6B07B4  extsw r11, r11
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 821969AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821969B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821969B4: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821969B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821969BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821969C0: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821969C4: C00B2128  lfs f0, 0x2128(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8488 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821969C8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969CC: 409A0010  bne cr6, 0x821969dc
	if !ctx.cr[6].eq {
	pc = 0x821969DC; continue 'dispatch;
	}
	// 821969D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821969D4: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969D8: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	pc = 0x821969DC; continue 'dispatch;
            }
            0x821969DC => {
    //   block [0x821969DC..0x82196A28)
	// 821969DC: 387F00A0  addi r3, r31, 0xa0
	ctx.r[3].s64 = ctx.r[31].s64 + 160;
	// 821969E0: C1BF00B0  lfs f13, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969E4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969E8: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821969EC: D1A30000  stfs f13, 0(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821969F0: C1BF00B4  lfs f13, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821969F4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821969F8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821969FC: C1BF00B8  lfs f13, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196A00: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196A04: D1A30008  stfs f13, 8(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82196A08: C1BF00BC  lfs f13, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196A0C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196A10: D003000C  stfs f0, 0xc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82196A14: 419A0014  beq cr6, 0x82196a28
	if ctx.cr[6].eq {
	pc = 0x82196A28; continue 'dispatch;
	}
	// 82196A18: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 82196A1C: F97D0000  std r11, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 82196A20: E9630008  ld r11, 8(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	// 82196A24: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x82196A28; continue 'dispatch;
            }
            0x82196A28 => {
    //   block [0x82196A28..0x82196A30)
	// 82196A28: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 82196A2C: 4839E6E0  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196A30(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82196A30 size=28
    let mut pc: u32 = 0x82196A30;
    'dispatch: loop {
        match pc {
            0x82196A30 => {
    //   block [0x82196A30..0x82196A4C)
	// 82196A30: 39630150  addi r11, r3, 0x150
	ctx.r[11].s64 = ctx.r[3].s64 + 336;
	// 82196A34: 394301D0  addi r10, r3, 0x1d0
	ctx.r[10].s64 = ctx.r[3].s64 + 464;
	// 82196A38: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 82196A3C: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82196A40: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 82196A44: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 82196A48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196A50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82196A50 size=1276
    let mut pc: u32 = 0x82196A50;
    'dispatch: loop {
        match pc {
            0x82196A50 => {
    //   block [0x82196A50..0x82196AD0)
	// 82196A50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196A54: 4839E665  bl 0x825350b8
	ctx.lr = 0x82196A58;
	sub_82535080(ctx, base);
	// 82196A58: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82196A5C: 4839F57D  bl 0x82535fd8
	ctx.lr = 0x82196A60;
	sub_82535FB0(ctx, base);
	// 82196A60: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82196A64: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82196A68: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82196A6C: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82196A70: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82196A74: 409A04C8  bne cr6, 0x82196f3c
	if !ctx.cr[6].eq {
	pc = 0x82196F3C; continue 'dispatch;
	}
	// 82196A78: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196A7C: 3B9F00D0  addi r28, r31, 0xd0
	ctx.r[28].s64 = ctx.r[31].s64 + 208;
	// 82196A80: 3BDC0020  addi r30, r28, 0x20
	ctx.r[30].s64 = ctx.r[28].s64 + 32;
	// 82196A84: C32B1FF8  lfs f25, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82196A88: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82196A8C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82196A90: FFC0C890  fmr f30, f25
	ctx.f[30].f64 = ctx.f[25].f64;
	// 82196A94: FFA0C890  fmr f29, f25
	ctx.f[29].f64 = ctx.f[25].f64;
	// 82196A98: C34BBA38  lfs f26, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 82196A9C: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	// 82196AA0: 4BFFF5B1  bl 0x82196050
	ctx.lr = 0x82196AA4;
	sub_82196050(ctx, base);
	// 82196AA4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196AA8: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AAC: C36B2490  lfs f27, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82196AB0: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AB4: 4BF86A15  bl 0x8211d4c8
	ctx.lr = 0x82196AB8;
	sub_8211D4C8(ctx, base);
	// 82196AB8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196ABC: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AC0: 3BDC0030  addi r30, r28, 0x30
	ctx.r[30].s64 = ctx.r[28].s64 + 48;
	// 82196AC4: EF810032  fmuls f28, f1, f0
	ctx.f[28].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196AC8: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82196ACC: C30BBFFC  lfs f24, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[24].f64 = (tmp.f32 as f64);
	pc = 0x82196AD0; continue 'dispatch;
            }
            0x82196AD0 => {
    //   block [0x82196AD0..0x82196B80)
	// 82196AD0: 387EFFD0  addi r3, r30, -0x30
	ctx.r[3].s64 = ctx.r[30].s64 + -48;
	// 82196AD4: 4BFFF57D  bl 0x82196050
	ctx.lr = 0x82196AD8;
	sub_82196050(ctx, base);
	// 82196AD8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82196ADC: 4BFFF575  bl 0x82196050
	ctx.lr = 0x82196AE0;
	sub_82196050(ctx, base);
	// 82196AE0: C01EFFD0  lfs f0, -0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196AE4: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AE8: 4BF869E1  bl 0x8211d4c8
	ctx.lr = 0x82196AEC;
	sub_8211D4C8(ctx, base);
	// 82196AEC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 82196AF0: C1BEFFDC  lfs f13, -0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196AF4: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196AF8: EC2C06F2  fmuls f1, f12, f27
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196AFC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196B00: EFC0F7FA  fmadds f30, f0, f31, f30
	ctx.f[30].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[30].f64) as f32) as f64);
	// 82196B04: 4BF869C5  bl 0x8211d4c8
	ctx.lr = 0x82196B08;
	sub_8211D4C8(ctx, base);
	// 82196B08: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 82196B0C: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B10: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82196B14: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82196B18: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82196B1C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B20: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82196B24: EFA0EFFA  fmadds f29, f0, f31, f29
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 82196B28: EFFF0632  fmuls f31, f31, f24
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[24].f64) as f32) as f64);
	// 82196B2C: 409AFFA4  bne cr6, 0x82196ad0
	if !ctx.cr[6].eq {
	pc = 0x82196AD0; continue 'dispatch;
	}
	// 82196B30: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196B34: C00B219C  lfs f0, 0x219c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B38: EDBD0032  fmuls f13, f29, f0
	ctx.f[13].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B3C: ED9E0032  fmuls f12, f30, f0
	ctx.f[12].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B40: FF0DC800  fcmpu cr6, f13, f25
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[25].f64);
	// 82196B44: 4098003C  bge cr6, 0x82196b80
	if !ctx.cr[6].lt {
	pc = 0x82196B80; continue 'dispatch;
	}
	// 82196B48: 481D06C1  bl 0x82367208
	ctx.lr = 0x82196B4C;
	sub_82367208(ctx, base);
	// 82196B4C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82196B50: C17C005C  lfs f11, 0x5c(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82196B54: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82196B58: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82196B5C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82196B60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196B64: FD400018  frsp f10, f0
	ctx.f[10].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82196B68: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196B6C: EC0A0032  fmuls f0, f10, f0
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196B70: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 82196B74: 4098000C  bge cr6, 0x82196b80
	if !ctx.cr[6].lt {
	pc = 0x82196B80; continue 'dispatch;
	}
	// 82196B78: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196B7C: 48000008  b 0x82196b84
	pc = 0x82196B84; continue 'dispatch;
            }
            0x82196B80 => {
    //   block [0x82196B80..0x82196B84)
	// 82196B80: EC0DD02A  fadds f0, f13, f26
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[26].f64) as f32) as f64;
	pc = 0x82196B84; continue 'dispatch;
            }
            0x82196B84 => {
    //   block [0x82196B84..0x82196BEC)
	// 82196B84: C1BC0050  lfs f13, 0x50(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196B88: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82196B8C: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82196B90: C1BC0054  lfs f13, 0x54(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196B94: EDADE02A  fadds f13, f13, f28
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[28].f64) as f32) as f64;
	// 82196B98: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82196B9C: C1BC0058  lfs f13, 0x58(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196BA0: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196BA4: D3FF0188  stfs f31, 0x188(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196BA8: FF1FC800  fcmpu cr6, f31, f25
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[25].f64);
	// 82196BAC: 40990060  ble cr6, 0x82196c0c
	if !ctx.cr[6].gt {
	pc = 0x82196C0C; continue 'dispatch;
	}
	// 82196BB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BB4: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BB8: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82196BBC: 40980030  bge cr6, 0x82196bec
	if !ctx.cr[6].lt {
	pc = 0x82196BEC; continue 'dispatch;
	}
	// 82196BC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BC4: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BC8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BCC: EDBF0032  fmuls f13, f31, f0
	ctx.f[13].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82196BD0: C00B2648  lfs f0, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196BD4: EC2D06FA  fmadds f1, f13, f27, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[27].f64 + ctx.f[0].f64) as f32) as f64);
	// 82196BD8: 4BF868F1  bl 0x8211d4c8
	ctx.lr = 0x82196BDC;
	sub_8211D4C8(ctx, base);
	// 82196BDC: EC01D02A  fadds f0, f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 82196BE0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82196BE4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196BE8: 48000028  b 0x82196c10
	pc = 0x82196C10; continue 'dispatch;
            }
            0x82196BEC => {
    //   block [0x82196BEC..0x82196C0C)
	// 82196BEC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196BF0: EC3FD028  fsubs f1, f31, f26
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82196BF4: C84B2970  lfd f2, 0x2970(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(10608 as u32) ) };
	// 82196BF8: 4839CB79  bl 0x82533770
	ctx.lr = 0x82196BFC;
	sub_82533770(ctx, base);
	// 82196BFC: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82196C00: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82196C04: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82196C08: 48000008  b 0x82196c10
	pc = 0x82196C10; continue 'dispatch;
            }
            0x82196C0C => {
    //   block [0x82196C0C..0x82196C10)
	// 82196C0C: D33F0188  stfs f25, 0x188(r31)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	pc = 0x82196C10; continue 'dispatch;
            }
            0x82196C10 => {
    //   block [0x82196C10..0x82196C4C)
	// 82196C10: C01F0180  lfs f0, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196C14: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82196C18: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82196C1C: C3FF0184  lfs f31, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82196C20: C3CB2048  lfs f30, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82196C24: FF0DC000  fcmpu cr6, f13, f24
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[24].f64);
	// 82196C28: 41980064  blt cr6, 0x82196c8c
	if ctx.cr[6].lt {
	pc = 0x82196C8C; continue 'dispatch;
	}
	// 82196C2C: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82196C30: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82196C34: 4098003C  bge cr6, 0x82196c70
	if !ctx.cr[6].lt {
	pc = 0x82196C70; continue 'dispatch;
	}
	// 82196C38: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196C3C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C40: 4098000C  bge cr6, 0x82196c4c
	if !ctx.cr[6].lt {
	pc = 0x82196C4C; continue 'dispatch;
	}
	// 82196C44: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196C48: 48000040  b 0x82196c88
	pc = 0x82196C88; continue 'dispatch;
            }
            0x82196C4C => {
    //   block [0x82196C4C..0x82196C70)
	// 82196C4C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196C50: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196C54: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196C58: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196C5C: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196C60: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C64: 41980024  blt cr6, 0x82196c88
	if ctx.cr[6].lt {
	pc = 0x82196C88; continue 'dispatch;
	}
	// 82196C68: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196C6C: 4800001C  b 0x82196c88
	pc = 0x82196C88; continue 'dispatch;
            }
            0x82196C70 => {
    //   block [0x82196C70..0x82196C88)
	// 82196C70: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196C74: 41980014  blt cr6, 0x82196c88
	if ctx.cr[6].lt {
	pc = 0x82196C88; continue 'dispatch;
	}
	// 82196C78: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196C7C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196C80: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196C84: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82196C88; continue 'dispatch;
            }
            0x82196C88 => {
    //   block [0x82196C88..0x82196C8C)
	// 82196C88: EC00C028  fsubs f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	pc = 0x82196C8C; continue 'dispatch;
            }
            0x82196C8C => {
    //   block [0x82196C8C..0x82196CCC)
	// 82196C8C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82196C90: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196C94: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82196C98: 4BF7B139  bl 0x82111dd0
	ctx.lr = 0x82196C9C;
	sub_82111DD0(ctx, base);
	// 82196C9C: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82196CA0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82196CA4: FF0DC000  fcmpu cr6, f13, f24
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[24].f64);
	// 82196CA8: 41980064  blt cr6, 0x82196d0c
	if ctx.cr[6].lt {
	pc = 0x82196D0C; continue 'dispatch;
	}
	// 82196CAC: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82196CB0: FF00C800  fcmpu cr6, f0, f25
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[25].f64);
	// 82196CB4: 4098003C  bge cr6, 0x82196cf0
	if !ctx.cr[6].lt {
	pc = 0x82196CF0; continue 'dispatch;
	}
	// 82196CB8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196CBC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CC0: 4098000C  bge cr6, 0x82196ccc
	if !ctx.cr[6].lt {
	pc = 0x82196CCC; continue 'dispatch;
	}
	// 82196CC4: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196CC8: 48000040  b 0x82196d08
	pc = 0x82196D08; continue 'dispatch;
            }
            0x82196CCC => {
    //   block [0x82196CCC..0x82196CF0)
	// 82196CCC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196CD0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196CD4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196CD8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82196CDC: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82196CE0: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CE4: 41980024  blt cr6, 0x82196d08
	if ctx.cr[6].lt {
	pc = 0x82196D08; continue 'dispatch;
	}
	// 82196CE8: FC00C890  fmr f0, f25
	ctx.f[0].f64 = ctx.f[25].f64;
	// 82196CEC: 4800001C  b 0x82196d08
	pc = 0x82196D08; continue 'dispatch;
            }
            0x82196CF0 => {
    //   block [0x82196CF0..0x82196D08)
	// 82196CF0: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82196CF4: 41980014  blt cr6, 0x82196d08
	if ctx.cr[6].lt {
	pc = 0x82196D08; continue 'dispatch;
	}
	// 82196CF8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82196CFC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82196D00: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82196D04: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82196D08; continue 'dispatch;
            }
            0x82196D08 => {
    //   block [0x82196D08..0x82196D0C)
	// 82196D08: EC00C028  fsubs f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[24].f64) as f32) as f64);
	pc = 0x82196D0C; continue 'dispatch;
            }
            0x82196D0C => {
    //   block [0x82196D0C..0x82196F3C)
	// 82196D0C: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82196D10: EC2006F2  fmuls f1, f0, f27
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[27].f64) as f32) as f64);
	// 82196D14: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82196D18: 4BF7B0B9  bl 0x82111dd0
	ctx.lr = 0x82196D1C;
	sub_82111DD0(ctx, base);
	// 82196D1C: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D20: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82196D24: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D28: C19F0188  lfs f12, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82196D2C: 397F00B0  addi r11, r31, 0xb0
	ctx.r[11].s64 = ctx.r[31].s64 + 176;
	// 82196D30: C1210060  lfs f9, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82196D34: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82196D38: C1AA296C  lfs f13, 0x296c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D40: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D44: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D48: C10B0004  lfs f8, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82196D4C: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82196D50: C0EB0008  lfs f7, 8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82196D54: 1180034A  vcfsx v12, v0, 0
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82196D58: C0CB000C  lfs f6, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82196D5C: ED600372  fmuls f11, f0, f13
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D60: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D64: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D68: C00A295C  lfs f0, 0x295c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82196D6C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82196D70: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D74: C1AA2960  lfs f13, 0x2960(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82196D78: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82196D7C: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D80: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D84: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D88: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82196D8C: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82196D90: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82196D94: EDA6037A  fmadds f13, f6, f13, f0
	ctx.f[13].f64 = (((ctx.f[6].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82196D98: D1AB000C  stfs f13, 0xc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82196D9C: EDAB503A  fmadds f13, f11, f0, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 82196DA0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82196DA4: EDA9403A  fmadds f13, f9, f0, f8
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82196DA8: D1AB0004  stfs f13, 4(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82196DAC: EC0C383A  fmadds f0, f12, f0, f7
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82196DB0: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	pc = 0x82196F3C; continue 'dispatch;
            }
            0x82196F3C => {
    //   block [0x82196F3C..0x82196F4C)
	// 82196F3C: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 82196F40: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82196F44: 4839F0E1  bl 0x82536024
	ctx.lr = 0x82196F48;
	sub_82535FFC(ctx, base);
	// 82196F48: 4839E1C0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82196F50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82196F50 size=688
    let mut pc: u32 = 0x82196F50;
    'dispatch: loop {
        match pc {
            0x82196F50 => {
    //   block [0x82196F50..0x82197200)
	// 82196F50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82196F54: 4839E169  bl 0x825350bc
	ctx.lr = 0x82196F58;
	sub_82535080(ctx, base);
	// 82196F58: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82196F5C: 4839F081  bl 0x82535fdc
	ctx.lr = 0x82196F60;
	sub_82535FB0(ctx, base);
	// 82196F60: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82196F64: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197200(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82197200 size=744
    let mut pc: u32 = 0x82197200;
    'dispatch: loop {
        match pc {
            0x82197200 => {
    //   block [0x82197200..0x8219723C)
	// 82197200: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197204: 4839DEB5  bl 0x825350b8
	ctx.lr = 0x82197208;
	sub_82535080(ctx, base);
	// 82197208: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219720C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82197210: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197214: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82197218: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219721C: C18ABA38  lfs f12, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197220: C16BD564  lfs f11, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197224: 409A0018  bne cr6, 0x8219723c
	if !ctx.cr[6].eq {
	pc = 0x8219723C; continue 'dispatch;
	}
	// 82197228: D17F0080  stfs f11, 0x80(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219722C: D19F0084  stfs f12, 0x84(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82197230: D17F0088  stfs f11, 0x88(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82197234: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82197238: 48000018  b 0x82197250
	pc = 0x82197250; continue 'dispatch;
            }
            0x8219723C => {
    //   block [0x8219723C..0x82197250)
	// 8219723C: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82197240: 397F0080  addi r11, r31, 0x80
	ctx.r[11].s64 = ctx.r[31].s64 + 128;
	// 82197244: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82197248: E9470008  ld r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 8219724C: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x82197250; continue 'dispatch;
            }
            0x82197250 => {
    //   block [0x82197250..0x821972A0)
	// 82197250: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197254: D19F008C  stfs f12, 0x8c(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82197258: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219725C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197260: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 82197264: C0CB2280  lfs f6, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82197268: 40990038  ble cr6, 0x821972a0
	if !ctx.cr[6].gt {
	pc = 0x821972A0; continue 'dispatch;
	}
	// 8219726C: 481CFECD  bl 0x82367138
	ctx.lr = 0x82197270;
	sub_82367138(ctx, base);
	// 82197270: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82197274: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82197278: C9A10050  lfd f13, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219727C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197280: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197284: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197288: ED4D01B2  fmuls f10, f13, f6
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219728C: C1ABD560  lfs f13, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197290: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197294: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197298: D1BF0050  stfs f13, 0x50(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219729C: 48000008  b 0x821972a4
	pc = 0x821972A4; continue 'dispatch;
            }
            0x821972A0 => {
    //   block [0x821972A0..0x821972A4)
	// 821972A0: D05F0050  stfs f2, 0x50(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x821972A4; continue 'dispatch;
            }
            0x821972A4 => {
    //   block [0x821972A4..0x821972D0)
	// 821972A4: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 821972A8: 40990028  ble cr6, 0x821972d0
	if !ctx.cr[6].gt {
	pc = 0x821972D0; continue 'dispatch;
	}
	// 821972AC: 481CFE8D  bl 0x82367138
	ctx.lr = 0x821972B0;
	sub_82367138(ctx, base);
	// 821972B0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821972B4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821972B8: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821972BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821972C0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821972C4: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 821972C8: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821972CC: 48000008  b 0x821972d4
	pc = 0x821972D4; continue 'dispatch;
            }
            0x821972D0 => {
    //   block [0x821972D0..0x821972D4)
	// 821972D0: D07F0054  stfs f3, 0x54(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x821972D4; continue 'dispatch;
            }
            0x821972D4 => {
    //   block [0x821972D4..0x82197320)
	// 821972D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821972D8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821972DC: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821972E0: 40980040  bge cr6, 0x82197320
	if !ctx.cr[6].lt {
	pc = 0x82197320; continue 'dispatch;
	}
	// 821972E4: 481CFE55  bl 0x82367138
	ctx.lr = 0x821972E8;
	sub_82367138(ctx, base);
	// 821972E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821972EC: C00B22AC  lfs f0, 0x22ac(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8876 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821972F0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821972F4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821972F8: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821972FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197304: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197308: ED4D01B2  fmuls f10, f13, f6
	ctx.f[10].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219730C: C1AB2328  lfs f13, 0x2328(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9000 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197310: EC0A683A  fmadds f0, f10, f0, f13
	ctx.f[0].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82197314: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82197318: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8219731C: 48000008  b 0x82197324
	pc = 0x82197324; continue 'dispatch;
            }
            0x82197320 => {
    //   block [0x82197320..0x82197324)
	// 82197320: D03F0058  stfs f1, 0x58(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x82197324; continue 'dispatch;
            }
            0x82197324 => {
    //   block [0x82197324..0x82197394)
	// 82197324: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197328: D1610054  stfs f11, 0x54(r1)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219732C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82197330: D1810050  stfs f12, 0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82197334: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82197338: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219733C: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 82197340: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197344: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197348: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219734C: C9882000  lfd f12, 0x2000(r8)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 82197350: C9292008  lfd f9, 0x2008(r9)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8200 as u32) ) };
	// 82197354: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82197358: C14A23D0  lfs f10, 0x23d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219735C: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 82197360: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197364: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82197368: C08BD5B0  lfs f4, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219736C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197370: EC01203A  fmadds f0, f1, f0, f4
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[4].f64) as f32) as f64);
	// 82197374: C16B20B0  lfs f11, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197378: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219737C: ED0002F2  fmuls f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197380: C00B23CC  lfs f0, 0x23cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197384: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82197388: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219738C: C0EB2198  lfs f7, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82197390: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	pc = 0x82197394; continue 'dispatch;
            }
            0x82197394 => {
    //   block [0x82197394..0x82197470)
	// 82197394: 481CFE75  bl 0x82367208
	ctx.lr = 0x82197398;
	sub_82367208(ctx, base);
	// 82197398: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219739C: EDA002B2  fmuls f13, f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 821973A0: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821973A4: C07C0000  lfs f3, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 821973A8: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 821973AC: EC6301F2  fmuls f3, f3, f7
	ctx.f[3].f64 = (((ctx.f[3].f64 * ctx.f[7].f64) as f32) as f64);
	// 821973B0: D11E0004  stfs f8, 4(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821973B4: D07EFFFC  stfs f3, -4(r30)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 821973B8: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 821973BC: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 821973C0: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 821973C4: FC0D4B6E  fsel f0, f13, f13, f9
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 821973C8: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 821973CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821973D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821973D4: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 821973D8: D1BEFFF8  stfs f13, -8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 821973DC: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 821973E0: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821973E4: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 821973E8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821973EC: 409AFFA8  bne cr6, 0x82197394
	if !ctx.cr[6].eq {
	pc = 0x82197394; continue 'dispatch;
	}
	// 821973F0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821973F4: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821973F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821973FC: C1AB2244  lfs f13, 0x2244(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8772 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197404: ED05682A  fadds f8, f5, f13
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 82197408: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219740C: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82197410: EC0802F2  fmuls f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197414: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 82197418: 481CFD21  bl 0x82367138
	ctx.lr = 0x8219741C;
	sub_82367138(ctx, base);
	// 8219741C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82197420: D01F0028  stfs f0, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82197424: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197428: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 8219742C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82197430: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 82197434: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 82197438: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 8219743C: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 82197440: C00B212C  lfs f0, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197444: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197448: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219744C: C0EA449C  lfs f7, 0x449c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17564 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82197450: C16B44A4  lfs f11, 0x44a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17572 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197454: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197458: C10B23C8  lfs f8, 0x23c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219745C: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82197460: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82197464: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82197468: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219746C: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x82197470; continue 'dispatch;
            }
            0x82197470 => {
    //   block [0x82197470..0x821974E8)
	// 82197470: 481D0019  bl 0x82367488
	ctx.lr = 0x82197474;
	sub_82367488(ctx, base);
	// 82197474: EC0B02B2  fmuls f0, f11, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82197478: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219747C: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 82197480: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82197484: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82197488: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219748C: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 82197490: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82197494: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82197498: D0E50008  stfs f7, 8(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219749C: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 821974A0: FC00482E  fsel f0, f0, f0, f9
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 821974A4: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 821974A8: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 821974AC: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821974B0: 409AFFC0  bne cr6, 0x82197470
	if !ctx.cr[6].eq {
	pc = 0x82197470; continue 'dispatch;
	}
	// 821974B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974B8: D09F0068  stfs f4, 0x68(r31)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821974BC: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821974C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974C4: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821974C8: D01F006C  stfs f0, 0x6c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821974CC: C1AB23D4  lfs f13, 0x23d4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821974D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821974D4: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821974D8: C1AB23C4  lfs f13, 0x23c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9156 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821974DC: D1BF005C  stfs f13, 0x5c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 821974E0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821974E4: 4839DC24  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821974E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821974E8 size=516
    let mut pc: u32 = 0x821974E8;
    'dispatch: loop {
        match pc {
            0x821974E8 => {
    //   block [0x821974E8..0x8219754C)
	// 821974E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821974EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821974F0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821974F4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 821974F8: 4839EAE9  bl 0x82535fe0
	ctx.lr = 0x821974FC;
	sub_82535FB0(ctx, base);
	// 821974FC: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197500: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82197504: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197508: 395F0080  addi r10, r31, 0x80
	ctx.r[10].s64 = ctx.r[31].s64 + 128;
	// 8219750C: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82197510: 396301D0  addi r11, r3, 0x1d0
	ctx.r[11].s64 = ctx.r[3].s64 + 464;
	// 82197514: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 82197518: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219751C: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82197520: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 82197524: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82197528: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219752C: C01F0070  lfs f0, 0x70(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197530: D0030094  stfs f0, 0x94(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197534: C01F009C  lfs f0, 0x9c(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197538: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 8219753C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82197540: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197544: 409A0008  bne cr6, 0x8219754c
	if !ctx.cr[6].eq {
	pc = 0x8219754C; continue 'dispatch;
	}
	// 82197548: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219754C; continue 'dispatch;
            }
            0x8219754C => {
    //   block [0x8219754C..0x8219759C)
	// 8219754C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82197550: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82197554: 419A017C  beq cr6, 0x821976d0
	if ctx.cr[6].eq {
	pc = 0x821976D0; continue 'dispatch;
	}
	// 82197558: C01F0090  lfs f0, 0x90(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219755C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197560: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82197564: C3BF0094  lfs f29, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82197568: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219756C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197570: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82197574: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82197578: 41980064  blt cr6, 0x821975dc
	if ctx.cr[6].lt {
	pc = 0x821975DC; continue 'dispatch;
	}
	// 8219757C: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82197580: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197584: 4098003C  bge cr6, 0x821975c0
	if !ctx.cr[6].lt {
	pc = 0x821975C0; continue 'dispatch;
	}
	// 82197588: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219758C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82197590: 4098000C  bge cr6, 0x8219759c
	if !ctx.cr[6].lt {
	pc = 0x8219759C; continue 'dispatch;
	}
	// 82197594: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197598: 48000040  b 0x821975d8
	pc = 0x821975D8; continue 'dispatch;
            }
            0x8219759C => {
    //   block [0x8219759C..0x821975C0)
	// 8219759C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821975A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821975A4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821975A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821975AC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821975B0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821975B4: 41980024  blt cr6, 0x821975d8
	if ctx.cr[6].lt {
	pc = 0x821975D8; continue 'dispatch;
	}
	// 821975B8: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 821975BC: 4800001C  b 0x821975d8
	pc = 0x821975D8; continue 'dispatch;
            }
            0x821975C0 => {
    //   block [0x821975C0..0x821975D8)
	// 821975C0: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821975C4: 41980014  blt cr6, 0x821975d8
	if ctx.cr[6].lt {
	pc = 0x821975D8; continue 'dispatch;
	}
	// 821975C8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821975CC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821975D0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821975D4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821975D8; continue 'dispatch;
            }
            0x821975D8 => {
    //   block [0x821975D8..0x821975DC)
	// 821975D8: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x821975DC; continue 'dispatch;
            }
            0x821975DC => {
    //   block [0x821975DC..0x82197624)
	// 821975DC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821975E0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821975E4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821975E8: C3CB2490  lfs f30, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821975EC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821975F0: 4BF7A7E1  bl 0x82111dd0
	ctx.lr = 0x821975F4;
	sub_82111DD0(ctx, base);
	// 821975F4: FDA0EA10  fabs f13, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[29].u64 & !0x8000_0000_0000_0000u64;
	// 821975F8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821975FC: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82197600: 41980064  blt cr6, 0x82197664
	if ctx.cr[6].lt {
	pc = 0x82197664; continue 'dispatch;
	}
	// 82197604: EC1DE028  fsubs f0, f29, f28
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 82197608: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 8219760C: 4098003C  bge cr6, 0x82197648
	if !ctx.cr[6].lt {
	pc = 0x82197648; continue 'dispatch;
	}
	// 82197610: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197614: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82197618: 4098000C  bge cr6, 0x82197624
	if !ctx.cr[6].lt {
	pc = 0x82197624; continue 'dispatch;
	}
	// 8219761C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197620: 48000040  b 0x82197660
	pc = 0x82197660; continue 'dispatch;
            }
            0x82197624 => {
    //   block [0x82197624..0x82197648)
	// 82197624: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197628: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219762C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197630: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197634: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197638: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219763C: 41980024  blt cr6, 0x82197660
	if ctx.cr[6].lt {
	pc = 0x82197660; continue 'dispatch;
	}
	// 82197640: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82197644: 4800001C  b 0x82197660
	pc = 0x82197660; continue 'dispatch;
            }
            0x82197648 => {
    //   block [0x82197648..0x82197660)
	// 82197648: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219764C: 41980014  blt cr6, 0x82197660
	if ctx.cr[6].lt {
	pc = 0x82197660; continue 'dispatch;
	}
	// 82197650: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197654: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197658: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219765C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82197660; continue 'dispatch;
            }
            0x82197660 => {
    //   block [0x82197660..0x82197664)
	// 82197660: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x82197664; continue 'dispatch;
            }
            0x82197664 => {
    //   block [0x82197664..0x821976D0)
	// 82197664: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82197668: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219766C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82197670: 4BF7A761  bl 0x82111dd0
	ctx.lr = 0x82197674;
	sub_82111DD0(ctx, base);
	// 82197674: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197678: C1BF0058  lfs f13, 0x58(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219767C: C1810054  lfs f12, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197680: C1610058  lfs f11, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82197684: D3E1006C  stfs f31, 0x6c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82197688: C00B21B0  lfs f0, 0x21b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219768C: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 82197690: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82197694: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197698: FDA06850  fneg f13, f13
	ctx.f[13].u64 = ctx.f[13].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219769C: EDAD0332  fmuls f13, f13, f12
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[12].f64) as f32) as f64);
	// 821976A0: ED8B0332  fmuls f12, f11, f12
	ctx.f[12].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 821976A4: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976A8: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821976AC: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821976B0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976B4: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821976B8: EC0C0032  fmuls f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 821976BC: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821976C0: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821976C4: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821976C8: F95F0090  std r10, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 821976CC: F97F0098  std r11, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	pc = 0x821976D0; continue 'dispatch;
            }
            0x821976D0 => {
    //   block [0x821976D0..0x821976EC)
	// 821976D0: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821976D4: 3981FFF0  addi r12, r1, -0x10
	ctx.r[12].s64 = ctx.r[1].s64 + -16;
	// 821976D8: 4839E955  bl 0x8253602c
	ctx.lr = 0x821976DC;
	sub_82535FFC(ctx, base);
	// 821976DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821976E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821976E4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821976E8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821976F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821976F0 size=1580
    let mut pc: u32 = 0x821976F0;
    'dispatch: loop {
        match pc {
            0x821976F0 => {
    //   block [0x821976F0..0x821977AC)
	// 821976F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821976F4: 4839D9C5  bl 0x825350b8
	ctx.lr = 0x821976F8;
	sub_82535080(ctx, base);
	// 821976F8: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821976FC: 4839E8D5  bl 0x82535fd0
	ctx.lr = 0x82197700;
	sub_82535FB0(ctx, base);
	// 82197700: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197704: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82197708: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219770C: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82197710: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82197714: 409A05F8  bne cr6, 0x82197d0c
	if !ctx.cr[6].eq {
	pc = 0x82197D0C; continue 'dispatch;
	}
	// 82197718: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219771C: C3DF0094  lfs f30, 0x94(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82197720: D3DF00C4  stfs f30, 0xc4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82197724: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82197728: C2EB1FF8  lfs f23, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 8219772C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197730: FFA0B890  fmr f29, f23
	ctx.f[29].f64 = ctx.f[23].f64;
	// 82197734: FF80B890  fmr f28, f23
	ctx.f[28].f64 = ctx.f[23].f64;
	// 82197738: FF1EB800  fcmpu cr6, f30, f23
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[23].f64);
	// 8219773C: C36BBA38  lfs f27, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82197740: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197744: FFE0D890  fmr f31, f27
	ctx.f[31].f64 = ctx.f[27].f64;
	// 82197748: C34B2648  lfs f26, 0x2648(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9800 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219774C: 40990060  ble cr6, 0x821977ac
	if !ctx.cr[6].gt {
	pc = 0x821977AC; continue 'dispatch;
	}
	// 82197750: C01D0070  lfs f0, 0x70(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197754: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197758: EDBE0024  fdivs f13, f30, f0
	ctx.f[13].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 8219775C: C00B2604  lfs f0, 0x2604(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197760: EC2DD03A  fmadds f1, f13, f0, f26
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64);
	// 82197764: 4BF85D65  bl 0x8211d4c8
	ctx.lr = 0x82197768;
	sub_8211D4C8(ctx, base);
	// 82197768: EC1ED828  fsubs f0, f30, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[27].f64) as f32) as f64);
	// 8219776C: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197770: EF01D82A  fadds f24, f1, f27
	ctx.f[24].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 82197774: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82197778: 41990038  bgt cr6, 0x821977b0
	if ctx.cr[6].gt {
	pc = 0x821977B0; continue 'dispatch;
	}
	// 8219777C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82197780: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 82197784: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82197788: 409A0584  bne cr6, 0x82197d0c
	if !ctx.cr[6].eq {
	pc = 0x82197D0C; continue 'dispatch;
	}
	// 8219778C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 82197790: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 82197794: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 82197798: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219779C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 821977A0: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 821977A4: 4839E879  bl 0x8253601c
	ctx.lr = 0x821977A8;
	sub_82535FFC(ctx, base);
	// 821977A8: 4839D960  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            0x821977AC => {
    //   block [0x821977AC..0x821977B0)
	// 821977AC: FF00D890  fmr f24, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[27].f64;
	pc = 0x821977B0; continue 'dispatch;
            }
            0x821977B0 => {
    //   block [0x821977B0..0x821977C4)
	// 821977B0: C01D009C  lfs f0, 0x9c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821977B4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821977B8: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 821977BC: 409A0008  bne cr6, 0x821977c4
	if !ctx.cr[6].eq {
	pc = 0x821977C4; continue 'dispatch;
	}
	// 821977C0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x821977C4; continue 'dispatch;
            }
            0x821977C4 => {
    //   block [0x821977C4..0x8219784C)
	// 821977C4: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821977C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821977CC: 419A0080  beq cr6, 0x8219784c
	if ctx.cr[6].eq {
	pc = 0x8219784C; continue 'dispatch;
	}
	// 821977D0: 397D0080  addi r11, r29, 0x80
	ctx.r[11].s64 = ctx.r[29].s64 + 128;
	// 821977D4: 39200090  li r9, 0x90
	ctx.r[9].s64 = 144;
	// 821977D8: 395F01D0  addi r10, r31, 0x1d0
	ctx.r[10].s64 = ctx.r[31].s64 + 464;
	// 821977DC: 39010070  addi r8, r1, 0x70
	ctx.r[8].s64 = ctx.r[1].s64 + 112;
	pc = 0x8219784C; continue 'dispatch;
            }
            0x8219784C => {
    //   block [0x8219784C..0x82197D0C)
	// 8219784C: 3BDD0020  addi r30, r29, 0x20
	ctx.r[30].s64 = ctx.r[29].s64 + 32;
	// 82197850: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82197854: 4BFFE7FD  bl 0x82196050
	ctx.lr = 0x82197858;
	sub_82196050(ctx, base);
	// 82197858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219785C: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197860: C32B2490  lfs f25, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82197864: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82197868: 4BF85C61  bl 0x8211d4c8
	ctx.lr = 0x8219786C;
	sub_8211D4C8(ctx, base);
	// 8219786C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197870: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197874: 3BDD0030  addi r30, r29, 0x30
	ctx.r[30].s64 = ctx.r[29].s64 + 48;
	// 82197878: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219787C: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 82197880: C2CBBFFC  lfs f22, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 82197884: 387EFFD0  addi r3, r30, -0x30
	ctx.r[3].s64 = ctx.r[30].s64 + -48;
	// 82197888: 4BFFE7C9  bl 0x82196050
	ctx.lr = 0x8219788C;
	sub_82196050(ctx, base);
	// 8219788C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82197890: 4BFFE7C1  bl 0x82196050
	ctx.lr = 0x82197894;
	sub_82196050(ctx, base);
	// 82197894: C01EFFD0  lfs f0, -0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197898: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 8219789C: 4BF85C2D  bl 0x8211d4c8
	ctx.lr = 0x821978A0;
	sub_8211D4C8(ctx, base);
	// 821978A0: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821978A4: C1BEFFDC  lfs f13, -0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821978A8: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821978AC: EC2C0672  fmuls f1, f12, f25
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 821978B0: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821978B4: EFA0EFFA  fmadds f29, f0, f31, f29
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[29].f64) as f32) as f64);
	// 821978B8: 4BF85C11  bl 0x8211d4c8
	ctx.lr = 0x821978BC;
	sub_8211D4C8(ctx, base);
	// 821978BC: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821978C0: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821978C4: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821978C8: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821978CC: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821978D0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821978D4: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 821978D8: EF80E7FA  fmadds f28, f0, f31, f28
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64);
	// 821978DC: EFFF05B2  fmuls f31, f31, f22
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[22].f64) as f32) as f64);
	// 821978E0: 409AFFA4  bne cr6, 0x82197884
	if !ctx.cr[6].eq {
	pc = 0x82197884; continue 'dispatch;
	}
	// 821978E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821978E8: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 821978EC: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 821978F0: C00A219C  lfs f0, 0x219c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8604 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821978F4: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 821978F8: ED9D0032  fmuls f12, f29, f0
	ctx.f[12].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821978FC: EC1C0032  fmuls f0, f28, f0
	ctx.f[0].f64 = (((ctx.f[28].f64 * ctx.f[0].f64) as f32) as f64);
	// 82197900: 915F00C0  stw r10, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82197904: 40990044  ble cr6, 0x82197948
	if !ctx.cr[6].gt {
	pc = 0x82197948; continue 'dispatch;
	}
	// 82197908: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 8219790C: 4098003C  bge cr6, 0x82197948
	if !ctx.cr[6].lt {
	pc = 0x82197948; continue 'dispatch;
	}
	// 82197910: 481CF8F9  bl 0x82367208
	ctx.lr = 0x82197914;
	sub_82367208(ctx, base);
	// 82197914: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82197918: C17D005C  lfs f11, 0x5c(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219791C: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82197920: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82197924: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197928: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219792C: FD406818  frsp f10, f13
	ctx.f[10].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197930: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197934: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197938: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 8219793C: 4098000C  bge cr6, 0x82197948
	if !ctx.cr[6].lt {
	pc = 0x82197948; continue 'dispatch;
	}
	// 82197940: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	// 82197944: 48000008  b 0x8219794c
	pc = 0x8219794C; continue 'dispatch;
	// 82197948: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 8219794C: C1BD0050  lfs f13, 0x50(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197950: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82197954: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82197958: C1BD0054  lfs f13, 0x54(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219795C: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82197960: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82197964: C1BD0058  lfs f13, 0x58(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197968: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219796C: D3FF0188  stfs f31, 0x188(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82197970: FF1FB800  fcmpu cr6, f31, f23
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[23].f64);
	// 82197974: 40990068  ble cr6, 0x821979dc
	if !ctx.cr[6].gt {
	pc = 0x821979DC; continue 'dispatch;
	}
	// 82197978: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219797C: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197980: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82197984: 40980030  bge cr6, 0x821979b4
	if !ctx.cr[6].lt {
	pc = 0x821979B4; continue 'dispatch;
	}
	// 82197988: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219798C: C00B2144  lfs f0, 0x2144(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197990: EC1F0032  fmuls f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 82197994: EC20D67A  fmadds f1, f0, f25, f26
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[26].f64) as f32) as f64);
	// 82197998: 4BF85B31  bl 0x8211d4c8
	ctx.lr = 0x8219799C;
	sub_8211D4C8(ctx, base);
	// 8219799C: EC01D82A  fadds f0, f1, f27
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[27].f64) as f32) as f64;
	// 821979A0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 821979A4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 821979A8: EC180032  fmuls f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[0].f64) as f32) as f64);
	// 821979AC: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 821979B0: 48000030  b 0x821979e0
	pc = 0x821979E0; continue 'dispatch;
	// 821979B4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821979B8: EC3FD828  fsubs f1, f31, f27
	ctx.f[1].f64 = (((ctx.f[31].f64 - ctx.f[27].f64) as f32) as f64);
	// 821979BC: C84B2970  lfd f2, 0x2970(r11)
	ctx.f[2].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(10608 as u32) ) };
	// 821979C0: 4839BDB1  bl 0x82533770
	ctx.lr = 0x821979C4;
	sub_82533770(ctx, base);
	// 821979C4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 821979C8: EC00D82A  fadds f0, f0, f27
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[27].f64) as f32) as f64;
	// 821979CC: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 821979D0: EC180032  fmuls f0, f24, f0
	ctx.f[0].f64 = (((ctx.f[24].f64 * ctx.f[0].f64) as f32) as f64);
	// 821979D4: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 821979D8: 48000008  b 0x821979e0
	pc = 0x821979E0; continue 'dispatch;
	// 821979DC: D2FF0188  stfs f23, 0x188(r31)
	tmp.f32 = (ctx.f[23].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 821979E0: C01F0180  lfs f0, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821979E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821979E8: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 821979EC: C3FF0184  lfs f31, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821979F0: C3CB2048  lfs f30, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821979F4: FF0DB000  fcmpu cr6, f13, f22
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[22].f64);
	// 821979F8: 41980064  blt cr6, 0x82197a5c
	if ctx.cr[6].lt {
	pc = 0x82197A5C; continue 'dispatch;
	}
	// 821979FC: EC00F028  fsubs f0, f0, f30
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 82197A00: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82197A04: 4098003C  bge cr6, 0x82197a40
	if !ctx.cr[6].lt {
	pc = 0x82197A40; continue 'dispatch;
	}
	// 82197A08: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197A0C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197A10: 4098000C  bge cr6, 0x82197a1c
	if !ctx.cr[6].lt {
	pc = 0x82197A1C; continue 'dispatch;
	}
	// 82197A14: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197A18: 48000040  b 0x82197a58
	pc = 0x82197A58; continue 'dispatch;
	// 82197A1C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197A20: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197A24: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197A28: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197A2C: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197A30: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197A34: 41980024  blt cr6, 0x82197a58
	if ctx.cr[6].lt {
	pc = 0x82197A58; continue 'dispatch;
	}
	// 82197A38: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	// 82197A3C: 4800001C  b 0x82197a58
	pc = 0x82197A58; continue 'dispatch;
	// 82197A40: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197A44: 41980014  blt cr6, 0x82197a58
	if ctx.cr[6].lt {
	pc = 0x82197A58; continue 'dispatch;
	}
	// 82197A48: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197A4C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197A50: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197A54: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197A58: EC00B028  fsubs f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 82197A5C: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 82197A60: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82197A64: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 82197A68: 4BF7A369  bl 0x82111dd0
	ctx.lr = 0x82197A6C;
	sub_82111DD0(ctx, base);
	// 82197A6C: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82197A70: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82197A74: FF0DB000  fcmpu cr6, f13, f22
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[22].f64);
	// 82197A78: 41980064  blt cr6, 0x82197adc
	if ctx.cr[6].lt {
	pc = 0x82197ADC; continue 'dispatch;
	}
	// 82197A7C: EC1FF028  fsubs f0, f31, f30
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[30].f64) as f32) as f64);
	// 82197A80: FF00B800  fcmpu cr6, f0, f23
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[23].f64);
	// 82197A84: 4098003C  bge cr6, 0x82197ac0
	if !ctx.cr[6].lt {
	pc = 0x82197AC0; continue 'dispatch;
	}
	// 82197A88: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197A8C: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197A90: 4098000C  bge cr6, 0x82197a9c
	if !ctx.cr[6].lt {
	pc = 0x82197A9C; continue 'dispatch;
	}
	// 82197A94: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197A98: 48000040  b 0x82197ad8
	pc = 0x82197AD8; continue 'dispatch;
	// 82197A9C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197AA0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197AA4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197AA8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197AAC: EC1B0028  fsubs f0, f27, f0
	ctx.f[0].f64 = (((ctx.f[27].f64 - ctx.f[0].f64) as f32) as f64);
	// 82197AB0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197AB4: 41980024  blt cr6, 0x82197ad8
	if ctx.cr[6].lt {
	pc = 0x82197AD8; continue 'dispatch;
	}
	// 82197AB8: FC00B890  fmr f0, f23
	ctx.f[0].f64 = ctx.f[23].f64;
	// 82197ABC: 4800001C  b 0x82197ad8
	pc = 0x82197AD8; continue 'dispatch;
	// 82197AC0: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82197AC4: 41980014  blt cr6, 0x82197ad8
	if ctx.cr[6].lt {
	pc = 0x82197AD8; continue 'dispatch;
	}
	// 82197AC8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82197ACC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82197AD0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82197AD4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82197AD8: EC00B028  fsubs f0, f0, f22
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[22].f64) as f32) as f64);
	// 82197ADC: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82197AE0: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82197AE4: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82197AE8: 4BF7A2E9  bl 0x82111dd0
	ctx.lr = 0x82197AEC;
	sub_82111DD0(ctx, base);
	// 82197AEC: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197AF0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82197AF4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197AF8: C19F0188  lfs f12, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197AFC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82197B00: C0FF00B4  lfs f7, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 82197B04: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82197B08: C1210060  lfs f9, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82197B0C: C11F00B0  lfs f8, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82197B10: C1AB296C  lfs f13, 0x296c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10604 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197B14: 397D0090  addi r11, r29, 0x90
	ctx.r[11].s64 = ctx.r[29].s64 + 144;
	// 82197B18: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B1C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197B20: C0DF00B8  lfs f6, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82197B24: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82197B28: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82197B2C: ED600372  fmuls f11, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B30: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197B34: ED400372  fmuls f10, f0, f13
	ctx.f[10].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B38: C00A295C  lfs f0, 0x295c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197B3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82197B40: ED290332  fmuls f9, f9, f12
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[12].f64) as f32) as f64);
	// 82197B44: C1AA2960  lfs f13, 0x2960(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10592 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197B48: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 82197B4C: ECE70372  fmuls f7, f7, f13
	ctx.f[7].f64 = (((ctx.f[7].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B50: ED080372  fmuls f8, f8, f13
	ctx.f[8].f64 = (((ctx.f[8].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B54: ED6B0332  fmuls f11, f11, f12
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[12].f64) as f32) as f64);
	// 82197B58: ECC60372  fmuls f6, f6, f13
	ctx.f[6].f64 = (((ctx.f[6].f64 * ctx.f[13].f64) as f32) as f64);
	// 82197B5C: ED8A0332  fmuls f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 * ctx.f[12].f64) as f32) as f64);
	// 82197B60: C15F00BC  lfs f10, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82197B64: EDAA037A  fmadds f13, f10, f13, f0
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64);
	// 82197B68: D1BF00BC  stfs f13, 0xbc(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82197B6C: EDA9383A  fmadds f13, f9, f0, f7
	ctx.f[13].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[7].f64) as f32) as f64);
	// 82197B70: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82197B74: EDAB403A  fmadds f13, f11, f0, f8
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 82197B78: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82197B7C: EC0C303A  fmadds f0, f12, f0, f6
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[6].f64) as f32) as f64);
	// 82197B80: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
            }
            0x82197D0C => {
    //   block [0x82197D0C..0x82197D1C)
	// 82197D0C: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 82197D10: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82197D14: 4839E309  bl 0x8253601c
	ctx.lr = 0x82197D18;
	sub_82535FFC(ctx, base);
	// 82197D18: 4839D3F0  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197D20(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82197D20 size=536
    let mut pc: u32 = 0x82197D20;
    'dispatch: loop {
        match pc {
            0x82197D20 => {
    //   block [0x82197D20..0x82197F38)
	// 82197D20: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197D24: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82197D28: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82197D2C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82197D30: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 82197D34: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197D38: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82197F38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82197F38 size=224
    let mut pc: u32 = 0x82197F38;
    'dispatch: loop {
        match pc {
            0x82197F38 => {
    //   block [0x82197F38..0x82197F90)
	// 82197F38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82197F3C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82197F40: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82197F44: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82197F48: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82197F4C: 4839E09D  bl 0x82535fe8
	ctx.lr = 0x82197F50;
	sub_82535FB0(ctx, base);
	// 82197F50: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82197F54: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197F58: D0A100D4  stfs f5, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 82197F5C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82197F60: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82197F64: FFC03090  fmr f30, f6
	ctx.f[30].f64 = ctx.f[6].f64;
	// 82197F68: C80B2008  lfd f0, 0x2008(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 82197F6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197F70: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82197F74: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82197F78: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82197F7C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82197F80: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197F84: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82197F88: 40990008  ble cr6, 0x82197f90
	if !ctx.cr[6].gt {
	pc = 0x82197F90; continue 'dispatch;
	}
	// 82197F8C: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	pc = 0x82197F90; continue 'dispatch;
            }
            0x82197F90 => {
    //   block [0x82197F90..0x82197FA0)
	// 82197F90: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82197F94: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82197F98: 40990008  ble cr6, 0x82197fa0
	if !ctx.cr[6].gt {
	pc = 0x82197FA0; continue 'dispatch;
	}
	// 82197F9C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	pc = 0x82197FA0; continue 'dispatch;
            }
            0x82197FA0 => {
    //   block [0x82197FA0..0x82198018)
	// 82197FA0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82197FA4: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82197FA8: 4BFFF259  bl 0x82197200
	ctx.lr = 0x82197FAC;
	sub_82197200(ctx, base);
	// 82197FAC: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82197FB0: 39400056  li r10, 0x56
	ctx.r[10].s64 = 86;
	// 82197FB4: D39F0070  stfs f28, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82197FB8: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82197FBC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197FC0: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 82197FC4: C1AB25BC  lfs f13, 0x25bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9660 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197FC8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 82197FCC: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82197FD0: C18BD4D0  lfs f12, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82197FD4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82197FD8: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82197FDC: C1AB209C  lfs f13, 0x209c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8348 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82197FE0: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82197FE4: D3BF0090  stfs f29, 0x90(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 82197FE8: D3DF0094  stfs f30, 0x94(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 82197FEC: D3FF0098  stfs f31, 0x98(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 82197FF0: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 82197FF4: 995E004F  stb r10, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[10].u8 ) };
	// 82197FF8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82197FFC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82198000: 4839E035  bl 0x82536034
	ctx.lr = 0x82198004;
	sub_82535FFC(ctx, base);
	// 82198004: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82198008: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219800C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82198010: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82198014: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198018(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198018 size=224
    let mut pc: u32 = 0x82198018;
    'dispatch: loop {
        match pc {
            0x82198018 => {
    //   block [0x82198018..0x82198070)
	// 82198018: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219801C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82198020: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82198024: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82198028: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219802C: 4839DFBD  bl 0x82535fe8
	ctx.lr = 0x82198030;
	sub_82535FB0(ctx, base);
	// 82198030: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198034: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198038: D0A100D4  stfs f5, 0xd4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8219803C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82198040: FF802090  fmr f28, f4
	ctx.f[28].f64 = ctx.f[4].f64;
	// 82198044: FFC03090  fmr f30, f6
	ctx.f[30].f64 = ctx.f[6].f64;
	// 82198048: C80B2008  lfd f0, 0x2008(r11)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8200 as u32) ) };
	// 8219804C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198050: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198054: C3EB1FF8  lfs f31, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82198058: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219805C: FFA0F890  fmr f29, f31
	ctx.f[29].f64 = ctx.f[31].f64;
	// 82198060: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198064: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198068: 40990008  ble cr6, 0x82198070
	if !ctx.cr[6].gt {
	pc = 0x82198070; continue 'dispatch;
	}
	// 8219806C: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	pc = 0x82198070; continue 'dispatch;
            }
            0x82198070 => {
    //   block [0x82198070..0x82198080)
	// 82198070: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82198074: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198078: 40990008  ble cr6, 0x82198080
	if !ctx.cr[6].gt {
	pc = 0x82198080; continue 'dispatch;
	}
	// 8219807C: FFC01890  fmr f30, f3
	ctx.f[30].f64 = ctx.f[3].f64;
	pc = 0x82198080; continue 'dispatch;
            }
            0x82198080 => {
    //   block [0x82198080..0x821980F8)
	// 82198080: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82198084: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82198088: 4BFFF179  bl 0x82197200
	ctx.lr = 0x8219808C;
	sub_82197200(ctx, base);
	// 8219808C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 82198090: 39400048  li r10, 0x48
	ctx.r[10].s64 = 72;
	// 82198094: D39F0070  stfs f28, 0x70(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82198098: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219809C: 3D60820B  lis r11, -0x7df5
	ctx.r[11].s64 = -2113208320;
	// 821980A0: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 821980A4: C1AB9F78  lfs f13, -0x6088(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24712 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821980A8: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821980AC: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821980B0: C18BD560  lfs f12, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821980B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821980B8: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 821980BC: C1ABD218  lfs f13, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821980C0: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 821980C4: D3BF0090  stfs f29, 0x90(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821980C8: D3DF0094  stfs f30, 0x94(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821980CC: D3FF0098  stfs f31, 0x98(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821980D0: D01F009C  stfs f0, 0x9c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 821980D4: 995E004F  stb r10, 0x4f(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(79 as u32), ctx.r[10].u8 ) };
	// 821980D8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821980DC: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821980E0: 4839DF55  bl 0x82536034
	ctx.lr = 0x821980E4;
	sub_82535FFC(ctx, base);
	// 821980E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821980E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821980EC: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821980F0: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821980F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821980F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821980F8 size=636
    let mut pc: u32 = 0x821980F8;
    'dispatch: loop {
        match pc {
            0x821980F8 => {
    //   block [0x821980F8..0x82198134)
	// 821980F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821980FC: 4839CFBD  bl 0x825350b8
	ctx.lr = 0x82198100;
	sub_82535080(ctx, base);
	// 82198100: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198104: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82198108: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219810C: 3BE300D0  addi r31, r3, 0xd0
	ctx.r[31].s64 = ctx.r[3].s64 + 208;
	// 82198110: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 82198114: C1AABA38  lfs f13, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198118: C18BD564  lfs f12, -0x2a9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10908 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219811C: 409A0018  bne cr6, 0x82198134
	if !ctx.cr[6].eq {
	pc = 0x82198134; continue 'dispatch;
	}
	// 82198120: D19F0060  stfs f12, 0x60(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 82198124: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 82198128: D19F0068  stfs f12, 0x68(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219812C: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82198130: 48000018  b 0x82198148
	pc = 0x82198148; continue 'dispatch;
            }
            0x82198134 => {
    //   block [0x82198134..0x82198148)
	// 82198134: E9470000  ld r10, 0(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 82198138: 397F0060  addi r11, r31, 0x60
	ctx.r[11].s64 = ctx.r[31].s64 + 96;
	// 8219813C: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 82198140: E9470008  ld r10, 8(r7)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 82198144: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	pc = 0x82198148; continue 'dispatch;
            }
            0x82198148 => {
    //   block [0x82198148..0x82198198)
	// 82198148: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219814C: D1BF006C  stfs f13, 0x6c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 82198150: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198158: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 8219815C: C0CB2280  lfs f6, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 82198160: 40990038  ble cr6, 0x82198198
	if !ctx.cr[6].gt {
	pc = 0x82198198; continue 'dispatch;
	}
	// 82198164: 481CEFD5  bl 0x82367138
	ctx.lr = 0x82198168;
	sub_82367138(ctx, base);
	// 82198168: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219816C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82198170: C9610050  lfd f11, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82198174: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 82198178: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219817C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 82198180: ED4B01B2  fmuls f10, f11, f6
	ctx.f[10].f64 = (((ctx.f[11].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198184: C16BD560  lfs f11, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198188: ED6A02F2  fmuls f11, f10, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219818C: FD605850  fneg f11, f11
	ctx.f[11].u64 = ctx.f[11].u64 ^ 0x8000_0000_0000_0000u64;
	// 82198190: D17F0050  stfs f11, 0x50(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82198194: 48000008  b 0x8219819c
	pc = 0x8219819C; continue 'dispatch;
            }
            0x82198198 => {
    //   block [0x82198198..0x8219819C)
	// 82198198: D05F0050  stfs f2, 0x50(r31)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	pc = 0x8219819C; continue 'dispatch;
            }
            0x8219819C => {
    //   block [0x8219819C..0x821981C8)
	// 8219819C: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 821981A0: 40990028  ble cr6, 0x821981c8
	if !ctx.cr[6].gt {
	pc = 0x821981C8; continue 'dispatch;
	}
	// 821981A4: 481CEF95  bl 0x82367138
	ctx.lr = 0x821981A8;
	sub_82367138(ctx, base);
	// 821981A8: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821981AC: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821981B0: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821981B4: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821981B8: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821981BC: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 821981C0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821981C4: 48000008  b 0x821981cc
	pc = 0x821981CC; continue 'dispatch;
            }
            0x821981C8 => {
    //   block [0x821981C8..0x821981CC)
	// 821981C8: D07F0054  stfs f3, 0x54(r31)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	pc = 0x821981CC; continue 'dispatch;
            }
            0x821981CC => {
    //   block [0x821981CC..0x82198240)
	// 821981CC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821981D0: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 821981D4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 821981D8: D1810054  stfs f12, 0x54(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 821981DC: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821981E0: D03F0058  stfs f1, 0x58(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 821981E4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821981E8: 3B810050  addi r28, r1, 0x50
	ctx.r[28].s64 = ctx.r[1].s64 + 80;
	// 821981EC: C00BCFEC  lfs f0, -0x3014(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-12308 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821981F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821981F4: ECA10032  fmuls f5, f1, f0
	ctx.f[5].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821981F8: C9882000  lfd f12, 0x2000(r8)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8192 as u32) ) };
	// 821981FC: C9292008  lfd f9, 0x2008(r9)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8200 as u32) ) };
	// 82198200: 3BDF0008  addi r30, r31, 8
	ctx.r[30].s64 = ctx.r[31].s64 + 8;
	// 82198204: C14A23D0  lfs f10, 0x23d0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9168 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198208: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	// 8219820C: C00BD6C8  lfs f0, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198210: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82198214: C1ABD5B0  lfs f13, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198218: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219821C: EC01683A  fmadds f0, f1, f0, f13
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 82198220: C16B20B0  lfs f11, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198224: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198228: ED0002F2  fmuls f8, f0, f11
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219822C: C00B23CC  lfs f0, 0x23cc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198230: EC05002A  fadds f0, f5, f0
	ctx.f[0].f64 = ((ctx.f[5].f64 + ctx.f[0].f64) as f32) as f64;
	// 82198234: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198238: C0EB2198  lfs f7, 0x2198(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8600 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219823C: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	pc = 0x82198240; continue 'dispatch;
            }
            0x82198240 => {
    //   block [0x82198240..0x8219831C)
	// 82198240: 481CEFC9  bl 0x82367208
	ctx.lr = 0x82198244;
	sub_82367208(ctx, base);
	// 82198244: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82198248: EDA002B2  fmuls f13, f0, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[10].f64) as f32) as f64);
	// 8219824C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82198250: C09C0000  lfs f4, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 82198254: 3BBDFFFF  addi r29, r29, -1
	ctx.r[29].s64 = ctx.r[29].s64 + -1;
	// 82198258: EC8401F2  fmuls f4, f4, f7
	ctx.f[4].f64 = (((ctx.f[4].f64 * ctx.f[7].f64) as f32) as f64);
	// 8219825C: D11E0004  stfs f8, 4(r30)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82198260: D09EFFFC  stfs f4, -4(r30)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82198264: 3B9C0004  addi r28, r28, 4
	ctx.r[28].s64 = ctx.r[28].s64 + 4;
	// 82198268: F9610058  std r11, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u64 ) };
	// 8219826C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 82198270: FC0D4B6E  fsel f0, f13, f13, f9
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[13].f64 } else { ctx.f[9].f64 };
	// 82198274: C9A10058  lfd f13, 0x58(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 82198278: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219827C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198280: EDAD01B2  fmuls f13, f13, f6
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198284: D1BEFFF8  stfs f13, -8(r30)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 82198288: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 8219828C: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 82198290: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82198294: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82198298: 409AFFA8  bne cr6, 0x82198240
	if !ctx.cr[6].eq {
	pc = 0x82198240; continue 'dispatch;
	}
	// 8219829C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 821982A0: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821982A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982A8: C1AB2244  lfs f13, 0x2244(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8772 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821982AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982B0: ED05682A  fadds f8, f5, f13
	ctx.f[8].f64 = ((ctx.f[5].f64 + ctx.f[13].f64) as f32) as f64;
	// 821982B4: C1AB2068  lfs f13, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821982B8: EDA1683A  fmadds f13, f1, f0, f13
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821982BC: EC0802F2  fmuls f0, f8, f11
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[11].f64) as f32) as f64);
	// 821982C0: EDAD02F2  fmuls f13, f13, f11
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[11].f64) as f32) as f64);
	// 821982C4: 481CEE75  bl 0x82367138
	ctx.lr = 0x821982C8;
	sub_82367138(ctx, base);
	// 821982C8: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821982CC: D01F0028  stfs f0, 0x28(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 821982D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821982D4: D1BF002C  stfs f13, 0x2c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 821982D8: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 821982DC: 38BF0034  addi r5, r31, 0x34
	ctx.r[5].s64 = ctx.r[31].s64 + 52;
	// 821982E0: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821982E4: F9410058  std r10, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[10].u64 ) };
	// 821982E8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821982EC: C00B212C  lfs f0, 0x212c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8492 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821982F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821982F4: D01F0024  stfs f0, 0x24(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 821982F8: C0EA449C  lfs f7, 0x449c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17564 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 821982FC: C16B44A4  lfs f11, 0x44a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(17572 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198300: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198304: C10B23C8  lfs f8, 0x23c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9160 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 82198308: C8010058  lfd f0, 0x58(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219830C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82198310: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82198314: EC0001B2  fmuls f0, f0, f6
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 82198318: D01F0020  stfs f0, 0x20(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(32 as u32), tmp.u32 ) };
	pc = 0x8219831C; continue 'dispatch;
            }
            0x8219831C => {
    //   block [0x8219831C..0x82198374)
	// 8219831C: 481CF16D  bl 0x82367488
	ctx.lr = 0x82198320;
	sub_82367488(ctx, base);
	// 82198320: EC0B02B2  fmuls f0, f11, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198324: C1A30000  lfs f13, 0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198328: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 8219832C: EDAD0232  fmuls f13, f13, f8
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[8].f64) as f32) as f64);
	// 82198330: D1A50000  stfs f13, 0(r5)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82198334: D1650004  stfs f11, 4(r5)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82198338: 38630004  addi r3, r3, 4
	ctx.r[3].s64 = ctx.r[3].s64 + 4;
	// 8219833C: D025FFFC  stfs f1, -4(r5)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 82198340: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 82198344: D0E50008  stfs f7, 8(r5)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82198348: 38A50010  addi r5, r5, 0x10
	ctx.r[5].s64 = ctx.r[5].s64 + 16;
	// 8219834C: FC00482E  fsel f0, f0, f0, f9
	ctx.f[0].f64 = if ctx.f[0].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[9].f64 };
	// 82198350: FDA06028  fsub f13, f0, f12
	ctx.f[13].f64 = ctx.f[0].f64 - ctx.f[12].f64;
	// 82198354: FC0D032E  fsel f0, f13, f12, f0
	ctx.f[0].f64 = if ctx.f[13].f64 >= 0.0 { ctx.f[12].f64 } else { ctx.f[0].f64 };
	// 82198358: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219835C: 409AFFC0  bne cr6, 0x8219831c
	if !ctx.cr[6].eq {
	pc = 0x8219831C; continue 'dispatch;
	}
	// 82198360: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198364: C00B23C4  lfs f0, 0x23c4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198368: D01F005C  stfs f0, 0x5c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8219836C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 82198370: 4839CD98  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198378 size=1124
    let mut pc: u32 = 0x82198378;
    'dispatch: loop {
        match pc {
            0x82198378 => {
    //   block [0x82198378..0x82198408)
	// 82198378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219837C: 4839CD41  bl 0x825350bc
	ctx.lr = 0x82198380;
	sub_82535080(ctx, base);
	// 82198380: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 82198384: 4839DC5D  bl 0x82535fe0
	ctx.lr = 0x82198388;
	sub_82535FB0(ctx, base);
	// 82198388: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219838C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82198390: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 82198394: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 82198398: 614A85E0  ori r10, r10, 0x85e0
	ctx.r[10].u64 = ctx.r[10].u64 | 34272;
	// 8219839C: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 821983A0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821983A4: 612985DC  ori r9, r9, 0x85dc
	ctx.r[9].u64 = ctx.r[9].u64 | 34268;
	// 821983A8: 3BDF00D0  addi r30, r31, 0xd0
	ctx.r[30].s64 = ctx.r[31].s64 + 208;
	// 821983AC: 7C0B542E  lfsx f0, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983B0: 395F0230  addi r10, r31, 0x230
	ctx.r[10].s64 = ctx.r[31].s64 + 560;
	// 821983B4: D01F018C  stfs f0, 0x18c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 821983B8: 7C0B4C2E  lfsx f0, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983BC: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	// 821983C0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821983C4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821983C8: C3EABA38  lfs f31, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821983CC: 395E0060  addi r10, r30, 0x60
	ctx.r[10].s64 = ctx.r[30].s64 + 96;
	// 821983D0: D3FE006C  stfs f31, 0x6c(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 821983D4: E92A0000  ld r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821983D8: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 821983DC: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 821983E0: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821983E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821983E8: C01E0080  lfs f0, 0x80(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983EC: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821983F0: C01E007C  lfs f0, 0x7c(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821983F4: C36B1FF8  lfs f27, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 821983F8: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821983FC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82198400: 409A0008  bne cr6, 0x82198408
	if !ctx.cr[6].eq {
	pc = 0x82198408; continue 'dispatch;
	}
	// 82198404: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x82198408; continue 'dispatch;
            }
            0x82198408 => {
    //   block [0x82198408..0x8219845C)
	// 82198408: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219840C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198410: 419A03BC  beq cr6, 0x821987cc
	if ctx.cr[6].eq {
	pc = 0x821987CC; continue 'dispatch;
	}
	// 82198414: C01E0070  lfs f0, 0x70(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219841C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198420: C3BE0074  lfs f29, 0x74(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(116 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82198424: 3BBE0070  addi r29, r30, 0x70
	ctx.r[29].s64 = ctx.r[30].s64 + 112;
	// 82198428: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219842C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198430: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82198434: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 82198438: 41980064  blt cr6, 0x8219849c
	if ctx.cr[6].lt {
	pc = 0x8219849C; continue 'dispatch;
	}
	// 8219843C: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82198440: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82198444: 4098003C  bge cr6, 0x82198480
	if !ctx.cr[6].lt {
	pc = 0x82198480; continue 'dispatch;
	}
	// 82198448: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219844C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198450: 4098000C  bge cr6, 0x8219845c
	if !ctx.cr[6].lt {
	pc = 0x8219845C; continue 'dispatch;
	}
	// 82198454: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198458: 48000040  b 0x82198498
	pc = 0x82198498; continue 'dispatch;
            }
            0x8219845C => {
    //   block [0x8219845C..0x82198480)
	// 8219845C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198460: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198464: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198468: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219846C: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198470: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198474: 41980024  blt cr6, 0x82198498
	if ctx.cr[6].lt {
	pc = 0x82198498; continue 'dispatch;
	}
	// 82198478: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 8219847C: 4800001C  b 0x82198498
	pc = 0x82198498; continue 'dispatch;
            }
            0x82198480 => {
    //   block [0x82198480..0x82198498)
	// 82198480: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82198484: 41980014  blt cr6, 0x82198498
	if ctx.cr[6].lt {
	pc = 0x82198498; continue 'dispatch;
	}
	// 82198488: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 8219848C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198490: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198494: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82198498; continue 'dispatch;
            }
            0x82198498 => {
    //   block [0x82198498..0x8219849C)
	// 82198498: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x8219849C; continue 'dispatch;
            }
            0x8219849C => {
    //   block [0x8219849C..0x821984E4)
	// 8219849C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821984A0: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821984A4: 3861005C  addi r3, r1, 0x5c
	ctx.r[3].s64 = ctx.r[1].s64 + 92;
	// 821984A8: C3CB2490  lfs f30, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821984AC: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 821984B0: 4BF79921  bl 0x82111dd0
	ctx.lr = 0x821984B4;
	sub_82111DD0(ctx, base);
	// 821984B4: FDA0EA10  fabs f13, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[29].u64 & !0x8000_0000_0000_0000u64;
	// 821984B8: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 821984BC: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 821984C0: 41980064  blt cr6, 0x82198524
	if ctx.cr[6].lt {
	pc = 0x82198524; continue 'dispatch;
	}
	// 821984C4: EC1DE028  fsubs f0, f29, f28
	ctx.f[0].f64 = (((ctx.f[29].f64 - ctx.f[28].f64) as f32) as f64);
	// 821984C8: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821984CC: 4098003C  bge cr6, 0x82198508
	if !ctx.cr[6].lt {
	pc = 0x82198508; continue 'dispatch;
	}
	// 821984D0: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821984D4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821984D8: 4098000C  bge cr6, 0x821984e4
	if !ctx.cr[6].lt {
	pc = 0x821984E4; continue 'dispatch;
	}
	// 821984DC: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821984E0: 48000040  b 0x82198520
	pc = 0x82198520; continue 'dispatch;
            }
            0x821984E4 => {
    //   block [0x821984E4..0x82198508)
	// 821984E4: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821984E8: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821984EC: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821984F0: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821984F4: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821984F8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821984FC: 41980024  blt cr6, 0x82198520
	if ctx.cr[6].lt {
	pc = 0x82198520; continue 'dispatch;
	}
	// 82198500: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82198504: 4800001C  b 0x82198520
	pc = 0x82198520; continue 'dispatch;
            }
            0x82198508 => {
    //   block [0x82198508..0x82198520)
	// 82198508: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219850C: 41980014  blt cr6, 0x82198520
	if ctx.cr[6].lt {
	pc = 0x82198520; continue 'dispatch;
	}
	// 82198510: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198514: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198518: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219851C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82198520; continue 'dispatch;
            }
            0x82198520 => {
    //   block [0x82198520..0x82198524)
	// 82198520: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x82198524; continue 'dispatch;
            }
            0x82198524 => {
    //   block [0x82198524..0x821987CC)
	// 82198524: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 82198528: EC2007B2  fmuls f1, f0, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219852C: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82198530: 4BF798A1  bl 0x82111dd0
	ctx.lr = 0x82198534;
	sub_82111DD0(ctx, base);
	// 82198534: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 82198538: C1BF018C  lfs f13, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219853C: 1001038C  vspltisw v0, 1
	for i in 0..4 {
		ctx.v[0].u32[i] = 1;
	}
	// 82198540: C15E0058  lfs f10, 0x58(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(88 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198544: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82198548: C00BD478  lfs f0, -0x2b88(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219854C: 39610080  addi r11, r1, 0x80
	ctx.r[11].s64 = ctx.r[1].s64 + 128;
	// 82198550: ED6D0032  fmuls f11, f13, f0
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198554: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198558: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 8219855C: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198560: 11A1034A  vcfsx v13, v0, 1
	ctx.fpscr.enable_flush_mode_unconditional();
	let scale = f32::from_bits(((127u32 - (1 as u32)) << 23));
	for i in 0..4 {
		ctx.v[13].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82198564: 1180034A  vcfsx v12, v0, 0
	let scale = f32::from_bits(((127u32 - (0 as u32)) << 23));
	for i in 0..4 {
		ctx.v[12].f32[i] = (ctx.v[0].s32[i] as f32) * scale;
	}
	// 82198568: ED800372  fmuls f12, f0, f13
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219856C: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198570: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82198574: EC0B02B2  fmuls f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198578: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 8219857C: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198580: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82198584: C181005C  lfs f12, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82198588: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219858C: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 82198590: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198594: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 82198598: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219859C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 821985A0: F95D0000  std r10, 0(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821985A4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821985A8: F97D0008  std r11, 8(r29)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	pc = 0x821987CC; continue 'dispatch;
            }
            0x821987CC => {
    //   block [0x821987CC..0x821987DC)
	// 821987CC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821987D0: 3981FFE0  addi r12, r1, -0x20
	ctx.r[12].s64 = ctx.r[1].s64 + -32;
	// 821987D4: 4839D859  bl 0x8253602c
	ctx.lr = 0x821987D8;
	sub_82535FFC(ctx, base);
	// 821987D8: 4839C934  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821987E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821987E0 size=1404
    let mut pc: u32 = 0x821987E0;
    'dispatch: loop {
        match pc {
            0x821987E0 => {
    //   block [0x821987E0..0x82198904)
	// 821987E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821987E4: 4839C8C1  bl 0x825350a4
	ctx.lr = 0x821987E8;
	sub_82535080(ctx, base);
	// 821987E8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821987EC: 4839D7C5  bl 0x82535fb0
	ctx.lr = 0x821987F0;
	sub_82535FB0(ctx, base);
	// 821987F0: 9421FEB0  stwu r1, -0x150(r1)
	ea = ctx.r[1].u32.wrapping_add(-336 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821987F4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821987F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821987FC: 896BBFF0  lbz r11, -0x4010(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(-16400 as u32) ) } as u64;
	// 82198800: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198804: 409A0548  bne cr6, 0x82198d4c
	if !ctx.cr[6].eq {
	pc = 0x82198D4C; continue 'dispatch;
	}
	// 82198808: 3CA0820D  lis r5, -0x7df3
	ctx.r[5].s64 = -2113077248;
	// 8219880C: 3C80820D  lis r4, -0x7df3
	ctx.r[4].s64 = -2113077248;
	// 82198810: 3F00820A  lis r24, -0x7df6
	ctx.r[24].s64 = -2113273856;
	// 82198814: 3F20820D  lis r25, -0x7df3
	ctx.r[25].s64 = -2113077248;
	// 82198818: 3F40820D  lis r26, -0x7df3
	ctx.r[26].s64 = -2113077248;
	// 8219881C: 3F608288  lis r27, -0x7d78
	ctx.r[27].s64 = -2105016320;
	// 82198820: C0052280  lfs f0, 0x2280(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198824: 3F80820D  lis r28, -0x7df3
	ctx.r[28].s64 = -2113077248;
	// 82198828: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219882C: 3FC0820D  lis r30, -0x7df3
	ctx.r[30].s64 = -2113077248;
	// 82198830: C0042068  lfs f0, 0x2068(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198834: 3C60820D  lis r3, -0x7df3
	ctx.r[3].s64 = -2113077248;
	// 82198838: C358BA38  lfs f26, -0x45c8(r24)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[24].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219883C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 82198840: C2FA295C  lfs f23, 0x295c(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(10588 as u32) ) };
	ctx.f[23].f64 = (tmp.f32 as f64);
	// 82198844: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 82198848: C29BD4DC  lfs f20, -0x2b24(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[20].f64 = (tmp.f32 as f64);
	// 8219884C: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 82198850: C23C2048  lfs f17, 0x2048(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8264 as u32) ) };
	ctx.f[17].f64 = (tmp.f32 as f64);
	// 82198854: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82198858: C1DE2958  lfs f14, 0x2958(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(10584 as u32) ) };
	ctx.f[14].f64 = (tmp.f32 as f64);
	// 8219885C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82198860: C1E32144  lfs f15, 0x2144(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8516 as u32) ) };
	ctx.f[15].f64 = (tmp.f32 as f64);
	// 82198864: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82198868: C206219C  lfs f16, 0x219c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8604 as u32) ) };
	ctx.f[16].f64 = (tmp.f32 as f64);
	// 8219886C: C2A7BFFC  lfs f21, -0x4004(r7)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[21].f64 = (tmp.f32 as f64);
	// 82198870: 3BBF00D0  addi r29, r31, 0xd0
	ctx.r[29].s64 = ctx.r[31].s64 + 208;
	// 82198874: C3282490  lfs f25, 0x2490(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(9360 as u32) ) };
	ctx.f[25].f64 = (tmp.f32 as f64);
	// 82198878: 3AE00070  li r23, 0x70
	ctx.r[23].s64 = 112;
	// 8219887C: C2692648  lfs f19, 0x2648(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(9800 as u32) ) };
	ctx.f[19].f64 = (tmp.f32 as f64);
	// 82198880: C24A2604  lfs f18, 0x2604(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9732 as u32) ) };
	ctx.f[18].f64 = (tmp.f32 as f64);
	// 82198884: C3AB1FF8  lfs f29, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 82198888: C2D92960  lfs f22, 0x2960(r25)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(10592 as u32) ) };
	ctx.f[22].f64 = (tmp.f32 as f64);
	// 8219888C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 82198890: C3DF0094  lfs f30, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82198894: FF80E890  fmr f28, f29
	ctx.f[28].f64 = ctx.f[29].f64;
	// 82198898: D3DF00C4  stfs f30, 0xc4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219889C: FF60E890  fmr f27, f29
	ctx.f[27].f64 = ctx.f[29].f64;
	// 821988A0: FFE0D090  fmr f31, f26
	ctx.f[31].f64 = ctx.f[26].f64;
	// 821988A4: FF1EE800  fcmpu cr6, f30, f29
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[29].f64);
	// 821988A8: 4099005C  ble cr6, 0x82198904
	if !ctx.cr[6].gt {
	pc = 0x82198904; continue 'dispatch;
	}
	// 821988AC: C01D0080  lfs f0, 0x80(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821988B0: EC1E0024  fdivs f0, f30, f0
	ctx.f[0].f64 = ((ctx.f[30].f64 / ctx.f[0].f64) as f32) as f64;
	// 821988B4: EC209CBA  fmadds f1, f0, f18, f19
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[18].f64 + ctx.f[19].f64) as f32) as f64);
	// 821988B8: 4BF84C11  bl 0x8211d4c8
	ctx.lr = 0x821988BC;
	sub_8211D4C8(ctx, base);
	// 821988BC: C01F0190  lfs f0, 0x190(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821988C0: EF01D02A  fadds f24, f1, f26
	ctx.f[24].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 821988C4: EC1E0028  fsubs f0, f30, f0
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[0].f64) as f32) as f64);
	// 821988C8: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821988CC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 821988D0: 41990038  bgt cr6, 0x82198908
	if ctx.cr[6].gt {
	pc = 0x82198908; continue 'dispatch;
	}
	// 821988D4: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821988D8: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821988DC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821988E0: 409A046C  bne cr6, 0x82198d4c
	if !ctx.cr[6].eq {
	pc = 0x82198D4C; continue 'dispatch;
	}
	// 821988E4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821988E8: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821988EC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821988F0: 997F0025  stb r11, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[11].u8 ) };
	// 821988F4: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 821988F8: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 821988FC: 4839D701  bl 0x82535ffc
	ctx.lr = 0x82198900;
	sub_82535FFC(ctx, base);
	// 82198900: 4839C7F4  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            0x82198904 => {
    //   block [0x82198904..0x82198908)
	// 82198904: FF00D090  fmr f24, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[24].f64 = ctx.f[26].f64;
	pc = 0x82198908; continue 'dispatch;
            }
            0x82198908 => {
    //   block [0x82198908..0x8219891C)
	// 82198908: C01D007C  lfs f0, 0x7c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(124 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219890C: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 82198910: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198914: 409A0008  bne cr6, 0x8219891c
	if !ctx.cr[6].eq {
	pc = 0x8219891C; continue 'dispatch;
	}
	// 82198918: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219891C; continue 'dispatch;
            }
            0x8219891C => {
    //   block [0x8219891C..0x82198978)
	// 8219891C: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 82198920: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198924: 419A0054  beq cr6, 0x82198978
	if ctx.cr[6].eq {
	pc = 0x82198978; continue 'dispatch;
	}
	// 82198928: 397D0060  addi r11, r29, 0x60
	ctx.r[11].s64 = ctx.r[29].s64 + 96;
	pc = 0x82198978; continue 'dispatch;
            }
            0x82198978 => {
    //   block [0x82198978..0x82198D4C)
	// 82198978: C01D00A8  lfs f0, 0xa8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(168 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219897C: 3BDD0020  addi r30, r29, 0x20
	ctx.r[30].s64 = ctx.r[29].s64 + 32;
	// 82198980: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82198984: EC1A0024  fdivs f0, f26, f0
	ctx.f[0].f64 = ((ctx.f[26].f64 / ctx.f[0].f64) as f32) as f64;
	// 82198988: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 8219898C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82198990: 4BFFD6C1  bl 0x82196050
	ctx.lr = 0x82198994;
	sub_82196050(ctx, base);
	// 82198994: C01E0000  lfs f0, 0(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198998: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 8219899C: 4BF84B2D  bl 0x8211d4c8
	ctx.lr = 0x821989A0;
	sub_8211D4C8(ctx, base);
	// 821989A0: C01E000C  lfs f0, 0xc(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821989A4: 3B800002  li r28, 2
	ctx.r[28].s64 = 2;
	// 821989A8: 3BDD0030  addi r30, r29, 0x30
	ctx.r[30].s64 = ctx.r[29].s64 + 48;
	// 821989AC: EFC10032  fmuls f30, f1, f0
	ctx.f[30].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 821989B0: 387EFFD0  addi r3, r30, -0x30
	ctx.r[3].s64 = ctx.r[30].s64 + -48;
	// 821989B4: 4BFFD69D  bl 0x82196050
	ctx.lr = 0x821989B8;
	sub_82196050(ctx, base);
	// 821989B8: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821989BC: 4BFFD695  bl 0x82196050
	ctx.lr = 0x821989C0;
	sub_82196050(ctx, base);
	// 821989C0: C01EFFD0  lfs f0, -0x30(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821989C4: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 821989C8: 4BF84B01  bl 0x8211d4c8
	ctx.lr = 0x821989CC;
	sub_8211D4C8(ctx, base);
	// 821989CC: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 821989D0: C1BEFFDC  lfs f13, -0x24(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821989D4: C19E0000  lfs f12, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821989D8: EC2C0672  fmuls f1, f12, f25
	ctx.f[1].f64 = (((ctx.f[12].f64 * ctx.f[25].f64) as f32) as f64);
	// 821989DC: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 821989E0: EF80E7FA  fmadds f28, f0, f31, f28
	ctx.f[28].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[28].f64) as f32) as f64);
	// 821989E4: 4BF84AE5  bl 0x8211d4c8
	ctx.lr = 0x821989E8;
	sub_8211D4C8(ctx, base);
	// 821989E8: FDA00A10  fabs f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[1].u64 & !0x8000_0000_0000_0000u64;
	// 821989EC: C01E000C  lfs f0, 0xc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821989F0: 3B9CFFFF  addi r28, r28, -1
	ctx.r[28].s64 = ctx.r[28].s64 + -1;
	// 821989F4: 3BDE0010  addi r30, r30, 0x10
	ctx.r[30].s64 = ctx.r[30].s64 + 16;
	// 821989F8: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 821989FC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198A00: EC000072  fmuls f0, f0, f1
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[1].f64) as f32) as f64);
	// 82198A04: EF60DFFA  fmadds f27, f0, f31, f27
	ctx.f[27].f64 = (((ctx.f[0].f64 * ctx.f[31].f64 + ctx.f[27].f64) as f32) as f64);
	// 82198A08: EFFF0572  fmuls f31, f31, f21
	ctx.f[31].f64 = (((ctx.f[31].f64 * ctx.f[21].f64) as f32) as f64);
	// 82198A0C: 409AFFA4  bne cr6, 0x821989b0
	if !ctx.cr[6].eq {
	pc = 0x821989B0; continue 'dispatch;
	}
	// 82198A10: 817F00C0  lwz r11, 0xc0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(192 as u32) ) } as u64;
	// 82198A14: ED9C0432  fmuls f12, f28, f16
	ctx.f[12].f64 = (((ctx.f[28].f64 * ctx.f[16].f64) as f32) as f64);
	// 82198A18: EC1B0432  fmuls f0, f27, f16
	ctx.f[0].f64 = (((ctx.f[27].f64 * ctx.f[16].f64) as f32) as f64);
	// 82198A1C: 394B0001  addi r10, r11, 1
	ctx.r[10].s64 = ctx.r[11].s64 + 1;
	// 82198A20: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 82198A24: 915F00C0  stw r10, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[10].u32 ) };
	// 82198A28: 40990040  ble cr6, 0x82198a68
	if !ctx.cr[6].gt {
	pc = 0x82198A68; continue 'dispatch;
	}
	// 82198A2C: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198A30: 40980038  bge cr6, 0x82198a68
	if !ctx.cr[6].lt {
	pc = 0x82198A68; continue 'dispatch;
	}
	// 82198A34: 481CE7D5  bl 0x82367208
	ctx.lr = 0x82198A38;
	sub_82367208(ctx, base);
	// 82198A38: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82198A3C: C1410054  lfs f10, 0x54(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198A40: C17D005C  lfs f11, 0x5c(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(92 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198A44: F9610068  std r11, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[11].u64 ) };
	// 82198A48: C9A10068  lfd f13, 0x68(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 82198A4C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198A50: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198A54: EDAD02B2  fmuls f13, f13, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198A58: FF0D5800  fcmpu cr6, f13, f11
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[11].f64);
	// 82198A5C: 4098000C  bge cr6, 0x82198a68
	if !ctx.cr[6].lt {
	pc = 0x82198A68; continue 'dispatch;
	}
	// 82198A60: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82198A64: 48000008  b 0x82198a6c
	pc = 0x82198A6C; continue 'dispatch;
	// 82198A68: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82198A6C: C1BD0050  lfs f13, 0x50(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198A70: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 82198A74: D1BF0180  stfs f13, 0x180(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82198A78: C1BD0054  lfs f13, 0x54(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198A7C: EDADF02A  fadds f13, f13, f30
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[30].f64) as f32) as f64;
	// 82198A80: D1BF0184  stfs f13, 0x184(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 82198A84: C1BD0058  lfs f13, 0x58(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198A88: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198A8C: D3FF0188  stfs f31, 0x188(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198A90: FF1FE800  fcmpu cr6, f31, f29
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[29].f64);
	// 82198A94: 40990074  ble cr6, 0x82198b08
	if !ctx.cr[6].gt {
	pc = 0x82198B08; continue 'dispatch;
	}
	// 82198A98: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198A9C: FF1F0000  fcmpu cr6, f31, f0
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[0].f64);
	// 82198AA0: 40980028  bge cr6, 0x82198ac8
	if !ctx.cr[6].lt {
	pc = 0x82198AC8; continue 'dispatch;
	}
	// 82198AA4: EC1F03F2  fmuls f0, f31, f15
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[15].f64) as f32) as f64);
	// 82198AA8: EC209E7A  fmadds f1, f0, f25, f19
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64 + ctx.f[19].f64) as f32) as f64);
	// 82198AAC: 4BF84A1D  bl 0x8211d4c8
	ctx.lr = 0x82198AB0;
	sub_8211D4C8(ctx, base);
	// 82198AB0: EC01D02A  fadds f0, f1, f26
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ((ctx.f[1].f64 + ctx.f[26].f64) as f32) as f64;
	// 82198AB4: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82198AB8: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198ABC: EC000632  fmuls f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82198AC0: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198AC4: 48000048  b 0x82198b0c
	pc = 0x82198B0C; continue 'dispatch;
	// 82198AC8: EC1FD028  fsubs f0, f31, f26
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[26].f64) as f32) as f64);
	// 82198ACC: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198AD0: 409A000C  bne cr6, 0x82198adc
	if !ctx.cr[6].eq {
	pc = 0x82198ADC; continue 'dispatch;
	}
	// 82198AD4: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82198AD8: 4800001C  b 0x82198af4
	pc = 0x82198AF4; continue 'dispatch;
	// 82198ADC: FC200210  fabs f1, f0
	ctx.f[1].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198AE0: 4839A4F9  bl 0x82532fd8
	ctx.lr = 0x82198AE4;
	sub_82532FD8(ctx, base);
	// 82198AE4: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82198AE8: EC2003B2  fmuls f1, f0, f14
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[14].f64) as f32) as f64);
	// 82198AEC: 4839A9AD  bl 0x82533498
	ctx.lr = 0x82198AF0;
	sub_82533498(ctx, base);
	// 82198AF0: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 82198AF4: EC00D02A  fadds f0, f0, f26
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[26].f64) as f32) as f64;
	// 82198AF8: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198AFC: EC000632  fmuls f0, f0, f24
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[24].f64) as f32) as f64);
	// 82198B00: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198B04: 48000008  b 0x82198b0c
	pc = 0x82198B0C; continue 'dispatch;
	// 82198B08: D3BF0188  stfs f29, 0x188(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198B0C: 817D0088  lwz r11, 0x88(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(136 as u32) ) } as u64;
	// 82198B10: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82198B14: 419A0024  beq cr6, 0x82198b38
	if ctx.cr[6].eq {
	pc = 0x82198B38; continue 'dispatch;
	}
	// 82198B18: C1BD0080  lfs f13, 0x80(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198B1C: C01F0094  lfs f0, 0x94(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198B20: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 82198B24: EC2004B2  fmuls f1, f0, f18
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[18].f64) as f32) as f64);
	// 82198B28: 4BF849A1  bl 0x8211d4c8
	ctx.lr = 0x82198B2C;
	sub_8211D4C8(ctx, base);
	// 82198B2C: C01F0188  lfs f0, 0x188(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198B30: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198B34: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82198B38: C01F0180  lfs f0, 0x180(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(384 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198B3C: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82198B40: C3FF0184  lfs f31, 0x184(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(388 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 82198B44: FF0DA800  fcmpu cr6, f13, f21
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[21].f64);
	// 82198B48: 41980064  blt cr6, 0x82198bac
	if ctx.cr[6].lt {
	pc = 0x82198BAC; continue 'dispatch;
	}
	// 82198B4C: EC008828  fsubs f0, f0, f17
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[17].f64) as f32) as f64);
	// 82198B50: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198B54: 4098003C  bge cr6, 0x82198b90
	if !ctx.cr[6].lt {
	pc = 0x82198B90; continue 'dispatch;
	}
	// 82198B58: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82198B5C: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198B60: 4098000C  bge cr6, 0x82198b6c
	if !ctx.cr[6].lt {
	pc = 0x82198B6C; continue 'dispatch;
	}
	// 82198B64: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198B68: 48000040  b 0x82198ba8
	pc = 0x82198BA8; continue 'dispatch;
	// 82198B6C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198B70: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198B74: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198B78: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198B7C: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198B80: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198B84: 41980024  blt cr6, 0x82198ba8
	if ctx.cr[6].lt {
	pc = 0x82198BA8; continue 'dispatch;
	}
	// 82198B88: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82198B8C: 4800001C  b 0x82198ba8
	pc = 0x82198BA8; continue 'dispatch;
	// 82198B90: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198B94: 41980014  blt cr6, 0x82198ba8
	if ctx.cr[6].lt {
	pc = 0x82198BA8; continue 'dispatch;
	}
	// 82198B98: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198B9C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198BA0: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198BA4: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198BA8: EC00A828  fsubs f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[21].f64) as f32) as f64);
	// 82198BAC: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 82198BB0: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82198BB4: 38610064  addi r3, r1, 0x64
	ctx.r[3].s64 = ctx.r[1].s64 + 100;
	// 82198BB8: 4BF79219  bl 0x82111dd0
	ctx.lr = 0x82198BBC;
	sub_82111DD0(ctx, base);
	// 82198BBC: FDA0FA10  fabs f13, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82198BC0: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 82198BC4: FF0DA800  fcmpu cr6, f13, f21
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[21].f64);
	// 82198BC8: 41980064  blt cr6, 0x82198c2c
	if ctx.cr[6].lt {
	pc = 0x82198C2C; continue 'dispatch;
	}
	// 82198BCC: EC1F8828  fsubs f0, f31, f17
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[17].f64) as f32) as f64);
	// 82198BD0: FF00E800  fcmpu cr6, f0, f29
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[29].f64);
	// 82198BD4: 4098003C  bge cr6, 0x82198c10
	if !ctx.cr[6].lt {
	pc = 0x82198C10; continue 'dispatch;
	}
	// 82198BD8: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82198BDC: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198BE0: 4098000C  bge cr6, 0x82198bec
	if !ctx.cr[6].lt {
	pc = 0x82198BEC; continue 'dispatch;
	}
	// 82198BE4: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198BE8: 48000040  b 0x82198c28
	pc = 0x82198C28; continue 'dispatch;
	// 82198BEC: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198BF0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198BF4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198BF8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198BFC: EC1A0028  fsubs f0, f26, f0
	ctx.f[0].f64 = (((ctx.f[26].f64 - ctx.f[0].f64) as f32) as f64);
	// 82198C00: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198C04: 41980024  blt cr6, 0x82198c28
	if ctx.cr[6].lt {
	pc = 0x82198C28; continue 'dispatch;
	}
	// 82198C08: FC00E890  fmr f0, f29
	ctx.f[0].f64 = ctx.f[29].f64;
	// 82198C0C: 4800001C  b 0x82198c28
	pc = 0x82198C28; continue 'dispatch;
	// 82198C10: FF00D000  fcmpu cr6, f0, f26
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[26].f64);
	// 82198C14: 41980014  blt cr6, 0x82198c28
	if ctx.cr[6].lt {
	pc = 0x82198C28; continue 'dispatch;
	}
	// 82198C18: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82198C1C: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82198C20: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82198C24: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82198C28: EC00A828  fsubs f0, f0, f21
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[21].f64) as f32) as f64);
	// 82198C2C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 82198C30: EC200672  fmuls f1, f0, f25
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[25].f64) as f32) as f64);
	// 82198C34: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82198C38: 4BF79199  bl 0x82111dd0
	ctx.lr = 0x82198C3C;
	sub_82111DD0(ctx, base);
	// 82198C3C: C01F018C  lfs f0, 0x18c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(396 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198C40: ED600532  fmuls f11, f0, f20
	ctx.f[11].f64 = (((ctx.f[0].f64 * ctx.f[20].f64) as f32) as f64);
	// 82198C44: C0010050  lfs f0, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198C48: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82198C4C: C1A1005C  lfs f13, 0x5c(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198C50: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 82198C54: 389F01C0  addi r4, r31, 0x1c0
	ctx.r[4].s64 = ctx.r[31].s64 + 448;
	// 82198C58: C15F0188  lfs f10, 0x188(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(392 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198C5C: C13F00B8  lfs f9, 0xb8(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 82198C60: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 82198C64: ED2905B2  fmuls f9, f9, f22
	ctx.f[9].f64 = (((ctx.f[9].f64 * ctx.f[22].f64) as f32) as f64);
	// 82198C68: ED800372  fmuls f12, f0, f13
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82198C6C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198C70: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82198C74: EC0B02B2  fmuls f0, f11, f10
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[10].f64) as f32) as f64);
	// 82198C78: C17F00B0  lfs f11, 0xb0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(176 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198C7C: ED0B05B2  fmuls f8, f11, f22
	ctx.f[8].f64 = (((ctx.f[11].f64 * ctx.f[22].f64) as f32) as f64);
	// 82198C80: C17F00BC  lfs f11, 0xbc(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198C84: ED6BBDBA  fmadds f11, f11, f22, f23
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[22].f64 + ctx.f[23].f64) as f32) as f64);
	// 82198C88: D17F00BC  stfs f11, 0xbc(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82198C8C: C1610064  lfs f11, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 82198C90: C15F00B4  lfs f10, 0xb4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(180 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 82198C94: ED4A05B2  fmuls f10, f10, f22
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[22].f64) as f32) as f64);
	// 82198C98: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198C9C: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198CA0: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 82198CA4: EDAC45FA  fmadds f13, f12, f23, f8
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[23].f64 + ctx.f[8].f64) as f32) as f64);
	// 82198CA8: D1BF00B0  stfs f13, 0xb0(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82198CAC: EDAB55FA  fmadds f13, f11, f23, f10
	ctx.f[13].f64 = (((ctx.f[11].f64 * ctx.f[23].f64 + ctx.f[10].f64) as f32) as f64);
	// 82198CB0: D1BF00B4  stfs f13, 0xb4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82198CB4: EC004DFA  fmadds f0, f0, f23, f9
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[23].f64 + ctx.f[9].f64) as f32) as f64);
	// 82198CB8: D01F00B8  stfs f0, 0xb8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82198CBC: C01F0200  lfs f0, 0x200(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(512 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CC0: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 82198CC4: C01F0204  lfs f0, 0x204(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CC8: D0040004  stfs f0, 4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 82198CCC: C01F0208  lfs f0, 0x208(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(520 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CD0: D0040008  stfs f0, 8(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 82198CD4: D3A4000C  stfs f29, 0xc(r4)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82198CD8: C01F0210  lfs f0, 0x210(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(528 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CDC: D0040010  stfs f0, 0x10(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 82198CE0: C01F0214  lfs f0, 0x214(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(532 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CE4: D0040014  stfs f0, 0x14(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 82198CE8: C01F0218  lfs f0, 0x218(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(536 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CEC: D0040018  stfs f0, 0x18(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 82198CF0: D3A4001C  stfs f29, 0x1c(r4)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 82198CF4: C01F0220  lfs f0, 0x220(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198CF8: D0040020  stfs f0, 0x20(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 82198CFC: C01F0224  lfs f0, 0x224(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(548 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198D00: D0040024  stfs f0, 0x24(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 82198D04: C01F0228  lfs f0, 0x228(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(552 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198D08: D0040028  stfs f0, 0x28(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(40 as u32), tmp.u32 ) };
	// 82198D0C: D3A4002C  stfs f29, 0x2c(r4)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(44 as u32), tmp.u32 ) };
	// 82198D10: C01D0060  lfs f0, 0x60(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198D14: D0040030  stfs f0, 0x30(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 82198D18: C01D0064  lfs f0, 0x64(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198D1C: D0040034  stfs f0, 0x34(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 82198D20: C01D0068  lfs f0, 0x68(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198D24: D0040038  stfs f0, 0x38(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 82198D28: D344003C  stfs f26, 0x3c(r4)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 82198D2C: 481CFE65  bl 0x82368b90
	ctx.lr = 0x82198D30;
	sub_82368B90(ctx, base);
	// 82198D30: 817F01A8  lwz r11, 0x1a8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(424 as u32) ) } as u64;
	// 82198D34: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 82198D38: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 82198D3C: 915F01A8  stw r10, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[10].u32 ) };
	// 82198D40: 4199FB50  bgt cr6, 0x82198890
	if ctx.cr[6].gt {
	pc = 0x82198890; continue 'dispatch;
	}
	// 82198D44: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82198D48: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
            }
            0x82198D4C => {
    //   block [0x82198D4C..0x82198D5C)
	// 82198D4C: 38210150  addi r1, r1, 0x150
	ctx.r[1].s64 = ctx.r[1].s64 + 336;
	// 82198D50: 3981FFB0  addi r12, r1, -0x50
	ctx.r[12].s64 = ctx.r[1].s64 + -80;
	// 82198D54: 4839D2A9  bl 0x82535ffc
	ctx.lr = 0x82198D58;
	sub_82535FFC(ctx, base);
	// 82198D58: 4839C39C  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198D60(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82198D60 size=428
    let mut pc: u32 = 0x82198D60;
    'dispatch: loop {
        match pc {
            0x82198D60 => {
    //   block [0x82198D60..0x82198F0C)
	// 82198D60: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198D64: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82198D68: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 82198D6C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82198D70: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198D74: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198F10(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198F10 size=232
    let mut pc: u32 = 0x82198F10;
    'dispatch: loop {
        match pc {
            0x82198F10 => {
    //   block [0x82198F10..0x82198F64)
	// 82198F10: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198F14: 4839C1A5  bl 0x825350b8
	ctx.lr = 0x82198F18;
	sub_82535080(ctx, base);
	// 82198F18: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82198F1C: 4839D0C1  bl 0x82535fdc
	ctx.lr = 0x82198F20;
	sub_82535FB0(ctx, base);
	// 82198F20: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82198F24: FFE04890  fmr f31, f9
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = ctx.f[9].f64;
	// 82198F28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82198F2C: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 82198F30: FFA01090  fmr f29, f2
	ctx.f[29].f64 = ctx.f[2].f64;
	// 82198F34: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 82198F38: FF801890  fmr f28, f3
	ctx.f[28].f64 = ctx.f[3].f64;
	// 82198F3C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 82198F40: FF602090  fmr f27, f4
	ctx.f[27].f64 = ctx.f[4].f64;
	// 82198F44: FF402890  fmr f26, f5
	ctx.f[26].f64 = ctx.f[5].f64;
	// 82198F48: C00BD2B0  lfs f0, -0x2d50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11600 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198F4C: FF204090  fmr f25, f8
	ctx.f[25].f64 = ctx.f[8].f64;
	// 82198F50: FFC05090  fmr f30, f10
	ctx.f[30].f64 = ctx.f[10].f64;
	// 82198F54: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 82198F58: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198F5C: 40990008  ble cr6, 0x82198f64
	if !ctx.cr[6].gt {
	pc = 0x82198F64; continue 'dispatch;
	}
	// 82198F60: FFE03090  fmr f31, f6
	ctx.f[31].f64 = ctx.f[6].f64;
	pc = 0x82198F64; continue 'dispatch;
            }
            0x82198F64 => {
    //   block [0x82198F64..0x82198F74)
	// 82198F64: FDA0F210  fabs f13, f30
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 82198F68: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 82198F6C: 40990008  ble cr6, 0x82198f74
	if !ctx.cr[6].gt {
	pc = 0x82198F74; continue 'dispatch;
	}
	// 82198F70: FFC03890  fmr f30, f7
	ctx.f[30].f64 = ctx.f[7].f64;
	pc = 0x82198F74; continue 'dispatch;
            }
            0x82198F74 => {
    //   block [0x82198F74..0x82198FF8)
	// 82198F74: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 82198F78: 80E10114  lwz r7, 0x114(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(276 as u32) ) } as u64;
	// 82198F7C: FC603890  fmr f3, f7
	ctx.f[3].f64 = ctx.f[7].f64;
	// 82198F80: 3BFE00D0  addi r31, r30, 0xd0
	ctx.r[31].s64 = ctx.r[30].s64 + 208;
	// 82198F84: FC403090  fmr f2, f6
	ctx.f[2].f64 = ctx.f[6].f64;
	// 82198F88: 4BFFF171  bl 0x821980f8
	ctx.lr = 0x82198F8C;
	sub_821980F8(ctx, base);
	// 82198F8C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82198F90: D33F0080  stfs f25, 0x80(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 82198F94: D3FF0070  stfs f31, 0x70(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 82198F98: 397E01B0  addi r11, r30, 0x1b0
	ctx.r[11].s64 = ctx.r[30].s64 + 432;
	// 82198F9C: D3DF0074  stfs f30, 0x74(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 82198FA0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82198FA4: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 82198FA8: D01F0078  stfs f0, 0x78(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 82198FAC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82198FB0: D1BF007C  stfs f13, 0x7c(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 82198FB4: 939F0088  stw r28, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[28].u32 ) };
	// 82198FB8: D3BF008C  stfs f29, 0x8c(r31)
	tmp.f32 = (ctx.f[29].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 82198FBC: E95D0000  ld r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	// 82198FC0: F95F0090  std r10, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 82198FC4: E95D0008  ld r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	// 82198FC8: D39F00A0  stfs f28, 0xa0(r31)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82198FCC: E93F0090  ld r9, 0x90(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	// 82198FD0: D37F00A4  stfs f27, 0xa4(r31)
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82198FD4: D35F00A8  stfs f26, 0xa8(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82198FD8: F95F0098  std r10, 0x98(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 82198FDC: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 82198FE0: E95F0098  ld r10, 0x98(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) };
	// 82198FE4: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 82198FE8: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 82198FEC: 3981FFD8  addi r12, r1, -0x28
	ctx.r[12].s64 = ctx.r[1].s64 + -40;
	// 82198FF0: 4839D039  bl 0x82536028
	ctx.lr = 0x82198FF4;
	sub_82535FFC(ctx, base);
	// 82198FF4: 4839C114  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82198FF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82198FF8 size=360
    let mut pc: u32 = 0x82198FF8;
    'dispatch: loop {
        match pc {
            0x82198FF8 => {
    //   block [0x82198FF8..0x821990A4)
	// 82198FF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82198FFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199000: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199004: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 82199008: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219900C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199010: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199014: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82199018: 393F00D0  addi r9, r31, 0xd0
	ctx.r[9].s64 = ctx.r[31].s64 + 208;
	// 8219901C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 82199020: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199024: C18ABFFC  lfs f12, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199028: C0090014  lfs f0, 0x14(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219902C: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 82199030: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199034: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199038: 419A007C  beq cr6, 0x821990b4
	if ctx.cr[6].eq {
	pc = 0x821990B4; continue 'dispatch;
	}
	// 8219903C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 82199040: 419A0064  beq cr6, 0x821990a4
	if ctx.cr[6].eq {
	pc = 0x821990A4; continue 'dispatch;
	}
	// 82199044: A14B0088  lhz r10, 0x88(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 82199048: 2B0A0004  cmplwi cr6, r10, 4
	ctx.cr[6].compare_u32(ctx.r[10].u32, 4 as u32, &mut ctx.xer);
	// 8219904C: 409A0058  bne cr6, 0x821990a4
	if !ctx.cr[6].eq {
	pc = 0x821990A4; continue 'dispatch;
	}
	// 82199050: 394B00D0  addi r10, r11, 0xd0
	ctx.r[10].s64 = ctx.r[11].s64 + 208;
	pc = 0x821990A4; continue 'dispatch;
            }
            0x821990A4 => {
    //   block [0x821990A4..0x821990B4)
	// 821990A4: 816B0080  lwz r11, 0x80(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821990A8: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821990AC: 419AFF88  beq cr6, 0x82199034
	if ctx.cr[6].eq {
	pc = 0x82199034; continue 'dispatch;
	}
	// 821990B0: 4800000C  b 0x821990bc
	pc = 0x821990BC; continue 'dispatch;
            }
            0x821990B4 => {
    //   block [0x821990B4..0x82199160)
	// 821990B4: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 821990B8: 419A0010  beq cr6, 0x821990c8
	if ctx.cr[6].eq {
	pc = 0x821990C8; continue 'dispatch;
	}
	// 821990BC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821990C0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821990C4: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821990C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821990CC: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821990D0: 614A85DC  ori r10, r10, 0x85dc
	ctx.r[10].u64 = ctx.r[10].u64 | 34268;
	// 821990D4: C00B222C  lfs f0, 0x222c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8748 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821990D8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821990DC: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 821990E0: C1890018  lfs f12, 0x18(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821990E4: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821990E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821990EC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821990F0: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821990F4: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821990F8: D1BF0198  stfs f13, 0x198(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 821990FC: D009000C  stfs f0, 0xc(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 82199100: 481CDE31  bl 0x82366f30
	ctx.lr = 0x82199104;
	sub_82366F30(ctx, base);
	// 82199104: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82199108: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219910C: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82199110: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82199114: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199118: C3EB2280  lfs f31, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219911C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82199120: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82199124: D01F01A0  stfs f0, 0x1a0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 82199128: 481CDE09  bl 0x82366f30
	ctx.lr = 0x8219912C;
	sub_82366F30(ctx, base);
	// 8219912C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 82199130: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 82199134: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 82199138: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219913C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 82199140: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 82199144: D01F019C  stfs f0, 0x19c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82199148: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219914C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199150: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199154: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82199158: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219915C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199160(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199160 size=684
    let mut pc: u32 = 0x82199160;
    'dispatch: loop {
        match pc {
            0x82199160 => {
    //   block [0x82199160..0x82199270)
	// 82199160: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199164: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199168: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219916C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199170: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 82199174: 4839CE6D  bl 0x82535fe0
	ctx.lr = 0x82199178;
	sub_82535FB0(ctx, base);
	// 82199178: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219917C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199180: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199184: 3BCBBFF0  addi r30, r11, -0x4010
	ctx.r[30].s64 = ctx.r[11].s64 + -16400;
	// 82199188: 897E0000  lbz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219918C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199190: 409A025C  bne cr6, 0x821993ec
	if !ctx.cr[6].eq {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 82199194: C01F0194  lfs f0, 0x194(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(404 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199198: C1BF0198  lfs f13, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219919C: EC0D002A  fadds f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 + ctx.f[0].f64) as f32) as f64;
	// 821991A0: D01F0194  stfs f0, 0x194(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(404 as u32), tmp.u32 ) };
	// 821991A4: 481CDD8D  bl 0x82366f30
	ctx.lr = 0x821991A8;
	sub_82366F30(ctx, base);
	// 821991A8: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821991AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821991B0: C1BF01A0  lfs f13, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821991B4: F9410060  std r10, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[10].u64 ) };
	// 821991B8: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 821991BC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821991C0: C3CB2038  lfs f30, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821991C4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821991C8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821991CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821991D0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821991D4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821991D8: C3AB2280  lfs f29, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821991DC: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821991E0: EC206FBA  fmadds f1, f0, f30, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 821991E4: 481CE95D  bl 0x82367b40
	ctx.lr = 0x821991E8;
	sub_82367B40(ctx, base);
	// 821991E8: D03F01A0  stfs f1, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(416 as u32), tmp.u32 ) };
	// 821991EC: 481CDD45  bl 0x82366f30
	ctx.lr = 0x821991F0;
	sub_82366F30(ctx, base);
	// 821991F0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821991F4: C1BF019C  lfs f13, 0x19c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(412 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821991F8: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821991FC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 82199200: C8010060  lfd f0, 0x60(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 82199204: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 82199208: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219920C: EC000772  fmuls f0, f0, f29
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82199210: EC206FBA  fmadds f1, f0, f30, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[30].f64 + ctx.f[13].f64) as f32) as f64);
	// 82199214: 481CE92D  bl 0x82367b40
	ctx.lr = 0x82199218;
	sub_82367B40(ctx, base);
	// 82199218: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219921C: C3DF01A0  lfs f30, 0x1a0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(416 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 82199220: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 82199224: D03F019C  stfs f1, 0x19c(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(412 as u32), tmp.u32 ) };
	// 82199228: C00BD4DC  lfs f0, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219922C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199230: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 82199234: C36A1FF8  lfs f27, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[27].f64 = (tmp.f32 as f64);
	// 82199238: C34BBFFC  lfs f26, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219923C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199240: C38B2048  lfs f28, 0x2048(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8264 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 82199244: FDA00210  fabs f13, f0
	ctx.f[13].u64 = ctx.f[0].u64 & !0x8000_0000_0000_0000u64;
	// 82199248: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 8219924C: 41980064  blt cr6, 0x821992b0
	if ctx.cr[6].lt {
	pc = 0x821992B0; continue 'dispatch;
	}
	// 82199250: EC00E028  fsubs f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[28].f64) as f32) as f64);
	// 82199254: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 82199258: 4098003C  bge cr6, 0x82199294
	if !ctx.cr[6].lt {
	pc = 0x82199294; continue 'dispatch;
	}
	// 8219925C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82199260: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199264: 4098000C  bge cr6, 0x82199270
	if !ctx.cr[6].lt {
	pc = 0x82199270; continue 'dispatch;
	}
	// 82199268: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219926C: 48000040  b 0x821992ac
	pc = 0x821992AC; continue 'dispatch;
            }
            0x82199270 => {
    //   block [0x82199270..0x82199294)
	// 82199270: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82199274: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82199278: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219927C: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82199280: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 82199284: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199288: 41980024  blt cr6, 0x821992ac
	if ctx.cr[6].lt {
	pc = 0x821992AC; continue 'dispatch;
	}
	// 8219928C: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82199290: 4800001C  b 0x821992ac
	pc = 0x821992AC; continue 'dispatch;
            }
            0x82199294 => {
    //   block [0x82199294..0x821992AC)
	// 82199294: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199298: 41980014  blt cr6, 0x821992ac
	if ctx.cr[6].lt {
	pc = 0x821992AC; continue 'dispatch;
	}
	// 8219929C: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821992A0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821992A4: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821992A8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x821992AC; continue 'dispatch;
            }
            0x821992AC => {
    //   block [0x821992AC..0x821992B0)
	// 821992AC: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x821992B0; continue 'dispatch;
            }
            0x821992B0 => {
    //   block [0x821992B0..0x821992F8)
	// 821992B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821992B4: 38810054  addi r4, r1, 0x54
	ctx.r[4].s64 = ctx.r[1].s64 + 84;
	// 821992B8: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 821992BC: C3AB2490  lfs f29, 0x2490(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9360 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821992C0: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 821992C4: 4BF78B0D  bl 0x82111dd0
	ctx.lr = 0x821992C8;
	sub_82111DD0(ctx, base);
	// 821992C8: FDA0F210  fabs f13, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].u64 = ctx.f[30].u64 & !0x8000_0000_0000_0000u64;
	// 821992CC: FC00F090  fmr f0, f30
	ctx.f[0].f64 = ctx.f[30].f64;
	// 821992D0: FF0DD000  fcmpu cr6, f13, f26
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[26].f64);
	// 821992D4: 41980064  blt cr6, 0x82199338
	if ctx.cr[6].lt {
	pc = 0x82199338; continue 'dispatch;
	}
	// 821992D8: EC1EE028  fsubs f0, f30, f28
	ctx.f[0].f64 = (((ctx.f[30].f64 - ctx.f[28].f64) as f32) as f64);
	// 821992DC: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821992E0: 4098003C  bge cr6, 0x8219931c
	if !ctx.cr[6].lt {
	pc = 0x8219931C; continue 'dispatch;
	}
	// 821992E4: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 821992E8: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 821992EC: 4098000C  bge cr6, 0x821992f8
	if !ctx.cr[6].lt {
	pc = 0x821992F8; continue 'dispatch;
	}
	// 821992F0: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 821992F4: 48000040  b 0x82199334
	pc = 0x82199334; continue 'dispatch;
            }
            0x821992F8 => {
    //   block [0x821992F8..0x8219931C)
	// 821992F8: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 821992FC: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 82199300: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82199304: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 82199308: EC1F0028  fsubs f0, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219930C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199310: 41980024  blt cr6, 0x82199334
	if ctx.cr[6].lt {
	pc = 0x82199334; continue 'dispatch;
	}
	// 82199314: FC00D890  fmr f0, f27
	ctx.f[0].f64 = ctx.f[27].f64;
	// 82199318: 4800001C  b 0x82199334
	pc = 0x82199334; continue 'dispatch;
            }
            0x8219931C => {
    //   block [0x8219931C..0x82199334)
	// 8219931C: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 82199320: 41980014  blt cr6, 0x82199334
	if ctx.cr[6].lt {
	pc = 0x82199334; continue 'dispatch;
	}
	// 82199324: FDA0065E  fctidz f13, f0
	ctx.f[13].s64 = if ctx.f[0].f64 > (i64::MAX as f64) { i64::MAX } else { ctx.f[0].f64.trunc() as i64 };
	// 82199328: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219932C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 82199330: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	pc = 0x82199334; continue 'dispatch;
            }
            0x82199334 => {
    //   block [0x82199334..0x82199338)
	// 82199334: EC00D028  fsubs f0, f0, f26
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[26].f64) as f32) as f64);
	pc = 0x82199338; continue 'dispatch;
            }
            0x82199338 => {
    //   block [0x82199338..0x821993EC)
	// 82199338: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219933C: EC200772  fmuls f1, f0, f29
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 82199340: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199344: 4BF78A8D  bl 0x82111dd0
	ctx.lr = 0x82199348;
	sub_82111DD0(ctx, base);
	// 82199348: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219934C: FC000050  fneg f0, f0
	ctx.f[0].u64 = ctx.f[0].u64 ^ 0x8000_0000_0000_0000u64;
	// 82199350: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199354: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199358: D3FF018C  stfs f31, 0x18c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(396 as u32), tmp.u32 ) };
	// 8219935C: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199360: D01F0180  stfs f0, 0x180(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(384 as u32), tmp.u32 ) };
	// 82199364: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199368: D01F0184  stfs f0, 0x184(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(388 as u32), tmp.u32 ) };
	// 8219936C: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199370: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199374: D01F0188  stfs f0, 0x188(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(392 as u32), tmp.u32 ) };
	// 82199378: C1AB22D0  lfs f13, 0x22d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8912 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219937C: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 82199380: C19F0198  lfs f12, 0x198(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(408 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199384: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 82199388: D1BF0198  stfs f13, 0x198(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(408 as u32), tmp.u32 ) };
	// 8219938C: C19F00E4  lfs f12, 0xe4(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(228 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 82199390: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 82199394: C1BF00E0  lfs f13, 0xe0(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199398: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 8219939C: C01F0190  lfs f0, 0x190(r31)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821993A0: ED8D0032  fmuls f12, f13, f0
	ctx.f[12].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821993A4: 7DBE5C2E  lfsx f13, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821993A8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 821993AC: 616B85DC  ori r11, r11, 0x85dc
	ctx.r[11].u64 = ctx.r[11].u64 | 34268;
	// 821993B0: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 821993B4: D1BF01A4  stfs f13, 0x1a4(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(420 as u32), tmp.u32 ) };
	// 821993B8: 7DBE5C2E  lfsx f13, r30, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821993BC: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821993C0: D01F0190  stfs f0, 0x190(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(400 as u32), tmp.u32 ) };
	// 821993C4: FF00D800  fcmpu cr6, f0, f27
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[27].f64);
	// 821993C8: 41990024  bgt cr6, 0x821993ec
	if ctx.cr[6].gt {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 821993CC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821993D0: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821993D4: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821993D8: 409A0014  bne cr6, 0x821993ec
	if !ctx.cr[6].eq {
	pc = 0x821993EC; continue 'dispatch;
	}
	// 821993DC: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821993E0: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821993E4: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821993E8: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x821993EC; continue 'dispatch;
            }
            0x821993EC => {
    //   block [0x821993EC..0x8219940C)
	// 821993EC: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821993F0: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 821993F4: 4839CC39  bl 0x8253602c
	ctx.lr = 0x821993F8;
	sub_82535FFC(ctx, base);
	// 821993F8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821993FC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199400: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 82199404: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199408: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199410(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82199410 size=476
    let mut pc: u32 = 0x82199410;
    'dispatch: loop {
        match pc {
            0x82199410 => {
    //   block [0x82199410..0x821995EC)
	// 82199410: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821995F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821995F0 size=28
    let mut pc: u32 = 0x821995F0;
    'dispatch: loop {
        match pc {
            0x821995F0 => {
    //   block [0x821995F0..0x8219960C)
	// 821995F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821995F4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821995F8: 9163008C  stw r11, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821995FC: 916AB9D8  stw r11, -0x4628(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(-17960 as u32), ctx.r[11].u32 ) };
	// 82199600: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 82199604: F96AB9D0  std r11, -0x4630(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-17968 as u32), ctx.r[11].u64 ) };
	// 82199608: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199610(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199610 size=204
    let mut pc: u32 = 0x82199610;
    'dispatch: loop {
        match pc {
            0x82199610 => {
    //   block [0x82199610..0x82199638)
	// 82199610: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199614: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199618: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219961C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199620: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199624: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 82199628: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219962C: 409A000C  bne cr6, 0x82199638
	if !ctx.cr[6].eq {
	pc = 0x82199638; continue 'dispatch;
	}
	// 82199630: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 82199634: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	pc = 0x82199638; continue 'dispatch;
            }
            0x82199638 => {
    //   block [0x82199638..0x8219965C)
	// 82199638: 3FC082C0  lis r30, -0x7d40
	ctx.r[30].s64 = -2101346304;
	// 8219963C: 3D602236  lis r11, 0x2236
	ctx.r[11].s64 = 573964288;
	// 82199640: 617F0679  ori r31, r11, 0x679
	ctx.r[31].u64 = ctx.r[11].u64 | 1657;
	// 82199644: 817EB9D8  lwz r11, -0x4628(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219964C: 419A0010  beq cr6, 0x8219965c
	if ctx.cr[6].eq {
	pc = 0x8219965C; continue 'dispatch;
	}
	// 82199650: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 82199654: 7F0BF800  cmpw cr6, r11, r31
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[31].s32, &mut ctx.xer);
	// 82199658: 419A006C  beq cr6, 0x821996c4
	if ctx.cr[6].eq {
	pc = 0x821996C4; continue 'dispatch;
	}
	pc = 0x8219965C; continue 'dispatch;
            }
            0x8219965C => {
    //   block [0x8219965C..0x821996BC)
	// 8219965C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199660: 3CC00000  lis r6, 0
	ctx.r[6].s64 = 0;
	// 82199664: 38EB099C  addi r7, r11, 0x99c
	ctx.r[7].s64 = ctx.r[11].s64 + 2460;
	// 82199668: 60C6EA60  ori r6, r6, 0xea60
	ctx.r[6].u64 = ctx.r[6].u64 | 60000;
	// 8219966C: 38A00040  li r5, 0x40
	ctx.r[5].s64 = 64;
	// 82199670: 38600150  li r3, 0x150
	ctx.r[3].s64 = 336;
	// 82199674: 481D0E1D  bl 0x8236a490
	ctx.lr = 0x82199678;
	sub_8236A490(ctx, base);
	// 82199678: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219967C: 419A0040  beq cr6, 0x821996bc
	if ctx.cr[6].eq {
	pc = 0x821996BC; continue 'dispatch;
	}
	// 82199680: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 82199684: 907EB9D8  stw r3, -0x4628(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17960 as u32), ctx.r[3].u32 ) };
	// 82199688: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219968C: 93E3008C  stw r31, 0x8c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(140 as u32), ctx.r[31].u32 ) };
	// 82199690: 394B09FC  addi r10, r11, 0x9fc
	ctx.r[10].s64 = ctx.r[11].s64 + 2556;
	// 82199694: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199698: C0091FF8  lfs f0, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219969C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821996A0: D0030084  stfs f0, 0x84(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821996A4: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821996A8: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821996AC: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 821996B0: 916300D0  stw r11, 0xd0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 821996B4: 9923001C  stb r9, 0x1c(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[9].u8 ) };
	// 821996B8: 4800000C  b 0x821996c4
	pc = 0x821996C4; continue 'dispatch;
            }
            0x821996BC => {
    //   block [0x821996BC..0x821996C4)
	// 821996BC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821996C0: 917EB9D8  stw r11, -0x4628(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(-17960 as u32), ctx.r[11].u32 ) };
	pc = 0x821996C4; continue 'dispatch;
            }
            0x821996C4 => {
    //   block [0x821996C4..0x821996DC)
	// 821996C4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821996C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821996CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821996D0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821996D4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821996D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821996E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821996E0 size=672
    let mut pc: u32 = 0x821996E0;
    'dispatch: loop {
        match pc {
            0x821996E0 => {
    //   block [0x821996E0..0x82199980)
	// 821996E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821996E4: 4839B9B9  bl 0x8253509c
	ctx.lr = 0x821996E8;
	sub_82535080(ctx, base);
	// 821996E8: 3981FFA0  addi r12, r1, -0x60
	ctx.r[12].s64 = ctx.r[1].s64 + -96;
	// 821996EC: 4839C8FD  bl 0x82535fe8
	ctx.lr = 0x821996F0;
	sub_82535FB0(ctx, base);
	// 821996F0: 3980FF70  li r12, -0x90
	ctx.r[12].s64 = -144;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199980(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x82199980 size=84
    let mut pc: u32 = 0x82199980;
    'dispatch: loop {
        match pc {
            0x82199980 => {
    //   block [0x82199980..0x821999D4)
	// 82199980: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199984: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199988: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219998C: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199990: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 82199994: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 82199998: 482308E1  bl 0x823ca278
	ctx.lr = 0x8219999C;
	sub_823CA278(ctx, base);
	// 8219999C: 816D0000  lwz r11, 0(r13)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[13].u32.wrapping_add(0 as u32) ) } as u64;
	// 821999A0: 39400068  li r10, 0x68
	ctx.r[10].s64 = 104;
	// 821999A4: E93F00E0  ld r9, 0xe0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[31].u32.wrapping_add(224 as u32) ) };
	// 821999A8: E9010050  ld r8, 0x50(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821999AC: 7D294050  subf r9, r9, r8
	ctx.r[9].s64 = ctx.r[8].s64 - ctx.r[9].s64;
	// 821999B0: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	// 821999B4: 3D4082C0  lis r10, -0x7d40
	ctx.r[10].s64 = -2101346304;
	// 821999B8: 7D6B4850  subf r11, r11, r9
	ctx.r[11].s64 = ctx.r[9].s64 - ctx.r[11].s64;
	// 821999BC: F96AB9D0  std r11, -0x4630(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-17968 as u32), ctx.r[11].u64 ) };
	// 821999C0: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821999C4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821999C8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821999CC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821999D0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821999D8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821999D8 size=360
    let mut pc: u32 = 0x821999D8;
    'dispatch: loop {
        match pc {
            0x821999D8 => {
    //   block [0x821999D8..0x82199B40)
	// 821999D8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821999DC: 4839B6DD  bl 0x825350b8
	ctx.lr = 0x821999E0;
	sub_82535080(ctx, base);
	// 821999E0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821999E4: 3980FFC0  li r12, -0x40
	ctx.r[12].s64 = -64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199B40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x82199B40 size=432
    let mut pc: u32 = 0x82199B40;
    'dispatch: loop {
        match pc {
            0x82199B40 => {
    //   block [0x82199B40..0x82199CF0)
	// 82199B40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199B44: 4839B575  bl 0x825350b8
	ctx.lr = 0x82199B48;
	sub_82535080(ctx, base);
	// 82199B48: 3980FFB0  li r12, -0x50
	ctx.r[12].s64 = -80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199D08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199D08 size=676
    let mut pc: u32 = 0x82199D08;
    'dispatch: loop {
        match pc {
            0x82199D08 => {
    //   block [0x82199D08..0x82199D5C)
	// 82199D08: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199D0C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 82199D10: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 82199D14: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199D18: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 82199D1C: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 82199D20: 2B040005  cmplwi cr6, r4, 5
	ctx.cr[6].compare_u32(ctx.r[4].u32, 5 as u32, &mut ctx.xer);
	// 82199D24: 83EBB9D8  lwz r31, -0x4628(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 82199D28: 41990234  bgt cr6, 0x82199f5c
	if ctx.cr[6].gt {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199D2C: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 82199D30: 398C9D44  addi r12, r12, -0x62bc
	ctx.r[12].s64 = ctx.r[12].s64 + -25276;
	// 82199D34: 5480103A  slwi r0, r4, 2
	ctx.r[0].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 82199D38: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 82199D3C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 82199D40: 4E800420  bctr
	match ctx.r[4].u64 {
		0 => {
	pc = 0x82199D5C; continue 'dispatch;
		},
		1 => {
	pc = 0x82199DC4; continue 'dispatch;
		},
		2 => {
	pc = 0x82199DFC; continue 'dispatch;
		},
		3 => {
	pc = 0x82199E34; continue 'dispatch;
		},
		4 => {
	pc = 0x82199E9C; continue 'dispatch;
		},
		5 => {
	pc = 0x82199EE0; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 82199D44: 82199D5C  lwz r16, -0x62a4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25252 as u32) ) } as u64;
	// 82199D48: 82199DC4  lwz r16, -0x623c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25148 as u32) ) } as u64;
	// 82199D4C: 82199DFC  lwz r16, -0x6204(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25092 as u32) ) } as u64;
	// 82199D50: 82199E34  lwz r16, -0x61cc(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-25036 as u32) ) } as u64;
	// 82199D54: 82199E9C  lwz r16, -0x6164(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24932 as u32) ) } as u64;
	// 82199D58: 82199EE0  lwz r16, -0x6120(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-24864 as u32) ) } as u64;
            }
            0x82199D5C => {
    //   block [0x82199D5C..0x82199DC4)
	// 82199D5C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199D60: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199D64: 38EB09A8  addi r7, r11, 0x9a8
	ctx.r[7].s64 = ctx.r[11].s64 + 2472;
	// 82199D68: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199D6C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199D70: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 82199D74: 481D071D  bl 0x8236a490
	ctx.lr = 0x82199D78;
	sub_8236A490(ctx, base);
	// 82199D78: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199D7C: 419A01E0  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199D80: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199D84: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199D88: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199D8C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199D90: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199D94: 394B0A40  addi r10, r11, 0xa40
	ctx.r[10].s64 = ctx.r[11].s64 + 2624;
	// 82199D98: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199D9C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199DA0: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199DA4: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199DA8: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199DAC: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199DB0: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199DB4: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199DB8: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199DBC: B1630088  sth r11, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u16 ) };
	// 82199DC0: 48000188  b 0x82199f48
	pc = 0x82199F48; continue 'dispatch;
            }
            0x82199DC4 => {
    //   block [0x82199DC4..0x82199DFC)
	// 82199DC4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199DC8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199DCC: 38EB09B4  addi r7, r11, 0x9b4
	ctx.r[7].s64 = ctx.r[11].s64 + 2484;
	// 82199DD0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199DD4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199DD8: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82199DDC: 481D06B5  bl 0x8236a490
	ctx.lr = 0x82199DE0;
	sub_8236A490(ctx, base);
	// 82199DE0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199DE4: 419A0178  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199DE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199DEC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199DF0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199DF4: 394B0A88  addi r10, r11, 0xa88
	ctx.r[10].s64 = ctx.r[11].s64 + 2696;
	// 82199DF8: 4800011C  b 0x82199f14
	pc = 0x82199F14; continue 'dispatch;
            }
            0x82199DFC => {
    //   block [0x82199DFC..0x82199E34)
	// 82199DFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E00: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199E04: 38EB09C0  addi r7, r11, 0x9c0
	ctx.r[7].s64 = ctx.r[11].s64 + 2496;
	// 82199E08: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199E0C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199E10: 386001E0  li r3, 0x1e0
	ctx.r[3].s64 = 480;
	// 82199E14: 481D067D  bl 0x8236a490
	ctx.lr = 0x82199E18;
	sub_8236A490(ctx, base);
	// 82199E18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199E1C: 419A0140  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199E20: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199E24: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199E28: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E2C: 394B0AAC  addi r10, r11, 0xaac
	ctx.r[10].s64 = ctx.r[11].s64 + 2732;
	// 82199E30: 480000E4  b 0x82199f14
	pc = 0x82199F14; continue 'dispatch;
            }
            0x82199E34 => {
    //   block [0x82199E34..0x82199E9C)
	// 82199E34: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E38: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199E3C: 38EB09CC  addi r7, r11, 0x9cc
	ctx.r[7].s64 = ctx.r[11].s64 + 2508;
	// 82199E40: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199E44: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199E48: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 82199E4C: 481D0645  bl 0x8236a490
	ctx.lr = 0x82199E50;
	sub_8236A490(ctx, base);
	// 82199E50: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199E54: 419A0108  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199E58: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199E5C: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199E60: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199E64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199E68: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199E6C: 394B0A64  addi r10, r11, 0xa64
	ctx.r[10].s64 = ctx.r[11].s64 + 2660;
	// 82199E70: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199E74: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199E78: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199E7C: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199E80: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199E84: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199E88: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199E8C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199E90: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199E94: B1630088  sth r11, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[11].u16 ) };
	// 82199E98: 480000B0  b 0x82199f48
	pc = 0x82199F48; continue 'dispatch;
            }
            0x82199E9C => {
    //   block [0x82199E9C..0x82199EE0)
	// 82199E9C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199EA0: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199EA4: 38EB09D8  addi r7, r11, 0x9d8
	ctx.r[7].s64 = ctx.r[11].s64 + 2520;
	// 82199EA8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199EAC: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199EB0: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 82199EB4: 481D05DD  bl 0x8236a490
	ctx.lr = 0x82199EB8;
	sub_8236A490(ctx, base);
	// 82199EB8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199EBC: 419A00A0  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199EC0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199EC4: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199EC8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199ECC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199ED0: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199ED4: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 82199ED8: 394B0AD0  addi r10, r11, 0xad0
	ctx.r[10].s64 = ctx.r[11].s64 + 2768;
	// 82199EDC: 48000044  b 0x82199f20
	pc = 0x82199F20; continue 'dispatch;
            }
            0x82199EE0 => {
    //   block [0x82199EE0..0x82199F14)
	// 82199EE0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199EE4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 82199EE8: 38EB09E4  addi r7, r11, 0x9e4
	ctx.r[7].s64 = ctx.r[11].s64 + 2532;
	// 82199EEC: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 82199EF0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 82199EF4: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 82199EF8: 481D0599  bl 0x8236a490
	ctx.lr = 0x82199EFC;
	sub_8236A490(ctx, base);
	// 82199EFC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199F00: 419A005C  beq cr6, 0x82199f5c
	if ctx.cr[6].eq {
	pc = 0x82199F5C; continue 'dispatch;
	}
	// 82199F04: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 82199F08: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 82199F0C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 82199F10: 394B0AF4  addi r10, r11, 0xaf4
	ctx.r[10].s64 = ctx.r[11].s64 + 2804;
	pc = 0x82199F14; continue 'dispatch;
            }
            0x82199F14 => {
    //   block [0x82199F14..0x82199F20)
	// 82199F14: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 82199F18: C1A9BA38  lfs f13, -0x45c8(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 82199F1C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x82199F20; continue 'dispatch;
            }
            0x82199F20 => {
    //   block [0x82199F20..0x82199F48)
	// 82199F20: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 82199F24: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 82199F28: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 82199F2C: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 82199F30: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 82199F34: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 82199F38: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 82199F3C: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 82199F40: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 82199F44: B1230088  sth r9, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[9].u16 ) };
	pc = 0x82199F48; continue 'dispatch;
            }
            0x82199F48 => {
    //   block [0x82199F48..0x82199F5C)
	// 82199F48: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 82199F4C: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 82199F50: 916300C0  stw r11, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[11].u32 ) };
	// 82199F54: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 82199F58: 409A001C  bne cr6, 0x82199f74
	if !ctx.cr[6].eq {
	pc = 0x82199F74; continue 'dispatch;
	}
	pc = 0x82199F5C; continue 'dispatch;
            }
            0x82199F5C => {
    //   block [0x82199F5C..0x82199F74)
	// 82199F5C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 82199F60: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82199F64: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199F68: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199F6C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199F70: 4E800020  blr
	return;
            }
            0x82199F74 => {
    //   block [0x82199F74..0x82199F94)
	// 82199F74: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 82199F78: 91630084  stw r11, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 82199F7C: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199F80: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 82199F84: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199F88: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199F8C: 419A0008  beq cr6, 0x82199f94
	if ctx.cr[6].eq {
	pc = 0x82199F94; continue 'dispatch;
	}
	// 82199F90: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	pc = 0x82199F94; continue 'dispatch;
            }
            0x82199F94 => {
    //   block [0x82199F94..0x82199FAC)
	// 82199F94: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 82199F98: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 82199F9C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 82199FA0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 82199FA4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 82199FA8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_82199FB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x82199FB0 size=532
    let mut pc: u32 = 0x82199FB0;
    'dispatch: loop {
        match pc {
            0x82199FB0 => {
    //   block [0x82199FB0..0x8219A024)
	// 82199FB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 82199FB4: 4839B109  bl 0x825350bc
	ctx.lr = 0x82199FB8;
	sub_82535080(ctx, base);
	// 82199FB8: DBA1FFC8  stfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[29].u64 ) };
	// 82199FBC: DBC1FFD0  stfd f30, -0x30(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[30].u64 ) };
	// 82199FC0: DBE1FFD8  stfd f31, -0x28(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 82199FC4: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 82199FC8: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 82199FCC: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 82199FD0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 82199FD4: 419A0050  beq cr6, 0x8219a024
	if ctx.cr[6].eq {
	pc = 0x8219A024; continue 'dispatch;
	}
	// 82199FD8: 813D00D4  lwz r9, 0xd4(r29)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 82199FDC: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 82199FE0: 409801C8  bge cr6, 0x8219a1a8
	if !ctx.cr[6].lt {
	pc = 0x8219A1A8; continue 'dispatch;
	}
	// 82199FE4: 817D00D0  lwz r11, 0xd0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(208 as u32) ) } as u64;
	// 82199FE8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 82199FEC: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 82199FF0: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 82199FF4: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 82199FF8: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 82199FFC: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A000: 7D4BE92E  stwx r10, r11, r29
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32), ctx.r[10].u32) };
	// 8219A004: 817D00D4  lwz r11, 0xd4(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A008: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A00C: 917D00D4  stw r11, 0xd4(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A010: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A014: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219A018: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8219A01C: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219A020: 4839B0EC  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8219A024 => {
    //   block [0x8219A024..0x8219A068)
	// 8219A024: 817D00D8  lwz r11, 0xd8(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(216 as u32) ) } as u64;
	// 8219A028: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A02C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A030: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A034: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A038: C3CB2280  lfs f30, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A03C: 4098002C  bge cr6, 0x8219a068
	if !ctx.cr[6].lt {
	pc = 0x8219A068; continue 'dispatch;
	}
	// 8219A040: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A044: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219A048: 3BEBB9D8  addi r31, r11, -0x4628
	ctx.r[31].s64 = ctx.r[11].s64 + -17960;
	// 8219A04C: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A050: 4BFFFCB9  bl 0x82199d08
	ctx.lr = 0x8219A054;
	sub_82199D08(ctx, base);
	// 8219A054: C09D00F8  lfs f4, 0xf8(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(248 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A058: C07D00F4  lfs f3, 0xf4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(244 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A05C: C05D00F0  lfs f2, 0xf0(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(240 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A060: C03D00FC  lfs f1, 0xfc(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(252 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A064: 4800004C  b 0x8219a0b0
	pc = 0x8219A0B0; continue 'dispatch;
            }
            0x8219A068 => {
    //   block [0x8219A068..0x8219A0B0)
	// 8219A068: 481CD0D1  bl 0x82367138
	ctx.lr = 0x8219A06C;
	sub_82367138(ctx, base);
	// 8219A06C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A070: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A074: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219A078: 3BEBB9D8  addi r31, r11, -0x4628
	ctx.r[31].s64 = ctx.r[11].s64 + -17960;
	// 8219A07C: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 8219A080: 807F0000  lwz r3, 0(r31)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A084: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A088: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A08C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A090: EFA007B2  fmuls f29, f0, f30
	ctx.f[29].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219A094: 4BFFFC75  bl 0x82199d08
	ctx.lr = 0x8219A098;
	sub_82199D08(ctx, base);
	// 8219A098: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A09C: FC60E890  fmr f3, f29
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[3].f64 = ctx.f[29].f64;
	// 8219A0A0: FC40F890  fmr f2, f31
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219A0A4: C08B23D0  lfs f4, 0x23d0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9168 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A0A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A0AC: C02B2E38  lfs f1, 0x2e38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11832 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x8219A0B0; continue 'dispatch;
            }
            0x8219A0B0 => {
    //   block [0x8219A0B0..0x8219A188)
	// 8219A0B0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A0B4: 4BFFC02D  bl 0x821960e0
	ctx.lr = 0x8219A0B8;
	sub_821960E0(ctx, base);
	// 8219A0B8: 39600DEF  li r11, 0xdef
	ctx.r[11].s64 = 3567;
	// 8219A0BC: 917E003C  stw r11, 0x3c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(60 as u32), ctx.r[11].u32 ) };
	// 8219A0C0: 481CD079  bl 0x82367138
	ctx.lr = 0x8219A0C4;
	sub_82367138(ctx, base);
	// 8219A0C4: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A0C8: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A0CC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A0D0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A0D4: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A0D8: ED8007B2  fmuls f12, f0, f30
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219A0DC: 481CD3AD  bl 0x82367488
	ctx.lr = 0x8219A0E0;
	sub_82367488(ctx, base);
	// 8219A0E0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A0E4: 83FF0000  lwz r31, 0(r31)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A0E8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219A0EC: 38EB09CC  addi r7, r11, 0x9cc
	ctx.r[7].s64 = ctx.r[11].s64 + 2508;
	// 8219A0F0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A0F4: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A0F8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219A0FC: 38600190  li r3, 0x190
	ctx.r[3].s64 = 400;
	// 8219A100: C00BBFFC  lfs f0, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A104: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219A108: EC0C0028  fsubs f0, f12, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A10C: EDA10032  fmuls f13, f1, f0
	ctx.f[13].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A110: C00BD560  lfs f0, -0x2aa0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10912 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A114: EFCD0032  fmuls f30, f13, f0
	ctx.f[30].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A118: 481D0379  bl 0x8236a490
	ctx.lr = 0x8219A11C;
	sub_8236A490(ctx, base);
	// 8219A11C: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A120: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219A124: 419A0098  beq cr6, 0x8219a1bc
	if ctx.cr[6].eq {
	pc = 0x8219A1BC; continue 'dispatch;
	}
	// 8219A128: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A12C: D3E300B0  stfs f31, 0xb0(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219A130: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219A134: D3E300B4  stfs f31, 0xb4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219A138: 396B0A64  addi r11, r11, 0xa64
	ctx.r[11].s64 = ctx.r[11].s64 + 2660;
	// 8219A13C: D3E300B8  stfs f31, 0xb8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219A140: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A144: D00300BC  stfs f0, 0xbc(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219A148: D3E300A0  stfs f31, 0xa0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219A14C: D3E300A4  stfs f31, 0xa4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219A150: D3E300A8  stfs f31, 0xa8(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219A154: D00300AC  stfs f0, 0xac(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219A158: 93C300C0  stw r30, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[30].u32 ) };
	// 8219A15C: D3E300C4  stfs f31, 0xc4(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A160: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219A164: B3C30088  sth r30, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[30].u16 ) };
	// 8219A168: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8219A16C: 93C30084  stw r30, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[30].u32 ) };
	// 8219A170: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A174: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219A178: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A17C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A180: 419A0008  beq cr6, 0x8219a188
	if ctx.cr[6].eq {
	pc = 0x8219A188; continue 'dispatch;
	}
	// 8219A184: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	pc = 0x8219A188; continue 'dispatch;
            }
            0x8219A188 => {
    //   block [0x8219A188..0x8219A18C)
	// 8219A188: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	pc = 0x8219A18C; continue 'dispatch;
            }
            0x8219A18C => {
    //   block [0x8219A18C..0x8219A1A8)
	// 8219A18C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A190: FC60F090  fmr f3, f30
	ctx.f[3].f64 = ctx.f[30].f64;
	// 8219A194: C04BD6C8  lfs f2, -0x2938(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A198: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A19C: C02B23F0  lfs f1, 0x23f0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9200 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A1A0: 4BFFC1F9  bl 0x82196398
	ctx.lr = 0x8219A1A4;
	sub_82196398(ctx, base);
	// 8219A1A4: 93DD00DC  stw r30, 0xdc(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(220 as u32), ctx.r[30].u32 ) };
	pc = 0x8219A1A8; continue 'dispatch;
            }
            0x8219A1A8 => {
    //   block [0x8219A1A8..0x8219A1BC)
	// 8219A1A8: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A1AC: CBA1FFC8  lfd f29, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219A1B0: CBC1FFD0  lfd f30, -0x30(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 8219A1B4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219A1B8: 4839AF54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x8219A1BC => {
    //   block [0x8219A1BC..0x8219A1C4)
	// 8219A1BC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A1C0: 4BFFFFCC  b 0x8219a18c
	pc = 0x8219A18C; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A1C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A1C8 size=132
    let mut pc: u32 = 0x8219A1C8;
    'dispatch: loop {
        match pc {
            0x8219A1C8 => {
    //   block [0x8219A1C8..0x8219A208)
	// 8219A1C8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A1CC: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A1D0: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A1D4: 2F0A0008  cmpwi cr6, r10, 8
	ctx.cr[6].compare_i32(ctx.r[10].s32, 8, &mut ctx.xer);
	// 8219A1D8: 40980030  bge cr6, 0x8219a208
	if !ctx.cr[6].lt {
	pc = 0x8219A208; continue 'dispatch;
	}
	// 8219A1DC: 812B00D0  lwz r9, 0xd0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A1E0: 3D00821A  lis r8, -0x7de6
	ctx.r[8].s64 = -2112225280;
	// 8219A1E4: 55291838  slwi r9, r9, 3
	ctx.r[9].u32 = ctx.r[9].u32.wrapping_shl(3);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 8219A1E8: 39089CF0  addi r8, r8, -0x6310
	ctx.r[8].s64 = ctx.r[8].s64 + -25360;
	// 8219A1EC: 7D495214  add r10, r9, r10
	ctx.r[10].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 8219A1F0: 394A0024  addi r10, r10, 0x24
	ctx.r[10].s64 = ctx.r[10].s64 + 36;
	// 8219A1F4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219A1F8: 7D0A592E  stwx r8, r10, r11
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32), ctx.r[8].u32) };
	// 8219A1FC: 814B00D4  lwz r10, 0xd4(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A200: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219A204: 914B00D4  stw r10, 0xd4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	pc = 0x8219A208; continue 'dispatch;
            }
            0x8219A208 => {
    //   block [0x8219A208..0x8219A24C)
	// 8219A208: 812300D4  lwz r9, 0xd4(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A20C: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A210: 4098003C  bge cr6, 0x8219a24c
	if !ctx.cr[6].lt {
		crate::recompiler::externs::call(ctx, base, 0x8219A24C);
		return;
	}
	// 8219A214: 816300D0  lwz r11, 0xd0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A218: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A21C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A220: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 8219A224: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A228: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219A22C: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A230: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A234: 7D4B192E  stwx r10, r11, r3
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[3].u32), ctx.r[10].u32) };
	// 8219A238: 816300D4  lwz r11, 0xd4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A23C: 912300DC  stw r9, 0xdc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(220 as u32), ctx.r[9].u32 ) };
	// 8219A240: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A244: 916300D4  stw r11, 0xd4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	// 8219A248: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A258 size=16
    let mut pc: u32 = 0x8219A258;
    'dispatch: loop {
        match pc {
            0x8219A258 => {
    //   block [0x8219A258..0x8219A268)
	// 8219A258: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A25C: 816BB9D8  lwz r11, -0x4628(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A260: 386B0100  addi r3, r11, 0x100
	ctx.r[3].s64 = ctx.r[11].s64 + 256;
	// 8219A264: 4BFFBC54  b 0x82195eb8
	sub_82195EB8(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A268 size=428
    let mut pc: u32 = 0x8219A268;
    'dispatch: loop {
        match pc {
            0x8219A268 => {
    //   block [0x8219A268..0x8219A29C)
	// 8219A268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A26C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A270: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A274: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A278: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A27C: 3FE082C0  lis r31, -0x7d40
	ctx.r[31].s64 = -2101346304;
	// 8219A280: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219A284: 809FB9D8  lwz r4, -0x4628(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A288: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219A28C: 409A0010  bne cr6, 0x8219a29c
	if !ctx.cr[6].eq {
	pc = 0x8219A29C; continue 'dispatch;
	}
	// 8219A290: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219A294: 4BFFF37D  bl 0x82199610
	ctx.lr = 0x8219A298;
	sub_82199610(ctx, base);
	// 8219A298: 809FB9D8  lwz r4, -0x4628(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-17960 as u32) ) } as u64;
	pc = 0x8219A29C; continue 'dispatch;
            }
            0x8219A29C => {
    //   block [0x8219A29C..0x8219A374)
	// 8219A29C: 481CCE9D  bl 0x82367138
	ctx.lr = 0x8219A2A0;
	sub_82367138(ctx, base);
	// 8219A2A0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A2A4: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219A2A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A2AC: C8010050  lfd f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A2B0: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A2B4: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A2B8: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A2BC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A2C0: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219A2C4: 481CCE75  bl 0x82367138
	ctx.lr = 0x8219A2C8;
	sub_82367138(ctx, base);
	// 8219A2C8: 78690260  clrldi r9, r3, 0x29
	ctx.r[9].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A2CC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A2D0: 810400DC  lwz r8, 0xdc(r4)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(220 as u32) ) } as u64;
	// 8219A2D4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A2D8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219A2DC: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8219A2E0: F9210050  std r9, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u64 ) };
	// 8219A2E4: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219A2E8: C18A3140  lfs f12, 0x3140(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12608 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A2EC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A2F0: D1810068  stfs f12, 0x68(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219A2F4: C1AB2038  lfs f13, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A2F8: 39610060  addi r11, r1, 0x60
	ctx.r[11].s64 = ctx.r[1].s64 + 96;
	// 8219A2FC: 90E400D8  stw r7, 0xd8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(216 as u32), ctx.r[7].u32 ) };
	// 8219A300: C18ABFFC  lfs f12, -0x4004(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A304: 394400F0  addi r10, r4, 0xf0
	ctx.r[10].s64 = ctx.r[4].s64 + 240;
	// 8219A308: D181006C  stfs f12, 0x6c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(108 as u32), tmp.u32 ) };
	// 8219A30C: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219A310: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219A314: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219A318: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A31C: C0092144  lfs f0, 0x2144(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8516 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A320: EC0C0378  fmsubs f0, f12, f13, f0
	ctx.f[0].f64 = (((ctx.f[12].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A324: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219A328: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219A32C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219A330: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219A334: F96A0008  std r11, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219A338: 409A007C  bne cr6, 0x8219a3b4
	if !ctx.cr[6].eq {
	pc = 0x8219A3B4; continue 'dispatch;
	}
	// 8219A33C: 812400D4  lwz r9, 0xd4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A340: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A344: 40980030  bge cr6, 0x8219a374
	if !ctx.cr[6].lt {
	pc = 0x8219A374; continue 'dispatch;
	}
	// 8219A348: 816400D0  lwz r11, 0xd0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A34C: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A350: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A354: 394A9CF0  addi r10, r10, -0x6310
	ctx.r[10].s64 = ctx.r[10].s64 + -25360;
	// 8219A358: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A35C: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A360: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A364: 7D4B212E  stwx r10, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 8219A368: 816400D4  lwz r11, 0xd4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A36C: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A370: 916400D4  stw r11, 0xd4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A374; continue 'dispatch;
            }
            0x8219A374 => {
    //   block [0x8219A374..0x8219A3AC)
	// 8219A374: 812400D4  lwz r9, 0xd4(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A378: 2F090008  cmpwi cr6, r9, 8
	ctx.cr[6].compare_i32(ctx.r[9].s32, 8, &mut ctx.xer);
	// 8219A37C: 40980030  bge cr6, 0x8219a3ac
	if !ctx.cr[6].lt {
	pc = 0x8219A3AC; continue 'dispatch;
	}
	// 8219A380: 816400D0  lwz r11, 0xd0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219A384: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219A388: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A38C: 394A9FB0  addi r10, r10, -0x6050
	ctx.r[10].s64 = ctx.r[10].s64 + -24656;
	// 8219A390: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219A394: 396B0024  addi r11, r11, 0x24
	ctx.r[11].s64 = ctx.r[11].s64 + 36;
	// 8219A398: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A39C: 7D4B212E  stwx r10, r11, r4
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[4].u32), ctx.r[10].u32) };
	// 8219A3A0: 816400D4  lwz r11, 0xd4(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A3A4: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219A3A8: 916400D4  stw r11, 0xd4(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A3AC; continue 'dispatch;
            }
            0x8219A3AC => {
    //   block [0x8219A3AC..0x8219A3B4)
	// 8219A3AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A3B0: 916400DC  stw r11, 0xdc(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(220 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A3B4; continue 'dispatch;
            }
            0x8219A3B4 => {
    //   block [0x8219A3B4..0x8219A3F0)
	// 8219A3B4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A3B8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219A3BC: 38EB09F0  addi r7, r11, 0x9f0
	ctx.r[7].s64 = ctx.r[11].s64 + 2544;
	// 8219A3C0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A3C4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219A3C8: 38600080  li r3, 0x80
	ctx.r[3].s64 = 128;
	// 8219A3CC: 481D00C5  bl 0x8236a490
	ctx.lr = 0x8219A3D0;
	sub_8236A490(ctx, base);
	// 8219A3D0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219A3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219A3D8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A3DC: 61299504  ori r9, r9, 0x9504
	ctx.r[9].u64 = ctx.r[9].u64 | 38148;
	// 8219A3E0: 419A0010  beq cr6, 0x8219a3f0
	if ctx.cr[6].eq {
	pc = 0x8219A3F0; continue 'dispatch;
	}
	// 8219A3E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A3E8: 396B0B38  addi r11, r11, 0xb38
	ctx.r[11].s64 = ctx.r[11].s64 + 2872;
	// 8219A3EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A3F0; continue 'dispatch;
            }
            0x8219A3F0 => {
    //   block [0x8219A3F0..0x8219A414)
	// 8219A3F0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A3F4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219A3F8: 7D4B492E  stwx r10, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 8219A3FC: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219A400: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A404: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A408: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219A40C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A410: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A418(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A418 size=668
    let mut pc: u32 = 0x8219A418;
    'dispatch: loop {
        match pc {
            0x8219A418 => {
    //   block [0x8219A418..0x8219A44C)
	// 8219A418: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A41C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219A420: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219A424: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219A428: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219A42C: 4839BBB5  bl 0x82535fe0
	ctx.lr = 0x8219A430;
	sub_82535FB0(ctx, base);
	// 8219A430: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A434: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A438: 809F0080  lwz r4, 0x80(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A43C: 89440007  lbz r10, 7(r4)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(7 as u32) ) } as u64;
	// 8219A440: 89640005  lbz r11, 5(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[4].u32.wrapping_add(5 as u32) ) } as u64;
	// 8219A444: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219A448: 409A0028  bne cr6, 0x8219a470
	if !ctx.cr[6].eq {
	pc = 0x8219A470; continue 'dispatch;
	}
	pc = 0x8219A44C; continue 'dispatch;
            }
            0x8219A44C => {
    //   block [0x8219A44C..0x8219A470)
	// 8219A44C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219A450: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219A454: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219A458: 409A023C  bne cr6, 0x8219a694
	if !ctx.cr[6].eq {
	pc = 0x8219A694; continue 'dispatch;
	}
	// 8219A45C: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219A460: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A464: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219A468: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219A46C: 48000228  b 0x8219a694
	pc = 0x8219A694; continue 'dispatch;
            }
            0x8219A470 => {
    //   block [0x8219A470..0x8219A52C)
	// 8219A470: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219A474: 4198FFD8  blt cr6, 0x8219a44c
	if ctx.cr[6].lt {
	pc = 0x8219A44C; continue 'dispatch;
	}
	// 8219A478: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8219A47C: 80C4005C  lwz r6, 0x5c(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219A480: 81640054  lwz r11, 0x54(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219A484: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	// 8219A488: 39210060  addi r9, r1, 0x60
	ctx.r[9].s64 = ctx.r[1].s64 + 96;
	// 8219A48C: 39010050  addi r8, r1, 0x50
	ctx.r[8].s64 = ctx.r[1].s64 + 80;
	// 8219A490: 38BF00B0  addi r5, r31, 0xb0
	ctx.r[5].s64 = ctx.r[31].s64 + 176;
	// 8219A494: C3471FF8  lfs f26, 0x1ff8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(8184 as u32) ) };
	ctx.f[26].f64 = (tmp.f32 as f64);
	// 8219A498: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8219A49C: C00B0020  lfs f0, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4A0: 38DF00A0  addi r6, r31, 0xa0
	ctx.r[6].s64 = ctx.r[31].s64 + 160;
	// 8219A4A4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219A4A8: C00B0024  lfs f0, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4AC: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219A4B0: E8670000  ld r3, 0(r7)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(0 as u32) ) };
	// 8219A4B4: C00B0028  lfs f0, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4B8: E8E70008  ld r7, 8(r7)
	ctx.r[7].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[7].u32.wrapping_add(8 as u32) ) };
	// 8219A4BC: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219A4C0: C12B0010  lfs f9, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219A4C4: C1AB0000  lfs f13, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A4C8: FF09D000  fcmpu cr6, f9, f26
	ctx.cr[6].compare_f64(ctx.f[9].f64, ctx.f[26].f64);
	// 8219A4CC: C18B0004  lfs f12, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A4D0: F86A0000  std r3, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 8219A4D4: C16B0008  lfs f11, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219A4D8: C14B000C  lfs f10, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219A4DC: F8EA0008  std r7, 8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[7].u64 ) };
	// 8219A4E0: C10B0014  lfs f8, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219A4E4: E9490000  ld r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) };
	// 8219A4E8: C0EB0018  lfs f7, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219A4EC: C00B001C  lfs f0, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A4F0: E9690008  ld r11, 8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) };
	// 8219A4F4: D341005C  stfs f26, 0x5c(r1)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), tmp.u32 ) };
	// 8219A4F8: EBC80000  ld r30, 0(r8)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	// 8219A4FC: E9280008  ld r9, 8(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[8].u32.wrapping_add(8 as u32) ) };
	// 8219A500: D1BF0090  stfs f13, 0x90(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219A504: F9460000  std r10, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219A508: D19F00E4  stfs f12, 0xe4(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8219A50C: D17F00D0  stfs f11, 0xd0(r31)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8219A510: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A514: D15F00D8  stfs f10, 0xd8(r31)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8219A518: F9660008  std r11, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219A51C: FBC50000  std r30, 0(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(0 as u32), ctx.r[30].u64 ) };
	// 8219A520: F9250008  std r9, 8(r5)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[5].u32.wrapping_add(8 as u32), ctx.r[9].u64 ) };
	// 8219A524: 409A0008  bne cr6, 0x8219a52c
	if !ctx.cr[6].eq {
	pc = 0x8219A52C; continue 'dispatch;
	}
	// 8219A528: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8219A52C; continue 'dispatch;
            }
            0x8219A52C => {
    //   block [0x8219A52C..0x8219A5FC)
	// 8219A52C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219A530: D11F00C0  stfs f8, 0xc0(r31)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), tmp.u32 ) };
	// 8219A534: D0FF00CC  stfs f7, 0xcc(r31)
	tmp.f32 = (ctx.f[7].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(204 as u32), tmp.u32 ) };
	// 8219A538: 915F00D4  stw r10, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[10].u32 ) };
	// 8219A53C: D01F00C4  stfs f0, 0xc4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A540: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219A544: C3ABBA38  lfs f29, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8219A548: EDA0E828  fsubs f13, f0, f29
	ctx.f[13].f64 = (((ctx.f[0].f64 - ctx.f[29].f64) as f32) as f64);
	// 8219A54C: D1BF00C8  stfs f13, 0xc8(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(200 as u32), tmp.u32 ) };
	// 8219A550: 8164005C  lwz r11, 0x5c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219A554: C06B0018  lfs f3, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A558: C04B0014  lfs f2, 0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A55C: C02B0010  lfs f1, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A560: 481CDCB9  bl 0x82368218
	ctx.lr = 0x8219A564;
	sub_82368218(ctx, base);
	// 8219A564: C0010090  lfs f0, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A568: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A56C: FF600090  fmr f27, f0
	ctx.f[27].f64 = ctx.f[0].f64;
	// 8219A570: C1AB2150  lfs f13, 0x2150(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8528 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A574: FD80DA10  fabs f12, f27
	ctx.f[12].u64 = ctx.f[27].u64 & !0x8000_0000_0000_0000u64;
	// 8219A578: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8219A57C: 40990080  ble cr6, 0x8219a5fc
	if !ctx.cr[6].gt {
	pc = 0x8219A5FC; continue 'dispatch;
	}
	// 8219A580: EC000032  fmuls f0, f0, f0
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219A584: C3E10098  lfs f31, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A588: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A58C: EC1F07FA  fmadds f0, f31, f31, f0
	ctx.f[0].f64 = (((ctx.f[31].f64 * ctx.f[31].f64 + ctx.f[0].f64) as f32) as f64);
	// 8219A590: EC40002C  fsqrts f2, f0
	ctx.f[2].f64 = ((ctx.f[0].f64).sqrt() as f32) as f64;
	// 8219A594: 48398915  bl 0x82532ea8
	ctx.lr = 0x8219A598;
	sub_82532EA8(ctx, base);
	// 8219A598: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A59C: FC000818  frsp f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A5A0: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A5A4: C38B2254  lfs f28, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8219A5A8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A5AC: C3CBBFFC  lfs f30, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A5B0: EC20F73A  fmadds f1, f0, f28, f30
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[28].f64 + ctx.f[30].f64) as f32) as f64);
	// 8219A5B4: 481CD58D  bl 0x82367b40
	ctx.lr = 0x8219A5B8;
	sub_82367B40(ctx, base);
	// 8219A5B8: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8219A5BC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219A5C0: FC40D890  fmr f2, f27
	ctx.f[2].f64 = ctx.f[27].f64;
	// 8219A5C4: EFE0F028  fsubs f31, f0, f30
	ctx.f[31].f64 = (((ctx.f[0].f64 - ctx.f[30].f64) as f32) as f64);
	// 8219A5C8: 483988E1  bl 0x82532ea8
	ctx.lr = 0x8219A5CC;
	sub_82532EA8(ctx, base);
	// 8219A5CC: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A5D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A5D4: FD80FA10  fabs f12, f31
	ctx.f[12].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 8219A5D8: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A5DC: EC2D0738  fmsubs f1, f13, f28, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[28].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219A5E0: FF0C0000  fcmpu cr6, f12, f0
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[0].f64);
	// 8219A5E4: 40990094  ble cr6, 0x8219a678
	if !ctx.cr[6].gt {
	pc = 0x8219A678; continue 'dispatch;
	}
	// 8219A5E8: EFFEF828  fsubs f31, f30, f31
	ctx.f[31].f64 = (((ctx.f[30].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219A5EC: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A5F0: EC21F02A  fadds f1, f1, f30
	ctx.f[1].f64 = ((ctx.f[1].f64 + ctx.f[30].f64) as f32) as f64;
	// 8219A5F4: 481CD54D  bl 0x82367b40
	ctx.lr = 0x8219A5F8;
	sub_82367B40(ctx, base);
	// 8219A5F8: 48000080  b 0x8219a678
	pc = 0x8219A678; continue 'dispatch;
            }
            0x8219A5FC => {
    //   block [0x8219A5FC..0x8219A654)
	// 8219A5FC: C3C10098  lfs f30, 0x98(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A600: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219A604: FC001210  fabs f0, f2
	ctx.f[0].u64 = ctx.f[2].u64 & !0x8000_0000_0000_0000u64;
	// 8219A608: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219A60C: 40990050  ble cr6, 0x8219a65c
	if !ctx.cr[6].gt {
	pc = 0x8219A65C; continue 'dispatch;
	}
	// 8219A610: C0210094  lfs f1, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A614: 48398895  bl 0x82532ea8
	ctx.lr = 0x8219A618;
	sub_82532EA8(ctx, base);
	// 8219A618: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A61C: FDA00818  frsp f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[13].f64 = (ctx.f[1].f64 as f32) as f64;
	// 8219A620: FC40E890  fmr f2, f29
	ctx.f[2].f64 = ctx.f[29].f64;
	// 8219A624: C00B2254  lfs f0, 0x2254(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8788 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A628: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A62C: C18BBFFC  lfs f12, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A630: EC2D603A  fmadds f1, f13, f0, f12
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219A634: 481CD50D  bl 0x82367b40
	ctx.lr = 0x8219A638;
	sub_82367B40(ctx, base);
	// 8219A638: EFE16028  fsubs f31, f1, f12
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].f64 = (((ctx.f[1].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219A63C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A640: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A644: FDA0FA10  fabs f13, f31
	ctx.f[13].u64 = ctx.f[31].u64 & !0x8000_0000_0000_0000u64;
	// 8219A648: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219A64C: 40990008  ble cr6, 0x8219a654
	if !ctx.cr[6].gt {
	pc = 0x8219A654; continue 'dispatch;
	}
	// 8219A650: EFECF828  fsubs f31, f12, f31
	ctx.f[31].f64 = (((ctx.f[12].f64 - ctx.f[31].f64) as f32) as f64);
	pc = 0x8219A654; continue 'dispatch;
            }
            0x8219A654 => {
    //   block [0x8219A654..0x8219A65C)
	// 8219A654: FC3E66AE  fsel f1, f30, f26, f12
	ctx.f[1].f64 = if ctx.f[30].f64 >= 0.0 { ctx.f[26].f64 } else { ctx.f[12].f64 };
	// 8219A658: 48000020  b 0x8219a678
	pc = 0x8219A678; continue 'dispatch;
            }
            0x8219A65C => {
    //   block [0x8219A65C..0x8219A678)
	// 8219A65C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A660: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A664: FC20D090  fmr f1, f26
	ctx.f[1].f64 = ctx.f[26].f64;
	// 8219A668: C00B2038  lfs f0, 0x2038(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8248 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A66C: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219A670: C1ABD428  lfs f13, -0x2bd8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11224 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A674: FFEC682E  fsel f31, f12, f0, f13
	ctx.f[31].f64 = if ctx.f[12].f64 >= 0.0 { ctx.f[0].f64 } else { ctx.f[13].f64 };
	pc = 0x8219A678; continue 'dispatch;
            }
            0x8219A678 => {
    //   block [0x8219A678..0x8219A694)
	// 8219A678: 396000B4  li r11, 0xb4
	ctx.r[11].s64 = 180;
	// 8219A67C: D3FF00DC  stfs f31, 0xdc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), tmp.u32 ) };
	// 8219A680: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219A684: D03F00E0  stfs f1, 0xe0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8219A688: D35F0094  stfs f26, 0x94(r31)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A68C: 917F008C  stw r11, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 8219A690: 915F0088  stw r10, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	pc = 0x8219A694; continue 'dispatch;
            }
            0x8219A694 => {
    //   block [0x8219A694..0x8219A6B4)
	// 8219A694: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219A698: 3981FFE8  addi r12, r1, -0x18
	ctx.r[12].s64 = ctx.r[1].s64 + -24;
	// 8219A69C: 4839B991  bl 0x8253602c
	ctx.lr = 0x8219A6A0;
	sub_82535FFC(ctx, base);
	// 8219A6A0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219A6A4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219A6A8: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219A6AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219A6B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A6B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219A6B8 size=464
    let mut pc: u32 = 0x8219A6B8;
    'dispatch: loop {
        match pc {
            0x8219A6B8 => {
    //   block [0x8219A6B8..0x8219A72C)
	// 8219A6B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219A6BC: 4839A9E5  bl 0x825350a0
	ctx.lr = 0x8219A6C0;
	sub_82535080(ctx, base);
	// 8219A6C0: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219A6C4: 4839B925  bl 0x82535fe8
	ctx.lr = 0x8219A6C8;
	sub_82535FB0(ctx, base);
	// 8219A6C8: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219A6CC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219A6D0: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219A6D4: 3ACBBFF0  addi r22, r11, -0x4010
	ctx.r[22].s64 = ctx.r[11].s64 + -16400;
	// 8219A6D8: 89760000  lbz r11, 0(r22)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[22].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219A6DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A6E0: 409A0198  bne cr6, 0x8219a878
	if !ctx.cr[6].eq {
	pc = 0x8219A878; continue 'dispatch;
	}
	// 8219A6E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A6E8: 3CE0820A  lis r7, -0x7df6
	ctx.r[7].s64 = -2113273856;
	// 8219A6EC: 3B4B0AF4  addi r26, r11, 0xaf4
	ctx.r[26].s64 = ctx.r[11].s64 + 2804;
	// 8219A6F0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219A6F4: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219A6F8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219A6FC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219A700: C3C7BA38  lfs f30, -0x45c8(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219A704: 3F8082C0  lis r28, -0x7d40
	ctx.r[28].s64 = -2101346304;
	// 8219A708: 3B0B09E4  addi r24, r11, 0x9e4
	ctx.r[24].s64 = ctx.r[11].s64 + 2532;
	// 8219A70C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219A710: C3A82054  lfs f29, 0x2054(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8276 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 8219A714: C3892280  lfs f28, 0x2280(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8832 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 8219A718: 3B600000  li r27, 0
	ctx.r[27].s64 = 0;
	// 8219A71C: C3EA1FF8  lfs f31, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219A720: 3AE00001  li r23, 1
	ctx.r[23].s64 = 1;
	// 8219A724: 83BCB9D8  lwz r29, -0x4628(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219A728: 61797A9E  ori r25, r11, 0x7a9e
	ctx.r[25].u64 = ctx.r[11].u64 | 31390;
	pc = 0x8219A72C; continue 'dispatch;
            }
            0x8219A72C => {
    //   block [0x8219A72C..0x8219A750)
	// 8219A72C: C01E0094  lfs f0, 0x94(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(148 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A730: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219A734: 4099001C  ble cr6, 0x8219a750
	if !ctx.cr[6].gt {
	pc = 0x8219A750; continue 'dispatch;
	}
	// 8219A738: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219A73C: 616B85E0  ori r11, r11, 0x85e0
	ctx.r[11].u64 = ctx.r[11].u64 | 34272;
	// 8219A740: 7DB65C2E  lfsx f13, r22, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[22].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A744: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219A748: D01E0094  stfs f0, 0x94(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A74C: 48000104  b 0x8219a850
	pc = 0x8219A850; continue 'dispatch;
            }
            0x8219A750 => {
    //   block [0x8219A750..0x8219A7F8)
	// 8219A750: 481CC9E9  bl 0x82367138
	ctx.lr = 0x8219A754;
	sub_82367138(ctx, base);
	// 8219A754: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219A758: C1BE00E4  lfs f13, 0xe4(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(228 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219A75C: 2B1D0000  cmplwi cr6, r29, 0
	ctx.cr[6].compare_u32(ctx.r[29].u32, 0 as u32, &mut ctx.xer);
	// 8219A760: C19E0090  lfs f12, 0x90(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219A764: F9610080  std r11, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8219A768: C8010080  lfd f0, 0x80(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8219A76C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219A770: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219A774: EC000732  fmuls f0, f0, f28
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[28].f64) as f32) as f64);
	// 8219A778: EC0D603A  fmadds f0, f13, f0, f12
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219A77C: D01E0094  stfs f0, 0x94(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219A780: 419A00D0  beq cr6, 0x8219a850
	if ctx.cr[6].eq {
	pc = 0x8219A850; continue 'dispatch;
	}
	// 8219A784: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219A788: 7F07C378  mr r7, r24
	ctx.r[7].u64 = ctx.r[24].u64;
	// 8219A78C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219A790: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219A794: 38600240  li r3, 0x240
	ctx.r[3].s64 = 576;
	// 8219A798: 481CFCF9  bl 0x8236a490
	ctx.lr = 0x8219A79C;
	sub_8236A490(ctx, base);
	// 8219A79C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219A7A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219A7A4: 419A00A8  beq cr6, 0x8219a84c
	if ctx.cr[6].eq {
	pc = 0x8219A84C; continue 'dispatch;
	}
	// 8219A7A8: D3FF00B0  stfs f31, 0xb0(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219A7AC: D3FF00B4  stfs f31, 0xb4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219A7B0: D3FF00B8  stfs f31, 0xb8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219A7B4: D3DF00BC  stfs f30, 0xbc(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219A7B8: D3FF00A0  stfs f31, 0xa0(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219A7BC: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219A7C0: D3FF00A8  stfs f31, 0xa8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219A7C4: D3DF00AC  stfs f30, 0xac(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219A7C8: 937F00C0  stw r27, 0xc0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(192 as u32), ctx.r[27].u32 ) };
	// 8219A7CC: D3FF00C4  stfs f31, 0xc4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219A7D0: 935F0000  stw r26, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[26].u32 ) };
	// 8219A7D4: B2FF0088  sth r23, 0x88(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[23].u16 ) };
	// 8219A7D8: 93BF0090  stw r29, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[29].u32 ) };
	// 8219A7DC: 937F0084  stw r27, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[27].u32 ) };
	// 8219A7E0: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A7E4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219A7E8: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219A7EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A7F0: 419A0008  beq cr6, 0x8219a7f8
	if ctx.cr[6].eq {
	pc = 0x8219A7F8; continue 'dispatch;
	}
	// 8219A7F4: 93EB0084  stw r31, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[31].u32 ) };
	pc = 0x8219A7F8; continue 'dispatch;
            }
            0x8219A7F8 => {
    //   block [0x8219A7F8..0x8219A84C)
	// 8219A7F8: 397E00A0  addi r11, r30, 0xa0
	ctx.r[11].s64 = ctx.r[30].s64 + 160;
	// 8219A7FC: 93FD0080  stw r31, 0x80(r29)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8219A800: C15E00E0  lfs f10, 0xe0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(224 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219A804: 38DE00B0  addi r6, r30, 0xb0
	ctx.r[6].s64 = ctx.r[30].s64 + 176;
	// 8219A808: C13E00DC  lfs f9, 0xdc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(220 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219A80C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219A810: C01E00D8  lfs f0, 0xd8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(216 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A814: 809E00D4  lwz r4, 0xd4(r30)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219A818: C0BE00CC  lfs f5, 0xcc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(204 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8219A81C: ED000772  fmuls f8, f0, f29
	ctx.f[8].f64 = (((ctx.f[0].f64 * ctx.f[29].f64) as f32) as f64);
	// 8219A820: C09E00C8  lfs f4, 0xc8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219A824: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219A828: C07E00C4  lfs f3, 0xc4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(196 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219A82C: FCE05090  fmr f7, f10
	ctx.f[7].f64 = ctx.f[10].f64;
	// 8219A830: C05E00C0  lfs f2, 0xc0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219A834: FCC04890  fmr f6, f9
	ctx.f[6].f64 = ctx.f[9].f64;
	// 8219A838: C03E00D0  lfs f1, 0xd0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A83C: 4BFFE6D5  bl 0x82198f10
	ctx.lr = 0x8219A840;
	sub_82198F10(ctx, base);
	// 8219A840: 933F003C  stw r25, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[25].u32 ) };
	// 8219A844: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A848: 917F01A8  stw r11, 0x1a8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(424 as u32), ctx.r[11].u32 ) };
	pc = 0x8219A84C; continue 'dispatch;
            }
            0x8219A84C => {
    //   block [0x8219A84C..0x8219A850)
	// 8219A84C: 83BCB9D8  lwz r29, -0x4628(r28)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(-17960 as u32) ) } as u64;
	pc = 0x8219A850; continue 'dispatch;
            }
            0x8219A850 => {
    //   block [0x8219A850..0x8219A870)
	// 8219A850: 817E0088  lwz r11, 0x88(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219A854: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A858: 40990018  ble cr6, 0x8219a870
	if !ctx.cr[6].gt {
	pc = 0x8219A870; continue 'dispatch;
	}
	// 8219A85C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219A860: 394BFFFF  addi r10, r11, -1
	ctx.r[10].s64 = ctx.r[11].s64 + -1;
	// 8219A864: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A868: 915E008C  stw r10, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219A86C: 409AFEC0  bne cr6, 0x8219a72c
	if !ctx.cr[6].eq {
	pc = 0x8219A72C; continue 'dispatch;
	}
	pc = 0x8219A870; continue 'dispatch;
            }
            0x8219A870 => {
    //   block [0x8219A870..0x8219A878)
	// 8219A870: 937E0088  stw r27, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[27].u32 ) };
	// 8219A874: 937E008C  stw r27, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[27].u32 ) };
	pc = 0x8219A878; continue 'dispatch;
            }
            0x8219A878 => {
    //   block [0x8219A878..0x8219A888)
	// 8219A878: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219A87C: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219A880: 4839B7B5  bl 0x82536034
	ctx.lr = 0x8219A884;
	sub_82535FFC(ctx, base);
	// 8219A884: 4839A86C  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A888(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219A888 size=84
    let mut pc: u32 = 0x8219A888;
    'dispatch: loop {
        match pc {
            0x8219A888 => {
    //   block [0x8219A888..0x8219A8B4)
	// 8219A888: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219A88C: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 8219A890: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 8219A894: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 8219A898: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219A89C: 40990018  ble cr6, 0x8219a8b4
	if !ctx.cr[6].gt {
	pc = 0x8219A8B4; continue 'dispatch;
	}
	// 8219A8A0: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219A8A4: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219A8A8: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219A8AC: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219A8B0: 41990008  bgt cr6, 0x8219a8b8
	if ctx.cr[6].gt {
	pc = 0x8219A8B8; continue 'dispatch;
	}
	pc = 0x8219A8B4; continue 'dispatch;
            }
            0x8219A8B4 => {
    //   block [0x8219A8B4..0x8219A8B8)
	// 8219A8B4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219A8B8; continue 'dispatch;
            }
            0x8219A8B8 => {
    //   block [0x8219A8B8..0x8219A8DC)
	// 8219A8B8: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219A8BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219A8C0: 419A001C  beq cr6, 0x8219a8dc
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x8219A8DC);
		return;
	}
	// 8219A8C4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219A8C8: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219A8CC: 396B1090  addi r11, r11, 0x1090
	ctx.r[11].s64 = ctx.r[11].s64 + 4240;
	// 8219A8D0: 396B00C8  addi r11, r11, 0xc8
	ctx.r[11].s64 = ctx.r[11].s64 + 200;
	// 8219A8D4: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219A8D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219A8E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219A8E8 size=496
    let mut pc: u32 = 0x8219A8E8;
    'dispatch: loop {
        match pc {
            0x8219A8E8 => {
    //   block [0x8219A8E8..0x8219A9C0)
	// 8219A8E8: 3963FFFC  addi r11, r3, -4
	ctx.r[11].s64 = ctx.r[3].s64 + -4;
	// 8219A8EC: 2B0B002C  cmplwi cr6, r11, 0x2c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 44 as u32, &mut ctx.xer);
	// 8219A8F0: 419901C0  bgt cr6, 0x8219aab0
	if ctx.cr[6].gt {
	pc = 0x8219AAB0; continue 'dispatch;
	}
	// 8219A8F4: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219A8F8: 398CA90C  addi r12, r12, -0x56f4
	ctx.r[12].s64 = ctx.r[12].s64 + -22260;
	// 8219A8FC: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219A900: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219A904: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219A908: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8219A9C0; continue 'dispatch;
		},
		1 => {
	pc = 0x8219A9C0; continue 'dispatch;
		},
		2 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		3 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		4 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		5 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		6 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		7 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		8 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		9 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		10 => {
	pc = 0x8219A9E8; continue 'dispatch;
		},
		11 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		12 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		13 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		14 => {
	pc = 0x8219AA38; continue 'dispatch;
		},
		15 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		16 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		17 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		18 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		19 => {
	pc = 0x8219A9E8; continue 'dispatch;
		},
		20 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		21 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		22 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		23 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		24 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		25 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		26 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		27 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		28 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		29 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		30 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		31 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		32 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		33 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		34 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		35 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		36 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		37 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		38 => {
	pc = 0x8219AA60; continue 'dispatch;
		},
		39 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		40 => {
	pc = 0x8219AA88; continue 'dispatch;
		},
		41 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		42 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		43 => {
	pc = 0x8219AAB0; continue 'dispatch;
		},
		44 => {
	pc = 0x8219AA10; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219A90C: 8219A9C0  lwz r16, -0x5640(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22080 as u32) ) } as u64;
	// 8219A910: 8219A9C0  lwz r16, -0x5640(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22080 as u32) ) } as u64;
	// 8219A914: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A918: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A91C: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A920: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A924: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A928: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A92C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A930: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A934: 8219A9E8  lwz r16, -0x5618(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22040 as u32) ) } as u64;
	// 8219A938: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A93C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A940: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A944: 8219AA38  lwz r16, -0x55c8(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21960 as u32) ) } as u64;
	// 8219A948: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A94C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A950: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A954: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A958: 8219A9E8  lwz r16, -0x5618(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22040 as u32) ) } as u64;
	// 8219A95C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A960: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A964: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A968: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A96C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A970: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A974: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A978: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A97C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A980: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A984: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A988: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
	// 8219A98C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A990: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A994: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A998: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A99C: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9A0: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9A4: 8219AA60  lwz r16, -0x55a0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21920 as u32) ) } as u64;
	// 8219A9A8: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9AC: 8219AA88  lwz r16, -0x5578(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21880 as u32) ) } as u64;
	// 8219A9B0: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9B4: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9B8: 8219AAB0  lwz r16, -0x5550(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-21840 as u32) ) } as u64;
	// 8219A9BC: 8219AA10  lwz r16, -0x55f0(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-22000 as u32) ) } as u64;
            }
            0x8219A9C0 => {
    //   block [0x8219A9C0..0x8219A9E8)
	// 8219A9C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9C4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219A9C8: C00B21C0  lfs f0, 0x21c0(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8640 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9D0: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219A9D4: C00B21BC  lfs f0, 0x21bc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8636 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9D8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219A9DC: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219A9E0: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219A9E4: 4E800020  blr
	return;
            }
            0x8219A9E8 => {
    //   block [0x8219A9E8..0x8219AA10)
	// 8219A9E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9EC: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219A9F0: C00B21B8  lfs f0, 0x21b8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8632 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219A9F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219A9F8: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219A9FC: C00B21B4  lfs f0, 0x21b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA00: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA04: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA08: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA0C: 4E800020  blr
	return;
            }
            0x8219AA10 => {
    //   block [0x8219AA10..0x8219AA38)
	// 8219AA10: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA14: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA18: C00B21B4  lfs f0, 0x21b4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8628 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA1C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA20: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA24: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA28: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA2C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA30: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA34: 4E800020  blr
	return;
            }
            0x8219AA38 => {
    //   block [0x8219AA38..0x8219AA60)
	// 8219AA38: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA3C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA40: C00B2098  lfs f0, 0x2098(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8344 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA44: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA48: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA4C: C00B21B0  lfs f0, 0x21b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8624 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA50: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA54: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA58: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA5C: 4E800020  blr
	return;
            }
            0x8219AA60 => {
    //   block [0x8219AA60..0x8219AA88)
	// 8219AA60: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA64: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA68: C00B21AC  lfs f0, 0x21ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA70: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA74: C00B21A8  lfs f0, 0x21a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA78: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AA7C: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AA80: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AA84: 4E800020  blr
	return;
            }
            0x8219AA88 => {
    //   block [0x8219AA88..0x8219AAB0)
	// 8219AA88: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA8C: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AA90: C00B21A8  lfs f0, 0x21a8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8616 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AA94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AA98: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AA9C: C00B21A4  lfs f0, 0x21a4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8612 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AAA0: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AAA4: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AAA8: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AAAC: 4E800020  blr
	return;
            }
            0x8219AAB0 => {
    //   block [0x8219AAB0..0x8219AAD8)
	// 8219AAB0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AAB4: 3941FFF0  addi r10, r1, -0x10
	ctx.r[10].s64 = ctx.r[1].s64 + -16;
	// 8219AAB8: C00B21A0  lfs f0, 0x21a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8608 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AABC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AAC0: D001FFF0  stfs f0, -0x10(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), tmp.u32 ) };
	// 8219AAC4: C00B21AC  lfs f0, 0x21ac(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8620 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AAC8: 548B103A  slwi r11, r4, 2
	ctx.r[11].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AACC: D001FFF4  stfs f0, -0xc(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-12 as u32), tmp.u32 ) };
	// 8219AAD0: 7C2B542E  lfsx f1, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AAD4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AAD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AAD8 size=364
    let mut pc: u32 = 0x8219AAD8;
    'dispatch: loop {
        match pc {
            0x8219AAD8 => {
    //   block [0x8219AAD8..0x8219AC44)
	// 8219AAD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AADC: 4839A5AD  bl 0x82535088
	ctx.lr = 0x8219AAE0;
	sub_82535080(ctx, base);
	// 8219AAE0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AAE4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219AAE8: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219AAEC: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219AAF0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219AAF4: 38E00008  li r7, 8
	ctx.r[7].s64 = 8;
	// 8219AAF8: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 8219AAFC: 3AA0000F  li r21, 0xf
	ctx.r[21].s64 = 15;
	// 8219AB00: 7FDD50AE  lbzx r30, r29, r10
	ctx.r[30].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AB04: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219AB08: C00BBA38  lfs f0, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AB0C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AB10: 57C3183E  rotlwi r3, r30, 3
	ctx.r[3].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB14: 3BEB1090  addi r31, r11, 0x1090
	ctx.r[31].s64 = ctx.r[11].s64 + 4240;
	// 8219AB18: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219AB1C: 393F0090  addi r9, r31, 0x90
	ctx.r[9].s64 = ctx.r[31].s64 + 144;
	// 8219AB20: 61668414  ori r6, r11, 0x8414
	ctx.r[6].u64 = ctx.r[11].u64 | 33812;
	// 8219AB24: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219AB28: 391F00B0  addi r8, r31, 0xb0
	ctx.r[8].s64 = ctx.r[31].s64 + 176;
	// 8219AB2C: 61658410  ori r5, r11, 0x8410
	ctx.r[5].u64 = ctx.r[11].u64 | 33808;
	// 8219AB30: 57CB183E  rotlwi r11, r30, 3
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB34: 7D43492E  stwx r10, r3, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[9].u32), ctx.r[10].u32) };
	// 8219AB38: 57D3103E  rotlwi r19, r30, 2
	ctx.r[19].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB3C: 7D6BFA14  add r11, r11, r31
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[31].u64;
	// 8219AB40: 3B1F00B8  addi r24, r31, 0xb8
	ctx.r[24].s64 = ctx.r[31].s64 + 184;
	// 8219AB44: 57D2183E  rotlwi r18, r30, 3
	ctx.r[18].u64 = ((ctx.r[30].u32).rotate_left(3)) as u64;
	// 8219AB48: 3B3F00C8  addi r25, r31, 0xc8
	ctx.r[25].s64 = ctx.r[31].s64 + 200;
	// 8219AB4C: 3AFF0104  addi r23, r31, 0x104
	ctx.r[23].s64 = ctx.r[31].s64 + 260;
	// 8219AB50: 914B0094  stw r10, 0x94(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(148 as u32), ctx.r[10].u32 ) };
	// 8219AB54: 3ADF00D0  addi r22, r31, 0xd0
	ctx.r[22].s64 = ctx.r[31].s64 + 208;
	// 8219AB58: 3A9F00D8  addi r20, r31, 0xd8
	ctx.r[20].s64 = ctx.r[31].s64 + 216;
	// 8219AB5C: 7CF3412E  stwx r7, r19, r8
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[19].u32.wrapping_add(ctx.r[8].u32), ctx.r[7].u32) };
	// 8219AB60: 57DA103E  rotlwi r26, r30, 2
	ctx.r[26].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB64: 7DBD342E  lfsx f13, r29, r6
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[6].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AB68: 57D1103E  rotlwi r17, r30, 2
	ctx.r[17].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB6C: D1AB00BC  stfs f13, 0xbc(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219AB70: 57D0103E  rotlwi r16, r30, 2
	ctx.r[16].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB74: 7DBD2C2E  lfsx f13, r29, r5
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[5].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AB78: 57C9103E  rotlwi r9, r30, 2
	ctx.r[9].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AB7C: 7DB2C52E  stfsx f13, r18, r24
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[18].u32.wrapping_add(ctx.r[24].u32), tmp.u32) };
	// 8219AB80: 3B7D0030  addi r27, r29, 0x30
	ctx.r[27].s64 = ctx.r[29].s64 + 48;
	// 8219AB84: 7F9AC92E  stwx r28, r26, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), ctx.r[28].u32) };
	// 8219AB88: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219AB8C: 7C11BD2E  stfsx f0, r17, r23
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[17].u32.wrapping_add(ctx.r[23].u32), tmp.u32) };
	// 8219AB90: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AB94: 7EB0B12E  stwx r21, r16, r22
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[16].u32.wrapping_add(ctx.r[22].u32), ctx.r[21].u32) };
	// 8219AB98: 7F89A12E  stwx r28, r9, r20
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[20].u32), ctx.r[28].u32) };
	// 8219AB9C: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ABA0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ABA4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ABA8: 4E800421  bctrl
	ctx.lr = 0x8219ABAC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ABAC: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ABB0: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219ABB4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219ABB8: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABBC: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219ABC0: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABC4: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219ABC8: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABCC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219ABD0: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ABD4: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ABD8: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ABDC: 4E800421  bctrl
	ctx.lr = 0x8219ABE0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ABE0: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABE4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219ABE8: D01F0010  stfs f0, 0x10(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219ABEC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ABF0: 395F00E0  addi r10, r31, 0xe0
	ctx.r[10].s64 = ctx.r[31].s64 + 224;
	// 8219ABF4: D01F0014  stfs f0, 0x14(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219ABF8: 393F00E4  addi r9, r31, 0xe4
	ctx.r[9].s64 = ctx.r[31].s64 + 228;
	// 8219ABFC: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC00: 57C8103E  rotlwi r8, r30, 2
	ctx.r[8].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC04: D01F0018  stfs f0, 0x18(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219AC08: 7F9AC92E  stwx r28, r26, r25
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[26].u32.wrapping_add(ctx.r[25].u32), ctx.r[28].u32) };
	// 8219AC0C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC10: 57CB103E  rotlwi r11, r30, 2
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC14: 7F9E51AE  stbx r28, r30, r10
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[30].u32.wrapping_add(ctx.r[10].u32), ctx.r[28].u8) };
	// 8219AC18: 38FF00EC  addi r7, r31, 0xec
	ctx.r[7].s64 = ctx.r[31].s64 + 236;
	// 8219AC1C: 57CA103E  rotlwi r10, r30, 2
	ctx.r[10].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC20: 38DF00F4  addi r6, r31, 0xf4
	ctx.r[6].s64 = ctx.r[31].s64 + 244;
	// 8219AC24: 7C0B4D2E  stfsx f0, r11, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 8219AC28: 57CB103E  rotlwi r11, r30, 2
	ctx.r[11].u64 = ((ctx.r[30].u32).rotate_left(2)) as u64;
	// 8219AC2C: 7F88392E  stwx r28, r8, r7
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32), ctx.r[28].u32) };
	// 8219AC30: 393F00FC  addi r9, r31, 0xfc
	ctx.r[9].s64 = ctx.r[31].s64 + 252;
	// 8219AC34: 7F8A312E  stwx r28, r10, r6
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[6].u32), ctx.r[28].u32) };
	// 8219AC38: 7F8B492E  stwx r28, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[28].u32) };
	// 8219AC3C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 8219AC40: 4839A498  b 0x825350d8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AC48(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AC48 size=396
    let mut pc: u32 = 0x8219AC48;
    'dispatch: loop {
        match pc {
            0x8219AC48 => {
    //   block [0x8219AC48..0x8219ADD4)
	// 8219AC48: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AC4C: 4839A465  bl 0x825350b0
	ctx.lr = 0x8219AC50;
	sub_82535080(ctx, base);
	// 8219AC50: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219AC54: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AC58: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219AC5C: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AC60: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219AC64: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AC68: 3B9F0030  addi r28, r31, 0x30
	ctx.r[28].s64 = ctx.r[31].s64 + 48;
	// 8219AC6C: 3BAB1090  addi r29, r11, 0x1090
	ctx.r[29].s64 = ctx.r[11].s64 + 4240;
	// 8219AC70: 813F0030  lwz r9, 0x30(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219AC74: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219AC78: 7F7F50AE  lbzx r27, r31, r10
	ctx.r[27].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AC7C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219AC80: 576B183E  rotlwi r11, r27, 3
	ctx.r[11].u64 = ((ctx.r[27].u32).rotate_left(3)) as u64;
	// 8219AC84: 7FCBEA14  add r30, r11, r29
	ctx.r[30].u64 = ctx.r[11].u64 + ctx.r[29].u64;
	// 8219AC88: 81490008  lwz r10, 8(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AC8C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219AC90: C1BE00BC  lfs f13, 0xbc(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(188 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AC94: C00BD210  lfs f0, -0x2df0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11760 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AC98: EFED0032  fmuls f31, f13, f0
	ctx.f[31].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219AC9C: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219ACA0: 4E800421  bctrl
	ctx.lr = 0x8219ACA4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ACA4: 3F5F0002  addis r26, r31, 2
	ctx.r[26].s64 = ctx.r[31].s64 + 131072;
	// 8219ACA8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ACAC: 3B5A9B84  addi r26, r26, -0x647c
	ctx.r[26].s64 = ctx.r[26].s64 + -25724;
	// 8219ACB0: 576A183E  rotlwi r10, r27, 3
	ctx.r[10].u64 = ((ctx.r[27].u32).rotate_left(3)) as u64;
	// 8219ACB4: 393D0080  addi r9, r29, 0x80
	ctx.r[9].s64 = ctx.r[29].s64 + 128;
	// 8219ACB8: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219ACBC: C00B0034  lfs f0, 0x34(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ACC0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219ACC4: C1BA0000  lfs f13, 0(r26)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219ACC8: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 8219ACCC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219ACD0: 7C0A4D2E  stfsx f0, r10, r9
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32), tmp.u32) };
	// 8219ACD4: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219ACD8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219ACDC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219ACE0: 4E800421  bctrl
	ctx.lr = 0x8219ACE4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219ACE4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219ACE8: C01A0000  lfs f0, 0(r26)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219ACEC: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219ACF0: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219ACF4: C1AB0034  lfs f13, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219ACF8: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219ACFC: EC00F828  fsubs f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219AD00: D01E0084  stfs f0, 0x84(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219AD04: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219AD08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219AD0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219AD10: 4E800421  bctrl
	ctx.lr = 0x8219AD14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219AD14: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219AD18: 576A283E  rotlwi r10, r27, 5
	ctx.r[10].u64 = ((ctx.r[27].u32).rotate_left(5)) as u64;
	// 8219AD1C: 5769283E  rotlwi r9, r27, 5
	ctx.r[9].u64 = ((ctx.r[27].u32).rotate_left(5)) as u64;
	// 8219AD20: 7FCAEA14  add r30, r10, r29
	ctx.r[30].u64 = ctx.r[10].u64 + ctx.r[29].u64;
	// 8219AD24: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8219AD28: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD2C: 391D0040  addi r8, r29, 0x40
	ctx.r[8].s64 = ctx.r[29].s64 + 64;
	// 8219AD30: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219AD34: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219AD38: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD3C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219AD40: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219AD44: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AD48: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219AD4C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219ADD8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219ADD8 size=204
    let mut pc: u32 = 0x8219ADD8;
    'dispatch: loop {
        match pc {
            0x8219ADD8 => {
    //   block [0x8219ADD8..0x8219AE50)
	// 8219ADD8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219ADDC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219ADE0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219ADE4: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219ADE8: 7C8B2378  mr r11, r4
	ctx.r[11].u64 = ctx.r[4].u64;
	// 8219ADEC: 6148BE64  ori r8, r10, 0xbe64
	ctx.r[8].u64 = ctx.r[10].u64 | 48740;
	// 8219ADF0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219ADF4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219ADF8: 6146BEBA  ori r6, r10, 0xbeba
	ctx.r[6].u64 = ctx.r[10].u64 | 48826;
	// 8219ADFC: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AE00: 7D0B40AE  lbzx r8, r11, r8
	ctx.r[8].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8219AE04: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219AE08: 392A1090  addi r9, r10, 0x1090
	ctx.r[9].s64 = ctx.r[10].s64 + 4240;
	// 8219AE0C: 7C6B322E  lhzx r3, r11, r6
	ctx.r[3].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 8219AE10: 550B083E  rotlwi r11, r8, 1
	ctx.r[11].u64 = ((ctx.r[8].u32).rotate_left(1)) as u64;
	// 8219AE14: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 8219AE18: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE1C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE20: 7DAB542E  lfsx f13, r11, r10
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219AE24: 4BFFFAC5  bl 0x8219a8e8
	ctx.lr = 0x8219AE28;
	sub_8219A8E8(ctx, base);
	// 8219AE28: FF0D0800  fcmpu cr6, f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 8219AE2C: 4099002C  ble cr6, 0x8219ae58
	if !ctx.cr[6].gt {
	pc = 0x8219AE58; continue 'dispatch;
	}
	// 8219AE30: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE34: 39490090  addi r10, r9, 0x90
	ctx.r[10].s64 = ctx.r[9].s64 + 144;
	// 8219AE38: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE3C: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE40: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AE44: 2F090001  cmpwi cr6, r9, 1
	ctx.cr[6].compare_i32(ctx.r[9].s32, 1, &mut ctx.xer);
	// 8219AE48: 409A0008  bne cr6, 0x8219ae50
	if !ctx.cr[6].eq {
	pc = 0x8219AE50; continue 'dispatch;
	}
	// 8219AE4C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	pc = 0x8219AE50; continue 'dispatch;
            }
            0x8219AE50 => {
    //   block [0x8219AE50..0x8219AE58)
	// 8219AE50: 39200004  li r9, 4
	ctx.r[9].s64 = 4;
	// 8219AE54: 48000038  b 0x8219ae8c
	pc = 0x8219AE8C; continue 'dispatch;
            }
            0x8219AE58 => {
    //   block [0x8219AE58..0x8219AE88)
	// 8219AE58: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219AE5C: 4BFFFA8D  bl 0x8219a8e8
	ctx.lr = 0x8219AE60;
	sub_8219A8E8(ctx, base);
	// 8219AE60: FF0D0800  fcmpu cr6, f13, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[1].f64);
	// 8219AE64: 4098002C  bge cr6, 0x8219ae90
	if !ctx.cr[6].lt {
	pc = 0x8219AE90; continue 'dispatch;
	}
	// 8219AE68: 550B083C  slwi r11, r8, 1
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE6C: 39490090  addi r10, r9, 0x90
	ctx.r[10].s64 = ctx.r[9].s64 + 144;
	// 8219AE70: 7D6B2A14  add r11, r11, r5
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[5].u64;
	// 8219AE74: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219AE78: 7D2B502E  lwzx r9, r11, r10
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219AE7C: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 8219AE80: 409A0008  bne cr6, 0x8219ae88
	if !ctx.cr[6].eq {
	pc = 0x8219AE88; continue 'dispatch;
	}
	// 8219AE84: 38E00002  li r7, 2
	ctx.r[7].s64 = 2;
	pc = 0x8219AE88; continue 'dispatch;
            }
            0x8219AE88 => {
    //   block [0x8219AE88..0x8219AE8C)
	// 8219AE88: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	pc = 0x8219AE8C; continue 'dispatch;
            }
            0x8219AE8C => {
    //   block [0x8219AE8C..0x8219AE90)
	// 8219AE8C: 7D2B512E  stwx r9, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[9].u32) };
	pc = 0x8219AE90; continue 'dispatch;
            }
            0x8219AE90 => {
    //   block [0x8219AE90..0x8219AEA4)
	// 8219AE90: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 8219AE94: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219AE98: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AE9C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AEA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AEA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AEA8 size=252
    let mut pc: u32 = 0x8219AEA8;
    'dispatch: loop {
        match pc {
            0x8219AEA8 => {
    //   block [0x8219AEA8..0x8219AF30)
	// 8219AEA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AEAC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219AEB0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219AEB4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219AEB8: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AEBC: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AEC0: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219AEC4: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219AEC8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219AECC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219AED0: 4801CAF9  bl 0x821b79c8
	ctx.lr = 0x8219AED4;
	sub_821B79C8(ctx, base);
	// 8219AED4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219AED8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219AEDC: C0410068  lfs f2, 0x68(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219AEE0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219AEE4: C0210060  lfs f1, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219AEE8: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219AEEC: 4801C645  bl 0x821b7530
	ctx.lr = 0x8219AEF0;
	sub_821B7530(ctx, base);
	// 8219AEF0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219AEF4: C00B2954  lfs f0, 0x2954(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10580 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219AEF8: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219AEFC: 40990044  ble cr6, 0x8219af40
	if !ctx.cr[6].gt {
	pc = 0x8219AF40; continue 'dispatch;
	}
	// 8219AF00: 81410050  lwz r10, 0x50(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219AF04: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219AF08: 419A0038  beq cr6, 0x8219af40
	if ctx.cr[6].eq {
	pc = 0x8219AF40; continue 'dispatch;
	}
	// 8219AF0C: 816A001C  lwz r11, 0x1c(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219AF10: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219AF14: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219AF18: 419A0020  beq cr6, 0x8219af38
	if ctx.cr[6].eq {
	pc = 0x8219AF38; continue 'dispatch;
	}
	// 8219AF1C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219AF20: 419A0010  beq cr6, 0x8219af30
	if ctx.cr[6].eq {
	pc = 0x8219AF30; continue 'dispatch;
	}
	// 8219AF24: 816A000C  lwz r11, 0xc(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219AF28: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8219AF2C: 48000018  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
            }
            0x8219AF30 => {
    //   block [0x8219AF30..0x8219AF38)
	// 8219AF30: 3960003C  li r11, 0x3c
	ctx.r[11].s64 = 60;
	// 8219AF34: 48000010  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
            }
            0x8219AF38 => {
    //   block [0x8219AF38..0x8219AF40)
	// 8219AF38: 3960003A  li r11, 0x3a
	ctx.r[11].s64 = 58;
	// 8219AF3C: 48000008  b 0x8219af44
	pc = 0x8219AF44; continue 'dispatch;
            }
            0x8219AF40 => {
    //   block [0x8219AF40..0x8219AF44)
	// 8219AF40: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219AF44; continue 'dispatch;
            }
            0x8219AF44 => {
    //   block [0x8219AF44..0x8219AF6C)
	// 8219AF44: 2F1E0011  cmpwi cr6, r30, 0x11
	ctx.cr[6].compare_i32(ctx.r[30].s32, 17, &mut ctx.xer);
	// 8219AF48: 419A0024  beq cr6, 0x8219af6c
	if ctx.cr[6].eq {
	pc = 0x8219AF6C; continue 'dispatch;
	}
	// 8219AF4C: 2F1E0015  cmpwi cr6, r30, 0x15
	ctx.cr[6].compare_i32(ctx.r[30].s32, 21, &mut ctx.xer);
	// 8219AF50: 409A003C  bne cr6, 0x8219af8c
	if !ctx.cr[6].eq {
	pc = 0x8219AF8C; continue 'dispatch;
	}
	// 8219AF54: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219AF58: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 8219AF5C: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AF60: 394A1090  addi r10, r10, 0x1090
	ctx.r[10].s64 = ctx.r[10].s64 + 4240;
	// 8219AF64: 394A00A0  addi r10, r10, 0xa0
	ctx.r[10].s64 = ctx.r[10].s64 + 160;
	// 8219AF68: 48000018  b 0x8219af80
	pc = 0x8219AF80; continue 'dispatch;
            }
            0x8219AF6C => {
    //   block [0x8219AF6C..0x8219AF80)
	// 8219AF6C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219AF70: 6149BE64  ori r9, r10, 0xbe64
	ctx.r[9].u64 = ctx.r[10].u64 | 48740;
	// 8219AF74: 3D40829E  lis r10, -0x7d62
	ctx.r[10].s64 = -2103574528;
	// 8219AF78: 394A1090  addi r10, r10, 0x1090
	ctx.r[10].s64 = ctx.r[10].s64 + 4240;
	// 8219AF7C: 394A00A4  addi r10, r10, 0xa4
	ctx.r[10].s64 = ctx.r[10].s64 + 164;
	pc = 0x8219AF80; continue 'dispatch;
            }
            0x8219AF80 => {
    //   block [0x8219AF80..0x8219AF8C)
	// 8219AF80: 7D3F48AE  lbzx r9, r31, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219AF84: 5529183E  rotlwi r9, r9, 3
	ctx.r[9].u64 = ((ctx.r[9].u32).rotate_left(3)) as u64;
	// 8219AF88: 7D69512E  stwx r11, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u32) };
	pc = 0x8219AF8C; continue 'dispatch;
            }
            0x8219AF8C => {
    //   block [0x8219AF8C..0x8219AFA4)
	// 8219AF8C: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219AF90: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219AF94: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219AF98: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219AF9C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219AFA0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219AFA8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219AFA8 size=996
    let mut pc: u32 = 0x8219AFA8;
    'dispatch: loop {
        match pc {
            0x8219AFA8 => {
    //   block [0x8219AFA8..0x8219B37C)
	// 8219AFA8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219AFAC: 4839A0E1  bl 0x8253508c
	ctx.lr = 0x8219AFB0;
	sub_82535080(ctx, base);
	// 8219AFB0: DBC1FF70  stfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-144 as u32), ctx.f[30].u64 ) };
	// 8219AFB4: DBE1FF78  stfd f31, -0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-136 as u32), ctx.f[31].u64 ) };
	// 8219AFB8: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219AFBC: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219AFC0: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219AFC4: 3A4BBFF0  addi r18, r11, -0x4010
	ctx.r[18].s64 = ctx.r[11].s64 + -16400;
	// 8219AFC8: 3D600003  lis r11, 3
	ctx.r[11].s64 = 196608;
	// 8219AFCC: 616B9450  ori r11, r11, 0x9450
	ctx.r[11].u64 = ctx.r[11].u64 | 37968;
	// 8219AFD0: 7D725A2E  lhzx r11, r18, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[18].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219AFD4: 2B0B0003  cmplwi cr6, r11, 3
	ctx.cr[6].compare_u32(ctx.r[11].u32, 3 as u32, &mut ctx.xer);
	// 8219AFD8: 419A03A4  beq cr6, 0x8219b37c
	if ctx.cr[6].eq {
	pc = 0x8219B37C; continue 'dispatch;
	}
	// 8219AFDC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219AFE0: 38A00015  li r5, 0x15
	ctx.r[5].s64 = 21;
	// 8219AFE4: 3B6B1090  addi r27, r11, 0x1090
	ctx.r[27].s64 = ctx.r[11].s64 + 4240;
	// 8219AFE8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AFEC: 4BFFFEBD  bl 0x8219aea8
	ctx.lr = 0x8219AFF0;
	sub_8219AEA8(ctx, base);
	// 8219AFF0: 38A00011  li r5, 0x11
	ctx.r[5].s64 = 17;
	// 8219AFF4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219AFF8: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219AFFC: 4BFFFEAD  bl 0x8219aea8
	ctx.lr = 0x8219B000;
	sub_8219AEA8(ctx, base);
	// 8219B000: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B004: 3BDF0030  addi r30, r31, 0x30
	ctx.r[30].s64 = ctx.r[31].s64 + 48;
	// 8219B008: 38800015  li r4, 0x15
	ctx.r[4].s64 = 21;
	// 8219B00C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B010: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B014: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B018: 4E800421  bctrl
	ctx.lr = 0x8219B01C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B01C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B020: 38800011  li r4, 0x11
	ctx.r[4].s64 = 17;
	// 8219B024: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B028: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B02C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B030: 4E800421  bctrl
	ctx.lr = 0x8219B034;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B034: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B038: 38800005  li r4, 5
	ctx.r[4].s64 = 5;
	// 8219B03C: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B040: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B044: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B048: 4E800421  bctrl
	ctx.lr = 0x8219B04C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B04C: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B050: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219B054: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B058: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B05C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219B060: 4E800421  bctrl
	ctx.lr = 0x8219B064;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B064: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219B068: 815F0030  lwz r10, 0x30(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B06C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219B070: 616B8410  ori r11, r11, 0x8410
	ctx.r[11].u64 = ctx.r[11].u64 | 33808;
	// 8219B074: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219B078: 814A0008  lwz r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219B07C: 7C1F5C2E  lfsx f0, r31, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B080: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B084: D001007C  stfs f0, 0x7c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8219B088: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B08C: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219B090: EDA007B2  fmuls f13, f0, f30
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[30].f64) as f32) as f64);
	// 8219B094: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219B098: D1A10078  stfs f13, 0x78(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219B09C: C18BD4DC  lfs f12, -0x2b24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11044 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219B0A0: ED800332  fmuls f12, f0, f12
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[12].f64) as f32) as f64);
	// 8219B0A4: D1810074  stfs f12, 0x74(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219B0A8: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219B0AC: 4E800421  bctrl
	ctx.lr = 0x8219B0B0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219B0B0: 39410070  addi r10, r1, 0x70
	ctx.r[10].s64 = ctx.r[1].s64 + 112;
	// 8219B0B4: 80FF0030  lwz r7, 0x30(r31)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B0B8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219B0BC: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219B0C0: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8219B0C4: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
            }
            0x8219B37C => {
    //   block [0x8219B37C..0x8219B38C)
	// 8219B37C: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8219B380: CBC1FF70  lfd f30, -0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-144 as u32) ) };
	// 8219B384: CBE1FF78  lfd f31, -0x88(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-136 as u32) ) };
	// 8219B388: 48399D54  b 0x825350dc
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B390(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219B390 size=408
    let mut pc: u32 = 0x8219B390;
    'dispatch: loop {
        match pc {
            0x8219B390 => {
    //   block [0x8219B390..0x8219B444)
	// 8219B390: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B394: 48399D01  bl 0x82535094
	ctx.lr = 0x8219B398;
	sub_82535080(ctx, base);
	// 8219B398: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 8219B39C: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 8219B3A0: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B3A4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B3A8: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219B3AC: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219B3B0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219B3B4: 3A600001  li r19, 1
	ctx.r[19].s64 = 1;
	// 8219B3B8: 3B6B1090  addi r27, r11, 0x1090
	ctx.r[27].s64 = ctx.r[11].s64 + 4240;
	// 8219B3BC: 39600011  li r11, 0x11
	ctx.r[11].s64 = 17;
	// 8219B3C0: 7FBC50AE  lbzx r29, r28, r10
	ctx.r[29].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B3C4: 3A9B00E4  addi r20, r27, 0xe4
	ctx.r[20].s64 = ctx.r[27].s64 + 228;
	// 8219B3C8: 57B5103E  rotlwi r21, r29, 2
	ctx.r[21].u64 = ((ctx.r[29].u32).rotate_left(2)) as u64;
	// 8219B3CC: 9261005C  stw r19, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[19].u32 ) };
	// 8219B3D0: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219B3D4: 39600015  li r11, 0x15
	ctx.r[11].s64 = 21;
	// 8219B3D8: 7DB5A42E  lfsx f13, r21, r20
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B3DC: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219B3E0: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219B3E4: 91610058  stw r11, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8219B3E8: 39600009  li r11, 9
	ctx.r[11].s64 = 9;
	// 8219B3EC: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8219B3F0: 3960000D  li r11, 0xd
	ctx.r[11].s64 = 13;
	// 8219B3F4: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219B3F8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219B3FC: C00BD218  lfs f0, -0x2de8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B400: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B404: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219B408: C3CB1FF8  lfs f30, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B40C: 409900C0  ble cr6, 0x8219b4cc
	if !ctx.cr[6].gt {
	pc = 0x8219B4CC; continue 'dispatch;
	}
	// 8219B410: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B414: 616BEB34  ori r11, r11, 0xeb34
	ctx.r[11].u64 = ctx.r[11].u64 | 60212;
	// 8219B418: 7D7C58AE  lbzx r11, r28, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B41C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B420: 409A00AC  bne cr6, 0x8219b4cc
	if !ctx.cr[6].eq {
	pc = 0x8219B4CC; continue 'dispatch;
	}
	// 8219B424: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219B428: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B42C: 57B8103A  slwi r24, r29, 2
	ctx.r[24].u32 = ctx.r[29].u32.wrapping_shl(2);
	ctx.r[24].u64 = ctx.r[24].u32 as u64;
	// 8219B430: 3B410050  addi r26, r1, 0x50
	ctx.r[26].s64 = ctx.r[1].s64 + 80;
	// 8219B434: 3AFB00B0  addi r23, r27, 0xb0
	ctx.r[23].s64 = ctx.r[27].s64 + 176;
	// 8219B438: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219B43C: 3B200006  li r25, 6
	ctx.r[25].s64 = 6;
	// 8219B440: 6156BEBA  ori r22, r10, 0xbeba
	ctx.r[22].u64 = ctx.r[10].u64 | 48826;
	pc = 0x8219B444; continue 'dispatch;
            }
            0x8219B444 => {
    //   block [0x8219B444..0x8219B470)
	// 8219B444: 7D78B82E  lwzx r11, r24, r23
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[24].u32.wrapping_add(ctx.r[23].u32)) } as u64;
	// 8219B448: 83DA0000  lwz r30, 0(r26)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219B44C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8219B450: 419A0020  beq cr6, 0x8219b470
	if ctx.cr[6].eq {
	pc = 0x8219B470; continue 'dispatch;
	}
	// 8219B454: 7D7CB22E  lhzx r11, r28, r22
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[22].u32)) } as u64;
	// 8219B458: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 8219B45C: 419A0048  beq cr6, 0x8219b4a4
	if ctx.cr[6].eq {
	pc = 0x8219B4A4; continue 'dispatch;
	}
	// 8219B460: 2F1E0015  cmpwi cr6, r30, 0x15
	ctx.cr[6].compare_i32(ctx.r[30].s32, 21, &mut ctx.xer);
	// 8219B464: 419A000C  beq cr6, 0x8219b470
	if ctx.cr[6].eq {
	pc = 0x8219B470; continue 'dispatch;
	}
	// 8219B468: 2F1E0011  cmpwi cr6, r30, 0x11
	ctx.cr[6].compare_i32(ctx.r[30].s32, 17, &mut ctx.xer);
	// 8219B46C: 409A0038  bne cr6, 0x8219b4a4
	if !ctx.cr[6].eq {
	pc = 0x8219B4A4; continue 'dispatch;
	}
	pc = 0x8219B470; continue 'dispatch;
            }
            0x8219B470 => {
    //   block [0x8219B470..0x8219B4A4)
	// 8219B470: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219B474: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B478: 395B00A0  addi r10, r27, 0xa0
	ctx.r[10].s64 = ctx.r[27].s64 + 160;
	// 8219B47C: 7FC40734  extsh r4, r30
	ctx.r[4].s64 = ctx.r[30].s16 as i64;
	// 8219B480: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B484: 7FEB502E  lwzx r31, r11, r10
	ctx.r[31].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B488: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219B48C: 4814C525  bl 0x822e79b0
	ctx.lr = 0x8219B490;
	sub_822E79B0(ctx, base);
	// 8219B490: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219B494: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219B498: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219B49C: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219B4A0: 48000A41  bl 0x8219bee0
	ctx.lr = 0x8219B4A4;
	sub_8219BEE0(ctx, base);
	pc = 0x8219B4A4; continue 'dispatch;
            }
            0x8219B4A4 => {
    //   block [0x8219B4A4..0x8219B4C8)
	// 8219B4A4: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 8219B4A8: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8219B4AC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219B4B0: 409AFF94  bne cr6, 0x8219b444
	if !ctx.cr[6].eq {
	pc = 0x8219B444; continue 'dispatch;
	}
	// 8219B4B4: 397B00E0  addi r11, r27, 0xe0
	ctx.r[11].s64 = ctx.r[27].s64 + 224;
	// 8219B4B8: 7D5D58AE  lbzx r10, r29, r11
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B4BC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219B4C0: 409A0008  bne cr6, 0x8219b4c8
	if !ctx.cr[6].eq {
	pc = 0x8219B4C8; continue 'dispatch;
	}
	// 8219B4C4: 7E7D59AE  stbx r19, r29, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[19].u8) };
	pc = 0x8219B4C8; continue 'dispatch;
            }
            0x8219B4C8 => {
    //   block [0x8219B4C8..0x8219B4CC)
	// 8219B4C8: 7FD5A52E  stfsx f30, r21, r20
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	pc = 0x8219B4CC; continue 'dispatch;
            }
            0x8219B4CC => {
    //   block [0x8219B4CC..0x8219B504)
	// 8219B4CC: 3D5C0006  addis r10, r28, 6
	ctx.r[10].s64 = ctx.r[28].s64 + 393216;
	// 8219B4D0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B4D4: 394A9238  addi r10, r10, -0x6dc8
	ctx.r[10].s64 = ctx.r[10].s64 + -28104;
	// 8219B4D8: C00B20B0  lfs f0, 0x20b0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8368 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B4DC: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B4E0: FF0D0000  fcmpu cr6, f13, f0
	ctx.cr[6].compare_f64(ctx.f[13].f64, ctx.f[0].f64);
	// 8219B4E4: 40980020  bge cr6, 0x8219b504
	if !ctx.cr[6].lt {
	pc = 0x8219B504; continue 'dispatch;
	}
	// 8219B4E8: 397B00E0  addi r11, r27, 0xe0
	ctx.r[11].s64 = ctx.r[27].s64 + 224;
	// 8219B4EC: 7D3D58AE  lbzx r9, r29, r11
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B4F0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219B4F4: 419A0010  beq cr6, 0x8219b504
	if ctx.cr[6].eq {
	pc = 0x8219B504; continue 'dispatch;
	}
	// 8219B4F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219B4FC: 7D3D59AE  stbx r9, r29, r11
	unsafe { crate::rt::store_u8(base as *mut u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32), ctx.r[9].u8) };
	// 8219B500: 7FD5A52E  stfsx f30, r21, r20
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	pc = 0x8219B504; continue 'dispatch;
            }
            0x8219B504 => {
    //   block [0x8219B504..0x8219B528)
	// 8219B504: 7C15A42E  lfsx f0, r21, r20
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B508: C1AA0000  lfs f13, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B50C: EC00682A  fadds f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219B510: 7C15A52E  stfsx f0, r21, r20
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[21].u32.wrapping_add(ctx.r[20].u32), tmp.u32) };
	// 8219B514: D3CA0000  stfs f30, 0(r10)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219B518: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8219B51C: CBC1FF80  lfd f30, -0x80(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 8219B520: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 8219B524: 48399BC0  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B528(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219B528 size=736
    let mut pc: u32 = 0x8219B528;
    'dispatch: loop {
        match pc {
            0x8219B528 => {
    //   block [0x8219B528..0x8219B5A0)
	// 8219B528: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B52C: 48399B79  bl 0x825350a4
	ctx.lr = 0x8219B530;
	sub_82535080(ctx, base);
	// 8219B530: DBC1FFA0  stfd f30, -0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-96 as u32), ctx.f[30].u64 ) };
	// 8219B534: DBE1FFA8  stfd f31, -0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[31].u64 ) };
	// 8219B538: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B53C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B540: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B544: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 8219B548: 614ABE64  ori r10, r10, 0xbe64
	ctx.r[10].u64 = ctx.r[10].u64 | 48740;
	// 8219B54C: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B550: 7F0450AE  lbzx r24, r4, r10
	ctx.r[24].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B554: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B558: 419A02A0  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B55C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B560: 616BEB00  ori r11, r11, 0xeb00
	ctx.r[11].u64 = ctx.r[11].u64 | 60160;
	// 8219B564: 7D6458AE  lbzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B568: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B56C: 419A028C  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B570: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B574: 38A00017  li r5, 0x17
	ctx.r[5].s64 = 23;
	// 8219B578: 616ABEBC  ori r10, r11, 0xbebc
	ctx.r[10].u64 = ctx.r[11].u64 | 48828;
	// 8219B57C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219B580: C3CBBA38  lfs f30, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219B584: 7D64522E  lhzx r11, r4, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B588: FC20F090  fmr f1, f30
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8219B58C: 2B0B000B  cmplwi cr6, r11, 0xb
	ctx.cr[6].compare_u32(ctx.r[11].u32, 11 as u32, &mut ctx.xer);
	// 8219B590: 409A0010  bne cr6, 0x8219b5a0
	if !ctx.cr[6].eq {
	pc = 0x8219B5A0; continue 'dispatch;
	}
	// 8219B594: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B598: 38A0001F  li r5, 0x1f
	ctx.r[5].s64 = 31;
	// 8219B59C: C02B2070  lfs f1, 0x2070(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8304 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	pc = 0x8219B5A0; continue 'dispatch;
            }
            0x8219B5A0 => {
    //   block [0x8219B5A0..0x8219B618)
	// 8219B5A0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219B5A4: 4814A9D5  bl 0x822e5f78
	ctx.lr = 0x8219B5A8;
	sub_822E5F78(ctx, base);
	// 8219B5A8: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219B5AC: 4801C1B5  bl 0x821b7760
	ctx.lr = 0x8219B5B0;
	sub_821B7760(ctx, base);
	// 8219B5B0: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219B5B4: C0010084  lfs f0, 0x84(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B5B8: 3AE00000  li r23, 0
	ctx.r[23].s64 = 0;
	// 8219B5BC: C3EBD4D0  lfs f31, -0x2b30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11056 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219B5C0: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219B5C4: FF00F800  fcmpu cr6, f0, f31
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[31].f64);
	// 8219B5C8: 3B8B1090  addi r28, r11, 0x1090
	ctx.r[28].s64 = ctx.r[11].s64 + 4240;
	// 8219B5CC: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219B5D0: 3B2B0C40  addi r25, r11, 0xc40
	ctx.r[25].s64 = ctx.r[11].s64 + 3136;
	// 8219B5D4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219B5D8: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 8219B5DC: 409800DC  bge cr6, 0x8219b6b8
	if !ctx.cr[6].lt {
	pc = 0x8219B6B8; continue 'dispatch;
	}
	// 8219B5E0: 571B103A  slwi r27, r24, 2
	ctx.r[27].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[27].u64 = ctx.r[27].u32 as u64;
	// 8219B5E4: 81590688  lwz r10, 0x688(r25)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B5E8: 3B5C00EC  addi r26, r28, 0xec
	ctx.r[26].s64 = ctx.r[28].s64 + 236;
	// 8219B5EC: 7D7BD02E  lwzx r11, r27, r26
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32)) } as u64;
	// 8219B5F0: 7D6B5050  subf r11, r11, r10
	ctx.r[11].s64 = ctx.r[10].s64 - ctx.r[11].s64;
	// 8219B5F4: 2B0B000A  cmplwi cr6, r11, 0xa
	ctx.cr[6].compare_u32(ctx.r[11].u32, 10 as u32, &mut ctx.xer);
	// 8219B5F8: 409900C0  ble cr6, 0x8219b6b8
	if !ctx.cr[6].gt {
	pc = 0x8219B6B8; continue 'dispatch;
	}
	// 8219B5FC: 2F030005  cmpwi cr6, r3, 5
	ctx.cr[6].compare_i32(ctx.r[3].s32, 5, &mut ctx.xer);
	// 8219B600: 419A0060  beq cr6, 0x8219b660
	if ctx.cr[6].eq {
	pc = 0x8219B660; continue 'dispatch;
	}
	// 8219B604: 2F030009  cmpwi cr6, r3, 9
	ctx.cr[6].compare_i32(ctx.r[3].s32, 9, &mut ctx.xer);
	// 8219B608: 409A00A8  bne cr6, 0x8219b6b0
	if !ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B60C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B610: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 8219B614: 3BEBC188  addi r31, r11, -0x3e78
	ctx.r[31].s64 = ctx.r[11].s64 + -15992;
	pc = 0x8219B618; continue 'dispatch;
            }
            0x8219B618 => {
    //   block [0x8219B618..0x8219B650)
	// 8219B618: 4814B809  bl 0x822e6e20
	ctx.lr = 0x8219B61C;
	sub_822E6E20(ctx, base);
	// 8219B61C: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219B620: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B624: 419A008C  beq cr6, 0x8219b6b0
	if ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B628: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 8219B62C: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B630: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8219B634: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 8219B638: 38600170  li r3, 0x170
	ctx.r[3].s64 = 368;
	// 8219B63C: 481CEE55  bl 0x8236a490
	ctx.lr = 0x8219B640;
	sub_8236A490(ctx, base);
	// 8219B640: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B644: 419A000C  beq cr6, 0x8219b650
	if ctx.cr[6].eq {
	pc = 0x8219B650; continue 'dispatch;
	}
	// 8219B648: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219B64C: 4814F7BD  bl 0x822eae08
	ctx.lr = 0x8219B650;
	sub_822EAE08(ctx, base);
	pc = 0x8219B650; continue 'dispatch;
            }
            0x8219B650 => {
    //   block [0x8219B650..0x8219B660)
	// 8219B650: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219B654: 2F1E000C  cmpwi cr6, r30, 0xc
	ctx.cr[6].compare_i32(ctx.r[30].s32, 12, &mut ctx.xer);
	// 8219B658: 4198FFC0  blt cr6, 0x8219b618
	if ctx.cr[6].lt {
	pc = 0x8219B618; continue 'dispatch;
	}
	// 8219B65C: 48000054  b 0x8219b6b0
	pc = 0x8219B6B0; continue 'dispatch;
            }
            0x8219B660 => {
    //   block [0x8219B660..0x8219B66C)
	// 8219B660: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219B664: 7EFEBB78  mr r30, r23
	ctx.r[30].u64 = ctx.r[23].u64;
	// 8219B668: 3BEBC188  addi r31, r11, -0x3e78
	ctx.r[31].s64 = ctx.r[11].s64 + -15992;
	pc = 0x8219B66C; continue 'dispatch;
            }
            0x8219B66C => {
    //   block [0x8219B66C..0x8219B6A4)
	// 8219B66C: 4814B7B5  bl 0x822e6e20
	ctx.lr = 0x8219B670;
	sub_822E6E20(ctx, base);
	// 8219B670: 546B063E  clrlwi r11, r3, 0x18
	ctx.r[11].u64 = ctx.r[3].u32 as u64 & 0x000000FFu64;
	// 8219B674: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B678: 419A0038  beq cr6, 0x8219b6b0
	if ctx.cr[6].eq {
	pc = 0x8219B6B0; continue 'dispatch;
	}
	// 8219B67C: 38C00005  li r6, 5
	ctx.r[6].s64 = 5;
	// 8219B680: 809D0014  lwz r4, 0x14(r29)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B684: 7FE7FB78  mr r7, r31
	ctx.r[7].u64 = ctx.r[31].u64;
	// 8219B688: 38A01385  li r5, 0x1385
	ctx.r[5].s64 = 4997;
	// 8219B68C: 38600180  li r3, 0x180
	ctx.r[3].s64 = 384;
	// 8219B690: 481CEE01  bl 0x8236a490
	ctx.lr = 0x8219B694;
	sub_8236A490(ctx, base);
	// 8219B694: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B698: 419A000C  beq cr6, 0x8219b6a4
	if ctx.cr[6].eq {
	pc = 0x8219B6A4; continue 'dispatch;
	}
	// 8219B69C: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219B6A0: 4814F089  bl 0x822ea728
	ctx.lr = 0x8219B6A4;
	sub_822EA728(ctx, base);
	pc = 0x8219B6A4; continue 'dispatch;
            }
            0x8219B6A4 => {
    //   block [0x8219B6A4..0x8219B6B0)
	// 8219B6A4: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219B6A8: 2F1E000C  cmpwi cr6, r30, 0xc
	ctx.cr[6].compare_i32(ctx.r[30].s32, 12, &mut ctx.xer);
	// 8219B6AC: 4198FFC0  blt cr6, 0x8219b66c
	if ctx.cr[6].lt {
	pc = 0x8219B66C; continue 'dispatch;
	}
	pc = 0x8219B6B0; continue 'dispatch;
            }
            0x8219B6B0 => {
    //   block [0x8219B6B0..0x8219B6B8)
	// 8219B6B0: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B6B4: 7D7BD12E  stwx r11, r27, r26
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[27].u32.wrapping_add(ctx.r[26].u32), ctx.r[11].u32) };
	pc = 0x8219B6B8; continue 'dispatch;
            }
            0x8219B6B8 => {
    //   block [0x8219B6B8..0x8219B744)
	// 8219B6B8: 3920003F  li r9, 0x3f
	ctx.r[9].s64 = 63;
	// 8219B6BC: 3900003F  li r8, 0x3f
	ctx.r[8].s64 = 63;
	// 8219B6C0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219B6C4: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8219B6C8: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 8219B6CC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219B6D0: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219B6D4: 480198F5  bl 0x821b4fc8
	ctx.lr = 0x8219B6D8;
	sub_821B4FC8(ctx, base);
	// 8219B6D8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219B6DC: 419A011C  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B6E0: 571F103A  slwi r31, r24, 2
	ctx.r[31].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8219B6E4: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B6E8: 3BDC00F4  addi r30, r28, 0xf4
	ctx.r[30].s64 = ctx.r[28].s64 + 244;
	// 8219B6EC: 7D5FF02E  lwzx r10, r31, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219B6F0: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219B6F4: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 8219B6F8: 40990100  ble cr6, 0x8219b7f8
	if !ctx.cr[6].gt {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B6FC: 8163001C  lwz r11, 0x1c(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219B700: 556BC73E  rlwinm r11, r11, 0x18, 0x1c, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219B704: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219B708: 419A00F0  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B70C: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219B710: 419A00E8  beq cr6, 0x8219b7f8
	if ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	// 8219B714: 8163000C  lwz r11, 0xc(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219B718: 556BE63E  rlwinm r11, r11, 0x1c, 0x18, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x0000000Fu64;
	// 8219B71C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219B720: 419A0024  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B724: 2F0B0006  cmpwi cr6, r11, 6
	ctx.cr[6].compare_i32(ctx.r[11].s32, 6, &mut ctx.xer);
	// 8219B728: 419A001C  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B72C: 2F0B0007  cmpwi cr6, r11, 7
	ctx.cr[6].compare_i32(ctx.r[11].s32, 7, &mut ctx.xer);
	// 8219B730: 419A0014  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B734: 2F0B000E  cmpwi cr6, r11, 0xe
	ctx.cr[6].compare_i32(ctx.r[11].s32, 14, &mut ctx.xer);
	// 8219B738: 419A000C  beq cr6, 0x8219b744
	if ctx.cr[6].eq {
	pc = 0x8219B744; continue 'dispatch;
	}
	// 8219B73C: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8219B740: 409A00B8  bne cr6, 0x8219b7f8
	if !ctx.cr[6].eq {
	pc = 0x8219B7F8; continue 'dispatch;
	}
	pc = 0x8219B744; continue 'dispatch;
            }
            0x8219B744 => {
    //   block [0x8219B744..0x8219B7D4)
	// 8219B744: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219B748: 80BD0014  lwz r5, 0x14(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219B74C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219B750: FC20F090  fmr f1, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[30].f64;
	// 8219B754: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219B758: 92E10054  stw r23, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[23].u32 ) };
	// 8219B75C: 38C0006A  li r6, 0x6a
	ctx.r[6].s64 = 106;
	// 8219B760: FAE10060  std r23, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[23].u64 ) };
	// 8219B764: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 8219B768: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219B76C: 481B01F5  bl 0x8234b960
	ctx.lr = 0x8219B770;
	sub_8234B960(ctx, base);
	// 8219B770: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8219B774: E8610060  ld r3, 0x60(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219B778: 481B0931  bl 0x8234c0a8
	ctx.lr = 0x8219B77C;
	sub_8234C0A8(ctx, base);
	// 8219B77C: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219B780: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B784: 419A006C  beq cr6, 0x8219b7f0
	if ctx.cr[6].eq {
	pc = 0x8219B7F0; continue 'dispatch;
	}
	// 8219B788: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219B78C: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219B790: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219B794: 409A005C  bne cr6, 0x8219b7f0
	if !ctx.cr[6].eq {
	pc = 0x8219B7F0; continue 'dispatch;
	}
	// 8219B798: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219B79C: 894B01F7  lbz r10, 0x1f7(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(503 as u32) ) } as u64;
	// 8219B7A0: C18B020C  lfs f12, 0x20c(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(524 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219B7A4: 614A0002  ori r10, r10, 2
	ctx.r[10].u64 = ctx.r[10].u64 | 2;
	// 8219B7A8: C00B009C  lfs f0, 0x9c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(156 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219B7AC: C1A92074  lfs f13, 0x2074(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B7B0: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219B7B4: FF0C6800  fcmpu cr6, f12, f13
	ctx.cr[6].compare_f64(ctx.f[12].f64, ctx.f[13].f64);
	// 8219B7B8: 994B01F7  stb r10, 0x1f7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(503 as u32), ctx.r[10].u8 ) };
	// 8219B7BC: C1A9D6C8  lfs f13, -0x2938(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10552 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219B7C0: EDA0682A  fadds f13, f0, f13
	ctx.f[13].f64 = ((ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219B7C4: D1AB0208  stfs f13, 0x208(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(520 as u32), tmp.u32 ) };
	// 8219B7C8: 409A000C  bne cr6, 0x8219b7d4
	if !ctx.cr[6].eq {
	pc = 0x8219B7D4; continue 'dispatch;
	}
	// 8219B7CC: 714A00FB  andi. r10, r10, 0xfb
	ctx.r[10].u64 = ctx.r[10].u64 & 251;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219B7D0: 48000010  b 0x8219b7e0
	pc = 0x8219B7E0; continue 'dispatch;
            }
            0x8219B7D4 => {
    //   block [0x8219B7D4..0x8219B7E0)
	// 8219B7D4: EC00F82A  fadds f0, f0, f31
	ctx.f[0].f64 = ((ctx.f[0].f64 + ctx.f[31].f64) as f32) as f64;
	// 8219B7D8: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 8219B7DC: D00B020C  stfs f0, 0x20c(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(524 as u32), tmp.u32 ) };
	pc = 0x8219B7E0; continue 'dispatch;
            }
            0x8219B7E0 => {
    //   block [0x8219B7E0..0x8219B7F0)
	// 8219B7E0: 994B01F7  stb r10, 0x1f7(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(503 as u32), ctx.r[10].u8 ) };
	// 8219B7E4: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219B7E8: 554A062C  rlwinm r10, r10, 0, 0x18, 0x16
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0xFFFFFFFFu64;
	// 8219B7EC: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	pc = 0x8219B7F0; continue 'dispatch;
            }
            0x8219B7F0 => {
    //   block [0x8219B7F0..0x8219B7F8)
	// 8219B7F0: 81790688  lwz r11, 0x688(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219B7F4: 7D7FF12E  stwx r11, r31, r30
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32), ctx.r[11].u32) };
	pc = 0x8219B7F8; continue 'dispatch;
            }
            0x8219B7F8 => {
    //   block [0x8219B7F8..0x8219B808)
	// 8219B7F8: 38210100  addi r1, r1, 0x100
	ctx.r[1].s64 = ctx.r[1].s64 + 256;
	// 8219B7FC: CBC1FFA0  lfd f30, -0x60(r1)
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-96 as u32) ) };
	// 8219B800: CBE1FFA8  lfd f31, -0x58(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8219B804: 483998F0  b 0x825350f4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219B808(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219B808 size=1068
    let mut pc: u32 = 0x8219B808;
    'dispatch: loop {
        match pc {
            0x8219B808 => {
    //   block [0x8219B808..0x8219B850)
	// 8219B808: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219B80C: 48399895  bl 0x825350a0
	ctx.lr = 0x8219B810;
	sub_82535080(ctx, base);
	// 8219B810: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219B814: 4839A7D5  bl 0x82535fe8
	ctx.lr = 0x8219B818;
	sub_82535FB0(ctx, base);
	// 8219B818: 9421FE50  stwu r1, -0x1b0(r1)
	ea = ctx.r[1].u32.wrapping_add(-432 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219B81C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219B820: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219B824: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219B828: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 8219B82C: 614AEB33  ori r10, r10, 0xeb33
	ctx.r[10].u64 = ctx.r[10].u64 | 60211;
	// 8219B830: 7EDC58AE  lbzx r22, r28, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B834: 7D7C50AE  lbzx r11, r28, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219B838: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B83C: 409A03E8  bne cr6, 0x8219bc24
	if !ctx.cr[6].eq {
	pc = 0x8219BC24; continue 'dispatch;
	}
	// 8219B840: 39610090  addi r11, r1, 0x90
	ctx.r[11].s64 = ctx.r[1].s64 + 144;
	// 8219B844: 394000A8  li r10, 0xa8
	ctx.r[10].s64 = 168;
	// 8219B848: 39200006  li r9, 6
	ctx.r[9].s64 = 6;
	// 8219B84C: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8219B850; continue 'dispatch;
            }
            0x8219B850 => {
    //   block [0x8219B850..0x8219B8A8)
	// 8219B850: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219B854: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219B858: 4200FFF8  bdnz 0x8219b850
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219B850; continue 'dispatch;
	}
	// 8219B85C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219B860: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219B864: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219B868: 396BCF90  addi r11, r11, -0x3070
	ctx.r[11].s64 = ctx.r[11].s64 + -12400;
	// 8219B86C: 3AE00005  li r23, 5
	ctx.r[23].s64 = 5;
	// 8219B870: 91210090  stw r9, 0x90(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u32 ) };
	// 8219B874: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8219B878: 396B0798  addi r11, r11, 0x798
	ctx.r[11].s64 = ctx.r[11].s64 + 1944;
	// 8219B87C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219B880: 92E10094  stw r23, 0x94(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), ctx.r[23].u32 ) };
	// 8219B884: 91210098  stw r9, 0x98(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[9].u32 ) };
	// 8219B888: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219B88C: 7D6A582E  lwzx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219B890: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219B894: 9121009C  stw r9, 0x9c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(156 as u32), ctx.r[9].u32 ) };
	// 8219B898: 39200014  li r9, 0x14
	ctx.r[9].s64 = 20;
	// 8219B89C: 912100A0  stw r9, 0xa0(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[9].u32 ) };
	// 8219B8A0: 419A0008  beq cr6, 0x8219b8a8
	if ctx.cr[6].eq {
	pc = 0x8219B8A8; continue 'dispatch;
	}
	// 8219B8A4: 3BCB0030  addi r30, r11, 0x30
	ctx.r[30].s64 = ctx.r[11].s64 + 48;
	pc = 0x8219B8A8; continue 'dispatch;
            }
            0x8219B8A8 => {
    //   block [0x8219B8A8..0x8219BC24)
	// 8219B8A8: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8219B8AC: 396100F0  addi r11, r1, 0xf0
	ctx.r[11].s64 = ctx.r[1].s64 + 240;
	// 8219B8B0: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	pc = 0x8219BC24; continue 'dispatch;
            }
            0x8219BC24 => {
    //   block [0x8219BC24..0x8219BC34)
	// 8219BC24: 382101B0  addi r1, r1, 0x1b0
	ctx.r[1].s64 = ctx.r[1].s64 + 432;
	// 8219BC28: 3981FFA8  addi r12, r1, -0x58
	ctx.r[12].s64 = ctx.r[1].s64 + -88;
	// 8219BC2C: 4839A409  bl 0x82536034
	ctx.lr = 0x8219BC30;
	sub_82535FFC(ctx, base);
	// 8219BC30: 483994C0  b 0x825350f0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BC38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BC38 size=348
    let mut pc: u32 = 0x8219BC38;
    'dispatch: loop {
        match pc {
            0x8219BC38 => {
    //   block [0x8219BC38..0x8219BD18)
	// 8219BC38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BC3C: 48399479  bl 0x825350b4
	ctx.lr = 0x8219BC40;
	sub_82535080(ctx, base);
	// 8219BC40: DBE1FFC8  stfd f31, -0x38(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), ctx.f[31].u64 ) };
	// 8219BC44: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BC48: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219BC4C: FFE00890  fmr f31, f1
	ctx.f[31].f64 = ctx.f[1].f64;
	// 8219BC50: 549C103A  slwi r28, r4, 2
	ctx.r[28].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[28].u64 = ctx.r[28].u32 as u64;
	// 8219BC54: 396B1090  addi r11, r11, 0x1090
	ctx.r[11].s64 = ctx.r[11].s64 + 4240;
	// 8219BC58: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 8219BC5C: 3B6B00FC  addi r27, r11, 0xfc
	ctx.r[27].s64 = ctx.r[11].s64 + 252;
	// 8219BC60: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219BC64: 3BAB0C40  addi r29, r11, 0xc40
	ctx.r[29].s64 = ctx.r[11].s64 + 3136;
	// 8219BC68: 7D5CD82E  lwzx r10, r28, r27
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219BC6C: 817D0688  lwz r11, 0x688(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219BC70: 7D6A5850  subf r11, r10, r11
	ctx.r[11].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 8219BC74: 2B0B003C  cmplwi cr6, r11, 0x3c
	ctx.cr[6].compare_u32(ctx.r[11].u32, 60 as u32, &mut ctx.xer);
	// 8219BC78: 41980110  blt cr6, 0x8219bd88
	if ctx.cr[6].lt {
	pc = 0x8219BD88; continue 'dispatch;
	}
	// 8219BC7C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BC80: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219BC84: 38EB09D8  addi r7, r11, 0x9d8
	ctx.r[7].s64 = ctx.r[11].s64 + 2520;
	// 8219BC88: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219BC8C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219BC90: 386001B0  li r3, 0x1b0
	ctx.r[3].s64 = 432;
	// 8219BC94: 83EBB9D8  lwz r31, -0x4628(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17960 as u32) ) } as u64;
	// 8219BC98: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219BC9C: 481CE7F5  bl 0x8236a490
	ctx.lr = 0x8219BCA0;
	sub_8236A490(ctx, base);
	// 8219BCA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219BCA4: 419A00E4  beq cr6, 0x8219bd88
	if ctx.cr[6].eq {
	pc = 0x8219BD88; continue 'dispatch;
	}
	// 8219BCA8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BCAC: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219BCB0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219BCB4: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BCB8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BCBC: C1AABA38  lfs f13, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BCC0: 39400004  li r10, 4
	ctx.r[10].s64 = 4;
	// 8219BCC4: 396B0AD0  addi r11, r11, 0xad0
	ctx.r[11].s64 = ctx.r[11].s64 + 2768;
	// 8219BCC8: D00300B0  stfs f0, 0xb0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 8219BCCC: D00300B4  stfs f0, 0xb4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 8219BCD0: D00300B8  stfs f0, 0xb8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(184 as u32), tmp.u32 ) };
	// 8219BCD4: D1A300BC  stfs f13, 0xbc(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(188 as u32), tmp.u32 ) };
	// 8219BCD8: D00300A0  stfs f0, 0xa0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219BCDC: D00300A4  stfs f0, 0xa4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219BCE0: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219BCE4: D1A300AC  stfs f13, 0xac(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219BCE8: 912300C0  stw r9, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[9].u32 ) };
	// 8219BCEC: D00300C4  stfs f0, 0xc4(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), tmp.u32 ) };
	// 8219BCF0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219BCF4: B1430088  sth r10, 0x88(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[10].u16 ) };
	// 8219BCF8: 93E30090  stw r31, 0x90(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(144 as u32), ctx.r[31].u32 ) };
	// 8219BCFC: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	// 8219BD00: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219BD04: 91630080  stw r11, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219BD08: 817F0080  lwz r11, 0x80(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219BD0C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BD10: 419A0008  beq cr6, 0x8219bd18
	if ctx.cr[6].eq {
	pc = 0x8219BD18; continue 'dispatch;
	}
	// 8219BD14: 906B0084  stw r3, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	pc = 0x8219BD18; continue 'dispatch;
            }
            0x8219BD18 => {
    //   block [0x8219BD18..0x8219BD60)
	// 8219BD18: 907F0080  stw r3, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[3].u32 ) };
	// 8219BD1C: 39610050  addi r11, r1, 0x50
	ctx.r[11].s64 = ctx.r[1].s64 + 80;
	// 8219BD20: E93E0000  ld r9, 0(r30)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	// 8219BD24: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
	// 8219BD28: E91E0008  ld r8, 8(r30)
	ctx.r[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	// 8219BD2C: FC00F890  fmr f0, f31
	ctx.f[0].f64 = ctx.f[31].f64;
	// 8219BD30: FF1F6800  fcmpu cr6, f31, f13
	ctx.cr[6].compare_f64(ctx.f[31].f64, ctx.f[13].f64);
	// 8219BD34: F92B0000  std r9, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219BD38: F90B0008  std r8, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[8].u64 ) };
	// 8219BD3C: E96A0000  ld r11, 0(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 8219BD40: E94A0008  ld r10, 8(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	// 8219BD44: F96300D0  std r11, 0xd0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[11].u64 ) };
	// 8219BD48: F94300D8  std r10, 0xd8(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[10].u64 ) };
	// 8219BD4C: 40980014  bge cr6, 0x8219bd60
	if !ctx.cr[6].lt {
	pc = 0x8219BD60; continue 'dispatch;
	}
	// 8219BD50: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BD54: C00B228C  lfs f0, 0x228c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8844 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BD58: D00300E0  stfs f0, 0xe0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	// 8219BD5C: 48000008  b 0x8219bd64
	pc = 0x8219BD64; continue 'dispatch;
            }
            0x8219BD60 => {
    //   block [0x8219BD60..0x8219BD64)
	// 8219BD60: D3E300E0  stfs f31, 0xe0(r3)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(224 as u32), tmp.u32 ) };
	pc = 0x8219BD64; continue 'dispatch;
            }
            0x8219BD64 => {
    //   block [0x8219BD64..0x8219BD88)
	// 8219BD64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BD68: C1ABF1FC  lfs f13, -0xe04(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-3588 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BD6C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BD70: D1A300E4  stfs f13, 0xe4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(228 as u32), tmp.u32 ) };
	// 8219BD74: C1AB23C0  lfs f13, 0x23c0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(9152 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219BD78: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219BD7C: D00300E8  stfs f0, 0xe8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(232 as u32), tmp.u32 ) };
	// 8219BD80: 817D0688  lwz r11, 0x688(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(1672 as u32) ) } as u64;
	// 8219BD84: 7D7CD92E  stwx r11, r28, r27
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[28].u32.wrapping_add(ctx.r[27].u32), ctx.r[11].u32) };
	pc = 0x8219BD88; continue 'dispatch;
            }
            0x8219BD88 => {
    //   block [0x8219BD88..0x8219BD94)
	// 8219BD88: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219BD8C: CBE1FFC8  lfd f31, -0x38(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-56 as u32) ) };
	// 8219BD90: 48399374  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BD98(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BD98 size=324
    let mut pc: u32 = 0x8219BD98;
    'dispatch: loop {
        match pc {
            0x8219BD98 => {
    //   block [0x8219BD98..0x8219BE18)
	// 8219BD98: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BD9C: 4839931D  bl 0x825350b8
	ctx.lr = 0x8219BDA0;
	sub_82535080(ctx, base);
	// 8219BDA0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BDA4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219BDA8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219BDAC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219BDB0: 614A8654  ori r10, r10, 0x8654
	ctx.r[10].u64 = ctx.r[10].u64 | 34388;
	// 8219BDB4: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8219BDB8: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219BDBC: 2B0B0016  cmplwi cr6, r11, 0x16
	ctx.cr[6].compare_u32(ctx.r[11].u32, 22 as u32, &mut ctx.xer);
	// 8219BDC0: 419A0114  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDC4: 2B0B0017  cmplwi cr6, r11, 0x17
	ctx.cr[6].compare_u32(ctx.r[11].u32, 23 as u32, &mut ctx.xer);
	// 8219BDC8: 419A010C  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDCC: 2B0B0019  cmplwi cr6, r11, 0x19
	ctx.cr[6].compare_u32(ctx.r[11].u32, 25 as u32, &mut ctx.xer);
	// 8219BDD0: 419A0104  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDD4: 2B0B0014  cmplwi cr6, r11, 0x14
	ctx.cr[6].compare_u32(ctx.r[11].u32, 20 as u32, &mut ctx.xer);
	// 8219BDD8: 419A00FC  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDDC: 2B0B0015  cmplwi cr6, r11, 0x15
	ctx.cr[6].compare_u32(ctx.r[11].u32, 21 as u32, &mut ctx.xer);
	// 8219BDE0: 419A00F4  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDE4: 2B0B0004  cmplwi cr6, r11, 4
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4 as u32, &mut ctx.xer);
	// 8219BDE8: 419A00EC  beq cr6, 0x8219bed4
	if ctx.cr[6].eq {
	pc = 0x8219BED4; continue 'dispatch;
	}
	// 8219BDEC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219BDF0: 617E9C00  ori r30, r11, 0x9c00
	ctx.r[30].u64 = ctx.r[11].u64 | 39936;
	// 8219BDF4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219BDF8: 3BEB1090  addi r31, r11, 0x1090
	ctx.r[31].s64 = ctx.r[11].s64 + 4240;
	// 8219BDFC: 7D44F02E  lwzx r10, r4, r30
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE00: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219BE04: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	// 8219BE08: 419A0010  beq cr6, 0x8219be18
	if ctx.cr[6].eq {
	pc = 0x8219BE18; continue 'dispatch;
	}
	// 8219BE0C: 813F00D0  lwz r9, 0xd0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 8219BE10: 7F0B4800  cmpw cr6, r11, r9
	ctx.cr[6].compare_i32(ctx.r[11].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8219BE14: 409A0020  bne cr6, 0x8219be34
	if !ctx.cr[6].eq {
	pc = 0x8219BE34; continue 'dispatch;
	}
	pc = 0x8219BE18; continue 'dispatch;
            }
            0x8219BE18 => {
    //   block [0x8219BE18..0x8219BE34)
	// 8219BE18: 7D3CF02E  lwzx r9, r28, r30
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE1C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219BE20: 419A00A8  beq cr6, 0x8219bec8
	if ctx.cr[6].eq {
	pc = 0x8219BEC8; continue 'dispatch;
	}
	// 8219BE24: 813F00D4  lwz r9, 0xd4(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 8219BE28: 811F00CC  lwz r8, 0xcc(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219BE2C: 7F084800  cmpw cr6, r8, r9
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[9].s32, &mut ctx.xer);
	// 8219BE30: 419A0098  beq cr6, 0x8219bec8
	if ctx.cr[6].eq {
	pc = 0x8219BEC8; continue 'dispatch;
	}
	pc = 0x8219BE34; continue 'dispatch;
            }
            0x8219BE34 => {
    //   block [0x8219BE34..0x8219BE50)
	// 8219BE34: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219BE38: 419A0018  beq cr6, 0x8219be50
	if ctx.cr[6].eq {
	pc = 0x8219BE50; continue 'dispatch;
	}
	// 8219BE3C: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219BE40: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219BE44: 4BFFEA45  bl 0x8219a888
	ctx.lr = 0x8219BE48;
	sub_8219A888(ctx, base);
	// 8219BE48: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219BE4C: 48000008  b 0x8219be54
	pc = 0x8219BE54; continue 'dispatch;
            }
            0x8219BE50 => {
    //   block [0x8219BE50..0x8219BE54)
	// 8219BE50: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8219BE54; continue 'dispatch;
            }
            0x8219BE54 => {
    //   block [0x8219BE54..0x8219BE74)
	// 8219BE54: 7D7CF02E  lwzx r11, r28, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[28].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219BE58: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219BE5C: 419A0018  beq cr6, 0x8219be74
	if ctx.cr[6].eq {
	pc = 0x8219BE74; continue 'dispatch;
	}
	// 8219BE60: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219BE64: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219BE68: 4BFFEA21  bl 0x8219a888
	ctx.lr = 0x8219BE6C;
	sub_8219A888(ctx, base);
	// 8219BE6C: 7C6A1B78  mr r10, r3
	ctx.r[10].u64 = ctx.r[3].u64;
	// 8219BE70: 48000008  b 0x8219be78
	pc = 0x8219BE78; continue 'dispatch;
            }
            0x8219BE74 => {
    //   block [0x8219BE74..0x8219BE78)
	// 8219BE74: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8219BE78; continue 'dispatch;
            }
            0x8219BE78 => {
    //   block [0x8219BE78..0x8219BE84)
	// 8219BE78: 7F1D5000  cmpw cr6, r29, r10
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[10].s32, &mut ctx.xer);
	// 8219BE7C: 41980008  blt cr6, 0x8219be84
	if ctx.cr[6].lt {
	pc = 0x8219BE84; continue 'dispatch;
	}
	// 8219BE80: 7FAAEB78  mr r10, r29
	ctx.r[10].u64 = ctx.r[29].u64;
	pc = 0x8219BE84; continue 'dispatch;
            }
            0x8219BE84 => {
    //   block [0x8219BE84..0x8219BEB4)
	// 8219BE84: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219BE88: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219BE8C: 396BCFD0  addi r11, r11, -0x3030
	ctx.r[11].s64 = ctx.r[11].s64 + -12336;
	// 8219BE90: 7C4A5C2E  lfsx f2, r10, r11
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219BE94: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BE98: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BE9C: 3D6082B5  lis r11, -0x7d4b
	ctx.r[11].s64 = -2102067200;
	// 8219BEA0: FF020000  fcmpu cr6, f2, f0
	ctx.cr[6].compare_f64(ctx.f[2].f64, ctx.f[0].f64);
	// 8219BEA4: 396BFFD8  addi r11, r11, -0x28
	ctx.r[11].s64 = ctx.r[11].s64 + -40;
	// 8219BEA8: C02B0098  lfs f1, 0x98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(152 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219BEAC: 40980008  bge cr6, 0x8219beb4
	if !ctx.cr[6].lt {
	pc = 0x8219BEB4; continue 'dispatch;
	}
	// 8219BEB0: FC400890  fmr f2, f1
	ctx.f[2].f64 = ctx.f[1].f64;
	pc = 0x8219BEB4; continue 'dispatch;
            }
            0x8219BEB4 => {
    //   block [0x8219BEB4..0x8219BEC8)
	// 8219BEB4: 38C00046  li r6, 0x46
	ctx.r[6].s64 = 70;
	// 8219BEB8: 38600023  li r3, 0x23
	ctx.r[3].s64 = 35;
	// 8219BEBC: 38EB0098  addi r7, r11, 0x98
	ctx.r[7].s64 = ctx.r[11].s64 + 152;
	// 8219BEC0: 481DD7D9  bl 0x82379698
	ctx.lr = 0x8219BEC4;
	sub_82379698(ctx, base);
	// 8219BEC4: 817F00C8  lwz r11, 0xc8(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(200 as u32) ) } as u64;
	pc = 0x8219BEC8; continue 'dispatch;
            }
            0x8219BEC8 => {
    //   block [0x8219BEC8..0x8219BED4)
	// 8219BEC8: 917F00D0  stw r11, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[11].u32 ) };
	// 8219BECC: 817F00CC  lwz r11, 0xcc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219BED0: 917F00D4  stw r11, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[11].u32 ) };
	pc = 0x8219BED4; continue 'dispatch;
            }
            0x8219BED4 => {
    //   block [0x8219BED4..0x8219BEDC)
	// 8219BED4: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219BED8: 48399230  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BEE0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BEE0 size=156
    let mut pc: u32 = 0x8219BEE0;
    'dispatch: loop {
        match pc {
            0x8219BEE0 => {
    //   block [0x8219BEE0..0x8219BF68)
	// 8219BEE0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BEE4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219BEE8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219BEEC: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BEF0: 3D0082C0  lis r8, -0x7d40
	ctx.r[8].s64 = -2101346304;
	// 8219BEF4: 3CE00003  lis r7, 3
	ctx.r[7].s64 = 196608;
	// 8219BEF8: 3908BFF0  addi r8, r8, -0x4010
	ctx.r[8].s64 = ctx.r[8].s64 + -16400;
	// 8219BEFC: 60E79450  ori r7, r7, 0x9450
	ctx.r[7].u64 = ctx.r[7].u64 | 37968;
	// 8219BF00: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219BF04: 7C8A2378  mr r10, r4
	ctx.r[10].u64 = ctx.r[4].u64;
	// 8219BF08: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 8219BF0C: 7D083A2E  lhzx r8, r8, r7
	ctx.r[8].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 8219BF10: 2B080001  cmplwi cr6, r8, 1
	ctx.cr[6].compare_u32(ctx.r[8].u32, 1 as u32, &mut ctx.xer);
	// 8219BF14: 409A0054  bne cr6, 0x8219bf68
	if !ctx.cr[6].eq {
	pc = 0x8219BF68; continue 'dispatch;
	}
	// 8219BF18: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219BF1C: 99410051  stb r10, 0x51(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(81 as u32), ctx.r[10].u8 ) };
	// 8219BF20: 38E10054  addi r7, r1, 0x54
	ctx.r[7].s64 = ctx.r[1].s64 + 84;
	// 8219BF24: 99210052  stb r9, 0x52(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(82 as u32), ctx.r[9].u8 ) };
	// 8219BF28: 38C00004  li r6, 4
	ctx.r[6].s64 = 4;
	// 8219BF2C: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219BF30: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8219BF34: C0082094  lfs f0, 0x2094(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8340 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BF38: 3D000001  lis r8, 1
	ctx.r[8].s64 = 65536;
	// 8219BF3C: EC010032  fmuls f0, f1, f0
	ctx.f[0].f64 = (((ctx.f[1].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219BF40: 611FBE64  ori r31, r8, 0xbe64
	ctx.r[31].u64 = ctx.r[8].u64 | 48740;
	// 8219BF44: 3D00829A  lis r8, -0x7d66
	ctx.r[8].s64 = -2103836672;
	// 8219BF48: 386845D8  addi r3, r8, 0x45d8
	ctx.r[3].s64 = ctx.r[8].s64 + 17880;
	// 8219BF4C: 7D6BF8AE  lbzx r11, r11, r31
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[31].u32)) } as u64;
	// 8219BF50: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219BF54: 7C003FAE  stfiwx f0, 0, r7
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32, tmp.u32) };
	// 8219BF58: 99610050  stb r11, 0x50(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u8 ) };
	// 8219BF5C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219BF60: 99610053  stb r11, 0x53(r1)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[1].u32.wrapping_add(83 as u32), ctx.r[11].u8 ) };
	// 8219BF64: 4BFE0AB5  bl 0x8217ca18
	ctx.lr = 0x8219BF68;
	sub_8217CA18(ctx, base);
	pc = 0x8219BF68; continue 'dispatch;
            }
            0x8219BF68 => {
    //   block [0x8219BF68..0x8219BF7C)
	// 8219BF68: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219BF6C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219BF70: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219BF74: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219BF78: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219BF80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219BF80 size=940
    let mut pc: u32 = 0x8219BF80;
    'dispatch: loop {
        match pc {
            0x8219BF80 => {
    //   block [0x8219BF80..0x8219C040)
	// 8219BF80: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219BF84: 48399139  bl 0x825350bc
	ctx.lr = 0x8219BF88;
	sub_82535080(ctx, base);
	// 8219BF88: 9421FF30  stwu r1, -0xd0(r1)
	ea = ctx.r[1].u32.wrapping_add(-208 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219BF8C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219BF90: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219BF94: 3CE50504  addis r7, r5, 0x504
	ctx.r[7].s64 = ctx.r[5].s64 + 84148224;
	// 8219BF98: 3D208288  lis r9, -0x7d78
	ctx.r[9].s64 = -2105016320;
	// 8219BF9C: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8219BFA0: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219BFA4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219BFA8: 38E74000  addi r7, r7, 0x4000
	ctx.r[7].s64 = ctx.r[7].s64 + 16384;
	// 8219BFAC: 394B0B58  addi r10, r11, 0xb58
	ctx.r[10].s64 = ctx.r[11].s64 + 2904;
	// 8219BFB0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219BFB4: 3BA00030  li r29, 0x30
	ctx.r[29].s64 = 48;
	// 8219BFB8: 39298E40  addi r9, r9, -0x71c0
	ctx.r[9].s64 = ctx.r[9].s64 + -29120;
	// 8219BFBC: 3BFE00B8  addi r31, r30, 0xb8
	ctx.r[31].s64 = ctx.r[30].s64 + 184;
	// 8219BFC0: 915E0000  stw r10, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219BFC4: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219BFC8: 917E0080  stw r11, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219BFCC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219BFD0: 394AC470  addi r10, r10, -0x3b90
	ctx.r[10].s64 = ctx.r[10].s64 + -15248;
	// 8219BFD4: B17E0084  sth r11, 0x84(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 8219BFD8: B17E0086  sth r11, 0x86(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 8219BFDC: 38800F00  li r4, 0xf00
	ctx.r[4].s64 = 3840;
	// 8219BFE0: 917E00B8  stw r11, 0xb8(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[11].u32 ) };
	// 8219BFE4: 386A0030  addi r3, r10, 0x30
	ctx.r[3].s64 = ctx.r[10].s64 + 48;
	// 8219BFE8: 991E001E  stb r8, 0x1e(r30)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[30].u32.wrapping_add(30 as u32), ctx.r[8].u8 ) };
	// 8219BFEC: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219BFF0: 917E00A4  stw r11, 0xa4(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(164 as u32), ctx.r[11].u32 ) };
	// 8219BFF4: 917E0098  stw r11, 0x98(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u32 ) };
	// 8219BFF8: 90FE0088  stw r7, 0x88(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 8219BFFC: 911E008C  stw r8, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[8].u32 ) };
	// 8219C000: 93BE0094  stw r29, 0x94(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(148 as u32), ctx.r[29].u32 ) };
	// 8219C004: D01E009C  stfs f0, 0x9c(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(156 as u32), tmp.u32 ) };
	// 8219C008: D01E00A0  stfs f0, 0xa0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219C00C: 913E0080  stw r9, 0x80(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219C010: B17E0084  sth r11, 0x84(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(132 as u32), ctx.r[11].u16 ) };
	// 8219C014: B17E0086  sth r11, 0x86(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(134 as u32), ctx.r[11].u16 ) };
	// 8219C018: 48005C19  bl 0x821a1c30
	ctx.lr = 0x8219C01C;
	sub_821A1C30(ctx, base);
	// 8219C01C: 817E00B8  lwz r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C020: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C024: 419A02FC  beq cr6, 0x8219c320
	if ctx.cr[6].eq {
	pc = 0x8219C320; continue 'dispatch;
	}
	// 8219C028: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219C02C: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219C030: 39600002  li r11, 2
	ctx.r[11].s64 = 2;
	// 8219C034: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 8219C038: C008BA38  lfs f0, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C03C: C1A92950  lfs f13, 0x2950(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10576 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8219C040; continue 'dispatch;
            }
            0x8219C040 => {
    //   block [0x8219C040..0x8219C320)
	// 8219C040: 38ABFFFF  addi r5, r11, -1
	ctx.r[5].s64 = ctx.r[11].s64 + -1;
	// 8219C044: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C048: 38CBFFFF  addi r6, r11, -1
	ctx.r[6].s64 = ctx.r[11].s64 + -1;
	// 8219C04C: 54A5F87E  srwi r5, r5, 1
	ctx.r[5].u32 = ctx.r[5].u32.wrapping_shr(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219C050: 78C607E0  clrldi r6, r6, 0x3f
	ctx.r[6].u64 = ctx.r[6].u64 & 0x0000000000000001u64;
	// 8219C054: 78A50020  clrldi r5, r5, 0x20
	ctx.r[5].u64 = ctx.r[5].u64 & 0x00000000FFFFFFFFu64;
	// 8219C058: 390BFFFE  addi r8, r11, -2
	ctx.r[8].s64 = ctx.r[11].s64 + -2;
	// 8219C05C: 5564F87E  srwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219C060: 38EAFF70  addi r7, r10, -0x90
	ctx.r[7].s64 = ctx.r[10].s64 + -144;
	// 8219C064: F8C10050  std r6, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[6].u64 ) };
	// 8219C068: 790607E0  clrldi r6, r8, 0x3f
	ctx.r[6].u64 = ctx.r[8].u64 & 0x0000000000000001u64;
	// 8219C06C: F8A10058  std r5, 0x58(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[5].u64 ) };
	// 8219C070: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C074: 78840020  clrldi r4, r4, 0x20
	ctx.r[4].u64 = ctx.r[4].u64 & 0x00000000FFFFFFFFu64;
	// 8219C078: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C07C: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8219C080: F8C10068  std r6, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[6].u64 ) };
	// 8219C084: 38CB0003  addi r6, r11, 3
	ctx.r[6].s64 = ctx.r[11].s64 + 3;
	// 8219C088: F8810060  std r4, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[4].u64 ) };
	// 8219C08C: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C090: F9010070  std r8, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.r[8].u64 ) };
	// 8219C094: 390B0001  addi r8, r11, 1
	ctx.r[8].s64 = ctx.r[11].s64 + 1;
	// 8219C098: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C09C: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C0A0: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C0A4: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C0A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C0AC: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C0B0: F9010078  std r8, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.r[8].u64 ) };
	// 8219C0B4: 78C80020  clrldi r8, r6, 0x20
	ctx.r[8].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C0B8: F9010088  std r8, 0x88(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), ctx.r[8].u64 ) };
	// 8219C0BC: C9810050  lfd f12, 0x50(r1)
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C0C0: C9610058  lfd f11, 0x58(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	// 8219C0C4: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219C0C8: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C0CC: C9410060  lfd f10, 0x60(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219C0D0: C9010070  lfd f8, 0x70(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	// 8219C0D4: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C0D8: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C0DC: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219C0E0: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C0E4: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C0E8: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C0EC: ED2B037C  fnmsubs f9, f11, f13, f0
	ctx.f[9].f64 = -(((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C0F0: C9610068  lfd f11, 0x68(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219C0F4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C0F8: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C0FC: ED08037C  fnmsubs f8, f8, f13, f0
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C100: D1090020  stfs f8, 0x20(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C104: C9010088  lfd f8, 0x88(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	// 8219C108: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C10C: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C110: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C114: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C118: 7D274A14  add r9, r7, r9
	ctx.r[9].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 8219C11C: 38EB0002  addi r7, r11, 2
	ctx.r[7].s64 = ctx.r[11].s64 + 2;
	// 8219C120: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8219C124: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C128: 78E70020  clrldi r7, r7, 0x20
	ctx.r[7].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 8219C12C: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C130: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C134: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C138: F8E10080  std r7, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.r[7].u64 ) };
	// 8219C13C: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C140: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C144: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C148: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C14C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C150: 3929FFD0  addi r9, r9, -0x30
	ctx.r[9].s64 = ctx.r[9].s64 + -48;
	// 8219C154: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C158: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C15C: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C160: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C164: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C168: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C16C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C170: C9410078  lfd f10, 0x78(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	// 8219C174: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C178: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C17C: C9210080  lfd f9, 0x80(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	// 8219C180: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8219C184: 390B0004  addi r8, r11, 4
	ctx.r[8].s64 = ctx.r[11].s64 + 4;
	// 8219C188: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C18C: 38EB0005  addi r7, r11, 5
	ctx.r[7].s64 = ctx.r[11].s64 + 5;
	// 8219C190: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C194: 5508F87E  srwi r8, r8, 1
	ctx.r[8].u32 = ctx.r[8].u32.wrapping_shr(1);
	ctx.r[8].u64 = ctx.r[8].u32 as u64;
	// 8219C198: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C19C: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C1A0: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C1A4: 79080020  clrldi r8, r8, 0x20
	ctx.r[8].u64 = ctx.r[8].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C1AC: 38CB0006  addi r6, r11, 6
	ctx.r[6].s64 = ctx.r[11].s64 + 6;
	// 8219C1B0: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8219C1B4: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C1B8: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C1BC: F9010090  std r8, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[8].u64 ) };
	// 8219C1C0: 78E80020  clrldi r8, r7, 0x20
	ctx.r[8].u64 = ctx.r[7].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1C4: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1C8: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C1CC: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C1D0: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C1D4: 78C70020  clrldi r7, r6, 0x20
	ctx.r[7].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1D8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C1DC: F9010098  std r8, 0x98(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), ctx.r[8].u64 ) };
	// 8219C1E0: 38CB0007  addi r6, r11, 7
	ctx.r[6].s64 = ctx.r[11].s64 + 7;
	// 8219C1E4: 39290030  addi r9, r9, 0x30
	ctx.r[9].s64 = ctx.r[9].s64 + 48;
	// 8219C1E8: ED29037C  fnmsubs f9, f9, f13, f0
	ctx.f[9].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1EC: ED08037C  fnmsubs f8, f8, f13, f0
	ctx.f[8].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C1F0: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C1F4: F8E100A0  std r7, 0xa0(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), ctx.r[7].u64 ) };
	// 8219C1F8: 78C80020  clrldi r8, r6, 0x20
	ctx.r[8].u64 = ctx.r[6].u64 & 0x00000000FFFFFFFFu64;
	// 8219C1FC: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C200: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C204: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C208: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C20C: F90100A8  std r8, 0xa8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), ctx.r[8].u64 ) };
	// 8219C210: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C214: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C218: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C21C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C220: 39290060  addi r9, r9, 0x60
	ctx.r[9].s64 = ctx.r[9].s64 + 96;
	// 8219C224: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C228: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C22C: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C230: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C234: D1090020  stfs f8, 0x20(r9)
	tmp.f32 = (ctx.f[8].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C238: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C23C: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C240: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C244: 39290090  addi r9, r9, 0x90
	ctx.r[9].s64 = ctx.r[9].s64 + 144;
	// 8219C248: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C24C: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C250: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C254: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C258: C9410090  lfd f10, 0x90(r1)
	ctx.f[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 8219C25C: FD40569C  fcfid f10, f10
	ctx.f[10].f64 = (ctx.f[10].s64 as f64);
	// 8219C260: C9210098  lfd f9, 0x98(r1)
	ctx.f[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	// 8219C264: FD204E9C  fcfid f9, f9
	ctx.f[9].f64 = (ctx.f[9].s64 as f64);
	// 8219C268: C90100A0  lfd f8, 0xa0(r1)
	ctx.f[8].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	// 8219C26C: FD00469C  fcfid f8, f8
	ctx.f[8].f64 = (ctx.f[8].s64 as f64);
	// 8219C270: FD405018  frsp f10, f10
	ctx.f[10].f64 = (ctx.f[10].f64 as f32) as f64;
	// 8219C274: FD204818  frsp f9, f9
	ctx.f[9].f64 = (ctx.f[9].f64 as f32) as f64;
	// 8219C278: FD004018  frsp f8, f8
	ctx.f[8].f64 = (ctx.f[8].f64 as f32) as f64;
	// 8219C27C: ED4A037C  fnmsubs f10, f10, f13, f0
	ctx.f[10].f64 = -(((ctx.f[10].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C280: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C284: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C288: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C28C: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C290: 392900C0  addi r9, r9, 0xc0
	ctx.r[9].s64 = ctx.r[9].s64 + 192;
	// 8219C294: ED49037C  fnmsubs f10, f9, f13, f0
	ctx.f[10].f64 = -(((ctx.f[9].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C298: ED28037C  fnmsubs f9, f8, f13, f0
	ctx.f[9].f64 = -(((ctx.f[8].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C29C: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2A0: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2A4: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C2A8: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C2AC: D1490020  stfs f10, 0x20(r9)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C2B0: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C2B4: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C2B8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C2BC: 392900F0  addi r9, r9, 0xf0
	ctx.r[9].s64 = ctx.r[9].s64 + 240;
	// 8219C2C0: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2C4: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2C8: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C2CC: 396B000A  addi r11, r11, 0xa
	ctx.r[11].s64 = ctx.r[11].s64 + 10;
	// 8219C2D0: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C2D4: D1290020  stfs f9, 0x20(r9)
	tmp.f32 = (ctx.f[9].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C2D8: D1690024  stfs f11, 0x24(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C2DC: 813F0000  lwz r9, 0(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C2E0: C96100A8  lfd f11, 0xa8(r1)
	ctx.f[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	// 8219C2E4: FD605E9C  fcfid f11, f11
	ctx.f[11].f64 = (ctx.f[11].s64 as f64);
	// 8219C2E8: 7D2A4A14  add r9, r10, r9
	ctx.r[9].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219C2EC: 394A01E0  addi r10, r10, 0x1e0
	ctx.r[10].s64 = ctx.r[10].s64 + 480;
	// 8219C2F0: 39290120  addi r9, r9, 0x120
	ctx.r[9].s64 = ctx.r[9].s64 + 288;
	// 8219C2F4: D0090010  stfs f0, 0x10(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C2F8: D0090014  stfs f0, 0x14(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C2FC: D0090018  stfs f0, 0x18(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C300: FD605818  frsp f11, f11
	ctx.f[11].f64 = (ctx.f[11].f64 as f32) as f64;
	// 8219C304: D009001C  stfs f0, 0x1c(r9)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C308: ED6B037C  fnmsubs f11, f11, f13, f0
	ctx.f[11].f64 = -(((ctx.f[11].f64 * ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C30C: D1690020  stfs f11, 0x20(r9)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C310: D1890024  stfs f12, 0x24(r9)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C314: 392BFFFE  addi r9, r11, -2
	ctx.r[9].s64 = ctx.r[11].s64 + -2;
	// 8219C318: 2B090028  cmplwi cr6, r9, 0x28
	ctx.cr[6].compare_u32(ctx.r[9].u32, 40 as u32, &mut ctx.xer);
	// 8219C31C: 4198FD24  blt cr6, 0x8219c040
	if ctx.cr[6].lt {
	pc = 0x8219C040; continue 'dispatch;
	}
	pc = 0x8219C320; continue 'dispatch;
            }
            0x8219C320 => {
    //   block [0x8219C320..0x8219C32C)
	// 8219C320: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219C324: 382100D0  addi r1, r1, 0xd0
	ctx.r[1].s64 = ctx.r[1].s64 + 208;
	// 8219C328: 48398DE4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C330(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219C330 size=156
    let mut pc: u32 = 0x8219C330;
    'dispatch: loop {
        match pc {
            0x8219C330 => {
    //   block [0x8219C330..0x8219C378)
	// 8219C330: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C334: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C338: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219C33C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C340: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C344: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219C348: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219C34C: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219C350: 396B0B58  addi r11, r11, 0xb58
	ctx.r[11].s64 = ctx.r[11].s64 + 2904;
	// 8219C354: 389F00B8  addi r4, r31, 0xb8
	ctx.r[4].s64 = ctx.r[31].s64 + 184;
	// 8219C358: 815F00B8  lwz r10, 0xb8(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C35C: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C360: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C364: 419A0014  beq cr6, 0x8219c378
	if ctx.cr[6].eq {
	pc = 0x8219C378; continue 'dispatch;
	}
	// 8219C368: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219C36C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219C370: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8219C374: 48005D0D  bl 0x821a2080
	ctx.lr = 0x8219C378;
	sub_821A2080(ctx, base);
	pc = 0x8219C378; continue 'dispatch;
            }
            0x8219C378 => {
    //   block [0x8219C378..0x8219C3B4)
	// 8219C378: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219C37C: 57CA07FE  clrlwi r10, r30, 0x1f
	ctx.r[10].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8219C380: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8219C384: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C388: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C38C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C390: 419A0024  beq cr6, 0x8219c3b4
	if ctx.cr[6].eq {
	pc = 0x8219C3B4; continue 'dispatch;
	}
	// 8219C394: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219C398: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219C39C: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219C3A0: 409A0014  bne cr6, 0x8219c3b4
	if !ctx.cr[6].eq {
	pc = 0x8219C3B4; continue 'dispatch;
	}
	// 8219C3A4: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219C3A8: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C3AC: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219C3B0: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8219C3B4; continue 'dispatch;
            }
            0x8219C3B4 => {
    //   block [0x8219C3B4..0x8219C3CC)
	// 8219C3B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C3B8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C3BC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C3C0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219C3C4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C3C8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C3D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C3D0 size=492
    let mut pc: u32 = 0x8219C3D0;
    'dispatch: loop {
        match pc {
            0x8219C3D0 => {
    //   block [0x8219C3D0..0x8219C400)
	// 8219C3D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C3D4: 48398CE9  bl 0x825350bc
	ctx.lr = 0x8219C3D8;
	sub_82535080(ctx, base);
	// 8219C3D8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C3DC: 7C691B78  mr r9, r3
	ctx.r[9].u64 = ctx.r[3].u64;
	// 8219C3E0: 816900B8  lwz r11, 0xb8(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C3E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C3E8: 419A01CC  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C3EC: 81490010  lwz r10, 0x10(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219C3F0: 816A00C4  lwz r11, 0xc4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(196 as u32) ) } as u64;
	// 8219C3F4: 2F0B0014  cmpwi cr6, r11, 0x14
	ctx.cr[6].compare_i32(ctx.r[11].s32, 20, &mut ctx.xer);
	// 8219C3F8: 41980008  blt cr6, 0x8219c400
	if ctx.cr[6].lt {
	pc = 0x8219C400; continue 'dispatch;
	}
	// 8219C3FC: 39600014  li r11, 0x14
	ctx.r[11].s64 = 20;
	pc = 0x8219C400; continue 'dispatch;
            }
            0x8219C400 => {
    //   block [0x8219C400..0x8219C424)
	// 8219C400: 557FF87E  srwi r31, r11, 1
	ctx.r[31].u32 = ctx.r[11].u32.wrapping_shr(1);
	ctx.r[31].u64 = ctx.r[31].u32 as u64;
	// 8219C404: 810A00CC  lwz r8, 0xcc(r10)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(204 as u32) ) } as u64;
	// 8219C408: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219C40C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219C410: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219C414: 419A01A0  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C418: 3CE0820D  lis r7, -0x7df3
	ctx.r[7].s64 = -2113077248;
	// 8219C41C: 39680034  addi r11, r8, 0x34
	ctx.r[11].s64 = ctx.r[8].s64 + 52;
	// 8219C420: C007BFFC  lfs f0, -0x4004(r7)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[7].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x8219C424; continue 'dispatch;
            }
            0x8219C424 => {
    //   block [0x8219C424..0x8219C510)
	// 8219C424: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219C428: 419A00E8  beq cr6, 0x8219c510
	if ctx.cr[6].eq {
	pc = 0x8219C510; continue 'dispatch;
	}
	// 8219C42C: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8219C430: C1AA0004  lfs f13, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C434: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C438: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C43C: 54E5083C  slwi r5, r7, 1
	ctx.r[5].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219C440: C18A0008  lfs f12, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C444: C16A0000  lfs f11, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C448: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C44C: 7CE72A14  add r7, r7, r5
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[5].u64;
	// 8219C450: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C454: C14BFFD8  lfs f10, -0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-40 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C458: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 8219C45C: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C460: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C464: D146000C  stfs f10, 0xc(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219C468: C14BFFD0  lfs f10, -0x30(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-48 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C46C: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219C470: C12BFFD4  lfs f9, -0x2c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-44 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C474: C1480000  lfs f10, 0(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C478: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219C47C: ED6A583A  fmadds f11, f10, f0, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219C480: D1A60004  stfs f13, 4(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219C484: D1660000  stfs f11, 0(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219C488: D1860008  stfs f12, 8(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C48C: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C490: C18A001C  lfs f12, 0x1c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C494: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C498: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C49C: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8219C4A0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4A4: D1A6001C  stfs f13, 0x1c(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C4A8: C1AA0034  lfs f13, 0x34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(52 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C4AC: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C4B0: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4B4: C16A0030  lfs f11, 0x30(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C4B8: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C4BC: C18A0038  lfs f12, 0x38(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(56 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C4C0: ED6B0032  fmuls f11, f11, f0
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4C4: C14B0008  lfs f10, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4C8: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C4CC: D146003C  stfs f10, 0x3c(r6)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(60 as u32), tmp.u32 ) };
	// 8219C4D0: C14B0000  lfs f10, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4D4: C12B0004  lfs f9, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C4D8: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219C4DC: C14BFFFC  lfs f10, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219C4E0: ED6A583A  fmadds f11, f10, f0, f11
	ctx.f[11].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219C4E4: D1660030  stfs f11, 0x30(r6)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(48 as u32), tmp.u32 ) };
	// 8219C4E8: D1A60034  stfs f13, 0x34(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(52 as u32), tmp.u32 ) };
	// 8219C4EC: ED89603A  fmadds f12, f9, f0, f12
	ctx.f[12].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219C4F0: D1860038  stfs f12, 0x38(r6)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(56 as u32), tmp.u32 ) };
	// 8219C4F4: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C4F8: C18A004C  lfs f12, 0x4c(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(76 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C4FC: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C500: 7D473214  add r10, r7, r6
	ctx.r[10].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C504: EDAD602A  fadds f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[12].f64) as f32) as f64;
	// 8219C508: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C50C: D1AA004C  stfs f13, 0x4c(r10)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(76 as u32), tmp.u32 ) };
	pc = 0x8219C510; continue 'dispatch;
            }
            0x8219C510 => {
    //   block [0x8219C510..0x8219C5B4)
	// 8219C510: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8219C514: 808900B8  lwz r4, 0xb8(r9)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C518: 7D064378  mr r6, r8
	ctx.r[6].u64 = ctx.r[8].u64;
	// 8219C51C: 54FE083C  slwi r30, r7, 1
	ctx.r[30].u32 = ctx.r[7].u32.wrapping_shl(1);
	ctx.r[30].u64 = ctx.r[30].u32 as u64;
	// 8219C520: 38ABFFFC  addi r5, r11, -4
	ctx.r[5].s64 = ctx.r[11].s64 + -4;
	// 8219C524: 7CE7F214  add r7, r7, r30
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[30].u64;
	// 8219C528: 3BFFFFFF  addi r31, r31, -1
	ctx.r[31].s64 = ctx.r[31].s64 + -1;
	// 8219C52C: 54E72036  slwi r7, r7, 4
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shl(4);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C530: EBA60000  ld r29, 0(r6)
	ctx.r[29].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	// 8219C534: 7D0A4378  mr r10, r8
	ctx.r[10].u64 = ctx.r[8].u64;
	// 8219C538: 7C872214  add r4, r7, r4
	ctx.r[4].u64 = ctx.r[7].u64 + ctx.r[4].u64;
	// 8219C53C: 38630002  addi r3, r3, 2
	ctx.r[3].s64 = ctx.r[3].s64 + 2;
	// 8219C540: 39080060  addi r8, r8, 0x60
	ctx.r[8].s64 = ctx.r[8].s64 + 96;
	// 8219C544: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219C548: FBA40000  std r29, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[29].u64 ) };
	// 8219C54C: E8C60008  ld r6, 8(r6)
	ctx.r[6].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	// 8219C550: F8C40008  std r6, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[6].u64 ) };
	// 8219C554: C1ABFFE8  lfs f13, -0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C558: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C55C: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C560: D1A6001C  stfs f13, 0x1c(r6)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C564: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C568: E8850000  ld r4, 0(r5)
	ctx.r[4].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(0 as u32) ) };
	// 8219C56C: 7CC73214  add r6, r7, r6
	ctx.r[6].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C570: 38C60030  addi r6, r6, 0x30
	ctx.r[6].s64 = ctx.r[6].s64 + 48;
	// 8219C574: F8860000  std r4, 0(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[4].u64 ) };
	// 8219C578: E8A50008  ld r5, 8(r5)
	ctx.r[5].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[5].u32.wrapping_add(8 as u32) ) };
	// 8219C57C: F8A60008  std r5, 8(r6)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[6].u32.wrapping_add(8 as u32), ctx.r[5].u64 ) };
	// 8219C580: C1AB0018  lfs f13, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C584: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C588: 396B0060  addi r11, r11, 0x60
	ctx.r[11].s64 = ctx.r[11].s64 + 96;
	// 8219C58C: 7CE73214  add r7, r7, r6
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[6].u64;
	// 8219C590: D1A7004C  stfs f13, 0x4c(r7)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(76 as u32), tmp.u32 ) };
	// 8219C594: 409AFE90  bne cr6, 0x8219c424
	if !ctx.cr[6].eq {
	pc = 0x8219C424; continue 'dispatch;
	}
	// 8219C598: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219C59C: 419A0018  beq cr6, 0x8219c5b4
	if ctx.cr[6].eq {
	pc = 0x8219C5B4; continue 'dispatch;
	}
	// 8219C5A0: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219C5A4: 80C900B8  lwz r6, 0xb8(r9)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(184 as u32) ) } as u64;
	// 8219C5A8: 38A90088  addi r5, r9, 0x88
	ctx.r[5].s64 = ctx.r[9].s64 + 136;
	// 8219C5AC: 38890080  addi r4, r9, 0x80
	ctx.r[4].s64 = ctx.r[9].s64 + 128;
	// 8219C5B0: 481D09C9  bl 0x8236cf78
	ctx.lr = 0x8219C5B4;
	sub_8236CF78(ctx, base);
	pc = 0x8219C5B4; continue 'dispatch;
            }
            0x8219C5B4 => {
    //   block [0x8219C5B4..0x8219C5BC)
	// 8219C5B4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219C5B8: 48398B54  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C5C0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C5C0 size=168
    let mut pc: u32 = 0x8219C5C0;
    'dispatch: loop {
        match pc {
            0x8219C5C0 => {
    //   block [0x8219C5C0..0x8219C60C)
	// 8219C5C0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C5C4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C5C8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219C5CC: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C5D0: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 8219C5D4: 80E40084  lwz r7, 0x84(r4)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 8219C5D8: 80C40080  lwz r6, 0x80(r4)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219C5DC: FD000890  fmr f8, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[8].f64 = ctx.f[1].f64;
	// 8219C5E0: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219C5E4: 7C892378  mr r9, r4
	ctx.r[9].u64 = ctx.r[4].u64;
	// 8219C5E8: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8219C5EC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C5F0: 409A001C  bne cr6, 0x8219c60c
	if !ctx.cr[6].eq {
	pc = 0x8219C60C; continue 'dispatch;
	}
	// 8219C5F4: 48013465  bl 0x821afa58
	ctx.lr = 0x8219C5F8;
	sub_821AFA58(ctx, base);
	// 8219C5F8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C5FC: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 8219C600: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C604: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C608: 40990008  ble cr6, 0x8219c610
	if !ctx.cr[6].gt {
	pc = 0x8219C610; continue 'dispatch;
	}
	pc = 0x8219C60C; continue 'dispatch;
            }
            0x8219C60C => {
    //   block [0x8219C60C..0x8219C610)
	// 8219C60C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	pc = 0x8219C610; continue 'dispatch;
            }
            0x8219C610 => {
    //   block [0x8219C610..0x8219C614)
	// 8219C610: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	pc = 0x8219C614; continue 'dispatch;
            }
            0x8219C614 => {
    //   block [0x8219C614..0x8219C644)
	// 8219C614: 554AF87E  srwi r10, r10, 1
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shr(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219C618: 39290010  addi r9, r9, 0x10
	ctx.r[9].s64 = ctx.r[9].s64 + 16;
	// 8219C61C: 554B07FE  clrlwi r11, r10, 0x1f
	ctx.r[11].u64 = ctx.r[10].u32 as u64 & 0x00000001u64;
	// 8219C620: 39080008  addi r8, r8, 8
	ctx.r[8].s64 = ctx.r[8].s64 + 8;
	// 8219C624: 54C6F87E  srwi r6, r6, 1
	ctx.r[6].u32 = ctx.r[6].u32.wrapping_shr(1);
	ctx.r[6].u64 = ctx.r[6].u32 as u64;
	// 8219C628: 54E7F87E  srwi r7, r7, 1
	ctx.r[7].u32 = ctx.r[7].u32.wrapping_shr(1);
	ctx.r[7].u64 = ctx.r[7].u32 as u64;
	// 8219C62C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219C630: 409A0014  bne cr6, 0x8219c644
	if !ctx.cr[6].eq {
	pc = 0x8219C644; continue 'dispatch;
	}
	// 8219C634: 7D244B78  mr r4, r9
	ctx.r[4].u64 = ctx.r[9].u64;
	// 8219C638: FC204090  fmr f1, f8
	ctx.f[1].f64 = ctx.f[8].f64;
	// 8219C63C: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8219C640: 48013419  bl 0x821afa58
	ctx.lr = 0x8219C644;
	sub_821AFA58(ctx, base);
	pc = 0x8219C644; continue 'dispatch;
            }
            0x8219C644 => {
    //   block [0x8219C644..0x8219C668)
	// 8219C644: 38A5FFFF  addi r5, r5, -1
	ctx.r[5].s64 = ctx.r[5].s64 + -1;
	// 8219C648: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219C64C: 409AFFC8  bne cr6, 0x8219c614
	if !ctx.cr[6].eq {
	pc = 0x8219C614; continue 'dispatch;
	}
	// 8219C650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219C654: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C658: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C65C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C660: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219C664: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C668(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C668 size=96
    let mut pc: u32 = 0x8219C668;
    'dispatch: loop {
        match pc {
            0x8219C668 => {
    //   block [0x8219C668..0x8219C69C)
	// 8219C668: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C66C: D0A3000C  stfs f5, 0xc(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[5].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219C670: 39400002  li r10, 2
	ctx.r[10].s64 = 2;
	// 8219C674: D0830010  stfs f4, 0x10(r3)
	tmp.f32 = (ctx.f[4].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219C678: 39200003  li r9, 3
	ctx.r[9].s64 = 3;
	// 8219C67C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C680: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219C684: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 8219C688: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219C68C: 91230004  stw r9, 4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 8219C690: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C694: 41990008  bgt cr6, 0x8219c69c
	if ctx.cr[6].gt {
	pc = 0x8219C69C; continue 'dispatch;
	}
	// 8219C698: FC206890  fmr f1, f13
	ctx.f[1].f64 = ctx.f[13].f64;
	pc = 0x8219C69C; continue 'dispatch;
            }
            0x8219C69C => {
    //   block [0x8219C69C..0x8219C6A8)
	// 8219C69C: FF030000  fcmpu cr6, f3, f0
	ctx.cr[6].compare_f64(ctx.f[3].f64, ctx.f[0].f64);
	// 8219C6A0: 41990008  bgt cr6, 0x8219c6a8
	if ctx.cr[6].gt {
	pc = 0x8219C6A8; continue 'dispatch;
	}
	// 8219C6A4: FC606890  fmr f3, f13
	ctx.f[3].f64 = ctx.f[13].f64;
	pc = 0x8219C6A8; continue 'dispatch;
            }
            0x8219C6A8 => {
    //   block [0x8219C6A8..0x8219C6C8)
	// 8219C6A8: C0030008  lfs f0, 8(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C6AC: EC040028  fsubs f0, f4, f0
	ctx.f[0].f64 = (((ctx.f[4].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C6B0: D023001C  stfs f1, 0x1c(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219C6B4: D0430020  stfs f2, 0x20(r3)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219C6B8: D0630024  stfs f3, 0x24(r3)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219C6BC: EC000824  fdivs f0, f0, f1
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[1].f64) as f32) as f64;
	// 8219C6C0: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C6C4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C6C8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C6C8 size=92
    let mut pc: u32 = 0x8219C6C8;
    'dispatch: loop {
        match pc {
            0x8219C6C8 => {
    //   block [0x8219C6C8..0x8219C71C)
	// 8219C6C8: 81630000  lwz r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219C6CC: C0230008  lfs f1, 8(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(8 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219C6D0: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219C6D4: 419A00C8  beq cr6, 0x8219c79c
	if ctx.cr[6].eq {
		sub_8219C79C(ctx, base);
		return;
	}
	// 8219C6D8: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219C6DC: 419A0048  beq cr6, 0x8219c724
	if ctx.cr[6].eq {
		sub_8219C724(ctx, base);
		return;
	}
	// 8219C6E0: 2F0B0003  cmpwi cr6, r11, 3
	ctx.cr[6].compare_i32(ctx.r[11].s32, 3, &mut ctx.xer);
	// 8219C6E4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8219C6E8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C6EC: C1A30018  lfs f13, 0x18(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C6F0: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C6F4: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C6F8: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C6FC: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C700: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C704: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C708: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C70C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 8219C710: 4199000C  bgt cr6, 0x8219c71c
	if ctx.cr[6].gt {
	pc = 0x8219C71C; continue 'dispatch;
	}
	// 8219C714: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219C718: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8219C71C; continue 'dispatch;
            }
            0x8219C71C => {
    //   block [0x8219C71C..0x8219C724)
	// 8219C71C: D0030018  stfs f0, 0x18(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C724(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C724 size=120
    let mut pc: u32 = 0x8219C724;
    'dispatch: loop {
        match pc {
            0x8219C724 => {
    //   block [0x8219C724..0x8219C75C)
	// 8219C724: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C728: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C72C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C730: C1830010  lfs f12, 0x10(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C734: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C738: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C73C: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C740: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C744: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 8219C748: C16B1FF8  lfs f11, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C74C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8219C750: 4098000C  bge cr6, 0x8219c75c
	if !ctx.cr[6].lt {
	pc = 0x8219C75C; continue 'dispatch;
	}
	// 8219C754: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 8219C758: 40990014  ble cr6, 0x8219c76c
	if !ctx.cr[6].gt {
	pc = 0x8219C76C; continue 'dispatch;
	}
	pc = 0x8219C75C; continue 'dispatch;
            }
            0x8219C75C => {
    //   block [0x8219C75C..0x8219C76C)
	// 8219C75C: FF005800  fcmpu cr6, f0, f11
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[11].f64);
	// 8219C760: 41980090  blt cr6, 0x8219c7f0
	if ctx.cr[6].lt {
		sub_8219C79C(ctx, base);
		return;
	}
	// 8219C764: FF016000  fcmpu cr6, f1, f12
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[12].f64);
	// 8219C768: 41980088  blt cr6, 0x8219c7f0
	if ctx.cr[6].lt {
		sub_8219C79C(ctx, base);
		return;
	}
	pc = 0x8219C76C; continue 'dispatch;
            }
            0x8219C76C => {
    //   block [0x8219C76C..0x8219C79C)
	// 8219C76C: C003000C  lfs f0, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C770: 81630004  lwz r11, 4(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219C774: EC006028  fsubs f0, f0, f12
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219C778: C1A30024  lfs f13, 0x24(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(36 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C77C: C1630020  lfs f11, 0x20(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C780: FC206090  fmr f1, f12
	ctx.f[1].f64 = ctx.f[12].f64;
	// 8219C784: D1630018  stfs f11, 0x18(r3)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219C788: D0230008  stfs f1, 8(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C78C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219C790: EC006824  fdivs f0, f0, f13
	ctx.f[0].f64 = ((ctx.f[0].f64 / ctx.f[13].f64) as f32) as f64;
	// 8219C794: D0030014  stfs f0, 0x14(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219C798: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C79C(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C79C size=92
    let mut pc: u32 = 0x8219C79C;
    'dispatch: loop {
        match pc {
            0x8219C79C => {
    //   block [0x8219C79C..0x8219C7D4)
	// 8219C79C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219C7A0: C0030014  lfs f0, 0x14(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C7A4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219C7A8: C163000C  lfs f11, 0xc(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(12 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219C7AC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219C7B0: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 8219C7B4: 7DAB542E  lfsx f13, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C7B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C7BC: EC200B7A  fmadds f1, f0, f13, f1
	ctx.f[1].f64 = (((ctx.f[0].f64 * ctx.f[13].f64 + ctx.f[1].f64) as f32) as f64);
	// 8219C7C0: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C7C4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8219C7C8: 4198000C  blt cr6, 0x8219c7d4
	if ctx.cr[6].lt {
	pc = 0x8219C7D4; continue 'dispatch;
	}
	// 8219C7CC: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 8219C7D0: 40980014  bge cr6, 0x8219c7e4
	if !ctx.cr[6].lt {
	pc = 0x8219C7E4; continue 'dispatch;
	}
	pc = 0x8219C7D4; continue 'dispatch;
            }
            0x8219C7D4 => {
    //   block [0x8219C7D4..0x8219C7E4)
	// 8219C7D4: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 8219C7D8: 40980018  bge cr6, 0x8219c7f0
	if !ctx.cr[6].lt {
	pc = 0x8219C7F0; continue 'dispatch;
	}
	// 8219C7DC: FF015800  fcmpu cr6, f1, f11
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[11].f64);
	// 8219C7E0: 41990010  bgt cr6, 0x8219c7f0
	if ctx.cr[6].gt {
	pc = 0x8219C7F0; continue 'dispatch;
	}
	pc = 0x8219C7E4; continue 'dispatch;
            }
            0x8219C7E4 => {
    //   block [0x8219C7E4..0x8219C7F0)
	// 8219C7E4: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219C7E8: FC205890  fmr f1, f11
	ctx.f[1].f64 = ctx.f[11].f64;
	// 8219C7EC: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	pc = 0x8219C7F0; continue 'dispatch;
            }
            0x8219C7F0 => {
    //   block [0x8219C7F0..0x8219C7F8)
	// 8219C7F0: D0230008  stfs f1, 8(r3)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219C7F4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C7F8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219C7F8 size=308
    let mut pc: u32 = 0x8219C7F8;
    'dispatch: loop {
        match pc {
            0x8219C7F8 => {
    //   block [0x8219C7F8..0x8219C80C)
	// 8219C7F8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219C7FC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219C800: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219C804: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219C808: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219C80C; continue 'dispatch;
            }
            0x8219C80C => {
    //   block [0x8219C80C..0x8219C868)
	// 8219C80C: 7D4B5214  add r10, r11, r10
	ctx.r[10].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219C810: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 8219C814: 394A0002  addi r10, r10, 2
	ctx.r[10].s64 = ctx.r[10].s64 + 2;
	// 8219C818: 2F0B0010  cmpwi cr6, r11, 0x10
	ctx.cr[6].compare_i32(ctx.r[11].s32, 16, &mut ctx.xer);
	// 8219C81C: 4198FFF0  blt cr6, 0x8219c80c
	if ctx.cr[6].lt {
	pc = 0x8219C80C; continue 'dispatch;
	}
	// 8219C820: 55432036  slwi r3, r10, 4
	ctx.r[3].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219C824: 4839744D  bl 0x82533c70
	ctx.lr = 0x8219C828;
	sub_82533C70(ctx, base);
	// 8219C828: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219C82C: 419A00FC  beq cr6, 0x8219c928
	if ctx.cr[6].eq {
	pc = 0x8219C928; continue 'dispatch;
	}
	// 8219C830: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219C834: 3CA0820A  lis r5, -0x7df6
	ctx.r[5].s64 = -2113273856;
	// 8219C838: 38EB1340  addi r7, r11, 0x1340
	ctx.r[7].s64 = ctx.r[11].s64 + 4928;
	// 8219C83C: 3CC0820D  lis r6, -0x7df3
	ctx.r[6].s64 = -2113077248;
	// 8219C840: 3D00820D  lis r8, -0x7df3
	ctx.r[8].s64 = -2113077248;
	// 8219C844: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219C848: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219C84C: C105BA38  lfs f8, -0x45c8(r5)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219C850: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219C854: C0A6219C  lfs f5, 0x219c(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8604 as u32) ) };
	ctx.f[5].f64 = (tmp.f32 as f64);
	// 8219C858: 38800010  li r4, 0x10
	ctx.r[4].s64 = 16;
	// 8219C85C: C1282120  lfs f9, 0x2120(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(8480 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219C860: C0C9BFFC  lfs f6, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[6].f64 = (tmp.f32 as f64);
	// 8219C864: C08B1FF8  lfs f4, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	pc = 0x8219C868; continue 'dispatch;
            }
            0x8219C868 => {
    //   block [0x8219C868..0x8219C8A0)
	// 8219C868: 7D4B07B4  extsw r11, r10
	ctx.r[11].s64 = ctx.r[10].s32 as i64;
	// 8219C86C: FC002090  fmr f0, f4
	ctx.f[0].f64 = ctx.f[4].f64;
	// 8219C870: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219C874: 90670000  stw r3, 0(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(0 as u32), ctx.r[3].u32 ) };
	// 8219C878: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219C87C: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219C880: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219C884: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219C888: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219C88C: ECE86824  fdivs f7, f8, f13
	ctx.f[7].f64 = ((ctx.f[8].f64 / ctx.f[13].f64) as f32) as f64;
	// 8219C890: 4198006C  blt cr6, 0x8219c8fc
	if ctx.cr[6].lt {
	pc = 0x8219C8FC; continue 'dispatch;
	}
	// 8219C894: 392A0001  addi r9, r10, 1
	ctx.r[9].s64 = ctx.r[10].s64 + 1;
	// 8219C898: 39630008  addi r11, r3, 8
	ctx.r[11].s64 = ctx.r[3].s64 + 8;
	// 8219C89C: 7D284B78  mr r8, r9
	ctx.r[8].u64 = ctx.r[9].u64;
	pc = 0x8219C8A0; continue 'dispatch;
            }
            0x8219C8A0 => {
    //   block [0x8219C8A0..0x8219C8FC)
	// 8219C8A0: ED680028  fsubs f11, f8, f0
	ctx.f[11].f64 = (((ctx.f[8].f64 - ctx.f[0].f64) as f32) as f64);
	// 8219C8A4: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8219C8A8: EDA001B2  fmuls f13, f0, f6
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[6].f64) as f32) as f64);
	// 8219C8AC: ED800032  fmuls f12, f0, f0
	ctx.f[12].f64 = (((ctx.f[0].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C8B0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219C8B4: EC6B02F2  fmuls f3, f11, f11
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219C8B8: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219C8BC: EC4C0032  fmuls f2, f12, f0
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219C8C0: ED6302F2  fmuls f11, f3, f11
	ctx.f[11].f64 = (((ctx.f[3].f64 * ctx.f[11].f64) as f32) as f64);
	// 8219C8C4: ED8A6028  fsubs f12, f10, f12
	ctx.f[12].f64 = (((ctx.f[10].f64 - ctx.f[12].f64) as f32) as f64);
	// 8219C8C8: EC620272  fmuls f3, f2, f9
	ctx.f[3].f64 = (((ctx.f[2].f64 * ctx.f[9].f64) as f32) as f64);
	// 8219C8CC: D06B0004  stfs f3, 4(r11)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219C8D0: ED6B0272  fmuls f11, f11, f9
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[9].f64) as f32) as f64);
	// 8219C8D4: D16BFFF8  stfs f11, -8(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8219C8D8: ED6D5038  fmsubs f11, f13, f0, f10
	ctx.f[11].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[10].f64) as f32) as f64);
	// 8219C8DC: ED8C282A  fadds f12, f12, f5
	ctx.f[12].f64 = ((ctx.f[12].f64 + ctx.f[5].f64) as f32) as f64;
	// 8219C8E0: D18BFFFC  stfs f12, -4(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219C8E4: EC07002A  fadds f0, f7, f0
	ctx.f[0].f64 = ((ctx.f[7].f64 + ctx.f[0].f64) as f32) as f64;
	// 8219C8E8: EDAB682A  fadds f13, f11, f13
	ctx.f[13].f64 = ((ctx.f[11].f64 + ctx.f[13].f64) as f32) as f64;
	// 8219C8EC: EDAD482A  fadds f13, f13, f9
	ctx.f[13].f64 = ((ctx.f[13].f64 + ctx.f[9].f64) as f32) as f64;
	// 8219C8F0: D1AB0000  stfs f13, 0(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219C8F4: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8219C8F8: 409AFFA8  bne cr6, 0x8219c8a0
	if !ctx.cr[6].eq {
	pc = 0x8219C8A0; continue 'dispatch;
	}
	pc = 0x8219C8FC; continue 'dispatch;
            }
            0x8219C8FC => {
    //   block [0x8219C8FC..0x8219C928)
	// 8219C8FC: 3884FFFF  addi r4, r4, -1
	ctx.r[4].s64 = ctx.r[4].s64 + -1;
	// 8219C900: 550B2036  slwi r11, r8, 4
	ctx.r[11].u32 = ctx.r[8].u32.wrapping_shl(4);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219C904: 38E70004  addi r7, r7, 4
	ctx.r[7].s64 = ctx.r[7].s64 + 4;
	// 8219C908: 7C6B1A14  add r3, r11, r3
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[3].u64;
	// 8219C90C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219C910: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219C914: 409AFF54  bne cr6, 0x8219c868
	if !ctx.cr[6].eq {
	pc = 0x8219C868; continue 'dispatch;
	}
	// 8219C918: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219C91C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219C920: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219C924: 4E800020  blr
	return;
            }
            0x8219C928 => {
    //   block [0x8219C928..0x8219C92C)
	// 8219C928: 48000000  b 0x8219c928
	pc = 0x8219C928; continue 'dispatch;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219C930(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x8219C930 size=352
    let mut pc: u32 = 0x8219C930;
    'dispatch: loop {
        match pc {
            0x8219C930 => {
    //   block [0x8219C930..0x8219C9F0)
	// 8219C930: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 8219C934: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219C938: 90E10034  stw r7, 0x34(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(52 as u32), ctx.r[7].u32 ) };
	// 8219C93C: 54CA103A  slwi r10, r6, 2
	ctx.r[10].u32 = ctx.r[6].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219C940: 396B1340  addi r11, r11, 0x1340
	ctx.r[11].s64 = ctx.r[11].s64 + 4928;
	// 8219C944: 38E5FFFF  addi r7, r5, -1
	ctx.r[7].s64 = ctx.r[5].s64 + -1;
	// 8219C948: 7C681B78  mr r8, r3
	ctx.r[8].u64 = ctx.r[3].u64;
	// 8219C94C: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219C950: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	// 8219C954: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219C958: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219C95C: 41980118  blt cr6, 0x8219ca74
	if ctx.cr[6].lt {
	pc = 0x8219CA74; continue 'dispatch;
	}
	// 8219C960: 3D20820A  lis r9, -0x7df6
	ctx.r[9].s64 = -2113273856;
	// 8219C964: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219C968: 39640018  addi r11, r4, 0x18
	ctx.r[11].s64 = ctx.r[4].s64 + 24;
	// 8219C96C: C1A9BA38  lfs f13, -0x45c8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219C970: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219C974: C1840000  lfs f12, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C978: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219C97C: D181FFB0  stfs f12, -0x50(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), tmp.u32 ) };
	// 8219C980: C18BFFEC  lfs f12, -0x14(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-20 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C984: D181FFB4  stfs f12, -0x4c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-76 as u32), tmp.u32 ) };
	// 8219C988: C18BFFF0  lfs f12, -0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C98C: D181FFB8  stfs f12, -0x48(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-72 as u32), tmp.u32 ) };
	// 8219C990: C18BFFF8  lfs f12, -8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C994: D181FFC0  stfs f12, -0x40(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), tmp.u32 ) };
	// 8219C998: C18BFFFC  lfs f12, -4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-4 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C99C: D181FFC4  stfs f12, -0x3c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-60 as u32), tmp.u32 ) };
	// 8219C9A0: C18B0000  lfs f12, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9A4: D181FFC8  stfs f12, -0x38(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-56 as u32), tmp.u32 ) };
	// 8219C9A8: C18B0008  lfs f12, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9AC: D181FFD0  stfs f12, -0x30(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), tmp.u32 ) };
	// 8219C9B0: C18B000C  lfs f12, 0xc(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9B4: D181FFD4  stfs f12, -0x2c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-44 as u32), tmp.u32 ) };
	// 8219C9B8: C18B0010  lfs f12, 0x10(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9BC: D181FFD8  stfs f12, -0x28(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), tmp.u32 ) };
	// 8219C9C0: C18B0018  lfs f12, 0x18(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(24 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9C4: D181FFE0  stfs f12, -0x20(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), tmp.u32 ) };
	// 8219C9C8: C18B001C  lfs f12, 0x1c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(28 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9CC: D181FFE4  stfs f12, -0x1c(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-28 as u32), tmp.u32 ) };
	// 8219C9D0: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219C9D4: D001FFBC  stfs f0, -0x44(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-68 as u32), tmp.u32 ) };
	// 8219C9D8: D001FFCC  stfs f0, -0x34(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-52 as u32), tmp.u32 ) };
	// 8219C9DC: D001FFDC  stfs f0, -0x24(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-36 as u32), tmp.u32 ) };
	// 8219C9E0: D1A1FFEC  stfs f13, -0x14(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-20 as u32), tmp.u32 ) };
	// 8219C9E4: D181FFE8  stfs f12, -0x18(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), tmp.u32 ) };
	// 8219C9E8: 409A0008  bne cr6, 0x8219c9f0
	if !ctx.cr[6].eq {
	pc = 0x8219C9F0; continue 'dispatch;
	}
	// 8219C9EC: 38C60001  addi r6, r6, 1
	ctx.r[6].s64 = ctx.r[6].s64 + 1;
	pc = 0x8219C9F0; continue 'dispatch;
            }
            0x8219C9F0 => {
    //   block [0x8219C9F0..0x8219CA60)
	// 8219C9F0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 8219C9F4: 4099006C  ble cr6, 0x8219ca60
	if !ctx.cr[6].gt {
	pc = 0x8219CA60; continue 'dispatch;
	}
	// 8219C9F8: 3BE1FFE0  addi r31, r1, -0x20
	ctx.r[31].s64 = ctx.r[1].s64 + -32;
	// 8219C9FC: 7CA92B78  mr r9, r5
	ctx.r[9].u64 = ctx.r[5].u64;
	// 8219CA00: 7CCA3378  mr r10, r6
	ctx.r[10].u64 = ctx.r[6].u64;
	// 8219CA04: 7C633214  add r3, r3, r6
	ctx.r[3].u64 = ctx.r[3].u64 + ctx.r[6].u64;
	pc = 0x8219CA60; continue 'dispatch;
            }
            0x8219CA60 => {
    //   block [0x8219CA60..0x8219CA74)
	// 8219CA60: 38E7FFFF  addi r7, r7, -1
	ctx.r[7].s64 = ctx.r[7].s64 + -1;
	// 8219CA64: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 8219CA68: 396B0010  addi r11, r11, 0x10
	ctx.r[11].s64 = ctx.r[11].s64 + 16;
	// 8219CA6C: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 8219CA70: 4098FF04  bge cr6, 0x8219c974
	if !ctx.cr[6].lt {
	pc = 0x8219C974; continue 'dispatch;
	}
	pc = 0x8219CA74; continue 'dispatch;
            }
            0x8219CA74 => {
    //   block [0x8219CA74..0x8219CA90)
	// 8219CA74: 39640020  addi r11, r4, 0x20
	ctx.r[11].s64 = ctx.r[4].s64 + 32;
	// 8219CA78: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219CA7C: F9480000  std r10, 0(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219CA80: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219CA84: F9680008  std r11, 8(r8)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219CA88: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 8219CA8C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CA90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CA90 size=300
    let mut pc: u32 = 0x8219CA90;
    'dispatch: loop {
        match pc {
            0x8219CA90 => {
    //   block [0x8219CA90..0x8219CADC)
	// 8219CA90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CA94: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219CA98: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219CA9C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219CAA0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CAA4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219CAA8: 9081008C  stw r4, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[4].u32 ) };
	// 8219CAAC: 816BBECC  lwz r11, -0x4134(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16692 as u32) ) } as u64;
	// 8219CAB0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219CAB4: 409A0028  bne cr6, 0x8219cadc
	if !ctx.cr[6].eq {
	pc = 0x8219CADC; continue 'dispatch;
	}
	// 8219CAB8: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219CABC: 38600100  li r3, 0x100
	ctx.r[3].s64 = 256;
	// 8219CAC0: 814BBED0  lwz r10, -0x4130(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16688 as u32) ) } as u64;
	// 8219CAC4: 394A0100  addi r10, r10, 0x100
	ctx.r[10].s64 = ctx.r[10].s64 + 256;
	// 8219CAC8: 914BBED0  stw r10, -0x4130(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-16688 as u32), ctx.r[10].u32 ) };
	// 8219CACC: 483971A5  bl 0x82533c70
	ctx.lr = 0x8219CAD0;
	sub_82533C70(ctx, base);
	// 8219CAD0: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219CAD4: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219CAD8: 409A000C  bne cr6, 0x8219cae4
	if !ctx.cr[6].eq {
	pc = 0x8219CAE4; continue 'dispatch;
	}
	pc = 0x8219CADC; continue 'dispatch;
            }
            0x8219CADC => {
    //   block [0x8219CADC..0x8219CAE4)
	// 8219CADC: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219CAE0: 480000C4  b 0x8219cba4
	pc = 0x8219CBA4; continue 'dispatch;
            }
            0x8219CAE4 => {
    //   block [0x8219CAE4..0x8219CB4C)
	// 8219CAE4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219CAE8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219CAEC: 396BFBB0  addi r11, r11, -0x450
	ctx.r[11].s64 = ctx.r[11].s64 + -1104;
	// 8219CAF0: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CAF4: 388B0010  addi r4, r11, 0x10
	ctx.r[4].s64 = ctx.r[11].s64 + 16;
	// 8219CAF8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219CAFC: C0291FF8  lfs f1, 0x1ff8(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CB00: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219CB04: 396B20B0  addi r11, r11, 0x20b0
	ctx.r[11].s64 = ctx.r[11].s64 + 8368;
	// 8219CB08: C04ABA38  lfs f2, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CB0C: 38E00010  li r7, 0x10
	ctx.r[7].s64 = 16;
	// 8219CB10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219CB14: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 8219CB18: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219CB1C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219CB20: 93EB0004  stw r31, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[31].u32 ) };
	// 8219CB24: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219CB28: 480130B9  bl 0x821afbe0
	ctx.lr = 0x8219CB2C;
	sub_821AFBE0(ctx, base);
	// 8219CB2C: 3D20820C  lis r9, -0x7df4
	ctx.r[9].s64 = -2113142784;
	// 8219CB30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219CB34: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219CB38: 389F0008  addi r4, r31, 8
	ctx.r[4].s64 = ctx.r[31].s64 + 8;
	// 8219CB3C: 3BC00010  li r30, 0x10
	ctx.r[30].s64 = 16;
	// 8219CB40: C169D6D0  lfs f11, -0x2930(r9)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219CB44: C18A20C8  lfs f12, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CB48: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	pc = 0x8219CB4C; continue 'dispatch;
            }
            0x8219CB4C => {
    //   block [0x8219CB4C..0x8219CBA4)
	// 8219CB4C: 481CA5ED  bl 0x82367138
	ctx.lr = 0x8219CB50;
	sub_82367138(ctx, base);
	// 8219CB50: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219CB54: C144FFF8  lfs f10, -8(r4)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-8 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219CB58: 3BDEFFFF  addi r30, r30, -1
	ctx.r[30].s64 = ctx.r[30].s64 + -1;
	// 8219CB5C: C124FFFC  lfs f9, -4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(-4 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219CB60: C1040000  lfs f8, 0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219CB64: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219CB68: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219CB6C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219CB70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219CB74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219CB78: EC000372  fmuls f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CB7C: EC005B3A  fmadds f0, f0, f12, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[12].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219CB80: ED4A0032  fmuls f10, f10, f0
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB84: D144FFF8  stfs f10, -8(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-8 as u32), tmp.u32 ) };
	// 8219CB88: ED490032  fmuls f10, f9, f0
	ctx.f[10].f64 = (((ctx.f[9].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB8C: D144FFFC  stfs f10, -4(r4)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(-4 as u32), tmp.u32 ) };
	// 8219CB90: EC080032  fmuls f0, f8, f0
	ctx.f[0].f64 = (((ctx.f[8].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CB94: D0040000  stfs f0, 0(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219CB98: 38840010  addi r4, r4, 0x10
	ctx.r[4].s64 = ctx.r[4].s64 + 16;
	// 8219CB9C: 409AFFB0  bne cr6, 0x8219cb4c
	if !ctx.cr[6].eq {
	pc = 0x8219CB4C; continue 'dispatch;
	}
	// 8219CBA0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	pc = 0x8219CBA4; continue 'dispatch;
            }
            0x8219CBA4 => {
    //   block [0x8219CBA4..0x8219CBBC)
	// 8219CBA4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219CBA8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CBAC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CBB0: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219CBB4: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219CBB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CBC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CBC0 size=712
    let mut pc: u32 = 0x8219CBC0;
    'dispatch: loop {
        match pc {
            0x8219CBC0 => {
    //   block [0x8219CBC0..0x8219CE88)
	// 8219CBC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CBC4: 483984F9  bl 0x825350bc
	ctx.lr = 0x8219CBC8;
	sub_82535080(ctx, base);
	// 8219CBC8: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8219CBCC: 9421FF00  stwu r1, -0x100(r1)
	ea = ctx.r[1].u32.wrapping_add(-256 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CBD0: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CBD4: FFE01090  fmr f31, f2
	ctx.f[31].f64 = ctx.f[2].f64;
	// 8219CBD8: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219CBDC: 7CFE3B78  mr r30, r7
	ctx.r[30].u64 = ctx.r[7].u64;
	// 8219CBE0: 7D3D4B78  mr r29, r9
	ctx.r[29].u64 = ctx.r[9].u64;
	// 8219CBE4: 481CB505  bl 0x823680e8
	ctx.lr = 0x8219CBE8;
	sub_823680E8(ctx, base);
	// 8219CBE8: C0010050  lfs f0, 0x50(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CBEC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219CBF0: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CBF4: D0010050  stfs f0, 0x50(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219CBF8: C0010060  lfs f0, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CBFC: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC00: D0010060  stfs f0, 0x60(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219CC04: C0010070  lfs f0, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC08: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC0C: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219CC10: C0010054  lfs f0, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC14: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC18: D0010054  stfs f0, 0x54(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219CC1C: C0010064  lfs f0, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC20: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC24: D0010064  stfs f0, 0x64(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219CC28: C0010074  lfs f0, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC2C: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC30: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219CC34: C0010058  lfs f0, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC38: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC3C: D0010058  stfs f0, 0x58(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219CC40: C0010068  lfs f0, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC44: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC48: D0010068  stfs f0, 0x68(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219CC4C: C0010078  lfs f0, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC50: EC0007F2  fmuls f0, f0, f31
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[31].f64) as f32) as f64);
	// 8219CC54: C07E0008  lfs f3, 8(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CC58: C05E0004  lfs f2, 4(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CC5C: C03E0000  lfs f1, 0(r30)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CC60: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219CC64: 481CB5B5  bl 0x82368218
	ctx.lr = 0x8219CC68;
	sub_82368218(ctx, base);
	// 8219CC68: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219CC6C: 38810050  addi r4, r1, 0x50
	ctx.r[4].s64 = ctx.r[1].s64 + 80;
	// 8219CC70: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219CC74: 481CB17D  bl 0x82367df0
	ctx.lr = 0x8219CC78;
	sub_82367DF0(ctx, base);
	// 8219CC78: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219CC7C: C01D0000  lfs f0, 0(r29)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC80: 394BD030  addi r10, r11, -0x2fd0
	ctx.r[10].s64 = ctx.r[11].s64 + -12240;
	// 8219CC84: D0010080  stfs f0, 0x80(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219CC88: C01D0004  lfs f0, 4(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CC8C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219CC90: D0010084  stfs f0, 0x84(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219CC94: C1A10050  lfs f13, 0x50(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CC98: 392B20B0  addi r9, r11, 0x20b0
	ctx.r[9].s64 = ctx.r[11].s64 + 8368;
	// 8219CC9C: C00A0000  lfs f0, 0(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CCA0: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CCA4: D1A10050  stfs f13, 0x50(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219CCA8: C1BD0008  lfs f13, 8(r29)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCAC: D1A10088  stfs f13, 0x88(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219CCB0: 81690004  lwz r11, 4(r9)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219CCB4: C1A10060  lfs f13, 0x60(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCB8: 81290000  lwz r9, 0(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219CCBC: EDA00372  fmuls f13, f0, f13
	ctx.f[13].f64 = (((ctx.f[0].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219CCC0: D1A10060  stfs f13, 0x60(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219CCC4: C1A10070  lfs f13, 0x70(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(112 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCC8: 2F090004  cmpwi cr6, r9, 4
	ctx.cr[6].compare_i32(ctx.r[9].s32, 4, &mut ctx.xer);
	// 8219CCCC: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCD0: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219CCD4: C00A0004  lfs f0, 4(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CCD8: C1A10054  lfs f13, 0x54(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCDC: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCE0: D1A10054  stfs f13, 0x54(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219CCE4: C1A10064  lfs f13, 0x64(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCE8: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCEC: D1A10064  stfs f13, 0x64(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219CCF0: C1A10074  lfs f13, 0x74(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(116 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CCF4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CCF8: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219CCFC: C00A0008  lfs f0, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CD00: C1A10058  lfs f13, 0x58(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD04: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD08: D1A10058  stfs f13, 0x58(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219CD0C: C1A10068  lfs f13, 0x68(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD10: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD14: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CD18: D1A10068  stfs f13, 0x68(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219CD1C: C1A10078  lfs f13, 0x78(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(120 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219CD20: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219CD24: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219CD28: C00ABA38  lfs f0, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CD2C: D001008C  stfs f0, 0x8c(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219CD30: 39410080  addi r10, r1, 0x80
	ctx.r[10].s64 = ctx.r[1].s64 + 128;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219CE88(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219CE88 size=608
    let mut pc: u32 = 0x8219CE88;
    'dispatch: loop {
        match pc {
            0x8219CE88 => {
    //   block [0x8219CE88..0x8219CEE0)
	// 8219CE88: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219CE8C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219CE90: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219CE94: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8219CE98: 3920FFFF  li r9, -1
	ctx.r[9].s64 = -1;
	// 8219CE9C: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8219CEA0: 40980040  bge cr6, 0x8219cee0
	if !ctx.cr[6].lt {
	pc = 0x8219CEE0; continue 'dispatch;
	}
	// 8219CEA4: 21250001  subfic r9, r5, 1
	ctx.xer.ca = ctx.r[5].u32 <= 1 as u32;
	ctx.r[9].s64 = (1 as i64) - ctx.r[5].s64;
	// 8219CEA8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219CEAC: 419A0228  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219CEB0: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219CEB4: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219CEB8: C08B000C  lfs f4, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219CEBC: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CEC0: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CEC4: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CEC8: 481E59B1  bl 0x82382878
	ctx.lr = 0x8219CECC;
	sub_82382878(ctx, base);
	// 8219CECC: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219CED0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219CED4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CED8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CEDC: 4E800020  blr
	return;
            }
            0x8219CEE0 => {
    //   block [0x8219CEE0..0x8219CF2C)
	// 8219CEE0: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 8219CEE4: 41980048  blt cr6, 0x8219cf2c
	if ctx.cr[6].lt {
	pc = 0x8219CF2C; continue 'dispatch;
	}
	// 8219CEE8: 3945FF00  addi r10, r5, -0x100
	ctx.r[10].s64 = ctx.r[5].s64 + -256;
	// 8219CEEC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219CEF0: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219CEF4: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219CEF8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219CEFC: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219CF00: 419A01D4  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219CF04: C08B000C  lfs f4, 0xc(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219CF08: C06B0008  lfs f3, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219CF0C: C04B0004  lfs f2, 4(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219CF10: C02B0000  lfs f1, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219CF14: 481E5965  bl 0x82382878
	ctx.lr = 0x8219CF18;
	sub_82382878(ctx, base);
	// 8219CF18: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219CF1C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219CF20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219CF24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219CF28: 4E800020  blr
	return;
            }
            0x8219CF2C => {
    //   block [0x8219CF2C..0x8219D064)
	// 8219CF2C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219CF30: 3965FF40  addi r11, r5, -0xc0
	ctx.r[11].s64 = ctx.r[5].s64 + -192;
	// 8219CF34: 2B0B003F  cmplwi cr6, r11, 0x3f
	ctx.cr[6].compare_u32(ctx.r[11].u32, 63 as u32, &mut ctx.xer);
	// 8219CF38: C00A1FF8  lfs f0, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219CF3C: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 8219CF40: C18ABA38  lfs f12, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219CF44: FDA06090  fmr f13, f12
	ctx.f[13].f64 = ctx.f[12].f64;
	// 8219CF48: 4199014C  bgt cr6, 0x8219d094
	if ctx.cr[6].gt {
	pc = 0x8219D094; continue 'dispatch;
	}
	// 8219CF4C: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219CF50: 398CCF64  addi r12, r12, -0x309c
	ctx.r[12].s64 = ctx.r[12].s64 + -12444;
	// 8219CF54: 5560103A  slwi r0, r11, 2
	ctx.r[0].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219CF58: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219CF5C: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219CF60: 4E800420  bctr
	match ctx.r[11].u64 {
		0 => {
	pc = 0x8219D064; continue 'dispatch;
		},
		1 => {
	pc = 0x8219D064; continue 'dispatch;
		},
		2 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		3 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		4 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		5 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		6 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		7 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		8 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		9 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		10 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		11 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		12 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		13 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		14 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		15 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		16 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		17 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		18 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		19 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		20 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		21 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		22 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		23 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		24 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		25 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		26 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		27 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		28 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		29 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		30 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		31 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		32 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		33 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		34 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		35 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		36 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		37 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		38 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		39 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		40 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		41 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		42 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		43 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		44 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		45 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		46 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		47 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		48 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		49 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		50 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		51 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		52 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		53 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		54 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		55 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		56 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		57 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		58 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		59 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		60 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		61 => {
	pc = 0x8219D094; continue 'dispatch;
		},
		62 => {
	pc = 0x8219D0BC; continue 'dispatch;
		},
		63 => {
	pc = 0x8219D06C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219CF64: 8219D064  lwz r16, -0x2f9c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12188 as u32) ) } as u64;
	// 8219CF68: 8219D064  lwz r16, -0x2f9c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12188 as u32) ) } as u64;
	// 8219CF6C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF70: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF74: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF78: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF7C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF80: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF84: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF88: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF8C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF90: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF94: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF98: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CF9C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFA8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFAC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFB8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFBC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFC8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFCC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFD8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFDC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFE8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFEC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF0: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF4: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFF8: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219CFFC: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D000: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D004: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D008: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D00C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D010: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D014: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D018: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D01C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D020: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D024: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D028: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D02C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D030: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D034: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D038: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D03C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D040: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D044: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D048: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D04C: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D050: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D054: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D058: 8219D094  lwz r16, -0x2f6c(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12140 as u32) ) } as u64;
	// 8219D05C: 8219D0BC  lwz r16, -0x2f44(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12100 as u32) ) } as u64;
	// 8219D060: 8219D06C  lwz r16, -0x2f94(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-12180 as u32) ) } as u64;
            }
            0x8219D064 => {
    //   block [0x8219D064..0x8219D06C)
	// 8219D064: FDA00090  fmr f13, f0
	ctx.f[13].f64 = ctx.f[0].f64;
	// 8219D068: 48000054  b 0x8219d0bc
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D06C => {
    //   block [0x8219D06C..0x8219D094)
	// 8219D06C: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219D070: 419AFFF4  beq cr6, 0x8219d064
	if ctx.cr[6].eq {
	pc = 0x8219D064; continue 'dispatch;
	}
	// 8219D074: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219D078: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 8219D07C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D080: 396BA510  addi r11, r11, -0x5af0
	ctx.r[11].s64 = ctx.r[11].s64 + -23280;
	// 8219D084: 7D47522E  lhzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D088: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8219D08C: 7C0A5C2E  lfsx f0, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D090: 4800002C  b 0x8219d0bc
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D094 => {
    //   block [0x8219D094..0x8219D0BC)
	// 8219D094: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D098: 40980024  bge cr6, 0x8219d0bc
	if !ctx.cr[6].lt {
	pc = 0x8219D0BC; continue 'dispatch;
	}
	// 8219D09C: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 8219D0A0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219D0A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D0A8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219D0AC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219D0B0: FD600018  frsp f11, f0
	ctx.f[11].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219D0B4: C00B2050  lfs f0, 0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D0B8: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8219D0BC; continue 'dispatch;
            }
            0x8219D0BC => {
    //   block [0x8219D0BC..0x8219D0D4)
	// 8219D0BC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D0C0: 419A0014  beq cr6, 0x8219d0d4
	if ctx.cr[6].eq {
	pc = 0x8219D0D4; continue 'dispatch;
	}
	// 8219D0C4: D0030000  stfs f0, 0(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219D0C8: D1A30004  stfs f13, 4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D0CC: D1830008  stfs f12, 8(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219D0D0: D183000C  stfs f12, 0xc(r3)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8219D0D4; continue 'dispatch;
            }
            0x8219D0D4 => {
    //   block [0x8219D0D4..0x8219D0E8)
	// 8219D0D4: 7D234B78  mr r3, r9
	ctx.r[3].u64 = ctx.r[9].u64;
	// 8219D0D8: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D0DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D0E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D0E4: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D0E8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D0E8 size=352
    let mut pc: u32 = 0x8219D0E8;
    'dispatch: loop {
        match pc {
            0x8219D0E8 => {
    //   block [0x8219D0E8..0x8219D134)
	// 8219D0E8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D0EC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D0F0: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D0F4: 3900FFFF  li r8, -1
	ctx.r[8].s64 = -1;
	// 8219D0F8: 2F050000  cmpwi cr6, r5, 0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 0, &mut ctx.xer);
	// 8219D0FC: 40980038  bge cr6, 0x8219d134
	if !ctx.cr[6].lt {
	pc = 0x8219D134; continue 'dispatch;
	}
	// 8219D100: 20650001  subfic r3, r5, 1
	ctx.xer.ca = ctx.r[5].u32 <= 1 as u32;
	ctx.r[3].s64 = (1 as i64) - ctx.r[5].s64;
	// 8219D104: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D108: 419A0130  beq cr6, 0x8219d238
	if ctx.cr[6].eq {
	pc = 0x8219D238; continue 'dispatch;
	}
	// 8219D10C: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D110: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219D114: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D118: F9440000  std r10, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219D11C: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219D120: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219D124: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D128: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D12C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D130: 4E800020  blr
	return;
            }
            0x8219D134 => {
    //   block [0x8219D134..0x8219D17C)
	// 8219D134: 2F050100  cmpwi cr6, r5, 0x100
	ctx.cr[6].compare_i32(ctx.r[5].s32, 256, &mut ctx.xer);
	// 8219D138: 41980044  blt cr6, 0x8219d17c
	if ctx.cr[6].lt {
	pc = 0x8219D17C; continue 'dispatch;
	}
	// 8219D13C: 3945FF00  addi r10, r5, -0x100
	ctx.r[10].s64 = ctx.r[5].s64 + -256;
	// 8219D140: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D144: 554A2036  slwi r10, r10, 4
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(4);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219D148: 396BB790  addi r11, r11, -0x4870
	ctx.r[11].s64 = ctx.r[11].s64 + -18544;
	// 8219D14C: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D150: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219D154: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	// 8219D158: 419A00E0  beq cr6, 0x8219d238
	if ctx.cr[6].eq {
	pc = 0x8219D238; continue 'dispatch;
	}
	// 8219D15C: E94B0000  ld r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D160: F9440000  std r10, 0(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 8219D164: E96B0008  ld r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	// 8219D168: F9640008  std r11, 8(r4)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[4].u32.wrapping_add(8 as u32), ctx.r[11].u64 ) };
	// 8219D16C: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D170: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D174: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D178: 4E800020  blr
	return;
            }
            0x8219D17C => {
    //   block [0x8219D17C..0x8219D1A0)
	// 8219D17C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D180: 2B060000  cmplwi cr6, r6, 0
	ctx.cr[6].compare_u32(ctx.r[6].u32, 0 as u32, &mut ctx.xer);
	// 8219D184: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D188: 419A0018  beq cr6, 0x8219d1a0
	if ctx.cr[6].eq {
	pc = 0x8219D1A0; continue 'dispatch;
	}
	// 8219D18C: C0260000  lfs f1, 0(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219D190: C0460004  lfs f2, 4(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219D194: C0660008  lfs f3, 8(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219D198: C086000C  lfs f4, 0xc(r6)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(12 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219D19C: 48000018  b 0x8219d1b4
	pc = 0x8219D1B4; continue 'dispatch;
            }
            0x8219D1A0 => {
    //   block [0x8219D1A0..0x8219D1B4)
	// 8219D1A0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219D1A4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 8219D1A8: C08BBA38  lfs f4, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219D1AC: FC602090  fmr f3, f4
	ctx.f[3].f64 = ctx.f[4].f64;
	// 8219D1B0: FC402090  fmr f2, f4
	ctx.f[2].f64 = ctx.f[4].f64;
	pc = 0x8219D1B4; continue 'dispatch;
            }
            0x8219D1B4 => {
    //   block [0x8219D1B4..0x8219D1F4)
	// 8219D1B4: 2F0500C0  cmpwi cr6, r5, 0xc0
	ctx.cr[6].compare_i32(ctx.r[5].s32, 192, &mut ctx.xer);
	// 8219D1B8: 41980044  blt cr6, 0x8219d1fc
	if ctx.cr[6].lt {
	pc = 0x8219D1FC; continue 'dispatch;
	}
	// 8219D1BC: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D1C0: 40990034  ble cr6, 0x8219d1f4
	if !ctx.cr[6].gt {
	pc = 0x8219D1F4; continue 'dispatch;
	}
	// 8219D1C4: 2F0500FF  cmpwi cr6, r5, 0xff
	ctx.cr[6].compare_i32(ctx.r[5].s32, 255, &mut ctx.xer);
	// 8219D1C8: 409A0034  bne cr6, 0x8219d1fc
	if !ctx.cr[6].eq {
	pc = 0x8219D1FC; continue 'dispatch;
	}
	// 8219D1CC: 2B070000  cmplwi cr6, r7, 0
	ctx.cr[6].compare_u32(ctx.r[7].u32, 0 as u32, &mut ctx.xer);
	// 8219D1D0: 419A0054  beq cr6, 0x8219d224
	if ctx.cr[6].eq {
	pc = 0x8219D224; continue 'dispatch;
	}
	// 8219D1D4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219D1D8: 616ABEB8  ori r10, r11, 0xbeb8
	ctx.r[10].u64 = ctx.r[11].u64 | 48824;
	// 8219D1DC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219D1E0: 396BA510  addi r11, r11, -0x5af0
	ctx.r[11].s64 = ctx.r[11].s64 + -23280;
	// 8219D1E4: 7D47522E  lhzx r10, r7, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[7].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D1E8: 554A303E  rotlwi r10, r10, 6
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(6)) as u64;
	// 8219D1EC: 7C2A5C2E  lfsx f1, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219D1F0: 48000034  b 0x8219d224
	pc = 0x8219D224; continue 'dispatch;
            }
            0x8219D1F4 => {
    //   block [0x8219D1F4..0x8219D1FC)
	// 8219D1F4: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8219D1F8: 4800002C  b 0x8219d224
	pc = 0x8219D224; continue 'dispatch;
            }
            0x8219D1FC => {
    //   block [0x8219D1FC..0x8219D224)
	// 8219D1FC: 2F0500C1  cmpwi cr6, r5, 0xc1
	ctx.cr[6].compare_i32(ctx.r[5].s32, 193, &mut ctx.xer);
	// 8219D200: 40980024  bge cr6, 0x8219d224
	if !ctx.cr[6].lt {
	pc = 0x8219D224; continue 'dispatch;
	}
	// 8219D204: 7CAB07B4  extsw r11, r5
	ctx.r[11].s64 = ctx.r[5].s32 as i64;
	// 8219D208: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219D20C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D210: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 8219D214: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 8219D218: FDA00018  frsp f13, f0
	ctx.f[13].f64 = (ctx.f[0].f64 as f32) as f64;
	// 8219D21C: C00B2050  lfs f0, 0x2050(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8272 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D220: EC2D0032  fmuls f1, f13, f0
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	pc = 0x8219D224; continue 'dispatch;
            }
            0x8219D224 => {
    //   block [0x8219D224..0x8219D234)
	// 8219D224: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 8219D228: 419A000C  beq cr6, 0x8219d234
	if ctx.cr[6].eq {
	pc = 0x8219D234; continue 'dispatch;
	}
	// 8219D22C: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 8219D230: 481D3B89  bl 0x82370db8
	ctx.lr = 0x8219D234;
	sub_82370DB8(ctx, base);
	pc = 0x8219D234; continue 'dispatch;
            }
            0x8219D234 => {
    //   block [0x8219D234..0x8219D238)
	// 8219D234: 7D034378  mr r3, r8
	ctx.r[3].u64 = ctx.r[8].u64;
	pc = 0x8219D238; continue 'dispatch;
            }
            0x8219D238 => {
    //   block [0x8219D238..0x8219D248)
	// 8219D238: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D23C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D240: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D244: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D248(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D248 size=28
    let mut pc: u32 = 0x8219D248;
    'dispatch: loop {
        match pc {
            0x8219D248 => {
    //   block [0x8219D248..0x8219D264)
	// 8219D248: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D24C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D250: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D254: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8219D258: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219D25C: 914B0040  stw r10, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[10].u32 ) };
	// 8219D260: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D268(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D268 size=180
    let mut pc: u32 = 0x8219D268;
    'dispatch: loop {
        match pc {
            0x8219D268 => {
    //   block [0x8219D268..0x8219D2B0)
	// 8219D268: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D26C: 48397E51  bl 0x825350bc
	ctx.lr = 0x8219D270;
	sub_82535080(ctx, base);
	// 8219D270: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D274: 3FC0830F  lis r30, -0x7cf1
	ctx.r[30].s64 = -2096168960;
	// 8219D278: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219D27C: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219D280: 817EFAC0  lwz r11, -0x540(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D284: 814B0040  lwz r10, 0x40(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(64 as u32) ) } as u64;
	// 8219D288: 912B0040  stw r9, 0x40(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(64 as u32), ctx.r[9].u32 ) };
	// 8219D28C: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 8219D290: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219D294: 419A0080  beq cr6, 0x8219d314
	if ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D298: 3BBF0080  addi r29, r31, 0x80
	ctx.r[29].s64 = ctx.r[31].s64 + 128;
	// 8219D29C: 817D0084  lwz r11, 0x84(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(132 as u32) ) } as u64;
	// 8219D2A0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D2A4: 419A000C  beq cr6, 0x8219d2b0
	if ctx.cr[6].eq {
	pc = 0x8219D2B0; continue 'dispatch;
	}
	// 8219D2A8: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219D2AC: 48000385  bl 0x8219d630
	ctx.lr = 0x8219D2B0;
	sub_8219D630(ctx, base);
	pc = 0x8219D2B0; continue 'dispatch;
            }
            0x8219D2B0 => {
    //   block [0x8219D2B0..0x8219D2EC)
	// 8219D2B0: 817D0080  lwz r11, 0x80(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219D2B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D2B8: 409A005C  bne cr6, 0x8219d314
	if !ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D2BC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D2C0: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219D2C4: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D2C8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D2CC: 419A0020  beq cr6, 0x8219d2ec
	if ctx.cr[6].eq {
	pc = 0x8219D2EC; continue 'dispatch;
	}
	// 8219D2D0: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D2D4: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D2D8: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D2DC: 409A0010  bne cr6, 0x8219d2ec
	if !ctx.cr[6].eq {
	pc = 0x8219D2EC; continue 'dispatch;
	}
	// 8219D2E0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D2E4: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219D2E8: 409A0008  bne cr6, 0x8219d2f0
	if !ctx.cr[6].eq {
	pc = 0x8219D2F0; continue 'dispatch;
	}
	pc = 0x8219D2EC; continue 'dispatch;
            }
            0x8219D2EC => {
    //   block [0x8219D2EC..0x8219D2F0)
	// 8219D2EC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219D2F0; continue 'dispatch;
            }
            0x8219D2F0 => {
    //   block [0x8219D2F0..0x8219D314)
	// 8219D2F0: 7F1D5840  cmplw cr6, r29, r11
	ctx.cr[6].compare_u32(ctx.r[29].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219D2F4: 419A0020  beq cr6, 0x8219d314
	if ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D2F8: 817EFAC0  lwz r11, -0x540(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D2FC: 7F0BF840  cmplw cr6, r11, r31
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[31].u32, &mut ctx.xer);
	// 8219D300: 409A0014  bne cr6, 0x8219d314
	if !ctx.cr[6].eq {
	pc = 0x8219D314; continue 'dispatch;
	}
	// 8219D304: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219D308: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219D30C: 997F0019  stb r11, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219D310: 995F0025  stb r10, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x8219D314; continue 'dispatch;
            }
            0x8219D314 => {
    //   block [0x8219D314..0x8219D31C)
	// 8219D314: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219D318: 48397DF4  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D320(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D320 size=76
    let mut pc: u32 = 0x8219D320;
    'dispatch: loop {
        match pc {
            0x8219D320 => {
    //   block [0x8219D320..0x8219D354)
	// 8219D320: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D324: 39030080  addi r8, r3, 0x80
	ctx.r[8].s64 = ctx.r[3].s64 + 128;
	// 8219D328: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219D32C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D330: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D334: 419A0020  beq cr6, 0x8219d354
	if ctx.cr[6].eq {
	pc = 0x8219D354; continue 'dispatch;
	}
	// 8219D338: 80EB0030  lwz r7, 0x30(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D33C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D340: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219D344: 409A0010  bne cr6, 0x8219d354
	if !ctx.cr[6].eq {
	pc = 0x8219D354; continue 'dispatch;
	}
	// 8219D348: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D34C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219D350: 409A0008  bne cr6, 0x8219d358
	if !ctx.cr[6].eq {
	pc = 0x8219D358; continue 'dispatch;
	}
	pc = 0x8219D354; continue 'dispatch;
            }
            0x8219D354 => {
    //   block [0x8219D354..0x8219D358)
	// 8219D354: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219D358; continue 'dispatch;
            }
            0x8219D358 => {
    //   block [0x8219D358..0x8219D36C)
	// 8219D358: 7F085840  cmplw cr6, r8, r11
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[11].u32, &mut ctx.xer);
	// 8219D35C: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8219D360: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D364: F96A0000  std r11, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 8219D368: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D370(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D370 size=704
    let mut pc: u32 = 0x8219D370;
    'dispatch: loop {
        match pc {
            0x8219D370 => {
    //   block [0x8219D370..0x8219D3D0)
	// 8219D370: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D374: 48397D35  bl 0x825350a8
	ctx.lr = 0x8219D378;
	sub_82535080(ctx, base);
	// 8219D378: 9421FF60  stwu r1, -0xa0(r1)
	ea = ctx.r[1].u32.wrapping_add(-160 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D37C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D380: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 8219D384: 38EB0B78  addi r7, r11, 0xb78
	ctx.r[7].s64 = ctx.r[11].s64 + 2936;
	// 8219D388: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D38C: 7C781B78  mr r24, r3
	ctx.r[24].u64 = ctx.r[3].u64;
	// 8219D390: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219D394: 3B400000  li r26, 0
	ctx.r[26].s64 = 0;
	// 8219D398: 7CBD2B78  mr r29, r5
	ctx.r[29].u64 = ctx.r[5].u64;
	// 8219D39C: 7CD93378  mr r25, r6
	ctx.r[25].u64 = ctx.r[6].u64;
	// 8219D3A0: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219D3A4: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 8219D3A8: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 8219D3AC: FB580000  std r26, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 8219D3B0: 7C9E2378  mr r30, r4
	ctx.r[30].u64 = ctx.r[4].u64;
	// 8219D3B4: 808B000C  lwz r4, 0xc(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219D3B8: 7D1B4378  mr r27, r8
	ctx.r[27].u64 = ctx.r[8].u64;
	// 8219D3BC: 481CD0D5  bl 0x8236a490
	ctx.lr = 0x8219D3C0;
	sub_8236A490(ctx, base);
	// 8219D3C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D3C4: 419A000C  beq cr6, 0x8219d3d0
	if ctx.cr[6].eq {
	pc = 0x8219D3D0; continue 'dispatch;
	}
	// 8219D3C8: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D3CC: 48000008  b 0x8219d3d4
	pc = 0x8219D3D4; continue 'dispatch;
            }
            0x8219D3D0 => {
    //   block [0x8219D3D0..0x8219D3D4)
	// 8219D3D0: 7F4BD378  mr r11, r26
	ctx.r[11].u64 = ctx.r[26].u64;
	pc = 0x8219D3D4; continue 'dispatch;
            }
            0x8219D3D4 => {
    //   block [0x8219D3D4..0x8219D444)
	// 8219D3D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D3D8: 91780000  stw r11, 0(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D3DC: 90780004  stw r3, 4(r24)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[24].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8219D3E0: 419A0064  beq cr6, 0x8219d444
	if ctx.cr[6].eq {
	pc = 0x8219D444; continue 'dispatch;
	}
	// 8219D3E4: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D3E8: 3BE30080  addi r31, r3, 0x80
	ctx.r[31].s64 = ctx.r[3].s64 + 128;
	// 8219D3EC: 396B0B80  addi r11, r11, 0xb80
	ctx.r[11].s64 = ctx.r[11].s64 + 2944;
	// 8219D3F0: 572A07BC  rlwinm r10, r25, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D3F4: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219D3F8: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D3FC: E9780000  ld r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	// 8219D400: FB430110  std r26, 0x110(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(272 as u32), ctx.r[26].u64 ) };
	// 8219D404: 93DF0000  stw r30, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	// 8219D408: 935F0080  stw r26, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[26].u32 ) };
	// 8219D40C: 933F0088  stw r25, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[25].u32 ) };
	// 8219D410: F97F0090  std r11, 0x90(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8219D414: 419A0080  beq cr6, 0x8219d494
	if ctx.cr[6].eq {
	pc = 0x8219D494; continue 'dispatch;
	}
	// 8219D418: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D41C: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D420: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D424: 419A0030  beq cr6, 0x8219d454
	if ctx.cr[6].eq {
	pc = 0x8219D454; continue 'dispatch;
	}
	// 8219D428: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D42C: D1BF0060  stfs f13, 0x60(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	// 8219D430: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D434: D1BF0064  stfs f13, 0x64(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219D438: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D43C: D1BF0068  stfs f13, 0x68(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219D440: 48000020  b 0x8219d460
	pc = 0x8219D460; continue 'dispatch;
            }
            0x8219D444 => {
    //   block [0x8219D444..0x8219D454)
	// 8219D444: FB580000  std r26, 0(r24)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[24].u32.wrapping_add(0 as u32), ctx.r[26].u64 ) };
	// 8219D448: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8219D44C: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219D450: 48397CA8  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            0x8219D454 => {
    //   block [0x8219D454..0x8219D460)
	// 8219D454: D01F0068  stfs f0, 0x68(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(104 as u32), tmp.u32 ) };
	// 8219D458: D01F0064  stfs f0, 0x64(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(100 as u32), tmp.u32 ) };
	// 8219D45C: D01F0060  stfs f0, 0x60(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(96 as u32), tmp.u32 ) };
	pc = 0x8219D460; continue 'dispatch;
            }
            0x8219D460 => {
    //   block [0x8219D460..0x8219D484)
	// 8219D460: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219D464: 419A0020  beq cr6, 0x8219d484
	if ctx.cr[6].eq {
	pc = 0x8219D484; continue 'dispatch;
	}
	// 8219D468: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D46C: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D470: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D474: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D478: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D47C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D480: 48000194  b 0x8219d614
	pc = 0x8219D614; continue 'dispatch;
            }
            0x8219D484 => {
    //   block [0x8219D484..0x8219D494)
	// 8219D484: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D488: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D48C: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D490: 48000184  b 0x8219d614
	pc = 0x8219D614; continue 'dispatch;
            }
            0x8219D494 => {
    //   block [0x8219D494..0x8219D4CC)
	// 8219D494: 572B077A  rlwinm r11, r25, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D498: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D49C: 419A0080  beq cr6, 0x8219d51c
	if ctx.cr[6].eq {
	pc = 0x8219D51C; continue 'dispatch;
	}
	// 8219D4A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D4A4: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D4A8: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4AC: 419A0020  beq cr6, 0x8219d4cc
	if ctx.cr[6].eq {
	pc = 0x8219D4CC; continue 'dispatch;
	}
	// 8219D4B0: C1BC0000  lfs f13, 0(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4B4: D1BF0040  stfs f13, 0x40(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	// 8219D4B8: C1BC0004  lfs f13, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4BC: D1BF0044  stfs f13, 0x44(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D4C0: C1BC0008  lfs f13, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219D4C4: D1BF0048  stfs f13, 0x48(r31)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D4C8: 48000010  b 0x8219d4d8
	pc = 0x8219D4D8; continue 'dispatch;
            }
            0x8219D4CC => {
    //   block [0x8219D4CC..0x8219D4D8)
	// 8219D4CC: D01F0048  stfs f0, 0x48(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(72 as u32), tmp.u32 ) };
	// 8219D4D0: D01F0044  stfs f0, 0x44(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(68 as u32), tmp.u32 ) };
	// 8219D4D4: D01F0040  stfs f0, 0x40(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), tmp.u32 ) };
	pc = 0x8219D4D8; continue 'dispatch;
            }
            0x8219D4D8 => {
    //   block [0x8219D4D8..0x8219D504)
	// 8219D4D8: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219D4DC: 419A0028  beq cr6, 0x8219d504
	if ctx.cr[6].eq {
	pc = 0x8219D504; continue 'dispatch;
	}
	// 8219D4E0: C01B0000  lfs f0, 0(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4E4: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219D4E8: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219D4EC: C01B0004  lfs f0, 4(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4F0: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219D4F4: C01B0008  lfs f0, 8(r27)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D4F8: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	// 8219D4FC: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8219D500: 48000118  b 0x8219d618
	pc = 0x8219D618; continue 'dispatch;
            }
            0x8219D504 => {
    //   block [0x8219D504..0x8219D510)
	// 8219D504: D01F0054  stfs f0, 0x54(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(84 as u32), tmp.u32 ) };
	// 8219D508: D01F0050  stfs f0, 0x50(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(80 as u32), tmp.u32 ) };
	// 8219D50C: D01F0058  stfs f0, 0x58(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(88 as u32), tmp.u32 ) };
	pc = 0x8219D510; continue 'dispatch;
            }
            0x8219D510 => {
    //   block [0x8219D510..0x8219D51C)
	// 8219D510: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219D514: 917F0084  stw r11, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[11].u32 ) };
	// 8219D518: 48000100  b 0x8219d618
	pc = 0x8219D618; continue 'dispatch;
            }
            0x8219D51C => {
    //   block [0x8219D51C..0x8219D558)
	// 8219D51C: 7F49D378  mr r9, r26
	ctx.r[9].u64 = ctx.r[26].u64;
	// 8219D520: 57AB0420  rlwinm r11, r29, 0, 0x10, 0x10
	ctx.r[11].u64 = ctx.r[29].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D524: 57A4057E  clrlwi r4, r29, 0x15
	ctx.r[4].u64 = ctx.r[29].u32 as u64 & 0x000007FFu64;
	// 8219D528: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D52C: 91210050  stw r9, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[9].u32 ) };
	// 8219D530: 419A0028  beq cr6, 0x8219d558
	if ctx.cr[6].eq {
	pc = 0x8219D558; continue 'dispatch;
	}
	// 8219D534: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219D538: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219D53C: 386B14A0  addi r3, r11, 0x14a0
	ctx.r[3].s64 = ctx.r[11].s64 + 5280;
	// 8219D540: 38C10050  addi r6, r1, 0x50
	ctx.r[6].s64 = ctx.r[1].s64 + 80;
	// 8219D544: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219D548: 480065C1  bl 0x821a3b08
	ctx.lr = 0x8219D54C;
	sub_821A3B08(ctx, base);
	// 8219D54C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219D550: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219D554: 48000030  b 0x8219d584
	pc = 0x8219D584; continue 'dispatch;
            }
            0x8219D558 => {
    //   block [0x8219D558..0x8219D584)
	// 8219D558: 2F040058  cmpwi cr6, r4, 0x58
	ctx.cr[6].compare_i32(ctx.r[4].s32, 88, &mut ctx.xer);
	// 8219D55C: 41980028  blt cr6, 0x8219d584
	if ctx.cr[6].lt {
	pc = 0x8219D584; continue 'dispatch;
	}
	// 8219D560: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8219D564: 3964FFA8  addi r11, r4, -0x58
	ctx.r[11].s64 = ctx.r[4].s64 + -88;
	// 8219D568: 394A47D0  addi r10, r10, 0x47d0
	ctx.r[10].s64 = ctx.r[10].s64 + 18384;
	// 8219D56C: 390A0002  addi r8, r10, 2
	ctx.r[8].s64 = ctx.r[10].s64 + 2;
	// 8219D570: 556A103A  slwi r10, r11, 2
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219D574: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219D578: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219D57C: 7D6B422E  lhzx r11, r11, r8
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[8].u32)) } as u64;
	// 8219D580: 7D640734  extsh r4, r11
	ctx.r[4].s64 = ctx.r[11].s16 as i64;
	pc = 0x8219D584; continue 'dispatch;
            }
            0x8219D584 => {
    //   block [0x8219D584..0x8219D5AC)
	// 8219D584: 397F0040  addi r11, r31, 0x40
	ctx.r[11].s64 = ctx.r[31].s64 + 64;
	// 8219D588: 2B1C0000  cmplwi cr6, r28, 0
	ctx.cr[6].compare_u32(ctx.r[28].u32, 0 as u32, &mut ctx.xer);
	// 8219D58C: 419A0020  beq cr6, 0x8219d5ac
	if ctx.cr[6].eq {
	pc = 0x8219D5AC; continue 'dispatch;
	}
	// 8219D590: C01C0000  lfs f0, 0(r28)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D594: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8219D598: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219D59C: C01C0004  lfs f0, 4(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(4 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5A0: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D5A4: C01C0008  lfs f0, 8(r28)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(8 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5A8: 48000014  b 0x8219d5bc
	pc = 0x8219D5BC; continue 'dispatch;
            }
            0x8219D5AC => {
    //   block [0x8219D5AC..0x8219D5BC)
	// 8219D5AC: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219D5B0: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D5B4: D00B0004  stfs f0, 4(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219D5B8: D00B0000  stfs f0, 0(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	pc = 0x8219D5BC; continue 'dispatch;
            }
            0x8219D5BC => {
    //   block [0x8219D5BC..0x8219D5E8)
	// 8219D5BC: D00B0008  stfs f0, 8(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219D5C0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219D5C4: 909F0010  stw r4, 0x10(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[4].u32 ) };
	// 8219D5C8: 913F0018  stw r9, 0x18(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8219D5CC: 935F001C  stw r26, 0x1c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[26].u32 ) };
	// 8219D5D0: 409A0018  bne cr6, 0x8219d5e8
	if !ctx.cr[6].eq {
	pc = 0x8219D5E8; continue 'dispatch;
	}
	// 8219D5D4: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219D5D8: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219D5DC: 394A3E78  addi r10, r10, 0x3e78
	ctx.r[10].s64 = ctx.r[10].s64 + 15992;
	// 8219D5E0: 396B3E78  addi r11, r11, 0x3e78
	ctx.r[11].s64 = ctx.r[11].s64 + 15992;
	// 8219D5E4: 48000014  b 0x8219d5f8
	pc = 0x8219D5F8; continue 'dispatch;
            }
            0x8219D5E8 => {
    //   block [0x8219D5E8..0x8219D5F8)
	// 8219D5E8: 3D40821A  lis r10, -0x7de6
	ctx.r[10].s64 = -2112225280;
	// 8219D5EC: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219D5F0: 394A3EC8  addi r10, r10, 0x3ec8
	ctx.r[10].s64 = ctx.r[10].s64 + 16072;
	// 8219D5F4: 396B3F60  addi r11, r11, 0x3f60
	ctx.r[11].s64 = ctx.r[11].s64 + 16224;
	pc = 0x8219D5F8; continue 'dispatch;
            }
            0x8219D5F8 => {
    //   block [0x8219D5F8..0x8219D614)
	// 8219D5F8: 917F0034  stw r11, 0x34(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(52 as u32), ctx.r[11].u32 ) };
	// 8219D5FC: 572B07FE  clrlwi r11, r25, 0x1f
	ctx.r[11].u64 = ctx.r[25].u32 as u64 & 0x00000001u64;
	// 8219D600: 915F0030  stw r10, 0x30(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(48 as u32), ctx.r[10].u32 ) };
	// 8219D604: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D608: 409AFF08  bne cr6, 0x8219d510
	if !ctx.cr[6].eq {
	pc = 0x8219D510; continue 'dispatch;
	}
	// 8219D60C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D610: 48000021  bl 0x8219d630
	ctx.lr = 0x8219D614;
	sub_8219D630(ctx, base);
	pc = 0x8219D614; continue 'dispatch;
            }
            0x8219D614 => {
    //   block [0x8219D614..0x8219D618)
	// 8219D614: 935F0084  stw r26, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[26].u32 ) };
	pc = 0x8219D618; continue 'dispatch;
            }
            0x8219D618 => {
    //   block [0x8219D618..0x8219D630)
	// 8219D618: E9780000  ld r11, 0(r24)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[24].u32.wrapping_add(0 as u32) ) };
	// 8219D61C: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219D620: 7F03C378  mr r3, r24
	ctx.r[3].u64 = ctx.r[24].u64;
	// 8219D624: F96AC448  std r11, -0x3bb8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-15288 as u32), ctx.r[11].u64 ) };
	// 8219D628: 382100A0  addi r1, r1, 0xa0
	ctx.r[1].s64 = ctx.r[1].s64 + 160;
	// 8219D62C: 48397ACC  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D630(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D630 size=244
    let mut pc: u32 = 0x8219D630;
    'dispatch: loop {
        match pc {
            0x8219D630 => {
    //   block [0x8219D630..0x8219D6D4)
	// 8219D630: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D634: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D638: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219D63C: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D640: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219D644: 817F0094  lwz r11, 0x94(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(148 as u32) ) } as u64;
	// 8219D648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D64C: 419A00C4  beq cr6, 0x8219d710
	if ctx.cr[6].eq {
	pc = 0x8219D710; continue 'dispatch;
	}
	// 8219D650: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D654: 815F0090  lwz r10, 0x90(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219D658: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D65C: 409A00B4  bne cr6, 0x8219d710
	if !ctx.cr[6].eq {
	pc = 0x8219D710; continue 'dispatch;
	}
	// 8219D660: 817F0088  lwz r11, 0x88(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219D664: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219D668: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D66C: 419A0068  beq cr6, 0x8219d6d4
	if ctx.cr[6].eq {
	pc = 0x8219D6D4; continue 'dispatch;
	}
	// 8219D670: 39400040  li r10, 0x40
	ctx.r[10].s64 = 64;
	// 8219D674: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D678: 39200110  li r9, 0x110
	ctx.r[9].s64 = 272;
	// 8219D67C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219D680: 390000E0  li r8, 0xe0
	ctx.r[8].s64 = 224;
	pc = 0x8219D6D4; continue 'dispatch;
            }
            0x8219D6D4 => {
    //   block [0x8219D6D4..0x8219D710)
	// 8219D6D4: 817F0000  lwz r11, 0(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D6D8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 8219D6DC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D6E0: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D6E4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219D6E8: 4E800421  bctrl
	ctx.lr = 0x8219D6EC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219D6EC: 397F0010  addi r11, r31, 0x10
	ctx.r[11].s64 = ctx.r[31].s64 + 16;
	// 8219D6F0: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 8219D6F4: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219D6F8: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219D6FC: 389F0060  addi r4, r31, 0x60
	ctx.r[4].s64 = ctx.r[31].s64 + 96;
	// 8219D700: 814B0020  lwz r10, 0x20(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219D704: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219D708: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	// 8219D70C: 4E800421  bctrl
	ctx.lr = 0x8219D710;
	crate::rt::call_indirect(ctx.ctr.u32);
            }
            0x8219D710 => {
    //   block [0x8219D710..0x8219D724)
	// 8219D710: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219D714: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D718: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D71C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219D720: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D728(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D728 size=120
    let mut pc: u32 = 0x8219D728;
    'dispatch: loop {
        match pc {
            0x8219D728 => {
    //   block [0x8219D728..0x8219D748)
	// 8219D728: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D72C: 48397985  bl 0x825350b0
	ctx.lr = 0x8219D730;
	sub_82535080(ctx, base);
	// 8219D730: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D734: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219D738: 7C7A1B78  mr r26, r3
	ctx.r[26].u64 = ctx.r[3].u64;
	// 8219D73C: 2F1D0040  cmpwi cr6, r29, 0x40
	ctx.cr[6].compare_i32(ctx.r[29].s32, 64, &mut ctx.xer);
	// 8219D740: 409A0008  bne cr6, 0x8219d748
	if !ctx.cr[6].eq {
	pc = 0x8219D748; continue 'dispatch;
	}
	// 8219D744: 3BA00002  li r29, 2
	ctx.r[29].s64 = 2;
	pc = 0x8219D748; continue 'dispatch;
            }
            0x8219D748 => {
    //   block [0x8219D748..0x8219D770)
	// 8219D748: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219D74C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 8219D750: 3B6B16A0  addi r27, r11, 0x16a0
	ctx.r[27].s64 = ctx.r[11].s64 + 5792;
	// 8219D754: 7D7DD8AE  lbzx r11, r29, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219D758: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219D75C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219D760: 40990038  ble cr6, 0x8219d798
	if !ctx.cr[6].gt {
	pc = 0x8219D798; continue 'dispatch;
	}
	// 8219D764: 57AB1838  slwi r11, r29, 3
	ctx.r[11].u32 = ctx.r[29].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219D768: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 8219D76C: 7F855850  subf r28, r5, r11
	ctx.r[28].s64 = ctx.r[11].s64 - ctx.r[5].s64;
	pc = 0x8219D770; continue 'dispatch;
            }
            0x8219D770 => {
    //   block [0x8219D770..0x8219D798)
	// 8219D770: 7CBCFA14  add r5, r28, r31
	ctx.r[5].u64 = ctx.r[28].u64 + ctx.r[31].u64;
	// 8219D774: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219D778: 7F43D378  mr r3, r26
	ctx.r[3].u64 = ctx.r[26].u64;
	// 8219D77C: 4800EB0D  bl 0x821ac288
	ctx.lr = 0x8219D780;
	sub_821AC288(ctx, base);
	// 8219D780: 7D7DD8AE  lbzx r11, r29, r27
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[27].u32)) } as u64;
	// 8219D784: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219D788: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219D78C: 3BFF0001  addi r31, r31, 1
	ctx.r[31].s64 = ctx.r[31].s64 + 1;
	// 8219D790: 7F1E5800  cmpw cr6, r30, r11
	ctx.cr[6].compare_i32(ctx.r[30].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8219D794: 4198FFDC  blt cr6, 0x8219d770
	if ctx.cr[6].lt {
	pc = 0x8219D770; continue 'dispatch;
	}
	pc = 0x8219D798; continue 'dispatch;
            }
            0x8219D798 => {
    //   block [0x8219D798..0x8219D7A0)
	// 8219D798: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 8219D79C: 48397964  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219D7A0 size=60
    let mut pc: u32 = 0x8219D7A0;
    'dispatch: loop {
        match pc {
            0x8219D7A0 => {
    //   block [0x8219D7A0..0x8219D7DC)
	// 8219D7A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D7A4: 548A07FE  clrlwi r10, r4, 0x1f
	ctx.r[10].u64 = ctx.r[4].u32 as u64 & 0x00000001u64;
	// 8219D7A8: 396BDED0  addi r11, r11, -0x2130
	ctx.r[11].s64 = ctx.r[11].s64 + -8496;
	// 8219D7AC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219D7B0: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219D7B4: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8219D7B8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D7BC: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D7C0: 7F0B1840  cmplw cr6, r11, r3
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[3].u32, &mut ctx.xer);
	// 8219D7C4: 4C9A0020  bnelr cr6
	if !ctx.cr[6].eq { return; }
	// 8219D7C8: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 8219D7CC: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 8219D7D0: 99630019  stb r11, 0x19(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 8219D7D4: 99430025  stb r10, 0x25(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	// 8219D7D8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D7E0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219D7E0 size=304
    let mut pc: u32 = 0x8219D7E0;
    'dispatch: loop {
        match pc {
            0x8219D7E0 => {
    //   block [0x8219D7E0..0x8219D87C)
	// 8219D7E0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D7E4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D7E8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219D7EC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219D7F0: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D7F4: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219D7F8: 815E0080  lwz r10, 0x80(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219D7FC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219D800: 419A00F8  beq cr6, 0x8219d8f8
	if ctx.cr[6].eq {
	pc = 0x8219D8F8; continue 'dispatch;
	}
	// 8219D804: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219D808: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 8219D80C: 3BEB63D0  addi r31, r11, 0x63d0
	ctx.r[31].s64 = ctx.r[11].s64 + 25552;
	// 8219D810: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219D814: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D818: 912A002C  stw r9, 0x2c(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8219D81C: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219D820: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 8219D824: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 8219D828: 3960002C  li r11, 0x2c
	ctx.r[11].s64 = 44;
	// 8219D82C: 91610060  stw r11, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u32 ) };
	// 8219D830: 4856FA2D  bl 0x8270d25c
	ctx.lr = 0x8219D834;
	// extern call 0x8270D25C  crate::xboxkrnl::RtlEnterCriticalSection
	crate::xboxkrnl::RtlEnterCriticalSection(ctx, base);
	// 8219D834: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D838: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219D83C: 38CB0BC4  addi r6, r11, 0xbc4
	ctx.r[6].s64 = ctx.r[11].s64 + 3012;
	// 8219D840: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219D844: 38610058  addi r3, r1, 0x58
	ctx.r[3].s64 = ctx.r[1].s64 + 88;
	// 8219D848: 808BB9F8  lwz r4, -0x4608(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17928 as u32) ) } as u64;
	// 8219D84C: 4805B495  bl 0x821f8ce0
	ctx.lr = 0x8219D850;
	sub_821F8CE0(ctx, base);
	// 8219D850: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219D854: 4856FA19  bl 0x8270d26c
	ctx.lr = 0x8219D858;
	// extern call 0x8270D26C  crate::xboxkrnl::RtlLeaveCriticalSection
	crate::xboxkrnl::RtlLeaveCriticalSection(ctx, base);
	// 8219D858: 81610058  lwz r11, 0x58(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(88 as u32) ) } as u64;
	// 8219D85C: 3881005C  addi r4, r1, 0x5c
	ctx.r[4].s64 = ctx.r[1].s64 + 92;
	// 8219D860: 38610054  addi r3, r1, 0x54
	ctx.r[3].s64 = ctx.r[1].s64 + 84;
	// 8219D864: 91610050  stw r11, 0x50(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u32 ) };
	// 8219D868: 4BF86631  bl 0x82123e98
	ctx.lr = 0x8219D86C;
	sub_82123E98(ctx, base);
	// 8219D86C: 8061005C  lwz r3, 0x5c(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(92 as u32) ) } as u64;
	// 8219D870: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D874: 419A0008  beq cr6, 0x8219d87c
	if ctx.cr[6].eq {
	pc = 0x8219D87C; continue 'dispatch;
	}
	// 8219D878: 4BF7F7E1  bl 0x8211d058
	ctx.lr = 0x8219D87C;
	sub_8211D058(ctx, base);
	pc = 0x8219D87C; continue 'dispatch;
            }
            0x8219D87C => {
    //   block [0x8219D87C..0x8219D8C4)
	// 8219D87C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219D880: 83E10050  lwz r31, 0x50(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219D884: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219D888: 38EB0BD0  addi r7, r11, 0xbd0
	ctx.r[7].s64 = ctx.r[11].s64 + 3024;
	// 8219D88C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D890: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219D894: 38600090  li r3, 0x90
	ctx.r[3].s64 = 144;
	// 8219D898: 93DF003C  stw r30, 0x3c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(60 as u32), ctx.r[30].u32 ) };
	// 8219D89C: 808BFAC0  lwz r4, -0x540(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D8A0: 481CCBF1  bl 0x8236a490
	ctx.lr = 0x8219D8A4;
	sub_8236A490(ctx, base);
	// 8219D8A4: 83C10054  lwz r30, 0x54(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219D8A8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219D8AC: 419A003C  beq cr6, 0x8219d8e8
	if ctx.cr[6].eq {
	pc = 0x8219D8E8; continue 'dispatch;
	}
	// 8219D8B0: 93E10058  stw r31, 0x58(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(88 as u32), ctx.r[31].u32 ) };
	// 8219D8B4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219D8B8: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 8219D8BC: 419A0024  beq cr6, 0x8219d8e0
	if ctx.cr[6].eq {
	pc = 0x8219D8E0; continue 'dispatch;
	}
	// 8219D8C0: 397E0004  addi r11, r30, 4
	ctx.r[11].s64 = ctx.r[30].s64 + 4;
	pc = 0x8219D8C4; continue 'dispatch;
            }
            0x8219D8C4 => {
    //   block [0x8219D8C4..0x8219D8E0)
	// 8219D8C4: 7D2000A6  mfmsr r9
	ctx.r[9].u64 = ctx.msr;
	// 8219D8C8: 7DA10164  mtmsrd r13, 1
	ctx.msr = (ctx.r[13].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D8CC: 7D405828  lwarx r10, 0, r11
	// lwarx
	let ea = ctx.r[11].u32;
	ctx.reserved.u32 = unsafe { crate::rt::load_u32(base as *const u8, ea) };
	ctx.r[10].u64 = ctx.reserved.u32 as u64;
	// 8219D8D0: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219D8D4: 7D40592D  stwcx. r10, 0, r11
	// stwcx.
	let addr = ctx.r[11].u32;
	ctx.cr[0].lt = false;
	ctx.cr[0].gt = false;
	let ok = unsafe { crate::rt::stwcx32(base as *mut u8, addr, ctx.reserved.u32, ctx.r[10].u32) };
	ctx.cr[0].eq = ok;
	ctx.cr[0].so = ctx.xer.so;
	// 8219D8D8: 7D210164  mtmsrd r9, 1
	ctx.msr = (ctx.r[9].u32 & 0x8020) | (ctx.msr & !0x8020);
	// 8219D8DC: 4082FFE8  bne 0x8219d8c4
	if !ctx.cr[0].eq {
	pc = 0x8219D8C4; continue 'dispatch;
	}
	pc = 0x8219D8E0; continue 'dispatch;
            }
            0x8219D8E0 => {
    //   block [0x8219D8E0..0x8219D8E8)
	// 8219D8E0: 38810058  addi r4, r1, 0x58
	ctx.r[4].s64 = ctx.r[1].s64 + 88;
	// 8219D8E4: 4813AD0D  bl 0x822d85f0
	ctx.lr = 0x8219D8E8;
	sub_822D85F0(ctx, base);
	pc = 0x8219D8E8; continue 'dispatch;
            }
            0x8219D8E8 => {
    //   block [0x8219D8E8..0x8219D8F8)
	// 8219D8E8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219D8EC: 419A000C  beq cr6, 0x8219d8f8
	if ctx.cr[6].eq {
	pc = 0x8219D8F8; continue 'dispatch;
	}
	// 8219D8F0: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219D8F4: 4BF7F765  bl 0x8211d058
	ctx.lr = 0x8219D8F8;
	sub_8211D058(ctx, base);
	pc = 0x8219D8F8; continue 'dispatch;
            }
            0x8219D8F8 => {
    //   block [0x8219D8F8..0x8219D910)
	// 8219D8F8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219D8FC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219D900: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219D904: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219D908: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219D90C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219D910(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219D910 size=368
    let mut pc: u32 = 0x8219D910;
    'dispatch: loop {
        match pc {
            0x8219D910 => {
    //   block [0x8219D910..0x8219D94C)
	// 8219D910: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219D914: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219D918: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219D91C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219D920: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219D924: 80CBFAC0  lwz r6, -0x540(r11)
	ctx.r[6].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219D928: 3D6082C3  lis r11, -0x7d3d
	ctx.r[11].s64 = -2101149696;
	// 8219D92C: 394B5518  addi r10, r11, 0x5518
	ctx.r[10].s64 = ctx.r[11].s64 + 21784;
	// 8219D930: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219D934: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219D938: 419A0014  beq cr6, 0x8219d94c
	if ctx.cr[6].eq {
	pc = 0x8219D94C; continue 'dispatch;
	}
	// 8219D93C: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219D940: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219D944: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219D948: 419A0008  beq cr6, 0x8219d950
	if ctx.cr[6].eq {
	pc = 0x8219D950; continue 'dispatch;
	}
	pc = 0x8219D94C; continue 'dispatch;
            }
            0x8219D94C => {
    //   block [0x8219D94C..0x8219D950)
	// 8219D94C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219D950; continue 'dispatch;
            }
            0x8219D950 => {
    //   block [0x8219D950..0x8219D96C)
	// 8219D950: 38EB0090  addi r7, r11, 0x90
	ctx.r[7].s64 = ctx.r[11].s64 + 144;
	// 8219D954: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219D958: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8219D95C: 390BC470  addi r8, r11, -0x3b90
	ctx.r[8].s64 = ctx.r[11].s64 + -15248;
	// 8219D960: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8219D964: 394800E0  addi r10, r8, 0xe0
	ctx.r[10].s64 = ctx.r[8].s64 + 224;
	// 8219D968: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8219D96C; continue 'dispatch;
            }
            0x8219D96C => {
    //   block [0x8219D96C..0x8219D99C)
	// 8219D96C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D970: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219D974: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219D978: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219D97C: 4200FFF0  bdnz 0x8219d96c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219D96C; continue 'dispatch;
	}
	// 8219D980: 388800E0  addi r4, r8, 0xe0
	ctx.r[4].s64 = ctx.r[8].s64 + 224;
	// 8219D984: 386800E0  addi r3, r8, 0xe0
	ctx.r[3].s64 = ctx.r[8].s64 + 224;
	// 8219D988: 481CA301  bl 0x82367c88
	ctx.lr = 0x8219D98C;
	sub_82367C88(ctx, base);
	// 8219D98C: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	// 8219D990: 39200008  li r9, 8
	ctx.r[9].s64 = 8;
	// 8219D994: 394800A0  addi r10, r8, 0xa0
	ctx.r[10].s64 = ctx.r[8].s64 + 160;
	// 8219D998: 7D2903A6  mtctr r9
	ctx.ctr.u64 = ctx.r[9].u64;
	pc = 0x8219D99C; continue 'dispatch;
            }
            0x8219D99C => {
    //   block [0x8219D99C..0x8219DA28)
	// 8219D99C: E92B0000  ld r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 8219D9A0: 396B0008  addi r11, r11, 8
	ctx.r[11].s64 = ctx.r[11].s64 + 8;
	// 8219D9A4: F92A0000  std r9, 0(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[9].u64 ) };
	// 8219D9A8: 394A0008  addi r10, r10, 8
	ctx.r[10].s64 = ctx.r[10].s64 + 8;
	// 8219D9AC: 4200FFF0  bdnz 0x8219d99c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219D99C; continue 'dispatch;
	}
	// 8219D9B0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219D9B4: 388800A0  addi r4, r8, 0xa0
	ctx.r[4].s64 = ctx.r[8].s64 + 160;
	// 8219D9B8: 386800A0  addi r3, r8, 0xa0
	ctx.r[3].s64 = ctx.r[8].s64 + 160;
	// 8219D9BC: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219D9C0: D00800D8  stfs f0, 0xd8(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(216 as u32), tmp.u32 ) };
	// 8219D9C4: D00800D4  stfs f0, 0xd4(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(212 as u32), tmp.u32 ) };
	// 8219D9C8: D00800D0  stfs f0, 0xd0(r8)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(208 as u32), tmp.u32 ) };
	// 8219D9CC: 481CA2BD  bl 0x82367c88
	ctx.lr = 0x8219D9D0;
	sub_82367C88(ctx, base);
	// 8219D9D0: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219D9D4: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219D9D8: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219D9DC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219D9E0: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8219D9E4: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8219D9E8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219D9EC: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219D9F0: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219D9F4: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219D9F8: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8219D9FC: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219DA00: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8219DA04: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DA08: A1660014  lhz r11, 0x14(r6)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[6].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DA0C: 419A001C  beq cr6, 0x8219da28
	if ctx.cr[6].eq {
	pc = 0x8219DA28; continue 'dispatch;
	}
	// 8219DA10: 616B0400  ori r11, r11, 0x400
	ctx.r[11].u64 = ctx.r[11].u64 | 1024;
	// 8219DA14: B1660014  sth r11, 0x14(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DA18: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DA1C: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DA20: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DA24: 4E800020  blr
	return;
            }
            0x8219DA28 => {
    //   block [0x8219DA28..0x8219DA80)
	// 8219DA28: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219DA2C: 39800001  li r12, 1
	ctx.r[12].s64 = 1;
	// 8219DA30: 556B05A8  rlwinm r11, r11, 0, 0x16, 0x14
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DA34: 798CFFE6  rldicr r12, r12, 0x3f, 0x3f
	ctx.r[12].u64 = (ctx.r[12].u64).rotate_left(63) & 0xFFFFFFFFFFFFFFFF;
	// 8219DA38: B1660014  sth r11, 0x14(r6)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[6].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DA3C: 81650080  lwz r11, 0x80(r5)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[5].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219DA40: 816B0024  lwz r11, 0x24(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) } as u64;
	// 8219DA44: E94B00A0  ld r10, 0xa0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(160 as u32) ) };
	// 8219DA48: F94B0080  std r10, 0x80(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u64 ) };
	// 8219DA4C: E94B00A8  ld r10, 0xa8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(168 as u32) ) };
	// 8219DA50: F94B0088  std r10, 0x88(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u64 ) };
	// 8219DA54: E94B00B0  ld r10, 0xb0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(176 as u32) ) };
	// 8219DA58: F94B0090  std r10, 0x90(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 8219DA5C: E94B00B8  ld r10, 0xb8(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(184 as u32) ) };
	// 8219DA60: F94B0098  std r10, 0x98(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(152 as u32), ctx.r[10].u64 ) };
	// 8219DA64: E94B0078  ld r10, 0x78(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(120 as u32) ) };
	// 8219DA68: 7D4A6378  or r10, r10, r12
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[12].u64;
	// 8219DA6C: F94B0078  std r10, 0x78(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(120 as u32), ctx.r[10].u64 ) };
	// 8219DA70: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DA74: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DA78: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DA7C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DA80(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219DA80 size=48
    let mut pc: u32 = 0x8219DA80;
    'dispatch: loop {
        match pc {
            0x8219DA80 => {
    //   block [0x8219DA80..0x8219DA9C)
	// 8219DA80: 81030080  lwz r8, 0x80(r3)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219DA84: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 8219DA88: 4D9A0020  beqlr cr6
	if ctx.cr[6].eq { return; }
	// 8219DA8C: 39680004  addi r11, r8, 4
	ctx.r[11].s64 = ctx.r[8].s64 + 4;
	// 8219DA90: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DA94: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8219DA98: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8219DA9C; continue 'dispatch;
            }
            0x8219DA9C => {
    //   block [0x8219DA9C..0x8219DAB0)
	// 8219DA9C: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219DAA0: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219DAA4: 4200FFF8  bdnz 0x8219da9c
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219DA9C; continue 'dispatch;
	}
	// 8219DAA8: 9128002C  stw r9, 0x2c(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(44 as u32), ctx.r[9].u32 ) };
	// 8219DAAC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DAB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DAB0 size=580
    let mut pc: u32 = 0x8219DAB0;
    'dispatch: loop {
        match pc {
            0x8219DAB0 => {
    //   block [0x8219DAB0..0x8219DAE0)
	// 8219DAB0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DAB4: 48397609  bl 0x825350bc
	ctx.lr = 0x8219DAB8;
	sub_82535080(ctx, base);
	// 8219DAB8: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DABC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DAC0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DAC4: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DAC8: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219DACC: 39400008  li r10, 8
	ctx.r[10].s64 = 8;
	// 8219DAD0: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DAD4: 917F002C  stw r11, 0x2c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(44 as u32), ctx.r[11].u32 ) };
	// 8219DAD8: 397F0004  addi r11, r31, 4
	ctx.r[11].s64 = ctx.r[31].s64 + 4;
	// 8219DADC: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8219DAE0; continue 'dispatch;
            }
            0x8219DAE0 => {
    //   block [0x8219DAE0..0x8219DCF4)
	// 8219DAE0: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219DAE4: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219DAE8: 4200FFF8  bdnz 0x8219dae0
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219DAE0; continue 'dispatch;
	}
	// 8219DAEC: 1000038C  vspltisw v0, 0
	for i in 0..4 {
		ctx.v[0].u32[i] = 0;
	}
	// 8219DAF0: 39400090  li r10, 0x90
	ctx.r[10].s64 = 144;
	// 8219DAF4: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219DAF8: 38A00010  li r5, 0x10
	ctx.r[5].s64 = 16;
	// 8219DAFC: 3BCB1380  addi r30, r11, 0x1380
	ctx.r[30].s64 = ctx.r[11].s64 + 4992;
	// 8219DB00: 3D608288  lis r11, -0x7d78
	ctx.r[11].s64 = -2105016320;
	// 8219DB04: 387E0D30  addi r3, r30, 0xd30
	ctx.r[3].s64 = ctx.r[30].s64 + 3376;
	// 8219DB08: 396B8E40  addi r11, r11, -0x71c0
	ctx.r[11].s64 = ctx.r[11].s64 + -29120;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DCF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219DCF8 size=248
    let mut pc: u32 = 0x8219DCF8;
    'dispatch: loop {
        match pc {
            0x8219DCF8 => {
    //   block [0x8219DCF8..0x8219DD28)
	// 8219DCF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DCFC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219DD00: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219DD04: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DD08: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DD0C: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DD10: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	// 8219DD14: 815F0174  lwz r10, 0x174(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 8219DD18: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DD1C: 409A000C  bne cr6, 0x8219dd28
	if !ctx.cr[6].eq {
	pc = 0x8219DD28; continue 'dispatch;
	}
	// 8219DD20: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DD24: 48000028  b 0x8219dd4c
	pc = 0x8219DD4C; continue 'dispatch;
            }
            0x8219DD28 => {
    //   block [0x8219DD28..0x8219DD3C)
	// 8219DD28: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DD2C: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219DD30: 419A000C  beq cr6, 0x8219dd3c
	if ctx.cr[6].eq {
	pc = 0x8219DD3C; continue 'dispatch;
	}
	// 8219DD34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219DD38: 48000014  b 0x8219dd4c
	pc = 0x8219DD4C; continue 'dispatch;
            }
            0x8219DD3C => {
    //   block [0x8219DD3C..0x8219DD4C)
	// 8219DD3C: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DD40: 7D290034  cntlzw r9, r9
	ctx.r[9].u64 = if ctx.r[9].u32 == 0 { 32 } else { ctx.r[9].u32.leading_zeros() as u64 };
	// 8219DD44: 5529DFFE  rlwinm r9, r9, 0x1b, 0x1f, 0x1f
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x0000001Fu64;
	// 8219DD48: 69290001  xori r9, r9, 1
	ctx.r[9].u64 = ctx.r[9].u64 ^ 1;
	pc = 0x8219DD4C; continue 'dispatch;
            }
            0x8219DD4C => {
    //   block [0x8219DD4C..0x8219DD7C)
	// 8219DD4C: 5529063E  clrlwi r9, r9, 0x18
	ctx.r[9].u64 = ctx.r[9].u32 as u64 & 0x000000FFu64;
	// 8219DD50: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219DD54: 409A0028  bne cr6, 0x8219dd7c
	if !ctx.cr[6].eq {
	pc = 0x8219DD7C; continue 'dispatch;
	}
	// 8219DD58: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DD5C: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 8219DD60: 38CB0BD8  addi r6, r11, 0xbd8
	ctx.r[6].s64 = ctx.r[11].s64 + 3032;
	// 8219DD64: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DD68: 389F016C  addi r4, r31, 0x16c
	ctx.r[4].s64 = ctx.r[31].s64 + 364;
	// 8219DD6C: 386B5508  addi r3, r11, 0x5508
	ctx.r[3].s64 = ctx.r[11].s64 + 21768;
	// 8219DD70: 4808F7C9  bl 0x8222d538
	ctx.lr = 0x8219DD74;
	sub_8222D538(ctx, base);
	// 8219DD74: 815F0174  lwz r10, 0x174(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(372 as u32) ) } as u64;
	// 8219DD78: 817F016C  lwz r11, 0x16c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(364 as u32) ) } as u64;
	pc = 0x8219DD7C; continue 'dispatch;
            }
            0x8219DD7C => {
    //   block [0x8219DD7C..0x8219DD8C)
	// 8219DD7C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219DD80: 409A000C  bne cr6, 0x8219dd8c
	if !ctx.cr[6].eq {
	pc = 0x8219DD8C; continue 'dispatch;
	}
	// 8219DD84: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219DD88: 48000028  b 0x8219ddb0
	pc = 0x8219DDB0; continue 'dispatch;
            }
            0x8219DD8C => {
    //   block [0x8219DD8C..0x8219DDA0)
	// 8219DD8C: 812B0008  lwz r9, 8(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DD90: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219DD94: 419A000C  beq cr6, 0x8219dda0
	if ctx.cr[6].eq {
	pc = 0x8219DDA0; continue 'dispatch;
	}
	// 8219DD98: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219DD9C: 48000014  b 0x8219ddb0
	pc = 0x8219DDB0; continue 'dispatch;
            }
            0x8219DDA0 => {
    //   block [0x8219DDA0..0x8219DDB0)
	// 8219DDA0: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DDA4: 7D4A0034  cntlzw r10, r10
	ctx.r[10].u64 = if ctx.r[10].u32 == 0 { 32 } else { ctx.r[10].u32.leading_zeros() as u64 };
	// 8219DDA8: 554ADFFE  rlwinm r10, r10, 0x1b, 0x1f, 0x1f
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x0000001Fu64;
	// 8219DDAC: 694A0001  xori r10, r10, 1
	ctx.r[10].u64 = ctx.r[10].u64 ^ 1;
	pc = 0x8219DDB0; continue 'dispatch;
            }
            0x8219DDB0 => {
    //   block [0x8219DDB0..0x8219DDC4)
	// 8219DDB0: 554A063E  clrlwi r10, r10, 0x18
	ctx.r[10].u64 = ctx.r[10].u32 as u64 & 0x000000FFu64;
	// 8219DDB4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219DDB8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219DDBC: 419A0008  beq cr6, 0x8219ddc4
	if ctx.cr[6].eq {
	pc = 0x8219DDC4; continue 'dispatch;
	}
	// 8219DDC0: 808B0000  lwz r4, 0(r11)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	pc = 0x8219DDC4; continue 'dispatch;
            }
            0x8219DDC4 => {
    //   block [0x8219DDC4..0x8219DDF0)
	// 8219DDC4: 39000800  li r8, 0x800
	ctx.r[8].s64 = 2048;
	// 8219DDC8: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219DDCC: 38C00800  li r6, 0x800
	ctx.r[6].s64 = 2048;
	// 8219DDD0: 3CA00020  lis r5, 0x20
	ctx.r[5].s64 = 2097152;
	// 8219DDD4: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 8219DDD8: 48003D79  bl 0x821a1b50
	ctx.lr = 0x8219DDDC;
	sub_821A1B50(ctx, base);
	// 8219DDDC: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219DDE0: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219DDE4: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219DDE8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219DDEC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219DDF0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219DDF0 size=644
    let mut pc: u32 = 0x8219DDF0;
    'dispatch: loop {
        match pc {
            0x8219DDF0 => {
    //   block [0x8219DDF0..0x8219DE34)
	// 8219DDF0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219DDF4: 483972A9  bl 0x8253509c
	ctx.lr = 0x8219DDF8;
	sub_82535080(ctx, base);
	// 8219DDF8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219DDFC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE00: 38C03A98  li r6, 0x3a98
	ctx.r[6].s64 = 15000;
	// 8219DE04: 38EB0BEC  addi r7, r11, 0xbec
	ctx.r[7].s64 = ctx.r[11].s64 + 3052;
	// 8219DE08: 38A00080  li r5, 0x80
	ctx.r[5].s64 = 128;
	// 8219DE0C: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8219DE10: 481CC681  bl 0x8236a490
	ctx.lr = 0x8219DE14;
	sub_8236A490(ctx, base);
	// 8219DE14: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8219DE18: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DE1C: 419A0018  beq cr6, 0x8219de34
	if ctx.cr[6].eq {
	pc = 0x8219DE34; continue 'dispatch;
	}
	// 8219DE20: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE24: 7C7B1B78  mr r27, r3
	ctx.r[27].u64 = ctx.r[3].u64;
	// 8219DE28: 396B0CC8  addi r11, r11, 0xcc8
	ctx.r[11].s64 = ctx.r[11].s64 + 3272;
	// 8219DE2C: 91630000  stw r11, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DE30: 48000008  b 0x8219de38
	pc = 0x8219DE38; continue 'dispatch;
            }
            0x8219DE34 => {
    //   block [0x8219DE34..0x8219DE38)
	// 8219DE34: 7EBBAB78  mr r27, r21
	ctx.r[27].u64 = ctx.r[21].u64;
	pc = 0x8219DE38; continue 'dispatch;
            }
            0x8219DE38 => {
    //   block [0x8219DE38..0x8219DE7C)
	// 8219DE38: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219DE3C: A15B0014  lhz r10, 0x14(r27)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DE40: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	// 8219DE44: 3BEBC470  addi r31, r11, -0x3b90
	ctx.r[31].s64 = ctx.r[11].s64 + -15248;
	// 8219DE48: 7D4B0734  extsh r11, r10
	ctx.r[11].s64 = ctx.r[10].s16 as i64;
	// 8219DE4C: 3B5F0004  addi r26, r31, 4
	ctx.r[26].s64 = ctx.r[31].s64 + 4;
	// 8219DE50: 556B05A6  rlwinm r11, r11, 0, 0x16, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219DE54: B17B0014  sth r11, 0x14(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219DE58: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE5C: 93FB0080  stw r31, 0x80(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(128 as u32), ctx.r[31].u32 ) };
	// 8219DE60: 3B2B0F7C  addi r25, r11, 0xf7c
	ctx.r[25].s64 = ctx.r[11].s64 + 3964;
	// 8219DE64: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE68: 3AEB0C00  addi r23, r11, 0xc00
	ctx.r[23].s64 = ctx.r[11].s64 + 3072;
	// 8219DE6C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DE70: 3ACB0BF4  addi r22, r11, 0xbf4
	ctx.r[22].s64 = ctx.r[11].s64 + 3060;
	// 8219DE74: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219DE78: 3B0B52F0  addi r24, r11, 0x52f0
	ctx.r[24].s64 = ctx.r[11].s64 + 21232;
	pc = 0x8219DE7C; continue 'dispatch;
            }
            0x8219DE7C => {
    //   block [0x8219DE7C..0x8219DE94)
	// 8219DE7C: 2F1E0001  cmpwi cr6, r30, 1
	ctx.cr[6].compare_i32(ctx.r[30].s32, 1, &mut ctx.xer);
	// 8219DE80: 409A0014  bne cr6, 0x8219de94
	if !ctx.cr[6].eq {
	pc = 0x8219DE94; continue 'dispatch;
	}
	// 8219DE84: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219DE88: 3B807FFF  li r28, 0x7fff
	ctx.r[28].s64 = 32767;
	// 8219DE8C: 7FABC02E  lwzx r29, r11, r24
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8219DE90: 48000048  b 0x8219ded8
	pc = 0x8219DED8; continue 'dispatch;
            }
            0x8219DE94 => {
    //   block [0x8219DE94..0x8219DEAC)
	// 8219DE94: 7FDCF378  mr r28, r30
	ctx.r[28].u64 = ctx.r[30].u64;
	// 8219DE98: 2F1E0003  cmpwi cr6, r30, 3
	ctx.cr[6].compare_i32(ctx.r[30].s32, 3, &mut ctx.xer);
	// 8219DE9C: 41990010  bgt cr6, 0x8219deac
	if ctx.cr[6].gt {
	pc = 0x8219DEAC; continue 'dispatch;
	}
	// 8219DEA0: 57CB103A  slwi r11, r30, 2
	ctx.r[11].u32 = ctx.r[30].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219DEA4: 7FABC02E  lwzx r29, r11, r24
	ctx.r[29].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[24].u32)) } as u64;
	// 8219DEA8: 48000030  b 0x8219ded8
	pc = 0x8219DED8; continue 'dispatch;
            }
            0x8219DEAC => {
    //   block [0x8219DEAC..0x8219DED4)
	// 8219DEAC: 57CB07FE  clrlwi r11, r30, 0x1f
	ctx.r[11].u64 = ctx.r[30].u32 as u64 & 0x00000001u64;
	// 8219DEB0: 3BA10050  addi r29, r1, 0x50
	ctx.r[29].s64 = ctx.r[1].s64 + 80;
	// 8219DEB4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219DEB8: 397EFFFE  addi r11, r30, -2
	ctx.r[11].s64 = ctx.r[30].s64 + -2;
	// 8219DEBC: 38610050  addi r3, r1, 0x50
	ctx.r[3].s64 = ctx.r[1].s64 + 80;
	// 8219DEC0: 7D6B0E70  srawi r11, r11, 1
	ctx.xer.ca = (ctx.r[11].s32 < 0) && ((ctx.r[11].u32 & ((1u32 << 1) - 1)) != 0);
	ctx.r[11].s64 = (ctx.r[11].s32 >> 1) as i64;
	// 8219DEC4: 7EC4B378  mr r4, r22
	ctx.r[4].u64 = ctx.r[22].u64;
	// 8219DEC8: 7CAB0194  addze r5, r11
	tmp.s64 = ctx.r[11].s64 + ctx.xer.ca as i64;
	ctx.xer.ca = (tmp.u32 < ctx.r[11].u32);
	ctx.r[5].s64 = tmp.s64;
	// 8219DECC: 409A0008  bne cr6, 0x8219ded4
	if !ctx.cr[6].eq {
	pc = 0x8219DED4; continue 'dispatch;
	}
	// 8219DED0: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	pc = 0x8219DED4; continue 'dispatch;
            }
            0x8219DED4 => {
    //   block [0x8219DED4..0x8219DED8)
	// 8219DED4: 48394D4D  bl 0x82532c20
	ctx.lr = 0x8219DED8;
	sub_82532C20(ctx, base);
	pc = 0x8219DED8; continue 'dispatch;
            }
            0x8219DED8 => {
    //   block [0x8219DED8..0x8219DF04)
	// 8219DED8: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219DEDC: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8219DEE0: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219DEE4: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219DEE8: 38600088  li r3, 0x88
	ctx.r[3].s64 = 136;
	// 8219DEEC: 481CC5A5  bl 0x8236a490
	ctx.lr = 0x8219DEF0;
	sub_8236A490(ctx, base);
	// 8219DEF0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DEF4: 419A0010  beq cr6, 0x8219df04
	if ctx.cr[6].eq {
	pc = 0x8219DF04; continue 'dispatch;
	}
	// 8219DEF8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219DEFC: 93230000  stw r25, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[25].u32 ) };
	// 8219DF00: 48000008  b 0x8219df08
	pc = 0x8219DF08; continue 'dispatch;
            }
            0x8219DF04 => {
    //   block [0x8219DF04..0x8219DF08)
	// 8219DF04: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x8219DF08; continue 'dispatch;
            }
            0x8219DF08 => {
    //   block [0x8219DF08..0x8219DFF8)
	// 8219DF08: 3BDE0001  addi r30, r30, 1
	ctx.r[30].s64 = ctx.r[30].s64 + 1;
	// 8219DF0C: 917A0000  stw r11, 0(r26)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[26].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219DF10: 3B5A0004  addi r26, r26, 4
	ctx.r[26].s64 = ctx.r[26].s64 + 4;
	// 8219DF14: 2F1E0008  cmpwi cr6, r30, 8
	ctx.cr[6].compare_i32(ctx.r[30].s32, 8, &mut ctx.xer);
	// 8219DF18: 4198FF64  blt cr6, 0x8219de7c
	if ctx.cr[6].lt {
	pc = 0x8219DE7C; continue 'dispatch;
	}
	// 8219DF1C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219DF20: 815F0014  lwz r10, 0x14(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DF24: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 8219DF28: 388BE1A0  addi r4, r11, -0x1e60
	ctx.r[4].s64 = ctx.r[11].s64 + -7776;
	// 8219DF2C: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219DF30: 3909E1A0  addi r8, r9, -0x1e60
	ctx.r[8].s64 = ctx.r[9].s64 + -7776;
	// 8219DF34: 3BABE1A0  addi r29, r11, -0x1e60
	ctx.r[29].s64 = ctx.r[11].s64 + -7776;
	// 8219DF38: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219DF3C: 3D20821A  lis r9, -0x7de6
	ctx.r[9].s64 = -2112225280;
	// 8219DF40: 38EB0C08  addi r7, r11, 0xc08
	ctx.r[7].s64 = ctx.r[11].s64 + 3080;
	// 8219DF44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219DF48: 910A0058  stw r8, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[8].u32 ) };
	// 8219DF4C: 3BC9E1A0  addi r30, r9, -0x1e60
	ctx.r[30].s64 = ctx.r[9].s64 + -7776;
	// 8219DF50: 396B76FC  addi r11, r11, 0x76fc
	ctx.r[11].s64 = ctx.r[11].s64 + 30460;
	// 8219DF54: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219DF58: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219DF5C: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 8219DF60: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DF64: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF68: 815F0018  lwz r10, 0x18(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(24 as u32) ) } as u64;
	// 8219DF6C: 908A0058  stw r4, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[4].u32 ) };
	// 8219DF70: 812B0000  lwz r9, 0(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219DF74: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF78: 815F001C  lwz r10, 0x1c(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219DF7C: 93CA0058  stw r30, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[30].u32 ) };
	// 8219DF80: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF84: 912A0080  stw r9, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 8219DF88: 815F0020  lwz r10, 0x20(r31)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(32 as u32) ) } as u64;
	// 8219DF8C: 93AA0058  stw r29, 0x58(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(88 as u32), ctx.r[29].u32 ) };
	// 8219DF90: 816B0004  lwz r11, 4(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219DF94: 916A0080  stw r11, 0x80(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 8219DF98: 809F0008  lwz r4, 8(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219DF9C: 481CC4F5  bl 0x8236a490
	ctx.lr = 0x8219DFA0;
	sub_8236A490(ctx, base);
	// 8219DFA0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219DFA4: 419A0054  beq cr6, 0x8219dff8
	if ctx.cr[6].eq {
	pc = 0x8219DFF8; continue 'dispatch;
	}
	// 8219DFA8: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8219DFAC: A1230014  lhz r9, 0x14(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[3].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219DFB0: 396300C4  addi r11, r3, 0xc4
	ctx.r[11].s64 = ctx.r[3].s64 + 196;
	// 8219DFB4: 92A300C0  stw r21, 0xc0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(192 as u32), ctx.r[21].u32 ) };
	// 8219DFB8: 394A0EF8  addi r10, r10, 0xef8
	ctx.r[10].s64 = ctx.r[10].s64 + 3832;
	// 8219DFBC: 92A300C4  stw r21, 0xc4(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(196 as u32), ctx.r[21].u32 ) };
	// 8219DFC0: 6128000D  ori r8, r9, 0xd
	ctx.r[8].u64 = ctx.r[9].u64 | 13;
	// 8219DFC4: FAA300D0  std r21, 0xd0(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(208 as u32), ctx.r[21].u64 ) };
	// 8219DFC8: 3D20821B  lis r9, -0x7de5
	ctx.r[9].s64 = -2112159744;
	// 8219DFCC: 92A300CC  stw r21, 0xcc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(204 as u32), ctx.r[21].u32 ) };
	// 8219DFD0: 38FF0024  addi r7, r31, 0x24
	ctx.r[7].s64 = ctx.r[31].s64 + 36;
	// 8219DFD4: 916300C8  stw r11, 0xc8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(200 as u32), ctx.r[11].u32 ) };
	// 8219DFD8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219DFDC: 91430000  stw r10, 0(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 8219DFE0: 3949C3E0  addi r10, r9, -0x3c20
	ctx.r[10].s64 = ctx.r[9].s64 + -15392;
	// 8219DFE4: B1030014  sth r8, 0x14(r3)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[3].u32.wrapping_add(20 as u32), ctx.r[8].u16 ) };
	// 8219DFE8: 90E300D8  stw r7, 0xd8(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(216 as u32), ctx.r[7].u32 ) };
	// 8219DFEC: 9143005C  stw r10, 0x5c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(92 as u32), ctx.r[10].u32 ) };
	// 8219DFF0: 907F0024  stw r3, 0x24(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[3].u32 ) };
	// 8219DFF4: 48000008  b 0x8219dffc
	pc = 0x8219DFFC; continue 'dispatch;
            }
            0x8219DFF8 => {
    //   block [0x8219DFF8..0x8219DFFC)
	// 8219DFF8: 7EBEAB78  mr r30, r21
	ctx.r[30].u64 = ctx.r[21].u64;
	pc = 0x8219DFFC; continue 'dispatch;
            }
            0x8219DFFC => {
    //   block [0x8219DFFC..0x8219E030)
	// 8219DFFC: 817E00C0  lwz r11, 0xc0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(192 as u32) ) } as u64;
	// 8219E000: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219E004: 409A002C  bne cr6, 0x8219e030
	if !ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E008: 817E00C8  lwz r11, 0xc8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(200 as u32) ) } as u64;
	// 8219E00C: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E010: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E014: 409A001C  bne cr6, 0x8219e030
	if !ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E018: E97E00D0  ld r11, 0xd0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(208 as u32) ) };
	// 8219E01C: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8219E020: 419A0010  beq cr6, 0x8219e030
	if ctx.cr[6].eq {
	pc = 0x8219E030; continue 'dispatch;
	}
	// 8219E024: 5563003E  slwi r3, r11, 0
	ctx.r[3].u32 = ctx.r[11].u32.wrapping_shl(0);
	ctx.r[3].u64 = ctx.r[3].u32 as u64;
	// 8219E028: 481DACB1  bl 0x82378cd8
	ctx.lr = 0x8219E02C;
	sub_82378CD8(ctx, base);
	// 8219E02C: FABE00D0  std r21, 0xd0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(208 as u32), ctx.r[21].u64 ) };
	pc = 0x8219E030; continue 'dispatch;
            }
            0x8219E030 => {
    //   block [0x8219E030..0x8219E074)
	// 8219E030: 3D60821A  lis r11, -0x7de6
	ctx.r[11].s64 = -2112225280;
	// 8219E034: 396BE078  addi r11, r11, -0x1f88
	ctx.r[11].s64 = ctx.r[11].s64 + -8072;
	// 8219E038: 917E0058  stw r11, 0x58(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(88 as u32), ctx.r[11].u32 ) };
	// 8219E03C: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219E040: FABE00A0  std r21, 0xa0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(160 as u32), ctx.r[21].u64 ) };
	// 8219E044: FABE00A8  std r21, 0xa8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), ctx.r[21].u64 ) };
	// 8219E048: FABE00B0  std r21, 0xb0(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), ctx.r[21].u64 ) };
	// 8219E04C: FABE00B8  std r21, 0xb8(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(184 as u32), ctx.r[21].u64 ) };
	// 8219E050: F97E0080  std r11, 0x80(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(128 as u32), ctx.r[11].u64 ) };
	// 8219E054: E97E00A8  ld r11, 0xa8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(168 as u32) ) };
	// 8219E058: F97E0088  std r11, 0x88(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(136 as u32), ctx.r[11].u64 ) };
	// 8219E05C: E97E00B0  ld r11, 0xb0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(176 as u32) ) };
	// 8219E060: F97E0090  std r11, 0x90(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 8219E064: E97E00B8  ld r11, 0xb8(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[30].u32.wrapping_add(184 as u32) ) };
	// 8219E068: F97E0098  std r11, 0x98(r30)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[30].u32.wrapping_add(152 as u32), ctx.r[11].u64 ) };
	// 8219E06C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219E070: 4839707C  b 0x825350ec
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E078(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E078 size=292
    let mut pc: u32 = 0x8219E078;
    'dispatch: loop {
        match pc {
            0x8219E078 => {
    //   block [0x8219E078..0x8219E0F4)
	// 8219E078: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E07C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E080: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E084: DBE1FFE8  stfd f31, -0x18(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.f[31].u64 ) };
	// 8219E088: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E08C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219E090: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219E094: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219E098: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219E09C: 61298608  ori r9, r9, 0x8608
	ctx.r[9].u64 = ctx.r[9].u64 | 34312;
	// 8219E0A0: 614A8600  ori r10, r10, 0x8600
	ctx.r[10].u64 = ctx.r[10].u64 | 34304;
	// 8219E0A4: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E0A8: 7D4B502E  lwzx r10, r11, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E0AC: 7D4A4B78  or r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 | ctx.r[9].u64;
	// 8219E0B0: 3D200003  lis r9, 3
	ctx.r[9].s64 = 196608;
	// 8219E0B4: 6129860C  ori r9, r9, 0x860c
	ctx.r[9].u64 = ctx.r[9].u64 | 34316;
	// 8219E0B8: 7D6B482E  lwzx r11, r11, r9
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E0BC: 7D4B5B78  or r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 | ctx.r[11].u64;
	// 8219E0C0: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E0C4: 409A00BC  bne cr6, 0x8219e180
	if !ctx.cr[6].eq {
	pc = 0x8219E180; continue 'dispatch;
	}
	// 8219E0C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E0CC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E0D0: 816B0168  lwz r11, 0x168(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(360 as u32) ) } as u64;
	// 8219E0D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E0D8: 419A00A8  beq cr6, 0x8219e180
	if ctx.cr[6].eq {
	pc = 0x8219E180; continue 'dispatch;
	}
	// 8219E0DC: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E0E0: 39200002  li r9, 2
	ctx.r[9].s64 = 2;
	// 8219E0E4: 386B1290  addi r3, r11, 0x1290
	ctx.r[3].s64 = ctx.r[11].s64 + 4752;
	// 8219E0E8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219E0EC: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219E0F0: FD40F890  fmr f10, f31
	ctx.f[10].f64 = ctx.f[31].f64;
	pc = 0x8219E0F4; continue 'dispatch;
            }
            0x8219E0F4 => {
    //   block [0x8219E0F4..0x8219E104)
	// 8219E0F4: 4BFFE5D5  bl 0x8219c6c8
	ctx.lr = 0x8219E0F8;
	sub_8219C6C8(ctx, base);
	// 8219E0F8: FF015000  fcmpu cr6, f1, f10
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[10].f64);
	// 8219E0FC: 40980008  bge cr6, 0x8219e104
	if !ctx.cr[6].lt {
	pc = 0x8219E104; continue 'dispatch;
	}
	// 8219E100: FD400890  fmr f10, f1
	ctx.f[10].f64 = ctx.f[1].f64;
	pc = 0x8219E104; continue 'dispatch;
            }
            0x8219E104 => {
    //   block [0x8219E104..0x8219E12C)
	// 8219E104: 3929FFFF  addi r9, r9, -1
	ctx.r[9].s64 = ctx.r[9].s64 + -1;
	// 8219E108: 3863002C  addi r3, r3, 0x2c
	ctx.r[3].s64 = ctx.r[3].s64 + 44;
	// 8219E10C: 2F090000  cmpwi cr6, r9, 0
	ctx.cr[6].compare_i32(ctx.r[9].s32, 0, &mut ctx.xer);
	// 8219E110: 4199FFE4  bgt cr6, 0x8219e0f4
	if ctx.cr[6].gt {
	pc = 0x8219E0F4; continue 'dispatch;
	}
	// 8219E114: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219E118: 7D6B0034  cntlzw r11, r11
	ctx.r[11].u64 = if ctx.r[11].u32 == 0 { 32 } else { ctx.r[11].u32.leading_zeros() as u64 };
	// 8219E11C: 214B001F  subfic r10, r11, 0x1f
	ctx.xer.ca = ctx.r[11].u32 <= 31 as u32;
	ctx.r[10].s64 = (31 as i64) - ctx.r[11].s64;
	// 8219E120: 2B0A0010  cmplwi cr6, r10, 0x10
	ctx.cr[6].compare_u32(ctx.r[10].u32, 16 as u32, &mut ctx.xer);
	// 8219E124: 41980008  blt cr6, 0x8219e12c
	if ctx.cr[6].lt {
	pc = 0x8219E12C; continue 'dispatch;
	}
	// 8219E128: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	pc = 0x8219E12C; continue 'dispatch;
            }
            0x8219E12C => {
    //   block [0x8219E12C..0x8219E180)
	// 8219E12C: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219E130: 3BEB4A00  addi r31, r11, 0x4a00
	ctx.r[31].s64 = ctx.r[11].s64 + 18944;
	// 8219E134: 1D6A03C0  mulli r11, r10, 0x3c0
	ctx.r[11].s32 = ((ctx.r[10].s32 as i64 * 960 as i64) as i32);
	ctx.r[11].s64 = ctx.r[11].s32 as i64;
	// 8219E138: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E13C: C00A2604  lfs f0, 0x2604(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(9732 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219E140: 395F00F0  addi r10, r31, 0xf0
	ctx.r[10].s64 = ctx.r[31].s64 + 240;
	// 8219E144: EC2A0032  fmuls f1, f10, f0
	ctx.f[1].f64 = (((ctx.f[10].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219E148: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 8219E14C: D14B0000  stfs f10, 0(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219E150: D14B0004  stfs f10, 4(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219E154: D14B0008  stfs f10, 8(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219E158: D3EB000C  stfs f31, 0xc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219E15C: 4BF7F36D  bl 0x8211d4c8
	ctx.lr = 0x8219E160;
	sub_8211D4C8(ctx, base);
	// 8219E160: D3FF04BC  stfs f31, 0x4bc(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1212 as u32), tmp.u32 ) };
	// 8219E164: D3FF087C  stfs f31, 0x87c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2172 as u32), tmp.u32 ) };
	// 8219E168: D03F04B0  stfs f1, 0x4b0(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1200 as u32), tmp.u32 ) };
	// 8219E16C: D03F04B4  stfs f1, 0x4b4(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1204 as u32), tmp.u32 ) };
	// 8219E170: D03F04B8  stfs f1, 0x4b8(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(1208 as u32), tmp.u32 ) };
	// 8219E174: D03F0870  stfs f1, 0x870(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2160 as u32), tmp.u32 ) };
	// 8219E178: D03F0874  stfs f1, 0x874(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2164 as u32), tmp.u32 ) };
	// 8219E17C: D03F0878  stfs f1, 0x878(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(2168 as u32), tmp.u32 ) };
	pc = 0x8219E180; continue 'dispatch;
            }
            0x8219E180 => {
    //   block [0x8219E180..0x8219E19C)
	// 8219E180: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E184: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E188: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E18C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E190: CBE1FFE8  lfd f31, -0x18(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219E194: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E198: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E1A0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E1A0 size=116
    let mut pc: u32 = 0x8219E1A0;
    'dispatch: loop {
        match pc {
            0x8219E1A0 => {
    //   block [0x8219E1A0..0x8219E200)
	// 8219E1A0: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E1A4: 3D40830F  lis r10, -0x7cf1
	ctx.r[10].s64 = -2096168960;
	// 8219E1A8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E1AC: 814AFAC0  lwz r10, -0x540(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219E1B0: 816B0190  lwz r11, 0x190(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(400 as u32) ) } as u64;
	// 8219E1B4: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E1B8: 409A005C  bne cr6, 0x8219e214
	if !ctx.cr[6].eq {
		sub_8219E214(ctx, base);
		return;
	}
	// 8219E1BC: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219E1C0: 816A0080  lwz r11, 0x80(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219E1C4: 61299C00  ori r9, r9, 0x9c00
	ctx.r[9].u64 = ctx.r[9].u64 | 39936;
	// 8219E1C8: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E1CC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1D0: 419A0030  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1D4: 812B0010  lwz r9, 0x10(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219E1D8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1DC: 419A0024  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1E0: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219E1E4: 6129EB2B  ori r9, r9, 0xeb2b
	ctx.r[9].u64 = ctx.r[9].u64 | 60203;
	// 8219E1E8: 7D2B48AE  lbzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219E1EC: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E1F0: 409A0010  bne cr6, 0x8219e200
	if !ctx.cr[6].eq {
	pc = 0x8219E200; continue 'dispatch;
	}
	// 8219E1F4: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E1F8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E1FC: 409A0028  bne cr6, 0x8219e224
	if !ctx.cr[6].eq {
		sub_8219E214(ctx, base);
		return;
	}
	pc = 0x8219E200; continue 'dispatch;
            }
            0x8219E200 => {
    //   block [0x8219E200..0x8219E214)
	// 8219E200: A16A0014  lhz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E204: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E208: 616B0800  ori r11, r11, 0x800
	ctx.r[11].u64 = ctx.r[11].u64 | 2048;
	// 8219E20C: B16A0014  sth r11, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219E210: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E214(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E214 size=40
    let mut pc: u32 = 0x8219E214;
    'dispatch: loop {
        match pc {
            0x8219E214 => {
    //   block [0x8219E214..0x8219E234)
	// 8219E214: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 8219E218: 419AFFE8  beq cr6, 0x8219e200
	if ctx.cr[6].eq {
		sub_8219E1A0(ctx, base);
		return;
	}
	// 8219E21C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219E220: 409A0014  bne cr6, 0x8219e234
	if !ctx.cr[6].eq {
	pc = 0x8219E234; continue 'dispatch;
	}
	// 8219E224: A16A0014  lhz r11, 0x14(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[10].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E228: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E22C: 556B0566  rlwinm r11, r11, 0, 0x15, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E230: B16A0014  sth r11, 0x14(r10)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[10].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x8219E234; continue 'dispatch;
            }
            0x8219E234 => {
    //   block [0x8219E234..0x8219E23C)
	// 8219E234: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 8219E238: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E240(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219E240 size=188
    let mut pc: u32 = 0x8219E240;
    'dispatch: loop {
        match pc {
            0x8219E240 => {
    //   block [0x8219E240..0x8219E288)
	// 8219E240: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E244: 48396E79  bl 0x825350bc
	ctx.lr = 0x8219E248;
	sub_82535080(ctx, base);
	// 8219E248: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E24C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219E250: 3D4082CF  lis r10, -0x7d31
	ctx.r[10].s64 = -2100363264;
	// 8219E254: 7C9F2378  mr r31, r4
	ctx.r[31].u64 = ctx.r[4].u64;
	// 8219E258: F96AC448  std r11, -0x3bb8(r10)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[10].u32.wrapping_add(-15288 as u32), ctx.r[11].u64 ) };
	// 8219E25C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E260: 3BABC470  addi r29, r11, -0x3b90
	ctx.r[29].s64 = ctx.r[11].s64 + -15248;
	// 8219E264: 817D002C  lwz r11, 0x2c(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E268: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E26C: 419A0054  beq cr6, 0x8219e2c0
	if ctx.cr[6].eq {
	pc = 0x8219E2C0; continue 'dispatch;
	}
	// 8219E270: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E274: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219E278: 617EBE64  ori r30, r11, 0xbe64
	ctx.r[30].u64 = ctx.r[11].u64 | 48740;
	// 8219E27C: 419A000C  beq cr6, 0x8219e288
	if ctx.cr[6].eq {
	pc = 0x8219E288; continue 'dispatch;
	}
	// 8219E280: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219E284: 48000008  b 0x8219e28c
	pc = 0x8219E28C; continue 'dispatch;
            }
            0x8219E288 => {
    //   block [0x8219E288..0x8219E28C)
	// 8219E288: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x8219E28C; continue 'dispatch;
            }
            0x8219E28C => {
    //   block [0x8219E28C..0x8219E2AC)
	// 8219E28C: 396B0002  addi r11, r11, 2
	ctx.r[11].s64 = ctx.r[11].s64 + 2;
	// 8219E290: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219E294: 5564083C  slwi r4, r11, 1
	ctx.r[4].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[4].u64 = ctx.r[4].u32 as u64;
	// 8219E298: 48000069  bl 0x8219e300
	ctx.lr = 0x8219E29C;
	sub_8219E300(ctx, base);
	// 8219E29C: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 8219E2A0: 419A000C  beq cr6, 0x8219e2ac
	if ctx.cr[6].eq {
	pc = 0x8219E2AC; continue 'dispatch;
	}
	// 8219E2A4: 7D7FF0AE  lbzx r11, r31, r30
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[30].u32)) } as u64;
	// 8219E2A8: 48000008  b 0x8219e2b0
	pc = 0x8219E2B0; continue 'dispatch;
            }
            0x8219E2AC => {
    //   block [0x8219E2AC..0x8219E2B0)
	// 8219E2AC: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x8219E2B0; continue 'dispatch;
            }
            0x8219E2B0 => {
    //   block [0x8219E2B0..0x8219E2C0)
	// 8219E2B0: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E2B4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219E2B8: 388B0005  addi r4, r11, 5
	ctx.r[4].s64 = ctx.r[11].s64 + 5;
	// 8219E2BC: 48000045  bl 0x8219e300
	ctx.lr = 0x8219E2C0;
	sub_8219E300(ctx, base);
	pc = 0x8219E2C0; continue 'dispatch;
            }
            0x8219E2C0 => {
    //   block [0x8219E2C0..0x8219E2F4)
	// 8219E2C0: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 8219E2C4: 394BF800  addi r10, r11, -0x800
	ctx.r[10].s64 = ctx.r[11].s64 + -2048;
	// 8219E2C8: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E2CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E2D0: 419A0024  beq cr6, 0x8219e2f4
	if ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2D4: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E2D8: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E2DC: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E2E0: 409A0014  bne cr6, 0x8219e2f4
	if !ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2E4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E2E8: 419A000C  beq cr6, 0x8219e2f4
	if ctx.cr[6].eq {
	pc = 0x8219E2F4; continue 'dispatch;
	}
	// 8219E2EC: 39400006  li r10, 6
	ctx.r[10].s64 = 6;
	// 8219E2F0: 994B0019  stb r10, 0x19(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	pc = 0x8219E2F4; continue 'dispatch;
            }
            0x8219E2F4 => {
    //   block [0x8219E2F4..0x8219E2FC)
	// 8219E2F4: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E2F8: 48396E14  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E300(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219E300 size=104
    let mut pc: u32 = 0x8219E300;
    'dispatch: loop {
        match pc {
            0x8219E300 => {
    //   block [0x8219E300..0x8219E350)
	// 8219E300: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E304: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219E308: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 8219E30C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 8219E310: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E314: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E318: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219E31C: 814B002C  lwz r10, 0x2c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E320: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219E324: 419A002C  beq cr6, 0x8219e350
	if ctx.cr[6].eq {
	pc = 0x8219E350; continue 'dispatch;
	}
	// 8219E328: 548A103A  slwi r10, r4, 2
	ctx.r[10].u32 = ctx.r[4].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219E32C: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219E330: 3FE0830F  lis r31, -0x7cf1
	ctx.r[31].s64 = -2096168960;
	// 8219E334: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219E338: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219E33C: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E340: 83DFFAC0  lwz r30, -0x540(r31)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 8219E344: 907FFAC0  stw r3, -0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1344 as u32), ctx.r[3].u32 ) };
	// 8219E348: 481CBFB1  bl 0x8236a2f8
	ctx.lr = 0x8219E34C;
	sub_8236A2F8(ctx, base);
	// 8219E34C: 93DFFAC0  stw r30, -0x540(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(-1344 as u32), ctx.r[30].u32 ) };
	pc = 0x8219E350; continue 'dispatch;
            }
            0x8219E350 => {
    //   block [0x8219E350..0x8219E368)
	// 8219E350: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 8219E354: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219E358: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219E35C: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 8219E360: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 8219E364: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E368(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x8219E368 size=212
    let mut pc: u32 = 0x8219E368;
    'dispatch: loop {
        match pc {
            0x8219E368 => {
    //   block [0x8219E368..0x8219E380)
	// 8219E368: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219E36C: 616B91F6  ori r11, r11, 0x91f6
	ctx.r[11].u64 = ctx.r[11].u64 | 37366;
	// 8219E370: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E374: 2B0BFFFF  cmplwi cr6, r11, 0xffff
	ctx.cr[6].compare_u32(ctx.r[11].u32, 65535 as u32, &mut ctx.xer);
	// 8219E378: 409A0008  bne cr6, 0x8219e380
	if !ctx.cr[6].eq {
	pc = 0x8219E380; continue 'dispatch;
	}
	// 8219E37C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219E380; continue 'dispatch;
            }
            0x8219E380 => {
    //   block [0x8219E380..0x8219E3A8)
	// 8219E380: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E384: 556A0462  rlwinm r10, r11, 0, 0x11, 0x11
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E388: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 8219E38C: 409A001C  bne cr6, 0x8219e3a8
	if !ctx.cr[6].eq {
	pc = 0x8219E3A8; continue 'dispatch;
	}
	// 8219E390: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8219E394: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E398: 614A9208  ori r10, r10, 0x9208
	ctx.r[10].u64 = ctx.r[10].u64 | 37384;
	// 8219E39C: 7D43502E  lwzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E3A0: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E3A4: 419A0008  beq cr6, 0x8219e3ac
	if ctx.cr[6].eq {
	pc = 0x8219E3AC; continue 'dispatch;
	}
	pc = 0x8219E3A8; continue 'dispatch;
            }
            0x8219E3A8 => {
    //   block [0x8219E3A8..0x8219E3AC)
	// 8219E3A8: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	pc = 0x8219E3AC; continue 'dispatch;
            }
            0x8219E3AC => {
    //   block [0x8219E3AC..0x8219E3C4)
	// 8219E3AC: 556B04A0  rlwinm r11, r11, 0, 0x12, 0x10
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E3B0: 3940000F  li r10, 0xf
	ctx.r[10].s64 = 15;
	// 8219E3B4: 7D690734  extsh r9, r11
	ctx.r[9].s64 = ctx.r[11].s16 as i64;
	// 8219E3B8: 2F090010  cmpwi cr6, r9, 0x10
	ctx.cr[6].compare_i32(ctx.r[9].s32, 16, &mut ctx.xer);
	// 8219E3BC: 41980008  blt cr6, 0x8219e3c4
	if ctx.cr[6].lt {
	pc = 0x8219E3C4; continue 'dispatch;
	}
	// 8219E3C0: 3940001F  li r10, 0x1f
	ctx.r[10].s64 = 31;
	pc = 0x8219E3C4; continue 'dispatch;
            }
            0x8219E3C4 => {
    //   block [0x8219E3C4..0x8219E3F4)
	// 8219E3C4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E3C8: 616BF322  ori r11, r11, 0xf322
	ctx.r[11].u64 = ctx.r[11].u64 | 62242;
	// 8219E3CC: 7D635A2E  lhzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E3D0: 556B0026  rlwinm r11, r11, 0, 0, 0x13
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219E3D4: 2B0B1000  cmplwi cr6, r11, 0x1000
	ctx.cr[6].compare_u32(ctx.r[11].u32, 4096 as u32, &mut ctx.xer);
	// 8219E3D8: 419A001C  beq cr6, 0x8219e3f4
	if ctx.cr[6].eq {
	pc = 0x8219E3F4; continue 'dispatch;
	}
	// 8219E3DC: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E3E0: 616BEB1B  ori r11, r11, 0xeb1b
	ctx.r[11].u64 = ctx.r[11].u64 | 60187;
	// 8219E3E4: 7D6358AE  lbzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E3E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E3EC: 409A0008  bne cr6, 0x8219e3f4
	if !ctx.cr[6].eq {
	pc = 0x8219E3F4; continue 'dispatch;
	}
	// 8219E3F0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	pc = 0x8219E3F4; continue 'dispatch;
            }
            0x8219E3F4 => {
    //   block [0x8219E3F4..0x8219E41C)
	// 8219E3F4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219E3F8: 7D470734  extsh r7, r10
	ctx.r[7].s64 = ctx.r[10].s16 as i64;
	// 8219E3FC: 616B9210  ori r11, r11, 0x9210
	ctx.r[11].u64 = ctx.r[11].u64 | 37392;
	// 8219E400: 7D63582E  lwzx r11, r3, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E404: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 8219E408: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 8219E40C: 7D695B78  mr r9, r11
	ctx.r[9].u64 = ctx.r[11].u64;
	// 8219E410: 7F093800  cmpw cr6, r9, r7
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[7].s32, &mut ctx.xer);
	// 8219E414: 40990008  ble cr6, 0x8219e41c
	if !ctx.cr[6].gt {
	pc = 0x8219E41C; continue 'dispatch;
	}
	// 8219E418: 7D4B5378  mr r11, r10
	ctx.r[11].u64 = ctx.r[10].u64;
	pc = 0x8219E41C; continue 'dispatch;
            }
            0x8219E41C => {
    //   block [0x8219E41C..0x8219E42C)
	// 8219E41C: 2F080000  cmpwi cr6, r8, 0
	ctx.cr[6].compare_i32(ctx.r[8].s32, 0, &mut ctx.xer);
	// 8219E420: 419A000C  beq cr6, 0x8219e42c
	if ctx.cr[6].eq {
	pc = 0x8219E42C; continue 'dispatch;
	}
	// 8219E424: 616B4000  ori r11, r11, 0x4000
	ctx.r[11].u64 = ctx.r[11].u64 | 16384;
	// 8219E428: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	pc = 0x8219E42C; continue 'dispatch;
            }
            0x8219E42C => {
    //   block [0x8219E42C..0x8219E43C)
	// 8219E42C: 3D400005  lis r10, 5
	ctx.r[10].s64 = 327680;
	// 8219E430: 614A91F4  ori r10, r10, 0x91f4
	ctx.r[10].u64 = ctx.r[10].u64 | 37364;
	// 8219E434: 7D63532E  sthx r11, r3, r10
	unsafe { crate::rt::store_u16(base as *mut u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32), ctx.r[11].u16) };
	// 8219E438: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E440(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E440 size=1364
    let mut pc: u32 = 0x8219E440;
    'dispatch: loop {
        match pc {
            0x8219E440 => {
    //   block [0x8219E440..0x8219E490)
	// 8219E440: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E444: 48396C3D  bl 0x82535080
	ctx.lr = 0x8219E448;
	sub_82535080(ctx, base);
	// 8219E448: DBE1FF60  stfd f31, -0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-160 as u32), ctx.f[31].u64 ) };
	// 8219E44C: 9421FEE0  stwu r1, -0x120(r1)
	ea = ctx.r[1].u32.wrapping_add(-288 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E450: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E454: 90A10144  stw r5, 0x144(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(324 as u32), ctx.r[5].u32 ) };
	// 8219E458: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219E45C: 616FBE64  ori r15, r11, 0xbe64
	ctx.r[15].u64 = ctx.r[11].u64 | 48740;
	// 8219E460: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219E464: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E468: 3B2BC470  addi r25, r11, -0x3b90
	ctx.r[25].s64 = ctx.r[11].s64 + -15248;
	// 8219E46C: 419A0024  beq cr6, 0x8219e490
	if ctx.cr[6].eq {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E470: 7D7B78AE  lbzx r11, r27, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E474: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8219E478: 40980018  bge cr6, 0x8219e490
	if !ctx.cr[6].lt {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E47C: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219E480: 419A0010  beq cr6, 0x8219e490
	if ctx.cr[6].eq {
	pc = 0x8219E490; continue 'dispatch;
	}
	// 8219E484: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E488: 39590180  addi r10, r25, 0x180
	ctx.r[10].s64 = ctx.r[25].s64 + 384;
	// 8219E48C: 7CAB512E  stwx r5, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[5].u32) };
	pc = 0x8219E490; continue 'dispatch;
            }
            0x8219E490 => {
    //   block [0x8219E490..0x8219E4C4)
	// 8219E490: 3AA00000  li r21, 0
	ctx.r[21].s64 = 0;
	// 8219E494: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E498: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	// 8219E49C: 396B1410  addi r11, r11, 0x1410
	ctx.r[11].s64 = ctx.r[11].s64 + 5136;
	// 8219E4A0: 3D2082CF  lis r9, -0x7d31
	ctx.r[9].s64 = -2100363264;
	// 8219E4A4: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 8219E4A8: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 8219E4AC: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 8219E4B0: F949C448  std r10, -0x3bb8(r9)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[9].u32.wrapping_add(-15288 as u32), ctx.r[10].u64 ) };
	// 8219E4B4: 7EA9AB78  mr r9, r21
	ctx.r[9].u64 = ctx.r[21].u64;
	// 8219E4B8: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
	// 8219E4BC: 39400020  li r10, 0x20
	ctx.r[10].s64 = 32;
	// 8219E4C0: 7D4903A6  mtctr r10
	ctx.ctr.u64 = ctx.r[10].u64;
	pc = 0x8219E4C4; continue 'dispatch;
            }
            0x8219E4C4 => {
    //   block [0x8219E4C4..0x8219E548)
	// 8219E4C4: 912B0000  stw r9, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 8219E4C8: 396B0004  addi r11, r11, 4
	ctx.r[11].s64 = ctx.r[11].s64 + 4;
	// 8219E4CC: 4200FFF8  bdnz 0x8219e4c4
	ctx.ctr.u64 = ctx.ctr.u64.wrapping_sub(1);
	if ctx.ctr.u32 != 0 {
			pc = 0x8219E4C4; continue 'dispatch;
	}
	// 8219E4D0: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219E4D4: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E4D8: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219E4DC: 419A006C  beq cr6, 0x8219e548
	if ctx.cr[6].eq {
	pc = 0x8219E548; continue 'dispatch;
	}
	// 8219E4E0: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E4E4: 7D3B78AE  lbzx r9, r27, r15
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E4E8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219E4EC: 396B1290  addi r11, r11, 0x1290
	ctx.r[11].s64 = ctx.r[11].s64 + 4752;
	// 8219E4F0: C1AA20C8  lfs f13, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219E4F4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219E4F8: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219E4FC: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8219E500: C18AD4CC  lfs f12, -0x2b34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219E504: 1D49002C  mulli r10, r9, 0x2c
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8219E508: 3D208200  lis r9, -0x7e00
	ctx.r[9].s64 = -2113929216;
	// 8219E50C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219E510: C1692938  lfs f11, 0x2938(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(10552 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219E514: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 8219E518: D3EB000C  stfs f31, 0xc(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), tmp.u32 ) };
	// 8219E51C: 92AB0004  stw r21, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[21].u32 ) };
	// 8219E520: D3EB0008  stfs f31, 8(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219E524: 92AB0000  stw r21, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[21].u32 ) };
	// 8219E528: D1AB0010  stfs f13, 0x10(r11)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(16 as u32), tmp.u32 ) };
	// 8219E52C: D00B0014  stfs f0, 0x14(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(20 as u32), tmp.u32 ) };
	// 8219E530: C1492094  lfs f10, 0x2094(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(8340 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219E534: D00B0018  stfs f0, 0x18(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(24 as u32), tmp.u32 ) };
	// 8219E538: D18B001C  stfs f12, 0x1c(r11)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(28 as u32), tmp.u32 ) };
	// 8219E53C: D16B0020  stfs f11, 0x20(r11)
	tmp.f32 = (ctx.f[11].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(32 as u32), tmp.u32 ) };
	// 8219E540: D14B0024  stfs f10, 0x24(r11)
	tmp.f32 = (ctx.f[10].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(36 as u32), tmp.u32 ) };
	// 8219E544: D00B0028  stfs f0, 0x28(r11)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(40 as u32), tmp.u32 ) };
	pc = 0x8219E548; continue 'dispatch;
            }
            0x8219E548 => {
    //   block [0x8219E548..0x8219E5AC)
	// 8219E548: 8179002C  lwz r11, 0x2c(r25)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(44 as u32) ) } as u64;
	// 8219E54C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219E550: 419A0438  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E554: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219E558: 419A0430  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E55C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E560: 2B050000  cmplwi cr6, r5, 0
	ctx.cr[6].compare_u32(ctx.r[5].u32, 0 as u32, &mut ctx.xer);
	// 8219E564: 617CBEB8  ori r28, r11, 0xbeb8
	ctx.r[28].u64 = ctx.r[11].u64 | 48824;
	// 8219E568: 409A01C8  bne cr6, 0x8219e730
	if !ctx.cr[6].eq {
	pc = 0x8219E730; continue 'dispatch;
	}
	// 8219E56C: 7FBBE214  add r29, r27, r28
	ctx.r[29].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 8219E570: 3BE00400  li r31, 0x400
	ctx.r[31].s64 = 1024;
	// 8219E574: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E578: 2B0B0026  cmplwi cr6, r11, 0x26
	ctx.cr[6].compare_u32(ctx.r[11].u32, 38 as u32, &mut ctx.xer);
	// 8219E57C: 409A0030  bne cr6, 0x8219e5ac
	if !ctx.cr[6].eq {
	pc = 0x8219E5AC; continue 'dispatch;
	}
	// 8219E580: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E584: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E588: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E58C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E590: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E594: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E598: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E59C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E5A0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E5A4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E5A8: 4800E871  bl 0x821ace18
	ctx.lr = 0x8219E5AC;
	sub_821ACE18(ctx, base);
	pc = 0x8219E5AC; continue 'dispatch;
            }
            0x8219E5AC => {
    //   block [0x8219E5AC..0x8219E610)
	// 8219E5AC: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E5B0: 2B0B0027  cmplwi cr6, r11, 0x27
	ctx.cr[6].compare_u32(ctx.r[11].u32, 39 as u32, &mut ctx.xer);
	// 8219E5B4: 409A005C  bne cr6, 0x8219e610
	if !ctx.cr[6].eq {
	pc = 0x8219E610; continue 'dispatch;
	}
	// 8219E5B8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E5BC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E5C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E5C4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E5C8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E5CC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E5D0: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E5D4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E5D8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E5DC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E5E0: 4800E839  bl 0x821ace18
	ctx.lr = 0x8219E5E4;
	sub_821ACE18(ctx, base);
	// 8219E5E4: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E5E8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E5EC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E5F0: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E5F4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E5F8: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E5FC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E600: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E604: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E608: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E60C: 4800E80D  bl 0x821ace18
	ctx.lr = 0x8219E610;
	sub_821ACE18(ctx, base);
	pc = 0x8219E610; continue 'dispatch;
            }
            0x8219E610 => {
    //   block [0x8219E610..0x8219E648)
	// 8219E610: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E614: 2B0B0024  cmplwi cr6, r11, 0x24
	ctx.cr[6].compare_u32(ctx.r[11].u32, 36 as u32, &mut ctx.xer);
	// 8219E618: 409A0030  bne cr6, 0x8219e648
	if !ctx.cr[6].eq {
	pc = 0x8219E648; continue 'dispatch;
	}
	// 8219E61C: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E620: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E624: 39000020  li r8, 0x20
	ctx.r[8].s64 = 32;
	// 8219E628: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E62C: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E630: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E634: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E638: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E63C: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E640: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E644: 4800E7D5  bl 0x821ace18
	ctx.lr = 0x8219E648;
	sub_821ACE18(ctx, base);
	pc = 0x8219E648; continue 'dispatch;
            }
            0x8219E648 => {
    //   block [0x8219E648..0x8219E670)
	// 8219E648: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E64C: 2B0B000F  cmplwi cr6, r11, 0xf
	ctx.cr[6].compare_u32(ctx.r[11].u32, 15 as u32, &mut ctx.xer);
	// 8219E650: 409A007C  bne cr6, 0x8219e6cc
	if !ctx.cr[6].eq {
	pc = 0x8219E6CC; continue 'dispatch;
	}
	// 8219E654: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E658: 616BBF12  ori r11, r11, 0xbf12
	ctx.r[11].u64 = ctx.r[11].u64 | 48914;
	// 8219E65C: 7D7B5A2E  lhzx r11, r27, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219E660: 2B0B0528  cmplwi cr6, r11, 0x528
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1320 as u32, &mut ctx.xer);
	// 8219E664: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	// 8219E668: 419A0008  beq cr6, 0x8219e670
	if ctx.cr[6].eq {
	pc = 0x8219E670; continue 'dispatch;
	}
	// 8219E66C: 39600030  li r11, 0x30
	ctx.r[11].s64 = 48;
	pc = 0x8219E670; continue 'dispatch;
            }
            0x8219E670 => {
    //   block [0x8219E670..0x8219E6CC)
	// 8219E670: 7D7E0734  extsh r30, r11
	ctx.r[30].s64 = ctx.r[11].s16 as i64;
	// 8219E674: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E678: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E67C: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E680: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E684: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E688: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E68C: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E690: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E694: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E698: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8219E69C: 4800E77D  bl 0x821ace18
	ctx.lr = 0x8219E6A0;
	sub_821ACE18(ctx, base);
	// 8219E6A0: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E6A4: 7FC8F378  mr r8, r30
	ctx.r[8].u64 = ctx.r[30].u64;
	// 8219E6A8: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E6AC: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E6B0: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E6B4: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E6B8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E6BC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E6C0: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E6C4: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E6C8: 4800E751  bl 0x821ace18
	ctx.lr = 0x8219E6CC;
	sub_821ACE18(ctx, base);
	pc = 0x8219E6CC; continue 'dispatch;
            }
            0x8219E6CC => {
    //   block [0x8219E6CC..0x8219E730)
	// 8219E6CC: A17D0000  lhz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E6D0: 2B0B0011  cmplwi cr6, r11, 0x11
	ctx.cr[6].compare_u32(ctx.r[11].u32, 17 as u32, &mut ctx.xer);
	// 8219E6D4: 409A005C  bne cr6, 0x8219e730
	if !ctx.cr[6].eq {
	pc = 0x8219E730; continue 'dispatch;
	}
	// 8219E6D8: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E6DC: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E6E0: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 8219E6E4: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E6E8: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E6EC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E6F0: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E6F4: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E6F8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 8219E6FC: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E700: 4800E719  bl 0x821ace18
	ctx.lr = 0x8219E704;
	sub_821ACE18(ctx, base);
	// 8219E704: 39200010  li r9, 0x10
	ctx.r[9].s64 = 16;
	// 8219E708: 39000090  li r8, 0x90
	ctx.r[8].s64 = 144;
	// 8219E70C: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E710: 38E00003  li r7, 3
	ctx.r[7].s64 = 3;
	// 8219E714: 92A1005C  stw r21, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[21].u32 ) };
	// 8219E718: 38C0000E  li r6, 0xe
	ctx.r[6].s64 = 14;
	// 8219E71C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219E720: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 8219E724: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 8219E728: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219E72C: 4800E6ED  bl 0x821ace18
	ctx.lr = 0x8219E730;
	sub_821ACE18(ctx, base);
	pc = 0x8219E730; continue 'dispatch;
            }
            0x8219E730 => {
    //   block [0x8219E730..0x8219E784)
	// 8219E730: 7FDBE214  add r30, r27, r28
	ctx.r[30].u64 = ctx.r[27].u64 + ctx.r[28].u64;
	// 8219E734: A17E0000  lhz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E738: 93C10060  stw r30, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u32 ) };
	// 8219E73C: 2B0B0029  cmplwi cr6, r11, 0x29
	ctx.cr[6].compare_u32(ctx.r[11].u32, 41 as u32, &mut ctx.xer);
	// 8219E740: 409A0060  bne cr6, 0x8219e7a0
	if !ctx.cr[6].eq {
	pc = 0x8219E7A0; continue 'dispatch;
	}
	// 8219E744: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E748: 39590018  addi r10, r25, 0x18
	ctx.r[10].s64 = ctx.r[25].s64 + 24;
	// 8219E74C: 38EB0C14  addi r7, r11, 0xc14
	ctx.r[7].s64 = ctx.r[11].s64 + 3092;
	// 8219E750: 7D7B78AE  lbzx r11, r27, r15
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[15].u32)) } as u64;
	// 8219E754: 3FFB0006  addis r31, r27, 6
	ctx.r[31].s64 = ctx.r[27].s64 + 393216;
	// 8219E758: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 8219E75C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219E760: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219E764: 38600098  li r3, 0x98
	ctx.r[3].s64 = 152;
	// 8219E768: 3BFFA908  addi r31, r31, -0x56f8
	ctx.r[31].s64 = ctx.r[31].s64 + -22264;
	// 8219E76C: 7C8B502E  lwzx r4, r11, r10
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E770: 481CBD21  bl 0x8236a490
	ctx.lr = 0x8219E774;
	sub_8236A490(ctx, base);
	// 8219E774: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E778: 419A000C  beq cr6, 0x8219e784
	if ctx.cr[6].eq {
	pc = 0x8219E784; continue 'dispatch;
	}
	// 8219E77C: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E780: 48000008  b 0x8219e788
	pc = 0x8219E788; continue 'dispatch;
            }
            0x8219E784 => {
    //   block [0x8219E784..0x8219E788)
	// 8219E784: 7EABAB78  mr r11, r21
	ctx.r[11].u64 = ctx.r[21].u64;
	pc = 0x8219E788; continue 'dispatch;
            }
            0x8219E788 => {
    //   block [0x8219E788..0x8219E7A0)
	// 8219E788: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 8219E78C: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 8219E790: 907F0004  stw r3, 4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), ctx.r[3].u32 ) };
	// 8219E794: 419A000C  beq cr6, 0x8219e7a0
	if ctx.cr[6].eq {
	pc = 0x8219E7A0; continue 'dispatch;
	}
	// 8219E798: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219E79C: 4BFB0FD5  bl 0x8214f770
	ctx.lr = 0x8219E7A0;
	sub_8214F770(ctx, base);
	pc = 0x8219E7A0; continue 'dispatch;
            }
            0x8219E7A0 => {
    //   block [0x8219E7A0..0x8219E7D0)
	// 8219E7A0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7A4: 7EB3AB78  mr r19, r21
	ctx.r[19].u64 = ctx.r[21].u64;
	// 8219E7A8: 3A2B0C20  addi r17, r11, 0xc20
	ctx.r[17].s64 = ctx.r[11].s64 + 3104;
	// 8219E7AC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7B0: 7E328B78  mr r18, r17
	ctx.r[18].u64 = ctx.r[17].u64;
	// 8219E7B4: 3AEB0CB0  addi r23, r11, 0xcb0
	ctx.r[23].s64 = ctx.r[11].s64 + 3248;
	// 8219E7B8: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219E7BC: 7EB0AB78  mr r16, r21
	ctx.r[16].u64 = ctx.r[21].u64;
	// 8219E7C0: 3A8B0CC0  addi r20, r11, 0xcc0
	ctx.r[20].s64 = ctx.r[11].s64 + 3264;
	// 8219E7C4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219E7C8: 3AC00001  li r22, 1
	ctx.r[22].s64 = 1;
	// 8219E7CC: 616EBECC  ori r14, r11, 0xbecc
	ctx.r[14].u64 = ctx.r[11].u64 | 48844;
	pc = 0x8219E7D0; continue 'dispatch;
            }
            0x8219E7D0 => {
    //   block [0x8219E7D0..0x8219E830)
	// 8219E7D0: 89720000  lbz r11, 0(r18)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[18].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E7D4: A15E0000  lhz r10, 0(r30)
	ctx.r[10].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E7D8: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E7DC: 409A0198  bne cr6, 0x8219e974
	if !ctx.cr[6].eq {
	pc = 0x8219E974; continue 'dispatch;
	}
	// 8219E7E0: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219E7E4: 614ABEBA  ori r10, r10, 0xbeba
	ctx.r[10].u64 = ctx.r[10].u64 | 48826;
	// 8219E7E8: 7D5B522E  lhzx r10, r27, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E7EC: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219E7F0: 409A0184  bne cr6, 0x8219e974
	if !ctx.cr[6].eq {
	pc = 0x8219E974; continue 'dispatch;
	}
	// 8219E7F4: 7D7B702E  lwzx r11, r27, r14
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[27].u32.wrapping_add(ctx.r[14].u32)) } as u64;
	// 8219E7F8: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219E7FC: 4098018C  bge cr6, 0x8219e988
	if !ctx.cr[6].lt {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E800: 7D735A14  add r11, r19, r11
	ctx.r[11].u64 = ctx.r[19].u64 + ctx.r[11].u64;
	// 8219E804: 39510002  addi r10, r17, 2
	ctx.r[10].s64 = ctx.r[17].s64 + 2;
	// 8219E808: 556B083C  slwi r11, r11, 1
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E80C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E810: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 8219E814: 2F1CFFFF  cmpwi cr6, r28, -1
	ctx.cr[6].compare_i32(ctx.r[28].s32, -1, &mut ctx.xer);
	// 8219E818: 419A0170  beq cr6, 0x8219e988
	if ctx.cr[6].eq {
	pc = 0x8219E988; continue 'dispatch;
	}
	// 8219E81C: FAA10068  std r21, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[21].u64 ) };
	// 8219E820: 3BDB0030  addi r30, r27, 0x30
	ctx.r[30].s64 = ctx.r[27].s64 + 48;
	// 8219E824: 7F5B7A14  add r26, r27, r15
	ctx.r[26].u64 = ctx.r[27].u64 + ctx.r[15].u64;
	// 8219E828: 7E9DA378  mr r29, r20
	ctx.r[29].u64 = ctx.r[20].u64;
	// 8219E82C: 3B000002  li r24, 2
	ctx.r[24].s64 = 2;
	pc = 0x8219E830; continue 'dispatch;
            }
            0x8219E830 => {
    //   block [0x8219E830..0x8219E8D0)
	// 8219E830: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 8219E834: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219E838: 7F23CB78  mr r3, r25
	ctx.r[3].u64 = ctx.r[25].u64;
	// 8219E83C: 4BF8698D  bl 0x821251c8
	ctx.lr = 0x8219E840;
	sub_821251C8(ctx, base);
	// 8219E840: 546B103A  slwi r11, r3, 2
	ctx.r[11].u32 = ctx.r[3].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219E844: 39590004  addi r10, r25, 4
	ctx.r[10].s64 = ctx.r[25].s64 + 4;
	// 8219E848: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219E84C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219E850: 92C10054  stw r22, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[22].u32 ) };
	// 8219E854: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219E858: 7F86E378  mr r6, r28
	ctx.r[6].u64 = ctx.r[28].u64;
	// 8219E85C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219E860: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219E864: 7CAB502E  lwzx r5, r11, r10
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219E868: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219E86C: 481AD0F5  bl 0x8234b960
	ctx.lr = 0x8219E870;
	sub_8234B960(ctx, base);
	// 8219E870: 817E0000  lwz r11, 0(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E874: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219E878: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219E87C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219E880: 4E800421  bctrl
	ctx.lr = 0x8219E884;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219E884: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219E888: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219E88C: 80BD0000  lwz r5, 0(r29)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E890: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E894: 481AD4CD  bl 0x8234bd60
	ctx.lr = 0x8219E898;
	sub_8234BD60(ctx, base);
	// 8219E898: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219E89C: 7EE4BB78  mr r4, r23
	ctx.r[4].u64 = ctx.r[23].u64;
	// 8219E8A0: 481AD809  bl 0x8234c0a8
	ctx.lr = 0x8219E8A4;
	sub_8234C0A8(ctx, base);
	// 8219E8A4: 8161006C  lwz r11, 0x6c(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219E8A8: 81010068  lwz r8, 0x68(r1)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219E8AC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E8B0: 419A0020  beq cr6, 0x8219e8d0
	if ctx.cr[6].eq {
	pc = 0x8219E8D0; continue 'dispatch;
	}
	// 8219E8B4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E8B8: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E8BC: 409A0014  bne cr6, 0x8219e8d0
	if !ctx.cr[6].eq {
	pc = 0x8219E8D0; continue 'dispatch;
	}
	// 8219E8C0: 814B008C  lwz r10, 0x8c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219E8C4: D3EB00A8  stfs f31, 0xa8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219E8C8: 614A0004  ori r10, r10, 4
	ctx.r[10].u64 = ctx.r[10].u64 | 4;
	// 8219E8CC: 914B008C  stw r10, 0x8c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(140 as u32), ctx.r[10].u32 ) };
            }
            0x8219E8D0 => {
    //   block [0x8219E8D0..0x8219E904)
	// 8219E8D0: 895A0000  lbz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E8D4: 2B0A0002  cmplwi cr6, r10, 2
	ctx.cr[6].compare_u32(ctx.r[10].u32, 2 as u32, &mut ctx.xer);
	// 8219E8D8: 40980088  bge cr6, 0x8219e960
	if !ctx.cr[6].lt {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E8DC: 81210144  lwz r9, 0x144(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(324 as u32) ) } as u64;
	// 8219E8E0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219E8E4: 419A007C  beq cr6, 0x8219e960
	if ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E8E8: 81490000  lwz r10, 0(r9)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E8EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219E8F0: 419A0014  beq cr6, 0x8219e904
	if ctx.cr[6].eq {
	pc = 0x8219E904; continue 'dispatch;
	}
	// 8219E8F4: 80EA001C  lwz r7, 0x1c(r10)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(28 as u32) ) } as u64;
	// 8219E8F8: 81290004  lwz r9, 4(r9)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219E8FC: 7F074840  cmplw cr6, r7, r9
	ctx.cr[6].compare_u32(ctx.r[7].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219E900: 419A0008  beq cr6, 0x8219e908
	if ctx.cr[6].eq {
	pc = 0x8219E908; continue 'dispatch;
	}
	pc = 0x8219E904; continue 'dispatch;
            }
            0x8219E904 => {
    //   block [0x8219E904..0x8219E908)
	// 8219E904: 7EAAAB78  mr r10, r21
	ctx.r[10].u64 = ctx.r[21].u64;
	pc = 0x8219E908; continue 'dispatch;
            }
            0x8219E908 => {
    //   block [0x8219E908..0x8219E938)
	// 8219E908: 812A0010  lwz r9, 0x10(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) } as u64;
	// 8219E90C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E910: 912A0018  stw r9, 0x18(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(24 as u32), ctx.r[9].u32 ) };
	// 8219E914: 419A0024  beq cr6, 0x8219e938
	if ctx.cr[6].eq {
	pc = 0x8219E938; continue 'dispatch;
	}
	// 8219E918: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E91C: 7F0A4040  cmplw cr6, r10, r8
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E920: 409A0018  bne cr6, 0x8219e938
	if !ctx.cr[6].eq {
	pc = 0x8219E938; continue 'dispatch;
	}
	// 8219E924: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 8219E928: 892B0090  lbz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 8219E92C: 61290008  ori r9, r9, 8
	ctx.r[9].u64 = ctx.r[9].u64 | 8;
	// 8219E930: 992B0090  stb r9, 0x90(r11)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), ctx.r[9].u8 ) };
	// 8219E934: 914B0448  stw r10, 0x448(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1096 as u32), ctx.r[10].u32 ) };
	pc = 0x8219E938; continue 'dispatch;
            }
            0x8219E938 => {
    //   block [0x8219E938..0x8219E960)
	// 8219E938: 895A0000  lbz r10, 0(r26)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[26].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219E93C: 39390180  addi r9, r25, 0x180
	ctx.r[9].s64 = ctx.r[25].s64 + 384;
	// 8219E940: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E944: 554A183E  rotlwi r10, r10, 3
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(3)) as u64;
	// 8219E948: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 8219E94C: 419A0014  beq cr6, 0x8219e960
	if ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E950: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E954: 7F094040  cmplw cr6, r9, r8
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[8].u32, &mut ctx.xer);
	// 8219E958: 409A0008  bne cr6, 0x8219e960
	if !ctx.cr[6].eq {
	pc = 0x8219E960; continue 'dispatch;
	}
	// 8219E95C: 914B044C  stw r10, 0x44c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(1100 as u32), ctx.r[10].u32 ) };
	pc = 0x8219E960; continue 'dispatch;
            }
            0x8219E960 => {
    //   block [0x8219E960..0x8219E974)
	// 8219E960: 3B18FFFF  addi r24, r24, -1
	ctx.r[24].s64 = ctx.r[24].s64 + -1;
	// 8219E964: 3BBD0004  addi r29, r29, 4
	ctx.r[29].s64 = ctx.r[29].s64 + 4;
	// 8219E968: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8219E96C: 409AFEC4  bne cr6, 0x8219e830
	if !ctx.cr[6].eq {
	pc = 0x8219E830; continue 'dispatch;
	}
	// 8219E970: 83C10060  lwz r30, 0x60(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	pc = 0x8219E974; continue 'dispatch;
            }
            0x8219E974 => {
    //   block [0x8219E974..0x8219E988)
	// 8219E974: 3A100012  addi r16, r16, 0x12
	ctx.r[16].s64 = ctx.r[16].s64 + 18;
	// 8219E978: 3A520012  addi r18, r18, 0x12
	ctx.r[18].s64 = ctx.r[18].s64 + 18;
	// 8219E97C: 3A730009  addi r19, r19, 9
	ctx.r[19].s64 = ctx.r[19].s64 + 9;
	// 8219E980: 2B100090  cmplwi cr6, r16, 0x90
	ctx.cr[6].compare_u32(ctx.r[16].u32, 144 as u32, &mut ctx.xer);
	// 8219E984: 4198FE4C  blt cr6, 0x8219e7d0
	if ctx.cr[6].lt {
	pc = 0x8219E7D0; continue 'dispatch;
	}
	pc = 0x8219E988; continue 'dispatch;
            }
            0x8219E988 => {
    //   block [0x8219E988..0x8219E994)
	// 8219E988: 38210120  addi r1, r1, 0x120
	ctx.r[1].s64 = ctx.r[1].s64 + 288;
	// 8219E98C: CBE1FF60  lfd f31, -0xa0(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-160 as u32) ) };
	// 8219E990: 48396740  b 0x825350d0
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219E998(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219E998 size=184
    let mut pc: u32 = 0x8219E998;
    'dispatch: loop {
        match pc {
            0x8219E998 => {
    //   block [0x8219E998..0x8219E9F0)
	// 8219E998: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219E99C: 4839671D  bl 0x825350b8
	ctx.lr = 0x8219E9A0;
	sub_82535080(ctx, base);
	// 8219E9A0: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219E9A4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219E9A8: 7CBE0734  extsh r30, r5
	ctx.r[30].s64 = ctx.r[5].s16 as i64;
	// 8219E9AC: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219E9B0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 8219E9B4: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 8219E9B8: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 8219E9BC: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219E9C0: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 8219E9C4: 480128C5  bl 0x821b1288
	ctx.lr = 0x8219E9C8;
	sub_821B1288(ctx, base);
	// 8219E9C8: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8219E9CC: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219E9D0: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219E9D4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219E9D8: 419A0018  beq cr6, 0x8219e9f0
	if ctx.cr[6].eq {
	pc = 0x8219E9F0; continue 'dispatch;
	}
	// 8219E9DC: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219E9E0: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219E9E4: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219E9E8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219E9EC: 419A0008  beq cr6, 0x8219e9f4
	if ctx.cr[6].eq {
	pc = 0x8219E9F4; continue 'dispatch;
	}
	pc = 0x8219E9F0; continue 'dispatch;
            }
            0x8219E9F0 => {
    //   block [0x8219E9F0..0x8219E9F4)
	// 8219E9F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	pc = 0x8219E9F4; continue 'dispatch;
            }
            0x8219E9F4 => {
    //   block [0x8219E9F4..0x8219EA08)
	// 8219E9F4: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219E9F8: 409A0010  bne cr6, 0x8219ea08
	if !ctx.cr[6].eq {
	pc = 0x8219EA08; continue 'dispatch;
	}
	// 8219E9FC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EA00: 419A0048  beq cr6, 0x8219ea48
	if ctx.cr[6].eq {
	pc = 0x8219EA48; continue 'dispatch;
	}
	// 8219EA04: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	pc = 0x8219EA08; continue 'dispatch;
            }
            0x8219EA08 => {
    //   block [0x8219EA08..0x8219EA48)
	// 8219EA08: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219EA0C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219EA10: 7F8A0734  extsh r10, r28
	ctx.r[10].s64 = ctx.r[28].s16 as i64;
	// 8219EA14: 7FA9EB78  mr r9, r29
	ctx.r[9].u64 = ctx.r[29].u64;
	// 8219EA18: 5545103A  slwi r5, r10, 2
	ctx.r[5].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[5].u64 = ctx.r[5].u32 as u64;
	// 8219EA1C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219EA20: C04BBA38  lfs f2, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219EA24: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219EA28: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219EA2C: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 8219EA30: 396B1594  addi r11, r11, 0x1594
	ctx.r[11].s64 = ctx.r[11].s64 + 5524;
	// 8219EA34: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219EA38: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219EA3C: 38800001  li r4, 1
	ctx.r[4].s64 = 1;
	// 8219EA40: 7C65582E  lwzx r3, r5, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[5].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EA44: 4800BFB5  bl 0x821aa9f8
	ctx.lr = 0x8219EA48;
	sub_821AA9F8(ctx, base);
	pc = 0x8219EA48; continue 'dispatch;
            }
            0x8219EA48 => {
    //   block [0x8219EA48..0x8219EA50)
	// 8219EA48: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 8219EA4C: 483966BC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EA50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EA50 size=420
    let mut pc: u32 = 0x8219EA50;
    'dispatch: loop {
        match pc {
            0x8219EA50 => {
    //   block [0x8219EA50..0x8219EAD0)
	// 8219EA50: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EA54: 48396659  bl 0x825350ac
	ctx.lr = 0x8219EA58;
	sub_82535080(ctx, base);
	// 8219EA58: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EA5C: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 8219EA60: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219EA64: 397A3C67  addi r11, r26, 0x3c67
	ctx.r[11].s64 = ctx.r[26].s64 + 15463;
	// 8219EA68: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 8219EA6C: 556B1838  slwi r11, r11, 3
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(3);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 8219EA70: 7CBB2B78  mr r27, r5
	ctx.r[27].u64 = ctx.r[5].u64;
	// 8219EA74: 7CDE3378  mr r30, r6
	ctx.r[30].u64 = ctx.r[6].u64;
	// 8219EA78: 7CF93B78  mr r25, r7
	ctx.r[25].u64 = ctx.r[7].u64;
	// 8219EA7C: 613CE338  ori r28, r9, 0xe338
	ctx.r[28].u64 = ctx.r[9].u64 | 58168;
	// 8219EA80: 7D6BE82A  ldx r11, r11, r29
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[29].u32)) };
	// 8219EA84: 556A0252  rlwinm r10, r11, 0, 9, 9
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EA88: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EA8C: 419A0044  beq cr6, 0x8219ead0
	if ctx.cr[6].eq {
	pc = 0x8219EAD0; continue 'dispatch;
	}
	// 8219EA90: 3BE00016  li r31, 0x16
	ctx.r[31].s64 = 22;
	// 8219EA94: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219EA98: 38C10060  addi r6, r1, 0x60
	ctx.r[6].s64 = ctx.r[1].s64 + 96;
	// 8219EA9C: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219EAA0: 38A10050  addi r5, r1, 0x50
	ctx.r[5].s64 = ctx.r[1].s64 + 80;
	// 8219EAA4: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219EAA8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EAAC: 7C6BE214  add r3, r11, r28
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[28].u64;
	// 8219EAB0: 4BFBB1F9  bl 0x82159ca8
	ctx.lr = 0x8219EAB4;
	sub_82159CA8(ctx, base);
	// 8219EAB4: 817E000C  lwz r11, 0xc(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219EAB8: 2F190000  cmpwi cr6, r25, 0
	ctx.cr[6].compare_i32(ctx.r[25].s32, 0, &mut ctx.xer);
	// 8219EABC: 409A00BC  bne cr6, 0x8219eb78
	if !ctx.cr[6].eq {
	pc = 0x8219EB78; continue 'dispatch;
	}
	// 8219EAC0: 39410060  addi r10, r1, 0x60
	ctx.r[10].s64 = ctx.r[1].s64 + 96;
	pc = 0x8219EAD0; continue 'dispatch;
            }
            0x8219EAD0 => {
    //   block [0x8219EAD0..0x8219EB78)
	// 8219EAD0: 556A0210  rlwinm r10, r11, 0, 8, 8
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EAD4: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EAD8: 419A000C  beq cr6, 0x8219eae4
	if ctx.cr[6].eq {
	pc = 0x8219EAE4; continue 'dispatch;
	}
	// 8219EADC: 3BE00017  li r31, 0x17
	ctx.r[31].s64 = 23;
	// 8219EAE0: 4BFFFFB4  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EAE4: 556A01CE  rlwinm r10, r11, 0, 7, 7
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EAE8: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EAEC: 419A000C  beq cr6, 0x8219eaf8
	if ctx.cr[6].eq {
	pc = 0x8219EAF8; continue 'dispatch;
	}
	// 8219EAF0: 3BE00018  li r31, 0x18
	ctx.r[31].s64 = 24;
	// 8219EAF4: 4BFFFFA0  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EAF8: 556A018C  rlwinm r10, r11, 0, 6, 6
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EAFC: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EB00: 419A000C  beq cr6, 0x8219eb0c
	if ctx.cr[6].eq {
	pc = 0x8219EB0C; continue 'dispatch;
	}
	// 8219EB04: 3BE00019  li r31, 0x19
	ctx.r[31].s64 = 25;
	// 8219EB08: 4BFFFF8C  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB0C: 556A014A  rlwinm r10, r11, 0, 5, 5
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EB10: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EB14: 419A000C  beq cr6, 0x8219eb20
	if ctx.cr[6].eq {
	pc = 0x8219EB20; continue 'dispatch;
	}
	// 8219EB18: 3BE0001A  li r31, 0x1a
	ctx.r[31].s64 = 26;
	// 8219EB1C: 4BFFFF78  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB20: 556A0108  rlwinm r10, r11, 0, 4, 4
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EB24: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EB28: 419A000C  beq cr6, 0x8219eb34
	if ctx.cr[6].eq {
	pc = 0x8219EB34; continue 'dispatch;
	}
	// 8219EB2C: 3BE0001B  li r31, 0x1b
	ctx.r[31].s64 = 27;
	// 8219EB30: 4BFFFF64  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB34: 556A00C6  rlwinm r10, r11, 0, 3, 3
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EB38: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EB3C: 419A000C  beq cr6, 0x8219eb48
	if ctx.cr[6].eq {
	pc = 0x8219EB48; continue 'dispatch;
	}
	// 8219EB40: 3BE0001C  li r31, 0x1c
	ctx.r[31].s64 = 28;
	// 8219EB44: 4BFFFF50  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB48: 556A0318  rlwinm r10, r11, 0, 0xc, 0xc
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EB4C: 2B2A0000  cmpldi cr6, r10, 0
	ctx.cr[6].compare_u64(ctx.r[10].u64, 0, &mut ctx.xer);
	// 8219EB50: 419A000C  beq cr6, 0x8219eb5c
	if ctx.cr[6].eq {
	pc = 0x8219EB5C; continue 'dispatch;
	}
	// 8219EB54: 3BE00013  li r31, 0x13
	ctx.r[31].s64 = 19;
	// 8219EB58: 4BFFFF3C  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB5C: 556B02D6  rlwinm r11, r11, 0, 0xb, 0xb
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219EB60: 2B2B0000  cmpldi cr6, r11, 0
	ctx.cr[6].compare_u64(ctx.r[11].u64, 0, &mut ctx.xer);
	// 8219EB64: 419A000C  beq cr6, 0x8219eb70
	if ctx.cr[6].eq {
	pc = 0x8219EB70; continue 'dispatch;
	}
	// 8219EB68: 3BE00014  li r31, 0x14
	ctx.r[31].s64 = 20;
	// 8219EB6C: 4BFFFF28  b 0x8219ea94
	pc = 0x8219EA94; continue 'dispatch;
	// 8219EB70: 3BE0FFFF  li r31, -1
	ctx.r[31].s64 = -1;
	// 8219EB74: 48000020  b 0x8219eb94
	pc = 0x8219EB94; continue 'dispatch;
            }
            0x8219EB78 => {
    //   block [0x8219EB78..0x8219EBF4)
	// 8219EB78: 39410050  addi r10, r1, 0x50
	ctx.r[10].s64 = ctx.r[1].s64 + 80;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EBF8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EBF8 size=584
    let mut pc: u32 = 0x8219EBF8;
    'dispatch: loop {
        match pc {
            0x8219EBF8 => {
    //   block [0x8219EBF8..0x8219EE40)
	// 8219EBF8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EBFC: 483964BD  bl 0x825350b8
	ctx.lr = 0x8219EC00;
	sub_82535080(ctx, base);
	// 8219EC00: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8219EC04: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EC08: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219EC0C: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 8219EC10: 4BF90F41  bl 0x8212fb50
	ctx.lr = 0x8219EC14;
	sub_8212FB50(ctx, base);
	// 8219EC14: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219EC18: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219EC1C: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219EC20: 615EE338  ori r30, r10, 0xe338
	ctx.r[30].u64 = ctx.r[10].u64 | 58168;
	// 8219EC24: 7C7D0734  extsh r29, r3
	ctx.r[29].s64 = ctx.r[3].s16 as i64;
	// 8219EC28: 38C100B0  addi r6, r1, 0xb0
	ctx.r[6].s64 = ctx.r[1].s64 + 176;
	// 8219EC2C: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8219EC30: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219EC34: 7C6BF214  add r3, r11, r30
	ctx.r[3].u64 = ctx.r[11].u64 + ctx.r[30].u64;
	// 8219EC38: 4BFBB071  bl 0x82159ca8
	ctx.lr = 0x8219EC3C;
	sub_82159CA8(ctx, base);
	// 8219EC3C: 396100B0  addi r11, r1, 0xb0
	ctx.r[11].s64 = ctx.r[1].s64 + 176;
	// 8219EC40: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 8219EC44: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219EC48: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219EC4C: 7C7FF214  add r3, r31, r30
	ctx.r[3].u64 = ctx.r[31].u64 + ctx.r[30].u64;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EE40(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219EE40 size=396
    let mut pc: u32 = 0x8219EE40;
    'dispatch: loop {
        match pc {
            0x8219EE40 => {
    //   block [0x8219EE40..0x8219EE9C)
	// 8219EE40: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EE44: 48396279  bl 0x825350bc
	ctx.lr = 0x8219EE48;
	sub_82535080(ctx, base);
	// 8219EE48: DBE1FFD8  stfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-40 as u32), ctx.f[31].u64 ) };
	// 8219EE4C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EE50: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 8219EE54: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219EE58: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219EE5C: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 8219EE60: 816A4300  lwz r11, 0x4300(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17152 as u32) ) } as u64;
	// 8219EE64: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219EE68: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219EE6C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219EE70: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 8219EE74: 3BE942F0  addi r31, r9, 0x42f0
	ctx.r[31].s64 = ctx.r[9].s64 + 17136;
	// 8219EE78: 409A0024  bne cr6, 0x8219ee9c
	if !ctx.cr[6].eq {
	pc = 0x8219EE9C; continue 'dispatch;
	}
	// 8219EE7C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219EE80: 916A4300  stw r11, 0x4300(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17152 as u32), ctx.r[11].u32 ) };
	// 8219EE84: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219EE88: C00BD47C  lfs f0, -0x2b84(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11140 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EE8C: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 8219EE90: D3FF0004  stfs f31, 4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 8219EE94: D3FF0008  stfs f31, 8(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 8219EE98: D3FF000C  stfs f31, 0xc(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x8219EE9C; continue 'dispatch;
            }
            0x8219EE9C => {
    //   block [0x8219EE9C..0x8219EFC0)
	// 8219EE9C: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219EEA0: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 8219EEA4: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219EEA8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219EEAC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219EEB0: 4E800421  bctrl
	ctx.lr = 0x8219EEB4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219EEB4: C0030030  lfs f0, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEB8: D0010070  stfs f0, 0x70(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 8219EEBC: C0030034  lfs f0, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEC0: D0010074  stfs f0, 0x74(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 8219EEC4: C0030038  lfs f0, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEC8: D3E1008C  stfs f31, 0x8c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 8219EECC: D3E1007C  stfs f31, 0x7c(r1)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 8219EED0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 8219EED4: 481C8265  bl 0x82367138
	ctx.lr = 0x8219EED8;
	sub_82367138(ctx, base);
	// 8219EED8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219EEDC: C00B2068  lfs f0, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219EEE0: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EEE4: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EEE8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219EEEC: C9A10060  lfd f13, 0x60(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EEF0: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 8219EEF4: FD806818  frsp f12, f13
	ctx.f[12].f64 = (ctx.f[13].f64 as f32) as f64;
	// 8219EEF8: C1AB2280  lfs f13, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219EEFC: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF00: ED8CF838  fmsubs f12, f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF04: D1810080  stfs f12, 0x80(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 8219EF08: 481C8231  bl 0x82367138
	ctx.lr = 0x8219EF0C;
	sub_82367138(ctx, base);
	// 8219EF0C: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EF10: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EF14: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EF18: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219EF1C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219EF20: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF24: ED8CF838  fmsubs f12, f12, f0, f31
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF28: D1810084  stfs f12, 0x84(r1)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 8219EF2C: 481C820D  bl 0x82367138
	ctx.lr = 0x8219EF30;
	sub_82367138(ctx, base);
	// 8219EF30: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 8219EF34: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219EF38: 38810080  addi r4, r1, 0x80
	ctx.r[4].s64 = ctx.r[1].s64 + 128;
	// 8219EF3C: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219EF40: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 8219EF44: C9810060  lfd f12, 0x60(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[12].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) };
	// 8219EF48: FD80669C  fcfid f12, f12
	ctx.f[12].f64 = (ctx.f[12].s64 as f64);
	// 8219EF4C: FD806018  frsp f12, f12
	ctx.f[12].f64 = (ctx.f[12].f64 as f32) as f64;
	// 8219EF50: EDAC0372  fmuls f13, f12, f13
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219EF54: EC0DF838  fmsubs f0, f13, f0, f31
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 - ctx.f[31].f64) as f32) as f64);
	// 8219EF58: D0010088  stfs f0, 0x88(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(136 as u32), tmp.u32 ) };
	// 8219EF5C: 48007C8D  bl 0x821a6be8
	ctx.lr = 0x8219EF60;
	sub_821A6BE8(ctx, base);
	// 8219EF60: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219EF64: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219EF68: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219EF6C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219EF70: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219EF74: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219EF78: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219EF7C: 9161005C  stw r11, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[11].u32 ) };
	// 8219EF80: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219EF84: 91610054  stw r11, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[11].u32 ) };
	// 8219EF88: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219EF8C: 48002325  bl 0x821a12b0
	ctx.lr = 0x8219EF90;
	sub_821A12B0(ctx, base);
	// 8219EF90: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219EF94: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219EF98: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219EF9C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219EFA0: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219EFA4: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219EFA8: 409A0018  bne cr6, 0x8219efc0
	if !ctx.cr[6].eq {
	pc = 0x8219EFC0; continue 'dispatch;
	}
	// 8219EFAC: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219EFB0: 7FA5EB78  mr r5, r29
	ctx.r[5].u64 = ctx.r[29].u64;
	// 8219EFB4: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219EFB8: 38600009  li r3, 9
	ctx.r[3].s64 = 9;
	// 8219EFBC: 4BFDDE45  bl 0x8217ce00
	ctx.lr = 0x8219EFC0;
	sub_8217CE00(ctx, base);
            }
            0x8219EFC0 => {
    //   block [0x8219EFC0..0x8219EFCC)
	// 8219EFC0: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 8219EFC4: CBE1FFD8  lfd f31, -0x28(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-40 as u32) ) };
	// 8219EFC8: 48396144  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219EFD0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219EFD0 size=96
    let mut pc: u32 = 0x8219EFD0;
    'dispatch: loop {
        match pc {
            0x8219EFD0 => {
    //   block [0x8219EFD0..0x8219F000)
	// 8219EFD0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219EFD4: 483960E1  bl 0x825350b4
	ctx.lr = 0x8219EFD8;
	sub_82535080(ctx, base);
	// 8219EFD8: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219EFDC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219EFE0: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219EFE4: 3B8BC450  addi r28, r11, -0x3bb0
	ctx.r[28].s64 = ctx.r[11].s64 + -15280;
	// 8219EFE8: 3BA00000  li r29, 0
	ctx.r[29].s64 = 0;
	// 8219EFEC: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219EFF0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219EFF4: 419A0034  beq cr6, 0x8219f028
	if ctx.cr[6].eq {
	pc = 0x8219F028; continue 'dispatch;
	}
	// 8219EFF8: 3BFC000C  addi r31, r28, 0xc
	ctx.r[31].s64 = ctx.r[28].s64 + 12;
	// 8219EFFC: 3BDC0002  addi r30, r28, 2
	ctx.r[30].s64 = ctx.r[28].s64 + 2;
	pc = 0x8219F000; continue 'dispatch;
            }
            0x8219F000 => {
    //   block [0x8219F000..0x8219F028)
	// 8219F000: 7F63DB78  mr r3, r27
	ctx.r[3].u64 = ctx.r[27].u64;
	// 8219F004: A0BE0000  lhz r5, 0(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F008: 809F0000  lwz r4, 0(r31)
	ctx.r[4].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F00C: 481AD14D  bl 0x8234c158
	ctx.lr = 0x8219F010;
	sub_8234C158(ctx, base);
	// 8219F010: A17C0000  lhz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F014: 3BBD0001  addi r29, r29, 1
	ctx.r[29].s64 = ctx.r[29].s64 + 1;
	// 8219F018: 3BFF0004  addi r31, r31, 4
	ctx.r[31].s64 = ctx.r[31].s64 + 4;
	// 8219F01C: 3BDE0002  addi r30, r30, 2
	ctx.r[30].s64 = ctx.r[30].s64 + 2;
	// 8219F020: 7F1D5800  cmpw cr6, r29, r11
	ctx.cr[6].compare_i32(ctx.r[29].s32, ctx.r[11].s32, &mut ctx.xer);
	// 8219F024: 4198FFDC  blt cr6, 0x8219f000
	if ctx.cr[6].lt {
	pc = 0x8219F000; continue 'dispatch;
	}
	pc = 0x8219F028; continue 'dispatch;
            }
            0x8219F028 => {
    //   block [0x8219F028..0x8219F030)
	// 8219F028: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 8219F02C: 483960D8  b 0x82535104
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F030(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F030 size=1828
    let mut pc: u32 = 0x8219F030;
    'dispatch: loop {
        match pc {
            0x8219F030 => {
    //   block [0x8219F030..0x8219F0D4)
	// 8219F030: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F034: 48396051  bl 0x82535084
	ctx.lr = 0x8219F038;
	sub_82535080(ctx, base);
	// 8219F038: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8219F03C: 48396FA1  bl 0x82535fdc
	ctx.lr = 0x8219F040;
	sub_82535FB0(ctx, base);
	// 8219F040: 9421FE70  stwu r1, -0x190(r1)
	ea = ctx.r[1].u32.wrapping_add(-400 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F044: 54BE057E  clrlwi r30, r5, 0x15
	ctx.r[30].u64 = ctx.r[5].u32 as u64 & 0x000007FFu64;
	// 8219F048: FF800890  fmr f28, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[28].f64 = ctx.f[1].f64;
	// 8219F04C: 3A400000  li r18, 0
	ctx.r[18].s64 = 0;
	// 8219F050: FF601090  fmr f27, f2
	ctx.f[27].f64 = ctx.f[2].f64;
	// 8219F054: 397EFFA8  addi r11, r30, -0x58
	ctx.r[11].s64 = ctx.r[30].s64 + -88;
	// 8219F058: FF401890  fmr f26, f3
	ctx.f[26].f64 = ctx.f[3].f64;
	// 8219F05C: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 8219F060: FF202090  fmr f25, f4
	ctx.f[25].f64 = ctx.f[4].f64;
	// 8219F064: 2B0B0002  cmplwi cr6, r11, 2
	ctx.cr[6].compare_u32(ctx.r[11].u32, 2 as u32, &mut ctx.xer);
	// 8219F068: FFC02890  fmr f30, f5
	ctx.f[30].f64 = ctx.f[5].f64;
	// 8219F06C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219F070: FFA03090  fmr f29, f6
	ctx.f[29].f64 = ctx.f[6].f64;
	// 8219F074: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F078: 7C731B78  mr r19, r3
	ctx.r[19].u64 = ctx.r[3].u64;
	// 8219F07C: 7C952378  mr r21, r4
	ctx.r[21].u64 = ctx.r[4].u64;
	// 8219F080: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F084: 7CCF3378  mr r15, r6
	ctx.r[15].u64 = ctx.r[6].u64;
	// 8219F088: 54B40428  rlwinm r20, r5, 0, 0x10, 0x14
	ctx.r[20].u64 = ctx.r[5].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F08C: 6151BE64  ori r17, r10, 0xbe64
	ctx.r[17].u64 = ctx.r[10].u64 | 48740;
	// 8219F090: 3A0BC450  addi r16, r11, -0x3bb0
	ctx.r[16].s64 = ctx.r[11].s64 + -15280;
	// 8219F094: 419902A0  bgt cr6, 0x8219f334
	if ctx.cr[6].gt {
	pc = 0x8219F334; continue 'dispatch;
	}
	// 8219F098: 7E669B78  mr r6, r19
	ctx.r[6].u64 = ctx.r[19].u64;
	// 8219F09C: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 8219F0A0: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219F0A4: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F0A8: 480121E1  bl 0x821b1288
	ctx.lr = 0x8219F0AC;
	sub_821B1288(ctx, base);
	// 8219F0AC: EB230000  ld r25, 0(r3)
	ctx.r[25].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 8219F0B0: FB210060  std r25, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[25].u64 ) };
	// 8219F0B4: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 8219F0B8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F0BC: 419A0018  beq cr6, 0x8219f0d4
	if ctx.cr[6].eq {
	pc = 0x8219F0D4; continue 'dispatch;
	}
	// 8219F0C0: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F0C4: 3B4B0080  addi r26, r11, 0x80
	ctx.r[26].s64 = ctx.r[11].s64 + 128;
	// 8219F0C8: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 8219F0CC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F0D0: 419A0008  beq cr6, 0x8219f0d8
	if ctx.cr[6].eq {
	pc = 0x8219F0D8; continue 'dispatch;
	}
	pc = 0x8219F0D4; continue 'dispatch;
            }
            0x8219F0D4 => {
    //   block [0x8219F0D4..0x8219F0D8)
	// 8219F0D4: 7E5A9378  mr r26, r18
	ctx.r[26].u64 = ctx.r[18].u64;
	pc = 0x8219F0D8; continue 'dispatch;
            }
            0x8219F0D8 => {
    //   block [0x8219F0D8..0x8219F0F0)
	// 8219F0D8: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219F0DC: 409A0014  bne cr6, 0x8219f0f0
	if !ctx.cr[6].eq {
	pc = 0x8219F0F0; continue 'dispatch;
	}
	// 8219F0E0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8219F0E4: 409A000C  bne cr6, 0x8219f0f0
	if !ctx.cr[6].eq {
	pc = 0x8219F0F0; continue 'dispatch;
	}
	// 8219F0E8: 7E5F9378  mr r31, r18
	ctx.r[31].u64 = ctx.r[18].u64;
	// 8219F0EC: 4800062C  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
            }
            0x8219F0F0 => {
    //   block [0x8219F0F0..0x8219F118)
	// 8219F0F0: 396FFFF9  addi r11, r15, -7
	ctx.r[11].s64 = ctx.r[15].s64 + -7;
	// 8219F0F4: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219F0F8: 41990034  bgt cr6, 0x8219f12c
	if ctx.cr[6].gt {
	pc = 0x8219F12C; continue 'dispatch;
	}
	// 8219F0FC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F100: 419A0018  beq cr6, 0x8219f118
	if ctx.cr[6].eq {
	pc = 0x8219F118; continue 'dispatch;
	}
	// 8219F104: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F108: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F10C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F110: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F114: 48000038  b 0x8219f14c
	pc = 0x8219F14C; continue 'dispatch;
            }
            0x8219F118 => {
    //   block [0x8219F118..0x8219F12C)
	// 8219F118: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F11C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F120: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F124: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F128: 48000024  b 0x8219f14c
	pc = 0x8219F14C; continue 'dispatch;
            }
            0x8219F12C => {
    //   block [0x8219F12C..0x8219F13C)
	// 8219F12C: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F130: 419A000C  beq cr6, 0x8219f13c
	if ctx.cr[6].eq {
	pc = 0x8219F13C; continue 'dispatch;
	}
	// 8219F134: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F138: 48000008  b 0x8219f140
	pc = 0x8219F140; continue 'dispatch;
            }
            0x8219F13C => {
    //   block [0x8219F13C..0x8219F140)
	// 8219F13C: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x8219F140; continue 'dispatch;
            }
            0x8219F140 => {
    //   block [0x8219F140..0x8219F14C)
	// 8219F140: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F144: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F148: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	pc = 0x8219F14C; continue 'dispatch;
            }
            0x8219F14C => {
    //   block [0x8219F14C..0x8219F1AC)
	// 8219F14C: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F150: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F154: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F158: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F15C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F160: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F164: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F168: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F16C: 7CAA582E  lwzx r5, r10, r11
	ctx.r[5].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F170: 38610060  addi r3, r1, 0x60
	ctx.r[3].s64 = ctx.r[1].s64 + 96;
	// 8219F174: 481AC7ED  bl 0x8234b960
	ctx.lr = 0x8219F178;
	sub_8234B960(ctx, base);
	// 8219F178: 8361006C  lwz r27, 0x6c(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F17C: 2B1B0000  cmplwi cr6, r27, 0
	ctx.cr[6].compare_u32(ctx.r[27].u32, 0 as u32, &mut ctx.xer);
	// 8219F180: 419A0594  beq cr6, 0x8219f714
	if ctx.cr[6].eq {
	pc = 0x8219F714; continue 'dispatch;
	}
	// 8219F184: 817B0030  lwz r11, 0x30(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F188: 3BBB0030  addi r29, r27, 0x30
	ctx.r[29].s64 = ctx.r[27].s64 + 48;
	// 8219F18C: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F190: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F194: 409A0580  bne cr6, 0x8219f714
	if !ctx.cr[6].eq {
	pc = 0x8219F714; continue 'dispatch;
	}
	// 8219F198: D37B00AC  stfs f27, 0xac(r27)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 8219F19C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F1A0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F1A4: 409A0008  bne cr6, 0x8219f1ac
	if !ctx.cr[6].eq {
	pc = 0x8219F1AC; continue 'dispatch;
	}
	// 8219F1A8: D35B00B0  stfs f26, 0xb0(r27)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(176 as u32), tmp.u32 ) };
	pc = 0x8219F1AC; continue 'dispatch;
            }
            0x8219F1AC => {
    //   block [0x8219F1AC..0x8219F1C8)
	// 8219F1AC: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F1B0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F1B4: 409A0014  bne cr6, 0x8219f1c8
	if !ctx.cr[6].eq {
	pc = 0x8219F1C8; continue 'dispatch;
	}
	// 8219F1B8: 817B008C  lwz r11, 0x8c(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F1BC: D33B00A8  stfs f25, 0xa8(r27)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F1C0: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F1C4: 917B008C  stw r11, 0x8c(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	pc = 0x8219F1C8; continue 'dispatch;
            }
            0x8219F1C8 => {
    //   block [0x8219F1C8..0x8219F1E0)
	// 8219F1C8: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 8219F1CC: 409A00FC  bne cr6, 0x8219f2c8
	if !ctx.cr[6].eq {
	pc = 0x8219F2C8; continue 'dispatch;
	}
	// 8219F1D0: 817A0088  lwz r11, 0x88(r26)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[26].u32.wrapping_add(136 as u32) ) } as u64;
	// 8219F1D4: 556A07BC  rlwinm r10, r11, 0, 0x1e, 0x1e
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F1D8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F1DC: 419A000C  beq cr6, 0x8219f1e8
	if ctx.cr[6].eq {
	pc = 0x8219F1E8; continue 'dispatch;
	}
	pc = 0x8219F1E0; continue 'dispatch;
            }
            0x8219F1E0 => {
    //   block [0x8219F1E0..0x8219F1E8)
	// 8219F1E0: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F1E4: 480000E8  b 0x8219f2cc
	pc = 0x8219F2CC; continue 'dispatch;
            }
            0x8219F1E8 => {
    //   block [0x8219F1E8..0x8219F228)
	// 8219F1E8: 556A077A  rlwinm r10, r11, 0, 0x1d, 0x1d
	ctx.r[10].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F1EC: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F1F0: 419A0068  beq cr6, 0x8219f258
	if ctx.cr[6].eq {
	pc = 0x8219F258; continue 'dispatch;
	}
	// 8219F1F4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F1F8: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219F1FC: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F200: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F204: 419A0030  beq cr6, 0x8219f234
	if ctx.cr[6].eq {
	pc = 0x8219F234; continue 'dispatch;
	}
	// 8219F208: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F20C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F210: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F214: 409A0020  bne cr6, 0x8219f234
	if !ctx.cr[6].eq {
	pc = 0x8219F234; continue 'dispatch;
	}
	// 8219F218: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F21C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219F220: 409A0008  bne cr6, 0x8219f228
	if !ctx.cr[6].eq {
	pc = 0x8219F228; continue 'dispatch;
	}
	// 8219F224: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x8219F228; continue 'dispatch;
            }
            0x8219F228 => {
    //   block [0x8219F228..0x8219F234)
	// 8219F228: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219F22C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219F230: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x8219F234; continue 'dispatch;
            }
            0x8219F234 => {
    //   block [0x8219F234..0x8219F258)
	// 8219F234: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F238: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F23C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F240: 481ACBD9  bl 0x8234be18
	ctx.lr = 0x8219F244;
	sub_8234BE18(ctx, base);
	// 8219F244: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F248: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F24C: 409A008C  bne cr6, 0x8219f2d8
	if !ctx.cr[6].eq {
	pc = 0x8219F2D8; continue 'dispatch;
	}
	// 8219F250: FB3B0450  std r25, 0x450(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(1104 as u32), ctx.r[25].u64 ) };
	// 8219F254: 48000084  b 0x8219f2d8
	pc = 0x8219F2D8; continue 'dispatch;
            }
            0x8219F258 => {
    //   block [0x8219F258..0x8219F298)
	// 8219F258: 556B07FE  clrlwi r11, r11, 0x1f
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219F25C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F260: 419AFF80  beq cr6, 0x8219f1e0
	if ctx.cr[6].eq {
	pc = 0x8219F1E0; continue 'dispatch;
	}
	// 8219F264: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F268: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 8219F26C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 8219F270: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F274: 419A0030  beq cr6, 0x8219f2a4
	if ctx.cr[6].eq {
	pc = 0x8219F2A4; continue 'dispatch;
	}
	// 8219F278: 812B0030  lwz r9, 0x30(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F27C: 814A0000  lwz r10, 0(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F280: 7F095040  cmplw cr6, r9, r10
	ctx.cr[6].compare_u32(ctx.r[9].u32, ctx.r[10].u32, &mut ctx.xer);
	// 8219F284: 409A0020  bne cr6, 0x8219f2a4
	if !ctx.cr[6].eq {
	pc = 0x8219F2A4; continue 'dispatch;
	}
	// 8219F288: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F28C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 8219F290: 409A0008  bne cr6, 0x8219f298
	if !ctx.cr[6].eq {
	pc = 0x8219F298; continue 'dispatch;
	}
	// 8219F294: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x8219F298; continue 'dispatch;
            }
            0x8219F298 => {
    //   block [0x8219F298..0x8219F2A4)
	// 8219F298: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 8219F29C: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 8219F2A0: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x8219F2A4; continue 'dispatch;
            }
            0x8219F2A4 => {
    //   block [0x8219F2A4..0x8219F2C8)
	// 8219F2A4: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F2A8: 389A0060  addi r4, r26, 0x60
	ctx.r[4].s64 = ctx.r[26].s64 + 96;
	// 8219F2AC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F2B0: 481ACB69  bl 0x8234be18
	ctx.lr = 0x8219F2B4;
	sub_8234BE18(ctx, base);
	// 8219F2B4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F2B8: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F2BC: 409A001C  bne cr6, 0x8219f2d8
	if !ctx.cr[6].eq {
	pc = 0x8219F2D8; continue 'dispatch;
	}
	// 8219F2C0: FB3B0450  std r25, 0x450(r27)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[27].u32.wrapping_add(1104 as u32), ctx.r[25].u64 ) };
	// 8219F2C4: 48000014  b 0x8219f2d8
	pc = 0x8219F2D8; continue 'dispatch;
            }
            0x8219F2C8 => {
    //   block [0x8219F2C8..0x8219F2CC)
	// 8219F2C8: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	pc = 0x8219F2CC; continue 'dispatch;
            }
            0x8219F2CC => {
    //   block [0x8219F2CC..0x8219F2D8)
	// 8219F2CC: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F2D0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F2D4: 481ACDD5  bl 0x8234c0a8
	ctx.lr = 0x8219F2D8;
	sub_8234C0A8(ctx, base);
	pc = 0x8219F2D8; continue 'dispatch;
            }
            0x8219F2D8 => {
    //   block [0x8219F2D8..0x8219F30C)
	// 8219F2D8: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F2DC: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F2E0: 4BFFFCF1  bl 0x8219efd0
	ctx.lr = 0x8219F2E4;
	sub_8219EFD0(ctx, base);
	// 8219F2E4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219F2E8: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F2EC: FF1E0000  fcmpu cr6, f30, f0
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[0].f64);
	// 8219F2F0: 419A001C  beq cr6, 0x8219f30c
	if ctx.cr[6].eq {
	pc = 0x8219F30C; continue 'dispatch;
	}
	// 8219F2F4: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F2F8: 80E101EC  lwz r7, 0x1ec(r1)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F2FC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F300: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F304: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F308: 481AC881  bl 0x8234bb88
	ctx.lr = 0x8219F30C;
	sub_8234BB88(ctx, base);
	pc = 0x8219F30C; continue 'dispatch;
            }
            0x8219F30C => {
    //   block [0x8219F30C..0x8219F334)
	// 8219F30C: 568B0528  rlwinm r11, r20, 0, 0x14, 0x14
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F310: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F314: 419A0404  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F318: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F31C: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F320: 409A03F8  bne cr6, 0x8219f718
	if !ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F324: A17B0014  lhz r11, 0x14(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[27].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F328: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F32C: B17B0014  sth r11, 0x14(r27)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[27].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	// 8219F330: 480003E8  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
            }
            0x8219F334 => {
    //   block [0x8219F334..0x8219F35C)
	// 8219F334: 396FFFF9  addi r11, r15, -7
	ctx.r[11].s64 = ctx.r[15].s64 + -7;
	// 8219F338: 2B0B0008  cmplwi cr6, r11, 8
	ctx.cr[6].compare_u32(ctx.r[11].u32, 8 as u32, &mut ctx.xer);
	// 8219F33C: 41990034  bgt cr6, 0x8219f370
	if ctx.cr[6].gt {
	pc = 0x8219F370; continue 'dispatch;
	}
	// 8219F340: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F344: 419A0018  beq cr6, 0x8219f35c
	if ctx.cr[6].eq {
	pc = 0x8219F35C; continue 'dispatch;
	}
	// 8219F348: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F34C: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F350: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F354: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F358: 48000038  b 0x8219f390
	pc = 0x8219F390; continue 'dispatch;
            }
            0x8219F35C => {
    //   block [0x8219F35C..0x8219F370)
	// 8219F35C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F360: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	// 8219F364: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F368: 396B0018  addi r11, r11, 0x18
	ctx.r[11].s64 = ctx.r[11].s64 + 24;
	// 8219F36C: 48000024  b 0x8219f390
	pc = 0x8219F390; continue 'dispatch;
            }
            0x8219F370 => {
    //   block [0x8219F370..0x8219F380)
	// 8219F370: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 8219F374: 419A000C  beq cr6, 0x8219f380
	if ctx.cr[6].eq {
	pc = 0x8219F380; continue 'dispatch;
	}
	// 8219F378: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F37C: 48000008  b 0x8219f384
	pc = 0x8219F384; continue 'dispatch;
            }
            0x8219F380 => {
    //   block [0x8219F380..0x8219F384)
	// 8219F380: 3940FFFF  li r10, -1
	ctx.r[10].s64 = -1;
	pc = 0x8219F384; continue 'dispatch;
            }
            0x8219F384 => {
    //   block [0x8219F384..0x8219F390)
	// 8219F384: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F388: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F38C: 396B0014  addi r11, r11, 0x14
	ctx.r[11].s64 = ctx.r[11].s64 + 20;
	pc = 0x8219F390; continue 'dispatch;
            }
            0x8219F390 => {
    //   block [0x8219F390..0x8219F3DC)
	// 8219F390: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F394: 38A100B0  addi r5, r1, 0xb0
	ctx.r[5].s64 = ctx.r[1].s64 + 176;
	// 8219F398: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219F39C: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F3A0: 7ECA582E  lwzx r22, r10, r11
	ctx.r[22].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F3A4: 48004575  bl 0x821a3918
	ctx.lr = 0x8219F3A8;
	sub_821A3918(ctx, base);
	// 8219F3A8: 568B0462  rlwinm r11, r20, 0, 0x11, 0x11
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F3AC: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F3B0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F3B4: 419A0134  beq cr6, 0x8219f4e8
	if ctx.cr[6].eq {
	pc = 0x8219F4E8; continue 'dispatch;
	}
	// 8219F3B8: 48004701  bl 0x821a3ab8
	ctx.lr = 0x8219F3BC;
	sub_821A3AB8(ctx, base);
	// 8219F3BC: 7C791B78  mr r25, r3
	ctx.r[25].u64 = ctx.r[3].u64;
	// 8219F3C0: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F3C4: 419A0354  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F3C8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219F3CC: 836101EC  lwz r27, 0x1ec(r1)
	ctx.r[27].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F3D0: 3B930030  addi r28, r19, 0x30
	ctx.r[28].s64 = ctx.r[19].s64 + 48;
	// 8219F3D4: 569A0528  rlwinm r26, r20, 0, 0x14, 0x14
	ctx.r[26].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F3D8: C3EB1FF8  lfs f31, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	pc = 0x8219F3DC; continue 'dispatch;
            }
            0x8219F3DC => {
    //   block [0x8219F3DC..0x8219F424)
	// 8219F3DC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F3E0: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F3E4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F3E8: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F3EC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F3F0: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F3F4: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8219F3F8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F3FC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F400: 481AC561  bl 0x8234b960
	ctx.lr = 0x8219F404;
	sub_8234B960(ctx, base);
	// 8219F404: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F408: 83A10068  lwz r29, 0x68(r1)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F40C: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F410: 419A0040  beq cr6, 0x8219f450
	if ctx.cr[6].eq {
	pc = 0x8219F450; continue 'dispatch;
	}
	// 8219F414: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F418: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F41C: 409A0008  bne cr6, 0x8219f424
	if !ctx.cr[6].eq {
	pc = 0x8219F424; continue 'dispatch;
	}
	// 8219F420: D37E00AC  stfs f27, 0xac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x8219F424; continue 'dispatch;
            }
            0x8219F424 => {
    //   block [0x8219F424..0x8219F434)
	// 8219F424: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F428: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F42C: 409A0008  bne cr6, 0x8219f434
	if !ctx.cr[6].eq {
	pc = 0x8219F434; continue 'dispatch;
	}
	// 8219F430: D35E00B0  stfs f26, 0xb0(r30)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), tmp.u32 ) };
	pc = 0x8219F434; continue 'dispatch;
            }
            0x8219F434 => {
    //   block [0x8219F434..0x8219F450)
	// 8219F434: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F438: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F43C: 409A0014  bne cr6, 0x8219f450
	if !ctx.cr[6].eq {
	pc = 0x8219F450; continue 'dispatch;
	}
	// 8219F440: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F444: D33E00A8  stfs f25, 0xa8(r30)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F448: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F44C: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	pc = 0x8219F450; continue 'dispatch;
            }
            0x8219F450 => {
    //   block [0x8219F450..0x8219F4B0)
	// 8219F450: 817C0000  lwz r11, 0(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F454: 7F83E378  mr r3, r28
	ctx.r[3].u64 = ctx.r[28].u64;
	// 8219F458: 816B0014  lwz r11, 0x14(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F45C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F460: 4E800421  bctrl
	ctx.lr = 0x8219F464;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F464: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 8219F468: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F46C: 4800457D  bl 0x821a39e8
	ctx.lr = 0x8219F470;
	sub_821A39E8(ctx, base);
	// 8219F470: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F474: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F478: 7C651B78  mr r5, r3
	ctx.r[5].u64 = ctx.r[3].u64;
	// 8219F47C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F480: 481AC8E1  bl 0x8234bd60
	ctx.lr = 0x8219F484;
	sub_8234BD60(ctx, base);
	// 8219F484: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F488: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F48C: 4BFFFB45  bl 0x8219efd0
	ctx.lr = 0x8219F490;
	sub_8219EFD0(ctx, base);
	// 8219F490: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 8219F494: 419A001C  beq cr6, 0x8219f4b0
	if ctx.cr[6].eq {
	pc = 0x8219F4B0; continue 'dispatch;
	}
	// 8219F498: 7F67DB78  mr r7, r27
	ctx.r[7].u64 = ctx.r[27].u64;
	// 8219F49C: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F4A0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F4A4: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F4A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F4AC: 481AC6DD  bl 0x8234bb88
	ctx.lr = 0x8219F4B0;
	sub_8234BB88(ctx, base);
            }
            0x8219F4B0 => {
    //   block [0x8219F4B0..0x8219F4D8)
	// 8219F4B0: 2B1A0000  cmplwi cr6, r26, 0
	ctx.cr[6].compare_u32(ctx.r[26].u32, 0 as u32, &mut ctx.xer);
	// 8219F4B4: 419A0024  beq cr6, 0x8219f4d8
	if ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4B8: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F4BC: 419A001C  beq cr6, 0x8219f4d8
	if ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4C0: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F4C4: 7F0BE840  cmplw cr6, r11, r29
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[29].u32, &mut ctx.xer);
	// 8219F4C8: 409A0010  bne cr6, 0x8219f4d8
	if !ctx.cr[6].eq {
	pc = 0x8219F4D8; continue 'dispatch;
	}
	// 8219F4CC: A17E0014  lhz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F4D0: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F4D4: B17E0014  sth r11, 0x14(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x8219F4D8; continue 'dispatch;
            }
            0x8219F4D8 => {
    //   block [0x8219F4D8..0x8219F4E8)
	// 8219F4D8: 3B39FFFF  addi r25, r25, -1
	ctx.r[25].s64 = ctx.r[25].s64 + -1;
	// 8219F4DC: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F4E0: 409AFEFC  bne cr6, 0x8219f3dc
	if !ctx.cr[6].eq {
	pc = 0x8219F3DC; continue 'dispatch;
	}
	// 8219F4E4: 48000234  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
            }
            0x8219F4E8 => {
    //   block [0x8219F4E8..0x8219F518)
	// 8219F4E8: 480045D1  bl 0x821a3ab8
	ctx.lr = 0x8219F4EC;
	sub_821A3AB8(ctx, base);
	// 8219F4EC: 7C771B78  mr r23, r3
	ctx.r[23].u64 = ctx.r[3].u64;
	// 8219F4F0: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 8219F4F4: 419A0224  beq cr6, 0x8219f718
	if ctx.cr[6].eq {
	pc = 0x8219F718; continue 'dispatch;
	}
	// 8219F4F8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219F4FC: 834101EC  lwz r26, 0x1ec(r1)
	ctx.r[26].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(492 as u32) ) } as u64;
	// 8219F500: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F504: 569904A4  rlwinm r25, r20, 0, 0x12, 0x12
	ctx.r[25].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F508: 3BB30030  addi r29, r19, 0x30
	ctx.r[29].s64 = ctx.r[19].s64 + 48;
	// 8219F50C: 56980528  rlwinm r24, r20, 0, 0x14, 0x14
	ctx.r[24].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F510: C3EA1FF8  lfs f31, 0x1ff8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F514: 3B6BDBD0  addi r27, r11, -0x2430
	ctx.r[27].s64 = ctx.r[11].s64 + -9264;
	pc = 0x8219F518; continue 'dispatch;
            }
            0x8219F518 => {
    //   block [0x8219F518..0x8219F560)
	// 8219F518: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F51C: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 8219F520: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F524: 92410054  stw r18, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[18].u32 ) };
	// 8219F528: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F52C: 7EA6AB78  mr r6, r21
	ctx.r[6].u64 = ctx.r[21].u64;
	// 8219F530: 7EC5B378  mr r5, r22
	ctx.r[5].u64 = ctx.r[22].u64;
	// 8219F534: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F538: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 8219F53C: 481AC425  bl 0x8234b960
	ctx.lr = 0x8219F540;
	sub_8234B960(ctx, base);
	// 8219F540: 83C1006C  lwz r30, 0x6c(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(108 as u32) ) } as u64;
	// 8219F544: 83810068  lwz r28, 0x68(r1)
	ctx.r[28].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) } as u64;
	// 8219F548: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F54C: 419A0040  beq cr6, 0x8219f58c
	if ctx.cr[6].eq {
	pc = 0x8219F58C; continue 'dispatch;
	}
	// 8219F550: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F554: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F558: 409A0008  bne cr6, 0x8219f560
	if !ctx.cr[6].eq {
	pc = 0x8219F560; continue 'dispatch;
	}
	// 8219F55C: D37E00AC  stfs f27, 0xac(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[27].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x8219F560; continue 'dispatch;
            }
            0x8219F560 => {
    //   block [0x8219F560..0x8219F570)
	// 8219F560: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F564: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F568: 409A0008  bne cr6, 0x8219f570
	if !ctx.cr[6].eq {
	pc = 0x8219F570; continue 'dispatch;
	}
	// 8219F56C: D35E00B0  stfs f26, 0xb0(r30)
	tmp.f32 = (ctx.f[26].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(176 as u32), tmp.u32 ) };
	pc = 0x8219F570; continue 'dispatch;
            }
            0x8219F570 => {
    //   block [0x8219F570..0x8219F58C)
	// 8219F570: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F574: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F578: 409A0014  bne cr6, 0x8219f58c
	if !ctx.cr[6].eq {
	pc = 0x8219F58C; continue 'dispatch;
	}
	// 8219F57C: 817E008C  lwz r11, 0x8c(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(140 as u32) ) } as u64;
	// 8219F580: D33E00A8  stfs f25, 0xa8(r30)
	tmp.f32 = (ctx.f[25].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F584: 616B0004  ori r11, r11, 4
	ctx.r[11].u64 = ctx.r[11].u64 | 4;
	// 8219F588: 917E008C  stw r11, 0x8c(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	pc = 0x8219F58C; continue 'dispatch;
            }
            0x8219F58C => {
    //   block [0x8219F58C..0x8219F5E4)
	// 8219F58C: 2B190000  cmplwi cr6, r25, 0
	ctx.cr[6].compare_u32(ctx.r[25].u32, 0 as u32, &mut ctx.xer);
	// 8219F590: 38610078  addi r3, r1, 0x78
	ctx.r[3].s64 = ctx.r[1].s64 + 120;
	// 8219F594: 419A0050  beq cr6, 0x8219f5e4
	if ctx.cr[6].eq {
	pc = 0x8219F5E4; continue 'dispatch;
	}
	// 8219F598: 48004451  bl 0x821a39e8
	ctx.lr = 0x8219F59C;
	sub_821A39E8(ctx, base);
	// 8219F59C: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F5A0: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F5A4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F5A8: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F5AC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F5B0: 4E800421  bctrl
	ctx.lr = 0x8219F5B4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F5B4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219F5B8: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F5BC: 38810090  addi r4, r1, 0x90
	ctx.r[4].s64 = ctx.r[1].s64 + 144;
	// 8219F5C0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F5C4: C00B0030  lfs f0, 0x30(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5C8: D0010090  stfs f0, 0x90(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219F5CC: C00B0034  lfs f0, 0x34(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(52 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5D0: D0010094  stfs f0, 0x94(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219F5D4: C00B0038  lfs f0, 0x38(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(56 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219F5D8: D0010098  stfs f0, 0x98(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8219F5DC: 481ACACD  bl 0x8234c0a8
	ctx.lr = 0x8219F5E0;
	sub_8234C0A8(ctx, base);
	// 8219F5E0: 480000D0  b 0x8219f6b0
	pc = 0x8219F6B0; continue 'dispatch;
            }
            0x8219F5E4 => {
    //   block [0x8219F5E4..0x8219F640)
	// 8219F5E4: 568B04E6  rlwinm r11, r20, 0, 0x13, 0x13
	ctx.r[11].u64 = ctx.r[20].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F5E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F5EC: 419A0098  beq cr6, 0x8219f684
	if ctx.cr[6].eq {
	pc = 0x8219F684; continue 'dispatch;
	}
	// 8219F5F0: 480043F9  bl 0x821a39e8
	ctx.lr = 0x8219F5F4;
	sub_821A39E8(ctx, base);
	// 8219F5F4: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F5F8: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F5FC: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F600: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F604: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F608: 4E800421  bctrl
	ctx.lr = 0x8219F60C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F60C: 897B0001  lbz r11, 1(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(1 as u32) ) } as u64;
	// 8219F610: C0230030  lfs f1, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219F614: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219F618: C0430038  lfs f2, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219F61C: D02100A0  stfs f1, 0xa0(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(160 as u32), tmp.u32 ) };
	// 8219F620: D04100A8  stfs f2, 0xa8(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 8219F624: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F628: 40990018  ble cr6, 0x8219f640
	if !ctx.cr[6].gt {
	pc = 0x8219F640; continue 'dispatch;
	}
	// 8219F62C: 897B0002  lbz r11, 2(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[27].u32.wrapping_add(2 as u32) ) } as u64;
	// 8219F630: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 8219F634: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F638: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 8219F63C: 41990008  bgt cr6, 0x8219f644
	if ctx.cr[6].gt {
	pc = 0x8219F644; continue 'dispatch;
	}
            }
            0x8219F640 => {
    //   block [0x8219F640..0x8219F644)
	// 8219F640: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	pc = 0x8219F644; continue 'dispatch;
            }
            0x8219F644 => {
    //   block [0x8219F644..0x8219F65C)
	// 8219F644: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 8219F648: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F64C: 409A0010  bne cr6, 0x8219f65c
	if !ctx.cr[6].eq {
	pc = 0x8219F65C; continue 'dispatch;
	}
	// 8219F650: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219F654: 48017E75  bl 0x821b74c8
	ctx.lr = 0x8219F658;
	sub_821B74C8(ctx, base);
	// 8219F658: 48000014  b 0x8219f66c
	pc = 0x8219F66C; continue 'dispatch;
            }
            0x8219F65C => {
    //   block [0x8219F65C..0x8219F66C)
	// 8219F65C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219F660: 92410060  stw r18, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[18].u32 ) };
	// 8219F664: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 8219F668: 48017EC9  bl 0x821b7530
	ctx.lr = 0x8219F66C;
	sub_821B7530(ctx, base);
	pc = 0x8219F66C; continue 'dispatch;
            }
            0x8219F66C => {
    //   block [0x8219F66C..0x8219F684)
	// 8219F66C: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F670: 388100A0  addi r4, r1, 0xa0
	ctx.r[4].s64 = ctx.r[1].s64 + 160;
	// 8219F674: D02100A4  stfs f1, 0xa4(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 8219F678: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F67C: 481ACA2D  bl 0x8234c0a8
	ctx.lr = 0x8219F680;
	sub_8234C0A8(ctx, base);
	// 8219F680: 48000030  b 0x8219f6b0
	pc = 0x8219F6B0; continue 'dispatch;
            }
            0x8219F684 => {
    //   block [0x8219F684..0x8219F6B0)
	// 8219F684: 48004365  bl 0x821a39e8
	ctx.lr = 0x8219F688;
	sub_821A39E8(ctx, base);
	// 8219F688: 817D0000  lwz r11, 0(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 8219F68C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F690: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F694: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219F698: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219F69C: 4E800421  bctrl
	ctx.lr = 0x8219F6A0;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219F6A0: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	// 8219F6A4: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 8219F6A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F6AC: 481AC8A5  bl 0x8234bf50
	ctx.lr = 0x8219F6B0;
	sub_8234BF50(ctx, base);
            }
            0x8219F6B0 => {
    //   block [0x8219F6B0..0x8219F6DC)
	// 8219F6B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 8219F6B4: 7E038378  mr r3, r16
	ctx.r[3].u64 = ctx.r[16].u64;
	// 8219F6B8: 4BFFF919  bl 0x8219efd0
	ctx.lr = 0x8219F6BC;
	sub_8219EFD0(ctx, base);
	// 8219F6BC: FF1EF800  fcmpu cr6, f30, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.cr[6].compare_f64(ctx.f[30].f64, ctx.f[31].f64);
	// 8219F6C0: 419A001C  beq cr6, 0x8219f6dc
	if ctx.cr[6].eq {
	pc = 0x8219F6DC; continue 'dispatch;
	}
	// 8219F6C4: 7F47D378  mr r7, r26
	ctx.r[7].u64 = ctx.r[26].u64;
	// 8219F6C8: FC40F090  fmr f2, f30
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219F6CC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F6D0: FC20E890  fmr f1, f29
	ctx.f[1].f64 = ctx.f[29].f64;
	// 8219F6D4: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 8219F6D8: 481AC4B1  bl 0x8234bb88
	ctx.lr = 0x8219F6DC;
	sub_8234BB88(ctx, base);
	pc = 0x8219F6DC; continue 'dispatch;
            }
            0x8219F6DC => {
    //   block [0x8219F6DC..0x8219F704)
	// 8219F6DC: 2B180000  cmplwi cr6, r24, 0
	ctx.cr[6].compare_u32(ctx.r[24].u32, 0 as u32, &mut ctx.xer);
	// 8219F6E0: 419A0024  beq cr6, 0x8219f704
	if ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6E4: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 8219F6E8: 419A001C  beq cr6, 0x8219f704
	if ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6EC: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F6F0: 7F0BE040  cmplw cr6, r11, r28
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[28].u32, &mut ctx.xer);
	// 8219F6F4: 409A0010  bne cr6, 0x8219f704
	if !ctx.cr[6].eq {
	pc = 0x8219F704; continue 'dispatch;
	}
	// 8219F6F8: A17E0014  lhz r11, 0x14(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) } as u64;
	// 8219F6FC: 716BFDFF  andi. r11, r11, 0xfdff
	ctx.r[11].u64 = ctx.r[11].u64 & 65023;
	ctx.cr[0].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F700: B17E0014  sth r11, 0x14(r30)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[30].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x8219F704; continue 'dispatch;
            }
            0x8219F704 => {
    //   block [0x8219F704..0x8219F714)
	// 8219F704: 3AF7FFFF  addi r23, r23, -1
	ctx.r[23].s64 = ctx.r[23].s64 + -1;
	// 8219F708: 2B170000  cmplwi cr6, r23, 0
	ctx.cr[6].compare_u32(ctx.r[23].u32, 0 as u32, &mut ctx.xer);
	// 8219F70C: 409AFE0C  bne cr6, 0x8219f518
	if !ctx.cr[6].eq {
	pc = 0x8219F518; continue 'dispatch;
	}
	// 8219F710: 48000008  b 0x8219f718
	pc = 0x8219F718; continue 'dispatch;
            }
            0x8219F714 => {
    //   block [0x8219F714..0x8219F718)
	// 8219F714: EBE10068  ld r31, 0x68(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(104 as u32) ) };
	pc = 0x8219F718; continue 'dispatch;
            }
            0x8219F718 => {
    //   block [0x8219F718..0x8219F754)
	// 8219F718: 7E4B9378  mr r11, r18
	ctx.r[11].u64 = ctx.r[18].u64;
	// 8219F71C: 7FE5FB78  mr r5, r31
	ctx.r[5].u64 = ctx.r[31].u64;
	// 8219F720: 7DE47B78  mr r4, r15
	ctx.r[4].u64 = ctx.r[15].u64;
	// 8219F724: B1700000  sth r11, 0(r16)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[16].u32.wrapping_add(0 as u32), ctx.r[11].u16 ) };
	// 8219F728: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F72C: 7D5388AE  lbzx r10, r19, r17
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[17].u32)) } as u64;
	// 8219F730: 396BC7D0  addi r11, r11, -0x3830
	ctx.r[11].s64 = ctx.r[11].s64 + -14384;
	// 8219F734: 1D4A0108  mulli r10, r10, 0x108
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 264 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8219F738: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219F73C: 4BFC7F7D  bl 0x821676b8
	ctx.lr = 0x8219F740;
	sub_821676B8(ctx, base);
	// 8219F740: 5463043E  clrlwi r3, r3, 0x10
	ctx.r[3].u64 = ctx.r[3].u32 as u64 & 0x0000FFFFu64;
	// 8219F744: 38210190  addi r1, r1, 0x190
	ctx.r[1].s64 = ctx.r[1].s64 + 400;
	// 8219F748: 3981FF70  addi r12, r1, -0x90
	ctx.r[12].s64 = ctx.r[1].s64 + -144;
	// 8219F74C: 483968DD  bl 0x82536028
	ctx.lr = 0x8219F750;
	sub_82535FFC(ctx, base);
	// 8219F750: 48395984  b 0x825350d4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F758(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x8219F758 size=152
    let mut pc: u32 = 0x8219F758;
    'dispatch: loop {
        match pc {
            0x8219F758 => {
    //   block [0x8219F758..0x8219F7A4)
	// 8219F758: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F75C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 8219F760: 9421FFA0  stwu r1, -0x60(r1)
	ea = ctx.r[1].u32.wrapping_add(-96 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F764: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F768: FC000890  fmr f0, f1
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[0].f64 = ctx.f[1].f64;
	// 8219F76C: 7CC73378  mr r7, r6
	ctx.r[7].u64 = ctx.r[6].u64;
	// 8219F770: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 8219F774: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 8219F778: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F77C: 2F040000  cmpwi cr6, r4, 0
	ctx.cr[6].compare_i32(ctx.r[4].s32, 0, &mut ctx.xer);
	// 8219F780: 396BC7D0  addi r11, r11, -0x3830
	ctx.r[11].s64 = ctx.r[11].s64 + -14384;
	// 8219F784: 7D4350AE  lbzx r10, r3, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[3].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219F788: 1D4A0108  mulli r10, r10, 0x108
	ctx.r[10].s32 = ((ctx.r[10].s32 as i64 * 264 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8219F78C: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219F790: 40980014  bge cr6, 0x8219f7a4
	if !ctx.cr[6].lt {
	pc = 0x8219F7A4; continue 'dispatch;
	}
	// 8219F794: 2F040010  cmpwi cr6, r4, 0x10
	ctx.cr[6].compare_i32(ctx.r[4].s32, 16, &mut ctx.xer);
	// 8219F798: 4198000C  blt cr6, 0x8219f7a4
	if ctx.cr[6].lt {
	pc = 0x8219F7A4; continue 'dispatch;
	}
	// 8219F79C: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 8219F7A0: 48000010  b 0x8219f7b0
	pc = 0x8219F7B0; continue 'dispatch;
            }
            0x8219F7A4 => {
    //   block [0x8219F7A4..0x8219F7B0)
	// 8219F7A4: 39440001  addi r10, r4, 1
	ctx.r[10].s64 = ctx.r[4].s64 + 1;
	// 8219F7A8: 554A1838  slwi r10, r10, 3
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(3);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 8219F7AC: 7D6A582A  ldx r11, r10, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u64(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	pc = 0x8219F7B0; continue 'dispatch;
            }
            0x8219F7B0 => {
    //   block [0x8219F7B0..0x8219F7E0)
	// 8219F7B0: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 8219F7B4: 81410054  lwz r10, 0x54(r1)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 8219F7B8: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 8219F7BC: 419A0024  beq cr6, 0x8219f7e0
	if ctx.cr[6].eq {
	pc = 0x8219F7E0; continue 'dispatch;
	}
	// 8219F7C0: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219F7C4: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 8219F7C8: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 8219F7CC: 409A0014  bne cr6, 0x8219f7e0
	if !ctx.cr[6].eq {
	pc = 0x8219F7E0; continue 'dispatch;
	}
	// 8219F7D0: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219F7D4: FC400090  fmr f2, f0
	ctx.f[2].f64 = ctx.f[0].f64;
	// 8219F7D8: 7D635B78  mr r3, r11
	ctx.r[3].u64 = ctx.r[11].u64;
	// 8219F7DC: 481AC3AD  bl 0x8234bb88
	ctx.lr = 0x8219F7E0;
	sub_8234BB88(ctx, base);
	pc = 0x8219F7E0; continue 'dispatch;
            }
            0x8219F7E0 => {
    //   block [0x8219F7E0..0x8219F7F0)
	// 8219F7E0: 38210060  addi r1, r1, 0x60
	ctx.r[1].s64 = ctx.r[1].s64 + 96;
	// 8219F7E4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 8219F7E8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 8219F7EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219F7F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219F7F0 size=928
    let mut pc: u32 = 0x8219F7F0;
    'dispatch: loop {
        match pc {
            0x8219F7F0 => {
    //   block [0x8219F7F0..0x8219F83C)
	// 8219F7F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219F7F4: 483958BD  bl 0x825350b0
	ctx.lr = 0x8219F7F8;
	sub_82535080(ctx, base);
	// 8219F7F8: DBE1FFC0  stfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-64 as u32), ctx.f[31].u64 ) };
	// 8219F7FC: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219F800: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F804: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219F808: 616BEB0E  ori r11, r11, 0xeb0e
	ctx.r[11].u64 = ctx.r[11].u64 | 60174;
	// 8219F80C: 7C9B2378  mr r27, r4
	ctx.r[27].u64 = ctx.r[4].u64;
	// 8219F810: 7D3A4B78  mr r26, r9
	ctx.r[26].u64 = ctx.r[9].u64;
	// 8219F814: 7D7D58AE  lbzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F818: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F81C: 419A0020  beq cr6, 0x8219f83c
	if ctx.cr[6].eq {
	pc = 0x8219F83C; continue 'dispatch;
	}
	// 8219F820: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F824: 616BA960  ori r11, r11, 0xa960
	ctx.r[11].u64 = ctx.r[11].u64 | 43360;
	// 8219F828: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F82C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219F830: 4198000C  blt cr6, 0x8219f83c
	if ctx.cr[6].lt {
	pc = 0x8219F83C; continue 'dispatch;
	}
	// 8219F834: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F838: 4199034C  bgt cr6, 0x8219fb84
	if ctx.cr[6].gt {
	pc = 0x8219FB84; continue 'dispatch;
	}
	pc = 0x8219F83C; continue 'dispatch;
            }
            0x8219F83C => {
    //   block [0x8219F83C..0x8219F894)
	// 8219F83C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F840: 4BF90311  bl 0x8212fb50
	ctx.lr = 0x8219F844;
	sub_8212FB50(ctx, base);
	// 8219F844: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219F848: 39000001  li r8, 1
	ctx.r[8].s64 = 1;
	// 8219F84C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F850: 38C100A0  addi r6, r1, 0xa0
	ctx.r[6].s64 = ctx.r[1].s64 + 160;
	// 8219F854: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 8219F858: 7F64DB78  mr r4, r27
	ctx.r[4].u64 = ctx.r[27].u64;
	// 8219F85C: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 8219F860: 7D7C0734  extsh r28, r11
	ctx.r[28].s64 = ctx.r[11].s16 as i64;
	// 8219F864: 4BFFF1ED  bl 0x8219ea50
	ctx.lr = 0x8219F868;
	sub_8219EA50(ctx, base);
	// 8219F868: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F86C: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 8219F870: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 8219F874: 614AE2D4  ori r10, r10, 0xe2d4
	ctx.r[10].u64 = ctx.r[10].u64 | 58068;
	// 8219F878: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219F87C: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F880: 7D6B502E  lwzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219F884: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 8219F888: 419A000C  beq cr6, 0x8219f894
	if ctx.cr[6].eq {
	pc = 0x8219F894; continue 'dispatch;
	}
	// 8219F88C: A16B0032  lhz r11, 0x32(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[11].u32.wrapping_add(50 as u32) ) } as u64;
	// 8219F890: 48000008  b 0x8219f898
	pc = 0x8219F898; continue 'dispatch;
            }
            0x8219F894 => {
    //   block [0x8219F894..0x8219F898)
	// 8219F894: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x8219F898; continue 'dispatch;
            }
            0x8219F898 => {
    //   block [0x8219F898..0x8219F8E0)
	// 8219F898: 556B0630  rlwinm r11, r11, 0, 0x18, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 8219F89C: 2B0B0080  cmplwi cr6, r11, 0x80
	ctx.cr[6].compare_u32(ctx.r[11].u32, 128 as u32, &mut ctx.xer);
	// 8219F8A0: 409A0040  bne cr6, 0x8219f8e0
	if !ctx.cr[6].eq {
	pc = 0x8219F8E0; continue 'dispatch;
	}
	// 8219F8A4: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F8A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F8AC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F8B0: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F8B4: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F8B8: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F8BC: 38C00093  li r6, 0x93
	ctx.r[6].s64 = 147;
	// 8219F8C0: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219F8C4: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F8C8: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F8CC: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F8D0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F8D4: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F8D8: 481AC089  bl 0x8234b960
	ctx.lr = 0x8219F8DC;
	sub_8234B960(ctx, base);
	// 8219F8DC: 48000278  b 0x8219fb54
	pc = 0x8219FB54; continue 'dispatch;
            }
            0x8219F8E0 => {
    //   block [0x8219F8E0..0x8219F92C)
	// 8219F8E0: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219F8E4: 616BE2E0  ori r11, r11, 0xe2e0
	ctx.r[11].u64 = ctx.r[11].u64 | 58080;
	// 8219F8E8: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F8EC: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 8219F8F0: 409800C8  bge cr6, 0x8219f9b8
	if !ctx.cr[6].lt {
	pc = 0x8219F9B8; continue 'dispatch;
	}
	// 8219F8F4: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 8219F8F8: 616BA968  ori r11, r11, 0xa968
	ctx.r[11].u64 = ctx.r[11].u64 | 43368;
	// 8219F8FC: 7D7D582E  lwzx r11, r29, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[29].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 8219F900: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 8219F904: 409A00B4  bne cr6, 0x8219f9b8
	if !ctx.cr[6].eq {
	pc = 0x8219F9B8; continue 'dispatch;
	}
	// 8219F908: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F90C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F910: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F914: 409A0074  bne cr6, 0x8219f988
	if !ctx.cr[6].eq {
	pc = 0x8219F988; continue 'dispatch;
	}
	// 8219F918: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F91C: 2F1C0009  cmpwi cr6, r28, 9
	ctx.cr[6].compare_i32(ctx.r[28].s32, 9, &mut ctx.xer);
	// 8219F920: 38C00015  li r6, 0x15
	ctx.r[6].s64 = 21;
	// 8219F924: 40980008  bge cr6, 0x8219f92c
	if !ctx.cr[6].lt {
	pc = 0x8219F92C; continue 'dispatch;
	}
	// 8219F928: 38C00014  li r6, 0x14
	ctx.r[6].s64 = 20;
	pc = 0x8219F92C; continue 'dispatch;
            }
            0x8219F92C => {
    //   block [0x8219F92C..0x8219F988)
	// 8219F92C: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F930: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F934: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F938: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F93C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219F940: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F944: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F948: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F94C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F950: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F954: 481AC00D  bl 0x8234b960
	ctx.lr = 0x8219F958;
	sub_8234B960(ctx, base);
	// 8219F958: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219F95C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219F960: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F964: 388BB8A0  addi r4, r11, -0x4760
	ctx.r[4].s64 = ctx.r[11].s64 + -18272;
	// 8219F968: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219F96C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F970: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F974: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F978: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219F97C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219F980: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219F984: 4800192D  bl 0x821a12b0
	ctx.lr = 0x8219F988;
	sub_821A12B0(ctx, base);
	pc = 0x8219F988; continue 'dispatch;
            }
            0x8219F988 => {
    //   block [0x8219F988..0x8219F9B8)
	// 8219F988: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219F98C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219F990: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8219F994: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F998: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8219F99C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F9A0: 38E0000D  li r7, 0xd
	ctx.r[7].s64 = 13;
	// 8219F9A4: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219F9A8: 38800004  li r4, 4
	ctx.r[4].s64 = 4;
	// 8219F9AC: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 8219F9B0: 4800B049  bl 0x821aa9f8
	ctx.lr = 0x8219F9B4;
	sub_821AA9F8(ctx, base);
	// 8219F9B4: 480001A0  b 0x8219fb54
	pc = 0x8219FB54; continue 'dispatch;
            }
            0x8219F9B8 => {
    //   block [0x8219F9B8..0x8219FAD4)
	// 8219F9B8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219F9BC: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 8219F9C0: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219F9C4: 409A0164  bne cr6, 0x8219fb28
	if !ctx.cr[6].eq {
	pc = 0x8219FB28; continue 'dispatch;
	}
	// 8219F9C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219F9CC: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219F9D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219F9D4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219F9D8: 3BCBC470  addi r30, r11, -0x3b90
	ctx.r[30].s64 = ctx.r[11].s64 + -15248;
	// 8219F9DC: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219F9E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219F9E4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219F9E8: 38C0000B  li r6, 0xb
	ctx.r[6].s64 = 11;
	// 8219F9EC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219F9F0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219F9F4: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219F9F8: 481ABF69  bl 0x8234b960
	ctx.lr = 0x8219F9FC;
	sub_8234B960(ctx, base);
	// 8219F9FC: 817D0030  lwz r11, 0x30(r29)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219FA00: 387D0030  addi r3, r29, 0x30
	ctx.r[3].s64 = ctx.r[29].s64 + 48;
	// 8219FA04: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219FA08: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219FA0C: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219FA10: 4E800421  bctrl
	ctx.lr = 0x8219FA14;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219FA14: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 8219FA18: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219FA1C: C12100A0  lfs f9, 0xa0(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(160 as u32) ) };
	ctx.f[9].f64 = (tmp.f32 as f64);
	// 8219FA20: C10100A4  lfs f8, 0xa4(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(164 as u32) ) };
	ctx.f[8].f64 = (tmp.f32 as f64);
	// 8219FA24: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FA28: C0E100A8  lfs f7, 0xa8(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(168 as u32) ) };
	ctx.f[7].f64 = (tmp.f32 as f64);
	// 8219FA2C: C00AD218  lfs f0, -0x2de8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11752 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FA30: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FA34: C18B0020  lfs f12, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FA38: C16B0024  lfs f11, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FA3C: C14B0028  lfs f10, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[10].f64 = (tmp.f32 as f64);
	// 8219FA40: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 8219FA44: C1AA2074  lfs f13, 0x2074(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8308 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA48: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA4C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA50: ED4A0372  fmuls f10, f10, f13
	ctx.f[10].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA54: C1ABD468  lfs f13, -0x2b98(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA58: ED8C0372  fmuls f12, f12, f13
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA5C: ED6B0372  fmuls f11, f11, f13
	ctx.f[11].f64 = (((ctx.f[11].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA60: EDAA0372  fmuls f13, f10, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FA64: EC29603A  fmadds f1, f9, f0, f12
	ctx.f[1].f64 = (((ctx.f[9].f64 * ctx.f[0].f64 + ctx.f[12].f64) as f32) as f64);
	// 8219FA68: EC48583A  fmadds f2, f8, f0, f11
	ctx.f[2].f64 = (((ctx.f[8].f64 * ctx.f[0].f64 + ctx.f[11].f64) as f32) as f64);
	// 8219FA6C: EC67683A  fmadds f3, f7, f0, f13
	ctx.f[3].f64 = (((ctx.f[7].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 8219FA70: 48010919  bl 0x821b0388
	ctx.lr = 0x8219FA74;
	sub_821B0388(ctx, base);
	// 8219FA74: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FA78: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FA7C: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FA80: 2F1C0009  cmpwi cr6, r28, 9
	ctx.cr[6].compare_i32(ctx.r[28].s32, 9, &mut ctx.xer);
	// 8219FA84: C1610088  lfs f11, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FA88: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 8219FA8C: C00B2034  lfs f0, 0x2034(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FA90: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA94: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA98: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FA9C: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8219FAA0: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 8219FAA4: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8219FAA8: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 8219FAAC: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219FAB0: D8010080  stfd f0, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[0].u64 ) };
	// 8219FAB4: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 8219FAB8: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 8219FABC: A161007E  lhz r11, 0x7e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 8219FAC0: B1610062  sth r11, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u16 ) };
	// 8219FAC4: A1610086  lhz r11, 0x86(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(134 as u32) ) } as u64;
	// 8219FAC8: B1610064  sth r11, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 8219FACC: 40980008  bge cr6, 0x8219fad4
	if !ctx.cr[6].lt {
	pc = 0x8219FAD4; continue 'dispatch;
	}
	// 8219FAD0: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
            }
            0x8219FAD4 => {
    //   block [0x8219FAD4..0x8219FB28)
	// 8219FAD4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FAD8: 80BE000C  lwz r5, 0xc(r30)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FADC: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8219FAE0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FAE4: 38E10090  addi r7, r1, 0x90
	ctx.r[7].s64 = ctx.r[1].s64 + 144;
	// 8219FAE8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FAEC: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219FAF0: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FAF4: 481ABE6D  bl 0x8234b960
	ctx.lr = 0x8219FAF8;
	sub_8234B960(ctx, base);
	// 8219FAF8: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FAFC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FB00: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FB04: 388BB8B0  addi r4, r11, -0x4750
	ctx.r[4].s64 = ctx.r[11].s64 + -18256;
	// 8219FB08: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219FB0C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FB10: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FB14: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FB18: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219FB1C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219FB20: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 8219FB24: 4800178D  bl 0x821a12b0
	ctx.lr = 0x8219FB28;
	sub_821A12B0(ctx, base);
	pc = 0x8219FB28; continue 'dispatch;
            }
            0x8219FB28 => {
    //   block [0x8219FB28..0x8219FB54)
	// 8219FB28: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FB2C: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FB30: 39210090  addi r9, r1, 0x90
	ctx.r[9].s64 = ctx.r[1].s64 + 144;
	// 8219FB34: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FB38: 390100A0  addi r8, r1, 0xa0
	ctx.r[8].s64 = ctx.r[1].s64 + 160;
	// 8219FB3C: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FB40: 38E0000C  li r7, 0xc
	ctx.r[7].s64 = 12;
	// 8219FB44: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FB48: 38800006  li r4, 6
	ctx.r[4].s64 = 6;
	// 8219FB4C: 3860000D  li r3, 0xd
	ctx.r[3].s64 = 13;
	// 8219FB50: 4800AEA9  bl 0x821aa9f8
	ctx.lr = 0x8219FB54;
	sub_821AA9F8(ctx, base);
	pc = 0x8219FB54; continue 'dispatch;
            }
            0x8219FB54 => {
    //   block [0x8219FB54..0x8219FB84)
	// 8219FB54: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219FB58: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219FB5C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219FB60: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219FB64: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219FB68: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219FB6C: 409A0018  bne cr6, 0x8219fb84
	if !ctx.cr[6].eq {
	pc = 0x8219FB84; continue 'dispatch;
	}
	// 8219FB70: 7F46D378  mr r6, r26
	ctx.r[6].u64 = ctx.r[26].u64;
	// 8219FB74: 7F65DB78  mr r5, r27
	ctx.r[5].u64 = ctx.r[27].u64;
	// 8219FB78: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 8219FB7C: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 8219FB80: 4BFDD281  bl 0x8217ce00
	ctx.lr = 0x8219FB84;
	sub_8217CE00(ctx, base);
	pc = 0x8219FB84; continue 'dispatch;
            }
            0x8219FB84 => {
    //   block [0x8219FB84..0x8219FB90)
	// 8219FB84: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 8219FB88: CBE1FFC0  lfd f31, -0x40(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-64 as u32) ) };
	// 8219FB8C: 48395574  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219FB90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219FB90 size=1064
    let mut pc: u32 = 0x8219FB90;
    'dispatch: loop {
        match pc {
            0x8219FB90 => {
    //   block [0x8219FB90..0x8219FBD4)
	// 8219FB90: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219FB94: 48395515  bl 0x825350a8
	ctx.lr = 0x8219FB98;
	sub_82535080(ctx, base);
	// 8219FB98: DBC1FFA8  stfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-88 as u32), ctx.f[30].u64 ) };
	// 8219FB9C: DBE1FFB0  stfd f31, -0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-80 as u32), ctx.f[31].u64 ) };
	// 8219FBA0: 9421FEF0  stwu r1, -0x110(r1)
	ea = ctx.r[1].u32.wrapping_add(-272 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219FBA4: 7D384B78  mr r24, r9
	ctx.r[24].u64 = ctx.r[9].u64;
	// 8219FBA8: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 8219FBAC: 3978FFCF  addi r11, r24, -0x31
	ctx.r[11].s64 = ctx.r[24].s64 + -49;
	// 8219FBB0: 7C992378  mr r25, r4
	ctx.r[25].u64 = ctx.r[4].u64;
	// 8219FBB4: 2B0B0025  cmplwi cr6, r11, 0x25
	ctx.cr[6].compare_u32(ctx.r[11].u32, 37 as u32, &mut ctx.xer);
	// 8219FBB8: 4199001C  bgt cr6, 0x8219fbd4
	if ctx.cr[6].gt {
	pc = 0x8219FBD4; continue 'dispatch;
	}
	// 8219FBBC: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FBC0: 3BA0000A  li r29, 0xa
	ctx.r[29].s64 = 10;
	// 8219FBC4: 3B8BB8E0  addi r28, r11, -0x4720
	ctx.r[28].s64 = ctx.r[11].s64 + -18208;
	// 8219FBC8: 3B400025  li r26, 0x25
	ctx.r[26].s64 = 37;
	// 8219FBCC: 3B60006D  li r27, 0x6d
	ctx.r[27].s64 = 109;
	// 8219FBD0: 48000018  b 0x8219fbe8
	pc = 0x8219FBE8; continue 'dispatch;
            }
            0x8219FBD4 => {
    //   block [0x8219FBD4..0x8219FBE8)
	// 8219FBD4: 3D608287  lis r11, -0x7d79
	ctx.r[11].s64 = -2105081856;
	// 8219FBD8: 3BA00009  li r29, 9
	ctx.r[29].s64 = 9;
	// 8219FBDC: 3B8BB8D0  addi r28, r11, -0x4730
	ctx.r[28].s64 = ctx.r[11].s64 + -18224;
	// 8219FBE0: 3B40000D  li r26, 0xd
	ctx.r[26].s64 = 13;
	// 8219FBE4: 3B60007B  li r27, 0x7b
	ctx.r[27].s64 = 123;
	pc = 0x8219FBE8; continue 'dispatch;
            }
            0x8219FBE8 => {
    //   block [0x8219FBE8..0x8219FD2C)
	// 8219FBE8: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 8219FBEC: 2B180046  cmplwi cr6, r24, 0x46
	ctx.cr[6].compare_u32(ctx.r[24].u32, 70 as u32, &mut ctx.xer);
	// 8219FBF0: C3EBBA38  lfs f31, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219FBF4: 4199019C  bgt cr6, 0x8219fd90
	if ctx.cr[6].gt {
	pc = 0x8219FD90; continue 'dispatch;
	}
	// 8219FBF8: 3D80821A  lis r12, -0x7de6
	ctx.r[12].s64 = -2112225280;
	// 8219FBFC: 398CFC10  addi r12, r12, -0x3f0
	ctx.r[12].s64 = ctx.r[12].s64 + -1008;
	// 8219FC00: 5700103A  slwi r0, r24, 2
	ctx.r[0].u32 = ctx.r[24].u32.wrapping_shl(2);
	ctx.r[0].u64 = ctx.r[0].u32 as u64;
	// 8219FC04: 7C0C002E  lwzx r0, r12, r0
	ctx.r[0].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[12].u32.wrapping_add(ctx.r[0].u32)) } as u64;
	// 8219FC08: 7C0903A6  mtctr r0
	ctx.ctr.u64 = ctx.r[0].u64;
	// 8219FC0C: 4E800420  bctr
	match ctx.r[24].u64 {
		0 => {
	pc = 0x8219FFA8; continue 'dispatch;
		},
		1 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		2 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		3 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		4 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		5 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		6 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		7 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		8 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		9 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		10 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		11 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		12 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		13 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		14 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		15 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		16 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		17 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		18 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		19 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		20 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		21 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		22 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		23 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		24 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		25 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		26 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		27 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		28 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		29 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		30 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		31 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		32 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		33 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		34 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		35 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		36 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		37 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		38 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		39 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		40 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		41 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		42 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		43 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		44 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		45 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		46 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		47 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		48 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		49 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		50 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		51 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		52 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		53 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		54 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		55 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		56 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		57 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		58 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		59 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		60 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		61 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		62 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		63 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		64 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		65 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		66 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		67 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		68 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		69 => {
	pc = 0x8219FD90; continue 'dispatch;
		},
		70 => {
	pc = 0x8219FD2C; continue 'dispatch;
		},
		_ => unsafe { core::hint::unreachable_unchecked() },
	}
	// 8219FC10: 8219FFA8  lwz r16, -0x58(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-88 as u32) ) } as u64;
	// 8219FC14: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC18: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC1C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC20: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC24: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC28: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC2C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC30: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC34: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC38: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC3C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC40: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC44: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC48: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC4C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC50: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC54: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC58: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC5C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC60: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC64: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC68: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC6C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC70: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC74: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC78: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC7C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC80: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC84: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FC88: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC8C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC90: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC94: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FC98: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FC9C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCA0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCA4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCA8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCAC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCB8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCBC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC4: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCC8: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCCC: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCD0: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FCD4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCD8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCDC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCE8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCEC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF0: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF4: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCF8: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FCFC: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD00: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD04: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD08: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD0C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD10: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD14: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
	// 8219FD18: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD1C: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD20: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD24: 8219FD90  lwz r16, -0x270(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-624 as u32) ) } as u64;
	// 8219FD28: 8219FD2C  lwz r16, -0x2d4(r25)
	ctx.r[16].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[25].u32.wrapping_add(-724 as u32) ) } as u64;
            }
            0x8219FD2C => {
    //   block [0x8219FD2C..0x8219FD90)
	// 8219FD2C: 3D408287  lis r10, -0x7d79
	ctx.r[10].s64 = -2105081856;
	// 8219FD30: FCA0F890  fmr f5, f31
	ctx.f[5].f64 = ctx.f[31].f64;
	// 8219FD34: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 8219FD38: 3B8AB8F0  addi r28, r10, -0x4710
	ctx.r[28].s64 = ctx.r[10].s64 + -18192;
	// 8219FD3C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FD40: 6169BE64  ori r9, r11, 0xbe64
	ctx.r[9].u64 = ctx.r[11].u64 | 48740;
	// 8219FD44: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 8219FD48: 3BA0000B  li r29, 0xb
	ctx.r[29].s64 = 11;
	// 8219FD4C: 3B60006E  li r27, 0x6e
	ctx.r[27].s64 = 110;
	// 8219FD50: C08A20C8  lfs f4, 0x20c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8392 as u32) ) };
	ctx.f[4].f64 = (tmp.f32 as f64);
	// 8219FD54: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FD58: 7D3E48AE  lbzx r9, r30, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[30].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 8219FD5C: 3B40000E  li r26, 0xe
	ctx.r[26].s64 = 14;
	// 8219FD60: C3CBD28C  lfs f30, -0x2d74(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-11636 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 8219FD64: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 8219FD68: 396B1290  addi r11, r11, 0x1290
	ctx.r[11].s64 = ctx.r[11].s64 + 4752;
	// 8219FD6C: C06A2094  lfs f3, 0x2094(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8340 as u32) ) };
	ctx.f[3].f64 = (tmp.f32 as f64);
	// 8219FD70: 3D408200  lis r10, -0x7e00
	ctx.r[10].s64 = -2113929216;
	// 8219FD74: C04A2938  lfs f2, 0x2938(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(10552 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 8219FD78: 3D408288  lis r10, -0x7d78
	ctx.r[10].s64 = -2105016320;
	// 8219FD7C: C02AD4CC  lfs f1, -0x2b34(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11060 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219FD80: 1D49002C  mulli r10, r9, 0x2c
	ctx.r[10].s32 = ((ctx.r[9].s32 as i64 * 44 as i64) as i32);
	ctx.r[10].s64 = ctx.r[10].s32 as i64;
	// 8219FD84: 7C6A5A14  add r3, r10, r11
	ctx.r[3].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	// 8219FD88: 4BFFC8E1  bl 0x8219c668
	ctx.lr = 0x8219FD8C;
	sub_8219C668(ctx, base);
	// 8219FD8C: 4800000C  b 0x8219fd98
	pc = 0x8219FD98; continue 'dispatch;
            }
            0x8219FD90 => {
    //   block [0x8219FD90..0x8219FD98)
	// 8219FD90: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FD94: C3CB3138  lfs f30, 0x3138(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12600 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	pc = 0x8219FD98; continue 'dispatch;
            }
            0x8219FD98 => {
    //   block [0x8219FD98..0x8219FFA8)
	// 8219FD98: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FD9C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 8219FDA0: 38C10090  addi r6, r1, 0x90
	ctx.r[6].s64 = ctx.r[1].s64 + 144;
	// 8219FDA4: 38A100A0  addi r5, r1, 0xa0
	ctx.r[5].s64 = ctx.r[1].s64 + 160;
	// 8219FDA8: 7F24CB78  mr r4, r25
	ctx.r[4].u64 = ctx.r[25].u64;
	// 8219FDAC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219FDB0: 4BFFECA1  bl 0x8219ea50
	ctx.lr = 0x8219FDB4;
	sub_8219EA50(ctx, base);
	// 8219FDB4: 817E0030  lwz r11, 0x30(r30)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(48 as u32) ) } as u64;
	// 8219FDB8: 387E0030  addi r3, r30, 0x30
	ctx.r[3].s64 = ctx.r[30].s64 + 48;
	// 8219FDBC: 38800000  li r4, 0
	ctx.r[4].s64 = 0;
	// 8219FDC0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 8219FDC4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 8219FDC8: 4E800421  bctrl
	ctx.lr = 0x8219FDCC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 8219FDCC: 3D408286  lis r10, -0x7d7a
	ctx.r[10].s64 = -2105147392;
	// 8219FDD0: C1810090  lfs f12, 0x90(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FDD4: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 8219FDD8: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 8219FDDC: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FDE0: C00AD468  lfs f0, -0x2b98(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-11160 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FDE4: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 8219FDE8: C16B0028  lfs f11, 0x28(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(40 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FDEC: FBE10068  std r31, 0x68(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(104 as u32), ctx.r[31].u64 ) };
	// 8219FDF0: C1AA2B88  lfs f13, 0x2b88(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(11144 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FDF4: ED4C0372  fmuls f10, f12, f13
	ctx.f[10].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FDF8: C1810094  lfs f12, 0x94(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(148 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FDFC: ED2C0372  fmuls f9, f12, f13
	ctx.f[9].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FE00: C1810098  lfs f12, 0x98(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(152 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE04: ED0C0372  fmuls f8, f12, f13
	ctx.f[8].f64 = (((ctx.f[12].f64 * ctx.f[13].f64) as f32) as f64);
	// 8219FE08: C1AB0020  lfs f13, 0x20(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(32 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FE0C: C18B0024  lfs f12, 0x24(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(36 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE10: EC2D503A  fmadds f1, f13, f0, f10
	ctx.f[1].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 8219FE14: D0210090  stfs f1, 0x90(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 8219FE18: EC4C483A  fmadds f2, f12, f0, f9
	ctx.f[2].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 8219FE1C: D0410094  stfs f2, 0x94(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 8219FE20: EC6B403A  fmadds f3, f11, f0, f8
	ctx.f[3].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 8219FE24: D0610098  stfs f3, 0x98(r1)
	tmp.f32 = (ctx.f[3].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 8219FE28: 48010561  bl 0x821b0388
	ctx.lr = 0x8219FE2C;
	sub_821B0388(ctx, base);
	// 8219FE2C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FE30: C1A10080  lfs f13, 0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(128 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 8219FE34: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FE38: C1810084  lfs f12, 0x84(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(132 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 8219FE3C: 39010060  addi r8, r1, 0x60
	ctx.r[8].s64 = ctx.r[1].s64 + 96;
	// 8219FE40: C1610088  lfs f11, 0x88(r1)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(136 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 8219FE44: 38E100A0  addi r7, r1, 0xa0
	ctx.r[7].s64 = ctx.r[1].s64 + 160;
	// 8219FE48: 7F66DB78  mr r6, r27
	ctx.r[6].u64 = ctx.r[27].u64;
	// 8219FE4C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FE50: C00B2034  lfs f0, 0x2034(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8244 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 8219FE54: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 8219FE58: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE5C: 38810068  addi r4, r1, 0x68
	ctx.r[4].s64 = ctx.r[1].s64 + 104;
	// 8219FE60: ED8C0032  fmuls f12, f12, f0
	ctx.f[12].f64 = (((ctx.f[12].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE64: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 8219FE68: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 8219FE6C: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 8219FE70: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FE74: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 8219FE78: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 8219FE7C: D9A10070  stfd f13, 0x70(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), ctx.f[13].u64 ) };
	// 8219FE80: FDA0601E  fctiwz f13, f12
	ctx.f[13].s64 = if ctx.f[12].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[12].f64.trunc() as i32 as i64 };
	// 8219FE84: D9A10078  stfd f13, 0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), ctx.f[13].u64 ) };
	// 8219FE88: FC00001E  fctiwz f0, f0
	ctx.f[0].s64 = if ctx.f[0].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[0].f64.trunc() as i32 as i64 };
	// 8219FE8C: D8010080  stfd f0, 0x80(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(128 as u32), ctx.f[0].u64 ) };
	// 8219FE90: A1610076  lhz r11, 0x76(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(118 as u32) ) } as u64;
	// 8219FE94: B1610060  sth r11, 0x60(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u16 ) };
	// 8219FE98: A161007E  lhz r11, 0x7e(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(126 as u32) ) } as u64;
	// 8219FE9C: B1610062  sth r11, 0x62(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(98 as u32), ctx.r[11].u16 ) };
	// 8219FEA0: A1610086  lhz r11, 0x86(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[1].u32.wrapping_add(134 as u32) ) } as u64;
	// 8219FEA4: B1610064  sth r11, 0x64(r1)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u16 ) };
	// 8219FEA8: 481ABAB9  bl 0x8234b960
	ctx.lr = 0x8219FEAC;
	sub_8234B960(ctx, base);
	// 8219FEAC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FEB0: FC40F090  fmr f2, f30
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[30].f64;
	// 8219FEB4: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FEB8: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FEBC: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FEC0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FEC4: 7FA7EB78  mr r7, r29
	ctx.r[7].u64 = ctx.r[29].u64;
	// 8219FEC8: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FECC: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 8219FED0: 38600027  li r3, 0x27
	ctx.r[3].s64 = 39;
	// 8219FED4: 4800AB25  bl 0x821aa9f8
	ctx.lr = 0x8219FED8;
	sub_821AA9F8(ctx, base);
	// 8219FED8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 8219FEDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FEE0: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 8219FEE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 8219FEE8: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 8219FEEC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 8219FEF0: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FEF4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 8219FEF8: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 8219FEFC: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 8219FF00: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 8219FF04: 480013AD  bl 0x821a12b0
	ctx.lr = 0x8219FF08;
	sub_821A12B0(ctx, base);
	// 8219FF08: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 8219FF0C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 8219FF10: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF14: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 8219FF18: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 8219FF1C: 481C11ED  bl 0x82361108
	ctx.lr = 0x8219FF20;
	sub_82361108(ctx, base);
	// 8219FF20: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FF24: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FF28: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FF2C: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FF30: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF34: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219FF38: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FF3C: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FF40: 38800003  li r4, 3
	ctx.r[4].s64 = 3;
	// 8219FF44: 3860000B  li r3, 0xb
	ctx.r[3].s64 = 11;
	// 8219FF48: 4800AAB1  bl 0x821aa9f8
	ctx.lr = 0x8219FF4C;
	sub_821AA9F8(ctx, base);
	// 8219FF4C: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 8219FF50: 392100A0  addi r9, r1, 0xa0
	ctx.r[9].s64 = ctx.r[1].s64 + 160;
	// 8219FF54: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 8219FF58: 39010090  addi r8, r1, 0x90
	ctx.r[8].s64 = ctx.r[1].s64 + 144;
	// 8219FF5C: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 8219FF60: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 8219FF64: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 8219FF68: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 8219FF6C: 38800020  li r4, 0x20
	ctx.r[4].s64 = 32;
	// 8219FF70: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 8219FF74: 4800AA85  bl 0x821aa9f8
	ctx.lr = 0x8219FF78;
	sub_821AA9F8(ctx, base);
	// 8219FF78: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 8219FF7C: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 8219FF80: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 8219FF84: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 8219FF88: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 8219FF8C: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 8219FF90: 409A0018  bne cr6, 0x8219ffa8
	if !ctx.cr[6].eq {
	pc = 0x8219FFA8; continue 'dispatch;
	}
	// 8219FF94: 7F06C378  mr r6, r24
	ctx.r[6].u64 = ctx.r[24].u64;
	// 8219FF98: 7F25CB78  mr r5, r25
	ctx.r[5].u64 = ctx.r[25].u64;
	// 8219FF9C: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 8219FFA0: 38600002  li r3, 2
	ctx.r[3].s64 = 2;
	// 8219FFA4: 4BFDCE5D  bl 0x8217ce00
	ctx.lr = 0x8219FFA8;
	sub_8217CE00(ctx, base);
            }
            0x8219FFA8 => {
    //   block [0x8219FFA8..0x8219FFB8)
	// 8219FFA8: 38210110  addi r1, r1, 0x110
	ctx.r[1].s64 = ctx.r[1].s64 + 272;
	// 8219FFAC: CBC1FFA8  lfd f30, -0x58(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-88 as u32) ) };
	// 8219FFB0: CBE1FFB0  lfd f31, -0x50(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-80 as u32) ) };
	// 8219FFB4: 48395144  b 0x825350f8
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_8219FFB8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x8219FFB8 size=344
    let mut pc: u32 = 0x8219FFB8;
    'dispatch: loop {
        match pc {
            0x8219FFB8 => {
    //   block [0x8219FFB8..0x821A0024)
	// 8219FFB8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 8219FFBC: 483950FD  bl 0x825350b8
	ctx.lr = 0x8219FFC0;
	sub_82535080(ctx, base);
	// 8219FFC0: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 8219FFC4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 8219FFC8: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 8219FFCC: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 8219FFD0: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 8219FFD4: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 8219FFD8: 816A42EC  lwz r11, 0x42ec(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17132 as u32) ) } as u64;
	// 8219FFDC: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 8219FFE0: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 8219FFE4: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 8219FFE8: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 8219FFEC: 3BC942DC  addi r30, r9, 0x42dc
	ctx.r[30].s64 = ctx.r[9].s64 + 17116;
	// 8219FFF0: 409A0034  bne cr6, 0x821a0024
	if !ctx.cr[6].eq {
	pc = 0x821A0024; continue 'dispatch;
	}
	// 8219FFF4: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 8219FFF8: 916A42EC  stw r11, 0x42ec(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17132 as u32), ctx.r[11].u32 ) };
	// 8219FFFC: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A0000: C00BD5B0  lfs f0, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0004: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0008: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A000C: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0010: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0014: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0018: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A001C: D01E0008  stfs f0, 8(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0020: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821A0024; continue 'dispatch;
            }
            0x821A0024 => {
    //   block [0x821A0024..0x821A0104)
	// 821A0024: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0028: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A002C: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0030: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A0034: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A0038: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A003C: 4BFFEA15  bl 0x8219ea50
	ctx.lr = 0x821A0040;
	sub_8219EA50(ctx, base);
	// 821A0040: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0044: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0048: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A004C: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0050: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0054: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0058: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A005C: 38C0006B  li r6, 0x6b
	ctx.r[6].s64 = 107;
	// 821A0060: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0064: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0068: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A006C: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A0070: FBE10060  std r31, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u64 ) };
	// 821A0074: 481AB8ED  bl 0x8234b960
	ctx.lr = 0x821A0078;
	sub_8234B960(ctx, base);
	// 821A0078: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A007C: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0080: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A0084: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A0088: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A008C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0090: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0094: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A0098: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A009C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A00A0: 4800A959  bl 0x821aa9f8
	ctx.lr = 0x821A00A4;
	sub_821AA9F8(ctx, base);
	// 821A00A4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A00A8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A00AC: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821A00B0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A00B4: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A00B8: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A00BC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A00C0: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A00C4: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A00C8: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A00CC: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A00D0: 480011E1  bl 0x821a12b0
	ctx.lr = 0x821A00D4;
	sub_821A12B0(ctx, base);
	// 821A00D4: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A00D8: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A00DC: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A00E0: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A00E4: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A00E8: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A00EC: 409A0018  bne cr6, 0x821a0104
	if !ctx.cr[6].eq {
	pc = 0x821A0104; continue 'dispatch;
	}
	// 821A00F0: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A00F4: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A00F8: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A00FC: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A0100: 4BFDCD01  bl 0x8217ce00
	ctx.lr = 0x821A0104;
	sub_8217CE00(ctx, base);
	pc = 0x821A0104; continue 'dispatch;
            }
            0x821A0104 => {
    //   block [0x821A0104..0x821A0110)
	// 821A0104: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0108: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A010C: 48394FFC  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0110(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0110 size=328
    let mut pc: u32 = 0x821A0110;
    'dispatch: loop {
        match pc {
            0x821A0110 => {
    //   block [0x821A0110..0x821A016C)
	// 821A0110: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0114: 48394FA5  bl 0x825350b8
	ctx.lr = 0x821A0118;
	sub_82535080(ctx, base);
	// 821A0118: DBE1FFD0  stfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-48 as u32), ctx.f[31].u64 ) };
	// 821A011C: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0120: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0124: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A0128: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A012C: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0130: 816A42D8  lwz r11, 0x42d8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17112 as u32) ) } as u64;
	// 821A0134: C3E8BA38  lfs f31, -0x45c8(r8)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A0138: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A013C: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0140: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A0144: 3BC942C8  addi r30, r9, 0x42c8
	ctx.r[30].s64 = ctx.r[9].s64 + 17096;
	// 821A0148: 409A0024  bne cr6, 0x821a016c
	if !ctx.cr[6].eq {
	pc = 0x821A016C; continue 'dispatch;
	}
	// 821A014C: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A0150: 916A42D8  stw r11, 0x42d8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17112 as u32), ctx.r[11].u32 ) };
	// 821A0154: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0158: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A015C: D01E0000  stfs f0, 0(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A0160: D01E0004  stfs f0, 4(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0164: D3FE0008  stfs f31, 8(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0168: D3FE000C  stfs f31, 0xc(r30)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821A016C; continue 'dispatch;
            }
            0x821A016C => {
    //   block [0x821A016C..0x821A024C)
	// 821A016C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0170: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A0174: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0178: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A017C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A0180: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A0184: 4BFFE8CD  bl 0x8219ea50
	ctx.lr = 0x821A0188;
	sub_8219EA50(ctx, base);
	// 821A0188: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A018C: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0190: FC20F890  fmr f1, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A0194: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0198: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A019C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A01A0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A01A4: 38C0007C  li r6, 0x7c
	ctx.r[6].s64 = 124;
	// 821A01A8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A01AC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A01B0: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A01B4: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A01B8: FBE10060  std r31, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u64 ) };
	// 821A01BC: 481AB7A5  bl 0x8234b960
	ctx.lr = 0x821A01C0;
	sub_8234B960(ctx, base);
	// 821A01C0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A01C4: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A01C8: FC40F890  fmr f2, f31
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[31].f64;
	// 821A01CC: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A01D0: FC20F890  fmr f1, f31
	ctx.f[1].f64 = ctx.f[31].f64;
	// 821A01D4: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A01D8: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A01DC: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A01E0: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A01E4: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A01E8: 4800A811  bl 0x821aa9f8
	ctx.lr = 0x821A01EC;
	sub_821AA9F8(ctx, base);
	// 821A01EC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A01F0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A01F4: 93E1005C  stw r31, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[31].u32 ) };
	// 821A01F8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A01FC: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0200: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0204: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0208: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A020C: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0210: 7FC4F378  mr r4, r30
	ctx.r[4].u64 = ctx.r[30].u64;
	// 821A0214: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0218: 48001099  bl 0x821a12b0
	ctx.lr = 0x821A021C;
	sub_821A12B0(ctx, base);
	// 821A021C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0220: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0224: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A0228: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A022C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0230: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0234: 409A0018  bne cr6, 0x821a024c
	if !ctx.cr[6].eq {
	pc = 0x821A024C; continue 'dispatch;
	}
	// 821A0238: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A023C: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0240: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0244: 38600004  li r3, 4
	ctx.r[3].s64 = 4;
	// 821A0248: 4BFDCBB9  bl 0x8217ce00
	ctx.lr = 0x821A024C;
	sub_8217CE00(ctx, base);
	pc = 0x821A024C; continue 'dispatch;
            }
            0x821A024C => {
    //   block [0x821A024C..0x821A0258)
	// 821A024C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0250: CBE1FFD0  lfd f31, -0x30(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-48 as u32) ) };
	// 821A0254: 48394EB4  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0258(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0258 size=288
    let mut pc: u32 = 0x821A0258;
    'dispatch: loop {
        match pc {
            0x821A0258 => {
    //   block [0x821A0258..0x821A02C0)
	// 821A0258: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A025C: 48394E5D  bl 0x825350b8
	ctx.lr = 0x821A0260;
	sub_82535080(ctx, base);
	// 821A0260: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0264: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0268: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A026C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A0270: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0274: 816A42A4  lwz r11, 0x42a4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17060 as u32) ) } as u64;
	// 821A0278: C028BA38  lfs f1, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A027C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A0280: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0284: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A0288: 3BE94294  addi r31, r9, 0x4294
	ctx.r[31].s64 = ctx.r[9].s64 + 17044;
	// 821A028C: 409A0034  bne cr6, 0x821a02c0
	if !ctx.cr[6].eq {
	pc = 0x821A02C0; continue 'dispatch;
	}
	// 821A0290: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A0294: 916A42A4  stw r11, 0x42a4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17060 as u32), ctx.r[11].u32 ) };
	// 821A0298: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A029C: C00B2C44  lfs f0, 0x2c44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02A0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A02A4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A02A8: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02AC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A02B0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A02B4: C00B295C  lfs f0, 0x295c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A02B8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A02BC: D03F000C  stfs f1, 0xc(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821A02C0; continue 'dispatch;
            }
            0x821A02C0 => {
    //   block [0x821A02C0..0x821A0370)
	// 821A02C0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A02C4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A02C8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A02CC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821A02D0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A02D4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A02D8: 4BFFE779  bl 0x8219ea50
	ctx.lr = 0x821A02DC;
	sub_8219EA50(ctx, base);
	// 821A02DC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A02E0: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A02E4: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A02E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A02EC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A02F0: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A02F4: 38C0007A  li r6, 0x7a
	ctx.r[6].s64 = 122;
	// 821A02F8: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A02FC: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0300: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0304: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0308: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A030C: 481AB655  bl 0x8234b960
	ctx.lr = 0x821A0310;
	sub_8234B960(ctx, base);
	// 821A0310: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0314: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0318: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A031C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0320: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0324: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0328: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A032C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0330: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0334: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A0338: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821A033C: 48000F75  bl 0x821a12b0
	ctx.lr = 0x821A0340;
	sub_821A12B0(ctx, base);
	// 821A0340: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0344: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0348: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A034C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A0350: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0354: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0358: 409A0018  bne cr6, 0x821a0370
	if !ctx.cr[6].eq {
	pc = 0x821A0370; continue 'dispatch;
	}
	// 821A035C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0360: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0364: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0368: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A036C: 4BFDCA95  bl 0x8217ce00
	ctx.lr = 0x821A0370;
	sub_8217CE00(ctx, base);
	pc = 0x821A0370; continue 'dispatch;
            }
            0x821A0370 => {
    //   block [0x821A0370..0x821A0378)
	// 821A0370: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0374: 48394D94  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0378(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0378 size=288
    let mut pc: u32 = 0x821A0378;
    'dispatch: loop {
        match pc {
            0x821A0378 => {
    //   block [0x821A0378..0x821A03E0)
	// 821A0378: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A037C: 48394D3D  bl 0x825350b8
	ctx.lr = 0x821A0380;
	sub_82535080(ctx, base);
	// 821A0380: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0384: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A0388: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A038C: 7C7D1B78  mr r29, r3
	ctx.r[29].u64 = ctx.r[3].u64;
	// 821A0390: 7C9C2378  mr r28, r4
	ctx.r[28].u64 = ctx.r[4].u64;
	// 821A0394: 816A4290  lwz r11, 0x4290(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17040 as u32) ) } as u64;
	// 821A0398: C028BA38  lfs f1, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A039C: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A03A0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A03A4: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A03A8: 3BE94280  addi r31, r9, 0x4280
	ctx.r[31].s64 = ctx.r[9].s64 + 17024;
	// 821A03AC: 409A0034  bne cr6, 0x821a03e0
	if !ctx.cr[6].eq {
	pc = 0x821A03E0; continue 'dispatch;
	}
	// 821A03B0: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A03B4: 916A4290  stw r11, 0x4290(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17040 as u32), ctx.r[11].u32 ) };
	// 821A03B8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03BC: C00B2C44  lfs f0, 0x2c44(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11332 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03C0: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03C4: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A03C8: C00B203C  lfs f0, 0x203c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8252 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03CC: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A03D0: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A03D4: C00B295C  lfs f0, 0x295c(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(10588 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A03D8: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A03DC: D03F000C  stfs f1, 0xc(r31)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821A03E0; continue 'dispatch;
            }
            0x821A03E0 => {
    //   block [0x821A03E0..0x821A0490)
	// 821A03E0: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A03E4: 38E00001  li r7, 1
	ctx.r[7].s64 = 1;
	// 821A03E8: 38C10070  addi r6, r1, 0x70
	ctx.r[6].s64 = ctx.r[1].s64 + 112;
	// 821A03EC: 38A10080  addi r5, r1, 0x80
	ctx.r[5].s64 = ctx.r[1].s64 + 128;
	// 821A03F0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A03F4: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A03F8: 4BFFE659  bl 0x8219ea50
	ctx.lr = 0x821A03FC;
	sub_8219EA50(ctx, base);
	// 821A03FC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0400: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A0404: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A0408: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A040C: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0410: 38E10080  addi r7, r1, 0x80
	ctx.r[7].s64 = ctx.r[1].s64 + 128;
	// 821A0414: 38C0000C  li r6, 0xc
	ctx.r[6].s64 = 12;
	// 821A0418: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A041C: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A0420: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0424: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0428: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A042C: 481AB535  bl 0x8234b960
	ctx.lr = 0x821A0430;
	sub_8234B960(ctx, base);
	// 821A0430: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0434: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0438: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A043C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0440: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0444: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0448: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A044C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0450: C02B2068  lfs f1, 0x2068(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0454: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A0458: 38610080  addi r3, r1, 0x80
	ctx.r[3].s64 = ctx.r[1].s64 + 128;
	// 821A045C: 48000E55  bl 0x821a12b0
	ctx.lr = 0x821A0460;
	sub_821A12B0(ctx, base);
	// 821A0460: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0464: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0468: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A046C: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A0470: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A0474: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A0478: 409A0018  bne cr6, 0x821a0490
	if !ctx.cr[6].eq {
	pc = 0x821A0490; continue 'dispatch;
	}
	// 821A047C: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0480: 7F85E378  mr r5, r28
	ctx.r[5].u64 = ctx.r[28].u64;
	// 821A0484: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0488: 38600006  li r3, 6
	ctx.r[3].s64 = 6;
	// 821A048C: 4BFDC975  bl 0x8217ce00
	ctx.lr = 0x821A0490;
	sub_8217CE00(ctx, base);
	pc = 0x821A0490; continue 'dispatch;
            }
            0x821A0490 => {
    //   block [0x821A0490..0x821A0498)
	// 821A0490: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0494: 48394C74  b 0x82535108
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0498(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0498 size=564
    let mut pc: u32 = 0x821A0498;
    'dispatch: loop {
        match pc {
            0x821A0498 => {
    //   block [0x821A0498..0x821A0508)
	// 821A0498: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A049C: 48394C15  bl 0x825350b0
	ctx.lr = 0x821A04A0;
	sub_82535080(ctx, base);
	// 821A04A0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821A04A4: 48395B45  bl 0x82535fe8
	ctx.lr = 0x821A04A8;
	sub_82535FB0(ctx, base);
	// 821A04A8: 9421FF10  stwu r1, -0xf0(r1)
	ea = ctx.r[1].u32.wrapping_add(-240 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A04AC: 3D408311  lis r10, -0x7cef
	ctx.r[10].s64 = -2096037888;
	// 821A04B0: 3D00820A  lis r8, -0x7df6
	ctx.r[8].s64 = -2113273856;
	// 821A04B4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A04B8: 7C9A2378  mr r26, r4
	ctx.r[26].u64 = ctx.r[4].u64;
	// 821A04BC: 816A44A8  lwz r11, 0x44a8(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(17576 as u32) ) } as u64;
	// 821A04C0: C388BA38  lfs f28, -0x45c8(r8)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[28].f64 = (tmp.f32 as f64);
	// 821A04C4: 556907FE  clrlwi r9, r11, 0x1f
	ctx.r[9].u64 = ctx.r[11].u32 as u64 & 0x00000001u64;
	// 821A04C8: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A04CC: 3D208311  lis r9, -0x7cef
	ctx.r[9].s64 = -2096037888;
	// 821A04D0: 3BA94498  addi r29, r9, 0x4498
	ctx.r[29].s64 = ctx.r[9].s64 + 17560;
	// 821A04D4: 409A0034  bne cr6, 0x821a0508
	if !ctx.cr[6].eq {
	pc = 0x821A0508; continue 'dispatch;
	}
	// 821A04D8: 616B0001  ori r11, r11, 1
	ctx.r[11].u64 = ctx.r[11].u64 | 1;
	// 821A04DC: 916A44A8  stw r11, 0x44a8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(17576 as u32), ctx.r[11].u32 ) };
	// 821A04E0: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A04E4: C00BD5B0  lfs f0, -0x2a50(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A04E8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A04EC: D01D0000  stfs f0, 0(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A04F0: C00B1FF8  lfs f0, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A04F4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A04F8: D01D0004  stfs f0, 4(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A04FC: C00B20C8  lfs f0, 0x20c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8392 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0500: D01D0008  stfs f0, 8(r29)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(8 as u32), tmp.u32 ) };
	// 821A0504: D39D000C  stfs f28, 0xc(r29)
	tmp.f32 = (ctx.f[28].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[29].u32.wrapping_add(12 as u32), tmp.u32 ) };
	pc = 0x821A0508; continue 'dispatch;
            }
            0x821A0508 => {
    //   block [0x821A0508..0x821A05F8)
	// 821A0508: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A050C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0510: 38C10080  addi r6, r1, 0x80
	ctx.r[6].s64 = ctx.r[1].s64 + 128;
	// 821A0514: 38A10070  addi r5, r1, 0x70
	ctx.r[5].s64 = ctx.r[1].s64 + 112;
	// 821A0518: 7F44D378  mr r4, r26
	ctx.r[4].u64 = ctx.r[26].u64;
	// 821A051C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0520: 4BFFE531  bl 0x8219ea50
	ctx.lr = 0x821A0524;
	sub_8219EA50(ctx, base);
	// 821A0524: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A0528: 387F0030  addi r3, r31, 0x30
	ctx.r[3].s64 = ctx.r[31].s64 + 48;
	// 821A052C: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A0530: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0534: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A0538: 4E800421  bctrl
	ctx.lr = 0x821A053C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A053C: 3D600005  lis r11, 5
	ctx.r[11].s64 = 327680;
	// 821A0540: C3E30030  lfs f31, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A0544: 38800002  li r4, 2
	ctx.r[4].s64 = 2;
	// 821A0548: 616BA9C0  ori r11, r11, 0xa9c0
	ctx.r[11].u64 = ctx.r[11].u64 | 43456;
	// 821A054C: C3C30034  lfs f30, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A0550: C3A30038  lfs f29, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[29].f64 = (tmp.f32 as f64);
	// 821A0554: 7D7F582E  lwzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0558: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A055C: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A0560: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0564: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A0568: 4E800421  bctrl
	ctx.lr = 0x821A056C;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A056C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0570: C1A1008C  lfs f13, 0x8c(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(140 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0574: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A0578: D1A1007C  stfs f13, 0x7c(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A057C: C1A30030  lfs f13, 0x30(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0580: C1830034  lfs f12, 0x34(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(52 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A0584: C00BBFFC  lfs f0, -0x4004(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0588: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A058C: ED5F0032  fmuls f10, f31, f0
	ctx.f[10].f64 = (((ctx.f[31].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0590: C1630038  lfs f11, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A0594: ED3E0032  fmuls f9, f30, f0
	ctx.f[9].f64 = (((ctx.f[30].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0598: 616BBE64  ori r11, r11, 0xbe64
	ctx.r[11].u64 = ctx.r[11].u64 | 48740;
	// 821A059C: ED1D0032  fmuls f8, f29, f0
	ctx.f[8].f64 = (((ctx.f[29].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A05A0: FBC10060  std r30, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[30].u64 ) };
	// 821A05A4: 7D7F58AE  lbzx r11, r31, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[31].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A05A8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A05AC: EDAD503A  fmadds f13, f13, f0, f10
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64 + ctx.f[10].f64) as f32) as f64);
	// 821A05B0: D1A10070  stfs f13, 0x70(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A05B4: EDAC483A  fmadds f13, f12, f0, f9
	ctx.f[13].f64 = (((ctx.f[12].f64 * ctx.f[0].f64 + ctx.f[9].f64) as f32) as f64);
	// 821A05B8: D1A10074  stfs f13, 0x74(r1)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A05BC: EC0B403A  fmadds f0, f11, f0, f8
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64 + ctx.f[8].f64) as f32) as f64);
	// 821A05C0: D0010078  stfs f0, 0x78(r1)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A05C4: 409A0034  bne cr6, 0x821a05f8
	if !ctx.cr[6].eq {
	pc = 0x821A05F8; continue 'dispatch;
	}
	// 821A05C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A05CC: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A05D0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A05D4: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A05D8: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A05DC: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A05E0: 38E10070  addi r7, r1, 0x70
	ctx.r[7].s64 = ctx.r[1].s64 + 112;
	// 821A05E4: 38C0007D  li r6, 0x7d
	ctx.r[6].s64 = 125;
	// 821A05E8: 38810060  addi r4, r1, 0x60
	ctx.r[4].s64 = ctx.r[1].s64 + 96;
	// 821A05EC: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A05F0: 80AB000C  lwz r5, 0xc(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A05F4: 481AB36D  bl 0x8234b960
	ctx.lr = 0x821A05F8;
	sub_8234B960(ctx, base);
            }
            0x821A05F8 => {
    //   block [0x821A05F8..0x821A0660)
	// 821A05F8: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A05FC: FC40E090  fmr f2, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[2].f64 = ctx.f[28].f64;
	// 821A0600: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0604: FC20E090  fmr f1, f28
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0608: 39010080  addi r8, r1, 0x80
	ctx.r[8].s64 = ctx.r[1].s64 + 128;
	// 821A060C: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0610: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0614: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A0618: 38800018  li r4, 0x18
	ctx.r[4].s64 = 24;
	// 821A061C: 38600005  li r3, 5
	ctx.r[3].s64 = 5;
	// 821A0620: 4800A3D9  bl 0x821aa9f8
	ctx.lr = 0x821A0624;
	sub_821AA9F8(ctx, base);
	// 821A0624: 3D4082B5  lis r10, -0x7d4b
	ctx.r[10].s64 = -2102067200;
	// 821A0628: 3F6082C0  lis r27, -0x7d40
	ctx.r[27].s64 = -2101346304;
	// 821A062C: 3B8A0C40  addi r28, r10, 0xc40
	ctx.r[28].s64 = ctx.r[10].s64 + 3136;
	// 821A0630: 817BB9DC  lwz r11, -0x4624(r27)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[27].u32.wrapping_add(-17956 as u32) ) } as u64;
	// 821A0634: 815C0684  lwz r10, 0x684(r28)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821A0638: 7F0B5040  cmplw cr6, r11, r10
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[10].u32, &mut ctx.xer);
	// 821A063C: 419A0024  beq cr6, 0x821a0660
	if ctx.cr[6].eq {
	pc = 0x821A0660; continue 'dispatch;
	}
	// 821A0640: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A0644: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0648: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A064C: 3880000B  li r4, 0xb
	ctx.r[4].s64 = 11;
	// 821A0650: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0654: 481C0AB5  bl 0x82361108
	ctx.lr = 0x821A0658;
	sub_82361108(ctx, base);
	// 821A0658: 817C0684  lwz r11, 0x684(r28)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[28].u32.wrapping_add(1668 as u32) ) } as u64;
	// 821A065C: 917BB9DC  stw r11, -0x4624(r27)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[27].u32.wrapping_add(-17956 as u32), ctx.r[11].u32 ) };
	pc = 0x821A0660; continue 'dispatch;
            }
            0x821A0660 => {
    //   block [0x821A0660..0x821A06BC)
	// 821A0660: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0664: FC20E090  fmr f1, f28
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[1].f64 = ctx.f[28].f64;
	// 821A0668: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A066C: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A0670: 39000000  li r8, 0
	ctx.r[8].s64 = 0;
	// 821A0674: 93C10054  stw r30, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[30].u32 ) };
	// 821A0678: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A067C: 38C00010  li r6, 0x10
	ctx.r[6].s64 = 16;
	// 821A0680: 7FA4EB78  mr r4, r29
	ctx.r[4].u64 = ctx.r[29].u64;
	// 821A0684: 38610070  addi r3, r1, 0x70
	ctx.r[3].s64 = ctx.r[1].s64 + 112;
	// 821A0688: 48000C29  bl 0x821a12b0
	ctx.lr = 0x821A068C;
	sub_821A12B0(ctx, base);
	// 821A068C: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A0690: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A0694: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A0698: 614A9450  ori r10, r10, 0x9450
	ctx.r[10].u64 = ctx.r[10].u64 | 37968;
	// 821A069C: 7D6B522E  lhzx r11, r11, r10
	ctx.r[11].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A06A0: 2B0B0001  cmplwi cr6, r11, 1
	ctx.cr[6].compare_u32(ctx.r[11].u32, 1 as u32, &mut ctx.xer);
	// 821A06A4: 409A0018  bne cr6, 0x821a06bc
	if !ctx.cr[6].eq {
	pc = 0x821A06BC; continue 'dispatch;
	}
	// 821A06A8: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A06AC: 7F45D378  mr r5, r26
	ctx.r[5].u64 = ctx.r[26].u64;
	// 821A06B0: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A06B4: 38600007  li r3, 7
	ctx.r[3].s64 = 7;
	// 821A06B8: 4BFDC749  bl 0x8217ce00
	ctx.lr = 0x821A06BC;
	sub_8217CE00(ctx, base);
	pc = 0x821A06BC; continue 'dispatch;
            }
            0x821A06BC => {
    //   block [0x821A06BC..0x821A06CC)
	// 821A06BC: 382100F0  addi r1, r1, 0xf0
	ctx.r[1].s64 = ctx.r[1].s64 + 240;
	// 821A06C0: 3981FFC8  addi r12, r1, -0x38
	ctx.r[12].s64 = ctx.r[1].s64 + -56;
	// 821A06C4: 48395971  bl 0x82536034
	ctx.lr = 0x821A06C8;
	sub_82535FFC(ctx, base);
	// 821A06C8: 48394A38  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A06D0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A06D0 size=228
    let mut pc: u32 = 0x821A06D0;
    'dispatch: loop {
        match pc {
            0x821A06D0 => {
    //   block [0x821A06D0..0x821A073C)
	// 821A06D0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A06D4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A06D8: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A06DC: 9421FF70  stwu r1, -0x90(r1)
	ea = ctx.r[1].u32.wrapping_add(-144 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A06E0: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A06E4: 3880000E  li r4, 0xe
	ctx.r[4].s64 = 14;
	// 821A06E8: 386B0030  addi r3, r11, 0x30
	ctx.r[3].s64 = ctx.r[11].s64 + 48;
	// 821A06EC: 816B0030  lwz r11, 0x30(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A06F0: 816B0008  lwz r11, 8(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A06F4: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A06F8: 4E800421  bctrl
	ctx.lr = 0x821A06FC;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A06FC: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A0700: C0230030  lfs f1, 0x30(r3)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A0704: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A0708: 396BDBD0  addi r11, r11, -0x2430
	ctx.r[11].s64 = ctx.r[11].s64 + -9264;
	// 821A070C: C0430038  lfs f2, 0x38(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(56 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0710: D0210070  stfs f1, 0x70(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(112 as u32), tmp.u32 ) };
	// 821A0714: D0410078  stfs f2, 0x78(r1)
	tmp.f32 = (ctx.f[2].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(120 as u32), tmp.u32 ) };
	// 821A0718: 894B0001  lbz r10, 1(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(1 as u32) ) } as u64;
	// 821A071C: 7D4A0774  extsb r10, r10
	ctx.r[10].s64 = ctx.r[10].s8 as i64;
	// 821A0720: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A0724: 40990018  ble cr6, 0x821a073c
	if !ctx.cr[6].gt {
	pc = 0x821A073C; continue 'dispatch;
	}
	// 821A0728: 896B0002  lbz r11, 2(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[11].u32.wrapping_add(2 as u32) ) } as u64;
	// 821A072C: 7D6B0774  extsb r11, r11
	ctx.r[11].s64 = ctx.r[11].s8 as i64;
	// 821A0730: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A0734: 39600001  li r11, 1
	ctx.r[11].s64 = 1;
	// 821A0738: 41990008  bgt cr6, 0x821a0740
	if ctx.cr[6].gt {
	pc = 0x821A0740; continue 'dispatch;
	}
            }
            0x821A073C => {
    //   block [0x821A073C..0x821A0740)
	// 821A073C: 7FEBFB78  mr r11, r31
	ctx.r[11].u64 = ctx.r[31].u64;
	pc = 0x821A0740; continue 'dispatch;
            }
            0x821A0740 => {
    //   block [0x821A0740..0x821A0758)
	// 821A0740: 556B063E  clrlwi r11, r11, 0x18
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0x000000FFu64;
	// 821A0744: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A0748: 409A0010  bne cr6, 0x821a0758
	if !ctx.cr[6].eq {
	pc = 0x821A0758; continue 'dispatch;
	}
	// 821A074C: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A0750: 48016D79  bl 0x821b74c8
	ctx.lr = 0x821A0754;
	sub_821B74C8(ctx, base);
	// 821A0754: 48000014  b 0x821a0768
	pc = 0x821A0768; continue 'dispatch;
            }
            0x821A0758 => {
    //   block [0x821A0758..0x821A0768)
	// 821A0758: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	// 821A075C: 93E10060  stw r31, 0x60(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[31].u32 ) };
	// 821A0760: 38A10060  addi r5, r1, 0x60
	ctx.r[5].s64 = ctx.r[1].s64 + 96;
	// 821A0764: 48016DCD  bl 0x821b7530
	ctx.lr = 0x821A0768;
	sub_821B7530(ctx, base);
	pc = 0x821A0768; continue 'dispatch;
            }
            0x821A0768 => {
    //   block [0x821A0768..0x821A07B4)
	// 821A0768: 3D608311  lis r11, -0x7cef
	ctx.r[11].s64 = -2096037888;
	// 821A076C: D0210074  stfs f1, 0x74(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), tmp.u32 ) };
	// 821A0770: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0774: 93E10054  stw r31, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[31].u32 ) };
	// 821A0778: 390B33C0  addi r8, r11, 0x33c0
	ctx.r[8].s64 = ctx.r[11].s64 + 13248;
	// 821A077C: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A0780: 39210070  addi r9, r1, 0x70
	ctx.r[9].s64 = ctx.r[1].s64 + 112;
	// 821A0784: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0788: 38C0FFFF  li r6, -1
	ctx.r[6].s64 = -1;
	// 821A078C: 38800040  li r4, 0x40
	ctx.r[4].s64 = 64;
	// 821A0790: C04BBA38  lfs f2, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0794: 38600011  li r3, 0x11
	ctx.r[3].s64 = 17;
	// 821A0798: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	// 821A079C: 4800A25D  bl 0x821aa9f8
	ctx.lr = 0x821A07A0;
	sub_821AA9F8(ctx, base);
	// 821A07A0: 38210090  addi r1, r1, 0x90
	ctx.r[1].s64 = ctx.r[1].s64 + 144;
	// 821A07A4: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A07A8: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A07AC: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A07B0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A07B8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A07B8 size=380
    let mut pc: u32 = 0x821A07B8;
    'dispatch: loop {
        match pc {
            0x821A07B8 => {
    //   block [0x821A07B8..0x821A07F8)
	// 821A07B8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A07BC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A07C0: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A07C4: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A07C8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A07CC: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A07D0: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A07D4: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A07D8: 40980020  bge cr6, 0x821a07f8
	if !ctx.cr[6].lt {
	pc = 0x821A07F8; continue 'dispatch;
	}
	// 821A07DC: 3D400001  lis r10, 1
	ctx.r[10].s64 = 65536;
	// 821A07E0: 614AFAF0  ori r10, r10, 0xfaf0
	ctx.r[10].u64 = ctx.r[10].u64 | 64240;
	// 821A07E4: 7D44502E  lwzx r10, r4, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A07E8: C00A0010  lfs f0, 0x10(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A07EC: C1AA0008  lfs f13, 8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A07F0: EC206828  fsubs f1, f0, f13
	ctx.f[1].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A07F4: 48000018  b 0x821a080c
	pc = 0x821A080C; continue 'dispatch;
            }
            0x821A07F8 => {
    //   block [0x821A07F8..0x821A080C)
	// 821A07F8: 7CCA07B4  extsw r10, r6
	ctx.r[10].s64 = ctx.r[6].s32 as i64;
	// 821A07FC: F9410090  std r10, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[10].u64 ) };
	// 821A0800: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0804: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0808: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x821A080C; continue 'dispatch;
            }
            0x821A080C => {
    //   block [0x821A080C..0x821A0828)
	// 821A080C: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A0810: C00A1FF8  lfs f0, 0x1ff8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0814: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0818: FF010000  fcmpu cr6, f1, f0
	ctx.cr[6].compare_f64(ctx.f[1].f64, ctx.f[0].f64);
	// 821A081C: C04ABA38  lfs f2, -0x45c8(r10)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0820: 41990008  bgt cr6, 0x821a0828
	if ctx.cr[6].gt {
	pc = 0x821A0828; continue 'dispatch;
	}
	// 821A0824: FC201090  fmr f1, f2
	ctx.f[1].f64 = ctx.f[2].f64;
	pc = 0x821A0828; continue 'dispatch;
            }
            0x821A0828 => {
    //   block [0x821A0828..0x821A0848)
	// 821A0828: 2B070001  cmplwi cr6, r7, 1
	ctx.cr[6].compare_u32(ctx.r[7].u32, 1 as u32, &mut ctx.xer);
	// 821A082C: 4198009C  blt cr6, 0x821a08c8
	if ctx.cr[6].lt {
	pc = 0x821A08C8; continue 'dispatch;
	}
	// 821A0830: 419A0058  beq cr6, 0x821a0888
	if ctx.cr[6].eq {
	pc = 0x821A0888; continue 'dispatch;
	}
	// 821A0834: 2B070003  cmplwi cr6, r7, 3
	ctx.cr[6].compare_u32(ctx.r[7].u32, 3 as u32, &mut ctx.xer);
	// 821A0838: 409800E0  bge cr6, 0x821a0918
	if !ctx.cr[6].lt {
	pc = 0x821A0918; continue 'dispatch;
	}
	// 821A083C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0840: 409A0008  bne cr6, 0x821a0848
	if !ctx.cr[6].eq {
	pc = 0x821A0848; continue 'dispatch;
	}
	// 821A0844: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	pc = 0x821A0848; continue 'dispatch;
            }
            0x821A0848 => {
    //   block [0x821A0848..0x821A0888)
	// 821A0848: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A084C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A0850: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A0854: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0858: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A085C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0860: 38A00008  li r5, 8
	ctx.r[5].s64 = 8;
	// 821A0864: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0868: 38800009  li r4, 9
	ctx.r[4].s64 = 9;
	// 821A086C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0870: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0874: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A0878: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A087C: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A0880: 4800A8D9  bl 0x821ab158
	ctx.lr = 0x821A0884;
	sub_821AB158(ctx, base);
	// 821A0884: 4800008C  b 0x821a0910
	pc = 0x821A0910; continue 'dispatch;
            }
            0x821A0888 => {
    //   block [0x821A0888..0x821A08C8)
	// 821A0888: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A088C: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A0890: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A0894: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0898: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A089C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A08A0: 38A00018  li r5, 0x18
	ctx.r[5].s64 = 24;
	// 821A08A4: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A08A8: 38800019  li r4, 0x19
	ctx.r[4].s64 = 25;
	// 821A08AC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A08B0: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A08B4: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A08B8: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A08BC: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A08C0: 4800A899  bl 0x821ab158
	ctx.lr = 0x821A08C4;
	sub_821AB158(ctx, base);
	// 821A08C4: 4800004C  b 0x821a0910
	pc = 0x821A0910; continue 'dispatch;
            }
            0x821A08C8 => {
    //   block [0x821A08C8..0x821A08D4)
	// 821A08C8: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A08CC: 409A0008  bne cr6, 0x821a08d4
	if !ctx.cr[6].eq {
	pc = 0x821A08D4; continue 'dispatch;
	}
	// 821A08D0: 3900007C  li r8, 0x7c
	ctx.r[8].s64 = 124;
	pc = 0x821A08D4; continue 'dispatch;
            }
            0x821A08D4 => {
    //   block [0x821A08D4..0x821A0910)
	// 821A08D4: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A08D8: 91210064  stw r9, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[9].u32 ) };
	// 821A08DC: 90A1005C  stw r5, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[5].u32 ) };
	// 821A08E0: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A08E4: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A08E8: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A08EC: 38A00005  li r5, 5
	ctx.r[5].s64 = 5;
	// 821A08F0: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A08F4: 3880001A  li r4, 0x1a
	ctx.r[4].s64 = 26;
	// 821A08F8: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A08FC: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0900: 386100A0  addi r3, r1, 0xa0
	ctx.r[3].s64 = ctx.r[1].s64 + 160;
	// 821A0904: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0908: 91610074  stw r11, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[11].u32 ) };
	// 821A090C: 4800A84D  bl 0x821ab158
	ctx.lr = 0x821A0910;
	sub_821AB158(ctx, base);
	pc = 0x821A0910; continue 'dispatch;
            }
            0x821A0910 => {
    //   block [0x821A0910..0x821A0918)
	// 821A0910: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0914: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	pc = 0x821A0918; continue 'dispatch;
            }
            0x821A0918 => {
    //   block [0x821A0918..0x821A0934)
	// 821A0918: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A091C: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0920: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A0924: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0928: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A092C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0930: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0938(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0938 size=396
    let mut pc: u32 = 0x821A0938;
    'dispatch: loop {
        match pc {
            0x821A0938 => {
    //   block [0x821A0938..0x821A0968)
	// 821A0938: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A093C: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0940: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0944: 7CE83B78  mr r8, r7
	ctx.r[8].u64 = ctx.r[7].u64;
	// 821A0948: 2B060001  cmplwi cr6, r6, 1
	ctx.cr[6].compare_u32(ctx.r[6].u32, 1 as u32, &mut ctx.xer);
	// 821A094C: 41980100  blt cr6, 0x821a0a4c
	if ctx.cr[6].lt {
	pc = 0x821A0A4C; continue 'dispatch;
	}
	// 821A0950: 419A0084  beq cr6, 0x821a09d4
	if ctx.cr[6].eq {
	pc = 0x821A09D4; continue 'dispatch;
	}
	// 821A0954: 2B060003  cmplwi cr6, r6, 3
	ctx.cr[6].compare_u32(ctx.r[6].u32, 3 as u32, &mut ctx.xer);
	// 821A0958: 4098015C  bge cr6, 0x821a0ab4
	if !ctx.cr[6].lt {
	pc = 0x821A0AB4; continue 'dispatch;
	}
	// 821A095C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0960: 409A0008  bne cr6, 0x821a0968
	if !ctx.cr[6].eq {
	pc = 0x821A0968; continue 'dispatch;
	}
	// 821A0964: 390000A0  li r8, 0xa0
	ctx.r[8].s64 = 160;
	pc = 0x821A0968; continue 'dispatch;
            }
            0x821A0968 => {
    //   block [0x821A0968..0x821A09D4)
	// 821A0968: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A096C: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A0970: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0974: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A0978: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A097C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A0980: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A0984: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0988: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A098C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0990: C04ABA38  lfs f2, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0994: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0998: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A099C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A09A0: 38800033  li r4, 0x33
	ctx.r[4].s64 = 51;
	// 821A09A4: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A09A8: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A09AC: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A09B0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A09B4: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A09B8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A09BC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A09C0: 4800A799  bl 0x821ab158
	ctx.lr = 0x821A09C4;
	sub_821AB158(ctx, base);
	// 821A09C4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A09C8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A09CC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A09D0: 4E800020  blr
	return;
            }
            0x821A09D4 => {
    //   block [0x821A09D4..0x821A09E0)
	// 821A09D4: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A09D8: 409A0008  bne cr6, 0x821a09e0
	if !ctx.cr[6].eq {
	pc = 0x821A09E0; continue 'dispatch;
	}
	// 821A09DC: 39000040  li r8, 0x40
	ctx.r[8].s64 = 64;
	pc = 0x821A09E0; continue 'dispatch;
            }
            0x821A09E0 => {
    //   block [0x821A09E0..0x821A0A4C)
	// 821A09E0: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A09E4: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A09E8: 3D40820D  lis r10, -0x7df3
	ctx.r[10].s64 = -2113077248;
	// 821A09EC: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A09F0: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A09F4: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A09F8: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A09FC: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0A00: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A0A04: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0A08: C04A207C  lfs f2, 0x207c(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(8316 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0A0C: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0A10: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0A14: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0A18: 38800014  li r4, 0x14
	ctx.r[4].s64 = 20;
	// 821A0A1C: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A0A20: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A0A24: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0A28: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A0A2C: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0A30: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0A34: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0A38: 4800A721  bl 0x821ab158
	ctx.lr = 0x821A0A3C;
	sub_821AB158(ctx, base);
	// 821A0A3C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0A40: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0A44: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0A48: 4E800020  blr
	return;
            }
            0x821A0A4C => {
    //   block [0x821A0A4C..0x821A0A58)
	// 821A0A4C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0A50: 409A0008  bne cr6, 0x821a0a58
	if !ctx.cr[6].eq {
	pc = 0x821A0A58; continue 'dispatch;
	}
	// 821A0A54: 39000080  li r8, 0x80
	ctx.r[8].s64 = 128;
	pc = 0x821A0A58; continue 'dispatch;
            }
            0x821A0A58 => {
    //   block [0x821A0A58..0x821A0AB4)
	// 821A0A58: 7CA707B4  extsw r7, r5
	ctx.r[7].s64 = ctx.r[5].s32 as i64;
	// 821A0A5C: 91210074  stw r9, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[9].u32 ) };
	// 821A0A60: 3D40820A  lis r10, -0x7df6
	ctx.r[10].s64 = -2113273856;
	// 821A0A64: 9081005C  stw r4, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[4].u32 ) };
	// 821A0A68: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A0A6C: 90610054  stw r3, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[3].u32 ) };
	// 821A0A70: 38C00400  li r6, 0x400
	ctx.r[6].s64 = 1024;
	// 821A0A74: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0A78: F8E10090  std r7, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[7].u64 ) };
	// 821A0A7C: 38A00001  li r5, 1
	ctx.r[5].s64 = 1;
	// 821A0A80: C04ABA38  lfs f2, -0x45c8(r10)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0A84: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0A88: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0A8C: 9161008C  stw r11, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[11].u32 ) };
	// 821A0A90: 38800013  li r4, 0x13
	ctx.r[4].s64 = 19;
	// 821A0A94: 90C10084  stw r6, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[6].u32 ) };
	// 821A0A98: 38610098  addi r3, r1, 0x98
	ctx.r[3].s64 = ctx.r[1].s64 + 152;
	// 821A0A9C: 9161007C  stw r11, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[11].u32 ) };
	// 821A0AA0: 91610064  stw r11, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[11].u32 ) };
	// 821A0AA4: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0AA8: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0AAC: FC200018  frsp f1, f0
	ctx.f[1].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0AB0: 4800A6A9  bl 0x821ab158
	ctx.lr = 0x821A0AB4;
	sub_821AB158(ctx, base);
	pc = 0x821A0AB4; continue 'dispatch;
            }
            0x821A0AB4 => {
    //   block [0x821A0AB4..0x821A0AC4)
	// 821A0AB4: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0AB8: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0ABC: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0AC0: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0AC8(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0AC8 size=364
    let mut pc: u32 = 0x821A0AC8;
    'dispatch: loop {
        match pc {
            0x821A0AC8 => {
    //   block [0x821A0AC8..0x821A0B10)
	// 821A0AC8: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0ACC: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0AD0: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A0AD4: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A0AD8: 9421FF50  stwu r1, -0xb0(r1)
	ea = ctx.r[1].u32.wrapping_add(-176 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0ADC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A0AE0: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A0AE4: 7CBE2B78  mr r30, r5
	ctx.r[30].u64 = ctx.r[5].u64;
	// 821A0AE8: 2F060000  cmpwi cr6, r6, 0
	ctx.cr[6].compare_i32(ctx.r[6].s32, 0, &mut ctx.xer);
	// 821A0AEC: F87F0000  std r3, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[3].u64 ) };
	// 821A0AF0: 40980020  bge cr6, 0x821a0b10
	if !ctx.cr[6].lt {
	pc = 0x821A0B10; continue 'dispatch;
	}
	// 821A0AF4: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A0AF8: 616BFAF0  ori r11, r11, 0xfaf0
	ctx.r[11].u64 = ctx.r[11].u64 | 64240;
	// 821A0AFC: 7D64582E  lwzx r11, r4, r11
	ctx.r[11].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A0B00: C00B0010  lfs f0, 0x10(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(16 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A0B04: C1AB0008  lfs f13, 8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0B08: EC006828  fsubs f0, f0, f13
	ctx.f[0].f64 = (((ctx.f[0].f64 - ctx.f[13].f64) as f32) as f64);
	// 821A0B0C: 48000018  b 0x821a0b24
	pc = 0x821A0B24; continue 'dispatch;
            }
            0x821A0B10 => {
    //   block [0x821A0B10..0x821A0B24)
	// 821A0B10: 7CCB07B4  extsw r11, r6
	ctx.r[11].s64 = ctx.r[6].s32 as i64;
	// 821A0B14: F9610090  std r11, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[11].u64 ) };
	// 821A0B18: C8010090  lfd f0, 0x90(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0B1C: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0B20: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	pc = 0x821A0B24; continue 'dispatch;
            }
            0x821A0B24 => {
    //   block [0x821A0B24..0x821A0B3C)
	// 821A0B24: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0B28: C1AB1FF8  lfs f13, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0B2C: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A0B30: 4199000C  bgt cr6, 0x821a0b3c
	if ctx.cr[6].gt {
	pc = 0x821A0B3C; continue 'dispatch;
	}
	// 821A0B34: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A0B38: C00BBA38  lfs f0, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A0B3C; continue 'dispatch;
            }
            0x821A0B3C => {
    //   block [0x821A0B3C..0x821A0B54)
	// 821A0B3C: 2F0800C1  cmpwi cr6, r8, 0xc1
	ctx.cr[6].compare_i32(ctx.r[8].s32, 193, &mut ctx.xer);
	// 821A0B40: 409A0014  bne cr6, 0x821a0b54
	if !ctx.cr[6].eq {
	pc = 0x821A0B54; continue 'dispatch;
	}
	// 821A0B44: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A0B48: 54E9103A  slwi r9, r7, 2
	ctx.r[9].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[9].u64 = ctx.r[9].u32 as u64;
	// 821A0B4C: 396B53C8  addi r11, r11, 0x53c8
	ctx.r[11].s64 = ctx.r[11].s64 + 21448;
	// 821A0B50: 7D09582E  lwzx r8, r9, r11
	ctx.r[8].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[9].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	pc = 0x821A0B54; continue 'dispatch;
            }
            0x821A0B54 => {
    //   block [0x821A0B54..0x821A0B9C)
	// 821A0B54: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821A0B58: 54EB103A  slwi r11, r7, 2
	ctx.r[11].u32 = ctx.r[7].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A0B5C: 38C95300  addi r6, r9, 0x5300
	ctx.r[6].s64 = ctx.r[9].s64 + 21248;
	// 821A0B60: 38A10090  addi r5, r1, 0x90
	ctx.r[5].s64 = ctx.r[1].s64 + 144;
	// 821A0B64: 39260068  addi r9, r6, 0x68
	ctx.r[9].s64 = ctx.r[6].s64 + 104;
	// 821A0B68: 7D2B482E  lwzx r9, r11, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A0B6C: 7D2907B4  extsw r9, r9
	ctx.r[9].s64 = ctx.r[9].s32 as i64;
	// 821A0B70: F9210090  std r9, 0x90(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(144 as u32), ctx.r[9].u64 ) };
	// 821A0B74: C9A10090  lfd f13, 0x90(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) };
	// 821A0B78: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A0B7C: FDA06818  frsp f13, f13
	ctx.f[13].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A0B80: EDAD0072  fmuls f13, f13, f1
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[1].f64) as f32) as f64);
	// 821A0B84: FDA0681E  fctiwz f13, f13
	ctx.f[13].s64 = if ctx.f[13].f64 > (i32::MAX as f64) { i32::MAX as i64 } else { ctx.f[13].f64.trunc() as i32 as i64 };
	// 821A0B88: 7DA02FAE  stfiwx f13, 0, r5
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[5].u32, tmp.u32) };
	// 821A0B8C: 80A10090  lwz r5, 0x90(r1)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A0B90: 2F050004  cmpwi cr6, r5, 4
	ctx.cr[6].compare_i32(ctx.r[5].s32, 4, &mut ctx.xer);
	// 821A0B94: 40980008  bge cr6, 0x821a0b9c
	if !ctx.cr[6].lt {
	pc = 0x821A0B9C; continue 'dispatch;
	}
	// 821A0B98: 38A00004  li r5, 4
	ctx.r[5].s64 = 4;
	pc = 0x821A0B9C; continue 'dispatch;
            }
            0x821A0B9C => {
    //   block [0x821A0B9C..0x821A0BC4)
	// 821A0B9C: 2F070011  cmpwi cr6, r7, 0x11
	ctx.cr[6].compare_i32(ctx.r[7].s32, 17, &mut ctx.xer);
	// 821A0BA0: 409A0024  bne cr6, 0x821a0bc4
	if !ctx.cr[6].eq {
	pc = 0x821A0BC4; continue 'dispatch;
	}
	// 821A0BA4: 3D200001  lis r9, 1
	ctx.r[9].s64 = 65536;
	// 821A0BA8: 6129BEC4  ori r9, r9, 0xbec4
	ctx.r[9].u64 = ctx.r[9].u64 | 48836;
	// 821A0BAC: 7D244A2E  lhzx r9, r4, r9
	ctx.r[9].u64 = unsafe { crate::rt::load_u16(base as *const u8, ctx.r[4].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A0BB0: 2B090000  cmplwi cr6, r9, 0
	ctx.cr[6].compare_u32(ctx.r[9].u32, 0 as u32, &mut ctx.xer);
	// 821A0BB4: 409A0010  bne cr6, 0x821a0bc4
	if !ctx.cr[6].eq {
	pc = 0x821A0BC4; continue 'dispatch;
	}
	// 821A0BB8: 3D20820D  lis r9, -0x7df3
	ctx.r[9].s64 = -2113077248;
	// 821A0BBC: C049BFFC  lfs f2, -0x4004(r9)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[9].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A0BC0: 48000010  b 0x821a0bd0
	pc = 0x821A0BD0; continue 'dispatch;
            }
            0x821A0BC4 => {
    //   block [0x821A0BC4..0x821A0BD0)
	// 821A0BC4: 3D208286  lis r9, -0x7d7a
	ctx.r[9].s64 = -2105147392;
	// 821A0BC8: 39295430  addi r9, r9, 0x5430
	ctx.r[9].s64 = ctx.r[9].s64 + 21552;
	// 821A0BCC: 7C4B4C2E  lfsx f2, r11, r9
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	pc = 0x821A0BD0; continue 'dispatch;
            }
            0x821A0BD0 => {
    //   block [0x821A0BD0..0x821A0C34)
	// 821A0BD0: 38E00400  li r7, 0x400
	ctx.r[7].s64 = 1024;
	// 821A0BD4: 91410064  stw r10, 0x64(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(100 as u32), ctx.r[10].u32 ) };
	// 821A0BD8: 9061008C  stw r3, 0x8c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821A0BDC: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A0BE0: 9061007C  stw r3, 0x7c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(124 as u32), ctx.r[3].u32 ) };
	// 821A0BE4: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0BE8: 90610074  stw r3, 0x74(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(116 as u32), ctx.r[3].u32 ) };
	// 821A0BEC: 38610090  addi r3, r1, 0x90
	ctx.r[3].s64 = ctx.r[1].s64 + 144;
	// 821A0BF0: 90810054  stw r4, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[4].u32 ) };
	// 821A0BF4: FC200090  fmr f1, f0
	ctx.f[1].f64 = ctx.f[0].f64;
	// 821A0BF8: 90E10084  stw r7, 0x84(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(132 as u32), ctx.r[7].u32 ) };
	// 821A0BFC: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0C00: 7C8B302E  lwzx r4, r11, r6
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[6].u32)) } as u64;
	// 821A0C04: 93C1005C  stw r30, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[30].u32 ) };
	// 821A0C08: 4800A551  bl 0x821ab158
	ctx.lr = 0x821A0C0C;
	sub_821AB158(ctx, base);
	// 821A0C0C: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0C10: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0C14: E96B0000  ld r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	// 821A0C18: F97F0000  std r11, 0(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u64 ) };
	// 821A0C1C: 382100B0  addi r1, r1, 0xb0
	ctx.r[1].s64 = ctx.r[1].s64 + 176;
	// 821A0C20: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A0C24: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A0C28: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A0C2C: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0C30: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0C38(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0C38 size=376
    let mut pc: u32 = 0x821A0C38;
    'dispatch: loop {
        match pc {
            0x821A0C38 => {
    //   block [0x821A0C38..0x821A0DB0)
	// 821A0C38: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0C3C: 4839447D  bl 0x825350b8
	ctx.lr = 0x821A0C40;
	sub_82535080(ctx, base);
	// 821A0C40: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0C44: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A0C48: 7CBF2B78  mr r31, r5
	ctx.r[31].u64 = ctx.r[5].u64;
	// 821A0C4C: 7CDD3378  mr r29, r6
	ctx.r[29].u64 = ctx.r[6].u64;
	// 821A0C50: 7CFC3B78  mr r28, r7
	ctx.r[28].u64 = ctx.r[7].u64;
	// 821A0C54: 481C64E5  bl 0x82367138
	ctx.lr = 0x821A0C58;
	sub_82367138(ctx, base);
	// 821A0C58: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0C5C: C1BE0010  lfs f13, 0x10(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(16 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0C60: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A0C64: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0C68: C16B2280  lfs f11, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A0C6C: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0C70: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0C74: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0C78: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0C7C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0C80: D01F0000  stfs f0, 0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), tmp.u32 ) };
	// 821A0C84: 481C64B5  bl 0x82367138
	ctx.lr = 0x821A0C88;
	sub_82367138(ctx, base);
	// 821A0C88: 786B0260  clrldi r11, r3, 0x29
	ctx.r[11].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0C8C: C1BE0014  lfs f13, 0x14(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(20 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0C90: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A0C94: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0C98: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0C9C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0CA0: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0CA4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0CA8: D01F0004  stfs f0, 4(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(4 as u32), tmp.u32 ) };
	// 821A0CAC: 481C648D  bl 0x82367138
	ctx.lr = 0x821A0CB0;
	sub_82367138(ctx, base);
	// 821A0CB0: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A0CB4: 39200020  li r9, 0x20
	ctx.r[9].s64 = 32;
	// 821A0CB8: C1BE0018  lfs f13, 0x18(r30)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[30].u32.wrapping_add(24 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A0CBC: 817F000C  lwz r11, 0xc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A0CC0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A0CC4: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A0CC8: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A0CCC: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A0CD0: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A0CD4: EC0002F2  fmuls f0, f0, f11
	ctx.f[0].f64 = (((ctx.f[0].f64 * ctx.f[11].f64) as f32) as f64);
	// 821A0CD8: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A0CDC: D01F0008  stfs f0, 8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(8 as u32), tmp.u32 ) };
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0DB0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0DB0 size=340
    let mut pc: u32 = 0x821A0DB0;
    'dispatch: loop {
        match pc {
            0x821A0DB0 => {
    //   block [0x821A0DB0..0x821A0DFC)
	// 821A0DB0: FBC1FFF0  std r30, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[30].u64 ) };
	// 821A0DB4: FBE1FFF8  std r31, -8(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[31].u64 ) };
	// 821A0DB8: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A0DBC: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A0DC0: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A0DC4: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A0DC8: 812B0084  lwz r9, 0x84(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0DCC: 7F095000  cmpw cr6, r9, r10
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[10].s32, &mut ctx.xer);
	// 821A0DD0: 419A0124  beq cr6, 0x821a0ef4
	if ctx.cr[6].eq {
	pc = 0x821A0EF4; continue 'dispatch;
	}
	// 821A0DD4: 812B008C  lwz r9, 0x8c(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0DD8: 3BC0FFFF  li r30, -1
	ctx.r[30].s64 = -1;
	// 821A0DDC: 7D095214  add r8, r9, r10
	ctx.r[8].u64 = ctx.r[9].u64 + ctx.r[10].u64;
	// 821A0DE0: 81280004  lwz r9, 4(r8)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[8].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0DE4: 90E80008  stw r7, 8(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(8 as u32), ctx.r[7].u32 ) };
	// 821A0DE8: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0DEC: 419A0010  beq cr6, 0x821a0dfc
	if ctx.cr[6].eq {
	pc = 0x821A0DFC; continue 'dispatch;
	}
	// 821A0DF0: 80EB008C  lwz r7, 0x8c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0DF4: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	// 821A0DF8: 7FC7492E  stwx r30, r7, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[7].u32.wrapping_add(ctx.r[9].u32), ctx.r[30].u32) };
	pc = 0x821A0DFC; continue 'dispatch;
            }
            0x821A0DFC => {
    //   block [0x821A0DFC..0x821A0E30)
	// 821A0DFC: 83EB0084  lwz r31, 0x84(r11)
	ctx.r[31].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0E00: 2F1FFFFF  cmpwi cr6, r31, -1
	ctx.cr[6].compare_i32(ctx.r[31].s32, -1, &mut ctx.xer);
	// 821A0E04: 409A0040  bne cr6, 0x821a0e44
	if !ctx.cr[6].eq {
	pc = 0x821A0E44; continue 'dispatch;
	}
	// 821A0E08: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E0C: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	// 821A0E10: 419A0020  beq cr6, 0x821a0e30
	if ctx.cr[6].eq {
	pc = 0x821A0E30; continue 'dispatch;
	}
	// 821A0E14: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A0E18: 80EB008C  lwz r7, 0x8c(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0E1C: 93C80004  stw r30, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A0E20: 7CE74A14  add r7, r7, r9
	ctx.r[7].u64 = ctx.r[7].u64 + ctx.r[9].u64;
	// 821A0E24: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821A0E28: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A0E2C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	pc = 0x821A0E30; continue 'dispatch;
            }
            0x821A0E30 => {
    //   block [0x821A0E30..0x821A0E44)
	// 821A0E30: 38600001  li r3, 1
	ctx.r[3].s64 = 1;
	// 821A0E34: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0E38: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0E3C: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0E40: 4E800020  blr
	return;
            }
            0x821A0E44 => {
    //   block [0x821A0E44..0x821A0E4C)
	// 821A0E44: 80AB008C  lwz r5, 0x8c(r11)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0E48: 7FE9FB78  mr r9, r31
	ctx.r[9].u64 = ctx.r[31].u64;
	pc = 0x821A0E4C; continue 'dispatch;
            }
            0x821A0E4C => {
    //   block [0x821A0E4C..0x821A0E6C)
	// 821A0E4C: 7CC54A14  add r6, r5, r9
	ctx.r[6].u64 = ctx.r[5].u64 + ctx.r[9].u64;
	// 821A0E50: 80E60008  lwz r7, 8(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A0E54: 2F070000  cmpwi cr6, r7, 0
	ctx.cr[6].compare_i32(ctx.r[7].s32, 0, &mut ctx.xer);
	// 821A0E58: 40980014  bge cr6, 0x821a0e6c
	if !ctx.cr[6].lt {
	pc = 0x821A0E6C; continue 'dispatch;
	}
	// 821A0E5C: 81260004  lwz r9, 4(r6)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0E60: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E64: 409AFFE8  bne cr6, 0x821a0e4c
	if !ctx.cr[6].eq {
	pc = 0x821A0E4C; continue 'dispatch;
	}
	// 821A0E68: 4800000C  b 0x821a0e74
	pc = 0x821A0E74; continue 'dispatch;
            }
            0x821A0E6C => {
    //   block [0x821A0E6C..0x821A0E74)
	// 821A0E6C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0E70: 409A002C  bne cr6, 0x821a0e9c
	if !ctx.cr[6].eq {
	pc = 0x821A0E9C; continue 'dispatch;
	}
	pc = 0x821A0E74; continue 'dispatch;
            }
            0x821A0E74 => {
    //   block [0x821A0E74..0x821A0E9C)
	// 821A0E74: 812B0088  lwz r9, 0x88(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A0E78: 93C80004  stw r30, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[30].u32 ) };
	// 821A0E7C: 7CE54A14  add r7, r5, r9
	ctx.r[7].u64 = ctx.r[5].u64 + ctx.r[9].u64;
	// 821A0E80: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0E84: 91280000  stw r9, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[9].u32 ) };
	// 821A0E88: 914B0088  stw r10, 0x88(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(136 as u32), ctx.r[10].u32 ) };
	// 821A0E8C: 91470004  stw r10, 4(r7)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[7].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0E90: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0E94: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0E98: 4E800020  blr
	return;
            }
            0x821A0E9C => {
    //   block [0x821A0E9C..0x821A0EA8)
	// 821A0E9C: 7F09F800  cmpw cr6, r9, r31
	ctx.cr[6].compare_i32(ctx.r[9].s32, ctx.r[31].s32, &mut ctx.xer);
	// 821A0EA0: 409A0008  bne cr6, 0x821a0ea8
	if !ctx.cr[6].eq {
	pc = 0x821A0EA8; continue 'dispatch;
	}
	// 821A0EA4: 914B0084  stw r10, 0x84(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(132 as u32), ctx.r[10].u32 ) };
	pc = 0x821A0EA8; continue 'dispatch;
            }
            0x821A0EA8 => {
    //   block [0x821A0EA8..0x821A0EDC)
	// 821A0EA8: 80E60000  lwz r7, 0(r6)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[6].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0EAC: 91280004  stw r9, 4(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821A0EB0: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 821A0EB4: 90E80000  stw r7, 0(r8)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[8].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0EB8: 419A0024  beq cr6, 0x821a0edc
	if ctx.cr[6].eq {
	pc = 0x821A0EDC; continue 'dispatch;
	}
	// 821A0EBC: 816B008C  lwz r11, 0x8c(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0EC0: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0EC4: 7D6B3A14  add r11, r11, r7
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[7].u64;
	// 821A0EC8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0ECC: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A0ED0: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0ED4: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0ED8: 4E800020  blr
	return;
            }
            0x821A0EDC => {
    //   block [0x821A0EDC..0x821A0EF4)
	// 821A0EDC: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	// 821A0EE0: 91460000  stw r10, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A0EE4: 91040000  stw r8, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A0EE8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0EEC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0EF0: 4E800020  blr
	return;
            }
            0x821A0EF4 => {
    //   block [0x821A0EF4..0x821A0F04)
	// 821A0EF4: 90E40000  stw r7, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0EF8: EBC1FFF0  ld r30, -0x10(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A0EFC: EBE1FFF8  ld r31, -8(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) };
	// 821A0F00: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F08(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F08 size=124
    let mut pc: u32 = 0x821A0F08;
    'dispatch: loop {
        match pc {
            0x821A0F08 => {
    //   block [0x821A0F08..0x821A0F2C)
	// 821A0F08: 81640000  lwz r11, 0(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0F0C: 8143008C  lwz r10, 0x8c(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0F10: 7D0A5850  subf r8, r10, r11
	ctx.r[8].s64 = ctx.r[11].s64 - ctx.r[10].s64;
	// 821A0F14: 812B0004  lwz r9, 4(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A0F18: 80EB0000  lwz r7, 0(r11)
	ctx.r[7].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A0F1C: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0F20: 7CCA4A14  add r6, r10, r9
	ctx.r[6].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A0F24: 409A0008  bne cr6, 0x821a0f2c
	if !ctx.cr[6].eq {
	pc = 0x821A0F2C; continue 'dispatch;
	}
	// 821A0F28: 38C00000  li r6, 0
	ctx.r[6].s64 = 0;
	pc = 0x821A0F2C; continue 'dispatch;
            }
            0x821A0F2C => {
    //   block [0x821A0F2C..0x821A0F48)
	// 821A0F2C: 2F07FFFF  cmpwi cr6, r7, -1
	ctx.cr[6].compare_i32(ctx.r[7].s32, -1, &mut ctx.xer);
	// 821A0F30: 419A0054  beq cr6, 0x821a0f84
	if ctx.cr[6].eq {
		crate::recompiler::externs::call(ctx, base, 0x821A0F84);
		return;
	}
	// 821A0F34: 80A30084  lwz r5, 0x84(r3)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A0F38: 7D4A3A14  add r10, r10, r7
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[7].u64;
	// 821A0F3C: 7F082800  cmpw cr6, r8, r5
	ctx.cr[6].compare_i32(ctx.r[8].s32, ctx.r[5].s32, &mut ctx.xer);
	// 821A0F40: 409A0008  bne cr6, 0x821a0f48
	if !ctx.cr[6].eq {
	pc = 0x821A0F48; continue 'dispatch;
	}
	// 821A0F44: 91230084  stw r9, 0x84(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(132 as u32), ctx.r[9].u32 ) };
	pc = 0x821A0F48; continue 'dispatch;
            }
            0x821A0F48 => {
    //   block [0x821A0F48..0x821A0F5C)
	// 821A0F48: 2F09FFFF  cmpwi cr6, r9, -1
	ctx.cr[6].compare_i32(ctx.r[9].s32, -1, &mut ctx.xer);
	// 821A0F4C: 912A0004  stw r9, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[9].u32 ) };
	// 821A0F50: 409A000C  bne cr6, 0x821a0f5c
	if !ctx.cr[6].eq {
	pc = 0x821A0F5C; continue 'dispatch;
	}
	// 821A0F54: 90E30088  stw r7, 0x88(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(136 as u32), ctx.r[7].u32 ) };
	// 821A0F58: 48000008  b 0x821a0f60
	pc = 0x821A0F60; continue 'dispatch;
            }
            0x821A0F5C => {
    //   block [0x821A0F5C..0x821A0F60)
	// 821A0F5C: 90E60000  stw r7, 0(r6)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[6].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	pc = 0x821A0F60; continue 'dispatch;
            }
            0x821A0F60 => {
    //   block [0x821A0F60..0x821A0F84)
	// 821A0F60: 81430080  lwz r10, 0x80(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A0F64: 38E0FFFF  li r7, -1
	ctx.r[7].s64 = -1;
	// 821A0F68: 8123008C  lwz r9, 0x8c(r3)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A0F6C: 91030080  stw r8, 0x80(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(128 as u32), ctx.r[8].u32 ) };
	// 821A0F70: 90C40000  stw r6, 0(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(0 as u32), ctx.r[6].u32 ) };
	// 821A0F74: 90EB0000  stw r7, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[7].u32 ) };
	// 821A0F78: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A0F7C: 7D09512E  stwx r8, r9, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[9].u32.wrapping_add(ctx.r[10].u32), ctx.r[8].u32) };
	// 821A0F80: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0F90(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A0F90 size=44
    let mut pc: u32 = 0x821A0F90;
    'dispatch: loop {
        match pc {
            0x821A0F90 => {
    //   block [0x821A0F90..0x821A0FBC)
	// 821A0F90: 89430020  lbz r10, 0x20(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[3].u32.wrapping_add(32 as u32) ) } as u64;
	// 821A0F94: 39600000  li r11, 0
	ctx.r[11].s64 = 0;
	// 821A0F98: 91630018  stw r11, 0x18(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(24 as u32), ctx.r[11].u32 ) };
	// 821A0F9C: 9163000C  stw r11, 0xc(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(12 as u32), ctx.r[11].u32 ) };
	// 821A0FA0: 99630026  stb r11, 0x26(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(38 as u32), ctx.r[11].u8 ) };
	// 821A0FA4: F9630010  std r11, 0x10(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(16 as u32), ctx.r[11].u64 ) };
	// 821A0FA8: F9630040  std r11, 0x40(r3)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[3].u32.wrapping_add(64 as u32), ctx.r[11].u64 ) };
	// 821A0FAC: 9163001C  stw r11, 0x1c(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(28 as u32), ctx.r[11].u32 ) };
	// 821A0FB0: 714A00DF  andi. r10, r10, 0xdf
	ctx.r[10].u64 = ctx.r[10].u64 & 223;
	ctx.cr[0].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A0FB4: 99430020  stb r10, 0x20(r3)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[3].u32.wrapping_add(32 as u32), ctx.r[10].u8 ) };
	// 821A0FB8: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A0FC0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A0FC0 size=172
    let mut pc: u32 = 0x821A0FC0;
    'dispatch: loop {
        match pc {
            0x821A0FC0 => {
    //   block [0x821A0FC0..0x821A106C)
	// 821A0FC0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A0FC4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A0FC8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A0FCC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A0FD0: DBE1FFE0  stfd f31, -0x20(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-32 as u32), ctx.f[31].u64 ) };
	// 821A0FD4: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A0FD8: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A0FDC: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A0FE0: 396BC918  addi r11, r11, -0x36e8
	ctx.r[11].s64 = ctx.r[11].s64 + -14056;
	// 821A0FE4: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A0FE8: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 821A0FEC: 394A0D0C  addi r10, r10, 0xd0c
	ctx.r[10].s64 = ctx.r[10].s64 + 3340;
	// 821A0FF0: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A0FF4: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A0FF8: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A0FFC: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1000: F93F0010  std r9, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 821A1004: F93F0040  std r9, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821A1008: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A100C: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1010: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A1014: 4E800421  bctrl
	ctx.lr = 0x821A1018;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A1018: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A101C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A1020: 392000B0  li r9, 0xb0
	ctx.r[9].s64 = 176;
	// 821A1024: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A1028: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A102C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1030: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1034: 995F001C  stb r10, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[10].u8 ) };
	// 821A1038: B13F0024  sth r9, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[9].u16 ) };
	// 821A103C: C02B1FF8  lfs f1, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A1040: 481E1A49  bl 0x82382a88
	ctx.lr = 0x821A1044;
	sub_82382A88(ctx, base);
	// 821A1044: D3FF007C  stfs f31, 0x7c(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A1048: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A104C: D3FF008C  stfs f31, 0x8c(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), tmp.u32 ) };
	// 821A1050: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1054: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1058: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A105C: CBE1FFE0  lfd f31, -0x20(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-32 as u32) ) };
	// 821A1060: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A1064: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1068: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1070(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A1070 size=128
    let mut pc: u32 = 0x821A1070;
    'dispatch: loop {
        match pc {
            0x821A1070 => {
    //   block [0x821A1070..0x821A10F0)
	// 821A1070: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1074: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A1078: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A107C: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A1080: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A1084: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1088: 7C7E1B78  mr r30, r3
	ctx.r[30].u64 = ctx.r[3].u64;
	// 821A108C: 396BC918  addi r11, r11, -0x36e8
	ctx.r[11].s64 = ctx.r[11].s64 + -14056;
	// 821A1090: 3D40820C  lis r10, -0x7df4
	ctx.r[10].s64 = -2113142784;
	// 821A1094: 3BFE0080  addi r31, r30, 0x80
	ctx.r[31].s64 = ctx.r[30].s64 + 128;
	// 821A1098: 394A0D18  addi r10, r10, 0xd18
	ctx.r[10].s64 = ctx.r[10].s64 + 3352;
	// 821A109C: 39200000  li r9, 0
	ctx.r[9].s64 = 0;
	// 821A10A0: 917E0000  stw r11, 0(r30)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A10A4: 554B003E  slwi r11, r10, 0
	ctx.r[11].u32 = ctx.r[10].u32.wrapping_shl(0);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A10A8: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A10AC: F93F0010  std r9, 0x10(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(16 as u32), ctx.r[9].u64 ) };
	// 821A10B0: F93F0040  std r9, 0x40(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(64 as u32), ctx.r[9].u64 ) };
	// 821A10B4: 816B0000  lwz r11, 0(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A10B8: 915F0000  stw r10, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A10BC: 7D6903A6  mtctr r11
	ctx.ctr.u64 = ctx.r[11].u64;
	// 821A10C0: 4E800421  bctrl
	ctx.lr = 0x821A10C4;
	crate::rt::call_indirect(ctx.ctr.u32);
	// 821A10C4: 39600007  li r11, 7
	ctx.r[11].s64 = 7;
	// 821A10C8: 394000A0  li r10, 0xa0
	ctx.r[10].s64 = 160;
	// 821A10CC: 7FC3F378  mr r3, r30
	ctx.r[3].u64 = ctx.r[30].u64;
	// 821A10D0: 997F001C  stb r11, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[11].u8 ) };
	// 821A10D4: B15F0024  sth r10, 0x24(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(36 as u32), ctx.r[10].u16 ) };
	// 821A10D8: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A10DC: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A10E0: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A10E4: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A10E8: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A10EC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A10F0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A10F0 size=328
    let mut pc: u32 = 0x821A10F0;
    'dispatch: loop {
        match pc {
            0x821A10F0 => {
    //   block [0x821A10F0..0x821A1154)
	// 821A10F0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A10F4: 48393FBD  bl 0x825350b0
	ctx.lr = 0x821A10F8;
	sub_82535080(ctx, base);
	// 821A10F8: 9421FF40  stwu r1, -0xc0(r1)
	ea = ctx.r[1].u32.wrapping_add(-192 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A10FC: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A1100: 7C9E0734  extsh r30, r4
	ctx.r[30].s64 = ctx.r[4].s16 as i64;
	// 821A1104: 7CBC2B78  mr r28, r5
	ctx.r[28].u64 = ctx.r[5].u64;
	// 821A1108: 7CDB3378  mr r27, r6
	ctx.r[27].u64 = ctx.r[6].u64;
	// 821A110C: 7FE6FB78  mr r6, r31
	ctx.r[6].u64 = ctx.r[31].u64;
	// 821A1110: 38810070  addi r4, r1, 0x70
	ctx.r[4].s64 = ctx.r[1].s64 + 112;
	// 821A1114: 38610068  addi r3, r1, 0x68
	ctx.r[3].s64 = ctx.r[1].s64 + 104;
	// 821A1118: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	// 821A111C: 7CFA3B78  mr r26, r7
	ctx.r[26].u64 = ctx.r[7].u64;
	// 821A1120: 3BA10070  addi r29, r1, 0x70
	ctx.r[29].s64 = ctx.r[1].s64 + 112;
	// 821A1124: 48010165  bl 0x821b1288
	ctx.lr = 0x821A1128;
	sub_821B1288(ctx, base);
	// 821A1128: E9630000  ld r11, 0(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[3].u32.wrapping_add(0 as u32) ) };
	// 821A112C: 38E00000  li r7, 0
	ctx.r[7].s64 = 0;
	// 821A1130: F9610060  std r11, 0x60(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(96 as u32), ctx.r[11].u64 ) };
	// 821A1134: 81610064  lwz r11, 0x64(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(100 as u32) ) } as u64;
	// 821A1138: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A113C: 419A0018  beq cr6, 0x821a1154
	if ctx.cr[6].eq {
	pc = 0x821A1154; continue 'dispatch;
	}
	// 821A1140: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1144: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1148: 81210060  lwz r9, 0x60(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(96 as u32) ) } as u64;
	// 821A114C: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1150: 419A0008  beq cr6, 0x821a1158
	if ctx.cr[6].eq {
	pc = 0x821A1158; continue 'dispatch;
	}
	pc = 0x821A1154; continue 'dispatch;
            }
            0x821A1154 => {
    //   block [0x821A1154..0x821A1158)
	// 821A1154: 7CEB3B78  mr r11, r7
	ctx.r[11].u64 = ctx.r[7].u64;
	pc = 0x821A1158; continue 'dispatch;
            }
            0x821A1158 => {
    //   block [0x821A1158..0x821A1174)
	// 821A1158: 2F1E005A  cmpwi cr6, r30, 0x5a
	ctx.cr[6].compare_i32(ctx.r[30].s32, 90, &mut ctx.xer);
	// 821A115C: 409A001C  bne cr6, 0x821a1178
	if !ctx.cr[6].eq {
	pc = 0x821A1178; continue 'dispatch;
	}
	// 821A1160: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1164: 409A0010  bne cr6, 0x821a1174
	if !ctx.cr[6].eq {
	pc = 0x821A1174; continue 'dispatch;
	}
	// 821A1168: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A116C: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1170: 48393F90  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1174 => {
    //   block [0x821A1174..0x821A1178)
	// 821A1174: 7CFD3B78  mr r29, r7
	ctx.r[29].u64 = ctx.r[7].u64;
	pc = 0x821A1178; continue 'dispatch;
            }
            0x821A1178 => {
    //   block [0x821A1178..0x821A11EC)
	// 821A1178: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A117C: 90E1005C  stw r7, 0x5c(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(92 as u32), ctx.r[7].u32 ) };
	// 821A1180: 7F5E0734  extsh r30, r26
	ctx.r[30].s64 = ctx.r[26].s16 as i64;
	// 821A1184: 90E10054  stw r7, 0x54(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(84 as u32), ctx.r[7].u32 ) };
	// 821A1188: 39400000  li r10, 0
	ctx.r[10].s64 = 0;
	// 821A118C: 39200001  li r9, 1
	ctx.r[9].s64 = 1;
	// 821A1190: 7FE8FB78  mr r8, r31
	ctx.r[8].u64 = ctx.r[31].u64;
	// 821A1194: 7F660734  extsh r6, r27
	ctx.r[6].s64 = ctx.r[27].s16 as i64;
	// 821A1198: C02BBA38  lfs f1, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A119C: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A11A0: 7FA3EB78  mr r3, r29
	ctx.r[3].u64 = ctx.r[29].u64;
	// 821A11A4: 7FC7F378  mr r7, r30
	ctx.r[7].u64 = ctx.r[30].u64;
	// 821A11A8: 48000109  bl 0x821a12b0
	ctx.lr = 0x821A11AC;
	sub_821A12B0(ctx, base);
	// 821A11AC: 7C671B78  mr r7, r3
	ctx.r[7].u64 = ctx.r[3].u64;
	// 821A11B0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A11B4: 419A0078  beq cr6, 0x821a122c
	if ctx.cr[6].eq {
	pc = 0x821A122C; continue 'dispatch;
	}
	// 821A11B8: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A11BC: 3D1F0002  addis r8, r31, 2
	ctx.r[8].s64 = ctx.r[31].s64 + 131072;
	// 821A11C0: 2F1E0002  cmpwi cr6, r30, 2
	ctx.cr[6].compare_i32(ctx.r[30].s32, 2, &mut ctx.xer);
	// 821A11C4: 392B1410  addi r9, r11, 0x1410
	ctx.r[9].s64 = ctx.r[11].s64 + 5136;
	// 821A11C8: 3908BE64  addi r8, r8, -0x419c
	ctx.r[8].s64 = ctx.r[8].s64 + -16796;
	// 821A11CC: 419A003C  beq cr6, 0x821a1208
	if ctx.cr[6].eq {
	pc = 0x821A1208; continue 'dispatch;
	}
	// 821A11D0: 89480000  lbz r10, 0(r8)
	ctx.r[10].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11D4: 39690080  addi r11, r9, 0x80
	ctx.r[11].s64 = ctx.r[9].s64 + 128;
	// 821A11D8: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821A11DC: 7C6A582E  lwzx r3, r10, r11
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) } as u64;
	// 821A11E0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A11E4: 419A0008  beq cr6, 0x821a11ec
	if ctx.cr[6].eq {
	pc = 0x821A11EC; continue 'dispatch;
	}
	// 821A11E8: 48000051  bl 0x821a1238
	ctx.lr = 0x821A11EC;
	sub_821A1238(ctx, base);
	pc = 0x821A11EC; continue 'dispatch;
            }
            0x821A11EC => {
    //   block [0x821A11EC..0x821A1208)
	// 821A11EC: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A11F0: 39490080  addi r10, r9, 0x80
	ctx.r[10].s64 = ctx.r[9].s64 + 128;
	// 821A11F4: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A11F8: 556B103E  rotlwi r11, r11, 2
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(2)) as u64;
	// 821A11FC: 7CEB512E  stwx r7, r11, r10
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32), ctx.r[7].u32) };
	// 821A1200: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1204: 48393EFC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1208 => {
    //   block [0x821A1208..0x821A1220)
	// 821A1208: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A120C: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 821A1210: 7C6B482E  lwzx r3, r11, r9
	ctx.r[3].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A1214: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1218: 419A0008  beq cr6, 0x821a1220
	if ctx.cr[6].eq {
	pc = 0x821A1220; continue 'dispatch;
	}
	// 821A121C: 4800001D  bl 0x821a1238
	ctx.lr = 0x821A1220;
	sub_821A1238(ctx, base);
	pc = 0x821A1220; continue 'dispatch;
            }
            0x821A1220 => {
    //   block [0x821A1220..0x821A122C)
	// 821A1220: 89680000  lbz r11, 0(r8)
	ctx.r[11].u64 = unsafe { crate::rt::load_u8( base as *const u8, ctx.r[8].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1224: 556B283E  rotlwi r11, r11, 5
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(5)) as u64;
	// 821A1228: 7CEB492E  stwx r7, r11, r9
	unsafe { crate::rt::store_u32(base as *mut u8, ctx.r[11].u32.wrapping_add(ctx.r[9].u32), ctx.r[7].u32) };
	pc = 0x821A122C; continue 'dispatch;
            }
            0x821A122C => {
    //   block [0x821A122C..0x821A1238)
	// 821A122C: 7CE33B78  mr r3, r7
	ctx.r[3].u64 = ctx.r[7].u64;
	// 821A1230: 382100C0  addi r1, r1, 0xc0
	ctx.r[1].s64 = ctx.r[1].s64 + 192;
	// 821A1234: 48393ECC  b 0x82535100
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1238(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1238 size=40
    let mut pc: u32 = 0x821A1238;
    'dispatch: loop {
        match pc {
            0x821A1238 => {
    //   block [0x821A1238..0x821A1260)
	// 821A1238: 81630094  lwz r11, 0x94(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A123C: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1240: 40980030  bge cr6, 0x821a1270
	if !ctx.cr[6].lt {
		sub_821A1270(ctx, base);
		return;
	}
	// 821A1244: 81630090  lwz r11, 0x90(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1248: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A124C: 419A0014  beq cr6, 0x821a1260
	if ctx.cr[6].eq {
		sub_821A1260(ctx, base);
		return;
	}
	// 821A1250: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1254: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1258: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A125C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1260(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1260 size=16
    let mut pc: u32 = 0x821A1260;
    'dispatch: loop {
        match pc {
            0x821A1260 => {
    //   block [0x821A1260..0x821A1270)
	// 821A1260: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1264: C00BD6D0  lfs f0, -0x2930(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1268: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A126C: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1270(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    // ---- function 0x821A1270 size=64
    let mut pc: u32 = 0x821A1270;
    'dispatch: loop {
        match pc {
            0x821A1270 => {
    //   block [0x821A1270..0x821A1290)
	// 821A1270: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	// 821A1274: 81430090  lwz r10, 0x90(r3)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1278: 2F0A0002  cmpwi cr6, r10, 2
	ctx.cr[6].compare_i32(ctx.r[10].s32, 2, &mut ctx.xer);
	// 821A127C: 91630094  stw r11, 0x94(r3)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(148 as u32), ctx.r[11].u32 ) };
	// 821A1280: 419A0010  beq cr6, 0x821a1290
	if ctx.cr[6].eq {
	pc = 0x821A1290; continue 'dispatch;
	}
	// 821A1284: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1288: C00B1FF8  lfs f0, 0x1ff8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A128C: 4800000C  b 0x821a1298
	pc = 0x821A1298; continue 'dispatch;
            }
            0x821A1290 => {
    //   block [0x821A1290..0x821A1298)
	// 821A1290: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1294: C00BD6D0  lfs f0, -0x2930(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10544 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A1298; continue 'dispatch;
            }
            0x821A1298 => {
    //   block [0x821A1298..0x821A12B0)
	// 821A1298: C1A300AC  lfs f13, 0xac(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A129C: C18300B0  lfs f12, 0xb0(r3)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(176 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A12A0: EDAD6024  fdivs f13, f13, f12
	ctx.f[13].f64 = ((ctx.f[13].f64 / ctx.f[12].f64) as f32) as f64;
	// 821A12A4: D00300A8  stfs f0, 0xa8(r3)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A12A8: D1A300A4  stfs f13, 0xa4(r3)
	tmp.f32 = (ctx.f[13].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A12AC: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A12B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A12B0 size=1116
    let mut pc: u32 = 0x821A12B0;
    'dispatch: loop {
        match pc {
            0x821A12B0 => {
    //   block [0x821A12B0..0x821A130C)
	// 821A12B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A12B4: 48393DE1  bl 0x82535094
	ctx.lr = 0x821A12B8;
	sub_82535080(ctx, base);
	// 821A12B8: DBC1FF80  stfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-128 as u32), ctx.f[30].u64 ) };
	// 821A12BC: DBE1FF88  stfd f31, -0x78(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-120 as u32), ctx.f[31].u64 ) };
	// 821A12C0: 9421FF20  stwu r1, -0xe0(r1)
	ea = ctx.r[1].u32.wrapping_add(-224 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A12C4: 3D608286  lis r11, -0x7d7a
	ctx.r[11].s64 = -2105147392;
	// 821A12C8: D0210104  stfs f1, 0x104(r1)
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(260 as u32), tmp.u32 ) };
	// 821A12CC: 7CF63B78  mr r22, r7
	ctx.r[22].u64 = ctx.r[7].u64;
	// 821A12D0: 3B0B052C  addi r24, r11, 0x52c
	ctx.r[24].s64 = ctx.r[11].s64 + 1324;
	// 821A12D4: 56CA103A  slwi r10, r22, 2
	ctx.r[10].u32 = ctx.r[22].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A12D8: 397847A4  addi r11, r24, 0x47a4
	ctx.r[11].s64 = ctx.r[24].s64 + 18340;
	// 821A12DC: 7C741B78  mr r20, r3
	ctx.r[20].u64 = ctx.r[3].u64;
	// 821A12E0: 7C9D2378  mr r29, r4
	ctx.r[29].u64 = ctx.r[4].u64;
	// 821A12E4: 7CDA3378  mr r26, r6
	ctx.r[26].u64 = ctx.r[6].u64;
	// 821A12E8: 7D134378  mr r19, r8
	ctx.r[19].u64 = ctx.r[8].u64;
	// 821A12EC: 7FCA5C2E  lfsx f30, r10, r11
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[11].u32)) };
	ctx.f[30].f64 = (tmp.f32 as f64);
	// 821A12F0: 7D374B78  mr r23, r9
	ctx.r[23].u64 = ctx.r[9].u64;
	// 821A12F4: 2F160006  cmpwi cr6, r22, 6
	ctx.cr[6].compare_i32(ctx.r[22].s32, 6, &mut ctx.xer);
	// 821A12F8: 3BC00001  li r30, 1
	ctx.r[30].s64 = 1;
	// 821A12FC: 3B800000  li r28, 0
	ctx.r[28].s64 = 0;
	// 821A1300: 409A000C  bne cr6, 0x821a130c
	if !ctx.cr[6].eq {
	pc = 0x821A130C; continue 'dispatch;
	}
	// 821A1304: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	// 821A1308: 4800009C  b 0x821a13a4
	pc = 0x821A13A4; continue 'dispatch;
            }
            0x821A130C => {
    //   block [0x821A130C..0x821A1348)
	// 821A130C: 2B140000  cmplwi cr6, r20, 0
	ctx.cr[6].compare_u32(ctx.r[20].u32, 0 as u32, &mut ctx.xer);
	// 821A1310: 409A007C  bne cr6, 0x821a138c
	if !ctx.cr[6].eq {
	pc = 0x821A138C; continue 'dispatch;
	}
	// 821A1314: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A1318: 394BC448  addi r10, r11, -0x3bb8
	ctx.r[10].s64 = ctx.r[11].s64 + -15288;
	// 821A131C: 816A0004  lwz r11, 4(r10)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A1320: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1324: 419A0030  beq cr6, 0x821a1354
	if ctx.cr[6].eq {
	pc = 0x821A1354; continue 'dispatch;
	}
	// 821A1328: 810B0030  lwz r8, 0x30(r11)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A132C: 812A0000  lwz r9, 0(r10)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1330: 7F084840  cmplw cr6, r8, r9
	ctx.cr[6].compare_u32(ctx.r[8].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1334: 409A0020  bne cr6, 0x821a1354
	if !ctx.cr[6].eq {
	pc = 0x821A1354; continue 'dispatch;
	}
	// 821A1338: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A133C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1340: 409A0008  bne cr6, 0x821a1348
	if !ctx.cr[6].eq {
	pc = 0x821A1348; continue 'dispatch;
	}
	// 821A1344: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A1348; continue 'dispatch;
            }
            0x821A1348 => {
    //   block [0x821A1348..0x821A1354)
	// 821A1348: 812B0080  lwz r9, 0x80(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A134C: 39290001  addi r9, r9, 1
	ctx.r[9].s64 = ctx.r[9].s64 + 1;
	// 821A1350: 912B0080  stw r9, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[9].u32 ) };
	pc = 0x821A1354; continue 'dispatch;
            }
            0x821A1354 => {
    //   block [0x821A1354..0x821A138C)
	// 821A1354: EB6A0000  ld r27, 0(r10)
	ctx.r[27].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[10].u32.wrapping_add(0 as u32) ) };
	// 821A1358: FB610050  std r27, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[27].u64 ) };
	// 821A135C: 81610054  lwz r11, 0x54(r1)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(84 as u32) ) } as u64;
	// 821A1360: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1364: 419A01C4  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1368: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A136C: 81210050  lwz r9, 0x50(r1)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1370: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1374: 409A01B4  bne cr6, 0x821a1528
	if !ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1378: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A137C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1380: 419A01A8  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1384: 3A8B0060  addi r20, r11, 0x60
	ctx.r[20].s64 = ctx.r[11].s64 + 96;
	// 821A1388: 48000008  b 0x821a1390
	pc = 0x821A1390; continue 'dispatch;
            }
            0x821A138C => {
    //   block [0x821A138C..0x821A1390)
	// 821A138C: 7F9BE378  mr r27, r28
	ctx.r[27].u64 = ctx.r[28].u64;
	pc = 0x821A1390; continue 'dispatch;
            }
            0x821A1390 => {
    //   block [0x821A1390..0x821A13A4)
	// 821A1390: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821A1394: 40980010  bge cr6, 0x821a13a4
	if !ctx.cr[6].lt {
	pc = 0x821A13A4; continue 'dispatch;
	}
	// 821A1398: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A139C: 7F89E378  mr r9, r28
	ctx.r[9].u64 = ctx.r[28].u64;
	// 821A13A0: 409A0008  bne cr6, 0x821a13a8
	if !ctx.cr[6].eq {
	pc = 0x821A13A8; continue 'dispatch;
	}
	pc = 0x821A13A4; continue 'dispatch;
            }
            0x821A13A4 => {
    //   block [0x821A13A4..0x821A13A8)
	// 821A13A4: 7FC9F378  mr r9, r30
	ctx.r[9].u64 = ctx.r[30].u64;
	pc = 0x821A13A8; continue 'dispatch;
            }
            0x821A13A8 => {
    //   block [0x821A13A8..0x821A13C0)
	// 821A13A8: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A13AC: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A13B0: 6175BE64  ori r21, r11, 0xbe64
	ctx.r[21].u64 = ctx.r[11].u64 | 48740;
	// 821A13B4: 419A000C  beq cr6, 0x821a13c0
	if ctx.cr[6].eq {
	pc = 0x821A13C0; continue 'dispatch;
	}
	// 821A13B8: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A13BC: 48000008  b 0x821a13c4
	pc = 0x821A13C4; continue 'dispatch;
            }
            0x821A13C0 => {
    //   block [0x821A13C0..0x821A13C4)
	// 821A13C0: 3960FFFF  li r11, -1
	ctx.r[11].s64 = -1;
	pc = 0x821A13C4; continue 'dispatch;
            }
            0x821A13C4 => {
    //   block [0x821A13C4..0x821A145C)
	// 821A13C4: 556A083C  slwi r10, r11, 1
	ctx.r[10].u32 = ctx.r[11].u32.wrapping_shl(1);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A13C8: 3D6082CF  lis r11, -0x7d31
	ctx.r[11].s64 = -2100363264;
	// 821A13CC: 7D4A4A14  add r10, r10, r9
	ctx.r[10].u64 = ctx.r[10].u64 + ctx.r[9].u64;
	// 821A13D0: 396BC470  addi r11, r11, -0x3b90
	ctx.r[11].s64 = ctx.r[11].s64 + -15248;
	// 821A13D4: 554A103A  slwi r10, r10, 2
	ctx.r[10].u32 = ctx.r[10].u32.wrapping_shl(2);
	ctx.r[10].u64 = ctx.r[10].u32 as u64;
	// 821A13D8: 392B0014  addi r9, r11, 0x14
	ctx.r[9].s64 = ctx.r[11].s64 + 20;
	// 821A13DC: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A13E0: 38C00002  li r6, 2
	ctx.r[6].s64 = 2;
	// 821A13E4: 38EB0CE8  addi r7, r11, 0xce8
	ctx.r[7].s64 = ctx.r[11].s64 + 3304;
	// 821A13E8: 38A00380  li r5, 0x380
	ctx.r[5].s64 = 896;
	// 821A13EC: 386000E0  li r3, 0xe0
	ctx.r[3].s64 = 224;
	// 821A13F0: 7C8A482E  lwzx r4, r10, r9
	ctx.r[4].u64 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[10].u32.wrapping_add(ctx.r[9].u32)) } as u64;
	// 821A13F4: 481C909D  bl 0x8236a490
	ctx.lr = 0x821A13F8;
	sub_8236A490(ctx, base);
	// 821A13F8: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A13FC: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A1400: 419A0128  beq cr6, 0x821a1528
	if ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1404: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1408: 833F0030  lwz r25, 0x30(r31)
	ctx.r[25].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A140C: 2F1A0000  cmpwi cr6, r26, 0
	ctx.cr[6].compare_i32(ctx.r[26].s32, 0, &mut ctx.xer);
	// 821A1410: 396B0D24  addi r11, r11, 0xd24
	ctx.r[11].s64 = ctx.r[11].s64 + 3364;
	// 821A1414: 917F0000  stw r11, 0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(0 as u32), ctx.r[11].u32 ) };
	// 821A1418: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A141C: FB9F0080  std r28, 0x80(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[28].u64 ) };
	// 821A1420: FB9F0088  std r28, 0x88(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[28].u64 ) };
	// 821A1424: FB9F00B8  std r28, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[28].u64 ) };
	// 821A1428: 9BDF001C  stb r30, 0x1c(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(28 as u32), ctx.r[30].u8 ) };
	// 821A142C: C3EBBA38  lfs f31, -0x45c8(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[31].f64 = (tmp.f32 as f64);
	// 821A1430: 92DF0090  stw r22, 0x90(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), ctx.r[22].u32 ) };
	// 821A1434: 939F00D8  stw r28, 0xd8(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(216 as u32), ctx.r[28].u32 ) };
	// 821A1438: 935F0094  stw r26, 0x94(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), ctx.r[26].u32 ) };
	// 821A143C: 40980020  bge cr6, 0x821a145c
	if !ctx.cr[6].lt {
	pc = 0x821A145C; continue 'dispatch;
	}
	// 821A1440: 397A0001  addi r11, r26, 1
	ctx.r[11].s64 = ctx.r[26].s64 + 1;
	// 821A1444: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1448: 7D6BC050  subf r11, r11, r24
	ctx.r[11].s64 = ctx.r[24].s64 - ctx.r[11].s64;
	// 821A144C: C00B0000  lfs f0, 0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1450: D01F00A8  stfs f0, 0xa8(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(168 as u32), tmp.u32 ) };
	// 821A1454: D3FF00A4  stfs f31, 0xa4(r31)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1458: 48000020  b 0x821a1478
	pc = 0x821A1478; continue 'dispatch;
            }
            0x821A145C => {
    //   block [0x821A145C..0x821A1478)
	// 821A145C: 7F4B07B4  extsw r11, r26
	ctx.r[11].s64 = ctx.r[26].s32 as i64;
	// 821A1460: F9610050  std r11, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[11].u64 ) };
	// 821A1464: C8010050  lfd f0, 0x50(r1)
	ctx.f[0].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1468: FC00069C  fcfid f0, f0
	ctx.f[0].f64 = (ctx.f[0].s64 as f64);
	// 821A146C: FC000018  frsp f0, f0
	ctx.f[0].f64 = (ctx.f[0].f64 as f32) as f64;
	// 821A1470: D01F00B0  stfs f0, 0xb0(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(176 as u32), tmp.u32 ) };
	// 821A1474: D01F00AC  stfs f0, 0xac(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(172 as u32), tmp.u32 ) };
	pc = 0x821A1478; continue 'dispatch;
            }
            0x821A1478 => {
    //   block [0x821A1478..0x821A14E4)
	// 821A1478: D3DF00B4  stfs f30, 0xb4(r31)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(180 as u32), tmp.u32 ) };
	// 821A147C: FB7F00B8  std r27, 0xb8(r31)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[31].u32.wrapping_add(184 as u32), ctx.r[27].u64 ) };
	// 821A1480: 939F00D4  stw r28, 0xd4(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(212 as u32), ctx.r[28].u32 ) };
	// 821A1484: 397F00C0  addi r11, r31, 0xc0
	ctx.r[11].s64 = ctx.r[31].s64 + 192;
	// 821A1488: 92FF009C  stw r23, 0x9c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(156 as u32), ctx.r[23].u32 ) };
	// 821A148C: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A1490: 939F00DC  stw r28, 0xdc(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(220 as u32), ctx.r[28].u32 ) };
	// 821A1494: 38A00000  li r5, 0
	ctx.r[5].s64 = 0;
	// 821A1498: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A149C: 7FE4FB78  mr r4, r31
	ctx.r[4].u64 = ctx.r[31].u64;
	// 821A14A0: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A14A4: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A14A8: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A14AC: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A14B0: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A14B4: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A14B8: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A14BC: 409A00DC  bne cr6, 0x821a1598
	if !ctx.cr[6].eq {
	pc = 0x821A1598; continue 'dispatch;
	}
	// 821A14C0: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A14C4: 38C00007  li r6, 7
	ctx.r[6].s64 = 7;
	// 821A14C8: 38EB0CF0  addi r7, r11, 0xcf0
	ctx.r[7].s64 = ctx.r[11].s64 + 3312;
	// 821A14CC: 38600120  li r3, 0x120
	ctx.r[3].s64 = 288;
	// 821A14D0: 481C8FC1  bl 0x8236a490
	ctx.lr = 0x821A14D4;
	sub_8236A490(ctx, base);
	// 821A14D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A14D8: 419A000C  beq cr6, 0x821a14e4
	if ctx.cr[6].eq {
	pc = 0x821A14E4; continue 'dispatch;
	}
	// 821A14DC: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A14E0: 48000008  b 0x821a14e8
	pc = 0x821A14E8; continue 'dispatch;
            }
            0x821A14E4 => {
    //   block [0x821A14E4..0x821A14E8)
	// 821A14E4: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A14E8; continue 'dispatch;
            }
            0x821A14E8 => {
    //   block [0x821A14E8..0x821A1504)
	// 821A14E8: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A14EC: 917F0088  stw r11, 0x88(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), ctx.r[11].u32 ) };
	// 821A14F0: 907F008C  stw r3, 0x8c(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(140 as u32), ctx.r[3].u32 ) };
	// 821A14F4: 419A0010  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A14F8: 4BFFFB79  bl 0x821a1070
	ctx.lr = 0x821A14FC;
	sub_821A1070(ctx, base);
	// 821A14FC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1500: 409A003C  bne cr6, 0x821a153c
	if !ctx.cr[6].eq {
	pc = 0x821A153C; continue 'dispatch;
	}
	pc = 0x821A1504; continue 'dispatch;
            }
            0x821A1504 => {
    //   block [0x821A1504..0x821A1528)
	// 821A1504: 817F0030  lwz r11, 0x30(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1508: 7F0BC840  cmplw cr6, r11, r25
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[25].u32, &mut ctx.xer);
	// 821A150C: 409A001C  bne cr6, 0x821a1528
	if !ctx.cr[6].eq {
	pc = 0x821A1528; continue 'dispatch;
	}
	// 821A1510: A17F0014  lhz r11, 0x14(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u16( base as *const u8, ctx.r[31].u32.wrapping_add(20 as u32) ) } as u64;
	// 821A1514: 39400005  li r10, 5
	ctx.r[10].s64 = 5;
	// 821A1518: 616B8000  ori r11, r11, 0x8000
	ctx.r[11].u64 = ctx.r[11].u64 | 32768;
	// 821A151C: 995F0019  stb r10, 0x19(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(25 as u32), ctx.r[10].u8 ) };
	// 821A1520: 9BDF0025  stb r30, 0x25(r31)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[31].u32.wrapping_add(37 as u32), ctx.r[30].u8 ) };
	// 821A1524: B17F0014  sth r11, 0x14(r31)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[31].u32.wrapping_add(20 as u32), ctx.r[11].u16 ) };
	pc = 0x821A1528; continue 'dispatch;
            }
            0x821A1528 => {
    //   block [0x821A1528..0x821A153C)
	// 821A1528: 38600000  li r3, 0
	ctx.r[3].s64 = 0;
	// 821A152C: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A1530: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821A1534: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821A1538: 48393BAC  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            0x821A153C => {
    //   block [0x821A153C..0x821A1598)
	// 821A153C: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 821A1540: 811D0000  lwz r8, 0(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1544: 80610050  lwz r3, 0x50(r1)
	ctx.r[3].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) } as u64;
	// 821A1548: 394B0070  addi r10, r11, 0x70
	ctx.r[10].s64 = ctx.r[11].s64 + 112;
	// 821A154C: 392B0080  addi r9, r11, 0x80
	ctx.r[9].s64 = ctx.r[11].s64 + 128;
	// 821A1550: 7D7C5B78  mr r28, r11
	ctx.r[28].u64 = ctx.r[11].u64;
	// 821A1554: 910A0000  stw r8, 0(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(0 as u32), ctx.r[8].u32 ) };
	// 821A1558: 811D0004  lwz r8, 4(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A155C: 910A0004  stw r8, 4(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(4 as u32), ctx.r[8].u32 ) };
	// 821A1560: 811D0008  lwz r8, 8(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1564: 910A0008  stw r8, 8(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(8 as u32), ctx.r[8].u32 ) };
	// 821A1568: 811D000C  lwz r8, 0xc(r29)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A156C: 910A000C  stw r8, 0xc(r10)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[10].u32.wrapping_add(12 as u32), ctx.r[8].u32 ) };
	// 821A1570: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1574: 91490000  stw r10, 0(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A1578: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A157C: 91490004  stw r10, 4(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A1580: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A1584: 91490008  stw r10, 8(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A1588: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A158C: D3EB0090  stfs f31, 0x90(r11)
	tmp.f32 = (ctx.f[31].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A1590: 9149000C  stw r10, 0xc(r9)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[9].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	// 821A1594: 48000074  b 0x821a1608
	pc = 0x821A1608; continue 'dispatch;
            }
            0x821A1598 => {
    //   block [0x821A1598..0x821A15BC)
	// 821A1598: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A159C: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A15A0: 38EB0CF8  addi r7, r11, 0xcf8
	ctx.r[7].s64 = ctx.r[11].s64 + 3320;
	// 821A15A4: 38600130  li r3, 0x130
	ctx.r[3].s64 = 304;
	// 821A15A8: 481C8EE9  bl 0x8236a490
	ctx.lr = 0x821A15AC;
	sub_8236A490(ctx, base);
	// 821A15AC: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15B0: 419A000C  beq cr6, 0x821a15bc
	if ctx.cr[6].eq {
	pc = 0x821A15BC; continue 'dispatch;
	}
	// 821A15B4: 81630030  lwz r11, 0x30(r3)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[3].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A15B8: 48000008  b 0x821a15c0
	pc = 0x821A15C0; continue 'dispatch;
            }
            0x821A15BC => {
    //   block [0x821A15BC..0x821A15C0)
	// 821A15BC: 7F8BE378  mr r11, r28
	ctx.r[11].u64 = ctx.r[28].u64;
	pc = 0x821A15C0; continue 'dispatch;
            }
            0x821A15C0 => {
    //   block [0x821A15C0..0x821A1608)
	// 821A15C0: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15C4: 917F0080  stw r11, 0x80(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), ctx.r[11].u32 ) };
	// 821A15C8: 907F0084  stw r3, 0x84(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), ctx.r[3].u32 ) };
	// 821A15CC: 419AFF38  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A15D0: 4BFFF9F1  bl 0x821a0fc0
	ctx.lr = 0x821A15D4;
	sub_821A0FC0(ctx, base);
	// 821A15D4: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A15D8: 419AFF2C  beq cr6, 0x821a1504
	if ctx.cr[6].eq {
	pc = 0x821A1504; continue 'dispatch;
	}
	// 821A15DC: 38630080  addi r3, r3, 0x80
	ctx.r[3].s64 = ctx.r[3].s64 + 128;
	// 821A15E0: 815D0000  lwz r10, 0(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A15E4: 39630090  addi r11, r3, 0x90
	ctx.r[11].s64 = ctx.r[3].s64 + 144;
	// 821A15E8: 7C7C1B78  mr r28, r3
	ctx.r[28].u64 = ctx.r[3].u64;
	// 821A15EC: 914B0000  stw r10, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u32 ) };
	// 821A15F0: 815D0004  lwz r10, 4(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(4 as u32) ) } as u64;
	// 821A15F4: 914B0004  stw r10, 4(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(4 as u32), ctx.r[10].u32 ) };
	// 821A15F8: 815D0008  lwz r10, 8(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(8 as u32) ) } as u64;
	// 821A15FC: 914B0008  stw r10, 8(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u32 ) };
	// 821A1600: 815D000C  lwz r10, 0xc(r29)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[29].u32.wrapping_add(12 as u32) ) } as u64;
	// 821A1604: 914B000C  stw r10, 0xc(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(12 as u32), ctx.r[10].u32 ) };
	pc = 0x821A1608; continue 'dispatch;
            }
            0x821A1608 => {
    //   block [0x821A1608..0x821A1630)
	// 821A1608: 3960EFEC  li r11, -0x1014
	ctx.r[11].s64 = -4116;
	// 821A160C: 9BDC0021  stb r30, 0x21(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(33 as u32), ctx.r[30].u8 ) };
	// 821A1610: 2F160006  cmpwi cr6, r22, 6
	ctx.cr[6].compare_i32(ctx.r[22].s32, 6, &mut ctx.xer);
	// 821A1614: 9BDC0027  stb r30, 0x27(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(39 as u32), ctx.r[30].u8 ) };
	// 821A1618: 9BDC001F  stb r30, 0x1f(r28)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[28].u32.wrapping_add(31 as u32), ctx.r[30].u8 ) };
	// 821A161C: B17C0022  sth r11, 0x22(r28)
	unsafe { crate::rt::store_u16( base as *mut u8, ctx.r[28].u32.wrapping_add(34 as u32), ctx.r[11].u16 ) };
	// 821A1620: 409A0010  bne cr6, 0x821a1630
	if !ctx.cr[6].eq {
	pc = 0x821A1630; continue 'dispatch;
	}
	// 821A1624: 38A00007  li r5, 7
	ctx.r[5].s64 = 7;
	// 821A1628: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 821A162C: 480000AC  b 0x821a16d8
	pc = 0x821A16D8; continue 'dispatch;
            }
            0x821A1630 => {
    //   block [0x821A1630..0x821A1654)
	// 821A1630: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1634: 2F160005  cmpwi cr6, r22, 5
	ctx.cr[6].compare_i32(ctx.r[22].s32, 5, &mut ctx.xer);
	// 821A1638: C02BBFFC  lfs f1, -0x4004(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-16388 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A163C: 409A0018  bne cr6, 0x821a1654
	if !ctx.cr[6].eq {
	pc = 0x821A1654; continue 'dispatch;
	}
	// 821A1640: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1644: 814BB9E4  lwz r10, -0x461c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17948 as u32) ) } as u64;
	// 821A1648: 394A0001  addi r10, r10, 1
	ctx.r[10].s64 = ctx.r[10].s64 + 1;
	// 821A164C: 914BB9E4  stw r10, -0x461c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17948 as u32), ctx.r[10].u32 ) };
	// 821A1650: 4800001C  b 0x821a166c
	pc = 0x821A166C; continue 'dispatch;
            }
            0x821A1654 => {
    //   block [0x821A1654..0x821A166C)
	// 821A1654: 2F160004  cmpwi cr6, r22, 4
	ctx.cr[6].compare_i32(ctx.r[22].s32, 4, &mut ctx.xer);
	// 821A1658: 419A0014  beq cr6, 0x821a166c
	if ctx.cr[6].eq {
	pc = 0x821A166C; continue 'dispatch;
	}
	// 821A165C: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1660: 2F160002  cmpwi cr6, r22, 2
	ctx.cr[6].compare_i32(ctx.r[22].s32, 2, &mut ctx.xer);
	// 821A1664: C02B2C40  lfs f1, 0x2c40(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(11328 as u32) ) };
	ctx.f[1].f64 = (tmp.f32 as f64);
	// 821A1668: 419A0050  beq cr6, 0x821a16b8
	if ctx.cr[6].eq {
	pc = 0x821A16B8; continue 'dispatch;
	}
	pc = 0x821A166C; continue 'dispatch;
            }
            0x821A166C => {
    //   block [0x821A166C..0x821A16B0)
	// 821A166C: D3C3007C  stfs f30, 0x7c(r3)
	tmp.f32 = (ctx.f[30].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[3].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A1670: E9540000  ld r10, 0(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(0 as u32) ) };
	// 821A1674: 39630080  addi r11, r3, 0x80
	ctx.r[11].s64 = ctx.r[3].s64 + 128;
	// 821A1678: F94B0000  std r10, 0(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[10].u64 ) };
	// 821A167C: E9540008  ld r10, 8(r20)
	ctx.r[10].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[20].u32.wrapping_add(8 as u32) ) };
	// 821A1680: F94B0008  std r10, 8(r11)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[11].u32.wrapping_add(8 as u32), ctx.r[10].u64 ) };
	// 821A1684: 481E1405  bl 0x82382a88
	ctx.lr = 0x821A1688;
	sub_82382A88(ctx, base);
	// 821A1688: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A168C: 419A0024  beq cr6, 0x821a16b0
	if ctx.cr[6].eq {
	pc = 0x821A16B0; continue 'dispatch;
	}
	// 821A1690: 2F160003  cmpwi cr6, r22, 3
	ctx.cr[6].compare_i32(ctx.r[22].s32, 3, &mut ctx.xer);
	// 821A1694: 409A001C  bne cr6, 0x821a16b0
	if !ctx.cr[6].eq {
	pc = 0x821A16B0; continue 'dispatch;
	}
	// 821A1698: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A169C: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A16A0: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A16A4: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A16A8: 3BCB0003  addi r30, r11, 3
	ctx.r[30].s64 = ctx.r[11].s64 + 3;
	// 821A16AC: 48000028  b 0x821a16d4
	pc = 0x821A16D4; continue 'dispatch;
            }
            0x821A16B0 => {
    //   block [0x821A16B0..0x821A16B8)
	// 821A16B0: 3BC00007  li r30, 7
	ctx.r[30].s64 = 7;
	// 821A16B4: 48000020  b 0x821a16d4
	pc = 0x821A16D4; continue 'dispatch;
            }
            0x821A16B8 => {
    //   block [0x821A16B8..0x821A16D4)
	// 821A16B8: 2B130000  cmplwi cr6, r19, 0
	ctx.cr[6].compare_u32(ctx.r[19].u32, 0 as u32, &mut ctx.xer);
	// 821A16BC: 419A0018  beq cr6, 0x821a16d4
	if ctx.cr[6].eq {
	pc = 0x821A16D4; continue 'dispatch;
	}
	// 821A16C0: 7D73A8AE  lbzx r11, r19, r21
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[19].u32.wrapping_add(ctx.r[21].u32)) } as u64;
	// 821A16C4: 216B0000  subfic r11, r11, 0
	ctx.xer.ca = ctx.r[11].u32 <= 0 as u32;
	ctx.r[11].s64 = (0 as i64) - ctx.r[11].s64;
	// 821A16C8: 7D6B5910  subfe r11, r11, r11
	let x = (!ctx.r[11].u32);
	let y = ctx.r[11].u32;
	let s = x.wrapping_add(y);
	let res = s.wrapping_add(ctx.xer.ca as u32);
	tmp.u8 = (s < x) as u8 | (res < s) as u8;
	ctx.r[11].u32 = res;
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	ctx.xer.ca = (tmp.u8 != 0);
	// 821A16CC: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A16D0: 3BCB0002  addi r30, r11, 2
	ctx.r[30].s64 = ctx.r[11].s64 + 2;
	pc = 0x821A16D4; continue 'dispatch;
            }
            0x821A16D4 => {
    //   block [0x821A16D4..0x821A16D8)
	// 821A16D4: 7FC5F378  mr r5, r30
	ctx.r[5].u64 = ctx.r[30].u64;
	pc = 0x821A16D8; continue 'dispatch;
            }
            0x821A16D8 => {
    //   block [0x821A16D8..0x821A170C)
	// 821A16D8: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A16DC: 38C00001  li r6, 1
	ctx.r[6].s64 = 1;
	// 821A16E0: 7F84E378  mr r4, r28
	ctx.r[4].u64 = ctx.r[28].u64;
	// 821A16E4: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A16E8: 481DCAE1  bl 0x8237e1c8
	ctx.lr = 0x821A16EC;
	sub_8237E1C8(ctx, base);
	// 821A16EC: 907F0098  stw r3, 0x98(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), ctx.r[3].u32 ) };
	// 821A16F0: 7FE3FB78  mr r3, r31
	ctx.r[3].u64 = ctx.r[31].u64;
	// 821A16F4: 93DF00A0  stw r30, 0xa0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(160 as u32), ctx.r[30].u32 ) };
	// 821A16F8: 927F00D0  stw r19, 0xd0(r31)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(208 as u32), ctx.r[19].u32 ) };
	// 821A16FC: 382100E0  addi r1, r1, 0xe0
	ctx.r[1].s64 = ctx.r[1].s64 + 224;
	// 821A1700: CBC1FF80  lfd f30, -0x80(r1)
	ctx.fpscr.disable_flush_mode_unconditional();
	ctx.f[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-128 as u32) ) };
	// 821A1704: CBE1FF88  lfd f31, -0x78(r1)
	ctx.f[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-120 as u32) ) };
	// 821A1708: 483939DC  b 0x825350e4
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1710(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut tmp: PPCRegister = Default::default();
    let mut ea: u32 = 0;
    // ---- function 0x821A1710 size=672
    let mut pc: u32 = 0x821A1710;
    'dispatch: loop {
        match pc {
            0x821A1710 => {
    //   block [0x821A1710..0x821A1780)
	// 821A1710: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A1714: 483939A9  bl 0x825350bc
	ctx.lr = 0x821A1718;
	sub_82535080(ctx, base);
	// 821A1718: 9421FF80  stwu r1, -0x80(r1)
	ea = ctx.r[1].u32.wrapping_add(-128 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A171C: 7C641B78  mr r4, r3
	ctx.r[4].u64 = ctx.r[3].u64;
	// 821A1720: 3BE00000  li r31, 0
	ctx.r[31].s64 = 0;
	// 821A1724: 81640040  lwz r11, 0x40(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(64 as u32) ) } as u64;
	// 821A1728: 93E40040  stw r31, 0x40(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(64 as u32), ctx.r[31].u32 ) };
	// 821A172C: 7D6B0734  extsh r11, r11
	ctx.r[11].s64 = ctx.r[11].s16 as i64;
	// 821A1730: 2F0B0001  cmpwi cr6, r11, 1
	ctx.cr[6].compare_i32(ctx.r[11].s32, 1, &mut ctx.xer);
	// 821A1734: 419A0274  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1738: 81640098  lwz r11, 0x98(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A173C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1740: 419A0248  beq cr6, 0x821a1988
	if ctx.cr[6].eq {
	pc = 0x821A1988; continue 'dispatch;
	}
	// 821A1744: 83A40090  lwz r29, 0x90(r4)
	ctx.r[29].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1748: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 821A174C: 409A0034  bne cr6, 0x821a1780
	if !ctx.cr[6].eq {
	pc = 0x821A1780; continue 'dispatch;
	}
	// 821A1750: 8164008C  lwz r11, 0x8c(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A1754: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1758: 419A0250  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A175C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1760: 81240088  lwz r9, 0x88(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A1764: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1768: 409A0240  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A176C: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A1770: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1774: 419A0234  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1778: 7D7E5B78  mr r30, r11
	ctx.r[30].u64 = ctx.r[11].u64;
	// 821A177C: 48000030  b 0x821a17ac
	pc = 0x821A17AC; continue 'dispatch;
            }
            0x821A1780 => {
    //   block [0x821A1780..0x821A17AC)
	// 821A1780: 81640084  lwz r11, 0x84(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A1784: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1788: 419A0220  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A178C: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1790: 81240080  lwz r9, 0x80(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1794: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1798: 409A0210  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A179C: 3BEB0080  addi r31, r11, 0x80
	ctx.r[31].s64 = ctx.r[11].s64 + 128;
	// 821A17A0: 2B1F0000  cmplwi cr6, r31, 0
	ctx.cr[6].compare_u32(ctx.r[31].u32, 0 as u32, &mut ctx.xer);
	// 821A17A4: 419A0204  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A17A8: 7FFEFB78  mr r30, r31
	ctx.r[30].u64 = ctx.r[31].u64;
	pc = 0x821A17AC; continue 'dispatch;
            }
            0x821A17AC => {
    //   block [0x821A17AC..0x821A1808)
	// 821A17AC: 2B1E0000  cmplwi cr6, r30, 0
	ctx.cr[6].compare_u32(ctx.r[30].u32, 0 as u32, &mut ctx.xer);
	// 821A17B0: 419A01F8  beq cr6, 0x821a19a8
	if ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A17B4: 2F1D0002  cmpwi cr6, r29, 2
	ctx.cr[6].compare_i32(ctx.r[29].s32, 2, &mut ctx.xer);
	// 821A17B8: 419A0050  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17BC: 816400BC  lwz r11, 0xbc(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A17C0: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A17C4: 419A0044  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17C8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A17CC: 812400B8  lwz r9, 0xb8(r4)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A17D0: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A17D4: 409A0034  bne cr6, 0x821a1808
	if !ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17D8: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A17DC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A17E0: 419A0028  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17E4: 814B0084  lwz r10, 0x84(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A17E8: 2F0A0000  cmpwi cr6, r10, 0
	ctx.cr[6].compare_i32(ctx.r[10].s32, 0, &mut ctx.xer);
	// 821A17EC: 419A001C  beq cr6, 0x821a1808
	if ctx.cr[6].eq {
	pc = 0x821A1808; continue 'dispatch;
	}
	// 821A17F0: C00B0060  lfs f0, 0x60(r11)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(96 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A17F4: D01F0080  stfs f0, 0x80(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(128 as u32), tmp.u32 ) };
	// 821A17F8: C00B0064  lfs f0, 0x64(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(100 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A17FC: D01F0084  stfs f0, 0x84(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(132 as u32), tmp.u32 ) };
	// 821A1800: C00B0068  lfs f0, 0x68(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(104 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1804: D01F0088  stfs f0, 0x88(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(136 as u32), tmp.u32 ) };
	pc = 0x821A1808; continue 'dispatch;
            }
            0x821A1808 => {
    //   block [0x821A1808..0x821A187C)
	// 821A1808: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A180C: 2F1D0006  cmpwi cr6, r29, 6
	ctx.cr[6].compare_i32(ctx.r[29].s32, 6, &mut ctx.xer);
	// 821A1810: C18B1FF8  lfs f12, 0x1ff8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8184 as u32) ) };
	ctx.f[12].f64 = (tmp.f32 as f64);
	// 821A1814: 409A0068  bne cr6, 0x821a187c
	if !ctx.cr[6].eq {
	pc = 0x821A187C; continue 'dispatch;
	}
	// 821A1818: 481C5921  bl 0x82367138
	ctx.lr = 0x821A181C;
	sub_82367138(ctx, base);
	// 821A181C: 786A0260  clrldi r10, r3, 0x29
	ctx.r[10].u64 = ctx.r[3].u64 & 0x00000000007FFFFFu64;
	// 821A1820: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1824: C17F0090  lfs f11, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A1828: F9410050  std r10, 0x50(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(80 as u32), ctx.r[10].u64 ) };
	// 821A182C: C00B2280  lfs f0, 0x2280(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8832 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1830: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1834: C04B20D8  lfs f2, 0x20d8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8408 as u32) ) };
	ctx.f[2].f64 = (tmp.f32 as f64);
	// 821A1838: 3D60820A  lis r11, -0x7df6
	ctx.r[11].s64 = -2113273856;
	// 821A183C: C9A10050  lfd f13, 0x50(r1)
	ctx.f[13].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(80 as u32) ) };
	// 821A1840: FDA06E9C  fcfid f13, f13
	ctx.f[13].f64 = (ctx.f[13].s64 as f64);
	// 821A1844: FD406818  frsp f10, f13
	ctx.f[10].f64 = (ctx.f[13].f64 as f32) as f64;
	// 821A1848: C1ABBA38  lfs f13, -0x45c8(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17864 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A184C: 3D60820C  lis r11, -0x7df4
	ctx.r[11].s64 = -2113142784;
	// 821A1850: EDAA683A  fmadds f13, f10, f0, f13
	ctx.f[13].f64 = (((ctx.f[10].f64 * ctx.f[0].f64 + ctx.f[13].f64) as f32) as f64);
	// 821A1854: C00BD760  lfs f0, -0x28a0(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-10400 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1858: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A185C: EDAD0032  fmuls f13, f13, f0
	ctx.f[13].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1860: C00B2054  lfs f0, 0x2054(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8276 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1864: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1868: EC020024  fdivs f0, f2, f0
	ctx.f[0].f64 = ((ctx.f[2].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A186C: EC2B002A  fadds f1, f11, f0
	ctx.f[1].f64 = ((ctx.f[11].f64 + ctx.f[0].f64) as f32) as f64;
	// 821A1870: 481C62D1  bl 0x82367b40
	ctx.lr = 0x821A1874;
	sub_82367B40(ctx, base);
	// 821A1874: D03F0090  stfs f1, 0x90(r31)
	ctx.fpscr.disable_flush_mode_unconditional();
	tmp.f32 = (ctx.f[1].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(144 as u32), tmp.u32 ) };
	// 821A1878: 48000080  b 0x821a18f8
	pc = 0x821A18F8; continue 'dispatch;
            }
            0x821A187C => {
    //   block [0x821A187C..0x821A18AC)
	// 821A187C: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821A1880: 409A002C  bne cr6, 0x821a18ac
	if !ctx.cr[6].eq {
	pc = 0x821A18AC; continue 'dispatch;
	}
	// 821A1884: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A1888: 556B07BC  rlwinm r11, r11, 0, 0x1e, 0x1e
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A188C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1890: 419A004C  beq cr6, 0x821a18dc
	if ctx.cr[6].eq {
	pc = 0x821A18DC; continue 'dispatch;
	}
	// 821A1894: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A1898: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A189C: C1A400C8  lfs f13, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A18A0: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18A4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A18A8: 48000040  b 0x821a18e8
	pc = 0x821A18E8; continue 'dispatch;
            }
            0x821A18AC => {
    //   block [0x821A18AC..0x821A18DC)
	// 821A18AC: 2F1D0005  cmpwi cr6, r29, 5
	ctx.cr[6].compare_i32(ctx.r[29].s32, 5, &mut ctx.xer);
	// 821A18B0: 409A0048  bne cr6, 0x821a18f8
	if !ctx.cr[6].eq {
	pc = 0x821A18F8; continue 'dispatch;
	}
	// 821A18B4: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A18B8: 556B077A  rlwinm r11, r11, 0, 0x1d, 0x1d
	ctx.r[11].u64 = ctx.r[11].u32 as u64 & 0xFFFFFFFFu64;
	// 821A18BC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A18C0: 419A001C  beq cr6, 0x821a18dc
	if ctx.cr[6].eq {
	pc = 0x821A18DC; continue 'dispatch;
	}
	// 821A18C4: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A18C8: D19F0094  stfs f12, 0x94(r31)
	tmp.f32 = (ctx.f[12].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A18CC: C1A400C8  lfs f13, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A18D0: C00B2068  lfs f0, 0x2068(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8296 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18D4: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A18D8: 48000010  b 0x821a18e8
	pc = 0x821A18E8; continue 'dispatch;
            }
            0x821A18DC => {
    //   block [0x821A18DC..0x821A18E8)
	// 821A18DC: C00400C4  lfs f0, 0xc4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(196 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A18E0: D01F0094  stfs f0, 0x94(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(148 as u32), tmp.u32 ) };
	// 821A18E4: C00400C8  lfs f0, 0xc8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(200 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	pc = 0x821A18E8; continue 'dispatch;
            }
            0x821A18E8 => {
    //   block [0x821A18E8..0x821A18F8)
	// 821A18E8: D01F0098  stfs f0, 0x98(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(152 as u32), tmp.u32 ) };
	// 821A18EC: 816400D8  lwz r11, 0xd8(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(216 as u32) ) } as u64;
	// 821A18F0: 396B0001  addi r11, r11, 1
	ctx.r[11].s64 = ctx.r[11].s64 + 1;
	// 821A18F4: 916400D8  stw r11, 0xd8(r4)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(216 as u32), ctx.r[11].u32 ) };
	pc = 0x821A18F8; continue 'dispatch;
            }
            0x821A18F8 => {
    //   block [0x821A18F8..0x821A1914)
	// 821A18F8: 81640094  lwz r11, 0x94(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A18FC: 2F0B0000  cmpwi cr6, r11, 0
	ctx.cr[6].compare_i32(ctx.r[11].s32, 0, &mut ctx.xer);
	// 821A1900: 40980038  bge cr6, 0x821a1938
	if !ctx.cr[6].lt {
	pc = 0x821A1938; continue 'dispatch;
	}
	// 821A1904: C00400A4  lfs f0, 0xa4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(164 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1908: 2F1D0001  cmpwi cr6, r29, 1
	ctx.cr[6].compare_i32(ctx.r[29].s32, 1, &mut ctx.xer);
	// 821A190C: 409A0008  bne cr6, 0x821a1914
	if !ctx.cr[6].eq {
	pc = 0x821A1914; continue 'dispatch;
	}
	// 821A1910: D01E0110  stfs f0, 0x110(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), tmp.u32 ) };
	pc = 0x821A1914; continue 'dispatch;
            }
            0x821A1914 => {
    //   block [0x821A1914..0x821A1938)
	// 821A1914: C1A400A8  lfs f13, 0xa8(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(168 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1918: 3D60820D  lis r11, -0x7df3
	ctx.r[11].s64 = -2113077248;
	// 821A191C: EC0D0032  fmuls f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1920: C1AB2238  lfs f13, 0x2238(r11)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(8760 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1924: FF006800  fcmpu cr6, f0, f13
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[13].f64);
	// 821A1928: 40990060  ble cr6, 0x821a1988
	if !ctx.cr[6].gt {
	pc = 0x821A1988; continue 'dispatch;
	}
	// 821A192C: D00400A4  stfs f0, 0xa4(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(164 as u32), tmp.u32 ) };
	// 821A1930: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A1934: 483937D8  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            0x821A1938 => {
    //   block [0x821A1938..0x821A1960)
	// 821A1938: 81640090  lwz r11, 0x90(r4)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A193C: C1A400AC  lfs f13, 0xac(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(172 as u32) ) };
	ctx.f[13].f64 = (tmp.f32 as f64);
	// 821A1940: C00400B0  lfs f0, 0xb0(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(176 as u32) ) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1944: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1948: EC0D0024  fdivs f0, f13, f0
	ctx.f[0].f64 = ((ctx.f[13].f64 / ctx.f[0].f64) as f32) as f64;
	// 821A194C: 419A0014  beq cr6, 0x821a1960
	if ctx.cr[6].eq {
	pc = 0x821A1960; continue 'dispatch;
	}
	// 821A1950: C16400B4  lfs f11, 0xb4(r4)
	tmp.u32 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[4].u32.wrapping_add(180 as u32) ) };
	ctx.f[11].f64 = (tmp.f32 as f64);
	// 821A1954: EC0B0032  fmuls f0, f11, f0
	ctx.f[0].f64 = (((ctx.f[11].f64 * ctx.f[0].f64) as f32) as f64);
	// 821A1958: D01F007C  stfs f0, 0x7c(r31)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[31].u32.wrapping_add(124 as u32), tmp.u32 ) };
	// 821A195C: 48000008  b 0x821a1964
	pc = 0x821A1964; continue 'dispatch;
            }
            0x821A1960 => {
    //   block [0x821A1960..0x821A1964)
	// 821A1960: D01E0110  stfs f0, 0x110(r30)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[30].u32.wrapping_add(272 as u32), tmp.u32 ) };
	pc = 0x821A1964; continue 'dispatch;
            }
            0x821A1964 => {
    //   block [0x821A1964..0x821A1988)
	// 821A1964: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1968: 3D400003  lis r10, 3
	ctx.r[10].s64 = 196608;
	// 821A196C: 396BBFF0  addi r11, r11, -0x4010
	ctx.r[11].s64 = ctx.r[11].s64 + -16400;
	// 821A1970: 614A85D8  ori r10, r10, 0x85d8
	ctx.r[10].u64 = ctx.r[10].u64 | 34264;
	// 821A1974: 7C0B542E  lfsx f0, r11, r10
	tmp.u32 = unsafe { crate::rt::load_u32(base as *const u8, ctx.r[11].u32.wrapping_add(ctx.r[10].u32)) };
	ctx.f[0].f64 = (tmp.f32 as f64);
	// 821A1978: EC0D0028  fsubs f0, f13, f0
	ctx.f[0].f64 = (((ctx.f[13].f64 - ctx.f[0].f64) as f32) as f64);
	// 821A197C: D00400AC  stfs f0, 0xac(r4)
	tmp.f32 = (ctx.f[0].f64 as f32);
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[4].u32.wrapping_add(172 as u32), tmp.u32 ) };
	// 821A1980: FF006000  fcmpu cr6, f0, f12
	ctx.cr[6].compare_f64(ctx.f[0].f64, ctx.f[12].f64);
	// 821A1984: 41990024  bgt cr6, 0x821a19a8
	if ctx.cr[6].gt {
	pc = 0x821A19A8; continue 'dispatch;
	}
	pc = 0x821A1988; continue 'dispatch;
            }
            0x821A1988 => {
    //   block [0x821A1988..0x821A19A8)
	// 821A1988: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A198C: 816BFAC0  lwz r11, -0x540(r11)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-1344 as u32) ) } as u64;
	// 821A1990: 7F0B2040  cmplw cr6, r11, r4
	ctx.cr[6].compare_u32(ctx.r[11].u32, ctx.r[4].u32, &mut ctx.xer);
	// 821A1994: 409A0014  bne cr6, 0x821a19a8
	if !ctx.cr[6].eq {
	pc = 0x821A19A8; continue 'dispatch;
	}
	// 821A1998: 39600005  li r11, 5
	ctx.r[11].s64 = 5;
	// 821A199C: 39400001  li r10, 1
	ctx.r[10].s64 = 1;
	// 821A19A0: 99640019  stb r11, 0x19(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(25 as u32), ctx.r[11].u8 ) };
	// 821A19A4: 99440025  stb r10, 0x25(r4)
	unsafe { crate::rt::store_u8( base as *mut u8, ctx.r[4].u32.wrapping_add(37 as u32), ctx.r[10].u8 ) };
	pc = 0x821A19A8; continue 'dispatch;
            }
            0x821A19A8 => {
    //   block [0x821A19A8..0x821A19B0)
	// 821A19A8: 38210080  addi r1, r1, 0x80
	ctx.r[1].s64 = ctx.r[1].s64 + 128;
	// 821A19AC: 48393760  b 0x8253510c
	sub_825350D0(ctx, base);
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A19B0(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    let mut ea: u32 = 0;
    // ---- function 0x821A19B0 size=412
    let mut pc: u32 = 0x821A19B0;
    'dispatch: loop {
        match pc {
            0x821A19B0 => {
    //   block [0x821A19B0..0x821A1A18)
	// 821A19B0: 7D8802A6  mflr r12
	ctx.r[12].u64 = ctx.lr;
	// 821A19B4: 9181FFF8  stw r12, -8(r1)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[1].u32.wrapping_add(-8 as u32), ctx.r[12].u32 ) };
	// 821A19B8: FBC1FFE8  std r30, -0x18(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-24 as u32), ctx.r[30].u64 ) };
	// 821A19BC: FBE1FFF0  std r31, -0x10(r1)
	unsafe { crate::rt::store_u64( base as *mut u8, ctx.r[1].u32.wrapping_add(-16 as u32), ctx.r[31].u64 ) };
	// 821A19C0: 9421FF90  stwu r1, -0x70(r1)
	ea = ctx.r[1].u32.wrapping_add(-112 as u32);
	unsafe { crate::rt::store_u32(base as *mut u8, ea, ctx.r[1].u32) };
	ctx.r[1].u32 = ea;
	// 821A19C4: 7C7F1B78  mr r31, r3
	ctx.r[31].u64 = ctx.r[3].u64;
	// 821A19C8: 817F00BC  lwz r11, 0xbc(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(188 as u32) ) } as u64;
	// 821A19CC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A19D0: 419A0048  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19D4: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A19D8: 813F00B8  lwz r9, 0xb8(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(184 as u32) ) } as u64;
	// 821A19DC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A19E0: 409A0038  bne cr6, 0x821a1a18
	if !ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19E4: 396B0080  addi r11, r11, 0x80
	ctx.r[11].s64 = ctx.r[11].s64 + 128;
	// 821A19E8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A19EC: 419A002C  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19F0: 814B0094  lwz r10, 0x94(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(148 as u32) ) } as u64;
	// 821A19F4: 2B0A0000  cmplwi cr6, r10, 0
	ctx.cr[6].compare_u32(ctx.r[10].u32, 0 as u32, &mut ctx.xer);
	// 821A19F8: 419A0020  beq cr6, 0x821a1a18
	if ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A19FC: 814A0030  lwz r10, 0x30(r10)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[10].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1A00: 812B0090  lwz r9, 0x90(r11)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A04: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1A08: 409A0010  bne cr6, 0x821a1a18
	if !ctx.cr[6].eq {
	pc = 0x821A1A18; continue 'dispatch;
	}
	// 821A1A0C: 814B0080  lwz r10, 0x80(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(128 as u32) ) } as u64;
	// 821A1A10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1A14: 914B0080  stw r10, 0x80(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(128 as u32), ctx.r[10].u32 ) };
	pc = 0x821A1A18; continue 'dispatch;
            }
            0x821A1A18 => {
    //   block [0x821A1A18..0x821A1A70)
	// 821A1A18: 817F009C  lwz r11, 0x9c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(156 as u32) ) } as u64;
	// 821A1A1C: 3BC00000  li r30, 0
	ctx.r[30].s64 = 0;
	// 821A1A20: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1A24: 419A0074  beq cr6, 0x821a1a98
	if ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A28: 811F00D0  lwz r8, 0xd0(r31)
	ctx.r[8].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(208 as u32) ) } as u64;
	// 821A1A2C: 2B080000  cmplwi cr6, r8, 0
	ctx.cr[6].compare_u32(ctx.r[8].u32, 0 as u32, &mut ctx.xer);
	// 821A1A30: 419A0068  beq cr6, 0x821a1a98
	if ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A34: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A38: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1A3C: 3D600001  lis r11, 1
	ctx.r[11].s64 = 65536;
	// 821A1A40: 409A0030  bne cr6, 0x821a1a70
	if !ctx.cr[6].eq {
	pc = 0x821A1A70; continue 'dispatch;
	}
	// 821A1A44: 6167BE64  ori r7, r11, 0xbe64
	ctx.r[7].u64 = ctx.r[11].u64 | 48740;
	// 821A1A48: 813F00DC  lwz r9, 0xdc(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(220 as u32) ) } as u64;
	// 821A1A4C: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A1A50: 396B1490  addi r11, r11, 0x1490
	ctx.r[11].s64 = ctx.r[11].s64 + 5264;
	// 821A1A54: 394BFF80  addi r10, r11, -0x80
	ctx.r[10].s64 = ctx.r[11].s64 + -128;
	// 821A1A58: 7D6838AE  lbzx r11, r8, r7
	ctx.r[11].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[7].u32)) } as u64;
	// 821A1A5C: 556B183E  rotlwi r11, r11, 3
	ctx.r[11].u64 = ((ctx.r[11].u32).rotate_left(3)) as u64;
	// 821A1A60: 7D6B4A14  add r11, r11, r9
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[9].u64;
	// 821A1A64: 556B103A  slwi r11, r11, 2
	ctx.r[11].u32 = ctx.r[11].u32.wrapping_shl(2);
	ctx.r[11].u64 = ctx.r[11].u32 as u64;
	// 821A1A68: 7D6B5214  add r11, r11, r10
	ctx.r[11].u64 = ctx.r[11].u64 + ctx.r[10].u64;
	// 821A1A6C: 4800001C  b 0x821a1a88
	pc = 0x821A1A88; continue 'dispatch;
            }
            0x821A1A70 => {
    //   block [0x821A1A70..0x821A1A88)
	// 821A1A70: 616ABE64  ori r10, r11, 0xbe64
	ctx.r[10].u64 = ctx.r[11].u64 | 48740;
	// 821A1A74: 3D60829E  lis r11, -0x7d62
	ctx.r[11].s64 = -2103574528;
	// 821A1A78: 396B1490  addi r11, r11, 0x1490
	ctx.r[11].s64 = ctx.r[11].s64 + 5264;
	// 821A1A7C: 7D4850AE  lbzx r10, r8, r10
	ctx.r[10].u64 = unsafe { crate::rt::load_u8(base as *const u8, ctx.r[8].u32.wrapping_add(ctx.r[10].u32)) } as u64;
	// 821A1A80: 554A103E  rotlwi r10, r10, 2
	ctx.r[10].u64 = ((ctx.r[10].u32).rotate_left(2)) as u64;
	// 821A1A84: 7D6A5A14  add r11, r10, r11
	ctx.r[11].u64 = ctx.r[10].u64 + ctx.r[11].u64;
	pc = 0x821A1A88; continue 'dispatch;
            }
            0x821A1A88 => {
    //   block [0x821A1A88..0x821A1A98)
	// 821A1A88: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1A8C: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A1A90: 409A0008  bne cr6, 0x821a1a98
	if !ctx.cr[6].eq {
	pc = 0x821A1A98; continue 'dispatch;
	}
	// 821A1A94: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821A1A98; continue 'dispatch;
            }
            0x821A1A98 => {
    //   block [0x821A1A98..0x821A1AB8)
	// 821A1A98: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1A9C: 2F0B0002  cmpwi cr6, r11, 2
	ctx.cr[6].compare_i32(ctx.r[11].s32, 2, &mut ctx.xer);
	// 821A1AA0: 409A0018  bne cr6, 0x821a1ab8
	if !ctx.cr[6].eq {
	pc = 0x821A1AB8; continue 'dispatch;
	}
	// 821A1AA4: 817F008C  lwz r11, 0x8c(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(140 as u32) ) } as u64;
	// 821A1AA8: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AAC: 419A0050  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AB0: 813F0088  lwz r9, 0x88(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(136 as u32) ) } as u64;
	// 821A1AB4: 48000014  b 0x821a1ac8
	pc = 0x821A1AC8; continue 'dispatch;
            }
            0x821A1AB8 => {
    //   block [0x821A1AB8..0x821A1AC8)
	// 821A1AB8: 817F0084  lwz r11, 0x84(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(132 as u32) ) } as u64;
	// 821A1ABC: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AC0: 419A003C  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AC4: 813F0080  lwz r9, 0x80(r31)
	ctx.r[9].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(128 as u32) ) } as u64;
	pc = 0x821A1AC8; continue 'dispatch;
            }
            0x821A1AC8 => {
    //   block [0x821A1AC8..0x821A1AFC)
	// 821A1AC8: 814B0030  lwz r10, 0x30(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(48 as u32) ) } as u64;
	// 821A1ACC: 7F0A4840  cmplw cr6, r10, r9
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[9].u32, &mut ctx.xer);
	// 821A1AD0: 409A002C  bne cr6, 0x821a1afc
	if !ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AD4: 388B0080  addi r4, r11, 0x80
	ctx.r[4].s64 = ctx.r[11].s64 + 128;
	// 821A1AD8: 2B040000  cmplwi cr6, r4, 0
	ctx.cr[6].compare_u32(ctx.r[4].u32, 0 as u32, &mut ctx.xer);
	// 821A1ADC: 419A0020  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AE0: 817F0098  lwz r11, 0x98(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(152 as u32) ) } as u64;
	// 821A1AE4: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1AE8: 419A0014  beq cr6, 0x821a1afc
	if ctx.cr[6].eq {
	pc = 0x821A1AFC; continue 'dispatch;
	}
	// 821A1AEC: 3D60830F  lis r11, -0x7cf1
	ctx.r[11].s64 = -2096168960;
	// 821A1AF0: 80BF00A0  lwz r5, 0xa0(r31)
	ctx.r[5].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(160 as u32) ) } as u64;
	// 821A1AF4: 386B4A00  addi r3, r11, 0x4a00
	ctx.r[3].s64 = ctx.r[11].s64 + 18944;
	// 821A1AF8: 481DC929  bl 0x8237e420
	ctx.lr = 0x821A1AFC;
	sub_8237E420(ctx, base);
	pc = 0x821A1AFC; continue 'dispatch;
            }
            0x821A1AFC => {
    //   block [0x821A1AFC..0x821A1B18)
	// 821A1AFC: 817F0090  lwz r11, 0x90(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(144 as u32) ) } as u64;
	// 821A1B00: 2F0B0005  cmpwi cr6, r11, 5
	ctx.cr[6].compare_i32(ctx.r[11].s32, 5, &mut ctx.xer);
	// 821A1B04: 409A0014  bne cr6, 0x821a1b18
	if !ctx.cr[6].eq {
	pc = 0x821A1B18; continue 'dispatch;
	}
	// 821A1B08: 3D6082C0  lis r11, -0x7d40
	ctx.r[11].s64 = -2101346304;
	// 821A1B0C: 814BB9E4  lwz r10, -0x461c(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(-17948 as u32) ) } as u64;
	// 821A1B10: 394AFFFF  addi r10, r10, -1
	ctx.r[10].s64 = ctx.r[10].s64 + -1;
	// 821A1B14: 914BB9E4  stw r10, -0x461c(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(-17948 as u32), ctx.r[10].u32 ) };
	pc = 0x821A1B18; continue 'dispatch;
            }
            0x821A1B18 => {
    //   block [0x821A1B18..0x821A1B34)
	// 821A1B18: 817F00D4  lwz r11, 0xd4(r31)
	ctx.r[11].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[31].u32.wrapping_add(212 as u32) ) } as u64;
	// 821A1B1C: 2B0B0000  cmplwi cr6, r11, 0
	ctx.cr[6].compare_u32(ctx.r[11].u32, 0 as u32, &mut ctx.xer);
	// 821A1B20: 419A0014  beq cr6, 0x821a1b34
	if ctx.cr[6].eq {
	pc = 0x821A1B34; continue 'dispatch;
	}
	// 821A1B24: 814B0000  lwz r10, 0(r11)
	ctx.r[10].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[11].u32.wrapping_add(0 as u32) ) } as u64;
	// 821A1B28: 7F0AF840  cmplw cr6, r10, r31
	ctx.cr[6].compare_u32(ctx.r[10].u32, ctx.r[31].u32, &mut ctx.xer);
	// 821A1B2C: 409A0008  bne cr6, 0x821a1b34
	if !ctx.cr[6].eq {
	pc = 0x821A1B34; continue 'dispatch;
	}
	// 821A1B30: 93CB0000  stw r30, 0(r11)
	unsafe { crate::rt::store_u32( base as *mut u8, ctx.r[11].u32.wrapping_add(0 as u32), ctx.r[30].u32 ) };
	pc = 0x821A1B34; continue 'dispatch;
            }
            0x821A1B34 => {
    //   block [0x821A1B34..0x821A1B4C)
	// 821A1B34: 38210070  addi r1, r1, 0x70
	ctx.r[1].s64 = ctx.r[1].s64 + 112;
	// 821A1B38: 8181FFF8  lwz r12, -8(r1)
	ctx.r[12].u64 = unsafe { crate::rt::load_u32( base as *const u8, ctx.r[1].u32.wrapping_add(-8 as u32) ) } as u64;
	// 821A1B3C: 7D8803A6  mtlr r12
	ctx.lr = ctx.r[12].u64;
	// 821A1B40: EBC1FFE8  ld r30, -0x18(r1)
	ctx.r[30].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-24 as u32) ) };
	// 821A1B44: EBE1FFF0  ld r31, -0x10(r1)
	ctx.r[31].u64 = unsafe { crate::rt::load_u64( base as *const u8, ctx.r[1].u32.wrapping_add(-16 as u32) ) };
	// 821A1B48: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


pub fn sub_821A1B50(ctx: &mut crate::recompiler::ppc_context::PPCContext, base: *mut u8) {
    // ---- function 0x821A1B50 size=20
    let mut pc: u32 = 0x821A1B50;
    'dispatch: loop {
        match pc {
            0x821A1B50 => {
    //   block [0x821A1B50..0x821A1B64)
	// 821A1B50: 7C6B1B78  mr r11, r3
	ctx.r[11].u64 = ctx.r[3].u64;
	// 821A1B54: 7C832378  mr r3, r4
	ctx.r[3].u64 = ctx.r[4].u64;
	// 821A1B58: 2B030000  cmplwi cr6, r3, 0
	ctx.cr[6].compare_u32(ctx.r[3].u32, 0 as u32, &mut ctx.xer);
	// 821A1B5C: 409A0008  bne cr6, 0x821a1b64
	if !ctx.cr[6].eq {
		sub_821A1B64(ctx, base);
		return;
	}
	// 821A1B60: 4E800020  blr
	return;
            }
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}


